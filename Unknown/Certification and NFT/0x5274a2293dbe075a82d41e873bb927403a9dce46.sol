['pragma solidity ^0.4.11;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EthCapsule is Ownable {\n', '  struct Depositor {\n', '    uint numCapsules;\n', '    mapping (uint => Capsule) capsules;\n', '  }\n', '\n', '  mapping (address => Depositor) depositors;\n', '\n', '  struct Capsule {\n', '    uint value;\n', '    uint id;\n', '    uint lockTime;\n', '    uint unlockTime;\n', '    uint withdrawnTime;\n', '  }\n', '\n', '  uint public minDeposit = 1000000000000000;\n', '  uint public minDuration = 0;\n', '  uint public maxDuration = 157680000;\n', '  uint public totalCapsules;\n', '  uint public totalValue;\n', '  uint public totalBuriedCapsules;\n', '\n', '  function bury(uint unlockTime) payable {\n', '    require(msg.value >= minDeposit);\n', '    require(unlockTime <= block.timestamp + maxDuration);\n', '\n', '    if (unlockTime < block.timestamp + minDuration) {\n', '      unlockTime = SafeMath.add(block.timestamp, minDuration);\n', '    }\n', '\n', '    if (depositors[msg.sender].numCapsules <= 0) {\n', '        depositors[msg.sender] = Depositor({ numCapsules: 0 });\n', '    }\n', '\n', '    Depositor storage depositor = depositors[msg.sender];\n', '\n', '    depositor.numCapsules++;\n', '    depositor.capsules[depositor.numCapsules] = Capsule({\n', '        value: msg.value,\n', '        id: depositors[msg.sender].numCapsules,\n', '        lockTime: block.timestamp,\n', '        unlockTime: unlockTime,\n', '        withdrawnTime: 0\n', '    });\n', '\n', '    totalBuriedCapsules++;\n', '    totalCapsules++;\n', '    totalValue = SafeMath.add(totalValue, msg.value);\n', '  }\n', '\n', '  function dig(uint capsuleNumber) {\n', '    Capsule storage capsule = depositors[msg.sender].capsules[capsuleNumber];\n', '\n', '    require(capsule.unlockTime <= block.timestamp);\n', '    require(capsule.withdrawnTime == 0);\n', '\n', '    totalBuriedCapsules--;\n', '    capsule.withdrawnTime = block.timestamp;\n', '    msg.sender.transfer(capsule.value);\n', '  }\n', '\n', '  function setMinDeposit(uint min) onlyOwner {\n', '    minDeposit = min;\n', '  }\n', '\n', '  function setMinDuration(uint min) onlyOwner {\n', '    minDuration = min;\n', '  }\n', '\n', '  function setMaxDuration(uint max) onlyOwner {\n', '    maxDuration = max;\n', '  }\n', '  \n', '  function getCapsuleInfo(uint capsuleNum) constant returns (uint, uint, uint, uint, uint) {\n', '    return (\n', '        depositors[msg.sender].capsules[capsuleNum].value,\n', '        depositors[msg.sender].capsules[capsuleNum].id,\n', '        depositors[msg.sender].capsules[capsuleNum].lockTime,\n', '        depositors[msg.sender].capsules[capsuleNum].unlockTime,\n', '        depositors[msg.sender].capsules[capsuleNum].withdrawnTime\n', '    );\n', '  }\n', '\n', '  function getNumberOfCapsules() constant returns (uint) {\n', '    return depositors[msg.sender].numCapsules;\n', '  }\n', '\n', '  function totalBuriedValue() constant returns (uint) {\n', '    return this.balance;\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract EthCapsule is Ownable {\n', '  struct Depositor {\n', '    uint numCapsules;\n', '    mapping (uint => Capsule) capsules;\n', '  }\n', '\n', '  mapping (address => Depositor) depositors;\n', '\n', '  struct Capsule {\n', '    uint value;\n', '    uint id;\n', '    uint lockTime;\n', '    uint unlockTime;\n', '    uint withdrawnTime;\n', '  }\n', '\n', '  uint public minDeposit = 1000000000000000;\n', '  uint public minDuration = 0;\n', '  uint public maxDuration = 157680000;\n', '  uint public totalCapsules;\n', '  uint public totalValue;\n', '  uint public totalBuriedCapsules;\n', '\n', '  function bury(uint unlockTime) payable {\n', '    require(msg.value >= minDeposit);\n', '    require(unlockTime <= block.timestamp + maxDuration);\n', '\n', '    if (unlockTime < block.timestamp + minDuration) {\n', '      unlockTime = SafeMath.add(block.timestamp, minDuration);\n', '    }\n', '\n', '    if (depositors[msg.sender].numCapsules <= 0) {\n', '        depositors[msg.sender] = Depositor({ numCapsules: 0 });\n', '    }\n', '\n', '    Depositor storage depositor = depositors[msg.sender];\n', '\n', '    depositor.numCapsules++;\n', '    depositor.capsules[depositor.numCapsules] = Capsule({\n', '        value: msg.value,\n', '        id: depositors[msg.sender].numCapsules,\n', '        lockTime: block.timestamp,\n', '        unlockTime: unlockTime,\n', '        withdrawnTime: 0\n', '    });\n', '\n', '    totalBuriedCapsules++;\n', '    totalCapsules++;\n', '    totalValue = SafeMath.add(totalValue, msg.value);\n', '  }\n', '\n', '  function dig(uint capsuleNumber) {\n', '    Capsule storage capsule = depositors[msg.sender].capsules[capsuleNumber];\n', '\n', '    require(capsule.unlockTime <= block.timestamp);\n', '    require(capsule.withdrawnTime == 0);\n', '\n', '    totalBuriedCapsules--;\n', '    capsule.withdrawnTime = block.timestamp;\n', '    msg.sender.transfer(capsule.value);\n', '  }\n', '\n', '  function setMinDeposit(uint min) onlyOwner {\n', '    minDeposit = min;\n', '  }\n', '\n', '  function setMinDuration(uint min) onlyOwner {\n', '    minDuration = min;\n', '  }\n', '\n', '  function setMaxDuration(uint max) onlyOwner {\n', '    maxDuration = max;\n', '  }\n', '  \n', '  function getCapsuleInfo(uint capsuleNum) constant returns (uint, uint, uint, uint, uint) {\n', '    return (\n', '        depositors[msg.sender].capsules[capsuleNum].value,\n', '        depositors[msg.sender].capsules[capsuleNum].id,\n', '        depositors[msg.sender].capsules[capsuleNum].lockTime,\n', '        depositors[msg.sender].capsules[capsuleNum].unlockTime,\n', '        depositors[msg.sender].capsules[capsuleNum].withdrawnTime\n', '    );\n', '  }\n', '\n', '  function getNumberOfCapsules() constant returns (uint) {\n', '    return depositors[msg.sender].numCapsules;\n', '  }\n', '\n', '  function totalBuriedValue() constant returns (uint) {\n', '    return this.balance;\n', '  }\n', '}']
