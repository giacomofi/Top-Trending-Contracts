['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Overflow protected math functions\n', '*/\n', 'contract SafeMath {\n', '    /**\n', '        constructor\n', '    */\n', '    function SafeMath() {\n', '    }\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Open issues:\n', '    - The formula is not yet super accurate, especially for very small/very high ratios\n', '    - Improve dynamic precision support\n', '*/\n', '\n', 'contract BancorFormula is SafeMath {\n', '\n', '    uint256 constant ONE = 1;\n', '    uint256 constant TWO = 2;\n', '    uint256 constant MAX_FIXED_EXP_32 = 0x386bfdba29;\n', '    string public version = &#39;0.2&#39;;\n', '\n', '    function BancorFormula() {\n', '    }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\n', '\n', '        Formula:\n', '        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\n', '\n', '        // special case for 0 deposit amount\n', '        if (_depositAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\n', '        uint256 temp;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp = safeMul(_supply, baseN) / _reserveBalance;\n', '            return safeSub(temp, _supply); \n', '        }\n', '\n', '        uint8 precision = calculateBestPrecision(baseN, _reserveBalance, _reserveRatio, 100);\n', '        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100, precision);\n', '        temp = safeMul(_supply, resN) >> precision;\n', '        return safeSub(temp, _supply);\n', '     }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\n', '\n', '        Formula:\n', '        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\n', '\n', '        // special case for 0 sell amount\n', '        if (_sellAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseD = safeSub(_supply, _sellAmount);\n', '        uint256 temp1;\n', '        uint256 temp2;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp1 = safeMul(_reserveBalance, _supply);\n', '            temp2 = safeMul(_reserveBalance, baseD);\n', '            return safeSub(temp1, temp2) / _supply;\n', '        }\n', '\n', '        // special case for selling the entire supply\n', '        if (_sellAmount == _supply)\n', '            return _reserveBalance;\n', '\n', '        uint8 precision = calculateBestPrecision(_supply, baseD, 100, _reserveRatio);\n', '        uint256 resN = power(_supply, baseD, 100, _reserveRatio, precision);\n', '        temp1 = safeMul(_reserveBalance, resN);\n', '        temp2 = safeMul(_reserveBalance, ONE << precision);\n', '        return safeSub(temp1, temp2) / resN;\n', '    }\n', '\n', '    /**\n', '        calculateBestPrecision \n', '        Predicts the highest precision which can be used in order to compute "base^exp" without exceeding 256 bits in any of the intermediate computations.\n', '        Instead of calculating "base ^ exp", we calculate "e ^ (ln(base) * exp)".\n', '        The value of ln(base) is represented with an integer slightly smaller than ln(base) * 2 ^ precision.\n', '        The larger the precision is, the more accurately this value represents the real value.\n', '        However, function fixedExpUnsafe(x), which calculates e ^ x, is limited to a maximum value of x.\n', '        The limit depends on the precision (e.g, for precision = 32, the maximum value of x is MAX_FIXED_EXP_32).\n', '        Hence before calling the &#39;power&#39; function, we need to estimate an upper-bound for ln(base) * exponent.\n', '        Of course, we should later assert that the value passed to fixedExpUnsafe is not larger than MAX_FIXED_EXP(precision).\n', '        Due to this assertion (made in function fixedExp), functions calculateBestPrecision and fixedExp are tightly coupled.\n', '        Note that the outcome of this function only affects the accuracy of the computation of "base ^ exp".\n', '        Therefore, we do not need to assert that no intermediate result exceeds 256 bits (nor in this function, neither in any of the functions down the calling tree).\n', '    */\n', '    function calculateBestPrecision(uint256 _baseN, uint256 _baseD, uint256 _expN, uint256 _expD) constant returns (uint8) {\n', '        uint8 precision;\n', '        uint256 maxExp = MAX_FIXED_EXP_32;\n', '        uint256 maxVal = lnUpperBound32(_baseN,_baseD) * _expN;\n', '        for (precision = 0; precision < 32; precision += 2) {\n', '            if (maxExp < (maxVal << precision) / _expD)\n', '                break;\n', '            maxExp = (maxExp * 0xeb5ec5975959c565) >> (64-2);\n', '        }\n', '        if (precision == 0)\n', '            return 32;\n', '        return precision+32-2;\n', '    }\n', '\n', '    /**\n', '        @dev calculates (_baseN / _baseD) ^ (_expN / _expD)\n', '        Returns result upshifted by precision\n', '\n', '        This method is overflow-safe\n', '    */ \n', '    function power(uint256 _baseN, uint256 _baseD, uint256 _expN, uint256 _expD, uint8 _precision) constant returns (uint256) {\n', '        uint256 logbase = ln(_baseN, _baseD, _precision);\n', '        // Not using safeDiv here, since safeDiv protects against\n', '        // precision loss. It&#39;s unavoidable, however\n', '        // Both `ln` and `fixedExp` are overflow-safe. \n', '        return fixedExp(safeMul(logbase, _expN) / _expD, _precision);\n', '    }\n', '    \n', '    /**\n', '        input range: \n', '            - numerator: [1, uint256_max >> precision]    \n', '            - denominator: [1, uint256_max >> precision]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '    */\n', '    function ln(uint256 _numerator, uint256 _denominator, uint8 _precision) public constant returns (uint256) {\n', '        // denominator > numerator: less than one yields negative values. Unsupported\n', '        assert(_denominator <= _numerator);\n', '\n', '        // log(1) is the lowest we can go\n', '        assert(_denominator != 0 && _numerator != 0);\n', '\n', '        // Upper bits are scaled off by precision\n', '        uint256 MAX_VAL = ONE << (256 - _precision);\n', '        assert(_numerator < MAX_VAL);\n', '        assert(_denominator < MAX_VAL);\n', '\n', '        return fixedLoge( (_numerator << _precision) / _denominator, _precision);\n', '    }\n', '\n', '    /**\n', '        lnUpperBound32 \n', '        Takes a rational number "baseN / baseD" as input.\n', '        Returns an integer upper-bound of the natural logarithm of the input scaled by 2^32.\n', '        We do this by calculating "UpperBound(log2(baseN / baseD)) * Ceiling(ln(2) * 2^32)".\n', '        We calculate "UpperBound(log2(baseN / baseD))" as "Floor(log2((_baseN - 1) / _baseD)) + 1".\n', '        For small values of "baseN / baseD", this sometimes yields a bad upper-bound approximation.\n', '        We therefore cover these cases (and a few more) manually.\n', '        Complexity is O(log(input bit-length)).\n', '    */\n', '    function lnUpperBound32(uint256 _baseN, uint256 _baseD) constant returns (uint256) {\n', '        assert(_baseN > _baseD);\n', '\n', '        uint256 scaledBaseN = _baseN * 100000;\n', '        if (scaledBaseN <= _baseD *  271828) // _baseN / _baseD < e^1 (floorLog2 will return 0 if _baseN / _baseD < 2)\n', '            return uint256(1) << 32;\n', '        if (scaledBaseN <= _baseD *  738905) // _baseN / _baseD < e^2 (floorLog2 will return 1 if _baseN / _baseD < 4)\n', '            return uint256(2) << 32;\n', '        if (scaledBaseN <= _baseD * 2008553) // _baseN / _baseD < e^3 (floorLog2 will return 2 if _baseN / _baseD < 8)\n', '            return uint256(3) << 32;\n', '\n', '        return (floorLog2((_baseN - 1) / _baseD) + 1) * 0xb17217f8;\n', '    }\n', '\n', '    /**\n', '        input range: \n', '            [0x100000000, uint256_max]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '        Since `fixedLog2_min` output range is max `0xdfffffffff` \n', '        (40 bits, or 5 bytes), we can use a very large approximation\n', '        for `ln(2)`. This one is used since it&#39;s the max accuracy \n', '        of Python `ln(2)`\n', '\n', '        0xb17217f7d1cf78 = ln(2) * (1 << 56)\n', '    */\n', '    function fixedLoge(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        // cannot represent negative numbers (below 1)\n', '        assert(_x >= ONE << _precision);\n', '\n', '        uint256 flog2 = fixedLog2(_x, _precision);\n', '        return (flog2 * 0xb17217f7d1cf78) >> 56;\n', '    }\n', '\n', '    /**\n', '        Returns log2(x >> 32) << 32 [1]\n', '        So x is assumed to be already upshifted 32 bits, and \n', '        the result is also upshifted 32 bits. \n', '        \n', '        [1] The function returns a number which is lower than the \n', '        actual value\n', '\n', '        input-range : \n', '            [0x100000000, uint256_max]\n', '        output-range: \n', '            [0,0xdfffffffff]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLog2(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 fixedOne = ONE << _precision;\n', '        uint256 fixedTwo = TWO << _precision;\n', '\n', '        // Numbers below 1 are negative. \n', '        assert( _x >= fixedOne);\n', '\n', '        uint256 hi = 0;\n', '        while (_x >= fixedTwo) {\n', '            _x >>= 1;\n', '            hi += fixedOne;\n', '        }\n', '\n', '        for (uint8 i = 0; i < _precision; ++i) {\n', '            _x = (_x * _x) / fixedOne;\n', '            if (_x >= fixedTwo) {\n', '                _x >>= 1;\n', '                hi += ONE << (_precision - 1 - i);\n', '            }\n', '        }\n', '\n', '        return hi;\n', '    }\n', '\n', '    /**\n', '        floorLog2\n', '        Takes a natural number (n) as input.\n', '        Returns the largest integer smaller than or equal to the binary logarithm of the input.\n', '        Complexity is O(log(input bit-length)).\n', '    */\n', '    function floorLog2(uint256 _n) constant returns (uint256) {\n', '        uint8 t = 0;\n', '        for (uint8 s = 128; s > 0; s >>= 1) {\n', '            if (_n >= (ONE << s)) {\n', '                _n >>= s;\n', '                t |= s;\n', '            }\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '    /**\n', '        fixedExp is a &#39;protected&#39; version of `fixedExpUnsafe`, which asserts instead of overflows.\n', '        The maximum value which can be passed to fixedExpUnsafe depends on the precision used.\n', '        The following array maps each precision between 0 and 63 to the maximum value permitted:\n', '        maxExpArray = {\n', '            0xc1               ,0x17a              ,0x2e5              ,0x5ab              ,\n', '            0xb1b              ,0x15bf             ,0x2a0c             ,0x50a2             ,\n', '            0x9aa2             ,0x1288c            ,0x238b2            ,0x4429a            ,\n', '            0x82b78            ,0xfaadc            ,0x1e0bb8           ,0x399e96           ,\n', '            0x6e7f88           ,0xd3e7a3           ,0x1965fea          ,0x30b5057          ,\n', '            0x5d681f3          ,0xb320d03          ,0x15784a40         ,0x292c5bdd         ,\n', '            0x4ef57b9b         ,0x976bd995         ,0x122624e32        ,0x22ce03cd5        ,\n', '            0x42beef808        ,0x7ffffffff        ,0xf577eded5        ,0x1d6bd8b2eb       ,\n', '            0x386bfdba29       ,0x6c3390ecc8       ,0xcf8014760f       ,0x18ded91f0e7      ,\n', '            0x2fb1d8fe082      ,0x5b771955b36      ,0xaf67a93bb50      ,0x15060c256cb2     ,\n', '            0x285145f31ae5     ,0x4d5156639708     ,0x944620b0e70e     ,0x11c592761c666    ,\n', '            0x2214d10d014ea    ,0x415bc6d6fb7dd    ,0x7d56e76777fc5    ,0xf05dc6b27edad    ,\n', '            0x1ccf4b44bb4820   ,0x373fc456c53bb7   ,0x69f3d1c921891c   ,0xcb2ff529eb71e4   ,\n', '            0x185a82b87b72e95  ,0x2eb40f9f620fda6  ,0x5990681d961a1ea  ,0xabc25204e02828d  ,\n', '            0x14962dee9dc97640 ,0x277abdcdab07d5a7 ,0x4bb5ecca963d54ab ,0x9131271922eaa606 ,\n', '            0x116701e6ab0cd188d,0x215f77c045fbe8856,0x3ffffffffffffffff,0x7abbf6f6abb9d087f,\n', '        };\n', '        Since we cannot use an array of constants, we need to approximate the maximum value dynamically.\n', '        For a precision of 32, the maximum value permitted is MAX_FIXED_EXP_32.\n', '        For each additional precision unit, the maximum value permitted increases by approximately 1.9.\n', '        So in order to calculate it, we need to multiply MAX_FIXED_EXP_32 by 1.9 for every additional precision unit.\n', '        And in order to optimize for speed, we multiply MAX_FIXED_EXP_32 by 1.9^2 for every 2 additional precision units.\n', '        Hence the general function for mapping a given precision to the maximum value permitted is:\n', '        - precision = [32, 34, 36, ..., 62]\n', '        - MaxFixedExp(precision) = MAX_FIXED_EXP_32 * 3.61 ^ (precision / 2 - 16)\n', '        Since we cannot use non-integers, we do MAX_FIXED_EXP_32 * 361 ^ (precision / 2 - 16) / 100 ^ (precision / 2 - 16).\n', '        But there is a better approximation, because this "1.9" factor in fact extends beyond a single decimal digit.\n', '        So instead, we use 0xeb5ec5975959c565 / 0x4000000000000000, which yields maximum values quite close to real ones:\n', '        maxExpArray = {\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            0x386bfdba29       ,-------------------,0xcf8014760e       ,-------------------,\n', '            0x2fb1d8fe07b      ,-------------------,0xaf67a93bb37      ,-------------------,\n', '            0x285145f31a8f     ,-------------------,0x944620b0e5ee     ,-------------------,\n', '            0x2214d10d0112e    ,-------------------,0x7d56e7677738e    ,-------------------,\n', '            0x1ccf4b44bb20d0   ,-------------------,0x69f3d1c9210d27   ,-------------------,\n', '            0x185a82b87b5b294  ,-------------------,0x5990681d95d4371  ,-------------------,\n', '            0x14962dee9dbd672b ,-------------------,0x4bb5ecca961fb9bf ,-------------------,\n', '            0x116701e6ab0967080,-------------------,0x3fffffffffffe6652,-------------------,\n', '        };\n', '    */\n', '    function fixedExp(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 maxExp = MAX_FIXED_EXP_32;\n', '        for (uint8 p = 32; p < _precision; p += 2)\n', '            maxExp = (maxExp * 0xeb5ec5975959c565) >> (64-2);\n', '        \n', '        assert(_x <= maxExp);\n', '        return fixedExpUnsafe(_x, _precision);\n', '    }\n', '\n', '    /**\n', '        fixedExp \n', '        Calculates e ^ x according to maclauren summation:\n', '\n', '        e^x = 1 + x + x ^ 2 / 2!...+ x ^ n / n!\n', '\n', '        and returns e ^ (x >> 32) << 32, that is, upshifted for accuracy\n', '\n', '        Input range:\n', '            - Function ok at    <= 242329958953 \n', '            - Function fails at >= 242329958954\n', '\n', '        This method is is visible for testcases, but not meant for direct use. \n', ' \n', '        The values in this method been generated via the following python snippet: \n', '\n', '        def calculateFactorials():\n', '            """Method to print out the factorials for fixedExp"""\n', '\n', '            ni = []\n', '            ni.append(295232799039604140847618609643520000000) # 34!\n', '            ITERATIONS = 34\n', '            for n in range(1, ITERATIONS, 1) :\n', '                ni.append(math.floor(ni[n - 1] / n))\n', '            print( "\\n        ".join(["xi = (xi * _x) >> _precision;\\n        res += xi * %s;" % hex(int(x)) for x in ni]))\n', '\n', '    */\n', '    function fixedExpUnsafe(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 xi = _x;\n', '        uint256 res = uint256(0xde1bc4d19efcac82445da75b00000000) << _precision;\n', '\n', '        res += xi * 0xde1bc4d19efcac82445da75b00000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x6f0de268cf7e5641222ed3ad80000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x2504a0cd9a7f7215b60f9be480000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9412833669fdc856d83e6f920000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1d9d4d714865f4de2b3fafea0000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x4ef8ce836bba8cfb1dff2a70000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xb481d807d1aa66d04490610000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x16903b00fa354cda08920c2000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x281cdaac677b334ab9e732000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x402e2aad725eb8778fd85000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x5d5a6c9f31fe2396a2af000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x7c7890d442a82f73839400000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9931ed54034526b58e400000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xaf147cf24ce150cf7e00000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xbac08546b867cdaa200000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xbac08546b867cdaa20000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xafc441338061b2820000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9c3cabbc0056d790000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x839168328705c30000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x694120286c049c000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x50319e98b3d2c000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x3a52a1e36b82000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x289286e0fce000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1b0c59eb53400;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x114f95b55400;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xaa7210d200;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x650139600;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x39b78e80;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1fd8080;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x10fbc0;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x8c40;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x462;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x22;\n', '\n', '        return res / 0xde1bc4d19efcac82445da75b00000000;\n', '    }\n', '}\n', '\n', '\n', 'contract BasicERC20Token {\n', '    /* Public variables of the token */\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;Ivan\\&#39;s Trackable Token&#39;;\n', '    string public symbol = &#39;ITT&#39;;\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply = 0;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event BalanceCheck(uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* Functions below are specific to this token and\n', '     * not part of the ERC-20 standard */\n', '\n', '    function deposit() payable returns (bool success) {\n', '        if (msg.value == 0) return false;\n', '        balances[msg.sender] += msg.value;\n', '        totalSupply += msg.value;\n', '        return true;\n', '    }\n', '\n', '    function withdraw(uint256 amount) returns (bool success) {\n', '        if (balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        if (!msg.sender.send(amount)) {\n', '            balances[msg.sender] += amount;\n', '            totalSupply += amount;\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract DummyBancorToken is BasicERC20Token, BancorFormula {\n', '\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;Dummy Constant Reserve Rate Token&#39;;\n', '    string public symbol = &#39;DBT&#39;;\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply = 0;\n', '\n', '    uint8 public ratio = 10; // CRR of 10%\n', '\n', '    address public owner = 0x0;\n', '\n', '    event Deposit(address indexed sender);\n', '    event Withdraw(uint256 amount);\n', '\n', '    /* I can&#39;t make MyEtherWallet send payments as part of constructor calls\n', '     * while creating contracts. So instead of implementing a constructor,\n', '     * we follow the SetUp/TearDown paradigm */\n', '    function setUp(uint256 _initialSupply) payable {\n', '        if (owner != 0) return;\n', '        owner = msg.sender;\n', '        balances[msg.sender] = _initialSupply;\n', '        totalSupply = _initialSupply;\n', '    }\n', '\n', '    function tearDown() {\n', '        if (msg.sender != owner) return;\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function reserveBalance() constant returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    // Our reserve token is always ETH.\n', '    function deposit() payable returns (bool success) {\n', '        if (msg.value == 0) return false;\n', '        uint256 tokensPurchased = calculatePurchaseReturn(totalSupply, reserveBalance(), ratio, msg.value);\n', '        balances[msg.sender] += tokensPurchased;\n', '        totalSupply += tokensPurchased;\n', '        Deposit(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function withdraw(uint256 amount) returns (bool success) {\n', '        if (balances[msg.sender] < amount) return false;\n', '        uint256 ethAmount = calculateSaleReturn(totalSupply, reserveBalance(), ratio, amount);\n', '        balances[msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        if (!msg.sender.send(ethAmount)) {\n', '            balances[msg.sender] += amount;\n', '            totalSupply += amount;\n', '            return false;\n', '        }\n', '        Withdraw(amount);\n', '        return true;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Overflow protected math functions\n', '*/\n', 'contract SafeMath {\n', '    /**\n', '        constructor\n', '    */\n', '    function SafeMath() {\n', '    }\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Open issues:\n', '    - The formula is not yet super accurate, especially for very small/very high ratios\n', '    - Improve dynamic precision support\n', '*/\n', '\n', 'contract BancorFormula is SafeMath {\n', '\n', '    uint256 constant ONE = 1;\n', '    uint256 constant TWO = 2;\n', '    uint256 constant MAX_FIXED_EXP_32 = 0x386bfdba29;\n', "    string public version = '0.2';\n", '\n', '    function BancorFormula() {\n', '    }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\n', '\n', '        Formula:\n', '        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\n', '\n', '        // special case for 0 deposit amount\n', '        if (_depositAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\n', '        uint256 temp;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp = safeMul(_supply, baseN) / _reserveBalance;\n', '            return safeSub(temp, _supply); \n', '        }\n', '\n', '        uint8 precision = calculateBestPrecision(baseN, _reserveBalance, _reserveRatio, 100);\n', '        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100, precision);\n', '        temp = safeMul(_supply, resN) >> precision;\n', '        return safeSub(temp, _supply);\n', '     }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\n', '\n', '        Formula:\n', '        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\n', '\n', '        // special case for 0 sell amount\n', '        if (_sellAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseD = safeSub(_supply, _sellAmount);\n', '        uint256 temp1;\n', '        uint256 temp2;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp1 = safeMul(_reserveBalance, _supply);\n', '            temp2 = safeMul(_reserveBalance, baseD);\n', '            return safeSub(temp1, temp2) / _supply;\n', '        }\n', '\n', '        // special case for selling the entire supply\n', '        if (_sellAmount == _supply)\n', '            return _reserveBalance;\n', '\n', '        uint8 precision = calculateBestPrecision(_supply, baseD, 100, _reserveRatio);\n', '        uint256 resN = power(_supply, baseD, 100, _reserveRatio, precision);\n', '        temp1 = safeMul(_reserveBalance, resN);\n', '        temp2 = safeMul(_reserveBalance, ONE << precision);\n', '        return safeSub(temp1, temp2) / resN;\n', '    }\n', '\n', '    /**\n', '        calculateBestPrecision \n', '        Predicts the highest precision which can be used in order to compute "base^exp" without exceeding 256 bits in any of the intermediate computations.\n', '        Instead of calculating "base ^ exp", we calculate "e ^ (ln(base) * exp)".\n', '        The value of ln(base) is represented with an integer slightly smaller than ln(base) * 2 ^ precision.\n', '        The larger the precision is, the more accurately this value represents the real value.\n', '        However, function fixedExpUnsafe(x), which calculates e ^ x, is limited to a maximum value of x.\n', '        The limit depends on the precision (e.g, for precision = 32, the maximum value of x is MAX_FIXED_EXP_32).\n', "        Hence before calling the 'power' function, we need to estimate an upper-bound for ln(base) * exponent.\n", '        Of course, we should later assert that the value passed to fixedExpUnsafe is not larger than MAX_FIXED_EXP(precision).\n', '        Due to this assertion (made in function fixedExp), functions calculateBestPrecision and fixedExp are tightly coupled.\n', '        Note that the outcome of this function only affects the accuracy of the computation of "base ^ exp".\n', '        Therefore, we do not need to assert that no intermediate result exceeds 256 bits (nor in this function, neither in any of the functions down the calling tree).\n', '    */\n', '    function calculateBestPrecision(uint256 _baseN, uint256 _baseD, uint256 _expN, uint256 _expD) constant returns (uint8) {\n', '        uint8 precision;\n', '        uint256 maxExp = MAX_FIXED_EXP_32;\n', '        uint256 maxVal = lnUpperBound32(_baseN,_baseD) * _expN;\n', '        for (precision = 0; precision < 32; precision += 2) {\n', '            if (maxExp < (maxVal << precision) / _expD)\n', '                break;\n', '            maxExp = (maxExp * 0xeb5ec5975959c565) >> (64-2);\n', '        }\n', '        if (precision == 0)\n', '            return 32;\n', '        return precision+32-2;\n', '    }\n', '\n', '    /**\n', '        @dev calculates (_baseN / _baseD) ^ (_expN / _expD)\n', '        Returns result upshifted by precision\n', '\n', '        This method is overflow-safe\n', '    */ \n', '    function power(uint256 _baseN, uint256 _baseD, uint256 _expN, uint256 _expD, uint8 _precision) constant returns (uint256) {\n', '        uint256 logbase = ln(_baseN, _baseD, _precision);\n', '        // Not using safeDiv here, since safeDiv protects against\n', "        // precision loss. It's unavoidable, however\n", '        // Both `ln` and `fixedExp` are overflow-safe. \n', '        return fixedExp(safeMul(logbase, _expN) / _expD, _precision);\n', '    }\n', '    \n', '    /**\n', '        input range: \n', '            - numerator: [1, uint256_max >> precision]    \n', '            - denominator: [1, uint256_max >> precision]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '    */\n', '    function ln(uint256 _numerator, uint256 _denominator, uint8 _precision) public constant returns (uint256) {\n', '        // denominator > numerator: less than one yields negative values. Unsupported\n', '        assert(_denominator <= _numerator);\n', '\n', '        // log(1) is the lowest we can go\n', '        assert(_denominator != 0 && _numerator != 0);\n', '\n', '        // Upper bits are scaled off by precision\n', '        uint256 MAX_VAL = ONE << (256 - _precision);\n', '        assert(_numerator < MAX_VAL);\n', '        assert(_denominator < MAX_VAL);\n', '\n', '        return fixedLoge( (_numerator << _precision) / _denominator, _precision);\n', '    }\n', '\n', '    /**\n', '        lnUpperBound32 \n', '        Takes a rational number "baseN / baseD" as input.\n', '        Returns an integer upper-bound of the natural logarithm of the input scaled by 2^32.\n', '        We do this by calculating "UpperBound(log2(baseN / baseD)) * Ceiling(ln(2) * 2^32)".\n', '        We calculate "UpperBound(log2(baseN / baseD))" as "Floor(log2((_baseN - 1) / _baseD)) + 1".\n', '        For small values of "baseN / baseD", this sometimes yields a bad upper-bound approximation.\n', '        We therefore cover these cases (and a few more) manually.\n', '        Complexity is O(log(input bit-length)).\n', '    */\n', '    function lnUpperBound32(uint256 _baseN, uint256 _baseD) constant returns (uint256) {\n', '        assert(_baseN > _baseD);\n', '\n', '        uint256 scaledBaseN = _baseN * 100000;\n', '        if (scaledBaseN <= _baseD *  271828) // _baseN / _baseD < e^1 (floorLog2 will return 0 if _baseN / _baseD < 2)\n', '            return uint256(1) << 32;\n', '        if (scaledBaseN <= _baseD *  738905) // _baseN / _baseD < e^2 (floorLog2 will return 1 if _baseN / _baseD < 4)\n', '            return uint256(2) << 32;\n', '        if (scaledBaseN <= _baseD * 2008553) // _baseN / _baseD < e^3 (floorLog2 will return 2 if _baseN / _baseD < 8)\n', '            return uint256(3) << 32;\n', '\n', '        return (floorLog2((_baseN - 1) / _baseD) + 1) * 0xb17217f8;\n', '    }\n', '\n', '    /**\n', '        input range: \n', '            [0x100000000, uint256_max]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '        Since `fixedLog2_min` output range is max `0xdfffffffff` \n', '        (40 bits, or 5 bytes), we can use a very large approximation\n', "        for `ln(2)`. This one is used since it's the max accuracy \n", '        of Python `ln(2)`\n', '\n', '        0xb17217f7d1cf78 = ln(2) * (1 << 56)\n', '    */\n', '    function fixedLoge(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        // cannot represent negative numbers (below 1)\n', '        assert(_x >= ONE << _precision);\n', '\n', '        uint256 flog2 = fixedLog2(_x, _precision);\n', '        return (flog2 * 0xb17217f7d1cf78) >> 56;\n', '    }\n', '\n', '    /**\n', '        Returns log2(x >> 32) << 32 [1]\n', '        So x is assumed to be already upshifted 32 bits, and \n', '        the result is also upshifted 32 bits. \n', '        \n', '        [1] The function returns a number which is lower than the \n', '        actual value\n', '\n', '        input-range : \n', '            [0x100000000, uint256_max]\n', '        output-range: \n', '            [0,0xdfffffffff]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLog2(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 fixedOne = ONE << _precision;\n', '        uint256 fixedTwo = TWO << _precision;\n', '\n', '        // Numbers below 1 are negative. \n', '        assert( _x >= fixedOne);\n', '\n', '        uint256 hi = 0;\n', '        while (_x >= fixedTwo) {\n', '            _x >>= 1;\n', '            hi += fixedOne;\n', '        }\n', '\n', '        for (uint8 i = 0; i < _precision; ++i) {\n', '            _x = (_x * _x) / fixedOne;\n', '            if (_x >= fixedTwo) {\n', '                _x >>= 1;\n', '                hi += ONE << (_precision - 1 - i);\n', '            }\n', '        }\n', '\n', '        return hi;\n', '    }\n', '\n', '    /**\n', '        floorLog2\n', '        Takes a natural number (n) as input.\n', '        Returns the largest integer smaller than or equal to the binary logarithm of the input.\n', '        Complexity is O(log(input bit-length)).\n', '    */\n', '    function floorLog2(uint256 _n) constant returns (uint256) {\n', '        uint8 t = 0;\n', '        for (uint8 s = 128; s > 0; s >>= 1) {\n', '            if (_n >= (ONE << s)) {\n', '                _n >>= s;\n', '                t |= s;\n', '            }\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '    /**\n', "        fixedExp is a 'protected' version of `fixedExpUnsafe`, which asserts instead of overflows.\n", '        The maximum value which can be passed to fixedExpUnsafe depends on the precision used.\n', '        The following array maps each precision between 0 and 63 to the maximum value permitted:\n', '        maxExpArray = {\n', '            0xc1               ,0x17a              ,0x2e5              ,0x5ab              ,\n', '            0xb1b              ,0x15bf             ,0x2a0c             ,0x50a2             ,\n', '            0x9aa2             ,0x1288c            ,0x238b2            ,0x4429a            ,\n', '            0x82b78            ,0xfaadc            ,0x1e0bb8           ,0x399e96           ,\n', '            0x6e7f88           ,0xd3e7a3           ,0x1965fea          ,0x30b5057          ,\n', '            0x5d681f3          ,0xb320d03          ,0x15784a40         ,0x292c5bdd         ,\n', '            0x4ef57b9b         ,0x976bd995         ,0x122624e32        ,0x22ce03cd5        ,\n', '            0x42beef808        ,0x7ffffffff        ,0xf577eded5        ,0x1d6bd8b2eb       ,\n', '            0x386bfdba29       ,0x6c3390ecc8       ,0xcf8014760f       ,0x18ded91f0e7      ,\n', '            0x2fb1d8fe082      ,0x5b771955b36      ,0xaf67a93bb50      ,0x15060c256cb2     ,\n', '            0x285145f31ae5     ,0x4d5156639708     ,0x944620b0e70e     ,0x11c592761c666    ,\n', '            0x2214d10d014ea    ,0x415bc6d6fb7dd    ,0x7d56e76777fc5    ,0xf05dc6b27edad    ,\n', '            0x1ccf4b44bb4820   ,0x373fc456c53bb7   ,0x69f3d1c921891c   ,0xcb2ff529eb71e4   ,\n', '            0x185a82b87b72e95  ,0x2eb40f9f620fda6  ,0x5990681d961a1ea  ,0xabc25204e02828d  ,\n', '            0x14962dee9dc97640 ,0x277abdcdab07d5a7 ,0x4bb5ecca963d54ab ,0x9131271922eaa606 ,\n', '            0x116701e6ab0cd188d,0x215f77c045fbe8856,0x3ffffffffffffffff,0x7abbf6f6abb9d087f,\n', '        };\n', '        Since we cannot use an array of constants, we need to approximate the maximum value dynamically.\n', '        For a precision of 32, the maximum value permitted is MAX_FIXED_EXP_32.\n', '        For each additional precision unit, the maximum value permitted increases by approximately 1.9.\n', '        So in order to calculate it, we need to multiply MAX_FIXED_EXP_32 by 1.9 for every additional precision unit.\n', '        And in order to optimize for speed, we multiply MAX_FIXED_EXP_32 by 1.9^2 for every 2 additional precision units.\n', '        Hence the general function for mapping a given precision to the maximum value permitted is:\n', '        - precision = [32, 34, 36, ..., 62]\n', '        - MaxFixedExp(precision) = MAX_FIXED_EXP_32 * 3.61 ^ (precision / 2 - 16)\n', '        Since we cannot use non-integers, we do MAX_FIXED_EXP_32 * 361 ^ (precision / 2 - 16) / 100 ^ (precision / 2 - 16).\n', '        But there is a better approximation, because this "1.9" factor in fact extends beyond a single decimal digit.\n', '        So instead, we use 0xeb5ec5975959c565 / 0x4000000000000000, which yields maximum values quite close to real ones:\n', '        maxExpArray = {\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            -------------------,-------------------,-------------------,-------------------,\n', '            0x386bfdba29       ,-------------------,0xcf8014760e       ,-------------------,\n', '            0x2fb1d8fe07b      ,-------------------,0xaf67a93bb37      ,-------------------,\n', '            0x285145f31a8f     ,-------------------,0x944620b0e5ee     ,-------------------,\n', '            0x2214d10d0112e    ,-------------------,0x7d56e7677738e    ,-------------------,\n', '            0x1ccf4b44bb20d0   ,-------------------,0x69f3d1c9210d27   ,-------------------,\n', '            0x185a82b87b5b294  ,-------------------,0x5990681d95d4371  ,-------------------,\n', '            0x14962dee9dbd672b ,-------------------,0x4bb5ecca961fb9bf ,-------------------,\n', '            0x116701e6ab0967080,-------------------,0x3fffffffffffe6652,-------------------,\n', '        };\n', '    */\n', '    function fixedExp(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 maxExp = MAX_FIXED_EXP_32;\n', '        for (uint8 p = 32; p < _precision; p += 2)\n', '            maxExp = (maxExp * 0xeb5ec5975959c565) >> (64-2);\n', '        \n', '        assert(_x <= maxExp);\n', '        return fixedExpUnsafe(_x, _precision);\n', '    }\n', '\n', '    /**\n', '        fixedExp \n', '        Calculates e ^ x according to maclauren summation:\n', '\n', '        e^x = 1 + x + x ^ 2 / 2!...+ x ^ n / n!\n', '\n', '        and returns e ^ (x >> 32) << 32, that is, upshifted for accuracy\n', '\n', '        Input range:\n', '            - Function ok at    <= 242329958953 \n', '            - Function fails at >= 242329958954\n', '\n', '        This method is is visible for testcases, but not meant for direct use. \n', ' \n', '        The values in this method been generated via the following python snippet: \n', '\n', '        def calculateFactorials():\n', '            """Method to print out the factorials for fixedExp"""\n', '\n', '            ni = []\n', '            ni.append(295232799039604140847618609643520000000) # 34!\n', '            ITERATIONS = 34\n', '            for n in range(1, ITERATIONS, 1) :\n', '                ni.append(math.floor(ni[n - 1] / n))\n', '            print( "\\n        ".join(["xi = (xi * _x) >> _precision;\\n        res += xi * %s;" % hex(int(x)) for x in ni]))\n', '\n', '    */\n', '    function fixedExpUnsafe(uint256 _x, uint8 _precision) constant returns (uint256) {\n', '        uint256 xi = _x;\n', '        uint256 res = uint256(0xde1bc4d19efcac82445da75b00000000) << _precision;\n', '\n', '        res += xi * 0xde1bc4d19efcac82445da75b00000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x6f0de268cf7e5641222ed3ad80000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x2504a0cd9a7f7215b60f9be480000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9412833669fdc856d83e6f920000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1d9d4d714865f4de2b3fafea0000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x4ef8ce836bba8cfb1dff2a70000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xb481d807d1aa66d04490610000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x16903b00fa354cda08920c2000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x281cdaac677b334ab9e732000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x402e2aad725eb8778fd85000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x5d5a6c9f31fe2396a2af000000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x7c7890d442a82f73839400000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9931ed54034526b58e400000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xaf147cf24ce150cf7e00000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xbac08546b867cdaa200000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xbac08546b867cdaa20000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xafc441338061b2820000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x9c3cabbc0056d790000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x839168328705c30000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x694120286c049c000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x50319e98b3d2c000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x3a52a1e36b82000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x289286e0fce000;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1b0c59eb53400;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x114f95b55400;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0xaa7210d200;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x650139600;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x39b78e80;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x1fd8080;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x10fbc0;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x8c40;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x462;\n', '        xi = (xi * _x) >> _precision;\n', '        res += xi * 0x22;\n', '\n', '        return res / 0xde1bc4d19efcac82445da75b00000000;\n', '    }\n', '}\n', '\n', '\n', 'contract BasicERC20Token {\n', '    /* Public variables of the token */\n', "    string public standard = 'Token 0.1';\n", "    string public name = 'Ivan\\'s Trackable Token';\n", "    string public symbol = 'ITT';\n", '    uint8 public decimals = 18;\n', '    uint256 public totalSupply = 0;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event BalanceCheck(uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* Functions below are specific to this token and\n', '     * not part of the ERC-20 standard */\n', '\n', '    function deposit() payable returns (bool success) {\n', '        if (msg.value == 0) return false;\n', '        balances[msg.sender] += msg.value;\n', '        totalSupply += msg.value;\n', '        return true;\n', '    }\n', '\n', '    function withdraw(uint256 amount) returns (bool success) {\n', '        if (balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        if (!msg.sender.send(amount)) {\n', '            balances[msg.sender] += amount;\n', '            totalSupply += amount;\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract DummyBancorToken is BasicERC20Token, BancorFormula {\n', '\n', "    string public standard = 'Token 0.1';\n", "    string public name = 'Dummy Constant Reserve Rate Token';\n", "    string public symbol = 'DBT';\n", '    uint8 public decimals = 18;\n', '    uint256 public totalSupply = 0;\n', '\n', '    uint8 public ratio = 10; // CRR of 10%\n', '\n', '    address public owner = 0x0;\n', '\n', '    event Deposit(address indexed sender);\n', '    event Withdraw(uint256 amount);\n', '\n', "    /* I can't make MyEtherWallet send payments as part of constructor calls\n", '     * while creating contracts. So instead of implementing a constructor,\n', '     * we follow the SetUp/TearDown paradigm */\n', '    function setUp(uint256 _initialSupply) payable {\n', '        if (owner != 0) return;\n', '        owner = msg.sender;\n', '        balances[msg.sender] = _initialSupply;\n', '        totalSupply = _initialSupply;\n', '    }\n', '\n', '    function tearDown() {\n', '        if (msg.sender != owner) return;\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function reserveBalance() constant returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    // Our reserve token is always ETH.\n', '    function deposit() payable returns (bool success) {\n', '        if (msg.value == 0) return false;\n', '        uint256 tokensPurchased = calculatePurchaseReturn(totalSupply, reserveBalance(), ratio, msg.value);\n', '        balances[msg.sender] += tokensPurchased;\n', '        totalSupply += tokensPurchased;\n', '        Deposit(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function withdraw(uint256 amount) returns (bool success) {\n', '        if (balances[msg.sender] < amount) return false;\n', '        uint256 ethAmount = calculateSaleReturn(totalSupply, reserveBalance(), ratio, amount);\n', '        balances[msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        if (!msg.sender.send(ethAmount)) {\n', '            balances[msg.sender] += amount;\n', '            totalSupply += amount;\n', '            return false;\n', '        }\n', '        Withdraw(amount);\n', '        return true;\n', '    }\n', '\n', '}']
