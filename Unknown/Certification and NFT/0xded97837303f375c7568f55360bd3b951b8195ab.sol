['pragma solidity ^0.4.0;\n', '\n', '/*\n', ' * Token - is a smart contract interface \n', ' * for managing common functionality of \n', ' * a token.\n', ' *\n', ' * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\n', ' */\n', 'contract TokenInterface {\n', '\n', '        \n', '    // total amount of tokens\n', '    uint totalSupplyVar;\n', '\n', '    \n', '    /**\n', '     *\n', '     * balanceOf() - constant function check concrete tokens balance  \n', '     *\n', '     *  @param owner - account owner\n', '     *  \n', '     *  @return the value of balance \n', '     */                               \n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '    \n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     *\n', '     * approve() - function approves to a person to spend some tokens from \n', '     *           owner balance. \n', '     *\n', '     *  @param spender - person whom this right been granted.\n', '     *  @param value   - value to spend.\n', '     * \n', '     *  @return true in case of succes, otherwise failure\n', '     * \n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     *\n', '     * allowance() - constant function to check how much is \n', '     *               permitted to spend to 3rd person from owner balance\n', '     *\n', '     *  @param owner   - owner of the balance\n', '     *  @param spender - permitted to spend from this balance person \n', '     *  \n', '     *  @return - remaining right to spend \n', '     * \n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '    \n', '    function totalSupply() constant returns (uint256 totalSupply){\n', '        return totalSupplyVar;    \n', '    }\n', '\n', '    // events notifications\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'pragma solidity ^0.4.2;\n', '\n', '/*\n', ' * StandardToken - is a smart contract  \n', ' * for managing common functionality of \n', ' * a token.\n', ' *\n', ' * ERC.20 Token standard: \n', ' *         https://github.com/eth ereum/EIPs/issues/20\n', ' */\n', 'contract StandardToken is TokenInterface {\n', '\n', '\n', '    // token ownership\n', '    mapping (address => uint256) balances;\n', '\n', '    // spending permision management\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    \n', '    \n', '    function StandardToken(){\n', '    }\n', '    \n', '    \n', '    /**\n', '     * transfer() - transfer tokens from msg.sender balance \n', '     *              to requested account\n', '     *\n', '     *  @param to    - target address to transfer tokens\n', '     *  @param value - ammount of tokens to transfer\n', '     *\n', '     *  @return - success / failure of the transaction\n', '     */    \n', '    function transfer(address to, uint256 value) returns (bool success) {\n', '        \n', '        \n', '        if (balances[msg.sender] >= value && value > 0) {\n', '\n', '            // do actual tokens transfer       \n', '            balances[msg.sender] -= value;\n', '            balances[to]         += value;\n', '            \n', '            // rise the Transfer event\n', '            Transfer(msg.sender, to, value);\n', '            return true;\n', '        } else {\n', '            \n', '            return false; \n', '        }\n', '    }\n', '    \n', '    \n', '\n', '    \n', '    /**\n', '     * transferFrom() - used to move allowed funds from other owner\n', '     *                  account \n', '     *\n', '     *  @param from  - move funds from account\n', '     *  @param to    - move funds to account\n', '     *  @param value - move the value \n', '     *\n', '     *  @return - return true on success false otherwise \n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success) {\n', '    \n', '        if ( balances[from] >= value && \n', '             allowed[from][msg.sender] >= value && \n', '             value > 0) {\n', '                                          \n', '    \n', '            // do the actual transfer\n', '            balances[from] -= value;    \n', '            balances[to]   += value;            \n', '            \n', '\n', '            // addjust the permision, after part of \n', '            // permited to spend value was used\n', '            allowed[from][msg.sender] -= value;\n', '            \n', '            // rise the Transfer event\n', '            Transfer(from, to, value);\n', '            return true;\n', '        } else { \n', '            \n', '            return false; \n', '        }\n', '    }\n', '\n', '    \n', '\n', '    \n', '    /**\n', '     *\n', '     * balanceOf() - constant function check concrete tokens balance  \n', '     *\n', '     *  @param owner - account owner\n', '     *  \n', '     *  @return the value of balance \n', '     */                               \n', '    function balanceOf(address owner) constant returns (uint256 balance) {\n', '        return balances[owner];\n', '    }\n', '\n', '    \n', '    \n', '    /**\n', '     *\n', '     * approve() - function approves to a person to spend some tokens from \n', '     *           owner balance. \n', '     *\n', '     *  @param spender - person whom this right been granted.\n', '     *  @param value   - value to spend.\n', '     * \n', '     *  @return true in case of succes, otherwise failure\n', '     * \n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success) {\n', '        \n', '        \n', '        \n', '        // now spender can use balance in \n', '        // ammount of value from owner balance\n', '        allowed[msg.sender][spender] = value;\n', '        \n', '        // rise event about the transaction\n', '        Approval(msg.sender, spender, value);\n', '        \n', '        return true;\n', '    }\n', '    \n', '\n', '    /**\n', '     *\n', '     * allowance() - constant function to check how mouch is \n', '     *               permited to spend to 3rd person from owner balance\n', '     *\n', '     *  @param owner   - owner of the balance\n', '     *  @param spender - permited to spend from this balance person \n', '     *  \n', '     *  @return - remaining right to spend \n', '     * \n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining) {\n', '      return allowed[owner][spender];\n', '    }\n', '\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.6;\n', '\n', '/**\n', ' * \n', ' * EventInfo - imutable class that denotes\n', ' * the time of the virtual accelerator hack\n', ' * event\n', ' * \n', ' */\n', 'contract EventInfo{\n', '    \n', '    \n', '    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;\n', '    uint constant T_1_WEEK = 60 * 60 * 24 * 7;\n', '\n', '    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT\n', '    uint eventEnd = eventStart + HACKATHON_5_WEEKS;\n', '    \n', '    \n', '    /**\n', '     * getEventStart - return the start of the event time\n', '     */ \n', '    function getEventStart() constant returns (uint result){        \n', '       return eventStart;\n', '    } \n', '    \n', '    /**\n', '     * getEventEnd - return the end of the event time\n', '     */ \n', '    function getEventEnd() constant returns (uint result){        \n', '       return eventEnd;\n', '    } \n', '    \n', '    \n', '    /**\n', '     * getVotingStart - the voting starts 1 week after the \n', '     *                  event starts\n', '     */ \n', '    function getVotingStart() constant returns (uint result){\n', '        return eventStart+ T_1_WEEK;\n', '    }\n', '\n', '    /**\n', '     * getTradingStart - the DST tokens trading starts 1 week \n', '     *                   after the event starts\n', '     */ \n', '    function getTradingStart() constant returns (uint result){\n', '        return eventStart+ T_1_WEEK;\n', '    }\n', '\n', '    /**\n', '     * getNow - helper class to check what time the contract see\n', '     */\n', '    function getNow() constant returns (uint result){        \n', '       return now;\n', '    } \n', '    \n', '}\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', '/**\n', ' *\n', ' * @title Hacker Gold\n', ' * \n', ' * The official token powering the hack.ether.camp virtual accelerator.\n', ' * This is the only way to acquire tokens from startups during the event.\n', ' *\n', ' * Whitepaper https://hack.ether.camp/whitepaper\n', ' *\n', ' */\n', 'contract HackerGold is StandardToken {\n', '\n', '    // Name of the token    \n', '    string public name = "HackerGold";\n', '\n', '    // Decimal places\n', '    uint8  public decimals = 3;\n', '    // Token abbreviation        \n', '    string public symbol = "HKG";\n', '    \n', '    // 1 ether = 200 hkg\n', '    uint BASE_PRICE = 200;\n', '    // 1 ether = 150 hkg\n', '    uint MID_PRICE = 150;\n', '    // 1 ether = 100 hkg\n', '    uint FIN_PRICE = 100;\n', '    // Safety cap\n', '    uint SAFETY_LIMIT = 4000000 ether;\n', '    // Zeros after the point\n', '    uint DECIMAL_ZEROS = 1000;\n', '    \n', '    // Total value in wei\n', '    uint totalValue;\n', '    \n', '    // Address of multisig wallet holding ether from sale\n', '    address wallet;\n', '\n', '    // Structure of sale increase milestones\n', '    struct milestones_struct {\n', '      uint p1;\n', '      uint p2; \n', '      uint p3;\n', '      uint p4;\n', '      uint p5;\n', '      uint p6;\n', '    }\n', '    // Milestones instance\n', '    milestones_struct milestones;\n', '    \n', '    /**\n', '     * Constructor of the contract.\n', '     * \n', '     * Passes address of the account holding the value.\n', '     * HackerGold contract itself does not hold any value\n', '     * \n', '     * @param multisig address of MultiSig wallet which will hold the value\n', '     */\n', '    function HackerGold(address multisig) {\n', '        \n', '        wallet = multisig;\n', '\n', '        // set time periods for sale\n', '        milestones = milestones_struct(\n', '        \n', '          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\n', '          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \n', '          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \n', '                       //                                Hackathon Starts\n', '          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\n', '          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\n', '          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\n', '        );\n', '        \n', '        // assign recovery balance\n', '        totalSupplyVar   = 16110893000;\n', '        balances[0x342e62732b76875da9305083ea8ae63125a4e667] = 16110893000;\n', '        totalValue    = 85362 ether;        \n', '    }\n', '    \n', '    \n', '    /**\n', '     * Fallback function: called on ether sent.\n', '     * \n', '     * It calls to createHKG function with msg.sender \n', '     * as a value for holder argument\n', '     */\n', '    function () payable {\n', '        createHKG(msg.sender);\n', '    }\n', '    \n', '    /**\n', '     * Creates HKG tokens.\n', '     * \n', '     * Runs sanity checks including safety cap\n', '     * Then calculates current price by getPrice() function, creates HKG tokens\n', '     * Finally sends a value of transaction to the wallet\n', '     * \n', '     * Note: due to lack of floating point types in Solidity,\n', '     * contract assumes that last 3 digits in tokens amount are stood after the point.\n', '     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\n', '     * \n', '     * @param holder token holder\n', '     */\n', '    function createHKG(address holder) payable {\n', '        \n', '        if (now < milestones.p1) throw;\n', '        if (now >= milestones.p6) throw;\n', '        if (msg.value == 0) throw;\n', '    \n', '        // safety cap\n', '        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \n', '    \n', '        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\n', '\n', '        totalSupplyVar += tokens;\n', '        balances[holder] += tokens;\n', '        totalValue += msg.value;\n', '        \n', '        if (!wallet.send(msg.value)) throw;\n', '    }\n', '    \n', '    /**\n', '     * Denotes complete price structure during the sale.\n', '     *\n', '     * @return HKG amount per 1 ETH for the current moment in time\n', '     */\n', '    function getPrice() constant returns (uint result) {\n', '        \n', '        if (now < milestones.p1) return 0;\n', '        \n', '        if (now >= milestones.p1 && now < milestones.p2) {\n', '        \n', '            return BASE_PRICE;\n', '        }\n', '        \n', '        if (now >= milestones.p2 && now < milestones.p3) {\n', '            \n', '            uint days_in = 1 + (now - milestones.p2) / 1 days; \n', '            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\n', '        }\n', '\n', '        if (now >= milestones.p3 && now < milestones.p4) {\n', '        \n', '            return MID_PRICE;\n', '        }\n', '        \n', '        if (now >= milestones.p4 && now < milestones.p5) {\n', '            \n', '            days_in = 1 + (now - milestones.p4) / 1 days; \n', '            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\n', '        }\n', '\n', '        if (now >= milestones.p5 && now < milestones.p6) {\n', '        \n', '            return FIN_PRICE;\n', '        }\n', '        \n', '        if (now >= milestones.p6){\n', '\n', '            return 0;\n', '        }\n', '\n', '     }\n', '    \n', '    /**\n', '     * Returns total stored HKG amount.\n', '     * \n', '     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\n', '     * Thus, result of this function should be divided by 1000 to get HKG value\n', '     * \n', '     * @return result stored HKG amount\n', '     */\n', '    function getTotalSupply() constant returns (uint result) {\n', '        return totalSupplyVar;\n', '    } \n', '\n', '    /**\n', '     * It is used for test purposes.\n', '     * \n', "     * Returns the result of 'now' statement of Solidity language\n", '     * \n', '     * @return unix timestamp for current moment in time\n', '     */\n', '    function getNow() constant returns (uint result) {\n', '        return now;\n', '    }\n', '\n', '    /**\n', '     * Returns total value passed through the contract\n', '     * \n', '     * @return result total value in wei\n', '     */\n', '    function getTotalValue() constant returns (uint result) {\n', '        return totalValue;  \n', '    }\n', '}\n', '\n', 'pragma solidity ^0.4.6;\n', '\n', '/*\n', ' * DSTContract - DST stands for decentralized startup team.\n', ' *               the contract ensures funding for a decentralized\n', ' *               team in 2 phases: \n', ' *\n', ' *                +. Funding by HKG during the hackathon event. \n', ' *                +. Funding by Ether after the event is over. \n', ' *\n', ' *               After the funds been collected there is a governence\n', ' *               mechanism managed by proposition to withdraw funds\n', ' *               for development usage. \n', ' *\n', ' *               The DST ensures that backers of the projects keeps\n', ' *               some influence on the project by ability to reject\n', ' *               propositions they find as non effective. \n', ' *\n', ' *               In very radical occasions the backers may loose \n', ' *               the trust in the team completelly, in that case \n', ' *               there is an option to propose impeachment process\n', ' *               completelly removing the execute and assigning new\n', ' *               person to manage the funds. \n', ' *\n', ' */\n', 'contract DSTContract is StandardToken{\n', '\n', '    // Zeros after the point\n', '    uint DECIMAL_ZEROS = 1000;\n', '    // Proposal lifetime\n', '    uint PROPOSAL_LIFETIME = 10 days;\n', '    // Proposal funds threshold, in percents\n', '    uint PROPOSAL_FUNDS_TH = 20;\n', '\n', '    address   executive; \n', '        \n', '    EventInfo eventInfo;\n', '    \n', '    // Indicated where the DST is traded\n', '    address virtualExchangeAddress;\n', '    \n', '    HackerGold hackerGold;\n', '        \n', '    mapping (address => uint256) votingRights;\n', '\n', '\n', '    // 1 - HKG => DST qty; tokens for 1 HKG\n', '    uint hkgPrice;\n', '    \n', '    // 1 - Ether => DST qty; tokens for 1 Ether\n', '    uint etherPrice;\n', '    \n', '    string public name = "...";                   \n', '    uint8  public decimals = 3;                 \n', '    string public symbol = "...";\n', '    \n', '    bool ableToIssueTokens = true; \n', '    \n', '    uint preferedQtySold;\n', '\n', '    uint collectedHKG; \n', '    uint collectedEther;    \n', '    \n', '    // Proposal of the funds spending\n', '    mapping (bytes32 => Proposal) proposals;\n', '\n', '    enum ProposalCurrency { HKG, ETHER }\n', '    ProposalCurrency enumDeclaration;\n', '                  \n', '       \n', '    struct Proposal{\n', '        \n', '        bytes32 id;\n', '        uint value;\n', '\n', '        string urlDetails;\n', '\n', '        uint votindEndTS;\n', '                \n', '        uint votesObjecting;\n', '        \n', '        address submitter;\n', '        bool redeemed;\n', '\n', '        ProposalCurrency proposalCurrency;\n', '        \n', '        mapping (address => bool) voted;\n', '    }\n', '    uint counterProposals;\n', '    uint timeOfLastProposal;\n', '    \n', '    Proposal[] listProposals;\n', '    \n', '\n', '    /**\n', '     * Impeachment process proposals\n', '     */    \n', '    struct ImpeachmentProposal{\n', '        \n', '        string urlDetails;\n', '        \n', '        address newExecutive;\n', '\n', '        uint votindEndTS;        \n', '        uint votesSupporting;\n', '        \n', '        mapping (address => bool) voted;        \n', '    }\n', '    ImpeachmentProposal lastImpeachmentProposal;\n', '\n', '        \n', '    /**\n', '     * \n', '     *  DSTContract: ctor for DST token and governence contract\n', '     *\n', '     *  @param eventInfoAddr EventInfo: address of object denotes events \n', '     *                                  milestones      \n', '     *  @param hackerGoldAddr HackerGold: address of HackerGold token\n', '     *\n', '     *  @param dstName string: dstName: real name of the team\n', '     *\n', '     *  @param dstSymbol string: 3 letter symbold of the team\n', '     *\n', '     */ \n', '    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\n', '    \n', '      executive   = msg.sender;  \n', '      name        = dstName;\n', '      symbol      = dstSymbol;\n', '\n', '      hackerGold = HackerGold(hackerGoldAddr);\n', '      eventInfo  = EventInfo(eventInfoAddr);\n', '    }\n', '    \n', '\n', '    function() payable\n', '               onlyAfterEnd {\n', '        \n', '        // there is tokens left from hackathon \n', '        if (etherPrice == 0) throw;\n', '        \n', '        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\n', '        \n', '        // check if demand of tokens is \n', '        // overflow the supply \n', '        uint retEther = 0;\n', '        if (balances[this] < tokens) {\n', '            \n', '            tokens = balances[this];\n', '            retEther = msg.value - tokens / etherPrice * (1 finney);\n', '        \n', '            // return left ether \n', '            if (!msg.sender.send(retEther)) throw;\n', '        }\n', '        \n', '        \n', '        // do transfer\n', '        balances[msg.sender] += tokens;\n', '        balances[this] -= tokens;\n', '        \n', '        // count collected ether \n', '        collectedEther += msg.value - retEther; \n', '        \n', '        // rise event\n', '        BuyForEtherTransaction(msg.sender, collectedEther, totalSupplyVar, etherPrice, tokens);\n', '        \n', '    }\n', '\n', '    \n', '    \n', '    /**\n', '     * setHKGPrice - set price: 1HKG => DST tokens qty\n', '     *\n', '     *  @param qtyForOneHKG uint: DST tokens for 1 HKG\n', '     * \n', '     */    \n', '     function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\n', '         \n', '         hkgPrice = qtyForOneHKG;\n', '         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupplyVar);\n', '     }\n', '     \n', '     \n', '    \n', '    /**\n', '     * \n', '     * issuePreferedTokens - prefered tokens issued on the hackathon event\n', '     *                       grant special rights\n', '     *\n', '     *  @param qtyForOneHKG uint: price DST tokens for one 1 HKG\n', '     *  @param qtyToEmit uint: new supply of tokens \n', '     * \n', '     */\n', '    function issuePreferedTokens(uint qtyForOneHKG, \n', '                                 uint256 qtyToEmit) onlyExecutive \n', '                                                 onlyIfAbleToIssueTokens\n', '                                                 onlyBeforeEnd\n', '                                                 onlyAfterTradingStart {\n', '                \n', '        // no issuence is allowed before enlisted on the\n', '        // exchange \n', '        if (virtualExchangeAddress == 0x0) throw;\n', '            \n', '        totalSupplyVar += qtyToEmit;\n', '        balances[this] += qtyToEmit;\n', '        hkgPrice = qtyForOneHKG;\n', '        \n', '        \n', '        // now spender can use balance in \n', '        // amount of value from owner balance\n', '        allowed[this][virtualExchangeAddress] += qtyToEmit;\n', '        \n', '        // rise event about the transaction\n', '        Approval(this, virtualExchangeAddress, qtyToEmit);\n', '        \n', '        // rise event \n', '        DstTokensIssued(hkgPrice, preferedQtySold, totalSupplyVar, qtyToEmit);\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    /**\n', '     * \n', '     * buyForHackerGold - on the hack event this function is available \n', '     *                    the buyer for hacker gold will gain votes to \n', '     *                    influence future proposals on the DST\n', '     *    \n', '     *  @param hkgValue - qty of this DST tokens for 1 HKG     \n', '     * \n', '     */\n', '    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \n', '                                             returns (bool success) {\n', '    \n', '      // validate that the caller is official accelerator HKG Exchange\n', '      if (msg.sender != virtualExchangeAddress) throw;\n', '      \n', '      \n', '      // transfer token \n', '      address sender = tx.origin;\n', '      uint tokensQty = hkgValue * hkgPrice;\n', '\n', '      // gain voting rights\n', '      votingRights[sender] +=tokensQty;\n', '      preferedQtySold += tokensQty;\n', '      collectedHKG += hkgValue;\n', '\n', '      // do actual transfer\n', '      transferFrom(this, \n', '                   virtualExchangeAddress, tokensQty);\n', '      transfer(sender, tokensQty);        \n', '            \n', '      // rise event       \n', '      BuyForHKGTransaction(sender, preferedQtySold, totalSupplyVar, hkgPrice, tokensQty);\n', '        \n', '      return true;\n', '    }\n', '        \n', '    \n', '    /**\n', '     * \n', '     * issueTokens - function will issue tokens after the \n', '     *               event, able to sell for 1 ether \n', '     * \n', '     *  @param qtyForOneEther uint: DST tokens for 1 ETH\n', '     *  @param qtyToEmit uint: new tokens supply\n', '     *\n', '     */\n', '    function issueTokens(uint qtyForOneEther, \n', '                         uint qtyToEmit) onlyAfterEnd \n', '                                         onlyExecutive\n', '                                         onlyIfAbleToIssueTokens {\n', '         \n', '         balances[this] += qtyToEmit;\n', '         etherPrice = qtyForOneEther;\n', '         totalSupplyVar    += qtyToEmit;\n', '         \n', '         // rise event  \n', '         DstTokensIssued(qtyForOneEther, totalSupplyVar, totalSupplyVar, qtyToEmit);\n', '    }\n', '     \n', '    \n', '    /**\n', '     * setEtherPrice - change the token price\n', '     *\n', '     *  @param qtyForOneEther uint: new price - DST tokens for 1 ETH\n', '     */     \n', '    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\n', '                                                onlyExecutive {\n', '         etherPrice = qtyForOneEther; \n', '\n', '         // rise event for this\n', '         NewEtherPrice(qtyForOneEther);\n', '    }    \n', '    \n', '\n', '    /**\n', '     *  disableTokenIssuance - function will disable any \n', '     *                         option for future token \n', '     *                         issuence\n', '     */\n', '    function disableTokenIssuance() onlyExecutive {\n', '        ableToIssueTokens = false;\n', '        \n', '        DisableTokenIssuance();\n', '    }\n', '\n', '    \n', '    /**\n', '     *  burnRemainToken -  eliminated all available for sale\n', '     *                     tokens. \n', '     */\n', '    function burnRemainToken() onlyExecutive {\n', '    \n', '        totalSupplyVar -= balances[this];\n', '        balances[this] = 0;\n', '        \n', '        // rise event for this\n', '        BurnedAllRemainedTokens();\n', '    }\n', '    \n', '    /**\n', '     *  submitEtherProposal: submit proposal to use part of the \n', '     *                       collected ether funds\n', '     *\n', '     *   @param requestValue uint: value in wei \n', '     *   @param url string: details of the proposal \n', '     */ \n', '    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \n', '                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \n', '    \n', '        // ensure there is no more issuence available \n', '        if (ableToIssueTokens) throw;\n', '            \n', '        // ensure there is no more tokens available \n', '        if (balanceOf(this) > 0) throw;\n', '\n', '        // Possible to submit a proposal once 2 weeks \n', '        if (now < (timeOfLastProposal + 2 weeks)) throw;\n', '            \n', '        uint percent = collectedEther / 100;\n', '            \n', '        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\n', '\n', '        // if remained value is less than requested gain all.\n', '        if (requestValue > this.balance) \n', '            requestValue = this.balance;    \n', '            \n', '        // set id of the proposal\n', '        // submit proposal to the map\n', '        bytes32 id = sha3(msg.data, now);\n', '        uint timeEnds = now + PROPOSAL_LIFETIME; \n', '            \n', '        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\n', '        proposals[id] = newProposal;\n', '        listProposals.push(newProposal);\n', '            \n', '        timeOfLastProposal = now;                        \n', '        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n', '        \n', '        return (id, true);\n', '    }\n', '    \n', '    \n', '     \n', '    /**\n', '     * \n', '     * submitHKGProposal - submit proposal to request for \n', '     *                     partial HKG funds collected \n', '     * \n', '     *  @param requestValue uint: value in HKG to request. \n', '     *  @param url string: url with details on the proposition \n', '     */\n', '    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\n', '                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\n', '        \n', '\n', '        // If there is no 2 months over since the last event.\n', '        // There is no posible to get any HKG. After 2 months\n', '        // all the HKG is available. \n', '        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\n', '            throw;\n', '        }\n', '\n', '        // Possible to submit a proposal once 2 weeks \n', '        if (now < (timeOfLastProposal + 2 weeks)) throw;\n', '\n', '        uint percent = preferedQtySold / 100;\n', '        \n', '        // validate the amount is legit\n', '        // first 5 proposals should be less than 20% \n', '        if (counterProposals <= 5 && \n', '            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\n', '                \n', '        // if remained value is less than requested \n', '        // gain all.\n', '        if (requestValue > getHKGOwned()) \n', '            requestValue = getHKGOwned();\n', '        \n', '        \n', '        // set id of the proposal\n', '        // submit proposal to the map\n', '        bytes32 id = sha3(msg.data, now);\n', '        uint timeEnds = now + PROPOSAL_LIFETIME; \n', '        \n', '        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\n', '        proposals[id] = newProposal;\n', '        listProposals.push(newProposal);\n', '        \n', '        ++counterProposals;\n', '        timeOfLastProposal = now;                \n', '                \n', '        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\n', '        \n', '        return (id, true);        \n', '    }  \n', '    \n', '    \n', '    \n', '    /**\n', '     * objectProposal - object previously submitted proposal, \n', '     *                  the objection right is obtained by \n', '     *                  purchasing prefered tokens on time of \n', '     *                  the hackathon.\n', '     * \n', '     *  @param id bytes32 : the id of the proposla to redeem\n', '     */\n', '     function objectProposal(bytes32 id){\n', '         \n', '        Proposal memory proposal = proposals[id];\n', '         \n', '        // check proposal exist \n', '        if (proposals[id].id == 0) throw;\n', '\n', '        // check already redeemed\n', '        if (proposals[id].redeemed) throw;\n', '         \n', '        // ensure objection time\n', '        if (now >= proposals[id].votindEndTS) throw;\n', '         \n', '        // ensure not voted  \n', '        if (proposals[id].voted[msg.sender]) throw;\n', '         \n', '         // submit votes\n', '         uint votes = votingRights[msg.sender];\n', '         proposals[id].votesObjecting += votes;\n', '         \n', '         // mark voted \n', '         proposals[id].voted[msg.sender] = true; \n', '         \n', '         uint idx = getIndexByProposalId(id);\n', '         listProposals[idx] = proposals[id];   \n', '\n', '         ObjectedVote(id, msg.sender, votes);         \n', '     }\n', '     \n', '     \n', '     function getIndexByProposalId(bytes32 id) returns (uint result){\n', '         \n', '         for (uint i = 0; i < listProposals.length; ++i){\n', '             if (id == listProposals[i].id) return i;\n', '         }\n', '     }\n', '    \n', '    \n', '   \n', '    /**\n', '     * redeemProposalFunds - redeem funds requested by prior \n', '     *                       submitted proposal     \n', '     * \n', '     * @param id bytes32: the id of the proposal to redeem\n', '     */\n', '    function redeemProposalFunds(bytes32 id) onlyExecutive {\n', '\n', '        if (proposals[id].id == 0) throw;\n', '        if (proposals[id].submitter != msg.sender) throw;\n', '\n', '        // ensure objection time\n', '        if (now < proposals[id].votindEndTS) throw;\n', '                           \n', '    \n', '            // check already redeemed\n', '        if (proposals[id].redeemed) throw;\n', '\n', '        // check votes objection => 55% of total votes\n', '        uint objectionThreshold = preferedQtySold / 100 * 55;\n', '        if (proposals[id].votesObjecting  > objectionThreshold) throw;\n', '    \n', '    \n', '        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\n', '            \n', '            // send hacker gold \n', '            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \n', '                        \n', '        } else {\n', '                        \n', '           // send ether              \n', '           bool success = proposals[id].submitter.send(proposals[id].value); \n', '\n', '           // rise event\n', '           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \n', '        }\n', '        \n', '        // execute the proposal \n', '        proposals[id].redeemed = true; \n', '    }\n', '    \n', '    \n', '    /**\n', '     *  getAllTheFunds - to ensure there is no deadlock can \n', '     *                   can happen, and no case that voting \n', '     *                   structure will freeze the funds forever\n', '     *                   the startup will be able to get all the\n', '     *                   funds without a proposal required after\n', '     *                   6 months.\n', '     * \n', '     * \n', '     */             \n', '    function getAllTheFunds() onlyExecutive {\n', '        \n', '        // If there is a deadlock in voting participates\n', '        // the funds can be redeemed completelly in 6 months\n', '        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\n', '            throw;\n', '        }  \n', '        \n', '        // all the Ether\n', '        bool success = msg.sender.send(this.balance);        \n', '        \n', '        // all the HKG\n', '        hackerGold.transfer(msg.sender, getHKGOwned());              \n', '    }\n', '    \n', '    \n', '    /**\n', '     * submitImpeachmentProposal - submit request to switch \n', '     *                             executive.\n', '     * \n', '     *  @param urlDetails  - details of the impeachment proposal \n', '     *  @param newExecutive - address of the new executive \n', '     * \n', '     */             \n', '     function submitImpeachmentProposal(string urlDetails, address newExecutive){\n', '         \n', '        // to offer impeachment you should have \n', '        // voting rights\n', '        if (votingRights[msg.sender] == 0) throw;\n', '         \n', '        // the submission of the first impeachment \n', '        // proposal is possible only after 3 months\n', '        // since the hackathon is over\n', '        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\n', '        \n', '                \n', '        // check there is 1 months over since last one\n', '        if (lastImpeachmentProposal.votindEndTS != 0 && \n', '            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\n', '\n', '\n', '        // submit impeachment proposal\n', '        // add the votes of the submitter \n', '        // to the proposal right away\n', '        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\n', '        lastImpeachmentProposal.voted[msg.sender] = true;\n', '         \n', '        // rise event\n', '        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\n', '     }\n', '    \n', '    \n', '    /**\n', '     * supportImpeachment - vote for impeachment proposal \n', '     *                      that is currently in progress\n', '     *\n', '     */\n', '    function supportImpeachment(){\n', '\n', '        // ensure that support is for exist proposal \n', '        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\n', '    \n', '        // to offer impeachment you should have \n', '        // voting rights\n', '        if (votingRights[msg.sender] == 0) throw;\n', '        \n', '        // check if not voted already \n', '        if (lastImpeachmentProposal.voted[msg.sender]) throw;\n', '        \n', '        // check if not finished the 2 weeks of voting \n', '        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\n', '                \n', '        // support the impeachment\n', '        lastImpeachmentProposal.voted[msg.sender] = true;\n', '        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\n', '\n', '        // rise impeachment suppporting event\n', '        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\n', '        \n', '        // if the vote is over 70% execute the switch \n', '        uint percent = preferedQtySold / 100; \n', '        \n', '        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\n', '            executive = lastImpeachmentProposal.newExecutive;\n', '            \n', '            // impeachment event\n', '            ImpeachmentAccepted(executive);\n', '        }\n', '        \n', '    } \n', '    \n', '      \n', '    \n', '    // **************************** //\n', '    // *     Constant Getters     * //\n', '    // **************************** //\n', '    \n', '    function votingRightsOf(address _owner) constant returns (uint256 result) {\n', '        result = votingRights[_owner];\n', '    }\n', '    \n', '    function getPreferedQtySold() constant returns (uint result){\n', '        return preferedQtySold;\n', '    }\n', '    \n', '    function setVirtualExchange(address virtualExchangeAddr){\n', '        if (virtualExchangeAddress != 0x0) throw;\n', '        virtualExchangeAddress = virtualExchangeAddr;\n', '    }\n', '\n', '    function getHKGOwned() constant returns (uint result){\n', '        return hackerGold.balanceOf(this);\n', '    }\n', '    \n', '    function getEtherValue() constant returns (uint result){\n', '        return this.balance;\n', '    }\n', '    \n', '    function getExecutive() constant returns (address result){\n', '        return executive;\n', '    }\n', '    \n', '    function getHKGPrice() constant returns (uint result){\n', '        return hkgPrice;\n', '    }\n', '\n', '    function getEtherPrice() constant returns (uint result){\n', '        return etherPrice;\n', '    }\n', '    \n', '    function getDSTName() constant returns(string result){\n', '        return name;\n', '    }    \n', '    \n', '    function getDSTNameBytes() constant returns(bytes32 result){\n', '        return convert(name);\n', '    }    \n', '\n', '    function getDSTSymbol() constant returns(string result){\n', '        return symbol;\n', '    }    \n', '    \n', '    function getDSTSymbolBytes() constant returns(bytes32 result){\n', '        return convert(symbol);\n', '    }    \n', '\n', '    function getAddress() constant returns (address result) {\n', '        return this;\n', '    }\n', '    \n', '    function getTotalSupply() constant returns (uint result) {\n', '        return totalSupplyVar;\n', '    } \n', '        \n', '    function getCollectedEther() constant returns (uint results) {        \n', '        return collectedEther;\n', '    }\n', '    \n', '    function getCounterProposals() constant returns (uint result){\n', '        return counterProposals;\n', '    }\n', '        \n', '    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\n', '        return listProposals[i].id;\n', '    }    \n', '\n', '    function getProposalObjectionByIndex(uint i) constant returns (uint result){\n', '        return listProposals[i].votesObjecting;\n', '    }\n', '\n', '    function getProposalValueByIndex(uint i) constant returns (uint result){\n', '        return listProposals[i].value;\n', '    }                  \n', '    \n', '    function getCurrentImpeachmentUrlDetails() constant returns (string result){\n', '        return lastImpeachmentProposal.urlDetails;\n', '    }\n', '    \n', '    \n', '    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\n', '        return lastImpeachmentProposal.votesSupporting;\n', '    }\n', '    \n', '    function convert(string key) returns (bytes32 ret) {\n', '            if (bytes(key).length > 32) {\n', '                throw;\n', '            }      \n', '\n', '            assembly {\n', '                ret := mload(add(key, 32))\n', '            }\n', '    }    \n', '    \n', '    // Emergency Fix limited by time functions\n', '    function setVoteRight(address voter, uint ammount){\n', '        \n', '        // limited by [24 Jan 2017 00:00:00 GMT]\n', '        if (now > 1485216000) throw;\n', '\n', '        // limited by one account to fix \n', '        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\n', '\n', '        votingRights[voter] = ammount;\n', '    }\n', '    \n', '    // Emergency Fix limited by time functions\n', '    function setBalance(address owner, uint ammount){\n', '\n', '        // limited by [24 Jan 2017 00:00:00 GMT]\n', '        if (now > 1485216000) throw;\n', '        \n', '        // limited by one account to fix \n', '        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\n', '        \n', '        balances[owner] = ammount;\n', '    }\n', '    \n', '    // Emergency Fix limited by time functions\n', '    function setInternalInfo(address fixExecutive, uint fixTotalSupply, uint256 fixPreferedQtySold, \n', '            uint256 fixCollectedHKG, uint fixCollectedEther){\n', '\n', '        // limited by [24 Jan 2017 00:00:00 GMT]\n', '        if (now > 1485216000) throw;\n', '        \n', '        // limited by one account to fix \n', '        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\n', '        \n', '        executive = fixExecutive;\n', '        totalSupplyVar = fixTotalSupply;\n', '        preferedQtySold = fixPreferedQtySold;\n', '        collectedHKG = fixCollectedHKG;\n', '        collectedEther = fixCollectedEther;\n', '    }\n', '    \n', '    \n', '    // ********************* //\n', '    // *     Modifiers     * //\n', '    // ********************* //    \n', ' \n', '    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\n', '    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\n', '    \n', '    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\n', '    \n', '    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\n', '                                       \n', '    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \n', '    \n', '\n', '    // ****************** //\n', '    // *     Events     * //\n', '    // ****************** //        \n', '\n', '    \n', '    event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);\n', '    event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);\n', '    event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);\n', '\n', '    event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);\n', '    \n', '    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\n', '    \n', '    event EtherRedeemAccepted(address sender, uint value);\n', '    \n', '    event ObjectedVote(bytes32 id, address voter, uint votes);\n', '    \n', '    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\n', '    event ImpeachmentSupport(address supportter, uint votes);\n', '    \n', '    event ImpeachmentAccepted(address newExecutive);\n', '\n', '    event NewEtherPrice(uint newQtyForOneEther);\n', '    event DisableTokenIssuance();\n', '    \n', '    event BurnedAllRemainedTokens();\n', '    \n', '}']