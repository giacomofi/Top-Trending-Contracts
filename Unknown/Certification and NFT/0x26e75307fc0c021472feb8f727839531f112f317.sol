['pragma solidity 0.4.11;\n', '\n', 'contract SafeMath {\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  // mitigate short address attack\n', '  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '  // TODO: doublecheck implication of >= compared to ==\n', '  modifier onlyPayloadSize(uint numWords) {\n', '     assert(msg.data.length >= numWords * 32 + 4);\n', '     _;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Token { // ERC20 standard\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    // TODO: update tests to expect throw\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value && _value > 0);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // TODO: update tests to expect throw\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // To change the approve amount you first have to reduce the addresses'\n", "    //  allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _oldValue);\n', '        allowed[msg.sender][_spender] = _newValue;\n', '        Approval(msg.sender, _spender, _newValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '}\n', '\n', '\n', 'contract C20 is StandardToken {\n', '\n', '    // FIELDS\n', '\n', '    string public name = "Crypto20";\n', '    string public symbol = "C20";\n', '    uint256 public decimals = 18;\n', '    string public version = "9.0";\n', '\n', '    uint256 public tokenCap = 86206896 * 10**18;\n', '\n', '    // crowdsale parameters\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingEndBlock;\n', '\n', '    // vesting fields\n', '    address public vestingContract;\n', '    bool private vestingSet = false;\n', '\n', '    // root control\n', '    address public fundWallet;\n', '    // control of liquidity and limited control of updatePrice\n', '    address public controlWallet;\n', '    // time to wait between controlWallet price updates\n', '    uint256 public waitTime = 5 hours;\n', '\n', '    // fundWallet controlled state variables\n', '    // halted: halt buying due to emergency, tradeable: signal that assets have been acquired\n', '    bool public halted = false;\n', '    bool public tradeable = false;\n', '\n', '    // -- totalSupply defined in StandardToken\n', '    // -- mapping to token balances done in StandardToken\n', '\n', '    uint256 public previousUpdateTime = 0;\n', '    Price public currentPrice;\n', '    uint256 public minAmount = 0.04 ether;\n', '\n', '    // map participant address to a withdrawal request\n', '    mapping (address => Withdrawal) public withdrawals;\n', '    // maps previousUpdateTime to the next price\n', '    mapping (uint256 => Price) public prices;\n', '    // maps addresses\n', '    mapping (address => bool) public whitelist;\n', '\n', '    // TYPES\n', '\n', '    struct Price { // tokensPerEth\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '    }\n', '\n', '    struct Withdrawal {\n', '        uint256 tokens;\n', '        uint256 time; // time for each withdrawal is set to the previousUpdateTime\n', '    }\n', '\n', '    // EVENTS\n', '\n', '    event Buy(address indexed participant, address indexed beneficiary, uint256 ethValue, uint256 amountTokens);\n', '    event AllocatePresale(address indexed participant, uint256 amountTokens);\n', '    event Whitelist(address indexed participant);\n', '    event PriceUpdate(uint256 numerator, uint256 denominator);\n', '    event AddLiquidity(uint256 ethAmount);\n', '    event RemoveLiquidity(uint256 ethAmount);\n', '    event WithdrawRequest(address indexed participant, uint256 amountTokens);\n', '    event Withdraw(address indexed participant, uint256 amountTokens, uint256 etherAmount);\n', '\n', '    // MODIFIERS\n', '\n', '    modifier isTradeable { // exempt vestingContract and fundWallet to allow dev allocations\n', '        require(tradeable || msg.sender == fundWallet || msg.sender == vestingContract);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhitelist {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFundWallet {\n', '        require(msg.sender == fundWallet);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManagingWallets {\n', '        require(msg.sender == controlWallet || msg.sender == fundWallet);\n', '        _;\n', '    }\n', '\n', '    modifier only_if_controlWallet {\n', '        if (msg.sender == controlWallet) _;\n', '    }\n', '    modifier require_waited {\n', '        require(safeSub(now, waitTime) >= previousUpdateTime);\n', '        _;\n', '    }\n', '    modifier only_if_increase (uint256 newNumerator) {\n', '        if (newNumerator > currentPrice.numerator) _;\n', '    }\n', '\n', '    // CONSTRUCTOR\n', '\n', '    function C20(address controlWalletInput, uint256 priceNumeratorInput, uint256 startBlockInput, uint256 endBlockInput) {\n', '        require(controlWalletInput != address(0));\n', '        require(priceNumeratorInput > 0);\n', '        require(endBlockInput > startBlockInput);\n', '        fundWallet = msg.sender;\n', '        controlWallet = controlWalletInput;\n', '        whitelist[fundWallet] = true;\n', '        whitelist[controlWallet] = true;\n', '        currentPrice = Price(priceNumeratorInput, 1000); // 1 token = 1 usd at ICO start\n', '        fundingStartBlock = startBlockInput;\n', '        fundingEndBlock = endBlockInput;\n', '        previousUpdateTime = now;\n', '    }\n', '\n', '    // METHODS\n', '\n', '    function setVestingContract(address vestingContractInput) external onlyFundWallet {\n', '        require(vestingContractInput != address(0));\n', '        vestingContract = vestingContractInput;\n', '        whitelist[vestingContract] = true;\n', '        vestingSet = true;\n', '    }\n', '\n', '    // allows controlWallet to update the price within a time contstraint, allows fundWallet complete control\n', '    function updatePrice(uint256 newNumerator) external onlyManagingWallets {\n', '        require(newNumerator > 0);\n', '        require_limited_change(newNumerator);\n', '        // either controlWallet command is compliant or transaction came from fundWallet\n', '        currentPrice.numerator = newNumerator;\n', '        // maps time to new Price (if not during ICO)\n', '        prices[previousUpdateTime] = currentPrice;\n', '        previousUpdateTime = now;\n', '        PriceUpdate(newNumerator, currentPrice.denominator);\n', '    }\n', '\n', '    function require_limited_change (uint256 newNumerator)\n', '        private\n', '        only_if_controlWallet\n', '        require_waited\n', '        only_if_increase(newNumerator)\n', '    {\n', '        uint256 percentage_diff = 0;\n', '        percentage_diff = safeMul(newNumerator, 100) / currentPrice.numerator;\n', '        percentage_diff = safeSub(percentage_diff, 100);\n', '        // controlWallet can only increase price by max 20% and only every waitTime\n', '        require(percentage_diff <= 20);\n', '    }\n', '\n', '    function updatePriceDenominator(uint256 newDenominator) external onlyFundWallet {\n', '        require(block.number > fundingEndBlock);\n', '        require(newDenominator > 0);\n', '        currentPrice.denominator = newDenominator;\n', '        // maps time to new Price\n', '        prices[previousUpdateTime] = currentPrice;\n', '        previousUpdateTime = now;\n', '        PriceUpdate(currentPrice.numerator, newDenominator);\n', '    }\n', '\n', '    function allocateTokens(address participant, uint256 amountTokens) private {\n', '        require(vestingSet);\n', '        // 13% of total allocated for PR, Marketing, Team, Advisors\n', '        uint256 developmentAllocation = safeMul(amountTokens, 14942528735632185) / 100000000000000000;\n', '        // check that token cap is not exceeded\n', '        uint256 newTokens = safeAdd(amountTokens, developmentAllocation);\n', '        require(safeAdd(totalSupply, newTokens) <= tokenCap);\n', '        // increase token supply, assign tokens to participant\n', '        totalSupply = safeAdd(totalSupply, newTokens);\n', '        balances[participant] = safeAdd(balances[participant], amountTokens);\n', '        balances[vestingContract] = safeAdd(balances[vestingContract], developmentAllocation);\n', '    }\n', '\n', '    function allocatePresaleTokens(address participant, uint amountTokens) external onlyFundWallet {\n', '        require(block.number < fundingEndBlock);\n', '        require(participant != address(0));\n', '        whitelist[participant] = true; // automatically whitelist accepted presale\n', '        allocateTokens(participant, amountTokens);\n', '        Whitelist(participant);\n', '        AllocatePresale(participant, amountTokens);\n', '    }\n', '\n', '    function verifyParticipant(address participant) external onlyManagingWallets {\n', '        whitelist[participant] = true;\n', '        Whitelist(participant);\n', '    }\n', '\n', '    function buy() external payable {\n', '        buyTo(msg.sender);\n', '    }\n', '\n', '    function buyTo(address participant) public payable onlyWhitelist {\n', '        require(!halted);\n', '        require(participant != address(0));\n', '        require(msg.value >= minAmount);\n', '        require(block.number >= fundingStartBlock && block.number < fundingEndBlock);\n', '        uint256 icoDenominator = icoDenominatorPrice();\n', '        uint256 tokensToBuy = safeMul(msg.value, currentPrice.numerator) / icoDenominator;\n', '        allocateTokens(participant, tokensToBuy);\n', '        // send ether to fundWallet\n', '        fundWallet.transfer(msg.value);\n', '        Buy(msg.sender, participant, msg.value, tokensToBuy);\n', '    }\n', '\n', '    // time based on blocknumbers, assuming a blocktime of 30s\n', '    function icoDenominatorPrice() public constant returns (uint256) {\n', '        uint256 icoDuration = safeSub(block.number, fundingStartBlock);\n', '        uint256 denominator;\n', '        if (icoDuration < 2880) { // #blocks = 24*60*60/30 = 2880\n', '            return currentPrice.denominator;\n', '        } else if (icoDuration < 80640 ) { // #blocks = 4*7*24*60*60/30 = 80640\n', '            denominator = safeMul(currentPrice.denominator, 105) / 100;\n', '            return denominator;\n', '        } else {\n', '            denominator = safeMul(currentPrice.denominator, 110) / 100;\n', '            return denominator;\n', '        }\n', '    }\n', '\n', '    function requestWithdrawal(uint256 amountTokensToWithdraw) external isTradeable onlyWhitelist {\n', '        require(block.number > fundingEndBlock);\n', '        require(amountTokensToWithdraw > 0);\n', '        address participant = msg.sender;\n', '        require(balanceOf(participant) >= amountTokensToWithdraw);\n', '        require(withdrawals[participant].tokens == 0); // participant cannot have outstanding withdrawals\n', '        balances[participant] = safeSub(balances[participant], amountTokensToWithdraw);\n', '        withdrawals[participant] = Withdrawal({tokens: amountTokensToWithdraw, time: previousUpdateTime});\n', '        WithdrawRequest(participant, amountTokensToWithdraw);\n', '    }\n', '\n', '    function withdraw() external {\n', '        address participant = msg.sender;\n', '        uint256 tokens = withdrawals[participant].tokens;\n', '        require(tokens > 0); // participant must have requested a withdrawal\n', '        uint256 requestTime = withdrawals[participant].time;\n', '        // obtain the next price that was set after the request\n', '        Price price = prices[requestTime];\n', '        require(price.numerator > 0); // price must have been set\n', '        uint256 withdrawValue = safeMul(tokens, price.denominator) / price.numerator;\n', '        // if contract ethbal > then send + transfer tokens to fundWallet, otherwise give tokens back\n', '        withdrawals[participant].tokens = 0;\n', '        if (this.balance >= withdrawValue)\n', '            enact_withdrawal_greater_equal(participant, withdrawValue, tokens);\n', '        else\n', '            enact_withdrawal_less(participant, withdrawValue, tokens);\n', '    }\n', '\n', '    function enact_withdrawal_greater_equal(address participant, uint256 withdrawValue, uint256 tokens)\n', '        private\n', '    {\n', '        assert(this.balance >= withdrawValue);\n', '        balances[fundWallet] = safeAdd(balances[fundWallet], tokens);\n', '        participant.transfer(withdrawValue);\n', '        Withdraw(participant, tokens, withdrawValue);\n', '    }\n', '    function enact_withdrawal_less(address participant, uint256 withdrawValue, uint256 tokens)\n', '        private\n', '    {\n', '        assert(this.balance < withdrawValue);\n', '        balances[participant] = safeAdd(balances[participant], tokens);\n', '        Withdraw(participant, tokens, 0); // indicate a failed withdrawal\n', '    }\n', '\n', '\n', '    function checkWithdrawValue(uint256 amountTokensToWithdraw) constant returns (uint256 etherValue) {\n', '        require(amountTokensToWithdraw > 0);\n', '        require(balanceOf(msg.sender) >= amountTokensToWithdraw);\n', '        uint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\n', '        require(this.balance >= withdrawValue);\n', '        return withdrawValue;\n', '    }\n', '\n', '    // allow fundWallet or controlWallet to add ether to contract\n', '    function addLiquidity() external onlyManagingWallets payable {\n', '        require(msg.value > 0);\n', '        AddLiquidity(msg.value);\n', '    }\n', '\n', '    // allow fundWallet to remove ether from contract\n', '    function removeLiquidity(uint256 amount) external onlyManagingWallets {\n', '        require(amount <= this.balance);\n', '        fundWallet.transfer(amount);\n', '        RemoveLiquidity(amount);\n', '    }\n', '\n', '    function changeFundWallet(address newFundWallet) external onlyFundWallet {\n', '        require(newFundWallet != address(0));\n', '        fundWallet = newFundWallet;\n', '    }\n', '\n', '    function changeControlWallet(address newControlWallet) external onlyFundWallet {\n', '        require(newControlWallet != address(0));\n', '        controlWallet = newControlWallet;\n', '    }\n', '\n', '    function changeWaitTime(uint256 newWaitTime) external onlyFundWallet {\n', '        waitTime = newWaitTime;\n', '    }\n', '\n', '    function updateFundingStartBlock(uint256 newFundingStartBlock) external onlyFundWallet {\n', '        require(block.number < fundingStartBlock);\n', '        require(block.number < newFundingStartBlock);\n', '        fundingStartBlock = newFundingStartBlock;\n', '    }\n', '\n', '    function updateFundingEndBlock(uint256 newFundingEndBlock) external onlyFundWallet {\n', '        require(block.number < fundingEndBlock);\n', '        require(block.number < newFundingEndBlock);\n', '        fundingEndBlock = newFundingEndBlock;\n', '    }\n', '\n', '    function halt() external onlyFundWallet {\n', '        halted = true;\n', '    }\n', '    function unhalt() external onlyFundWallet {\n', '        halted = false;\n', '    }\n', '\n', '    function enableTrading() external onlyFundWallet {\n', '        require(block.number > fundingEndBlock);\n', '        tradeable = true;\n', '    }\n', '\n', '    // fallback function\n', '    function() payable {\n', '        require(tx.origin == msg.sender);\n', '        buyTo(msg.sender);\n', '    }\n', '\n', '    function claimTokens(address _token) external onlyFundWallet {\n', '        require(_token != address(0));\n', '        Token token = Token(_token);\n', '        uint256 balance = token.balanceOf(this);\n', '        token.transfer(fundWallet, balance);\n', '     }\n', '\n', '    // prevent transfers until trading allowed\n', '    function transfer(address _to, uint256 _value) isTradeable returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) isTradeable returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '}']