['pragma solidity ^0.4.11;\n', '\n', 'contract Mineable {\n', '    address public owner;\n', '    uint public supply = 100000000000000;\n', '    string public name = &#39;MineableBonusEthereumToken&#39;;\n', '    string public symbol = &#39;MBET&#39;;\n', '    uint8 public decimals = 8;\n', '    uint public price = 1 finney;\n', '    uint public durationInBlocks = 157553; // 1 month\n', '    uint public miningReward = 100000000;\n', '    uint public amountRaised;\n', '    uint public deadline;\n', '    uint public tokensSold;\n', '    uint private divider;\n', '    \n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public successesOf;\n', '    mapping (address => uint256) public failsOf;\n', '    \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '    \n', '    function isOwner() returns (bool isOwner) {\n', '        return msg.sender == owner;\n', '    }\n', '    \n', '    function addressIsOwner(address addr)  returns (bool isOwner) {\n', '        return addr == owner;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function Mineable() {\n', '        owner = msg.sender;\n', '        divider -= 1;\n', '        divider /= 1048576;\n', '        balanceOf[msg.sender] = supply;\n', '        deadline = block.number + durationInBlocks;\n', '    }\n', '    \n', '    function isCrowdsale() returns (bool isCrowdsale) {\n', '        return block.number < deadline;\n', '    }\n', '    \n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        /* if the sender doesnt have enough balance then stop */\n', '        if (balanceOf[msg.sender] < _value) revert();\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();\n', '        \n', '        /* Add and subtract new balances */\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        \n', '        /* Notify anyone listening that this transfer took place */\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function () payable {\n', '        if (isOwner()) {\n', '            owner.transfer(amountRaised);\n', '            FundTransfer(owner, amountRaised, false);\n', '            amountRaised = 0;\n', '        } else if (isCrowdsale()) {\n', '            uint amount = msg.value;\n', '            if (amount == 0) revert();\n', '            \n', '            uint tokensCount = amount * 100000000 / price;\n', '            if (tokensCount < 100000000) revert();\n', '            \n', '            balanceOf[msg.sender] += tokensCount;\n', '            supply += tokensCount;\n', '            tokensSold += tokensCount;\n', '            Transfer(0, this, tokensCount);\n', '            Transfer(this, msg.sender, tokensCount);\n', '            amountRaised += amount;\n', '        } else if (msg.value == 0) {\n', '            uint minedAtBlock = uint(block.blockhash(block.number - 1));\n', '            uint minedHashRel = uint(sha256(minedAtBlock + uint(msg.sender))) / divider;\n', '            uint balanceRel = balanceOf[msg.sender] * 1048576 / supply;\n', '            \n', '            if (minedHashRel < balanceRel * 933233 / 1048576 + 10485) {\n', '                uint reward = miningReward + minedHashRel * 10000;\n', '                balanceOf[msg.sender] += reward;\n', '                supply += reward;\n', '                Transfer(0, this, reward);\n', '                Transfer(this, msg.sender, reward);\n', '                successesOf[msg.sender]++;\n', '            } else {\n', '                failsOf[msg.sender]++;\n', '            }\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Mineable {\n', '    address public owner;\n', '    uint public supply = 100000000000000;\n', "    string public name = 'MineableBonusEthereumToken';\n", "    string public symbol = 'MBET';\n", '    uint8 public decimals = 8;\n', '    uint public price = 1 finney;\n', '    uint public durationInBlocks = 157553; // 1 month\n', '    uint public miningReward = 100000000;\n', '    uint public amountRaised;\n', '    uint public deadline;\n', '    uint public tokensSold;\n', '    uint private divider;\n', '    \n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public successesOf;\n', '    mapping (address => uint256) public failsOf;\n', '    \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '    \n', '    function isOwner() returns (bool isOwner) {\n', '        return msg.sender == owner;\n', '    }\n', '    \n', '    function addressIsOwner(address addr)  returns (bool isOwner) {\n', '        return addr == owner;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function Mineable() {\n', '        owner = msg.sender;\n', '        divider -= 1;\n', '        divider /= 1048576;\n', '        balanceOf[msg.sender] = supply;\n', '        deadline = block.number + durationInBlocks;\n', '    }\n', '    \n', '    function isCrowdsale() returns (bool isCrowdsale) {\n', '        return block.number < deadline;\n', '    }\n', '    \n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        /* if the sender doesnt have enough balance then stop */\n', '        if (balanceOf[msg.sender] < _value) revert();\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();\n', '        \n', '        /* Add and subtract new balances */\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        \n', '        /* Notify anyone listening that this transfer took place */\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function () payable {\n', '        if (isOwner()) {\n', '            owner.transfer(amountRaised);\n', '            FundTransfer(owner, amountRaised, false);\n', '            amountRaised = 0;\n', '        } else if (isCrowdsale()) {\n', '            uint amount = msg.value;\n', '            if (amount == 0) revert();\n', '            \n', '            uint tokensCount = amount * 100000000 / price;\n', '            if (tokensCount < 100000000) revert();\n', '            \n', '            balanceOf[msg.sender] += tokensCount;\n', '            supply += tokensCount;\n', '            tokensSold += tokensCount;\n', '            Transfer(0, this, tokensCount);\n', '            Transfer(this, msg.sender, tokensCount);\n', '            amountRaised += amount;\n', '        } else if (msg.value == 0) {\n', '            uint minedAtBlock = uint(block.blockhash(block.number - 1));\n', '            uint minedHashRel = uint(sha256(minedAtBlock + uint(msg.sender))) / divider;\n', '            uint balanceRel = balanceOf[msg.sender] * 1048576 / supply;\n', '            \n', '            if (minedHashRel < balanceRel * 933233 / 1048576 + 10485) {\n', '                uint reward = miningReward + minedHashRel * 10000;\n', '                balanceOf[msg.sender] += reward;\n', '                supply += reward;\n', '                Transfer(0, this, reward);\n', '                Transfer(this, msg.sender, reward);\n', '                successesOf[msg.sender]++;\n', '            } else {\n', '                failsOf[msg.sender]++;\n', '            }\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '}']
