['pragma solidity ^0.4.16;\n', '\n', 'contract SafeMath {\n', '     function safeMul(uint a, uint b) internal returns (uint) {\n', '          uint c = a * b;\n', '          assert(a == 0 || c / a == b);\n', '          return c;\n', '     }\n', '\n', '     function safeSub(uint a, uint b) internal returns (uint) {\n', '          assert(b <= a);\n', '          return a - b;\n', '     }\n', '\n', '     function safeAdd(uint a, uint b) internal returns (uint) {\n', '          uint c = a + b;\n', '          assert(c>=a && c>=b);\n', '          return c;\n', '     }\n', '}\n', '\n', '// ERC20 standard\n', '// We don&#39;t use ERC23 standard\n', 'contract StdToken is SafeMath {\n', '// Fields:\n', '     mapping(address => uint256) balances;\n', '     mapping (address => mapping (address => uint256)) allowed;\n', '     uint public totalSupply = 0;\n', '\n', '// Events:\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '// Functions:\n', '     function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool){\n', '          require(balances[msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '          Transfer(msg.sender, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function transferFrom(address _from, address _to, uint256 _value) returns(bool){\n', '          require(balances[_from] >= _value);\n', '          require(allowed[_from][msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '          balances[_from] = safeSub(balances[_from],_value);\n', '          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '\n', '          Transfer(_from, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function balanceOf(address _owner) constant returns (uint256) {\n', '          return balances[_owner];\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value) returns (bool) {\n', '          // To change the approve amount you first have to reduce the addresses`\n', '          //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '          //  already 0 to mitigate the race condition described here:\n', '          //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '          require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '          allowed[msg.sender][_spender] = _value;\n', '          Approval(msg.sender, _spender, _value);\n', '          return true;\n', '     }\n', '\n', '     function allowance(address _owner, address _spender) constant returns (uint256) {\n', '          return allowed[_owner][_spender];\n', '     }\n', '\n', '     modifier onlyPayloadSize(uint _size) {\n', '          require(msg.data.length >= _size + 4);\n', '          _;\n', '     }\n', '}\n', '\n', 'contract MNTP is StdToken {\n', '// Fields:\n', '     string public constant name = "Goldmint MNT Prelaunch Token";\n', '     string public constant symbol = "MNTP";\n', '     uint public constant decimals = 18;\n', '\n', '     address public creator = 0x0;\n', '     address public icoContractAddress = 0x0;\n', '     bool public lockTransfers = false;\n', '\n', '     // 10 mln\n', '     uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * 1 ether;\n', '\n', '/// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender == creator); \n', '          _; \n', '     }\n', '\n', '     modifier byIcoContract() { \n', '          require(msg.sender == icoContractAddress); \n', '          _; \n', '     }\n', '\n', '     function setCreator(address _creator) onlyCreator {\n', '          creator = _creator;\n', '     }\n', '\n', '// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '// Functions:\n', '     function MNTP() {\n', '          creator = msg.sender;\n', '\n', '          assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether);\n', '     }\n', '\n', '     /// @dev Override\n', '     function transfer(address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transfer(_to,_value);\n', '     }\n', '\n', '     /// @dev Override\n', '     function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transferFrom(_from,_to,_value);\n', '     }\n', '\n', '     function issueTokens(address _who, uint _tokens) byIcoContract {\n', '          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\n', '\n', '          balances[_who] = safeAdd(balances[_who],_tokens);\n', '          totalSupply = safeAdd(totalSupply,_tokens);\n', '\n', '          Transfer(0x0, _who, _tokens);\n', '     }\n', '\n', '     // For refunds only\n', '     function burnTokens(address _who, uint _tokens) byIcoContract {\n', '          balances[_who] = safeSub(balances[_who], _tokens);\n', '          totalSupply = safeSub(totalSupply, _tokens);\n', '     }\n', '\n', '     function lockTransfer(bool _lock) byIcoContract {\n', '          lockTransfers = _lock;\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() {\n', '          revert();\n', '     }\n', '}\n', '\n', '// This contract will hold all tokens that were unsold during ICO.\n', '//\n', '// Goldmint Team should be able to withdraw them and sell only after 1 year is passed after \n', '// ICO is finished.\n', 'contract GoldmintUnsold is SafeMath {\n', '     address public creator;\n', '     address public teamAccountAddress;\n', '     address public icoContractAddress;\n', '     uint64 public icoIsFinishedDate;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){\n', '          creator = msg.sender;\n', '          teamAccountAddress = _teamAccountAddress;\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '     }\n', '\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '\n', '     modifier onlyIcoContract() { \n', '          require(msg.sender==icoContractAddress); \n', '          _; \n', '     }\n', '\n', '// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '     function finishIco() public onlyIcoContract {\n', '          icoIsFinishedDate = uint64(now);\n', '     }\n', '\n', '     // can be called by anyone...\n', '     function withdrawTokens() public {\n', '          // Check if 1 year is passed\n', '          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \n', '          require(uint(now) >= oneYearPassed);\n', '\n', '          // Transfer all tokens from this contract to the teamAccountAddress\n', '          uint total = mntToken.balanceOf(this);\n', '          mntToken.transfer(teamAccountAddress,total);\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() payable {\n', '          revert();\n', '     }\n', '}\n', '\n', 'contract FoundersVesting is SafeMath {\n', '     address public creator;\n', '     address public teamAccountAddress;\n', '     uint64 public lastWithdrawTime;\n', '\n', '     uint public withdrawsCount = 0;\n', '     uint public amountToSend = 0;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){\n', '          teamAccountAddress = _teamAccountAddress;\n', '          lastWithdrawTime = uint64(now);\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '\n', '          creator = msg.sender;\n', '     }\n', '\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '\n', '     function withdrawTokens() onlyCreator public {\n', '          // 1 - wait for the next month\n', '          uint64 oneMonth = lastWithdrawTime + 30 days;  \n', '          require(uint(now) >= oneMonth);\n', '\n', '          // 2 - calculate amount (only first time)\n', '          if(withdrawsCount==0){\n', '               amountToSend = mntToken.balanceOf(this) / 10;\n', '          }\n', '\n', '          require(amountToSend!=0);\n', '\n', '          // 3 - send 1/10th\n', '          uint currentBalance = mntToken.balanceOf(this);\n', '          if(currentBalance<amountToSend){\n', '             amountToSend = currentBalance;  \n', '          }\n', '          mntToken.transfer(teamAccountAddress,amountToSend);\n', '\n', '          // 4 - update counter\n', '          withdrawsCount++;\n', '          lastWithdrawTime = uint64(now);\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() payable {\n', '          revert();\n', '     }\n', '}\n', '\n', '// This is the main Goldmint ICO smart contract\n', 'contract Goldmint is SafeMath {\n', '// Constants:\n', '     // These values are HARD CODED!!!\n', '     // For extra security we split single multisig wallet into 10 separate multisig wallets\n', '     //\n', '     // THIS IS A REAL ICO WALLETS!!!\n', '     // PLEASE DOUBLE CHECK THAT...\n', '     address[] public multisigs = [\n', '          0xcec42e247097c276ad3d7cfd270adbd562da5c61,\n', '          0x373c46c544662b8c5d55c24cf4f9a5020163ec2f,\n', '          0x672cf829272339a6c8c11b14acc5f9d07bafac7c,\n', '          0xce0e1981a19a57ae808a7575a6738e4527fb9118,\n', '          0x93aa76cdb17eea80e4de983108ef575d8fc8f12b,\n', '          0x20ae3329cd1e35feff7115b46218c9d056d430fd,\n', '          0xe9fc1a57a5dc1caa3de22a940e9f09e640615f7e,\n', '          0xd360433950de9f6fa0e93c29425845eed6bfa0d0,\n', '          0xf0de97eaff5d6c998c80e07746c81a336e1bbd43,\n', '          0x80b365da1C18f4aa1ecFa0dFA07Ed4417B05Cc69\n', '     ];\n', '\n', '     // We count ETH invested by person, for refunds (see below)\n', '     mapping(address => uint) ethInvestedBy;\n', '     uint collectedWei = 0;\n', '\n', '     // These can be changed before ICO starts ($7USD/MNTP)\n', '     uint constant STD_PRICE_USD_PER_1000_TOKENS = 7000;\n', '\n', '     // The USD/ETH exchange rate may be changed every hour and can vary from $100 to $700 depending on the market. The exchange rate is retrieved from coinmarketcap.com site and is rounded to $1 dollar. For example if current marketcap price is $306.123 per ETH, the price is set as $306 to the contract.\n', '     uint public usdPerEthCoinmarketcapRate = 300;\n', '     uint64 public lastUsdPerEthChangeDate = 0;\n', '\n', '     // Price changes from block to block\n', '     //uint constant SINGLE_BLOCK_LEN = 700000;\n', '     // TODO: for test\n', '     uint constant SINGLE_BLOCK_LEN = 100;\n', '\n', '     // 1 000 000 tokens\n', '     uint public constant BONUS_REWARD = 1000000 * 1 ether;\n', '     // 2 000 000 tokens\n', '     uint public constant FOUNDERS_REWARD = 2000000 * 1 ether;\n', '     // 7 000 000 is sold during the ICO\n', '     //uint public constant ICO_TOKEN_SUPPLY_LIMIT = 7000000 * 1 ether;\n', '\n', '     // TODO: for tests only!\n', '     uint public constant ICO_TOKEN_SUPPLY_LIMIT = 250 * 1 ether;\n', '\n', '     // 150 000 tokens soft cap (otherwise - refund)\n', '     uint public constant ICO_TOKEN_SOFT_CAP = 150000 * 1 ether;\n', '\n', '     // 3 000 000 can be issued from other currencies\n', '     uint public constant MAX_ISSUED_FROM_OTHER_CURRENCIES = 3000000 * 1 ether;\n', '     // 30 000 MNTP tokens per one call only\n', '     uint public constant MAX_SINGLE_ISSUED_FROM_OTHER_CURRENCIES = 30000 * 1 ether;\n', '     uint public issuedFromOtherCurrencies = 0;\n', '\n', '// Fields:\n', '     address public creator = 0x0;                // can not be changed after deploy\n', '     address public ethRateChanger = 0x0;         // can not be changed after deploy\n', '     address public tokenManager = 0x0;           // can be changed by token manager only\n', '     address public otherCurrenciesChecker = 0x0; // can not be changed after deploy\n', '\n', '     uint64 public icoStartedTime = 0;\n', '\n', '     MNTP public mntToken; \n', '\n', '     GoldmintUnsold public unsoldContract;\n', '\n', '     // Total amount of tokens sold during ICO\n', '     uint public icoTokensSold = 0;\n', '     // Total amount of tokens sent to GoldmintUnsold contract after ICO is finished\n', '     uint public icoTokensUnsold = 0;\n', '     // Total number of tokens that were issued by a scripts\n', '     uint public issuedExternallyTokens = 0;\n', '     // This is where FOUNDERS_REWARD will be allocated\n', '     address public foundersRewardsAccount = 0x0;\n', '\n', '     enum State{\n', '          Init,\n', '\n', '          ICORunning,\n', '          ICOPaused,\n', '\n', '          // Collected ETH is transferred to multisigs.\n', '          // Unsold tokens transferred to GoldmintUnsold contract.\n', '          ICOFinished,\n', '\n', '          // We start to refund if Soft Cap is not reached.\n', '          // Then each token holder should request a refund personally from his\n', '          // personal wallet.\n', '          //\n', '          // We will return ETHs only to the original address. If your address is changed\n', '          // or you have lost your keys -> you will not be able to get a refund.\n', '          // \n', '          // There is no any possibility to transfer tokens\n', '          // There is no any possibility to move back\n', '          Refunding,\n', '\n', '          // In this state we lock all MNT tokens forever.\n', '          // We are going to migrate MNTP -> MNT tokens during this stage. \n', '          // \n', '          // There is no any possibility to transfer tokens\n', '          // There is no any possibility to move back\n', '          Migrating\n', '     }\n', '     State public currentState = State.Init;\n', '\n', '// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '     modifier onlyTokenManager() { \n', '          require(msg.sender==tokenManager); \n', '          _; \n', '     }\n', '     modifier onlyOtherCurrenciesChecker() { \n', '          require(msg.sender==otherCurrenciesChecker); \n', '          _; \n', '     }\n', '     modifier onlyEthSetter() { \n', '          require(msg.sender==ethRateChanger); \n', '          _; \n', '     }\n', '\n', '     modifier onlyInState(State state){ \n', '          require(state==currentState); \n', '          _; \n', '     }\n', '\n', '// Events:\n', '     event LogStateSwitch(State newState);\n', '     event LogBuy(address indexed owner, uint value);\n', '     event LogBurn(address indexed owner, uint value);\n', '     \n', '// Functions:\n', '     /// @dev Constructor\n', '     function Goldmint(\n', '          address _tokenManager,\n', '          address _ethRateChanger,\n', '          address _otherCurrenciesChecker,\n', '\n', '          address _mntTokenAddress,\n', '          address _unsoldContractAddress,\n', '          address _foundersVestingAddress)\n', '     {\n', '          creator = msg.sender;\n', '\n', '          tokenManager = _tokenManager;\n', '          ethRateChanger = _ethRateChanger;\n', '          lastUsdPerEthChangeDate = uint64(now);\n', '\n', '          otherCurrenciesChecker = _otherCurrenciesChecker; \n', '\n', '          mntToken = MNTP(_mntTokenAddress);\n', '          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\n', '\n', '          // slight rename\n', '          foundersRewardsAccount = _foundersVestingAddress;\n', '\n', '          assert(multisigs.length==10);\n', '     }\n', '\n', '     function startICO() public onlyCreator onlyInState(State.Init) {\n', '          setState(State.ICORunning);\n', '          icoStartedTime = uint64(now);\n', '          mntToken.lockTransfer(true);\n', '          mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD);\n', '     }\n', '\n', '     function pauseICO() public onlyCreator onlyInState(State.ICORunning) {\n', '          setState(State.ICOPaused);\n', '     }\n', '\n', '     function resumeICO() public onlyCreator onlyInState(State.ICOPaused) {\n', '          setState(State.ICORunning);\n', '     }\n', '\n', '     function startRefunding() public onlyCreator onlyInState(State.ICORunning) {\n', '          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\n', '          require(icoTokensSold < ICO_TOKEN_SOFT_CAP);\n', '          setState(State.Refunding);\n', '\n', '          // in this state tokens still shouldn&#39;t be transferred\n', '          assert(mntToken.lockTransfers());\n', '     }\n', '\n', '     function startMigration() public onlyCreator onlyInState(State.ICOFinished) {\n', '          // there is no way back...\n', '          setState(State.Migrating);\n', '\n', '          // disable token transfers\n', '          mntToken.lockTransfer(true);\n', '     }\n', '\n', '     /// @dev This function can be called by creator at any time,\n', '     /// or by anyone if ICO has really finished.\n', '     function finishICO() public onlyInState(State.ICORunning) {\n', '          require(msg.sender == creator || isIcoFinished());\n', '          setState(State.ICOFinished);\n', '\n', '          // 1 - lock all transfers\n', '          mntToken.lockTransfer(false);\n', '\n', '          // 2 - move all unsold tokens to unsoldTokens contract\n', '          icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\n', '          if(icoTokensUnsold>0){\n', '               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\n', '               unsoldContract.finishIco();\n', '          }\n', '\n', '          // 3 - send all ETH to multisigs\n', '          // we have N separate multisigs for extra security\n', '          uint sendThisAmount = (this.balance / 10);\n', '\n', '          // 3.1 - send to 9 multisigs\n', '          for(uint i=0; i<9; ++i){\n', '               address ms = multisigs[i];\n', '\n', '               if(this.balance>=sendThisAmount){\n', '                    ms.transfer(sendThisAmount);\n', '               }\n', '          }\n', '\n', '          // 3.2 - send everything left to 10th multisig\n', '          if(0!=this.balance){\n', '               address lastMs = multisigs[9];\n', '               lastMs.transfer(this.balance);\n', '          }\n', '     }\n', '\n', '     function setState(State _s) internal {\n', '          currentState = _s;\n', '          LogStateSwitch(_s);\n', '     }\n', '\n', '// Access methods:\n', '     function setTokenManager(address _new) public onlyTokenManager {\n', '          tokenManager = _new;\n', '     }\n', '\n', '     // TODO: stealing creator&#39;s key means stealing otherCurrenciesChecker key too!\n', '     /*\n', '     function setOtherCurrenciesChecker(address _new) public onlyCreator {\n', '          otherCurrenciesChecker = _new;\n', '     }\n', '     */\n', '\n', '     // These are used by frontend so we can not remove them\n', '     function getTokensIcoSold() constant public returns (uint){          \n', '          return icoTokensSold;       \n', '     }      \n', '     \n', '     function getTotalIcoTokens() constant public returns (uint){          \n', '          return ICO_TOKEN_SUPPLY_LIMIT;         \n', '     }       \n', '     \n', '     function getMntTokenBalance(address _of) constant public returns (uint){         \n', '          return mntToken.balanceOf(_of);         \n', '     }        \n', '\n', '     function getBlockLength()constant public returns (uint){          \n', '          return SINGLE_BLOCK_LEN;      \n', '     }\n', '\n', '     function getCurrentPrice()constant public returns (uint){\n', '          return getMntTokensPerEth(icoTokensSold);\n', '     }\n', '\n', '     function getTotalCollectedWei()constant public returns (uint){\n', '          return collectedWei;\n', '     }\n', '\n', '/////////////////////////////\n', '     function isIcoFinished() constant public returns(bool) {\n', '          return (icoStartedTime > 0)\n', '            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT));\n', '     }\n', '\n', '     function getMntTokensPerEth(uint _tokensSold) public constant returns (uint){\n', '          // 10 buckets\n', '          uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN;\n', '          assert(priceIndex>=0 && (priceIndex<=9));\n', '          \n', '          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\n', '\n', '          // We have to multiply by &#39;1 ether&#39; to avoid float truncations\n', '          // Example: ($7000 * 100) / 120 = $5833.33333\n', '          uint pricePer1000tokensUsd = \n', '               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex]);\n', '\n', '          // Correct: 300000 / 5833.33333333 = 51.42857142\n', '          // We have to multiply by &#39;1 ether&#39; to avoid float truncations\n', '          uint mntPerEth = (usdPerEthCoinmarketcapRate * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd;\n', '          return mntPerEth;\n', '     }\n', '\n', '     function buyTokens(address _buyer) public payable onlyInState(State.ICORunning) {\n', '          require(msg.value!=0);\n', '\n', '          // The price is selected based on current sold tokens.\n', '          // Price can &#39;overlap&#39;. For example:\n', '          //   1. if currently we sold 699950 tokens (the price is 10% discount)\n', '          //   2. buyer buys 1000 tokens\n', '          //   3. the price of all 1000 tokens would be with 10% discount!!!\n', '          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether;\n', '\n', '          issueTokensInternal(_buyer,newTokens);\n', '\n', '          // Update this only when buying from ETH\n', '          ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value);\n', '\n', '          // This is total collected ETH\n', '          collectedWei = safeAdd(collectedWei, msg.value);\n', '     }\n', '\n', '     /// @dev This is called by other currency processors to issue new tokens \n', '     function issueTokensFromOtherCurrency(address _to, uint _weiCount) onlyInState(State.ICORunning) public onlyOtherCurrenciesChecker {\n', '          require(_weiCount!=0);\n', '\n', '          uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether;\n', '          \n', '          require(newTokens<=MAX_SINGLE_ISSUED_FROM_OTHER_CURRENCIES);\n', '          require((issuedFromOtherCurrencies + newTokens)<=MAX_ISSUED_FROM_OTHER_CURRENCIES);\n', '\n', '          issueTokensInternal(_to,newTokens);\n', '\n', '          issuedFromOtherCurrencies = issuedFromOtherCurrencies + newTokens;\n', '     }\n', '\n', '     /// @dev This can be called to manually issue new tokens \n', '     /// from the bonus reward\n', '     function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\n', '          // can not issue more than BONUS_REWARD\n', '          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\n', '\n', '          mntToken.issueTokens(_to,_tokens);\n', '\n', '          issuedExternallyTokens = issuedExternallyTokens + _tokens;\n', '     }\n', '\n', '     function issueTokensInternal(address _to, uint _tokens) internal {\n', '          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\n', '\n', '          mntToken.issueTokens(_to,_tokens); \n', '          icoTokensSold+=_tokens;\n', '\n', '          LogBuy(_to,_tokens);\n', '     }\n', '\n', '     // anyone can call this and get his money back\n', '     function getMyRefund() public onlyInState(State.Refunding) {\n', '          address sender = msg.sender;\n', '          uint ethValue = ethInvestedBy[sender];\n', '\n', '          require(ethValue > 0);\n', '\n', '          // 1 - send money back\n', '          sender.transfer(ethValue);\n', '          ethInvestedBy[sender] = 0;\n', '\n', '          // 2 - burn tokens\n', '          mntToken.burnTokens(sender, mntToken.balanceOf(sender));\n', '     }\n', '\n', '     function setUsdPerEthRate(uint _usdPerEthRate) public onlyEthSetter {\n', '          // 1 - check\n', '          require((_usdPerEthRate>=100) && (_usdPerEthRate<=700));\n', '          uint64 hoursPassed = lastUsdPerEthChangeDate + 1 hours;  \n', '          require(uint(now) >= hoursPassed);\n', '\n', '          // 2 - update\n', '          usdPerEthCoinmarketcapRate = _usdPerEthRate;\n', '          lastUsdPerEthChangeDate = uint64(now);\n', '     }\n', '\n', '     // Default fallback function\n', '     function() payable {\n', '          // buyTokens -> issueTokensInternal\n', '          buyTokens(msg.sender);\n', '     }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract SafeMath {\n', '     function safeMul(uint a, uint b) internal returns (uint) {\n', '          uint c = a * b;\n', '          assert(a == 0 || c / a == b);\n', '          return c;\n', '     }\n', '\n', '     function safeSub(uint a, uint b) internal returns (uint) {\n', '          assert(b <= a);\n', '          return a - b;\n', '     }\n', '\n', '     function safeAdd(uint a, uint b) internal returns (uint) {\n', '          uint c = a + b;\n', '          assert(c>=a && c>=b);\n', '          return c;\n', '     }\n', '}\n', '\n', '// ERC20 standard\n', "// We don't use ERC23 standard\n", 'contract StdToken is SafeMath {\n', '// Fields:\n', '     mapping(address => uint256) balances;\n', '     mapping (address => mapping (address => uint256)) allowed;\n', '     uint public totalSupply = 0;\n', '\n', '// Events:\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '// Functions:\n', '     function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool){\n', '          require(balances[msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '          Transfer(msg.sender, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function transferFrom(address _from, address _to, uint256 _value) returns(bool){\n', '          require(balances[_from] >= _value);\n', '          require(allowed[_from][msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '          balances[_from] = safeSub(balances[_from],_value);\n', '          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '\n', '          Transfer(_from, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function balanceOf(address _owner) constant returns (uint256) {\n', '          return balances[_owner];\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value) returns (bool) {\n', '          // To change the approve amount you first have to reduce the addresses`\n', '          //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '          //  already 0 to mitigate the race condition described here:\n', '          //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '          require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '          allowed[msg.sender][_spender] = _value;\n', '          Approval(msg.sender, _spender, _value);\n', '          return true;\n', '     }\n', '\n', '     function allowance(address _owner, address _spender) constant returns (uint256) {\n', '          return allowed[_owner][_spender];\n', '     }\n', '\n', '     modifier onlyPayloadSize(uint _size) {\n', '          require(msg.data.length >= _size + 4);\n', '          _;\n', '     }\n', '}\n', '\n', 'contract MNTP is StdToken {\n', '// Fields:\n', '     string public constant name = "Goldmint MNT Prelaunch Token";\n', '     string public constant symbol = "MNTP";\n', '     uint public constant decimals = 18;\n', '\n', '     address public creator = 0x0;\n', '     address public icoContractAddress = 0x0;\n', '     bool public lockTransfers = false;\n', '\n', '     // 10 mln\n', '     uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * 1 ether;\n', '\n', '/// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender == creator); \n', '          _; \n', '     }\n', '\n', '     modifier byIcoContract() { \n', '          require(msg.sender == icoContractAddress); \n', '          _; \n', '     }\n', '\n', '     function setCreator(address _creator) onlyCreator {\n', '          creator = _creator;\n', '     }\n', '\n', '// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '// Functions:\n', '     function MNTP() {\n', '          creator = msg.sender;\n', '\n', '          assert(TOTAL_TOKEN_SUPPLY == 10000000 * 1 ether);\n', '     }\n', '\n', '     /// @dev Override\n', '     function transfer(address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transfer(_to,_value);\n', '     }\n', '\n', '     /// @dev Override\n', '     function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transferFrom(_from,_to,_value);\n', '     }\n', '\n', '     function issueTokens(address _who, uint _tokens) byIcoContract {\n', '          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\n', '\n', '          balances[_who] = safeAdd(balances[_who],_tokens);\n', '          totalSupply = safeAdd(totalSupply,_tokens);\n', '\n', '          Transfer(0x0, _who, _tokens);\n', '     }\n', '\n', '     // For refunds only\n', '     function burnTokens(address _who, uint _tokens) byIcoContract {\n', '          balances[_who] = safeSub(balances[_who], _tokens);\n', '          totalSupply = safeSub(totalSupply, _tokens);\n', '     }\n', '\n', '     function lockTransfer(bool _lock) byIcoContract {\n', '          lockTransfers = _lock;\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() {\n', '          revert();\n', '     }\n', '}\n', '\n', '// This contract will hold all tokens that were unsold during ICO.\n', '//\n', '// Goldmint Team should be able to withdraw them and sell only after 1 year is passed after \n', '// ICO is finished.\n', 'contract GoldmintUnsold is SafeMath {\n', '     address public creator;\n', '     address public teamAccountAddress;\n', '     address public icoContractAddress;\n', '     uint64 public icoIsFinishedDate;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){\n', '          creator = msg.sender;\n', '          teamAccountAddress = _teamAccountAddress;\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '     }\n', '\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '\n', '     modifier onlyIcoContract() { \n', '          require(msg.sender==icoContractAddress); \n', '          _; \n', '     }\n', '\n', '// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '     function finishIco() public onlyIcoContract {\n', '          icoIsFinishedDate = uint64(now);\n', '     }\n', '\n', '     // can be called by anyone...\n', '     function withdrawTokens() public {\n', '          // Check if 1 year is passed\n', '          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \n', '          require(uint(now) >= oneYearPassed);\n', '\n', '          // Transfer all tokens from this contract to the teamAccountAddress\n', '          uint total = mntToken.balanceOf(this);\n', '          mntToken.transfer(teamAccountAddress,total);\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() payable {\n', '          revert();\n', '     }\n', '}\n', '\n', 'contract FoundersVesting is SafeMath {\n', '     address public creator;\n', '     address public teamAccountAddress;\n', '     uint64 public lastWithdrawTime;\n', '\n', '     uint public withdrawsCount = 0;\n', '     uint public amountToSend = 0;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){\n', '          teamAccountAddress = _teamAccountAddress;\n', '          lastWithdrawTime = uint64(now);\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '\n', '          creator = msg.sender;\n', '     }\n', '\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '\n', '     function withdrawTokens() onlyCreator public {\n', '          // 1 - wait for the next month\n', '          uint64 oneMonth = lastWithdrawTime + 30 days;  \n', '          require(uint(now) >= oneMonth);\n', '\n', '          // 2 - calculate amount (only first time)\n', '          if(withdrawsCount==0){\n', '               amountToSend = mntToken.balanceOf(this) / 10;\n', '          }\n', '\n', '          require(amountToSend!=0);\n', '\n', '          // 3 - send 1/10th\n', '          uint currentBalance = mntToken.balanceOf(this);\n', '          if(currentBalance<amountToSend){\n', '             amountToSend = currentBalance;  \n', '          }\n', '          mntToken.transfer(teamAccountAddress,amountToSend);\n', '\n', '          // 4 - update counter\n', '          withdrawsCount++;\n', '          lastWithdrawTime = uint64(now);\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() payable {\n', '          revert();\n', '     }\n', '}\n', '\n', '// This is the main Goldmint ICO smart contract\n', 'contract Goldmint is SafeMath {\n', '// Constants:\n', '     // These values are HARD CODED!!!\n', '     // For extra security we split single multisig wallet into 10 separate multisig wallets\n', '     //\n', '     // THIS IS A REAL ICO WALLETS!!!\n', '     // PLEASE DOUBLE CHECK THAT...\n', '     address[] public multisigs = [\n', '          0xcec42e247097c276ad3d7cfd270adbd562da5c61,\n', '          0x373c46c544662b8c5d55c24cf4f9a5020163ec2f,\n', '          0x672cf829272339a6c8c11b14acc5f9d07bafac7c,\n', '          0xce0e1981a19a57ae808a7575a6738e4527fb9118,\n', '          0x93aa76cdb17eea80e4de983108ef575d8fc8f12b,\n', '          0x20ae3329cd1e35feff7115b46218c9d056d430fd,\n', '          0xe9fc1a57a5dc1caa3de22a940e9f09e640615f7e,\n', '          0xd360433950de9f6fa0e93c29425845eed6bfa0d0,\n', '          0xf0de97eaff5d6c998c80e07746c81a336e1bbd43,\n', '          0x80b365da1C18f4aa1ecFa0dFA07Ed4417B05Cc69\n', '     ];\n', '\n', '     // We count ETH invested by person, for refunds (see below)\n', '     mapping(address => uint) ethInvestedBy;\n', '     uint collectedWei = 0;\n', '\n', '     // These can be changed before ICO starts ($7USD/MNTP)\n', '     uint constant STD_PRICE_USD_PER_1000_TOKENS = 7000;\n', '\n', '     // The USD/ETH exchange rate may be changed every hour and can vary from $100 to $700 depending on the market. The exchange rate is retrieved from coinmarketcap.com site and is rounded to $1 dollar. For example if current marketcap price is $306.123 per ETH, the price is set as $306 to the contract.\n', '     uint public usdPerEthCoinmarketcapRate = 300;\n', '     uint64 public lastUsdPerEthChangeDate = 0;\n', '\n', '     // Price changes from block to block\n', '     //uint constant SINGLE_BLOCK_LEN = 700000;\n', '     // TODO: for test\n', '     uint constant SINGLE_BLOCK_LEN = 100;\n', '\n', '     // 1 000 000 tokens\n', '     uint public constant BONUS_REWARD = 1000000 * 1 ether;\n', '     // 2 000 000 tokens\n', '     uint public constant FOUNDERS_REWARD = 2000000 * 1 ether;\n', '     // 7 000 000 is sold during the ICO\n', '     //uint public constant ICO_TOKEN_SUPPLY_LIMIT = 7000000 * 1 ether;\n', '\n', '     // TODO: for tests only!\n', '     uint public constant ICO_TOKEN_SUPPLY_LIMIT = 250 * 1 ether;\n', '\n', '     // 150 000 tokens soft cap (otherwise - refund)\n', '     uint public constant ICO_TOKEN_SOFT_CAP = 150000 * 1 ether;\n', '\n', '     // 3 000 000 can be issued from other currencies\n', '     uint public constant MAX_ISSUED_FROM_OTHER_CURRENCIES = 3000000 * 1 ether;\n', '     // 30 000 MNTP tokens per one call only\n', '     uint public constant MAX_SINGLE_ISSUED_FROM_OTHER_CURRENCIES = 30000 * 1 ether;\n', '     uint public issuedFromOtherCurrencies = 0;\n', '\n', '// Fields:\n', '     address public creator = 0x0;                // can not be changed after deploy\n', '     address public ethRateChanger = 0x0;         // can not be changed after deploy\n', '     address public tokenManager = 0x0;           // can be changed by token manager only\n', '     address public otherCurrenciesChecker = 0x0; // can not be changed after deploy\n', '\n', '     uint64 public icoStartedTime = 0;\n', '\n', '     MNTP public mntToken; \n', '\n', '     GoldmintUnsold public unsoldContract;\n', '\n', '     // Total amount of tokens sold during ICO\n', '     uint public icoTokensSold = 0;\n', '     // Total amount of tokens sent to GoldmintUnsold contract after ICO is finished\n', '     uint public icoTokensUnsold = 0;\n', '     // Total number of tokens that were issued by a scripts\n', '     uint public issuedExternallyTokens = 0;\n', '     // This is where FOUNDERS_REWARD will be allocated\n', '     address public foundersRewardsAccount = 0x0;\n', '\n', '     enum State{\n', '          Init,\n', '\n', '          ICORunning,\n', '          ICOPaused,\n', '\n', '          // Collected ETH is transferred to multisigs.\n', '          // Unsold tokens transferred to GoldmintUnsold contract.\n', '          ICOFinished,\n', '\n', '          // We start to refund if Soft Cap is not reached.\n', '          // Then each token holder should request a refund personally from his\n', '          // personal wallet.\n', '          //\n', '          // We will return ETHs only to the original address. If your address is changed\n', '          // or you have lost your keys -> you will not be able to get a refund.\n', '          // \n', '          // There is no any possibility to transfer tokens\n', '          // There is no any possibility to move back\n', '          Refunding,\n', '\n', '          // In this state we lock all MNT tokens forever.\n', '          // We are going to migrate MNTP -> MNT tokens during this stage. \n', '          // \n', '          // There is no any possibility to transfer tokens\n', '          // There is no any possibility to move back\n', '          Migrating\n', '     }\n', '     State public currentState = State.Init;\n', '\n', '// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '     modifier onlyTokenManager() { \n', '          require(msg.sender==tokenManager); \n', '          _; \n', '     }\n', '     modifier onlyOtherCurrenciesChecker() { \n', '          require(msg.sender==otherCurrenciesChecker); \n', '          _; \n', '     }\n', '     modifier onlyEthSetter() { \n', '          require(msg.sender==ethRateChanger); \n', '          _; \n', '     }\n', '\n', '     modifier onlyInState(State state){ \n', '          require(state==currentState); \n', '          _; \n', '     }\n', '\n', '// Events:\n', '     event LogStateSwitch(State newState);\n', '     event LogBuy(address indexed owner, uint value);\n', '     event LogBurn(address indexed owner, uint value);\n', '     \n', '// Functions:\n', '     /// @dev Constructor\n', '     function Goldmint(\n', '          address _tokenManager,\n', '          address _ethRateChanger,\n', '          address _otherCurrenciesChecker,\n', '\n', '          address _mntTokenAddress,\n', '          address _unsoldContractAddress,\n', '          address _foundersVestingAddress)\n', '     {\n', '          creator = msg.sender;\n', '\n', '          tokenManager = _tokenManager;\n', '          ethRateChanger = _ethRateChanger;\n', '          lastUsdPerEthChangeDate = uint64(now);\n', '\n', '          otherCurrenciesChecker = _otherCurrenciesChecker; \n', '\n', '          mntToken = MNTP(_mntTokenAddress);\n', '          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\n', '\n', '          // slight rename\n', '          foundersRewardsAccount = _foundersVestingAddress;\n', '\n', '          assert(multisigs.length==10);\n', '     }\n', '\n', '     function startICO() public onlyCreator onlyInState(State.Init) {\n', '          setState(State.ICORunning);\n', '          icoStartedTime = uint64(now);\n', '          mntToken.lockTransfer(true);\n', '          mntToken.issueTokens(foundersRewardsAccount, FOUNDERS_REWARD);\n', '     }\n', '\n', '     function pauseICO() public onlyCreator onlyInState(State.ICORunning) {\n', '          setState(State.ICOPaused);\n', '     }\n', '\n', '     function resumeICO() public onlyCreator onlyInState(State.ICOPaused) {\n', '          setState(State.ICORunning);\n', '     }\n', '\n', '     function startRefunding() public onlyCreator onlyInState(State.ICORunning) {\n', '          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\n', '          require(icoTokensSold < ICO_TOKEN_SOFT_CAP);\n', '          setState(State.Refunding);\n', '\n', "          // in this state tokens still shouldn't be transferred\n", '          assert(mntToken.lockTransfers());\n', '     }\n', '\n', '     function startMigration() public onlyCreator onlyInState(State.ICOFinished) {\n', '          // there is no way back...\n', '          setState(State.Migrating);\n', '\n', '          // disable token transfers\n', '          mntToken.lockTransfer(true);\n', '     }\n', '\n', '     /// @dev This function can be called by creator at any time,\n', '     /// or by anyone if ICO has really finished.\n', '     function finishICO() public onlyInState(State.ICORunning) {\n', '          require(msg.sender == creator || isIcoFinished());\n', '          setState(State.ICOFinished);\n', '\n', '          // 1 - lock all transfers\n', '          mntToken.lockTransfer(false);\n', '\n', '          // 2 - move all unsold tokens to unsoldTokens contract\n', '          icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\n', '          if(icoTokensUnsold>0){\n', '               mntToken.issueTokens(unsoldContract,icoTokensUnsold);\n', '               unsoldContract.finishIco();\n', '          }\n', '\n', '          // 3 - send all ETH to multisigs\n', '          // we have N separate multisigs for extra security\n', '          uint sendThisAmount = (this.balance / 10);\n', '\n', '          // 3.1 - send to 9 multisigs\n', '          for(uint i=0; i<9; ++i){\n', '               address ms = multisigs[i];\n', '\n', '               if(this.balance>=sendThisAmount){\n', '                    ms.transfer(sendThisAmount);\n', '               }\n', '          }\n', '\n', '          // 3.2 - send everything left to 10th multisig\n', '          if(0!=this.balance){\n', '               address lastMs = multisigs[9];\n', '               lastMs.transfer(this.balance);\n', '          }\n', '     }\n', '\n', '     function setState(State _s) internal {\n', '          currentState = _s;\n', '          LogStateSwitch(_s);\n', '     }\n', '\n', '// Access methods:\n', '     function setTokenManager(address _new) public onlyTokenManager {\n', '          tokenManager = _new;\n', '     }\n', '\n', "     // TODO: stealing creator's key means stealing otherCurrenciesChecker key too!\n", '     /*\n', '     function setOtherCurrenciesChecker(address _new) public onlyCreator {\n', '          otherCurrenciesChecker = _new;\n', '     }\n', '     */\n', '\n', '     // These are used by frontend so we can not remove them\n', '     function getTokensIcoSold() constant public returns (uint){          \n', '          return icoTokensSold;       \n', '     }      \n', '     \n', '     function getTotalIcoTokens() constant public returns (uint){          \n', '          return ICO_TOKEN_SUPPLY_LIMIT;         \n', '     }       \n', '     \n', '     function getMntTokenBalance(address _of) constant public returns (uint){         \n', '          return mntToken.balanceOf(_of);         \n', '     }        \n', '\n', '     function getBlockLength()constant public returns (uint){          \n', '          return SINGLE_BLOCK_LEN;      \n', '     }\n', '\n', '     function getCurrentPrice()constant public returns (uint){\n', '          return getMntTokensPerEth(icoTokensSold);\n', '     }\n', '\n', '     function getTotalCollectedWei()constant public returns (uint){\n', '          return collectedWei;\n', '     }\n', '\n', '/////////////////////////////\n', '     function isIcoFinished() constant public returns(bool) {\n', '          return (icoStartedTime > 0)\n', '            && (now > (icoStartedTime + 30 days) || (icoTokensSold >= ICO_TOKEN_SUPPLY_LIMIT));\n', '     }\n', '\n', '     function getMntTokensPerEth(uint _tokensSold) public constant returns (uint){\n', '          // 10 buckets\n', '          uint priceIndex = (_tokensSold / 1 ether) / SINGLE_BLOCK_LEN;\n', '          assert(priceIndex>=0 && (priceIndex<=9));\n', '          \n', '          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\n', '\n', "          // We have to multiply by '1 ether' to avoid float truncations\n", '          // Example: ($7000 * 100) / 120 = $5833.33333\n', '          uint pricePer1000tokensUsd = \n', '               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * 1 ether) / (100 + discountPercents[priceIndex]);\n', '\n', '          // Correct: 300000 / 5833.33333333 = 51.42857142\n', "          // We have to multiply by '1 ether' to avoid float truncations\n", '          uint mntPerEth = (usdPerEthCoinmarketcapRate * 1000 * 1 ether * 1 ether) / pricePer1000tokensUsd;\n', '          return mntPerEth;\n', '     }\n', '\n', '     function buyTokens(address _buyer) public payable onlyInState(State.ICORunning) {\n', '          require(msg.value!=0);\n', '\n', '          // The price is selected based on current sold tokens.\n', "          // Price can 'overlap'. For example:\n", '          //   1. if currently we sold 699950 tokens (the price is 10% discount)\n', '          //   2. buyer buys 1000 tokens\n', '          //   3. the price of all 1000 tokens would be with 10% discount!!!\n', '          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / 1 ether;\n', '\n', '          issueTokensInternal(_buyer,newTokens);\n', '\n', '          // Update this only when buying from ETH\n', '          ethInvestedBy[msg.sender] = safeAdd(ethInvestedBy[msg.sender], msg.value);\n', '\n', '          // This is total collected ETH\n', '          collectedWei = safeAdd(collectedWei, msg.value);\n', '     }\n', '\n', '     /// @dev This is called by other currency processors to issue new tokens \n', '     function issueTokensFromOtherCurrency(address _to, uint _weiCount) onlyInState(State.ICORunning) public onlyOtherCurrenciesChecker {\n', '          require(_weiCount!=0);\n', '\n', '          uint newTokens = (_weiCount * getMntTokensPerEth(icoTokensSold)) / 1 ether;\n', '          \n', '          require(newTokens<=MAX_SINGLE_ISSUED_FROM_OTHER_CURRENCIES);\n', '          require((issuedFromOtherCurrencies + newTokens)<=MAX_ISSUED_FROM_OTHER_CURRENCIES);\n', '\n', '          issueTokensInternal(_to,newTokens);\n', '\n', '          issuedFromOtherCurrencies = issuedFromOtherCurrencies + newTokens;\n', '     }\n', '\n', '     /// @dev This can be called to manually issue new tokens \n', '     /// from the bonus reward\n', '     function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\n', '          // can not issue more than BONUS_REWARD\n', '          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\n', '\n', '          mntToken.issueTokens(_to,_tokens);\n', '\n', '          issuedExternallyTokens = issuedExternallyTokens + _tokens;\n', '     }\n', '\n', '     function issueTokensInternal(address _to, uint _tokens) internal {\n', '          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\n', '\n', '          mntToken.issueTokens(_to,_tokens); \n', '          icoTokensSold+=_tokens;\n', '\n', '          LogBuy(_to,_tokens);\n', '     }\n', '\n', '     // anyone can call this and get his money back\n', '     function getMyRefund() public onlyInState(State.Refunding) {\n', '          address sender = msg.sender;\n', '          uint ethValue = ethInvestedBy[sender];\n', '\n', '          require(ethValue > 0);\n', '\n', '          // 1 - send money back\n', '          sender.transfer(ethValue);\n', '          ethInvestedBy[sender] = 0;\n', '\n', '          // 2 - burn tokens\n', '          mntToken.burnTokens(sender, mntToken.balanceOf(sender));\n', '     }\n', '\n', '     function setUsdPerEthRate(uint _usdPerEthRate) public onlyEthSetter {\n', '          // 1 - check\n', '          require((_usdPerEthRate>=100) && (_usdPerEthRate<=700));\n', '          uint64 hoursPassed = lastUsdPerEthChangeDate + 1 hours;  \n', '          require(uint(now) >= hoursPassed);\n', '\n', '          // 2 - update\n', '          usdPerEthCoinmarketcapRate = _usdPerEthRate;\n', '          lastUsdPerEthChangeDate = uint64(now);\n', '     }\n', '\n', '     // Default fallback function\n', '     function() payable {\n', '          // buyTokens -> issueTokensInternal\n', '          buyTokens(msg.sender);\n', '     }\n', '}']
