['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Token {\n', '  function balanceOf(address _who) constant returns (uint balance);\n', '  function transferFrom(address _from, address _to, uint _value);\n', '  function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract UnicornRanch {\n', '  enum VisitType { Spa, Afternoon, Day, Overnight, Week, Extended }\n', '  enum VisitState { InProgress, Completed, Repossessed }\n', '  function getBooking(address _who, uint _index) constant returns (uint _unicornCount, VisitType _type, uint _startBlock, uint _expiresBlock, VisitState _state, uint _completedBlock, uint _completedCount);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract UnicornRefunds {\n', '  using SafeMath for uint;\n', '\n', '  address public cardboardUnicornTokenAddress;\n', '  address public unicornRanchAddress;\n', '  address public owner = msg.sender;\n', '  uint public pricePerUnicorn = 1 finney;\n', '  uint public rewardUnicornAmount = 100;\n', '  mapping(address => uint) allowedAmounts;\n', '  mapping(address => bool) rewardClaimed;\n', '\n', '  event RewardClaimed(address indexed _who, uint _bookingIndex);\n', '  event UnicornsSold(address indexed _who, uint _unicornCount, uint _unicornCost, uint _paymentTotal);\n', '  event DonationReceived(address indexed _who, uint _amount, uint _allowanceEarned);\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  function getAllowedAmount(address _who) constant returns (uint _amount) {\n', '    return allowedAmounts[_who];\n', '  }\n', '\n', '  function claimReward(uint _bookingIndex) {\n', '    UnicornRanch ranch = UnicornRanch(unicornRanchAddress);\n', '    var (unicornCount, visitType, , , state, , completedCount) = ranch.getBooking(msg.sender, _bookingIndex);\n', '    require(state == UnicornRanch.VisitState.Completed); // Must be a visit that&#39;s completed (not in progress or repossessed)\n', '    require(visitType != UnicornRanch.VisitType.Spa); // Must be longer than a Spa visit\n', '    require(completedCount > unicornCount); // Must have triggered the "birth" conditions so the user went home with more than what they send in\n', '    require(rewardClaimed[msg.sender] == false); // Must not have already claimed the reward\n', '      \n', '    rewardClaimed[msg.sender] = true;\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount);\n', '      \n', '    RewardClaimed(msg.sender, _bookingIndex);\n', '  }\n', '  \n', '  /**\n', '   * Sell back a number of unicorn tokens, in exchange for ether.\n', '   */\n', '  function sell(uint _unicornCount) {\n', '    require(_unicornCount > 0);\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].sub(_unicornCount);\n', '    ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress);\n', '    cardboardUnicorns.transferFrom(msg.sender, owner, _unicornCount); // Transfer the actual asset\n', '    uint total = pricePerUnicorn.mul(_unicornCount);\n', '    msg.sender.transfer(total);\n', '    \n', '    UnicornsSold(msg.sender, _unicornCount, pricePerUnicorn, total);\n', '  }\n', '  \n', '  function() payable {\n', '    uint count = (msg.value).div(pricePerUnicorn);\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(count);\n', '    \n', '    DonationReceived(msg.sender, msg.value, count);\n', '  }\n', '  \n', '  /**\n', '   * Change ownership\n', '   */\n', '  function changeOwner(address _newOwner) onlyOwner {\n', '    owner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * Change the outside contracts used by this contract\n', '   */\n', '  function changeCardboardUnicornTokenAddress(address _newTokenAddress) onlyOwner {\n', '    cardboardUnicornTokenAddress = _newTokenAddress;\n', '  }\n', '  function changeUnicornRanchAddress(address _newAddress) onlyOwner {\n', '    unicornRanchAddress = _newAddress;\n', '  }\n', '  \n', '  /**\n', '   * Update unicorn price\n', '   */\n', '  function changePricePerUnicorn(uint _newPrice) onlyOwner {\n', '    pricePerUnicorn = _newPrice;\n', '  }\n', '  \n', '  /**\n', '   * Update reward amount\n', '   */\n', '  function changeRewardAmount(uint _newAmount) onlyOwner {\n', '    rewardUnicornAmount = _newAmount;\n', '  }\n', '  \n', '  function setAllowance(address _who, uint _amount) onlyOwner {\n', '    allowedAmounts[_who] = _amount;\n', '  }\n', '  \n', '  function withdraw() onlyOwner {\n', '    owner.transfer(this.balance); // Send all ether in this contract to this contract&#39;s owner\n', '  }\n', '  function withdrawForeignTokens(address _tokenContract) onlyOwner {\n', '    ERC20Token token = ERC20Token(_tokenContract);\n', '    token.transfer(owner, token.balanceOf(address(this))); // Send all owned tokens to this contract&#39;s owner\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Token {\n', '  function balanceOf(address _who) constant returns (uint balance);\n', '  function transferFrom(address _from, address _to, uint _value);\n', '  function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract UnicornRanch {\n', '  enum VisitType { Spa, Afternoon, Day, Overnight, Week, Extended }\n', '  enum VisitState { InProgress, Completed, Repossessed }\n', '  function getBooking(address _who, uint _index) constant returns (uint _unicornCount, VisitType _type, uint _startBlock, uint _expiresBlock, VisitState _state, uint _completedBlock, uint _completedCount);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract UnicornRefunds {\n', '  using SafeMath for uint;\n', '\n', '  address public cardboardUnicornTokenAddress;\n', '  address public unicornRanchAddress;\n', '  address public owner = msg.sender;\n', '  uint public pricePerUnicorn = 1 finney;\n', '  uint public rewardUnicornAmount = 100;\n', '  mapping(address => uint) allowedAmounts;\n', '  mapping(address => bool) rewardClaimed;\n', '\n', '  event RewardClaimed(address indexed _who, uint _bookingIndex);\n', '  event UnicornsSold(address indexed _who, uint _unicornCount, uint _unicornCost, uint _paymentTotal);\n', '  event DonationReceived(address indexed _who, uint _amount, uint _allowanceEarned);\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  function getAllowedAmount(address _who) constant returns (uint _amount) {\n', '    return allowedAmounts[_who];\n', '  }\n', '\n', '  function claimReward(uint _bookingIndex) {\n', '    UnicornRanch ranch = UnicornRanch(unicornRanchAddress);\n', '    var (unicornCount, visitType, , , state, , completedCount) = ranch.getBooking(msg.sender, _bookingIndex);\n', "    require(state == UnicornRanch.VisitState.Completed); // Must be a visit that's completed (not in progress or repossessed)\n", '    require(visitType != UnicornRanch.VisitType.Spa); // Must be longer than a Spa visit\n', '    require(completedCount > unicornCount); // Must have triggered the "birth" conditions so the user went home with more than what they send in\n', '    require(rewardClaimed[msg.sender] == false); // Must not have already claimed the reward\n', '      \n', '    rewardClaimed[msg.sender] = true;\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount);\n', '      \n', '    RewardClaimed(msg.sender, _bookingIndex);\n', '  }\n', '  \n', '  /**\n', '   * Sell back a number of unicorn tokens, in exchange for ether.\n', '   */\n', '  function sell(uint _unicornCount) {\n', '    require(_unicornCount > 0);\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].sub(_unicornCount);\n', '    ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress);\n', '    cardboardUnicorns.transferFrom(msg.sender, owner, _unicornCount); // Transfer the actual asset\n', '    uint total = pricePerUnicorn.mul(_unicornCount);\n', '    msg.sender.transfer(total);\n', '    \n', '    UnicornsSold(msg.sender, _unicornCount, pricePerUnicorn, total);\n', '  }\n', '  \n', '  function() payable {\n', '    uint count = (msg.value).div(pricePerUnicorn);\n', '    allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(count);\n', '    \n', '    DonationReceived(msg.sender, msg.value, count);\n', '  }\n', '  \n', '  /**\n', '   * Change ownership\n', '   */\n', '  function changeOwner(address _newOwner) onlyOwner {\n', '    owner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * Change the outside contracts used by this contract\n', '   */\n', '  function changeCardboardUnicornTokenAddress(address _newTokenAddress) onlyOwner {\n', '    cardboardUnicornTokenAddress = _newTokenAddress;\n', '  }\n', '  function changeUnicornRanchAddress(address _newAddress) onlyOwner {\n', '    unicornRanchAddress = _newAddress;\n', '  }\n', '  \n', '  /**\n', '   * Update unicorn price\n', '   */\n', '  function changePricePerUnicorn(uint _newPrice) onlyOwner {\n', '    pricePerUnicorn = _newPrice;\n', '  }\n', '  \n', '  /**\n', '   * Update reward amount\n', '   */\n', '  function changeRewardAmount(uint _newAmount) onlyOwner {\n', '    rewardUnicornAmount = _newAmount;\n', '  }\n', '  \n', '  function setAllowance(address _who, uint _amount) onlyOwner {\n', '    allowedAmounts[_who] = _amount;\n', '  }\n', '  \n', '  function withdraw() onlyOwner {\n', "    owner.transfer(this.balance); // Send all ether in this contract to this contract's owner\n", '  }\n', '  function withdrawForeignTokens(address _tokenContract) onlyOwner {\n', '    ERC20Token token = ERC20Token(_tokenContract);\n', "    token.transfer(owner, token.balanceOf(address(this))); // Send all owned tokens to this contract's owner\n", '  }\n', '  \n', '}']
