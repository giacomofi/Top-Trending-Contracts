['/*\n', 'This file is part of the PROOF Contract.\n', '\n', 'The PROOF Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The PROOF Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the PROOF Contract. If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        owner = _owner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    \n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    uint    public etherPrice;\n', '    address public crowdsaleOwner;\n', '    uint    public totalLimitUSD;\n', '    uint    public minimalSuccessUSD;\n', '    uint    public collectedUSD;\n', '\n', '    enum State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\n', '    event NewState(State state);\n', '    State   public state = State.Disabled;\n', '    uint    public crowdsaleStartTime;\n', '    uint    public crowdsaleFinishTime;\n', '\n', '    modifier enabledState {\n', '        require(state == State.Enabled);\n', '        _;\n', '    }\n', '\n', '    modifier enabledOrMigrationState {\n', '        require(state == State.Enabled || state == State.Migration);\n', '        _;\n', '    }\n', '\n', '    struct Investor {\n', '        uint256 amountTokens;\n', '        uint    amountWei;\n', '    }\n', '    mapping (address => Investor) public investors;\n', '    mapping (uint => address)     public investorsIter;\n', '    uint                          public numberOfInvestors;\n', '    \n', '    function () payable {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        uint256 tokensPerUSD = 0;\n', '        if (state == State.PreICO) {\n', '            tokensPerUSD = 125;\n', '        } else if (state == State.Crowdsale) {\n', '            if (now < crowdsaleStartTime + 1 days) {\n', '                tokensPerUSD = 115;\n', '            } else if (now < crowdsaleStartTime + 1 weeks) {\n', '                tokensPerUSD = 110;\n', '            } else {\n', '                tokensPerUSD = 100;\n', '            }\n', '        }\n', '        if (tokensPerUSD > 0) {\n', '            uint valueWei = msg.value;\n', '            uint valueUSD = valueWei * etherPrice / 1000000000000000000;\n', '            if (collectedUSD + valueUSD > totalLimitUSD) { // don&#39;t need so much ether\n', '                valueUSD = totalLimitUSD - collectedUSD;\n', '                valueWei = valueUSD * 1000000000000000000 / etherPrice;\n', '                msg.sender.transfer(msg.value - valueWei);\n', '                collectedUSD = totalLimitUSD; // to be sure!\n', '            } else {\n', '                collectedUSD += valueUSD;\n', '            }\n', '            uint256 tokens = tokensPerUSD * valueUSD;\n', '            require(balanceOf[msg.sender] + tokens > balanceOf[msg.sender]); // overflow\n', '            require(tokens > 0);\n', '            \n', '            Investor storage inv = investors[msg.sender];\n', '            if (inv.amountWei == 0) { // new investor\n', '                investorsIter[numberOfInvestors++] = msg.sender;\n', '            }\n', '            inv.amountTokens += tokens;\n', '            inv.amountWei += valueWei;\n', '            balanceOf[msg.sender] += tokens;\n', '            totalSupply += tokens;\n', '        }\n', '    }\n', '    \n', '    function startTokensSale(address _crowdsaleOwner, uint _etherPrice) public onlyOwner {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        crowdsaleStartTime = now;\n', '        crowdsaleOwner = _crowdsaleOwner;\n', '        etherPrice = _etherPrice;\n', '        delete numberOfInvestors;\n', '        delete collectedUSD;\n', '        if (state == State.Disabled) {\n', '            crowdsaleFinishTime = now + 14 days;\n', '            state = State.PreICO;\n', '            totalLimitUSD = 300000;\n', '            minimalSuccessUSD = 300000;\n', '        } else {\n', '            crowdsaleFinishTime = now + 30 days;\n', '            state = State.Crowdsale;\n', '            totalLimitUSD = 5200000;\n', '            minimalSuccessUSD = 3600000;\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    function timeToFinishTokensSale() public constant returns(uint t) {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        if (now > crowdsaleFinishTime) {\n', '            t = 0;\n', '        } else {\n', '            t = crowdsaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishTokensSale(uint _investorsToProcess) public {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD);\n', '        if (collectedUSD < minimalSuccessUSD) {\n', '            // Investors can get their ether calling withdrawBack() function\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                address addr = investorsIter[--numberOfInvestors];\n', '                Investor memory inv = investors[addr];\n', '                balanceOf[addr] -= inv.amountTokens;\n', '                totalSupply -= inv.amountTokens;\n', '                --_investorsToProcess;\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                state = State.Disabled;\n', '            } else {\n', '                state = State.CompletePreICO;\n', '            }\n', '        } else {\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                --numberOfInvestors;\n', '                --_investorsToProcess;\n', '                delete investors[investorsIter[numberOfInvestors]];\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                if (!crowdsaleOwner.send(this.balance)) throw;\n', '                state = State.CompletePreICO;\n', '            } else {\n', '                if (!crowdsaleOwner.send(1500000 * 1000000000000000000 / etherPrice)) throw;\n', '                // Create additional tokens for owner (28% of complete totalSupply)\n', '                balanceOf[owner] = totalSupply * 28 / 72;\n', '                totalSupply += totalSupply * 28 / 72;\n', '                state = State.Enabled;\n', '            }\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() public {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        uint value = investors[msg.sender].amountWei;\n', '        if (value > 0) {\n', '            delete investors[msg.sender];\n', '            msg.sender.transfer(value);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Token is Crowdsale {\n', '    \n', '    string  public standard    = &#39;Token 0.1&#39;;\n', '    string  public name        = &#39;PROOF&#39;;\n', '    string  public symbol      = "PF";\n', '    uint8   public decimals    = 0;\n', '\n', '    modifier onlyTokenHolders {\n', '        require(balanceOf[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function Token() payable Crowdsale() {}\n', '\n', '    function transfer(address _to, uint256 _value) public enabledState {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public enabledState {\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public enabledState {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant enabledState\n', '        returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '}\n', '\n', 'contract TokenMigration is Token {\n', '    \n', '    address public migrationAgent;\n', '    uint256 public totalMigrated;\n', '\n', '    event Migrate(address indexed from, address indexed to, uint256 value);\n', '\n', '    function TokenMigration() payable Token() {}\n', '\n', '    // Migrate _value of tokens to the new token contract\n', '    function migrate(uint256 _value) external {\n', '        require(state == State.Migration);\n', '        require(migrationAgent != 0);\n', '        require(_value != 0);\n', '        require(_value <= balanceOf[msg.sender]);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        totalMigrated += _value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n', '        Migrate(msg.sender, migrationAgent, _value);\n', '    }\n', '\n', '    function setMigrationAgent(address _agent) external onlyOwner {\n', '        require(migrationAgent == 0);\n', '        migrationAgent = _agent;\n', '        state = State.Migration;\n', '    }\n', '}\n', '\n', 'contract ProofTeamVote is TokenMigration {\n', '\n', '    function ProofTeamVote() payable TokenMigration() {}\n', '\n', '    event VotingStarted(uint weiReqFund);\n', '    event Voted(address indexed voter, bool inSupport);\n', '    event VotingFinished(bool inSupport);\n', '\n', '    struct Vote {\n', '        bool inSupport;\n', '        bool voted;\n', '    }\n', '\n', '    uint public weiReqFund;\n', '    uint public votingDeadline;\n', '    uint public numberOfVotes;\n', '    uint public yea;\n', '    uint public nay;\n', '    mapping (address => Vote) public votes;\n', '    mapping (uint => address) public votesIter;\n', '\n', '    function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\n', '        require(weiReqFund == 0 && _weiReqFund > 0 && _weiReqFund <= this.balance);\n', '        weiReqFund = _weiReqFund;\n', '        votingDeadline = now + 7 days;\n', '        delete yea;\n', '        delete nay;\n', '        VotingStarted(_weiReqFund);\n', '    }\n', '    \n', '    function votingInfo() public constant enabledOrMigrationState\n', '        returns(uint _weiReqFund, uint _timeToFinish) {\n', '        _weiReqFund = weiReqFund;\n', '        if (votingDeadline <= now) {\n', '            _timeToFinish = 0;\n', '        } else {\n', '            _timeToFinish = votingDeadline - now;\n', '        }\n', '    }\n', '\n', '    function vote(bool _inSupport) public onlyTokenHolders enabledOrMigrationState\n', '        returns (uint voteId) {\n', '        require(votes[msg.sender].voted != true);\n', '        require(votingDeadline > now);\n', '        voteId = numberOfVotes++;\n', '        votesIter[voteId] = msg.sender;\n', '        votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\n', '        Voted(msg.sender, _inSupport);\n', '        return voteId;\n', '    }\n', '\n', '    function finishVoting(uint _votesToProcess) public enabledOrMigrationState\n', '        returns (bool _inSupport) {\n', '        require(now >= votingDeadline);\n', '\n', '        while (_votesToProcess > 0 && numberOfVotes > 0) {\n', '            address voter = votesIter[--numberOfVotes];\n', '            Vote memory v = votes[voter];\n', '            uint voteWeight = balanceOf[voter];\n', '            if (v.inSupport) {\n', '                yea += voteWeight;\n', '            } else {\n', '                nay += voteWeight;\n', '            }\n', '            delete votes[voter];\n', '            delete votesIter[numberOfVotes];\n', '            --_votesToProcess;\n', '        }\n', '        if (numberOfVotes > 0) {\n', '            _inSupport = false;\n', '            return;\n', '        }\n', '\n', '        _inSupport = (yea > nay);\n', '        uint weiForSend = weiReqFund;\n', '        delete weiReqFund;\n', '        delete votingDeadline;\n', '        delete numberOfVotes;\n', '\n', '        if (_inSupport) {\n', '            if (migrationAgent == 0) {\n', '                if (!owner.send(weiForSend)) throw;\n', '            } else {\n', '                if (!migrationAgent.send(this.balance)) throw;\n', '            }\n', '        }\n', '\n', '        VotingFinished(_inSupport);\n', '    }\n', '}\n', '\n', 'contract ProofPublicVote is ProofTeamVote {\n', '\n', '    function ProofPublicVote() payable ProofTeamVote() {}\n', '\n', '    event Deployed(address indexed projectOwner, uint proofReqFund, string urlInfo);\n', '    event Voted(address indexed projectOwner, address indexed voter, bool inSupport);\n', '    event VotingFinished(address indexed projectOwner, bool inSupport);\n', '\n', '    struct Project {\n', '        uint   proofReqFund;\n', '        string urlInfo;\n', '        uint   votingDeadline;\n', '        uint   numberOfVotes;\n', '        uint   yea;\n', '        uint   nay;\n', '        mapping (address => Vote) votes;\n', '        mapping (uint => address) votesIter;\n', '    }\n', '    mapping (address => Project) public projects;\n', '\n', '    function deployProject(uint _proofReqFund, string _urlInfo) public\n', '        onlyTokenHolders enabledOrMigrationState {\n', '        require(_proofReqFund > 0 && _proofReqFund <= balanceOf[this]);\n', '        require(_proofReqFund <= balanceOf[msg.sender] * 1000);\n', '        require(projects[msg.sender].proofReqFund == 0);\n', '        projects[msg.sender].proofReqFund = _proofReqFund;\n', '        projects[msg.sender].urlInfo = _urlInfo;\n', '        projects[msg.sender].votingDeadline = now + 7 days;\n', '        Deployed(msg.sender, _proofReqFund, _urlInfo);\n', '    }\n', '    \n', '    function projectInfo(address _projectOwner) enabledOrMigrationState constant public \n', '        returns(uint _proofReqFund, string _urlInfo, uint _timeToFinish) {\n', '        _proofReqFund = projects[_projectOwner].proofReqFund;\n', '        _urlInfo = projects[_projectOwner].urlInfo;\n', '        if (projects[_projectOwner].votingDeadline <= now) {\n', '            _timeToFinish = 0;\n', '        } else {\n', '            _timeToFinish = projects[_projectOwner].votingDeadline - now;\n', '        }\n', '    }\n', '\n', '    function vote(address _projectOwner, bool _inSupport) public\n', '        onlyTokenHolders enabledOrMigrationState returns (uint voteId) {\n', '        Project storage p = projects[_projectOwner];\n', '        require(p.proofReqFund > 0);\n', '        require(p.votes[msg.sender].voted != true);\n', '        require(p.votingDeadline > now);\n', '        voteId = p.numberOfVotes++;\n', '        p.votesIter[voteId] = msg.sender;\n', '        p.votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\n', '        Voted(_projectOwner, msg.sender, _inSupport); \n', '        return voteId;\n', '    }\n', '\n', '    function finishVoting(address _projectOwner, uint _votesToProcess) public\n', '        enabledOrMigrationState returns (bool _inSupport) {\n', '        Project storage p = projects[_projectOwner];\n', '        require(p.proofReqFund > 0);\n', '        require(now >= p.votingDeadline && p.proofReqFund <= balanceOf[this]);\n', '\n', '        while (_votesToProcess > 0 && p.numberOfVotes > 0) {\n', '            address voter = p.votesIter[--p.numberOfVotes];\n', '            Vote memory v = p.votes[voter];\n', '            uint voteWeight = balanceOf[voter];\n', '            if (v.inSupport) {\n', '                p.yea += voteWeight;\n', '            } else {\n', '                p.nay += voteWeight;\n', '            }\n', '            delete p.votesIter[p.numberOfVotes];\n', '            delete p.votes[voter];\n', '            --_votesToProcess;\n', '        }\n', '        if (p.numberOfVotes > 0) {\n', '            _inSupport = false;\n', '            return;\n', '        }\n', '\n', '        _inSupport = (p.yea > p.nay);\n', '\n', '        uint proofReqFund = p.proofReqFund;\n', '        delete projects[_projectOwner];\n', '\n', '        if (_inSupport) {\n', '            require(balanceOf[_projectOwner] + proofReqFund >= balanceOf[_projectOwner]); // overflow\n', '            balanceOf[this] -= proofReqFund;\n', '            balanceOf[_projectOwner] += proofReqFund;\n', '            Transfer(this, _projectOwner, proofReqFund);\n', '        }\n', '\n', '        VotingFinished(_projectOwner, _inSupport);\n', '    }\n', '}\n', '\n', 'contract Proof is ProofPublicVote {\n', '\n', '    struct Swype {\n', '        uint16  swype;\n', '        uint    timestampSwype;\n', '    }\n', '    \n', '    struct Video {\n', '        uint16  swype;\n', '        uint    timestampSwype;\n', '        uint    timestampHash;\n', '        address owner;\n', '    }\n', '\n', '    mapping (address => Swype) public swypes;\n', '    mapping (bytes32 => Video) public videos;\n', '\n', '    uint priceInTokens;\n', '    uint teamFee;\n', '\n', '    function Proof() payable ProofPublicVote() {}\n', '\n', '    function setPrice(uint _priceInTokens) public onlyOwner {\n', '        require(_priceInTokens >= 2);\n', '        teamFee = _priceInTokens / 10;\n', '        if (teamFee == 0) {\n', '            teamFee = 1;\n', '        }\n', '        priceInTokens = _priceInTokens - teamFee;\n', '    }\n', '\n', '    function swypeCode() public enabledState returns (uint16 _swype) {\n', '        bytes32 blockHash = block.blockhash(block.number - 1);\n', '        bytes32 shaTemp = sha3(msg.sender, blockHash);\n', '        _swype = uint16(uint256(shaTemp) % 65536);\n', '        swypes[msg.sender] = Swype({swype: _swype, timestampSwype: now});\n', '    }\n', '    \n', '    function setHash(uint16 _swype, bytes32 _hash) public enabledState {\n', '        require(swypes[msg.sender].timestampSwype != 0);\n', '        require(swypes[msg.sender].swype == _swype);\n', '        transfer(owner, teamFee);\n', '        transfer(this, priceInTokens);\n', '        videos[_hash] = Video({swype: _swype, timestampSwype:swypes[msg.sender].timestampSwype, \n', '            timestampHash: now, owner: msg.sender});\n', '        delete swypes[msg.sender];\n', '    }\n', '}']
['/*\n', 'This file is part of the PROOF Contract.\n', '\n', 'The PROOF Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The PROOF Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the PROOF Contract. If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        owner = _owner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    \n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    uint    public etherPrice;\n', '    address public crowdsaleOwner;\n', '    uint    public totalLimitUSD;\n', '    uint    public minimalSuccessUSD;\n', '    uint    public collectedUSD;\n', '\n', '    enum State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\n', '    event NewState(State state);\n', '    State   public state = State.Disabled;\n', '    uint    public crowdsaleStartTime;\n', '    uint    public crowdsaleFinishTime;\n', '\n', '    modifier enabledState {\n', '        require(state == State.Enabled);\n', '        _;\n', '    }\n', '\n', '    modifier enabledOrMigrationState {\n', '        require(state == State.Enabled || state == State.Migration);\n', '        _;\n', '    }\n', '\n', '    struct Investor {\n', '        uint256 amountTokens;\n', '        uint    amountWei;\n', '    }\n', '    mapping (address => Investor) public investors;\n', '    mapping (uint => address)     public investorsIter;\n', '    uint                          public numberOfInvestors;\n', '    \n', '    function () payable {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        uint256 tokensPerUSD = 0;\n', '        if (state == State.PreICO) {\n', '            tokensPerUSD = 125;\n', '        } else if (state == State.Crowdsale) {\n', '            if (now < crowdsaleStartTime + 1 days) {\n', '                tokensPerUSD = 115;\n', '            } else if (now < crowdsaleStartTime + 1 weeks) {\n', '                tokensPerUSD = 110;\n', '            } else {\n', '                tokensPerUSD = 100;\n', '            }\n', '        }\n', '        if (tokensPerUSD > 0) {\n', '            uint valueWei = msg.value;\n', '            uint valueUSD = valueWei * etherPrice / 1000000000000000000;\n', "            if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\n", '                valueUSD = totalLimitUSD - collectedUSD;\n', '                valueWei = valueUSD * 1000000000000000000 / etherPrice;\n', '                msg.sender.transfer(msg.value - valueWei);\n', '                collectedUSD = totalLimitUSD; // to be sure!\n', '            } else {\n', '                collectedUSD += valueUSD;\n', '            }\n', '            uint256 tokens = tokensPerUSD * valueUSD;\n', '            require(balanceOf[msg.sender] + tokens > balanceOf[msg.sender]); // overflow\n', '            require(tokens > 0);\n', '            \n', '            Investor storage inv = investors[msg.sender];\n', '            if (inv.amountWei == 0) { // new investor\n', '                investorsIter[numberOfInvestors++] = msg.sender;\n', '            }\n', '            inv.amountTokens += tokens;\n', '            inv.amountWei += valueWei;\n', '            balanceOf[msg.sender] += tokens;\n', '            totalSupply += tokens;\n', '        }\n', '    }\n', '    \n', '    function startTokensSale(address _crowdsaleOwner, uint _etherPrice) public onlyOwner {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        crowdsaleStartTime = now;\n', '        crowdsaleOwner = _crowdsaleOwner;\n', '        etherPrice = _etherPrice;\n', '        delete numberOfInvestors;\n', '        delete collectedUSD;\n', '        if (state == State.Disabled) {\n', '            crowdsaleFinishTime = now + 14 days;\n', '            state = State.PreICO;\n', '            totalLimitUSD = 300000;\n', '            minimalSuccessUSD = 300000;\n', '        } else {\n', '            crowdsaleFinishTime = now + 30 days;\n', '            state = State.Crowdsale;\n', '            totalLimitUSD = 5200000;\n', '            minimalSuccessUSD = 3600000;\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    function timeToFinishTokensSale() public constant returns(uint t) {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        if (now > crowdsaleFinishTime) {\n', '            t = 0;\n', '        } else {\n', '            t = crowdsaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishTokensSale(uint _investorsToProcess) public {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD);\n', '        if (collectedUSD < minimalSuccessUSD) {\n', '            // Investors can get their ether calling withdrawBack() function\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                address addr = investorsIter[--numberOfInvestors];\n', '                Investor memory inv = investors[addr];\n', '                balanceOf[addr] -= inv.amountTokens;\n', '                totalSupply -= inv.amountTokens;\n', '                --_investorsToProcess;\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                state = State.Disabled;\n', '            } else {\n', '                state = State.CompletePreICO;\n', '            }\n', '        } else {\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                --numberOfInvestors;\n', '                --_investorsToProcess;\n', '                delete investors[investorsIter[numberOfInvestors]];\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                if (!crowdsaleOwner.send(this.balance)) throw;\n', '                state = State.CompletePreICO;\n', '            } else {\n', '                if (!crowdsaleOwner.send(1500000 * 1000000000000000000 / etherPrice)) throw;\n', '                // Create additional tokens for owner (28% of complete totalSupply)\n', '                balanceOf[owner] = totalSupply * 28 / 72;\n', '                totalSupply += totalSupply * 28 / 72;\n', '                state = State.Enabled;\n', '            }\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() public {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        uint value = investors[msg.sender].amountWei;\n', '        if (value > 0) {\n', '            delete investors[msg.sender];\n', '            msg.sender.transfer(value);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Token is Crowdsale {\n', '    \n', "    string  public standard    = 'Token 0.1';\n", "    string  public name        = 'PROOF';\n", '    string  public symbol      = "PF";\n', '    uint8   public decimals    = 0;\n', '\n', '    modifier onlyTokenHolders {\n', '        require(balanceOf[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function Token() payable Crowdsale() {}\n', '\n', '    function transfer(address _to, uint256 _value) public enabledState {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public enabledState {\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public enabledState {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant enabledState\n', '        returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '}\n', '\n', 'contract TokenMigration is Token {\n', '    \n', '    address public migrationAgent;\n', '    uint256 public totalMigrated;\n', '\n', '    event Migrate(address indexed from, address indexed to, uint256 value);\n', '\n', '    function TokenMigration() payable Token() {}\n', '\n', '    // Migrate _value of tokens to the new token contract\n', '    function migrate(uint256 _value) external {\n', '        require(state == State.Migration);\n', '        require(migrationAgent != 0);\n', '        require(_value != 0);\n', '        require(_value <= balanceOf[msg.sender]);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        totalMigrated += _value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n', '        Migrate(msg.sender, migrationAgent, _value);\n', '    }\n', '\n', '    function setMigrationAgent(address _agent) external onlyOwner {\n', '        require(migrationAgent == 0);\n', '        migrationAgent = _agent;\n', '        state = State.Migration;\n', '    }\n', '}\n', '\n', 'contract ProofTeamVote is TokenMigration {\n', '\n', '    function ProofTeamVote() payable TokenMigration() {}\n', '\n', '    event VotingStarted(uint weiReqFund);\n', '    event Voted(address indexed voter, bool inSupport);\n', '    event VotingFinished(bool inSupport);\n', '\n', '    struct Vote {\n', '        bool inSupport;\n', '        bool voted;\n', '    }\n', '\n', '    uint public weiReqFund;\n', '    uint public votingDeadline;\n', '    uint public numberOfVotes;\n', '    uint public yea;\n', '    uint public nay;\n', '    mapping (address => Vote) public votes;\n', '    mapping (uint => address) public votesIter;\n', '\n', '    function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\n', '        require(weiReqFund == 0 && _weiReqFund > 0 && _weiReqFund <= this.balance);\n', '        weiReqFund = _weiReqFund;\n', '        votingDeadline = now + 7 days;\n', '        delete yea;\n', '        delete nay;\n', '        VotingStarted(_weiReqFund);\n', '    }\n', '    \n', '    function votingInfo() public constant enabledOrMigrationState\n', '        returns(uint _weiReqFund, uint _timeToFinish) {\n', '        _weiReqFund = weiReqFund;\n', '        if (votingDeadline <= now) {\n', '            _timeToFinish = 0;\n', '        } else {\n', '            _timeToFinish = votingDeadline - now;\n', '        }\n', '    }\n', '\n', '    function vote(bool _inSupport) public onlyTokenHolders enabledOrMigrationState\n', '        returns (uint voteId) {\n', '        require(votes[msg.sender].voted != true);\n', '        require(votingDeadline > now);\n', '        voteId = numberOfVotes++;\n', '        votesIter[voteId] = msg.sender;\n', '        votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\n', '        Voted(msg.sender, _inSupport);\n', '        return voteId;\n', '    }\n', '\n', '    function finishVoting(uint _votesToProcess) public enabledOrMigrationState\n', '        returns (bool _inSupport) {\n', '        require(now >= votingDeadline);\n', '\n', '        while (_votesToProcess > 0 && numberOfVotes > 0) {\n', '            address voter = votesIter[--numberOfVotes];\n', '            Vote memory v = votes[voter];\n', '            uint voteWeight = balanceOf[voter];\n', '            if (v.inSupport) {\n', '                yea += voteWeight;\n', '            } else {\n', '                nay += voteWeight;\n', '            }\n', '            delete votes[voter];\n', '            delete votesIter[numberOfVotes];\n', '            --_votesToProcess;\n', '        }\n', '        if (numberOfVotes > 0) {\n', '            _inSupport = false;\n', '            return;\n', '        }\n', '\n', '        _inSupport = (yea > nay);\n', '        uint weiForSend = weiReqFund;\n', '        delete weiReqFund;\n', '        delete votingDeadline;\n', '        delete numberOfVotes;\n', '\n', '        if (_inSupport) {\n', '            if (migrationAgent == 0) {\n', '                if (!owner.send(weiForSend)) throw;\n', '            } else {\n', '                if (!migrationAgent.send(this.balance)) throw;\n', '            }\n', '        }\n', '\n', '        VotingFinished(_inSupport);\n', '    }\n', '}\n', '\n', 'contract ProofPublicVote is ProofTeamVote {\n', '\n', '    function ProofPublicVote() payable ProofTeamVote() {}\n', '\n', '    event Deployed(address indexed projectOwner, uint proofReqFund, string urlInfo);\n', '    event Voted(address indexed projectOwner, address indexed voter, bool inSupport);\n', '    event VotingFinished(address indexed projectOwner, bool inSupport);\n', '\n', '    struct Project {\n', '        uint   proofReqFund;\n', '        string urlInfo;\n', '        uint   votingDeadline;\n', '        uint   numberOfVotes;\n', '        uint   yea;\n', '        uint   nay;\n', '        mapping (address => Vote) votes;\n', '        mapping (uint => address) votesIter;\n', '    }\n', '    mapping (address => Project) public projects;\n', '\n', '    function deployProject(uint _proofReqFund, string _urlInfo) public\n', '        onlyTokenHolders enabledOrMigrationState {\n', '        require(_proofReqFund > 0 && _proofReqFund <= balanceOf[this]);\n', '        require(_proofReqFund <= balanceOf[msg.sender] * 1000);\n', '        require(projects[msg.sender].proofReqFund == 0);\n', '        projects[msg.sender].proofReqFund = _proofReqFund;\n', '        projects[msg.sender].urlInfo = _urlInfo;\n', '        projects[msg.sender].votingDeadline = now + 7 days;\n', '        Deployed(msg.sender, _proofReqFund, _urlInfo);\n', '    }\n', '    \n', '    function projectInfo(address _projectOwner) enabledOrMigrationState constant public \n', '        returns(uint _proofReqFund, string _urlInfo, uint _timeToFinish) {\n', '        _proofReqFund = projects[_projectOwner].proofReqFund;\n', '        _urlInfo = projects[_projectOwner].urlInfo;\n', '        if (projects[_projectOwner].votingDeadline <= now) {\n', '            _timeToFinish = 0;\n', '        } else {\n', '            _timeToFinish = projects[_projectOwner].votingDeadline - now;\n', '        }\n', '    }\n', '\n', '    function vote(address _projectOwner, bool _inSupport) public\n', '        onlyTokenHolders enabledOrMigrationState returns (uint voteId) {\n', '        Project storage p = projects[_projectOwner];\n', '        require(p.proofReqFund > 0);\n', '        require(p.votes[msg.sender].voted != true);\n', '        require(p.votingDeadline > now);\n', '        voteId = p.numberOfVotes++;\n', '        p.votesIter[voteId] = msg.sender;\n', '        p.votes[msg.sender] = Vote({inSupport: _inSupport, voted: true});\n', '        Voted(_projectOwner, msg.sender, _inSupport); \n', '        return voteId;\n', '    }\n', '\n', '    function finishVoting(address _projectOwner, uint _votesToProcess) public\n', '        enabledOrMigrationState returns (bool _inSupport) {\n', '        Project storage p = projects[_projectOwner];\n', '        require(p.proofReqFund > 0);\n', '        require(now >= p.votingDeadline && p.proofReqFund <= balanceOf[this]);\n', '\n', '        while (_votesToProcess > 0 && p.numberOfVotes > 0) {\n', '            address voter = p.votesIter[--p.numberOfVotes];\n', '            Vote memory v = p.votes[voter];\n', '            uint voteWeight = balanceOf[voter];\n', '            if (v.inSupport) {\n', '                p.yea += voteWeight;\n', '            } else {\n', '                p.nay += voteWeight;\n', '            }\n', '            delete p.votesIter[p.numberOfVotes];\n', '            delete p.votes[voter];\n', '            --_votesToProcess;\n', '        }\n', '        if (p.numberOfVotes > 0) {\n', '            _inSupport = false;\n', '            return;\n', '        }\n', '\n', '        _inSupport = (p.yea > p.nay);\n', '\n', '        uint proofReqFund = p.proofReqFund;\n', '        delete projects[_projectOwner];\n', '\n', '        if (_inSupport) {\n', '            require(balanceOf[_projectOwner] + proofReqFund >= balanceOf[_projectOwner]); // overflow\n', '            balanceOf[this] -= proofReqFund;\n', '            balanceOf[_projectOwner] += proofReqFund;\n', '            Transfer(this, _projectOwner, proofReqFund);\n', '        }\n', '\n', '        VotingFinished(_projectOwner, _inSupport);\n', '    }\n', '}\n', '\n', 'contract Proof is ProofPublicVote {\n', '\n', '    struct Swype {\n', '        uint16  swype;\n', '        uint    timestampSwype;\n', '    }\n', '    \n', '    struct Video {\n', '        uint16  swype;\n', '        uint    timestampSwype;\n', '        uint    timestampHash;\n', '        address owner;\n', '    }\n', '\n', '    mapping (address => Swype) public swypes;\n', '    mapping (bytes32 => Video) public videos;\n', '\n', '    uint priceInTokens;\n', '    uint teamFee;\n', '\n', '    function Proof() payable ProofPublicVote() {}\n', '\n', '    function setPrice(uint _priceInTokens) public onlyOwner {\n', '        require(_priceInTokens >= 2);\n', '        teamFee = _priceInTokens / 10;\n', '        if (teamFee == 0) {\n', '            teamFee = 1;\n', '        }\n', '        priceInTokens = _priceInTokens - teamFee;\n', '    }\n', '\n', '    function swypeCode() public enabledState returns (uint16 _swype) {\n', '        bytes32 blockHash = block.blockhash(block.number - 1);\n', '        bytes32 shaTemp = sha3(msg.sender, blockHash);\n', '        _swype = uint16(uint256(shaTemp) % 65536);\n', '        swypes[msg.sender] = Swype({swype: _swype, timestampSwype: now});\n', '    }\n', '    \n', '    function setHash(uint16 _swype, bytes32 _hash) public enabledState {\n', '        require(swypes[msg.sender].timestampSwype != 0);\n', '        require(swypes[msg.sender].swype == _swype);\n', '        transfer(owner, teamFee);\n', '        transfer(this, priceInTokens);\n', '        videos[_hash] = Video({swype: _swype, timestampSwype:swypes[msg.sender].timestampSwype, \n', '            timestampHash: now, owner: msg.sender});\n', '        delete swypes[msg.sender];\n', '    }\n', '}']
