['contract EthereumRouletteInterface {\n', '\n', '  // The owner is responsible for committing and revealing spin results.\n', '  address public owner;\n', '  // Funds that are kept in reserve in order to pay off the winners in all revealed spins.\n', '  // This number increases when new bets are made and decreases when winners collect their\n', '  // winnings. When all winnings have been collected, this should be 0.\n', '  uint public locked_funds_for_revealed_spins;\n', '  // How much time (in seconds) the owner has to reveal the result to a spin after the\n', '  // first bet has been made.\n', '  uint public owner_time_limit;\n', '  // Used to calculate the maximum bet a player can make.\n', '  uint public fraction;\n', '  // Maximum bet that a player can make on one of the numbers this spin.\n', '  uint public max_bet_this_spin;\n', '  // Contains all spins that happened so far. All spins, except that last two, are\n', '  // settled. A spin is settled if and only if the spin_result and nonce are revealed by\n', '  // the owner or owner_took_too_long flag is true. If a spin is settled, then players can\n', "  // collect their winnings from that spin. It's possible that the last two spins are also\n", '  // settled if the owner took too long.\n', '  Spin[] public spins;\n', '\n', '  struct Spin {\n', '    // If owner takes too long (does not respond in time and someone calls the\n', '    // player_declare_taking_too_long function), owner_took_too_long will be set to true\n', '    // and all players will be paid out. This represents the total sum that will be paid\n', '    // out in that case.\n', '    uint total_payout;\n', '    // The owner privately computes the sha3 of spin_result + nonce.\n', '    bytes32 commit_hash;\n', '    // Should be in [0, 37] range. 0 and 37 represent 0 and 00 on the roulette wheel.\n', '    uint8 spin_result;\n', '    // Some random value that the owner generates to make it impossible for someone to\n', '    // guess the spin_result based on the commit_hash.\n', '    bytes32 nonce;\n', '    // Total amount that was bet on a particular number. Used to verify that the amount\n', '    // bet on a number does not exceed max_bet_this_spin.\n', '    mapping(uint8 => uint) total_bet_on_number;\n', '    // Maps player address to a bet on a particular spin_result.\n', '    mapping(address => mapping(uint8 => Bet)) bets;\n', '    // This can be set to true if player_declare_taking_too_long is called if the owner is\n', '    // taking too long. In that case all bets in this round will be winners.\n', '    bool owner_took_too_long;\n', '    // Time (in seconds) by which the spin result should be revealed by the owner.\n', '    uint time_of_latest_reveal;\n', '  }\n', '\n', '  struct Bet {\n', '    uint amount;\n', '    // True if this bet was already paid.\n', '    bool already_paid;\n', '  }\n', '\n', '  // Allows only the owner to call certain functions.\n', '  modifier onlyOwner {}\n', '  // Verifies no Ether is sent when calling a function.\n', '  modifier noEther {}\n', '  // Verifies that more than 0 Ether is sent when calling a function.\n', '  modifier etherRequired {}\n', '\n', '  // Player makes a bet on a particular spin_result.\n', '  function player_make_bet(uint8 spin_result) etherRequired;\n', '\n', '  // Player calls this function to collect all winnings from a particular spin.\n', '  function player_collect_winnings(uint spin_num) noEther;\n', '\n', '  // If the owner is taking too long to reveal the spin result, player can call this\n', '  // function. If enough time passed, all bets in the last two spins (which are\n', '  // unrevealed) will become winners. Player can then call player_collect_winnings.\n', '  function player_declare_taking_too_long() noEther;\n', '\n', '  // Owner reveals the spin_result and nonce for the first unrevealed spin (which is\n', '  // second last in the spins array). Owner also also adds a new unrevealed spin to the\n', '  // spins array. All new player bets will be on this new spin after this function is\n', '  // called.\n', '  //\n', '  // The reason why we always have two unrevealed spins (instead of 1) is because of this\n', '  // function. If there was only 1 unrevealed spin, when the owner tried revealing it,\n', '  // an attacker would be able to see the spin result in the transaction that the owner\n', '  // submits and quickly try to place a bet on the spin_result to try to get his\n', '  // trasaction to be processed before the owner.\n', '  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther;\n', '\n', '  // Set a new time limit for the owner between commit and reveal.\n', '  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther;\n', '\n', '  // Allows the owner to deposit additional funds into the contract.\n', '  function owner_deposit() onlyOwner etherRequired;\n', '\n', '  // Allows the owner to withdraw the winnings. Makes sure that the owner does not\n', '  // withdraw any funds that should be paid out to the players.\n', '  function owner_withdraw(uint amount) onlyOwner noEther;\n', '\n', '  // Updates the fraction (has an effect on how large the player bets can be).\n', '  function owner_set_fraction(uint _fraction) onlyOwner noEther;\n', '\n', '  function owner_transfer_ownership(address new_owner) onlyOwner noEther;\n', '\n', '  event MadeBet(uint amount, uint8 spin_result, address player_addr);\n', '  event Revealed(uint spin_number, uint8 spin_result);\n', '}\n', '\n', '\n', 'contract EthereumRoulette is EthereumRouletteInterface {\n', '\n', '  modifier onlyOwner {if (msg.sender != owner) throw; _}\n', '\n', '  modifier noEther {if (msg.value > 0) throw; _}\n', '\n', '  modifier etherRequired {if (msg.value == 0) throw; _}\n', '\n', '  function EthereumRoulette() {\n', '    owner = msg.sender;\n', '    fraction = 800;\n', '    owner_time_limit = 7 days;\n', '    // The contract must always have 2 unrevealed spins. This is why we commit the first\n', "    // two spins in the constructor. This means that it's not possible to bet on spin #1.\n", '    bytes32 first_num_hash = 0x3c81cf7279de81901303687979a6b62fdf04ec93480108d2ef38090d6135ad9f;\n', '    bytes32 second_num_hash = 0xb1540f17822cbe4daef5f1d96662b2dc92c5f9a2411429faaf73555d3149b68e;\n', '    spins.length++;\n', '    spins[spins.length - 1].commit_hash = first_num_hash;\n', '    spins.length++;\n', '    spins[spins.length - 1].commit_hash = second_num_hash;\n', '    max_bet_this_spin = address(this).balance / fraction;\n', '  }\n', '\n', '  function player_make_bet(uint8 spin_result) etherRequired {\n', '    Spin second_unrevealed_spin = spins[spins.length - 1];\n', '    if (second_unrevealed_spin.owner_took_too_long\n', '        || spin_result > 37\n', '        || msg.value + second_unrevealed_spin.total_bet_on_number[spin_result] > max_bet_this_spin\n', '        // verify it will be possible to pay the player in the worst case\n', '        || msg.value * 36 + reserved_funds() > address(this).balance) {\n', '      throw;\n', '    }\n', '    Bet b = second_unrevealed_spin.bets[msg.sender][spin_result];\n', '    b.amount += msg.value;\n', '    second_unrevealed_spin.total_bet_on_number[spin_result] += msg.value;\n', '    second_unrevealed_spin.total_payout += msg.value * 36;\n', '    if (second_unrevealed_spin.time_of_latest_reveal == 0) {\n', '      second_unrevealed_spin.time_of_latest_reveal = now + owner_time_limit;\n', '    }\n', '    MadeBet(msg.value, spin_result, msg.sender);\n', '  }\n', '\n', '  function player_collect_winnings(uint spin_num) noEther {\n', '    Spin s = spins[spin_num];\n', '    if (spin_num >= spins.length - 2) {\n', '      throw;\n', '    }\n', '    if (s.owner_took_too_long) {\n', '      bool at_least_one_number_paid = false;\n', '      for (uint8 roulette_num = 0; roulette_num < 38; roulette_num++) {\n', '        Bet messed_up_bet = s.bets[msg.sender][roulette_num];\n', '        if (messed_up_bet.already_paid) {\n', '          throw;\n', '        }\n', '        if (messed_up_bet.amount > 0) {\n', '          msg.sender.send(messed_up_bet.amount * 36);\n', '          locked_funds_for_revealed_spins -= messed_up_bet.amount * 36;\n', '          messed_up_bet.already_paid = true;\n', '          at_least_one_number_paid = true;\n', '        }\n', '      }\n', '      if (!at_least_one_number_paid) {\n', '        // If at least one number does not get paid, we let the user know when they try to estimate gas.\n', '        throw;\n', '      }\n', '    } else {\n', '      Bet b = s.bets[msg.sender][s.spin_result];\n', '      if (b.already_paid || b.amount == 0) {\n', '        throw;\n', '      }\n', '      msg.sender.send(b.amount * 36);\n', '      locked_funds_for_revealed_spins -= b.amount * 36;\n', '      b.already_paid = true;\n', '    }\n', '  }\n', '\n', '  function player_declare_taking_too_long() noEther {\n', '    Spin first_unrevealed_spin = spins[spins.length - 2];\n', '    bool first_spin_too_long = first_unrevealed_spin.time_of_latest_reveal != 0\n', '        && now > first_unrevealed_spin.time_of_latest_reveal;\n', '    Spin second_unrevealed_spin = spins[spins.length - 1];\n', '    bool second_spin_too_long = second_unrevealed_spin.time_of_latest_reveal != 0\n', '        && now > second_unrevealed_spin.time_of_latest_reveal;\n', '    if (!(first_spin_too_long || second_spin_too_long)) {\n', '      throw;\n', '    }\n', '    first_unrevealed_spin.owner_took_too_long = true;\n', '    second_unrevealed_spin.owner_took_too_long = true;\n', '    locked_funds_for_revealed_spins += (first_unrevealed_spin.total_payout + second_unrevealed_spin.total_payout);\n', '  }\n', '\n', '  function () {\n', '    // Do not allow sending Ether without calling a function.\n', '    throw;\n', '  }\n', '\n', '  function commit(bytes32 commit_hash) internal {\n', '    uint spin_num = spins.length++;\n', '    Spin second_unrevealed_spin = spins[spins.length - 1];\n', '    second_unrevealed_spin.commit_hash = commit_hash;\n', '    max_bet_this_spin = (address(this).balance - reserved_funds()) / fraction;\n', '  }\n', '\n', '  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther {\n', '    Spin first_unrevealed_spin = spins[spins.length - 2];\n', '    if (!first_unrevealed_spin.owner_took_too_long) {\n', '      if (sha3(spin_result, nonce) != first_unrevealed_spin.commit_hash || spin_result > 37) {\n', '        throw;\n', '      }\n', '      first_unrevealed_spin.spin_result = spin_result;\n', '      first_unrevealed_spin.nonce = nonce;\n', '      locked_funds_for_revealed_spins += first_unrevealed_spin.total_bet_on_number[spin_result] * 36;\n', '      Revealed(spins.length - 2, spin_result);\n', '    }\n', '    // If owner took too long, the spin result and nonce can be ignored because all payers\n', '    // won.\n', '    commit(commit_hash);\n', '  }\n', '\n', '  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther {\n', '    if (new_time_limit > 2 weeks) {\n', "      // We don't want the owner to be able to set a time limit of something like 1000\n", '      // years.\n', '      throw;\n', '    }\n', '    owner_time_limit = new_time_limit;\n', '  }\n', '\n', '  function owner_deposit() onlyOwner etherRequired {}\n', '\n', '  function owner_withdraw(uint amount) onlyOwner noEther {\n', '    if (amount > address(this).balance - reserved_funds()) {\n', '      throw;\n', '    }\n', '    owner.send(amount);\n', '  }\n', '\n', '  function owner_set_fraction(uint _fraction) onlyOwner noEther {\n', '    if (_fraction == 0) {\n', '      throw;\n', '    }\n', '    fraction = _fraction;\n', '  }\n', '\n', '  function owner_transfer_ownership(address new_owner) onlyOwner noEther {\n', '    owner = new_owner;\n', '  }\n', '\n', '  function seconds_left() constant returns(int) {\n', '    // Seconds left until player_declare_taking_too_long can be called.\n', '    Spin s = spins[spins.length - 1];\n', '    if (s.time_of_latest_reveal == 0) {\n', '      return -1;\n', '    }\n', '    if (now > s.time_of_latest_reveal) {\n', '      return 0;\n', '    }\n', '    return int(s.time_of_latest_reveal - now);\n', '  }\n', '\n', '  function reserved_funds() constant returns (uint) {\n', '    // These funds cannot be withdrawn by the owner. This is the amount contract will have\n', '    // to keep in reserve to be able to pay all players in the worst case.\n', '    uint total = locked_funds_for_revealed_spins;\n', '    Spin first_unrevealed_spin = spins[spins.length - 2];\n', '    if (!first_unrevealed_spin.owner_took_too_long) {\n', '      total += first_unrevealed_spin.total_payout;\n', '    }\n', '    Spin second_unrevealed_spin = spins[spins.length - 1];\n', '    if (!second_unrevealed_spin.owner_took_too_long) {\n', '      total += second_unrevealed_spin.total_payout;\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function get_hash(uint8 number, bytes32 nonce) constant returns (bytes32) {\n', '    return sha3(number, nonce);\n', '  }\n', '\n', '  function bet_this_spin() constant returns (bool) {\n', '    // Returns true if there was a bet placed in the latest spin.\n', '    Spin s = spins[spins.length - 1];\n', '    return s.time_of_latest_reveal != 0;\n', '  }\n', '\n', '  function check_bet(uint spin_num, address player_addr, uint8 spin_result) constant returns (uint) {\n', '    // Returns the amount of ether a player player bet on a spin result in a given spin\n', '    // number.\n', '    Spin s = spins[spin_num];\n', '    Bet b = s.bets[player_addr][spin_result];\n', '    return b.amount;\n', '  }\n', '\n', '  function current_spin_number() constant returns (uint) {\n', '    // Returns the number of the current spin.\n', '    return spins.length - 1;\n', '  }\n', '}']