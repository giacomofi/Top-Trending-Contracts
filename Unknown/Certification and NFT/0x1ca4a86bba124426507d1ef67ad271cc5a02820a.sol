['contract Token { \n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '// replay protection\n', 'contract ReplayProtection {\n', '    bool public isMainChain;\n', '\n', '    function ReplayProtection() {\n', '        bytes32 blockHash = 0xcf9055c648b3689a2b74e980fc6fa27817622fa9ac0749d60a6489a7fbcfe831;\n', '        // creates a unique signature with the latest 16 blocks\n', '        for (uint i = 1; i < 64; i++) {\n', '            if (blockHash == block.blockhash(block.number - i)) isMainChain = true;\n', '        }\n', '    }\n', '\n', '    // Splits the funds into 2 addresses\n', '    function etherSplit(address recipient, address altChainRecipient) returns(bool) {\n', '        if (isMainChain && recipient.send(msg.value)) {\n', '            return true;\n', '        } else if (!isMainChain && altChainRecipient > 0 && altChainRecipient.send(msg.value)) {\n', '            return true;\n', '        }\n', "        throw; // don't accept value transfer, otherwise it would be trapped.\n", '    }\n', '\n', '\n', '    function tokenSplit(address recipient, address altChainRecipient, address tokenAddress, uint amount) returns (bool) {\n', '        if (msg.value > 0 ) throw;\n', '\n', '        Token token = Token(tokenAddress);\n', '\n', '        if (isMainChain && token.transferFrom(msg.sender, recipient, amount)) {\n', '            return true;\n', '        } else if (!isMainChain && altChainRecipient > 0 && token.transferFrom(msg.sender, altChainRecipient, amount)) {\n', '            return true;\n', '        }\n', '        throw;\n', '    }\n', '\n', '    function () {\n', '        throw;\n', '    }\n', '}']