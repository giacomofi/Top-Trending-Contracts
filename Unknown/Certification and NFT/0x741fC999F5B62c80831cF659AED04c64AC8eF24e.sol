['/**\n', ' *  Crowdsale for Monetha Tokens.\n', ' *  Raised Ether will be stored safely at the wallet and returned to the ICO in case the funding goal is not reached,\n', ' *  allowing the investors to withdraw their funds.\n', ' *  Author: Julia Altenried\n', ' *  Internal audit: Alex Bazhanau, Andrej Ruckij\n', ' *  Audit: Blockchain & Smart Contract Security Group\n', ' **/\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) returns(bool success) {}\n', '\n', '\tfunction burn() {}\n', '\t\n', '\tfunction setStart(uint newStart) {}\n', '}\n', '\n', 'contract SafeMath {\n', '\t//internals\n', '\n', '\tfunction safeMul(uint a, uint b) internal returns(uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeSub(uint a, uint b) internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '}\n', '\n', '\n', 'contract Crowdsale is SafeMath {\n', '\t/* tokens will be transfered from this address */\n', '\taddress public tokenOwner;\n', '\t/* if the funding goal is not reached, investors may withdraw their funds */\n', '\tuint constant public fundingGoal = 672000000000;\n', '\t/* when the soft cap is reached, the price for monetha tokens will rise */\n', '\tuint constant public softCap = 6720000000000;\n', '\t/* the maximum amount of tokens to be sold */\n', '\tuint constant public maxGoal = 20120000000000;\n', '\t/* how much has been raised by crowdale (in ETH) */\n', '\tuint public amountRaised;\n', '\t/* the start date of the crowdsale */\n', '\tuint public start;\n', '\t/* the end date of the crowdsale*/\n', '\tuint public end;\n', '\t/* time after reaching the soft cap, while the crowdsale will be still available*/\n', '\tuint public timeAfterSoftCap;\n', '\t/* the number of tokens already sold */\n', '\tuint public tokensSold = 0;\n', '\t/* the rates before and after the soft cap is reached */\n', '\tuint constant public rateSoft = 24;\n', '\tuint constant public rateHard = 20;\n', '\n', '\tuint constant public rateCoefficient = 100000000000;\n', '\t/* the address of the token contract */\n', '\ttoken public tokenReward;\n', '\t/* the balances (in ETH) of all investors */\n', '\tmapping(address => uint) public balanceOf;\n', '\t/* indicates if the crowdsale has been closed already */\n', '\tbool public crowdsaleClosed = false;\n', '\t/* the wallet on which the funds will be stored */\n', '\taddress msWallet;\n', '\t/* notifying transfers and the success of the crowdsale*/\n', '\tevent GoalReached(address _tokenOwner, uint _amountRaised);\n', '\tevent FundTransfer(address backer, uint amount, bool isContribution, uint _amountRaised);\n', '\n', '\n', '\n', '\t/*  initialization, set the token address */\n', '\tfunction Crowdsale(\n', '\t\taddress _tokenAddr, \n', '\t\taddress _walletAddr, \n', '\t\taddress _tokenOwner, \n', '\t\tuint _start, \n', '\t\tuint _end,\n', '\t\tuint _timeAfterSoftCap) {\n', '\t\ttokenReward = token(_tokenAddr);\n', '\t\tmsWallet = _walletAddr;\n', '\t\ttokenOwner = _tokenOwner;\n', '\n', '\t\trequire(_start < _end);\n', '\t\tstart = _start;\n', '\t\tend = _end;\n', '\t\ttimeAfterSoftCap = _timeAfterSoftCap;\n', '\t}\n', '\n', '\t/* invest by sending ether to the contract. */\n', '\tfunction() payable {\n', '\t\tif (msg.sender != msWallet) //do not trigger investment if the wallet is returning the funds\n', '\t\t\tinvest(msg.sender);\n', '\t}\n', '\n', '\t/* make an investment\n', '\t *  only callable if the crowdsale started and hasn&#39;t been closed already and the maxGoal wasn&#39;t reached yet.\n', '\t *  the current token price is looked up and the corresponding number of tokens is transfered to the receiver.\n', '\t *  the sent value is directly forwarded to a safe wallet.\n', '\t *  this method allows to purchase tokens in behalf of another address.*/\n', '\tfunction invest(address _receiver) payable {\n', '\t\tuint amount = msg.value;\n', '\t\tvar (numTokens, reachedSoftCap) = getNumTokens(amount);\n', '\t\trequire(numTokens>0);\n', '\t\trequire(!crowdsaleClosed && now >= start && now <= end && safeAdd(tokensSold, numTokens) <= maxGoal);\n', '\t\tmsWallet.transfer(amount);\n', '\t\tbalanceOf[_receiver] = safeAdd(balanceOf[_receiver], amount);\n', '\t\tamountRaised = safeAdd(amountRaised, amount);\n', '\t\ttokensSold += numTokens;\n', '\t\tassert(tokenReward.transferFrom(tokenOwner, _receiver, numTokens));\n', '\t\tFundTransfer(_receiver, amount, true, amountRaised);\n', '\t\tif (reachedSoftCap) {\n', '\t\t\tuint newEnd = now + timeAfterSoftCap;\n', '\t\t\tif (newEnd < end) {\n', '\t\t\t\tend = newEnd;\n', '\t\t\t\ttokenReward.setStart(newEnd);\n', '\t\t\t} \n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction getNumTokens(uint _value) constant returns(uint numTokens, bool reachedSoftCap) {\n', '\t\tif (tokensSold < softCap) {\n', '\t\t\tnumTokens = safeMul(_value,rateSoft)/rateCoefficient;\n', '\t\t\tif (safeAdd(tokensSold,numTokens) < softCap) \n', '\t\t\t\treturn (numTokens, false);\n', '\t\t\telse if (safeAdd(tokensSold,numTokens) == softCap) \n', '\t\t\t\treturn (numTokens, true);\n', '\t\t\telse {\n', '\t\t\t\tnumTokens = safeSub(softCap, tokensSold);\n', '\t\t\t\tuint missing = safeSub(_value, safeMul(numTokens,rateCoefficient)/rateSoft);\n', '\t\t\t\treturn (safeAdd(numTokens, safeMul(missing,rateHard)/rateCoefficient), true);\n', '\t\t\t}\n', '\t\t} \n', '\t\telse \n', '\t\t\treturn (safeMul(_value,rateHard)/rateCoefficient, false);\n', '\t}\n', '\n', '\tmodifier afterDeadline() {\n', '\t\tif (now > end) \n', '\t\t\t_;\n', '\t}\n', '\n', '\t/* checks if the goal or time limit has been reached and ends the campaign */\n', '\tfunction checkGoalReached() afterDeadline {\n', '\t\trequire(msg.sender == tokenOwner);\n', '\n', '\t\tif (tokensSold >= fundingGoal) {\n', '\t\t\ttokenReward.burn(); //burn remaining tokens but the reserved ones\n', '\t\t\tGoalReached(tokenOwner, amountRaised);\n', '\t\t}\n', '\t\tcrowdsaleClosed = true;\n', '\t}\n', '\n', '\t/* allows the funders to withdraw their funds if the goal has not been reached.\n', '\t *  only works after funds have been returned from the wallet. */\n', '\tfunction safeWithdrawal() afterDeadline {\n', '\t\tuint amount = balanceOf[msg.sender];\n', '\t\tif (address(this).balance >= amount) {\n', '\t\t\tbalanceOf[msg.sender] = 0;\n', '\t\t\tif (amount > 0) {\n', '\t\t\t\tmsg.sender.transfer(amount);\n', '\t\t\t\tFundTransfer(msg.sender, amount, false, amountRaised);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '}']