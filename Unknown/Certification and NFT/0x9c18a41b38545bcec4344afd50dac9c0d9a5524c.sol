['pragma solidity ^0.4.11;\n', '\n', '// SafeMath Taken From FirstBlood\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// ERC20 Interface\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// ERC20Token\n', 'contract ERC20Token is ERC20, SafeMath {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalTokens; \n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Wolk is ERC20Token {\n', '\n', '    // TOKEN INFO\n', '    string  public constant name = "Wolk Protocol Token";\n', '    string  public constant symbol = "WOLK";\n', '    uint256 public constant decimals = 18;\n', '\n', '    // RESERVE\n', '    uint256 public reserveBalance = 0; \n', '    uint16  public constant percentageETHReserve = 20;\n', '\n', '    // CONTRACT OWNER\n', '    address public owner = msg.sender;      \n', '    address public multisigWallet;\n', '    modifier onlyOwner { assert(msg.sender == owner); _; }\n', '\n', '    // TOKEN GENERATION EVENT\n', '    mapping (address => uint256) contribution;\n', '    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\n', '    uint256 public constant tokenGenerationMax = 500 * 10**6 * 10**decimals;\n', '    uint256 public start_block; \n', '    uint256 public end_block;\n', '    bool    public saleCompleted = false;\n', '    modifier isTransferable { assert(saleCompleted); _; }\n', '\n', '    // WOLK SETTLERS\n', '    mapping (address => bool) settlers;\n', '    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\n', '\n', '    // TOKEN GENERATION EVENTLOG\n', '    event WolkCreated(address indexed _to, uint256 _tokenCreated);\n', '    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '\n', '    // @param _startBlock\n', '    // @param _endBlock\n', '    // @param _wolkWallet\n', '    // @return success\n', '    // @dev Wolk Genesis Event [only accessible by Contract Owner]\n', '    function wolkGenesis(uint256 _startBlock, uint256 _endBlock, address _wolkWallet) onlyOwner returns (bool success){\n', '        require( (totalTokens < 1) && (!settlers[msg.sender]) && (_endBlock > _startBlock) );\n', '        start_block = _startBlock;\n', '        end_block = _endBlock;\n', '        multisigWallet = _wolkWallet;\n', '        settlers[msg.sender] = true;\n', '        return true;\n', '    }\n', '\n', '    // @param _newOwner\n', '    // @return success\n', '    // @dev Transfering Contract Ownership. [only accessible by current Contract Owner]\n', '    function changeOwner(address _newOwner) onlyOwner returns (bool success){\n', '        owner = _newOwner;\n', '        settlers[_newOwner] = true;\n', '        return true;\n', '    }\n', '\n', '    // @dev Token Generation Event for Wolk Protocol Token. TGE Participant send Eth into this func in exchange of Wolk Protocol Token\n', '    function tokenGenerationEvent() payable external {\n', '        require(!saleCompleted);\n', '        require( (block.number >= start_block) && (block.number <= end_block) );\n', '        uint256 tokens = safeMul(msg.value, 5*10**9); //exchange rate\n', '        uint256 checkedSupply = safeAdd(totalTokens, tokens);\n', '        require(checkedSupply <= tokenGenerationMax);\n', '        totalTokens = checkedSupply;\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);  \n', '        contribution[msg.sender] = safeAdd(contribution[msg.sender], msg.value);  \n', '        WolkCreated(msg.sender, tokens); // logs token creation\n', '    }\n', '\n', '    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\n', '    function refund() external {\n', '        require( (contribution[msg.sender] > 0) && (!saleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block) );\n', '        uint256 tokenBalance = balances[msg.sender];\n', '        uint256 refundBalance = contribution[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        contribution[msg.sender] = 0;\n', '        totalTokens = safeSub(totalTokens, tokenBalance);\n', '        WolkDestroyed(msg.sender, tokenBalance);\n', '        LogRefund(msg.sender, refundBalance);\n', '        msg.sender.transfer(refundBalance); \n', '    }\n', '\n', '    // @dev Finalizing the Token Generation Event. 20% of Eth will be kept in contract to provide liquidity\n', '    function finalize() onlyOwner {\n', '        require( (!saleCompleted) && (totalTokens >= tokenGenerationMin) );\n', '        saleCompleted = true;\n', '        end_block = block.number;\n', '        reserveBalance = safeDiv(safeMul(this.balance, percentageETHReserve), 100);\n', '        var withdrawalBalance = safeSub(this.balance, reserveBalance);\n', '        msg.sender.transfer(withdrawalBalance);\n', '    }\n', '}\n', '\n', 'contract WolkProtocol is Wolk {\n', '\n', '    // WOLK NETWORK PROTOCOL\n', '    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers&#39; accounts\n', '    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\n', '    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller \n', '\n', '    // WOLK PROTOCOL Events:\n', '    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\n', '    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\n', '\n', '    // @param  _burnBasisPoints\n', '    // @return success\n', '    // @dev Set BurnRate on Wolk Protocol -- only Wolk Foundation can set this, affects Service Provider settleBuyer\n', '    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\n', '        require( (_burnBasisPoints > 0) && (_burnBasisPoints <= 1000) );\n', '        burnBasisPoints = _burnBasisPoints;\n', '        return true;\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @param  _feeBasisPoints\n', '    // @return success\n', '    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\n', '    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\n', '        if ( _feeBasisPoints <= 0 || _feeBasisPoints > 4000){\n', '            // revoke Settler privilege\n', '            settlers[_serviceProvider] = false;\n', '            feeBasisPoints[_serviceProvider] = 0;\n', '            return false;\n', '        }else{\n', '            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\n', '            settlers[_serviceProvider] = true;\n', '            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @return _feeBasisPoints\n', '    // @dev Check service ee (in BP) for a given provider\n', '    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\n', '        return feeBasisPoints[_serviceProvider];\n', '    }\n', '\n', '    // @param  _buyer\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\n', '    function settleBuyer(address _buyer, uint256 _value) onlySettler returns (bool success) {\n', '        require( (burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender] ); // Buyer must authorize Service Provider \n', '        if ( balances[_buyer] >= _value && _value > 0) {\n', '            var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000);\n', '            var transferredToServiceProvider = safeSub(_value, burnCap);\n', '            balances[_buyer] = safeSub(balances[_buyer], _value);\n', '            balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\n', '            totalTokens = safeSub(totalTokens, burnCap);\n', '            Transfer(_buyer, msg.sender, transferredToServiceProvider);\n', '            BurnTokens(_buyer, msg.sender, burnCap);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    } \n', '\n', '    // @param  _seller\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\n', '    function settleSeller(address _seller, uint256 _value) onlySettler returns (bool success) {\n', '        // Service Providers have a % fee for Sellers (e.g. 20%)\n', '        var serviceProviderBP = feeBasisPoints[msg.sender];\n', '        require( (serviceProviderBP > 0) && (serviceProviderBP <= 4000) );\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            var fee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\n', '            var transferredToSeller = safeSub(_value, fee);\n', '            balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\n', '            Transfer(msg.sender, _seller, transferredToSeller);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _providerToAdd\n', '    // @return success\n', '    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Foundation first\n', '    function authorizeProvider(address _providerToAdd) returns (bool success) {\n', '        require(settlers[_providerToAdd]);\n', '        authorized[msg.sender][_providerToAdd] = true;\n', '        AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToRemove\n', '    // @return success\n', '    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\n', '    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\n', '        authorized[msg.sender][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\n', '        return true;\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _serviceProvider\n', '    // @return authorizationStatus\n', '    // @dev Check authorization between account and Service Provider\n', '    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\n', '        return authorized[_owner][_serviceProvider];\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToAdd\n', '    // @return authorizationStatus\n', '    // @dev Grant authorization between account and Service Provider on buyers&#39; behalf [only accessible by Contract Owner]\n', '    // @note Explicit permission from balance owner MUST be obtained beforehand\n', '    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\n', '        var isPreauthorized = authorized[_owner][msg.sender];\n', '        if (isPreauthorized && settlers[_providerToAdd] ) {\n', '            authorized[_owner][_providerToAdd] = true;\n', '            AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToRemove\n', '    // @return authorization_status\n', '    // @dev Revoke authorization between account and Service Provider on buyers&#39; behalf [only accessible by Contract Owner]\n', '    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\n', '    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\n', '        authorized[_owner][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(_owner, _providerToRemove);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BancorFormula is SafeMath {\n', '\n', '    // Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\n', '    uint8 constant PRECISION   = 32;  // fractional bits\n', '    uint256 constant FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\n', '    uint256 constant FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\n', '    uint256 constant MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\n', '\n', '        Formula:\n', '        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\n', '\n', '        // special case for 0 deposit amount\n', '        if (_depositAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\n', '        uint256 temp;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp = safeMul(_supply, baseN) / _reserveBalance;\n', '            return safeSub(temp, _supply); \n', '        }\n', '\n', '        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100);\n', '\n', '        temp = safeMul(_supply, resN) / FIXED_ONE;\n', '\n', '        uint256 result =  safeSub(temp, _supply);\n', '        // from the result, we deduct the minimal increment, which is a         \n', '        // function of S and precision.       \n', '        return safeSub(result, _supply / 0x100000000);\n', '     }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\n', '\n', '        Formula:\n', '        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\n', '\n', '        // special case for 0 sell amount\n', '        if (_sellAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeSub(_supply, _sellAmount);\n', '        uint256 temp1;\n', '        uint256 temp2;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp1 = safeMul(_reserveBalance, _supply);\n', '            temp2 = safeMul(_reserveBalance, baseN);\n', '            return safeSub(temp1, temp2) / _supply;\n', '        }\n', '\n', '        // special case for selling the entire supply\n', '        if (_sellAmount == _supply)\n', '            return _reserveBalance;\n', '\n', '        uint256 resN = power(_supply, baseN, 100, _reserveRatio);\n', '\n', '        temp1 = safeMul(_reserveBalance, resN);\n', '        temp2 = safeMul(_reserveBalance, FIXED_ONE);\n', '\n', '        uint256 result = safeSub(temp1, temp2) / resN;\n', '\n', '        // from the result, we deduct the minimal increment, which is a         \n', '        // function of R and precision.       \n', '        return safeSub(result, _reserveBalance / 0x100000000);\n', '    }\n', '\n', '    /**\n', '        @dev Calculate (_baseN / _baseD) ^ (_expN / _expD)\n', '        Returns result upshifted by PRECISION\n', '\n', '        This method is overflow-safe\n', '    */ \n', '    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal returns (uint256 resN) {\n', '        uint256 logbase = ln(_baseN, _baseD);\n', '        // Not using safeDiv here, since safeDiv protects against\n', '        // precision loss. It’s unavoidable, however\n', '        // Both `ln` and `fixedExp` are overflow-safe. \n', '        resN = fixedExp(safeMul(logbase, _expN) / _expD);\n', '        return resN;\n', '    }\n', '    \n', '    /**\n', '        input range: \n', '            - numerator: [1, uint256_max >> PRECISION]    \n', '            - denominator: [1, uint256_max >> PRECISION]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function ln(uint256 _numerator, uint256 _denominator) internal returns (uint256) {\n', '        // denominator > numerator: less than one yields negative values. Unsupported\n', '        assert(_denominator <= _numerator);\n', '\n', '        // log(1) is the lowest we can go\n', '        assert(_denominator != 0 && _numerator != 0);\n', '\n', '        // Upper 32 bits are scaled off by PRECISION\n', '        assert(_numerator < MAX_VAL);\n', '        assert(_denominator < MAX_VAL);\n', '\n', '        return fixedLoge( (_numerator * FIXED_ONE) / _denominator);\n', '    }\n', '\n', '    /**\n', '        input range: \n', '            [0x100000000,uint256_max]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLoge(uint256 _x) internal returns (uint256 logE) {\n', '        /*\n', '        Since `fixedLog2_min` output range is max `0xdfffffffff` \n', '        (40 bits, or 5 bytes), we can use a very large approximation\n', '        for `ln(2)`. This one is used since it’s the max accuracy \n', '        of Python `ln(2)`\n', '\n', '        0xb17217f7d1cf78 = ln(2) * (1 << 56)\n', '        \n', '        */\n', '        //Cannot represent negative numbers (below 1)\n', '        assert(_x >= FIXED_ONE);\n', '\n', '        uint256 log2 = fixedLog2(_x);\n', '        logE = (log2 * 0xb17217f7d1cf78) >> 56;\n', '    }\n', '\n', '    /**\n', '        Returns log2(x >> 32) << 32 [1]\n', '        So x is assumed to be already upshifted 32 bits, and \n', '        the result is also upshifted 32 bits. \n', '        \n', '        [1] The function returns a number which is lower than the \n', '        actual value\n', '\n', '        input-range : \n', '            [0x100000000,uint256_max]\n', '        output-range: \n', '            [0,0xdfffffffff]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLog2(uint256 _x) internal returns (uint256) {\n', '        // Numbers below 1 are negative. \n', '        assert( _x >= FIXED_ONE);\n', '\n', '        uint256 hi = 0;\n', '        while (_x >= FIXED_TWO) {\n', '            _x >>= 1;\n', '            hi += FIXED_ONE;\n', '        }\n', '\n', '        for (uint8 i = 0; i < PRECISION; ++i) {\n', '            _x = (_x * _x) / FIXED_ONE;\n', '            if (_x >= FIXED_TWO) {\n', '                _x >>= 1;\n', '                hi += uint256(1) << (PRECISION - 1 - i);\n', '            }\n', '        }\n', '\n', '        return hi;\n', '    }\n', '\n', '    /**\n', '        fixedExp is a ‘protected’ version of `fixedExpUnsafe`, which \n', '        asserts instead of overflows\n', '    */\n', '    function fixedExp(uint256 _x) internal returns (uint256) {\n', '        assert(_x <= 0x386bfdba29);\n', '        return fixedExpUnsafe(_x);\n', '    }\n', '\n', '    /**\n', '        fixedExp \n', '        Calculates e^x according to maclauren summation:\n', '\n', '        e^x = 1+x+x^2/2!...+x^n/n!\n', '\n', '        and returns e^(x>>32) << 32, that is, upshifted for accuracy\n', '\n', '        Input range:\n', '            - Function ok at    <= 242329958953 \n', '            - Function fails at >= 242329958954\n', '\n', '        This method is is visible for testcases, but not meant for direct use. \n', ' \n', '        The values in this method been generated via the following python snippet: \n', '\n', '        def calculateFactorials():\n', '            “”"Method to print out the factorials for fixedExp”“”\n', '\n', '            ni = []\n', '            ni.append( 295232799039604140847618609643520000000) # 34!\n', '            ITERATIONS = 34\n', '            for n in range( 1,  ITERATIONS,1 ) :\n', '                ni.append(math.floor(ni[n - 1] / n))\n', '            print( “\\n        “.join([“xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;” % hex(int(x)) for x in ni]))\n', '\n', '    */\n', '    function fixedExpUnsafe(uint256 _x) internal returns (uint256) {\n', '    \n', '        uint256 xi = FIXED_ONE;\n', '        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\n', '\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xde1bc4d19efcb0000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x6f0de268cf7e58000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x2504a0cd9a7f72000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9412833669fdc800000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1d9d4d714865f500000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x4ef8ce836bba8c0000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xb481d807d1aa68000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x16903b00fa354d000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x281cdaac677b3400000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x402e2aad725eb80000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x5d5a6c9f31fe24000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x7c7890d442a83000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9931ed540345280000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaf147cf24ce150000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d00000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xafc441338061b8000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9c3cabbc0056e000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x839168328705c80000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x694120286c04a0000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x50319e98b3d2c400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x3a52a1e36b82020;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x289286e0fce002;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1b0c59eb53400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x114f95b55400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaa7210d200;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x650139600;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x39b78e80;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1fd8080;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x10fbc0;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x8c40;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x462;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x22;\n', '\n', '        return res / 0xde1bc4d19efcac82445da75b00000000;\n', '    }  \n', '}\n', '\n', 'contract WolkExchange is WolkProtocol, BancorFormula {\n', '\n', '    uint256 public maxPerExchangeBP = 50;\n', '\n', '    // @param  _maxPerExchange\n', '    // @return success\n', '    // @dev Set max sell token amount per transaction -- only Wolk Foundation can set this\n', '    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\n', '        require( (_maxPerExchange >= 10) && (_maxPerExchange <= 100) );\n', '        maxPerExchangeBP = _maxPerExchange;\n', '        return true;\n', '    }\n', '\n', '    // @return Estimated Liquidation Cap\n', '    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \n', '    function EstLiquidationCap() public constant returns (uint256) {\n', '        if (saleCompleted){\n', '            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\n', '            if (liquidationMax < 100 * 10**decimals){ \n', '                liquidationMax = 100 * 10**decimals;\n', '            }\n', '            return liquidationMax;   \n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // @param _wolkAmount\n', '    // @return ethReceivable\n', '    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\n', '    function sellWolk(uint256 _wolkAmount) isTransferable() external returns(uint256) {\n', '        uint256 sellCap = EstLiquidationCap();\n', '        uint256 ethReceivable = calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmount);\n', '        require( (sellCap >= _wolkAmount) && (balances[msg.sender] >= _wolkAmount) && (this.balance > ethReceivable) );\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n', '        totalTokens = safeSub(totalTokens, _wolkAmount);\n', '        reserveBalance = safeSub(this.balance, ethReceivable);\n', '        WolkDestroyed(msg.sender, _wolkAmount);\n', '        msg.sender.transfer(ethReceivable);\n', '        return ethReceivable;     \n', '    }\n', '\n', '    // @return wolkReceivable    \n', '    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\n', '    function purchaseWolk() isTransferable() payable external returns(uint256){\n', '        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\n', '        totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\n', '        reserveBalance = safeAdd(reserveBalance, msg.value);\n', '        WolkCreated(msg.sender, wolkReceivable);\n', '        return wolkReceivable;\n', '    }\n', '\n', '    // @param _exactWolk\n', '    // @return ethRefundable\n', '    // @dev send eth into contract in exchange for exact amount of Wolk tokens with margin of error of no more than 1 Wolk. \n', '    // @note Purchase with the insufficient eth will be cancelled and returned; exceeding eth balanance from purchase, if any, will be returned.     \n', '    function purchaseExactWolk(uint256 _exactWolk) isTransferable() payable external returns(uint256){\n', '        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\n', '        if (wolkReceivable < _exactWolk){\n', '            // Cancel Insufficient Purchase\n', '            revert();\n', '            return msg.value;\n', '        }else {\n', '            var wolkDiff = safeSub(wolkReceivable, _exactWolk);\n', '            uint256 ethRefundable = 0;\n', '            // Refund if wolkDiff exceeds 1 Wolk\n', '            if (wolkDiff < 10**decimals){\n', '                // Credit Buyer Full amount if within margin of error\n', '                totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '                balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\n', '                reserveBalance = safeAdd(reserveBalance, msg.value);\n', '                WolkCreated(msg.sender, wolkReceivable);\n', '                return 0;     \n', '            }else{\n', '                ethRefundable = calculateSaleReturn( safeAdd(totalTokens, wolkReceivable) , safeAdd(reserveBalance, msg.value), percentageETHReserve, wolkDiff);\n', '                totalTokens = safeAdd(totalTokens, _exactWolk);\n', '                balances[msg.sender] = safeAdd(balances[msg.sender], _exactWolk);\n', '                reserveBalance = safeAdd(reserveBalance, safeSub(msg.value, ethRefundable));\n', '                WolkCreated(msg.sender, _exactWolk);\n', '                msg.sender.transfer(ethRefundable);\n', '                return ethRefundable;\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// SafeMath Taken From FirstBlood\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// ERC20 Interface\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// ERC20Token\n', 'contract ERC20Token is ERC20, SafeMath {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalTokens; \n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Wolk is ERC20Token {\n', '\n', '    // TOKEN INFO\n', '    string  public constant name = "Wolk Protocol Token";\n', '    string  public constant symbol = "WOLK";\n', '    uint256 public constant decimals = 18;\n', '\n', '    // RESERVE\n', '    uint256 public reserveBalance = 0; \n', '    uint16  public constant percentageETHReserve = 20;\n', '\n', '    // CONTRACT OWNER\n', '    address public owner = msg.sender;      \n', '    address public multisigWallet;\n', '    modifier onlyOwner { assert(msg.sender == owner); _; }\n', '\n', '    // TOKEN GENERATION EVENT\n', '    mapping (address => uint256) contribution;\n', '    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\n', '    uint256 public constant tokenGenerationMax = 500 * 10**6 * 10**decimals;\n', '    uint256 public start_block; \n', '    uint256 public end_block;\n', '    bool    public saleCompleted = false;\n', '    modifier isTransferable { assert(saleCompleted); _; }\n', '\n', '    // WOLK SETTLERS\n', '    mapping (address => bool) settlers;\n', '    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\n', '\n', '    // TOKEN GENERATION EVENTLOG\n', '    event WolkCreated(address indexed _to, uint256 _tokenCreated);\n', '    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '\n', '    // @param _startBlock\n', '    // @param _endBlock\n', '    // @param _wolkWallet\n', '    // @return success\n', '    // @dev Wolk Genesis Event [only accessible by Contract Owner]\n', '    function wolkGenesis(uint256 _startBlock, uint256 _endBlock, address _wolkWallet) onlyOwner returns (bool success){\n', '        require( (totalTokens < 1) && (!settlers[msg.sender]) && (_endBlock > _startBlock) );\n', '        start_block = _startBlock;\n', '        end_block = _endBlock;\n', '        multisigWallet = _wolkWallet;\n', '        settlers[msg.sender] = true;\n', '        return true;\n', '    }\n', '\n', '    // @param _newOwner\n', '    // @return success\n', '    // @dev Transfering Contract Ownership. [only accessible by current Contract Owner]\n', '    function changeOwner(address _newOwner) onlyOwner returns (bool success){\n', '        owner = _newOwner;\n', '        settlers[_newOwner] = true;\n', '        return true;\n', '    }\n', '\n', '    // @dev Token Generation Event for Wolk Protocol Token. TGE Participant send Eth into this func in exchange of Wolk Protocol Token\n', '    function tokenGenerationEvent() payable external {\n', '        require(!saleCompleted);\n', '        require( (block.number >= start_block) && (block.number <= end_block) );\n', '        uint256 tokens = safeMul(msg.value, 5*10**9); //exchange rate\n', '        uint256 checkedSupply = safeAdd(totalTokens, tokens);\n', '        require(checkedSupply <= tokenGenerationMax);\n', '        totalTokens = checkedSupply;\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);  \n', '        contribution[msg.sender] = safeAdd(contribution[msg.sender], msg.value);  \n', '        WolkCreated(msg.sender, tokens); // logs token creation\n', '    }\n', '\n', '    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\n', '    function refund() external {\n', '        require( (contribution[msg.sender] > 0) && (!saleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block) );\n', '        uint256 tokenBalance = balances[msg.sender];\n', '        uint256 refundBalance = contribution[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        contribution[msg.sender] = 0;\n', '        totalTokens = safeSub(totalTokens, tokenBalance);\n', '        WolkDestroyed(msg.sender, tokenBalance);\n', '        LogRefund(msg.sender, refundBalance);\n', '        msg.sender.transfer(refundBalance); \n', '    }\n', '\n', '    // @dev Finalizing the Token Generation Event. 20% of Eth will be kept in contract to provide liquidity\n', '    function finalize() onlyOwner {\n', '        require( (!saleCompleted) && (totalTokens >= tokenGenerationMin) );\n', '        saleCompleted = true;\n', '        end_block = block.number;\n', '        reserveBalance = safeDiv(safeMul(this.balance, percentageETHReserve), 100);\n', '        var withdrawalBalance = safeSub(this.balance, reserveBalance);\n', '        msg.sender.transfer(withdrawalBalance);\n', '    }\n', '}\n', '\n', 'contract WolkProtocol is Wolk {\n', '\n', '    // WOLK NETWORK PROTOCOL\n', "    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers' accounts\n", '    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\n', '    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller \n', '\n', '    // WOLK PROTOCOL Events:\n', '    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\n', '    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\n', '\n', '    // @param  _burnBasisPoints\n', '    // @return success\n', '    // @dev Set BurnRate on Wolk Protocol -- only Wolk Foundation can set this, affects Service Provider settleBuyer\n', '    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\n', '        require( (_burnBasisPoints > 0) && (_burnBasisPoints <= 1000) );\n', '        burnBasisPoints = _burnBasisPoints;\n', '        return true;\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @param  _feeBasisPoints\n', '    // @return success\n', '    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\n', '    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\n', '        if ( _feeBasisPoints <= 0 || _feeBasisPoints > 4000){\n', '            // revoke Settler privilege\n', '            settlers[_serviceProvider] = false;\n', '            feeBasisPoints[_serviceProvider] = 0;\n', '            return false;\n', '        }else{\n', '            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\n', '            settlers[_serviceProvider] = true;\n', '            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @return _feeBasisPoints\n', '    // @dev Check service ee (in BP) for a given provider\n', '    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\n', '        return feeBasisPoints[_serviceProvider];\n', '    }\n', '\n', '    // @param  _buyer\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\n', '    function settleBuyer(address _buyer, uint256 _value) onlySettler returns (bool success) {\n', '        require( (burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender] ); // Buyer must authorize Service Provider \n', '        if ( balances[_buyer] >= _value && _value > 0) {\n', '            var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000);\n', '            var transferredToServiceProvider = safeSub(_value, burnCap);\n', '            balances[_buyer] = safeSub(balances[_buyer], _value);\n', '            balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\n', '            totalTokens = safeSub(totalTokens, burnCap);\n', '            Transfer(_buyer, msg.sender, transferredToServiceProvider);\n', '            BurnTokens(_buyer, msg.sender, burnCap);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    } \n', '\n', '    // @param  _seller\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\n', '    function settleSeller(address _seller, uint256 _value) onlySettler returns (bool success) {\n', '        // Service Providers have a % fee for Sellers (e.g. 20%)\n', '        var serviceProviderBP = feeBasisPoints[msg.sender];\n', '        require( (serviceProviderBP > 0) && (serviceProviderBP <= 4000) );\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            var fee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\n', '            var transferredToSeller = safeSub(_value, fee);\n', '            balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\n', '            Transfer(msg.sender, _seller, transferredToSeller);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _providerToAdd\n', '    // @return success\n', '    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Foundation first\n', '    function authorizeProvider(address _providerToAdd) returns (bool success) {\n', '        require(settlers[_providerToAdd]);\n', '        authorized[msg.sender][_providerToAdd] = true;\n', '        AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToRemove\n', '    // @return success\n', '    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\n', '    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\n', '        authorized[msg.sender][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\n', '        return true;\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _serviceProvider\n', '    // @return authorizationStatus\n', '    // @dev Check authorization between account and Service Provider\n', '    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\n', '        return authorized[_owner][_serviceProvider];\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToAdd\n', '    // @return authorizationStatus\n', "    // @dev Grant authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\n", '    // @note Explicit permission from balance owner MUST be obtained beforehand\n', '    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\n', '        var isPreauthorized = authorized[_owner][msg.sender];\n', '        if (isPreauthorized && settlers[_providerToAdd] ) {\n', '            authorized[_owner][_providerToAdd] = true;\n', '            AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToRemove\n', '    // @return authorization_status\n', "    // @dev Revoke authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\n", '    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\n', '    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\n', '        authorized[_owner][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(_owner, _providerToRemove);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BancorFormula is SafeMath {\n', '\n', '    // Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\n', '    uint8 constant PRECISION   = 32;  // fractional bits\n', '    uint256 constant FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\n', '    uint256 constant FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\n', '    uint256 constant MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a deposit amount (in the reserve token), calculates the return for a given change (in the main token)\n', '\n', '        Formula:\n', '        Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 100) - 1)\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100);\n', '\n', '        // special case for 0 deposit amount\n', '        if (_depositAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeAdd(_depositAmount, _reserveBalance);\n', '        uint256 temp;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp = safeMul(_supply, baseN) / _reserveBalance;\n', '            return safeSub(temp, _supply); \n', '        }\n', '\n', '        uint256 resN = power(baseN, _reserveBalance, _reserveRatio, 100);\n', '\n', '        temp = safeMul(_supply, resN) / FIXED_ONE;\n', '\n', '        uint256 result =  safeSub(temp, _supply);\n', '        // from the result, we deduct the minimal increment, which is a         \n', '        // function of S and precision.       \n', '        return safeSub(result, _supply / 0x100000000);\n', '     }\n', '\n', '    /**\n', '        @dev given a token supply, reserve, CRR and a sell amount (in the main token), calculates the return for a given change (in the reserve token)\n', '\n', '        Formula:\n', '        Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 100)))\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-100\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        // validate input\n', '        require(_supply != 0 && _reserveBalance != 0 && _reserveRatio > 0 && _reserveRatio <= 100 && _sellAmount <= _supply);\n', '\n', '        // special case for 0 sell amount\n', '        if (_sellAmount == 0)\n', '            return 0;\n', '\n', '        uint256 baseN = safeSub(_supply, _sellAmount);\n', '        uint256 temp1;\n', '        uint256 temp2;\n', '\n', '        // special case if the CRR = 100\n', '        if (_reserveRatio == 100) {\n', '            temp1 = safeMul(_reserveBalance, _supply);\n', '            temp2 = safeMul(_reserveBalance, baseN);\n', '            return safeSub(temp1, temp2) / _supply;\n', '        }\n', '\n', '        // special case for selling the entire supply\n', '        if (_sellAmount == _supply)\n', '            return _reserveBalance;\n', '\n', '        uint256 resN = power(_supply, baseN, 100, _reserveRatio);\n', '\n', '        temp1 = safeMul(_reserveBalance, resN);\n', '        temp2 = safeMul(_reserveBalance, FIXED_ONE);\n', '\n', '        uint256 result = safeSub(temp1, temp2) / resN;\n', '\n', '        // from the result, we deduct the minimal increment, which is a         \n', '        // function of R and precision.       \n', '        return safeSub(result, _reserveBalance / 0x100000000);\n', '    }\n', '\n', '    /**\n', '        @dev Calculate (_baseN / _baseD) ^ (_expN / _expD)\n', '        Returns result upshifted by PRECISION\n', '\n', '        This method is overflow-safe\n', '    */ \n', '    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal returns (uint256 resN) {\n', '        uint256 logbase = ln(_baseN, _baseD);\n', '        // Not using safeDiv here, since safeDiv protects against\n', '        // precision loss. It’s unavoidable, however\n', '        // Both `ln` and `fixedExp` are overflow-safe. \n', '        resN = fixedExp(safeMul(logbase, _expN) / _expD);\n', '        return resN;\n', '    }\n', '    \n', '    /**\n', '        input range: \n', '            - numerator: [1, uint256_max >> PRECISION]    \n', '            - denominator: [1, uint256_max >> PRECISION]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function ln(uint256 _numerator, uint256 _denominator) internal returns (uint256) {\n', '        // denominator > numerator: less than one yields negative values. Unsupported\n', '        assert(_denominator <= _numerator);\n', '\n', '        // log(1) is the lowest we can go\n', '        assert(_denominator != 0 && _numerator != 0);\n', '\n', '        // Upper 32 bits are scaled off by PRECISION\n', '        assert(_numerator < MAX_VAL);\n', '        assert(_denominator < MAX_VAL);\n', '\n', '        return fixedLoge( (_numerator * FIXED_ONE) / _denominator);\n', '    }\n', '\n', '    /**\n', '        input range: \n', '            [0x100000000,uint256_max]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLoge(uint256 _x) internal returns (uint256 logE) {\n', '        /*\n', '        Since `fixedLog2_min` output range is max `0xdfffffffff` \n', '        (40 bits, or 5 bytes), we can use a very large approximation\n', '        for `ln(2)`. This one is used since it’s the max accuracy \n', '        of Python `ln(2)`\n', '\n', '        0xb17217f7d1cf78 = ln(2) * (1 << 56)\n', '        \n', '        */\n', '        //Cannot represent negative numbers (below 1)\n', '        assert(_x >= FIXED_ONE);\n', '\n', '        uint256 log2 = fixedLog2(_x);\n', '        logE = (log2 * 0xb17217f7d1cf78) >> 56;\n', '    }\n', '\n', '    /**\n', '        Returns log2(x >> 32) << 32 [1]\n', '        So x is assumed to be already upshifted 32 bits, and \n', '        the result is also upshifted 32 bits. \n', '        \n', '        [1] The function returns a number which is lower than the \n', '        actual value\n', '\n', '        input-range : \n', '            [0x100000000,uint256_max]\n', '        output-range: \n', '            [0,0xdfffffffff]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLog2(uint256 _x) internal returns (uint256) {\n', '        // Numbers below 1 are negative. \n', '        assert( _x >= FIXED_ONE);\n', '\n', '        uint256 hi = 0;\n', '        while (_x >= FIXED_TWO) {\n', '            _x >>= 1;\n', '            hi += FIXED_ONE;\n', '        }\n', '\n', '        for (uint8 i = 0; i < PRECISION; ++i) {\n', '            _x = (_x * _x) / FIXED_ONE;\n', '            if (_x >= FIXED_TWO) {\n', '                _x >>= 1;\n', '                hi += uint256(1) << (PRECISION - 1 - i);\n', '            }\n', '        }\n', '\n', '        return hi;\n', '    }\n', '\n', '    /**\n', '        fixedExp is a ‘protected’ version of `fixedExpUnsafe`, which \n', '        asserts instead of overflows\n', '    */\n', '    function fixedExp(uint256 _x) internal returns (uint256) {\n', '        assert(_x <= 0x386bfdba29);\n', '        return fixedExpUnsafe(_x);\n', '    }\n', '\n', '    /**\n', '        fixedExp \n', '        Calculates e^x according to maclauren summation:\n', '\n', '        e^x = 1+x+x^2/2!...+x^n/n!\n', '\n', '        and returns e^(x>>32) << 32, that is, upshifted for accuracy\n', '\n', '        Input range:\n', '            - Function ok at    <= 242329958953 \n', '            - Function fails at >= 242329958954\n', '\n', '        This method is is visible for testcases, but not meant for direct use. \n', ' \n', '        The values in this method been generated via the following python snippet: \n', '\n', '        def calculateFactorials():\n', '            “”"Method to print out the factorials for fixedExp”“”\n', '\n', '            ni = []\n', '            ni.append( 295232799039604140847618609643520000000) # 34!\n', '            ITERATIONS = 34\n', '            for n in range( 1,  ITERATIONS,1 ) :\n', '                ni.append(math.floor(ni[n - 1] / n))\n', '            print( “\\n        “.join([“xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;” % hex(int(x)) for x in ni]))\n', '\n', '    */\n', '    function fixedExpUnsafe(uint256 _x) internal returns (uint256) {\n', '    \n', '        uint256 xi = FIXED_ONE;\n', '        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\n', '\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xde1bc4d19efcb0000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x6f0de268cf7e58000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x2504a0cd9a7f72000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9412833669fdc800000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1d9d4d714865f500000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x4ef8ce836bba8c0000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xb481d807d1aa68000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x16903b00fa354d000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x281cdaac677b3400000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x402e2aad725eb80000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x5d5a6c9f31fe24000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x7c7890d442a83000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9931ed540345280000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaf147cf24ce150000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d00000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xafc441338061b8000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9c3cabbc0056e000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x839168328705c80000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x694120286c04a0000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x50319e98b3d2c400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x3a52a1e36b82020;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x289286e0fce002;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1b0c59eb53400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x114f95b55400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaa7210d200;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x650139600;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x39b78e80;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1fd8080;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x10fbc0;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x8c40;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x462;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x22;\n', '\n', '        return res / 0xde1bc4d19efcac82445da75b00000000;\n', '    }  \n', '}\n', '\n', 'contract WolkExchange is WolkProtocol, BancorFormula {\n', '\n', '    uint256 public maxPerExchangeBP = 50;\n', '\n', '    // @param  _maxPerExchange\n', '    // @return success\n', '    // @dev Set max sell token amount per transaction -- only Wolk Foundation can set this\n', '    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\n', '        require( (_maxPerExchange >= 10) && (_maxPerExchange <= 100) );\n', '        maxPerExchangeBP = _maxPerExchange;\n', '        return true;\n', '    }\n', '\n', '    // @return Estimated Liquidation Cap\n', '    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \n', '    function EstLiquidationCap() public constant returns (uint256) {\n', '        if (saleCompleted){\n', '            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\n', '            if (liquidationMax < 100 * 10**decimals){ \n', '                liquidationMax = 100 * 10**decimals;\n', '            }\n', '            return liquidationMax;   \n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // @param _wolkAmount\n', '    // @return ethReceivable\n', '    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\n', '    function sellWolk(uint256 _wolkAmount) isTransferable() external returns(uint256) {\n', '        uint256 sellCap = EstLiquidationCap();\n', '        uint256 ethReceivable = calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmount);\n', '        require( (sellCap >= _wolkAmount) && (balances[msg.sender] >= _wolkAmount) && (this.balance > ethReceivable) );\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n', '        totalTokens = safeSub(totalTokens, _wolkAmount);\n', '        reserveBalance = safeSub(this.balance, ethReceivable);\n', '        WolkDestroyed(msg.sender, _wolkAmount);\n', '        msg.sender.transfer(ethReceivable);\n', '        return ethReceivable;     \n', '    }\n', '\n', '    // @return wolkReceivable    \n', '    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\n', '    function purchaseWolk() isTransferable() payable external returns(uint256){\n', '        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\n', '        totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\n', '        reserveBalance = safeAdd(reserveBalance, msg.value);\n', '        WolkCreated(msg.sender, wolkReceivable);\n', '        return wolkReceivable;\n', '    }\n', '\n', '    // @param _exactWolk\n', '    // @return ethRefundable\n', '    // @dev send eth into contract in exchange for exact amount of Wolk tokens with margin of error of no more than 1 Wolk. \n', '    // @note Purchase with the insufficient eth will be cancelled and returned; exceeding eth balanance from purchase, if any, will be returned.     \n', '    function purchaseExactWolk(uint256 _exactWolk) isTransferable() payable external returns(uint256){\n', '        uint256 wolkReceivable = calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, msg.value);\n', '        if (wolkReceivable < _exactWolk){\n', '            // Cancel Insufficient Purchase\n', '            revert();\n', '            return msg.value;\n', '        }else {\n', '            var wolkDiff = safeSub(wolkReceivable, _exactWolk);\n', '            uint256 ethRefundable = 0;\n', '            // Refund if wolkDiff exceeds 1 Wolk\n', '            if (wolkDiff < 10**decimals){\n', '                // Credit Buyer Full amount if within margin of error\n', '                totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '                balances[msg.sender] = safeAdd(balances[msg.sender], wolkReceivable);\n', '                reserveBalance = safeAdd(reserveBalance, msg.value);\n', '                WolkCreated(msg.sender, wolkReceivable);\n', '                return 0;     \n', '            }else{\n', '                ethRefundable = calculateSaleReturn( safeAdd(totalTokens, wolkReceivable) , safeAdd(reserveBalance, msg.value), percentageETHReserve, wolkDiff);\n', '                totalTokens = safeAdd(totalTokens, _exactWolk);\n', '                balances[msg.sender] = safeAdd(balances[msg.sender], _exactWolk);\n', '                reserveBalance = safeAdd(reserveBalance, safeSub(msg.value, ethRefundable));\n', '                WolkCreated(msg.sender, _exactWolk);\n', '                msg.sender.transfer(ethRefundable);\n', '                return ethRefundable;\n', '            }\n', '        }\n', '    }\n', '}']
