['pragma solidity ^0.4.13;\n', '\n', 'contract ReentrnacyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract IToken {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function mintTokens(address _to, uint256 _amount) {}\n', '}\n', '\n', 'contract IERC20Token {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract MusiconomiCrowdsale is ReentrnacyHandlingContract, Owned{\n', '\n', '  struct ContributorData{\n', '    uint priorityPassAllowance;\n', '    uint communityAllowance;\n', '    bool isActive;\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint nextContributorIndex;\n', '  mapping(uint => address) contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\n', '\n', '  uint public presaleStartBlock = 4216670;\n', '  uint public presaleUnlimitedStartBlock = 4220000;\n', '  uint public crowdsaleStartBlock = 4223470;\n', '  uint public crowdsaleEndedBlock = 4318560;\n', '\n', '  event PresaleStarted(uint blockNumber);\n', '  event PresaleUnlimitedStarted(uint blockNumber);\n', '  event CrowdsaleStarted(uint blockNumber);\n', '  event CrowdsaleEnded(uint blockNumber);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockNumber);\n', '  event MaxCapReached(uint blockNumber);\n', '\n', '  IToken token = IToken(0x0);\n', '  uint ethToMusicConversion = 1416;\n', '\n', '  uint minCap = 8824000000000000000000;\n', '  uint maxCap = 17648000000000000000000;\n', '  uint ethRaised;\n', '\n', '  address public multisigAddress;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint maxTokenSupply = 100000000000000000000000000;\n', '  bool ownerHasClaimedTokens;\n', '  uint cofounditReward = 2700000000000000000000000;\n', '  address cofounditAddress = 0x8C0DB695de876a42cE2e133ca00fdF59A9166708;\n', '  bool cofounditHasClaimedTokens;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  //\n', '  function() noReentrancy payable{\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.priorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.openedPriorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.crowdsale){\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    }\n', '    else{\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool){\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      MaxCapReached(block.number);                                                              // Close the crowdsale\n', '      CrowdsaleEnded(block.number);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.number > presaleStartBlock && block.number <= presaleUnlimitedStartBlock){  // Check if we are in presale phase\n', '      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.priorityPass;                                              // Set new state\n', '        PresaleStarted(block.number);                                                     // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > presaleUnlimitedStartBlock && block.number <= crowdsaleStartBlock){ // Check if we are in presale unlimited phase\n', '      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.openedPriorityPass;                                              // Set new state\n', '        PresaleUnlimitedStarted(block.number);                                                  // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock){        // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.number);                                                         // Raise event\n', '        return true;\n', '      }\n', '    }else{\n', '      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock){        // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.number);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal{\n', '    if (_stateChanged){\n', '      msg.sender.transfer(msg.value);\n', '    }else{\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  // Calculate how much user can contribute\n', '  //\n', '  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\n', '    uint maxContrib;\n', '    if (crowdsaleState == state.priorityPass){   // Check if we are in priority pass\n', '      maxContrib = contributorList[_contributor].priorityPassAllowance + contributorList[_contributor].communityAllowance - contributorList[_contributor].contributionAmount;\n', '      if (maxContrib > (maxCap - ethRaised)){   // Check if max contribution is more that max cap\n', '        maxContrib = maxCap - ethRaised;        // Alter max cap\n', '      }\n', '    }\n', '    else{\n', '      maxContrib = maxCap - ethRaised;          // Alter max cap\n', '    }\n', '    return maxContrib;\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal{\n', '    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxContribution;                                     // Set that user contibutes his maximum alowed contribution\n', '      returnAmount = _amount - maxContribution;                                 // Calculate howmuch he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount > minCap && minCap < ethRaised) MinCapReached(block.number);\n', '\n', '    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\n', '      contributorList[_contributor].isActive = true;                            // Set his activity to true\n', '      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\n', '      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '      nextContributorIndex++;\n', '    }\n', '    else{\n', '      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n', '    }\n', '    ethRaised += contributionAmount;                                            // Add to eth raised\n', '\n', '    uint tokenAmount = contributionAmount * ethToMusicConversion;               // Calculate how much tokens must contributor get\n', '    token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\n', '    contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\n', '\n', '    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\n', '  }\n', '\n', '  //\n', '  // Push contributor data to the contract before the crowdsale so that they are eligible for priorit pass\n', '  //\n', '  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances, uint[] _contributorCommunityAllowance) onlyOwner{\n', '    require(crowdsaleState == state.pendingStart);                                                        // Check if crowdsale has started\n', '    require(_contributorAddresses.length == _contributorPPAllowances.length && _contributorAddresses.length == _contributorCommunityAllowance.length); // Check if input data is correct\n', '\n', '    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\n', '      contributorList[_contributorAddresses[cnt]].isActive = true;                                        // Activate contributor\n', '      contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];  // Set PP allowance\n', '      contributorList[_contributorAddresses[cnt]].communityAllowance = _contributorCommunityAllowance[cnt];// Set community whitelist allowance\n', '      contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];                              // Set users index\n', '      nextContributorIndex++;\n', '    }\n', '  }\n', '\n', '  //\n', '  // Method is needed for recovering tokens accedentaly sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  //\n', '  function withdrawEth() onlyOwner{\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    multisigAddress.transfer(this.balance);\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed(){\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)){                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner{\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner{\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) onlyOwner{\n', '    token = IToken(_newAddress);\n', '  }\n', '\n', '  //\n', '  // Owner can claim teams tokens when crowdsale has successfully ended\n', '  //\n', '  function claimCoreTeamsTokens(address _to) onlyOwner{\n', '    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\n', '    require(!ownerHasClaimedTokens);                              // Check if owner has allready claimed tokens\n', '\n', '    uint devReward = maxTokenSupply - token.totalSupply();\n', '    if (!cofounditHasClaimedTokens) devReward -= cofounditReward; // If cofoundit has claimed tokens its ok if not set aside cofounditReward\n', '    token.mintTokens(_to, devReward);                             // Issue Teams tokens\n', '    ownerHasClaimedTokens = true;                                 // Block further mints from this function\n', '  }\n', '\n', '  //\n', '  // Cofoundit can claim their tokens\n', '  //\n', '  function claimCofounditTokens(){\n', '    require(msg.sender == cofounditAddress);            // Check if sender is cofoundit\n', '    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\n', '    require(!cofounditHasClaimedTokens);                // Check if cofoundit has allready claimed tokens\n', '\n', '    token.mintTokens(cofounditAddress, cofounditReward);// Issue cofoundit tokens\n', '    cofounditHasClaimedTokens = true;                   // Block further mints from this function\n', '  }\n', '\n', '  function getTokenAddress() constant returns(address){\n', '    return address(token);\n', '  }\n', '}']