['pragma solidity ^0.4.13;\n', '// **-----------------------------------------------\n', '// 0.4.13+commit.0fb4cb1a\n', '// [Assistive Reality ARX ERC20 token & crowdsale contract w/10% dev alloc]\n', '// [https://aronline.io/icoinfo]\n', '// [v3.2 final released 10/09/17 final masterARXsale32mainnet.sol]\n', '// [Adapted from Ethereum standard crowdsale contract]\n', '// [Contact <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82f1f6e3e4e4c2e3f0edeceeebece7acebed">[email&#160;protected]</a> for any queries]\n', '// [Join us in changing the world]\n', '// [aronline.io]\n', '// **-----------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/issues/20\n', '// -------------------------------------------------\n', '// Security reviews completed 10/09/17 [passed OK]\n', '// Functional reviews completed 10/09/17 [passed OK]\n', '// Final code revision and regression test cycle complete 10/09/17 [passed]\n', '// https://github.com/assistivereality/ico/blob/master/3.2crowdsaletestsARXmainnet.txt\n', '// -------------------------------------------------\n', 'contract owned { // security reviewed 10/09/17\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract SafeMath { // security reviewed 10/09/17\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    safeAssert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '    safeAssert(b > 0);\n', '    uint256 c = a / b;\n', '    safeAssert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    safeAssert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    safeAssert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function safeAssert(bool assertion) internal {\n', '    if (!assertion) revert();\n', '  }\n', '}\n', '\n', 'contract ERC20Interface is owned, SafeMath { // security reviewed 10/09/17\n', '    function totalSupply() constant returns (uint256 tokenTotalSupply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Burn(address _from, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Refund(address indexed _refunder, uint256 _value);\n', '}\n', '\n', 'contract ARXCrowdsale is ERC20Interface { // security reviewed 10/09/17\n', '    // deployment variables for dynamic supply token\n', '    string  public constant standard              = "ARX";\n', '    string  public constant name                  = "Assistive Reality";\n', '    string  public constant symbol                = "ARX";\n', '    uint8   public constant decimals              = 18;\n', '    uint256 _totalSupply                          = 0;\n', '\n', '    // multi-sig addresses and price variable\n', '    address public admin = owner;                               // admin address\n', '    address public beneficiaryMultiSig;                         // beneficiaryMultiSig (founder group) multi-sig wallet account\n', '    address public foundationFundMultisig;                      // foundationFundMultisig multi-sig wallet address - Assistive Reality foundation fund\n', '    uint256 public tokensPerEthPrice;                           // priceVar e.g. 2,000 tokens per Eth\n', '\n', '    // uint256 values for min,max,caps,tracking\n', '    uint256 public amountRaisedInWei;                           // total amount raised in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth\n', '    uint256 public fundingMaxInWei;                             // funding max in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth\n', '    uint256 public fundingMinInWei;                             // funding min in Wei e.g. 11 000 000 000 000 000 000 = 11 Eth\n', '    uint256 public fundingMaxInEth;                             // funding max in Eth (approx) e.g. 21 Eth\n', '    uint256 public fundingMinInEth;                             // funding min in Eth (approx) e.g. 11 Eth\n', '    uint256 public remainingCapInWei;                           // amount of cap remaining to raise in Wei e.g. 1 200 000 000 000 000 000 = 1.2 Eth remaining\n', '    uint256 public remainingCapInEth;                           // amount of cap remaining to raise in Eth (approx) e.g. 1\n', '    uint256 public foundationFundTokenCountInWei;               // 10% additional tokens generated and sent to foundationFundMultisig/Assistive Reality foundation, 18 decimals\n', '\n', '    // loop control, ICO startup and limiters\n', '    string  public CurrentStatus                  = "";         // current crowdsale status\n', '    uint256 public fundingStartBlock;                           // crowdsale start block#\n', '    uint256 public fundingEndBlock;                             // crowdsale end block#\n', '    bool    public isCrowdSaleFinished            = false;      // boolean for crowdsale completed or not\n', '    bool    public isCrowdSaleSetup               = false;      // boolean for crowdsale setup\n', '    bool    public halted                         = false;      // boolean for halted or not\n', '    bool    public founderTokensAvailable         = false;      // variable to set false after generating founderTokens\n', '\n', '    // balance mapping and transfer allowance array\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Burn(address _from, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Refund(address indexed _refunder, uint256 _value);\n', '\n', '    // default function, map admin\n', '    function ARXCrowdsale() onlyOwner {\n', '      admin = msg.sender;\n', '      CurrentStatus = "Crowdsale deployed to chain";\n', '    }\n', '\n', '    // total number of tokens issued so far, normalised\n', '    function totalSupply() constant returns (uint256 tokenTotalSupply) {\n', '        tokenTotalSupply = safeDiv(_totalSupply,1 ether);\n', '    }\n', '\n', '    // get the account balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // returns crowdsale max funding in Eth, low res\n', '    function fundingMaxInEth() constant returns (uint256 fundingMaximumInEth) {\n', '      fundingMaximumInEth = safeDiv(fundingMaxInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale min funding in Eth, low res\n', '    function fundingMinInEth() constant returns (uint256 fundingMinimumInEth) {\n', '      fundingMinimumInEth = safeDiv(fundingMinInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale progress (funds raised) in Eth, low res\n', '    function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) {\n', '      amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale remaining cap (hardcap) in Eth, low res\n', '    function remainingCapInEth() constant returns (uint256 remainingHardCapInEth) {\n', '      remainingHardCapInEth = safeDiv(remainingCapInWei,1 ether);\n', '    }\n', '\n', '    // ERC20 token transfer function\n', '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        require(!(_to == 0x0));\n', '        if ((balances[msg.sender] >= _amount)\n', '        && (_amount > 0)\n', '        && ((safeAdd(balances[_to],_amount) > balances[_to]))) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ERC20 token transferFrom function\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount) returns (bool success) {\n', '        require(!(_to == 0x0));\n', '        if ((balances[_from] >= _amount)\n', '        && (allowed[_from][msg.sender] >= _amount)\n', '        && (_amount > 0)\n', '        && (safeAdd(balances[_to],_amount) > balances[_to])) {\n', '            balances[_from] = safeSub(balances[_from], _amount);\n', '            allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ERC20 allow _spender to withdraw, multiple times, up to the _value amount\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        //Fix for known double-spend https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#\n', '        //Input must either set allow amount to 0, or have 0 already set, to workaround issue\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 return allowance for given owner spender pair\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // setup the CrowdSale parameters\n', '    function SetupCrowdsale(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner returns (bytes32 response) {\n', '        if ((msg.sender == admin)\n', '        && (!(isCrowdSaleSetup))\n', '        && (!(beneficiaryMultiSig > 0))\n', '        && (!(fundingMaxInWei > 0))) {\n', '            // mainnet values\n', '            beneficiaryMultiSig = 0xd93333f8cb765397A5D0d0e0ba53A2899B48511f;\n', '            foundationFundMultisig = 0x70A0bE1a5d8A9F39afED536Ec7b55d87067371aA;\n', '\n', '            // mainnet funding targets with 18 decimals\n', '            fundingMaxInWei = 70000000000000000000000; //70 000 000 000 000 000 000 000 = 70,000 Eth (hard cap) - crowdsale no longer accepts Eth after this value\n', '            fundingMinInWei = 3500000000000000000000;   //3 500 000 000 000 000 000 000 =  3,500 Eth (soft cap) - crowdsale is considered success after this value\n', '\n', '            // value of ARX token for mainnet. if hardcap is reached, this results in 280,000,000 ARX tokens in general supply (+28,000,000 in the foundationFundMultisig for a total supply of 308,000,000)\n', '            tokensPerEthPrice = 4000; // 4,000 tokens per Eth\n', '\n', '            // update values\n', '            fundingMaxInEth = safeDiv(fundingMaxInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            fundingMinInEth = safeDiv(fundingMinInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            remainingCapInWei = fundingMaxInWei;\n', '            remainingCapInEth = safeDiv(remainingCapInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            fundingStartBlock = _fundingStartBlock;\n', '            fundingEndBlock = _fundingEndBlock;\n', '\n', '            // configure crowdsale\n', '            isCrowdSaleSetup = true;\n', '            CurrentStatus = "Crowdsale is setup";\n', '            return "Crowdsale is setup";\n', '        } else if (msg.sender != admin) {\n', '            return "not authorized";\n', '        } else  {\n', '            return "campaign cannot be changed";\n', '        }\n', '    }\n', '\n', '    // default payable function when sending ether to this contract\n', '    function () payable {\n', '      require(msg.data.length == 0);\n', '      BuyTokens();\n', '    }\n', '\n', '    function BuyTokens() payable {\n', '      // 0. conditions (length, crowdsale setup, zero check, exceed funding contrib check, contract valid check, within funding block range check, balance overflow check etc)\n', '      require((!(msg.value == 0))\n', '      && (!(halted))\n', '      && (isCrowdSaleSetup)\n', '      && (!((safeAdd(amountRaisedInWei,msg.value)) > fundingMaxInWei))\n', '      && (block.number >= fundingStartBlock)\n', '      && (block.number <= fundingEndBlock)\n', '      && (!(isCrowdSaleFinished)));\n', '\n', '      // 1. vars\n', '      address recipient = msg.sender; // to simplify refunding\n', '      uint256 amount = msg.value;\n', '      uint256 rewardTransferAmount = 0;\n', '\n', '      // 2. effects\n', '      amountRaisedInWei = safeAdd(amountRaisedInWei,amount);\n', '      remainingCapInWei = safeSub(fundingMaxInWei,amountRaisedInWei);\n', '      rewardTransferAmount = safeMul(amount,tokensPerEthPrice);\n', '\n', '      // 3. interaction\n', '      balances[recipient] = safeAdd(balances[recipient], rewardTransferAmount);\n', '      _totalSupply = safeAdd(_totalSupply, rewardTransferAmount);\n', '      Transfer(this, recipient, rewardTransferAmount);\n', '      Buy(recipient, amount, rewardTransferAmount);\n', '    }\n', '\n', '    function AllocateFounderTokens() onlyOwner {\n', '      require(isCrowdSaleFinished && founderTokensAvailable && (foundationFundTokenCountInWei == 0));\n', '\n', '      // calculate additional 10% tokens to allocate for foundation developer distributions\n', '      foundationFundTokenCountInWei = safeMul((safeDiv(amountRaisedInWei,10)), tokensPerEthPrice);\n', '\n', '      // generate and send foundation developer token distributions\n', '      balances[foundationFundMultisig] = safeAdd(balances[foundationFundMultisig], foundationFundTokenCountInWei);\n', '\n', '      _totalSupply = safeAdd(_totalSupply, foundationFundTokenCountInWei);\n', '      Transfer(this, foundationFundMultisig, foundationFundTokenCountInWei);\n', '      Buy(foundationFundMultisig, 0, foundationFundTokenCountInWei);\n', '      founderTokensAvailable = false;\n', '    }\n', '\n', '    function beneficiaryMultiSigWithdraw(uint256 _amount) onlyOwner {\n', '      require(isCrowdSaleFinished && (amountRaisedInWei >= fundingMinInWei));\n', '      beneficiaryMultiSig.transfer(_amount);\n', '    }\n', '\n', '    function checkGoalReached() onlyOwner returns (bytes32 response) { // return crowdfund status to owner for each result case, update public constant\n', '      require (!(halted) && isCrowdSaleSetup);\n', '\n', '      if ((amountRaisedInWei < fundingMinInWei) && (block.number <= fundingEndBlock && block.number >= fundingStartBlock)) { // ICO in progress, under softcap\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "In progress (Eth < Softcap)";\n', '        return "In progress (Eth < Softcap)";\n', '      } else if ((amountRaisedInWei < fundingMinInWei) && (block.number < fundingStartBlock)) { // ICO has not started\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "Crowdsale is setup";\n', '        return "Crowdsale is setup";\n', '      } else if ((amountRaisedInWei < fundingMinInWei) && (block.number > fundingEndBlock)) { // ICO ended, under softcap\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = true;\n', '        CurrentStatus = "Unsuccessful (Eth < Softcap)";\n', '        return "Unsuccessful (Eth < Softcap)";\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei >= fundingMaxInWei)) { // ICO ended, at hardcap!\n', '        if (foundationFundTokenCountInWei == 0) {\n', '          founderTokensAvailable = true;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Hardcap)!";\n', '          return "Successful (Eth >= Hardcap)!";\n', '        } else if (foundationFundTokenCountInWei > 0) {\n', '          founderTokensAvailable = false;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Hardcap)!";\n', '          return "Successful (Eth >= Hardcap)!";\n', '        }\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei < fundingMaxInWei) && (block.number > fundingEndBlock)) { // ICO ended, over softcap!\n', '        if (foundationFundTokenCountInWei == 0) {\n', '          founderTokensAvailable = true;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Softcap)!";\n', '          return "Successful (Eth >= Softcap)!";\n', '        } else if (foundationFundTokenCountInWei > 0) {\n', '          founderTokensAvailable = false;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Softcap)!";\n', '          return "Successful (Eth >= Softcap)!";\n', '        }\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei < fundingMaxInWei) && (block.number <= fundingEndBlock)) { // ICO in progress, over softcap!\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "In progress (Eth >= Softcap)!";\n', '        return "In progress (Eth >= Softcap)!";\n', '      }\n', '    }\n', '\n', '    function refund() { // any contributor can call this to have their Eth returned, if not halted, soft cap not reached and deadline expires\n', '      require (!(halted)\n', '      && (amountRaisedInWei < fundingMinInWei)\n', '      && (block.number > fundingEndBlock)\n', '      && (balances[msg.sender] > 0));\n', '      //Proceed with refund\n', '      uint256 ARXbalance = balances[msg.sender];\n', '      balances[msg.sender] = 0;\n', '      _totalSupply = safeSub(_totalSupply, ARXbalance);\n', '      uint256 ethValue = safeDiv(ARXbalance, tokensPerEthPrice);\n', '      amountRaisedInWei = safeSub(amountRaisedInWei, ethValue);\n', '      msg.sender.transfer(ethValue);\n', '      Burn(msg.sender, ARXbalance);\n', '      Refund(msg.sender, ethValue);\n', '    }\n', '\n', '    function halt() onlyOwner { // halt the crowdsale\n', '        halted = true;\n', '        CurrentStatus = "Halted";\n', '    }\n', '\n', '    function unhalt() onlyOwner { // resume the crowdsale\n', '        halted = false;\n', '        CurrentStatus = "Unhalted";\n', '        checkGoalReached();\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '// **-----------------------------------------------\n', '// 0.4.13+commit.0fb4cb1a\n', '// [Assistive Reality ARX ERC20 token & crowdsale contract w/10% dev alloc]\n', '// [https://aronline.io/icoinfo]\n', '// [v3.2 final released 10/09/17 final masterARXsale32mainnet.sol]\n', '// [Adapted from Ethereum standard crowdsale contract]\n', '// [Contact staff@aronline.io for any queries]\n', '// [Join us in changing the world]\n', '// [aronline.io]\n', '// **-----------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/issues/20\n', '// -------------------------------------------------\n', '// Security reviews completed 10/09/17 [passed OK]\n', '// Functional reviews completed 10/09/17 [passed OK]\n', '// Final code revision and regression test cycle complete 10/09/17 [passed]\n', '// https://github.com/assistivereality/ico/blob/master/3.2crowdsaletestsARXmainnet.txt\n', '// -------------------------------------------------\n', 'contract owned { // security reviewed 10/09/17\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract SafeMath { // security reviewed 10/09/17\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    safeAssert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '    safeAssert(b > 0);\n', '    uint256 c = a / b;\n', '    safeAssert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    safeAssert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    safeAssert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function safeAssert(bool assertion) internal {\n', '    if (!assertion) revert();\n', '  }\n', '}\n', '\n', 'contract ERC20Interface is owned, SafeMath { // security reviewed 10/09/17\n', '    function totalSupply() constant returns (uint256 tokenTotalSupply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Burn(address _from, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Refund(address indexed _refunder, uint256 _value);\n', '}\n', '\n', 'contract ARXCrowdsale is ERC20Interface { // security reviewed 10/09/17\n', '    // deployment variables for dynamic supply token\n', '    string  public constant standard              = "ARX";\n', '    string  public constant name                  = "Assistive Reality";\n', '    string  public constant symbol                = "ARX";\n', '    uint8   public constant decimals              = 18;\n', '    uint256 _totalSupply                          = 0;\n', '\n', '    // multi-sig addresses and price variable\n', '    address public admin = owner;                               // admin address\n', '    address public beneficiaryMultiSig;                         // beneficiaryMultiSig (founder group) multi-sig wallet account\n', '    address public foundationFundMultisig;                      // foundationFundMultisig multi-sig wallet address - Assistive Reality foundation fund\n', '    uint256 public tokensPerEthPrice;                           // priceVar e.g. 2,000 tokens per Eth\n', '\n', '    // uint256 values for min,max,caps,tracking\n', '    uint256 public amountRaisedInWei;                           // total amount raised in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth\n', '    uint256 public fundingMaxInWei;                             // funding max in Wei e.g. 21 000 000 000 000 000 000 = 21 Eth\n', '    uint256 public fundingMinInWei;                             // funding min in Wei e.g. 11 000 000 000 000 000 000 = 11 Eth\n', '    uint256 public fundingMaxInEth;                             // funding max in Eth (approx) e.g. 21 Eth\n', '    uint256 public fundingMinInEth;                             // funding min in Eth (approx) e.g. 11 Eth\n', '    uint256 public remainingCapInWei;                           // amount of cap remaining to raise in Wei e.g. 1 200 000 000 000 000 000 = 1.2 Eth remaining\n', '    uint256 public remainingCapInEth;                           // amount of cap remaining to raise in Eth (approx) e.g. 1\n', '    uint256 public foundationFundTokenCountInWei;               // 10% additional tokens generated and sent to foundationFundMultisig/Assistive Reality foundation, 18 decimals\n', '\n', '    // loop control, ICO startup and limiters\n', '    string  public CurrentStatus                  = "";         // current crowdsale status\n', '    uint256 public fundingStartBlock;                           // crowdsale start block#\n', '    uint256 public fundingEndBlock;                             // crowdsale end block#\n', '    bool    public isCrowdSaleFinished            = false;      // boolean for crowdsale completed or not\n', '    bool    public isCrowdSaleSetup               = false;      // boolean for crowdsale setup\n', '    bool    public halted                         = false;      // boolean for halted or not\n', '    bool    public founderTokensAvailable         = false;      // variable to set false after generating founderTokens\n', '\n', '    // balance mapping and transfer allowance array\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    event Buy(address indexed _sender, uint256 _eth, uint256 _ARX);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Burn(address _from, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Refund(address indexed _refunder, uint256 _value);\n', '\n', '    // default function, map admin\n', '    function ARXCrowdsale() onlyOwner {\n', '      admin = msg.sender;\n', '      CurrentStatus = "Crowdsale deployed to chain";\n', '    }\n', '\n', '    // total number of tokens issued so far, normalised\n', '    function totalSupply() constant returns (uint256 tokenTotalSupply) {\n', '        tokenTotalSupply = safeDiv(_totalSupply,1 ether);\n', '    }\n', '\n', '    // get the account balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // returns crowdsale max funding in Eth, low res\n', '    function fundingMaxInEth() constant returns (uint256 fundingMaximumInEth) {\n', '      fundingMaximumInEth = safeDiv(fundingMaxInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale min funding in Eth, low res\n', '    function fundingMinInEth() constant returns (uint256 fundingMinimumInEth) {\n', '      fundingMinimumInEth = safeDiv(fundingMinInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale progress (funds raised) in Eth, low res\n', '    function amountRaisedInEth() constant returns (uint256 amountRaisedSoFarInEth) {\n', '      amountRaisedSoFarInEth = safeDiv(amountRaisedInWei,1 ether);\n', '    }\n', '\n', '    // returns crowdsale remaining cap (hardcap) in Eth, low res\n', '    function remainingCapInEth() constant returns (uint256 remainingHardCapInEth) {\n', '      remainingHardCapInEth = safeDiv(remainingCapInWei,1 ether);\n', '    }\n', '\n', '    // ERC20 token transfer function\n', '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        require(!(_to == 0x0));\n', '        if ((balances[msg.sender] >= _amount)\n', '        && (_amount > 0)\n', '        && ((safeAdd(balances[_to],_amount) > balances[_to]))) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ERC20 token transferFrom function\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount) returns (bool success) {\n', '        require(!(_to == 0x0));\n', '        if ((balances[_from] >= _amount)\n', '        && (allowed[_from][msg.sender] >= _amount)\n', '        && (_amount > 0)\n', '        && (safeAdd(balances[_to],_amount) > balances[_to])) {\n', '            balances[_from] = safeSub(balances[_from], _amount);\n', '            allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ERC20 allow _spender to withdraw, multiple times, up to the _value amount\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        //Fix for known double-spend https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#\n', '        //Input must either set allow amount to 0, or have 0 already set, to workaround issue\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 return allowance for given owner spender pair\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // setup the CrowdSale parameters\n', '    function SetupCrowdsale(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner returns (bytes32 response) {\n', '        if ((msg.sender == admin)\n', '        && (!(isCrowdSaleSetup))\n', '        && (!(beneficiaryMultiSig > 0))\n', '        && (!(fundingMaxInWei > 0))) {\n', '            // mainnet values\n', '            beneficiaryMultiSig = 0xd93333f8cb765397A5D0d0e0ba53A2899B48511f;\n', '            foundationFundMultisig = 0x70A0bE1a5d8A9F39afED536Ec7b55d87067371aA;\n', '\n', '            // mainnet funding targets with 18 decimals\n', '            fundingMaxInWei = 70000000000000000000000; //70 000 000 000 000 000 000 000 = 70,000 Eth (hard cap) - crowdsale no longer accepts Eth after this value\n', '            fundingMinInWei = 3500000000000000000000;   //3 500 000 000 000 000 000 000 =  3,500 Eth (soft cap) - crowdsale is considered success after this value\n', '\n', '            // value of ARX token for mainnet. if hardcap is reached, this results in 280,000,000 ARX tokens in general supply (+28,000,000 in the foundationFundMultisig for a total supply of 308,000,000)\n', '            tokensPerEthPrice = 4000; // 4,000 tokens per Eth\n', '\n', '            // update values\n', '            fundingMaxInEth = safeDiv(fundingMaxInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            fundingMinInEth = safeDiv(fundingMinInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            remainingCapInWei = fundingMaxInWei;\n', '            remainingCapInEth = safeDiv(remainingCapInWei,1 ether); //approximate to 1 Eth due to resolution, provided for ease/viewing only\n', '            fundingStartBlock = _fundingStartBlock;\n', '            fundingEndBlock = _fundingEndBlock;\n', '\n', '            // configure crowdsale\n', '            isCrowdSaleSetup = true;\n', '            CurrentStatus = "Crowdsale is setup";\n', '            return "Crowdsale is setup";\n', '        } else if (msg.sender != admin) {\n', '            return "not authorized";\n', '        } else  {\n', '            return "campaign cannot be changed";\n', '        }\n', '    }\n', '\n', '    // default payable function when sending ether to this contract\n', '    function () payable {\n', '      require(msg.data.length == 0);\n', '      BuyTokens();\n', '    }\n', '\n', '    function BuyTokens() payable {\n', '      // 0. conditions (length, crowdsale setup, zero check, exceed funding contrib check, contract valid check, within funding block range check, balance overflow check etc)\n', '      require((!(msg.value == 0))\n', '      && (!(halted))\n', '      && (isCrowdSaleSetup)\n', '      && (!((safeAdd(amountRaisedInWei,msg.value)) > fundingMaxInWei))\n', '      && (block.number >= fundingStartBlock)\n', '      && (block.number <= fundingEndBlock)\n', '      && (!(isCrowdSaleFinished)));\n', '\n', '      // 1. vars\n', '      address recipient = msg.sender; // to simplify refunding\n', '      uint256 amount = msg.value;\n', '      uint256 rewardTransferAmount = 0;\n', '\n', '      // 2. effects\n', '      amountRaisedInWei = safeAdd(amountRaisedInWei,amount);\n', '      remainingCapInWei = safeSub(fundingMaxInWei,amountRaisedInWei);\n', '      rewardTransferAmount = safeMul(amount,tokensPerEthPrice);\n', '\n', '      // 3. interaction\n', '      balances[recipient] = safeAdd(balances[recipient], rewardTransferAmount);\n', '      _totalSupply = safeAdd(_totalSupply, rewardTransferAmount);\n', '      Transfer(this, recipient, rewardTransferAmount);\n', '      Buy(recipient, amount, rewardTransferAmount);\n', '    }\n', '\n', '    function AllocateFounderTokens() onlyOwner {\n', '      require(isCrowdSaleFinished && founderTokensAvailable && (foundationFundTokenCountInWei == 0));\n', '\n', '      // calculate additional 10% tokens to allocate for foundation developer distributions\n', '      foundationFundTokenCountInWei = safeMul((safeDiv(amountRaisedInWei,10)), tokensPerEthPrice);\n', '\n', '      // generate and send foundation developer token distributions\n', '      balances[foundationFundMultisig] = safeAdd(balances[foundationFundMultisig], foundationFundTokenCountInWei);\n', '\n', '      _totalSupply = safeAdd(_totalSupply, foundationFundTokenCountInWei);\n', '      Transfer(this, foundationFundMultisig, foundationFundTokenCountInWei);\n', '      Buy(foundationFundMultisig, 0, foundationFundTokenCountInWei);\n', '      founderTokensAvailable = false;\n', '    }\n', '\n', '    function beneficiaryMultiSigWithdraw(uint256 _amount) onlyOwner {\n', '      require(isCrowdSaleFinished && (amountRaisedInWei >= fundingMinInWei));\n', '      beneficiaryMultiSig.transfer(_amount);\n', '    }\n', '\n', '    function checkGoalReached() onlyOwner returns (bytes32 response) { // return crowdfund status to owner for each result case, update public constant\n', '      require (!(halted) && isCrowdSaleSetup);\n', '\n', '      if ((amountRaisedInWei < fundingMinInWei) && (block.number <= fundingEndBlock && block.number >= fundingStartBlock)) { // ICO in progress, under softcap\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "In progress (Eth < Softcap)";\n', '        return "In progress (Eth < Softcap)";\n', '      } else if ((amountRaisedInWei < fundingMinInWei) && (block.number < fundingStartBlock)) { // ICO has not started\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "Crowdsale is setup";\n', '        return "Crowdsale is setup";\n', '      } else if ((amountRaisedInWei < fundingMinInWei) && (block.number > fundingEndBlock)) { // ICO ended, under softcap\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = true;\n', '        CurrentStatus = "Unsuccessful (Eth < Softcap)";\n', '        return "Unsuccessful (Eth < Softcap)";\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei >= fundingMaxInWei)) { // ICO ended, at hardcap!\n', '        if (foundationFundTokenCountInWei == 0) {\n', '          founderTokensAvailable = true;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Hardcap)!";\n', '          return "Successful (Eth >= Hardcap)!";\n', '        } else if (foundationFundTokenCountInWei > 0) {\n', '          founderTokensAvailable = false;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Hardcap)!";\n', '          return "Successful (Eth >= Hardcap)!";\n', '        }\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei < fundingMaxInWei) && (block.number > fundingEndBlock)) { // ICO ended, over softcap!\n', '        if (foundationFundTokenCountInWei == 0) {\n', '          founderTokensAvailable = true;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Softcap)!";\n', '          return "Successful (Eth >= Softcap)!";\n', '        } else if (foundationFundTokenCountInWei > 0) {\n', '          founderTokensAvailable = false;\n', '          isCrowdSaleFinished = true;\n', '          CurrentStatus = "Successful (Eth >= Softcap)!";\n', '          return "Successful (Eth >= Softcap)!";\n', '        }\n', '      } else if ((amountRaisedInWei >= fundingMinInWei) && (amountRaisedInWei < fundingMaxInWei) && (block.number <= fundingEndBlock)) { // ICO in progress, over softcap!\n', '        founderTokensAvailable = false;\n', '        isCrowdSaleFinished = false;\n', '        CurrentStatus = "In progress (Eth >= Softcap)!";\n', '        return "In progress (Eth >= Softcap)!";\n', '      }\n', '    }\n', '\n', '    function refund() { // any contributor can call this to have their Eth returned, if not halted, soft cap not reached and deadline expires\n', '      require (!(halted)\n', '      && (amountRaisedInWei < fundingMinInWei)\n', '      && (block.number > fundingEndBlock)\n', '      && (balances[msg.sender] > 0));\n', '      //Proceed with refund\n', '      uint256 ARXbalance = balances[msg.sender];\n', '      balances[msg.sender] = 0;\n', '      _totalSupply = safeSub(_totalSupply, ARXbalance);\n', '      uint256 ethValue = safeDiv(ARXbalance, tokensPerEthPrice);\n', '      amountRaisedInWei = safeSub(amountRaisedInWei, ethValue);\n', '      msg.sender.transfer(ethValue);\n', '      Burn(msg.sender, ARXbalance);\n', '      Refund(msg.sender, ethValue);\n', '    }\n', '\n', '    function halt() onlyOwner { // halt the crowdsale\n', '        halted = true;\n', '        CurrentStatus = "Halted";\n', '    }\n', '\n', '    function unhalt() onlyOwner { // resume the crowdsale\n', '        halted = false;\n', '        CurrentStatus = "Unhalted";\n', '        checkGoalReached();\n', '    }\n', '}']
