['pragma solidity ^0.4.11;\n', '\n', '/*\n', '  Copyright 2017, Anton Egorov (Mothership Foundation)\n', '  Copyright 2017, Klaus Hott (BlockchainLabs.nz)\n', '  Copyright 2017, Jordi Baylina (Giveth)\n', '\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '*/\n', '\n', 'contract ERC20Token {\n', '  /* This is a slight change to the ERC20 base standard.\n', '     function totalSupply() constant returns (uint256 supply);\n', '     is replaced with:\n', '     uint256 public totalSupply;\n', '     This automatically creates a getter function for the totalSupply.\n', '     This is moved to the base contract since public getter functions are not\n', '     currently recognised as an implementation of the matching abstract\n', '     function by the compiler.\n', '  */\n', '  /// total amount of tokens\n', '  function totalSupply() constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier\n', '  modifier onlyController { if (msg.sender != controller) throw; _; }\n', '\n', '  address public controller;\n', '\n', '  function Controlled() { controller = msg.sender;}\n', '\n', '  /// @notice Changes the controller of the contract\n', '  /// @param _newController The new controller of the contract\n', '  function changeController(address _newController) onlyController {\n', '    controller = _newController;\n', '  }\n', '}\n', '\n', 'contract Burnable is Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier, also the burner can call but also the\n', '  /// target of the function must be the burner\n', '  modifier onlyControllerOrBurner(address target) {\n', '    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\n', '    _;\n', '  }\n', '\n', '  modifier onlyBurner {\n', '    assert(msg.sender == burner);\n', '    _;\n', '  }\n', '  address public burner;\n', '\n', '  function Burnable() { burner = msg.sender;}\n', '\n', '  /// @notice Changes the burner of the contract\n', '  /// @param _newBurner The new burner of the contract\n', '  function changeBurner(address _newBurner) onlyBurner {\n', '    burner = _newBurner;\n', '  }\n', '}\n', '\n', 'contract MiniMeTokenI is ERC20Token, Burnable {\n', '\n', "      string public name;                //The Token's name: e.g. DigixDAO Tokens\n", '      uint8 public decimals;             //Number of decimals of the smallest unit\n', '      string public symbol;              //An identifier: e.g. REP\n', "      string public version = 'MMT_0.1'; //An arbitrary versioning scheme\n", '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _amount,\n', '        bytes _extraData\n', '    ) returns (bool success);\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _blockNumber The block number when the balance is queried\n', '    /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(\n', '        address _owner,\n', '        uint _blockNumber\n', '    ) constant returns (uint);\n', '\n', '    /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '    /// @param _blockNumber The block number when the totalSupply is queried\n', '    /// @return The total amount of tokens at `_blockNumber`\n', '    function totalSupplyAt(uint _blockNumber) constant returns(uint);\n', '\n', '////////////////\n', '// Clone Token Method\n', '////////////////\n', '\n', '    /// @notice Creates a new clone token with the initial distribution being\n', '    ///  this token at `_snapshotBlock`\n', '    /// @param _cloneTokenName Name of the clone token\n', '    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\n', '    /// @param _cloneTokenSymbol Symbol of the clone token\n', '    /// @param _snapshotBlock Block when the distribution of the parent token is\n', '    ///  copied to set the initial distribution of the new clone token;\n', '    ///  if the block is zero than the actual block, the current block is used\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    /// @return The address of the new MiniMeToken Contract\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '    ) returns(address);\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '    /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '    /// @param _owner The address that will be assigned the new tokens\n', '    /// @param _amount The quantity of tokens generated\n', '    /// @return True if the tokens are generated correctly\n', '    function generateTokens(address _owner, uint _amount) returns (bool);\n', '\n', '\n', '    /// @notice Burns `_amount` tokens from `_owner`\n', '    /// @param _owner The address that will lose the tokens\n', '    /// @param _amount The quantity of tokens to burn\n', '    /// @return True if the tokens are burned correctly\n', '    function destroyTokens(address _owner, uint _amount) returns (bool);\n', '\n', '////////////////\n', '// Enable tokens transfers\n', '////////////////\n', '\n', '    /// @notice Enables token holders to transfer their tokens freely if true\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    function enableTransfers(bool _transfersEnabled);\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token);\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '}\n', '\n', 'contract ReferalsTokenHolder is Controlled {\n', '  MiniMeTokenI public msp;\n', '  mapping (address => bool) been_spread;\n', '\n', '  function ReferalsTokenHolder(address _msp) {\n', '    msp = MiniMeTokenI(_msp);\n', '  }\n', '\n', '  function spread(address[] _addresses, uint256[] _amounts) public onlyController {\n', '    require(_addresses.length == _amounts.length);\n', '\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      address addr = _addresses[i];\n', '      if (!been_spread[addr]) {\n', '        uint256 amount = _amounts[i];\n', '        assert(msp.transfer(addr, amount));\n', '        been_spread[addr] = true;\n', '      }\n', '    }\n', '  }\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) onlyController {\n', '    if (_token == 0x0) {\n', '      controller.transfer(this.balance);\n', '      return;\n', '    }\n', '\n', '    ERC20Token token = ERC20Token(_token);\n', '    uint balance = token.balanceOf(this);\n', '    token.transfer(controller, balance);\n', '    ClaimedTokens(_token, controller, balance);\n', '  }\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '}']