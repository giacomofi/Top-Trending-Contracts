['pragma solidity 0.4.15;\n', '\n', 'contract owned {\n', '    \n', '    address public owner;\n', '    \n', '    event ContractOwnershipTransferred(address newOwner);\n', '    \n', '    function owned() { owner = msg.sender; }\n', '    \n', '    modifier onlyOwner { \n', '        require(msg.sender == owner); \n', '        _; \n', '    }\n', '    \n', '    function setContractOwner(address newOwner) external onlyOwner  {\n', '        owner = newOwner;\n', '        ContractOwnershipTransferred(newOwner);\n', '    }\n', '}\n', '\n', '/// Cillionaire is a lottery where people can participate until a pot limit is reached. Then, a random participant is chosen to be the winner.\n', '/// \n', '/// Randomness is achieved by XOR&#39;ing the following two numbers:\n', '/// ownerRandomNumber ... a random number supplied by the contract owner and submitted upon `start` as a hash, much like a concealed bid in an auction.\n', '/// minerRandomNumber ... timestamp of the block that contains the last participant&#39;s `particpate` transaction.\n', '/// Neither can the owner know the minerRandomNumber, nor can the miner know the ownerRandomNumber (unless the owner supplies a breakable hash, e.h. keccak256(1)).\n', '///\n', '/// Many safeguards are in place to prevent loss of participants&#39; stakes and ensure fairness:\n', '/// - The owner can `cancel`, in which case participants must be refunded.\n', '/// - If the owner does not end the game via `chooseWinner` within 24 hours after PARTICIPATION `state` ended, then anyone can `cancel`.\n', '/// - The contract has no `kill` function which would allow the owner to run off with the pot.\n', '/// - Game parameters cannot be changed when a game is ongoing\n', '/// - Logging of relevant events to increase transparency\n', 'contract Cillionaire is owned {\n', '    \n', '    enum State { ENDED, PARTICIPATION, CHOOSE_WINNER, REFUND }\n', '\n', '    /// Target amount of ether. As long as the `potTarget` is not reached, people can `participate` when the contract is in PARTICIPATION `state`.\n', '    uint public potTarget;\n', '    /// Amount of ether that will be used to `participate`.\n', '    uint public stake;\n', '    /// Amount of ether that will be taken from `stake` as a fee for the owner.\n', '    uint public fee;\n', '    \n', '    State public state;\n', '    address[] public participants;\n', '    bytes32 public ownerRandomHash;\n', '    uint public minerRandomNumber;\n', '    uint public ownerRandomNumber;\n', '    uint public participationEndTimestamp;\n', '    uint public pot;\n', '    address public winner;\n', '    mapping (address => uint) public funds;\n', '    uint public fees;\n', '    uint public lastRefundedIndex;\n', '    \n', '    event StateChange(State newState);\n', '    event NewParticipant(address participant, uint total, uint stakeAfterFee, uint refundNow);\n', '    event MinerRandomNumber(uint number);\n', '    event OwnerRandomNumber(uint number);\n', '    event RandomNumber(uint randomNumber);\n', '    event WinnerIndex(uint winnerIndex);\n', '    event Winner(address _winner, uint amount);\n', '    event Refund(address participant, uint amount);\n', '    event Cancelled(address cancelledBy);\n', '    event ParametersChanged(uint newPotTarget, uint newStake, uint newFee);\n', '    \n', '    modifier onlyState(State _state) { \n', '        require(state == _state); \n', '        _; \n', '    }\n', '    \n', '    // Taken from: https://solidity.readthedocs.io/en/develop/common-patterns.html\n', '    // This modifier requires a certain\n', '    // fee being associated with a function call.\n', '    // If the caller sent too much, he or she is\n', '    // refunded, but only after the function body.\n', '    // This was dangerous before Solidity version 0.4.0,\n', '    // where it was possible to skip the part after `_;`.\n', '    modifier costs(uint _amount) {\n', '        require(msg.value >= _amount);\n', '        _;\n', '        if (msg.value > _amount) {\n', '            msg.sender.transfer(msg.value - _amount);\n', '        }\n', '    }\n', '    \n', '    function Cillionaire() {\n', '        state = State.ENDED;\n', '        potTarget = 0.1 ether;\n', '        stake = 0.05 ether;\n', '        fee = 0;\n', '    }\n', '    \n', '    function setState(State _state) internal {\n', '        state = _state;\n', '        StateChange(state);\n', '    }\n', '    \n', '    /// Starts the game, i.e. resets game variables and transitions to state `PARTICIPATION`\n', '    /// `_ownerRandomHash` is the owner&#39;s concealed random number. \n', '    /// It must be a keccak256 hash that can be verfied in `chooseWinner`.\n', '    function start(bytes32 _ownerRandomHash) external onlyOwner onlyState(State.ENDED) {\n', '        ownerRandomHash = _ownerRandomHash;\n', '        minerRandomNumber = 0;\n', '        ownerRandomNumber = 0;\n', '        participationEndTimestamp = 0;\n', '        winner = 0;\n', '        pot = 0;\n', '        lastRefundedIndex = 0;\n', '        delete participants;\n', '        setState(State.PARTICIPATION);\n', '    }\n', '    \n', '    /// Participate in the game.\n', '    /// You must send at least `stake` amount of ether. Surplus ether is refunded automatically and immediately.\n', '    /// This function will only work when the contract is in `state` PARTICIPATION.\n', '    /// Once the `potTarget` is reached, the `state` transitions to CHOOSE_WINNER.\n', '    function participate() external payable onlyState(State.PARTICIPATION) costs(stake) {\n', '        participants.push(msg.sender);\n', '        uint stakeAfterFee = stake - fee;\n', '        pot += stakeAfterFee;\n', '        fees += fee;\n', '        NewParticipant(msg.sender, msg.value, stakeAfterFee, msg.value - stake);\n', '        if (pot >= potTarget) {\n', '            participationEndTimestamp = block.timestamp;\n', '            minerRandomNumber = block.timestamp;\n', '            MinerRandomNumber(minerRandomNumber);\n', '            setState(State.CHOOSE_WINNER);\n', '        }\n', '    }\n', '    \n', '    /// Reveal the owner&#39;s random number and choose a winner using all three random numbers.\n', '    /// The winner is credited the pot and can get their funds using `withdraw`.\n', '    /// This function will only work when the contract is in `state` CHOOSE_WINNER.\n', '    function chooseWinner(string _ownerRandomNumber, string _ownerRandomSecret) external onlyOwner onlyState(State.CHOOSE_WINNER) {\n', '        require(keccak256(_ownerRandomNumber, _ownerRandomSecret) == ownerRandomHash);\n', '        require(!startsWithDigit(_ownerRandomSecret)); // This is needed because keccak256("12", "34") == keccak256("1", "234") to prevent owner from changing his initially comitted random number\n', '        ownerRandomNumber = parseInt(_ownerRandomNumber);\n', '        OwnerRandomNumber(ownerRandomNumber);\n', '        uint randomNumber = ownerRandomNumber ^ minerRandomNumber;\n', '        RandomNumber(randomNumber);\n', '        uint winnerIndex = randomNumber % participants.length;\n', '        WinnerIndex(winnerIndex);\n', '        winner = participants[winnerIndex];\n', '        funds[winner] += pot;\n', '        Winner(winner, pot);\n', '        setState(State.ENDED);\n', '    }\n', '    \n', '    /// Cancel the game.\n', '    /// Participants&#39; stakes (including fee) are refunded. Use the `withdraw` function to get the refund.\n', '    /// Owner can cancel at any time in `state` PARTICIPATION or CHOOSE_WINNER\n', '    /// Anyone can cancel 24h after `state` PARTICIPATION ended. This is to make sure no funds get locked up due to inactivity of the owner.\n', '    function cancel() external {\n', '        if (msg.sender == owner) {\n', '            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);\n', '        } else {\n', '            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));\n', '        }\n', '        Cancelled(msg.sender);\n', '        // refund index 0 so lastRefundedIndex=0 is correct\n', '        if (participants.length > 0) {\n', '            funds[participants[0]] += stake;\n', '            fees -= fee;\n', '            lastRefundedIndex = 0;\n', '            Refund(participants[0], stake);\n', '            if (participants.length == 1) {\n', '                setState(State.ENDED);\n', '            } else {\n', '                setState(State.REFUND);\n', '            }\n', '        } else {\n', '            // nothing to refund\n', '            setState(State.ENDED);\n', '        }\n', '    }\n', '    \n', '    /// Refund a number of accounts specified by `_count`, beginning at the next un-refunded index which is lastRefundedIndex`+1.\n', '    /// This is so that refunds can be dimensioned such that they don&#39;t exceed block gas limit.\n', '    /// Once all participants are refunded `state` transitions to ENDED.\n', '    /// Any user can do the refunds.\n', '    function refund(uint _count) onlyState(State.REFUND) {\n', '        require(participants.length > 0);\n', '        uint first = lastRefundedIndex + 1;\n', '        uint last = lastRefundedIndex + _count;\n', '        if (last > participants.length - 1) {\n', '            last = participants.length - 1;\n', '        }\n', '        for (uint i = first; i <= last; i++) {\n', '            funds[participants[i]] += stake;\n', '            fees -= fee;\n', '            Refund(participants[i], stake);\n', '        }\n', '        lastRefundedIndex = last;\n', '        if (lastRefundedIndex >= participants.length - 1) {\n', '            setState(State.ENDED);\n', '        }\n', '    }\n', '\n', '    /// Withdraw your funds, i.e. winnings and refunds.\n', '    /// This function can be called in any state and will withdraw all winnings as well as refunds. \n', '    function withdraw() external {\n', '        uint amount = funds[msg.sender];\n', '        funds[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    /// Withdraw accumulated fees. \n', '    /// Usable by contract owner when `state` is ENDED.\n', '    function withdrawFees() external onlyOwner onlyState(State.ENDED) {\n', '        uint amount = fees;\n', '        fees = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    /// Adjust game parameters. All parameters are in Wei.\n', '    /// Can be called by the contract owner in `state` ENDED.\n', '    function setParams(uint _potTarget, uint _stake, uint _fee) external onlyOwner onlyState(State.ENDED) {\n', '        require(_fee < _stake);\n', '        potTarget = _potTarget;\n', '        stake = _stake; \n', '        fee = _fee;\n', '        ParametersChanged(potTarget, stake, fee);\n', '    }\n', '    \n', '    function startsWithDigit(string str) internal returns (bool) {\n', '        bytes memory b = bytes(str);\n', '        return b[0] >= 48 && b[0] <= 57; // 0-9; see http://dev.networkerror.org/utf8/\n', '    }\n', '    \n', '    // parseInt \n', '    // Copyright (c) 2015-2016 Oraclize SRL\n', '    // Copyright (c) 2016 Oraclize LTD\n', '    // Source: https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', '    function parseInt(string _a) internal returns (uint) {\n', '        return parseInt(_a, 0);\n', '    }\n', '\n', '    // parseInt(parseFloat*10^_b)\n', '    // Copyright (c) 2015-2016 Oraclize SRL\n', '    // Copyright (c) 2016 Oraclize LTD\n', '    // Source: https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', '    function parseInt(string _a, uint _b) internal returns (uint) {\n', '        bytes memory bresult = bytes(_a);\n', '        uint mint = 0;\n', '        bool decimals = false;\n', '        for (uint i=0; i<bresult.length; i++){\n', '            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n', '                if (decimals){\n', '                   if (_b == 0) break;\n', '                    else _b--;\n', '                }\n', '                mint *= 10;\n', '                mint += uint(bresult[i]) - 48;\n', '            } else if (bresult[i] == 46) decimals = true;\n', '        }\n', '        if (_b > 0) mint *= 10**_b;\n', '        return mint;\n', '    }\n', '\n', '}']