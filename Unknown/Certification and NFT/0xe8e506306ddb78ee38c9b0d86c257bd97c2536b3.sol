['contract TheDAOHardForkOracle {\n', '    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n', '    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n', '\n', '    // public, so accessors available\n', '    bool public ran;\n', '    bool public forked;\n', '    bool public notforked;\n', '    \n', '    modifier after_dao_hf_block {\n', '        if (block.number < 1920000) throw;\n', '        _\n', '    }\n', '    \n', '    modifier run_once {\n', '        if (ran) throw;\n', '        _\n', '    }\n', '\n', '    modifier has_millions(address _addr, uint _millions) {\n', '        if (_addr.balance >= (_millions * 1000000 ether)) _\n', '    }\n', '\n', '    // 10M ether is ~ 2M less than would be available for a short\n', '    // while in WithdrawDAO after the HF, but probably more than\n', '    // anyone is willing to drop into WithdrawDAO in Classic\n', '    function check_withdrawdao() internal\n', '        has_millions(WithdrawDAO, 10) {\n', '        forked = true;\n', '    }\n', '\n', '    // failsafe: if the above assumption is incorrect, HF tine\n', "    // won't have balance in DarkDAO anyway, and Classic has a\n", '    // sliver of time before DarkDAO split happens\n', '    function check_darkdao() internal\n', '        has_millions(DarkDAO, 3) {\n', '        notforked = true;\n', '    }\n', '\n', '    // running is possible only once\n', '    // after that the dapp can only throw\n', '    function ()\n', '        after_dao_hf_block run_once {\n', '        ran = true;\n', '\n', '        check_withdrawdao();\n', '        check_darkdao();\n', '\n', '        // if both flags are same, then something went wrong\n', '        if (forked == notforked) throw;\n', '    }\n', '}']