['/*\n', 'This file is part of WeiFund.\n', '*/\n', '\n', '/*\n', 'A generic issued EC20 standard token, that can be issued by an issuer which the owner\n', 'of the contract sets. The issuer can only be set once if the onlyOnce option is true.\n', 'There is a freezePeriod option on transfers, if need be. There is also an date of\n', 'last issuance setting, if set, no more tokens can be issued past that time.\n', '\n', 'The token uses the a standard token API as much as possible, and overrides the transfer\n', 'and transferFrom methods. This way, we dont need special API&#39;s to issue this token.\n', 'We can retain the original StandardToken api, but add additional features.\n', '\n', 'Upon construction, initial token holders can be specified with their values.\n', 'Two arrays must be used. One with the token holer addresses, the other with the token\n', 'holder balances. They must be aligned by array index.\n', '*/\n', '\n', 'pragma solidity ^0.4.4;\n', '/*\n', 'This file is part of WeiFund.\n', '*/\n', '\n', '/*\n', 'A common Owned contract that contains properties for contract ownership.\n', '*/\n', '\n', '\n', '\n', '/// @title A single owned campaign contract for instantiating ownership properties.\n', '/// @author Nick Dodson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5bbbcb6befbb1bab1a6babb95b6babba6b0bba6aca6fbbbb0a1">[email&#160;protected]</a>>\n', 'contract Owned {\n', '  // only the owner can use this method\n', '  modifier onlyowner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '\n', '    _;\n', '  }\n', '\n', '  // the owner property\n', '  address public owner;\n', '}\n', '\n', '/*\n', 'This file is part of WeiFund.\n', '*/\n', '\n', '\n', '/*\n', 'This implements ONLY the standard functions and NOTHING else.\n', 'For a token like you would want to deploy in something like Mist, see HumanStandardToken.sol.\n', '\n', 'If you deploy this, you won&#39;t have anything useful.\n', '\n', 'Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', '.*/\n', '/*\n', 'This file is part of WeiFund.\n', '*/\n', '\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '}\n', '\n', '\n', '/*\n', 'This file is part of WeiFund.\n', '*/\n', '\n', '/*\n', 'Used for contracts that have an issuer.\n', '*/\n', '\n', '\n', '\n', '/// @title Issued - interface used for build issued asset contracts\n', '/// @author Nick Dodson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="56383f353d7832393225393816353938253338252f2578383322">[email&#160;protected]</a>>\n', 'contract Issued {\n', '  /// @notice will set the asset issuer address\n', '  /// @param _issuer The address of the issuer\n', '  function setIssuer(address _issuer) public {}\n', '}\n', '\n', '\n', '\n', '/// @title Issued token contract allows new tokens to be issued by an issuer.\n', '/// @author Nick Dodson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9a7a0aaa2e7ada6adbaa6a789aaa6a7baaca7bab0bae7a7acbd">[email&#160;protected]</a>>\n', 'contract IssuedToken is Owned, Issued, StandardToken {\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    // if the issuer is attempting transfer\n', '    // then mint new coins to address of transfer\n', '    // by using transfer, we dont need to switch StandardToken API method\n', '    if (msg.sender == issuer && (lastIssuance == 0 || block.number < lastIssuance)) {\n', '      // increase the balance of user by transfer amount\n', '      balances[_to] += _value;\n', '\n', '      // increase total supply by balance\n', '      totalSupply += _value;\n', '\n', '      // return required true value for transfer\n', '      return true;\n', '    } else {\n', '      if (freezePeriod == 0 || block.number > freezePeriod) {\n', '        // continue with a normal transfer\n', '        return super.transfer(_to, _value);\n', '      }\n', '    }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    returns (bool success) {\n', '    // if we are passed the free period, then transferFrom\n', '    if (freezePeriod == 0 || block.number > freezePeriod) {\n', '      // return transferFrom\n', '      return super.transferFrom(_from, _to, _value);\n', '    }\n', '  }\n', '\n', '  function setIssuer(address _issuer) public onlyowner() {\n', '    // set the issuer\n', '    if (issuer == address(0)) {\n', '      issuer = _issuer;\n', '    } else {\n', '      throw;\n', '    }\n', '  }\n', '\n', '  function IssuedToken(\n', '    address[] _addrs,\n', '    uint256[] _amounts,\n', '    uint256 _freezePeriod,\n', '    uint256 _lastIssuance,\n', '    address _owner,\n', '    string _name,\n', '    uint8 _decimals,\n', '    string _symbol) {\n', '    // issue the initial tokens, if any\n', '    for (uint256 i = 0; i < _addrs.length; i ++) {\n', '      // increase balance of that address\n', '      balances[_addrs[i]] += _amounts[i];\n', '\n', '      // increase token supply of that address\n', '      totalSupply += _amounts[i];\n', '    }\n', '\n', '    // set the transfer freeze period, if any\n', '    freezePeriod = _freezePeriod;\n', '\n', '    // set the token owner, who can set the issuer\n', '    owner = _owner;\n', '\n', '    // set the blocknumber of last issuance, if any\n', '    lastIssuance = _lastIssuance;\n', '\n', '    // set token name\n', '    name = _name;\n', '\n', '    // set decimals\n', '    decimals = _decimals;\n', '\n', '    // set sumbol\n', '    symbol = _symbol;\n', '  }\n', '\n', '  // the transfer freeze period\n', '  uint256 public freezePeriod;\n', '\n', '  // the block number of last issuance (set to zero, if none)\n', '  uint256 public lastIssuance;\n', '\n', '  // the token issuer address, if any\n', '  address public issuer;\n', '\n', '  // token name\n', '  string public name;\n', '\n', '  // token decimals\n', '  uint8 public decimals;\n', '\n', '  // symbol\n', '  string public symbol;\n', '\n', '  // verison\n', '  string public version = "WFIT1.0";\n', '}\n', '\n', '\n', '/// @title Private Service Registry - used to register generated service contracts.\n', '/// @author Nick Dodson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0c62656f67226863687f63624c6f63627f69627f757f22626978">[email&#160;protected]</a>>\n', 'contract PrivateServiceRegistryInterface {\n', '  /// @notice register the service &#39;_service&#39; with the private service registry\n', '  /// @param _service the service contract to be registered\n', '  /// @return the service ID &#39;serviceId&#39;\n', '  function register(address _service) internal returns (uint256 serviceId) {}\n', '\n', '  /// @notice is the service in question &#39;_service&#39; a registered service with this registry\n', '  /// @param _service the service contract address\n', '  /// @return either yes (true) the service is registered or no (false) the service is not\n', '  function isService(address _service) public constant returns (bool) {}\n', '\n', '  /// @notice helps to get service address\n', '  /// @param _serviceId the service ID\n', '  /// @return returns the service address of service ID\n', '  function services(uint256 _serviceId) public constant returns (address _service) {}\n', '\n', '  /// @notice returns the id of a service address, if any\n', '  /// @param _service the service contract address\n', '  /// @return the service id of a service\n', '  function ids(address _service) public constant returns (uint256 serviceId) {}\n', '\n', '  event ServiceRegistered(address _sender, address _service);\n', '}\n', '\n', 'contract PrivateServiceRegistry is PrivateServiceRegistryInterface {\n', '\n', '  modifier isRegisteredService(address _service) {\n', '    // does the service exist in the registry, is the service address not empty\n', '    if (services.length > 0) {\n', '      if (services[ids[_service]] == _service && _service != address(0)) {\n', '        _;\n', '      }\n', '    }\n', '  }\n', '\n', '  modifier isNotRegisteredService(address _service) {\n', '    // if the service &#39;_service&#39; is not a registered service\n', '    if (!isService(_service)) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  function register(address _service)\n', '    internal\n', '    isNotRegisteredService(_service)\n', '    returns (uint serviceId) {\n', '    // create service ID by increasing services length\n', '    serviceId = services.length++;\n', '\n', '    // set the new service ID to the &#39;_service&#39; address\n', '    services[serviceId] = _service;\n', '\n', '    // set the ids store to link to the &#39;serviceId&#39; created\n', '    ids[_service] = serviceId;\n', '\n', '    // fire the &#39;ServiceRegistered&#39; event\n', '    ServiceRegistered(msg.sender, _service);\n', '  }\n', '\n', '  function isService(address _service)\n', '    public\n', '    constant\n', '    isRegisteredService(_service)\n', '    returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  address[] public services;\n', '  mapping(address => uint256) public ids;\n', '}\n', '\n', '/// @title Issued Token Factory - used to generate and register IssuedToken contracts\n', '/// @author Nick Dodson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="93fdfaf0f8bdf7fcf7e0fcfdd3f0fcfde0f6fde0eae0bdfdf6e7">[email&#160;protected]</a>>\n', 'contract IssuedTokenFactory is PrivateServiceRegistry {\n', '  function createIssuedToken(\n', '    address[] _addrs,\n', '    uint256[] _amounts,\n', '    uint256 _freezePeriod,\n', '    uint256 _lastIssuance,\n', '    string _name,\n', '    uint8 _decimals,\n', '    string _symbol)\n', '  public\n', '  returns (address tokenAddress) {\n', '    // create a new multi sig wallet\n', '    tokenAddress = address(new IssuedToken(\n', '      _addrs,\n', '      _amounts,\n', '      _freezePeriod,\n', '      _lastIssuance,\n', '      msg.sender,\n', '      _name,\n', '      _decimals,\n', '      _symbol));\n', '\n', '    // register that multisig wallet address as service\n', '    register(tokenAddress);\n', '  }\n', '}']