['pragma solidity ^0.4.11;\n', '\n', '/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\n', 'contract AuthenticationManager {\n', '    /* Map addresses to admins */\n', '    mapping (address => bool) adminAddresses;\n', '\n', '    /* Map addresses to account readers */\n', '    mapping (address => bool) accountReaderAddresses;\n', '\n', '    /* Details of all admins that have ever existed */\n', '    address[] adminAudit;\n', '\n', '    /* Details of all account readers that have ever existed */\n', '    address[] accountReaderAudit;\n', '\n', '    /* Fired whenever an admin is added to the contract. */\n', '    event AdminAdded(address addedBy, address admin);\n', '\n', '    /* Fired whenever an admin is removed from the contract. */\n', '    event AdminRemoved(address removedBy, address admin);\n', '\n', '    /* Fired whenever an account-reader contract is added. */\n', '    event AccountReaderAdded(address addedBy, address account);\n', '\n', '    /* Fired whenever an account-reader contract is removed. */\n', '    event AccountReaderRemoved(address removedBy, address account);\n', '\n', '    /* When this contract is first setup we use the creator as the first admin */    \n', '    function AuthenticationManager() {\n', '        /* Set the first admin to be the person creating the contract */\n', '        adminAddresses[msg.sender] = true;\n', '        AdminAdded(0, msg.sender);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = msg.sender;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        // Admin contract identifies as 100YYYYMMDDHHMM\n', '        return 100201707171503;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an admin */\n', '    function isCurrentAdmin(address _address) constant returns (bool) {\n', '        return adminAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < adminAudit.length; i++)\n', '            if (adminAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an account reader */\n', '    function isCurrentAccountReader(address _address) constant returns (bool) {\n', '        return accountReaderAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < accountReaderAudit.length; i++)\n', '            if (accountReaderAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Adds a user to our list of admins */\n', '    function addAdmin(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already admin\n', '        if (adminAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        adminAddresses[_address] = true;\n', '        AdminAdded(msg.sender, _address);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user from our list of admins but keeps them in the history audit */\n', '    function removeAdmin(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        /* Don&#39;t allow removal of self */\n', '        if (_address == msg.sender)\n', '            throw;\n', '\n', '        // Fail if this account is already non-admin\n', '        if (!adminAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        adminAddresses[_address] = false;\n', '        AdminRemoved(msg.sender, _address);\n', '    }\n', '\n', '    /* Adds a user/contract to our list of account readers */\n', '    function addAccountReader(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already in the list\n', '        if (accountReaderAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        accountReaderAddresses[_address] = true;\n', '        AccountReaderAdded(msg.sender, _address);\n', '        accountReaderAudit.length++;\n', '        accountReaderAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\n', '    function removeAccountReader(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already not in the list\n', '        if (!accountReaderAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        accountReaderAddresses[_address] = false;\n', '        AccountReaderRemoved(msg.sender, _address);\n', '    }\n', '}\n', '\n', '/* The transparency relayer contract is responsible for keeping an immutable ledger of account balances that can be audited at a later time .*/\n', 'contract TransparencyRelayer {\n', '    /* Represents what SIFT administration report the fund as being worth at a snapshot moment in time. */\n', '    struct FundValueRepresentation {\n', '        uint256 usdValue;\n', '        uint256 etherEquivalent;\n', '        uint256 suppliedTimestamp;\n', '        uint256 blockTimestamp;\n', '    }\n', '\n', '    /* Represents a published balance of a particular account at a moment in time. */\n', '    struct AccountBalanceRepresentation {\n', '        string accountType; /* Bitcoin, USD, etc. */\n', '        string accountIssuer; /* Kraken, Bank of America, etc. */\n', '        uint256 balance; /* Rounded to appropriate for balance - i.e. full USD or full BTC */\n', '        string accountReference; /* Could be crypto address, bank account number, etc. */\n', '        string validationUrl; /* Some validation URL - i.e. base64 encoded notary */\n', '        uint256 suppliedTimestamp;\n', '        uint256 blockTimestamp;\n', '    }\n', '\n', '    /* An array defining all the fund values as supplied by SIFT over the time of the contract. */\n', '    FundValueRepresentation[] public fundValues;\n', '    \n', '    /* An array defining the history of account balances over time. */\n', '    AccountBalanceRepresentation[] public accountBalances;\n', '\n', '    /* Defines the admin contract we interface with for credentails. */\n', '    AuthenticationManager authenticationManager;\n', '\n', '    /* Fired when the fund value is updated by an administrator. */\n', '    event FundValue(uint256 usdValue, uint256 etherEquivalent, uint256 suppliedTimestamp, uint256 blockTimestamp);\n', '\n', '    /* Fired when an account balance is being supplied in some confirmed form for future validation on the blockchain. */\n', '    event AccountBalance(string accountType, string accountIssuer, uint256 balance, string accountReference, string validationUrl, uint256 timestamp, uint256 blockTimestamp);\n', '\n', '    /* This modifier allows a method to only be called by current admins */\n', '    modifier adminOnly {\n', '        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    /* Create our contract and specify the location of other addresses */\n', '    function TransparencyRelayer(address _authenticationManagerAddress) {\n', '        /* Setup access to our other contracts and validate their versions */\n', '        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\n', '        if (authenticationManager.contractVersion() != 100201707171503)\n', '            throw;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        /* Transparency contract identifies as 200YYYYMMDDHHMM */\n', '        return 200201707071127;\n', '    }\n', '\n', '    /* Returns how many fund values are present in the market. */\n', '    function fundValueCount() constant returns (uint256 _count) {\n', '        _count = fundValues.length;\n', '    }\n', '\n', '    /* Returns how account balances are present in the market. */\n', '    function accountBalanceCount() constant returns (uint256 _count) {\n', '        _count = accountBalances.length;\n', '    }\n', '\n', '    /* Defines the current value of the funds assets in USD and ETHER */\n', '    function fundValuePublish(uint256 _usdTotalFund, uint256 _etherTotalFund, uint256 _definedTimestamp) adminOnly {\n', '        /* Store values */\n', '        fundValues.length++;\n', '        fundValues[fundValues.length - 1] = FundValueRepresentation(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\n', '\n', '        /* Audit this */\n', '        FundValue(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\n', '    }\n', '\n', '    function accountBalancePublish(string _accountType, string _accountIssuer, uint256 _balance, string _accountReference, string _validationUrl, uint256 _timestamp) adminOnly {\n', '        /* Store values */\n', '        accountBalances.length++;\n', '        accountBalances[accountBalances.length - 1] = AccountBalanceRepresentation(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\n', '\n', '        /* Audit this */\n', '        AccountBalance(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\n', 'contract AuthenticationManager {\n', '    /* Map addresses to admins */\n', '    mapping (address => bool) adminAddresses;\n', '\n', '    /* Map addresses to account readers */\n', '    mapping (address => bool) accountReaderAddresses;\n', '\n', '    /* Details of all admins that have ever existed */\n', '    address[] adminAudit;\n', '\n', '    /* Details of all account readers that have ever existed */\n', '    address[] accountReaderAudit;\n', '\n', '    /* Fired whenever an admin is added to the contract. */\n', '    event AdminAdded(address addedBy, address admin);\n', '\n', '    /* Fired whenever an admin is removed from the contract. */\n', '    event AdminRemoved(address removedBy, address admin);\n', '\n', '    /* Fired whenever an account-reader contract is added. */\n', '    event AccountReaderAdded(address addedBy, address account);\n', '\n', '    /* Fired whenever an account-reader contract is removed. */\n', '    event AccountReaderRemoved(address removedBy, address account);\n', '\n', '    /* When this contract is first setup we use the creator as the first admin */    \n', '    function AuthenticationManager() {\n', '        /* Set the first admin to be the person creating the contract */\n', '        adminAddresses[msg.sender] = true;\n', '        AdminAdded(0, msg.sender);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = msg.sender;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        // Admin contract identifies as 100YYYYMMDDHHMM\n', '        return 100201707171503;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an admin */\n', '    function isCurrentAdmin(address _address) constant returns (bool) {\n', '        return adminAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < adminAudit.length; i++)\n', '            if (adminAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an account reader */\n', '    function isCurrentAccountReader(address _address) constant returns (bool) {\n', '        return accountReaderAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < accountReaderAudit.length; i++)\n', '            if (accountReaderAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Adds a user to our list of admins */\n', '    function addAdmin(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already admin\n', '        if (adminAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        adminAddresses[_address] = true;\n', '        AdminAdded(msg.sender, _address);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user from our list of admins but keeps them in the history audit */\n', '    function removeAdmin(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', "        /* Don't allow removal of self */\n", '        if (_address == msg.sender)\n', '            throw;\n', '\n', '        // Fail if this account is already non-admin\n', '        if (!adminAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        adminAddresses[_address] = false;\n', '        AdminRemoved(msg.sender, _address);\n', '    }\n', '\n', '    /* Adds a user/contract to our list of account readers */\n', '    function addAccountReader(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already in the list\n', '        if (accountReaderAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        accountReaderAddresses[_address] = true;\n', '        AccountReaderAdded(msg.sender, _address);\n', '        accountReaderAudit.length++;\n', '        accountReaderAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\n', '    function removeAccountReader(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already not in the list\n', '        if (!accountReaderAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        accountReaderAddresses[_address] = false;\n', '        AccountReaderRemoved(msg.sender, _address);\n', '    }\n', '}\n', '\n', '/* The transparency relayer contract is responsible for keeping an immutable ledger of account balances that can be audited at a later time .*/\n', 'contract TransparencyRelayer {\n', '    /* Represents what SIFT administration report the fund as being worth at a snapshot moment in time. */\n', '    struct FundValueRepresentation {\n', '        uint256 usdValue;\n', '        uint256 etherEquivalent;\n', '        uint256 suppliedTimestamp;\n', '        uint256 blockTimestamp;\n', '    }\n', '\n', '    /* Represents a published balance of a particular account at a moment in time. */\n', '    struct AccountBalanceRepresentation {\n', '        string accountType; /* Bitcoin, USD, etc. */\n', '        string accountIssuer; /* Kraken, Bank of America, etc. */\n', '        uint256 balance; /* Rounded to appropriate for balance - i.e. full USD or full BTC */\n', '        string accountReference; /* Could be crypto address, bank account number, etc. */\n', '        string validationUrl; /* Some validation URL - i.e. base64 encoded notary */\n', '        uint256 suppliedTimestamp;\n', '        uint256 blockTimestamp;\n', '    }\n', '\n', '    /* An array defining all the fund values as supplied by SIFT over the time of the contract. */\n', '    FundValueRepresentation[] public fundValues;\n', '    \n', '    /* An array defining the history of account balances over time. */\n', '    AccountBalanceRepresentation[] public accountBalances;\n', '\n', '    /* Defines the admin contract we interface with for credentails. */\n', '    AuthenticationManager authenticationManager;\n', '\n', '    /* Fired when the fund value is updated by an administrator. */\n', '    event FundValue(uint256 usdValue, uint256 etherEquivalent, uint256 suppliedTimestamp, uint256 blockTimestamp);\n', '\n', '    /* Fired when an account balance is being supplied in some confirmed form for future validation on the blockchain. */\n', '    event AccountBalance(string accountType, string accountIssuer, uint256 balance, string accountReference, string validationUrl, uint256 timestamp, uint256 blockTimestamp);\n', '\n', '    /* This modifier allows a method to only be called by current admins */\n', '    modifier adminOnly {\n', '        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    /* Create our contract and specify the location of other addresses */\n', '    function TransparencyRelayer(address _authenticationManagerAddress) {\n', '        /* Setup access to our other contracts and validate their versions */\n', '        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\n', '        if (authenticationManager.contractVersion() != 100201707171503)\n', '            throw;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        /* Transparency contract identifies as 200YYYYMMDDHHMM */\n', '        return 200201707071127;\n', '    }\n', '\n', '    /* Returns how many fund values are present in the market. */\n', '    function fundValueCount() constant returns (uint256 _count) {\n', '        _count = fundValues.length;\n', '    }\n', '\n', '    /* Returns how account balances are present in the market. */\n', '    function accountBalanceCount() constant returns (uint256 _count) {\n', '        _count = accountBalances.length;\n', '    }\n', '\n', '    /* Defines the current value of the funds assets in USD and ETHER */\n', '    function fundValuePublish(uint256 _usdTotalFund, uint256 _etherTotalFund, uint256 _definedTimestamp) adminOnly {\n', '        /* Store values */\n', '        fundValues.length++;\n', '        fundValues[fundValues.length - 1] = FundValueRepresentation(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\n', '\n', '        /* Audit this */\n', '        FundValue(_usdTotalFund, _etherTotalFund, _definedTimestamp, now);\n', '    }\n', '\n', '    function accountBalancePublish(string _accountType, string _accountIssuer, uint256 _balance, string _accountReference, string _validationUrl, uint256 _timestamp) adminOnly {\n', '        /* Store values */\n', '        accountBalances.length++;\n', '        accountBalances[accountBalances.length - 1] = AccountBalanceRepresentation(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\n', '\n', '        /* Audit this */\n', '        AccountBalance(_accountType, _accountIssuer, _balance, _accountReference, _validationUrl, _timestamp, now);\n', '    }\n', '}']
