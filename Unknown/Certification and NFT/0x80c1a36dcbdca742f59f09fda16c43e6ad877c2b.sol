['pragma solidity ^ 0.4 .15;\n', '\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) revert();\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract owned {\n', '    address owner;\n', '\n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '}\n', '\n', 'contract Fish is owned, StandardToken {\n', '\n', '  string public constant TermsOfUse = "https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md";\n', '\n', '  /*\n', '   * State variables\n', '   */\n', '\n', '  string public constant symbol = "FSH";\n', '  string public constant name = "Fish";\n', '  uint8 public constant decimals = 3;\n', '\n', '  /*\n', '   * Constructor function\n', '   */\n', '\n', '  function Fish() {\n', '    owner = msg.sender;\n', '    balances[msg.sender] = 1;                                                   // Owner can now be a referral\n', '    totalSupply = 1;\n', '    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\n', '    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\n', '  }\n', '\n', '  function () payable { revert(); }\n', '\n', '  /*\n', '   * SECTION: PRICE GROWTH\n', '   *\n', '   * This section is responsible for daily price increase. Once per day the buy price will be increased \n', '   * through adjustPrice modifier. The price update happens before buy and sell functions are executed.\n', '   * Contract owner has only one way to control the growth rate here - setGrowth.\n', '   */\n', '\n', '  // Growth rate is present in parts per million (ppm)\n', '  uint32 public dailyGrowth_ppm = 6100;                                         // default growth is 20% (0.61% per day)\n', '  uint public dailyGrowthUpdated_date = now;                                    // Don&#39;t update it on first day of contract\n', '  \n', '  uint32 private constant dailyGrowthMin_ppm =  6096;                           // 20% every month in price growth or 0.00610 daily\n', '  uint32 private constant dailyGrowthMax_ppm = 23374;                           // 100% in growth every month or 0,02337 daily\n', '  \n', '  uint32 public constant sell_ppc = 90;                                         // Sell price is 90% of buy price\n', '\n', '  event DailyGrowthUpdate(uint _newRate_ppm);\n', '  event PriceAdjusted(uint _newBuyPrice_wei, uint _newSellPrice_wei);\n', '\n', '  /*\n', '   * MODIFIER\n', '   * If last update happened more than one day ago, update the price, save the time of current price update\n', '   * Adjust sell price and log the event\n', '   */\n', '  modifier adjustPrice() {\n', '    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\n', '      dailyGrowthUpdated_date = now;\n', '      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\n', '      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\n', '      PriceAdjusted(buyPrice_wie, sellPrice_wie);\n', '    }\n', '    _;\n', '  }\n', '\n', '  /* \n', '   * OWNER ONLY; EXTERNAL METHOD\n', '   * setGrowth can accept values within range from 20% to 100% of growth per month (based on 30 days per month assumption).\n', '   * \n', '   *   Formula is:\n', '   *\n', '   *       buyPrice_eth = buyPrice_eth * (1000000 + dailyGrowthMin_ppm) / 1000000;\n', '   *       ^new value     ^current value  ^1.0061 (if dailyGrowth_ppm == 6100)\n', '   *\n', '   *       1.0061^30 = 1.20 (if dailyGrowth_ppm == 6100)\n', '   *       1.023374^30 = 2 (if dailyGrowth_ppm == 23374)\n', '   * \n', '   *  Some other daily rates\n', '   *\n', '   *   Per month -> Value in ppm\n', '   *      1.3    ->  8783\n', '   *      1.4    -> 11278\n', '   *      1.5    -> 13607\n', '   *      1.6    -> 15790\n', '   *      1.7    -> 17844\n', '   *      1.8    -> 19786\n', '   */\n', '  function setGrowth(uint32 _newGrowth_ppm) onlyOwner external returns(bool result) {\n', '    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\n', '        _newGrowth_ppm <= dailyGrowthMax_ppm\n', '    ) {\n', '      dailyGrowth_ppm = _newGrowth_ppm;\n', '      DailyGrowthUpdate(_newGrowth_ppm);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* \n', '   * SECTION: TRADING\n', '   *\n', '   * This section is responsible purely for trading the tokens. User can buy tokens, user can sell tokens.\n', '   *\n', '   */\n', '\n', '  uint256 public sellPrice_wie;\n', '  uint256 public buyPrice_wie;\n', '\n', '  /*\n', '   * EXTERNAL METHOD\n', '   * User can buy arbitrary amount of tokens. Before amount of tokens will be calculated, the price of tokens \n', '   * has to be adjusted. This happens in adjustPrice modified before function call.\n', '   *\n', '   * Short description of this method\n', '   *\n', '   *   Calculate tokens that user is buying\n', '   *   Assign awards ro refereals\n', '   *   Add some bounty for new users who set referral before first buy\n', '   *   Send tokens that belong to contract or if there is non issue more and send them to user\n', '   *\n', '   * Read -> https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\n', '   */\n', '  function buy() adjustPrice payable external {\n', '    require(msg.value >= buyPrice_wie);\n', '    var amount = safeDiv(msg.value, buyPrice_wie);\n', '\n', '    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\n', '\n', '    // Buy discount if User is a new user and has set referral\n', '    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\n', '      // Check that user has to wait at least two weeks before he get break even on what he will get\n', '      amount = amount * (100 + landingDiscount_ppc) / 100;\n', '    }\n', '\n', '    issueTo(msg.sender, amount);\n', '  }\n', '\n', '  /*\n', '   * EXTERNAL METHOD\n', '   * User can sell tokens back to contract.\n', '   *\n', '   * Short description of this method\n', '   *\n', '   *   Adjust price\n', '   *   Calculate tokens price that user is selling \n', '   *   Make all possible checks\n', '   *   Transfer the money\n', '   */\n', '  function sell(uint256 _amount) adjustPrice external {\n', '    require(_amount > 0 && balances[msg.sender] >= _amount);\n', '    uint moneyWorth = safeMul(_amount, sellPrice_wie);\n', '    require(this.balance > moneyWorth);                                         // We can&#39;t sell if we don&#39;t have enough money\n', '    \n', '    if (\n', '        balances[this] + _amount > balances[this] &&\n', '        balances[msg.sender] - _amount < balances[msg.sender]\n', '    ) {\n', '      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner&#39;s balance\n', '      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller&#39;s balance\n', '      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It&#39;s important\n', '        revert();                                                               // to do this last to avoid recursion attacks\n', '      } else {\n', '        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\n', '      }        \n', '    } else {\n', '      revert();                                                                 // checks if the sender has enough to sell\n', '    }  \n', '  }\n', '\n', '  /*\n', '   * PRIVATE METHOD\n', '   * Issue  new tokens to contract\n', '   */\n', '  function issueTo(address _beneficiary, uint256 _amount_tkns) private {\n', '    if (\n', '        balances[this] >= _amount_tkns\n', '    ) {\n', '      // All tokens are taken from balance\n', '      balances[this] = safeSub(balances[this], _amount_tkns);\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\n', '    } else {\n', '      // Balance will be lowered and new tokens will be issued\n', '      uint diff = safeSub(_amount_tkns, balances[this]);\n', '\n', '      totalSupply = safeAdd(totalSupply, diff);\n', '      balances[this] = 0;\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\n', '    }\n', '    \n', '    Transfer(this, _beneficiary, _amount_tkns);\n', '  }\n', '  \n', '  /*\n', '   * SECTION: BOUNTIES\n', '   *\n', '   * This section describes all possible awards.\n', '   */\n', '    \n', '  mapping(address => address[3]) referrals;\n', '  mapping(address => uint256) bounties;\n', '\n', '  uint32 public constant landingDiscount_ppc = 4;                               // Landing discount is 4%\n', '\n', '  /*\n', '   * EXTERNAL METHOD \n', '   * Set your referral first. You will get 4% more tokens on your first buy and trigger a\n', '   * reward of whoever told you about this contract. A win-win scenario.\n', '   */\n', '  function referral(address _referral) external returns(bool) {\n', '    if ( balances[_referral] > 0 &&                                              // Referral participated already\n', '         balances[msg.sender] == 0  &&                                          // Sender is a new user\n', '         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\n', '    ) {\n', '      var referral_referrals = referrals[_referral];\n', '      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\n', '      return true;\n', '    }\n', '    \n', '    return false;\n', '  }\n', '\n', '  /*\n', '   * PRIVATE METHOD\n', '   * Award bounties to referrals.\n', '   */ \n', '  function assignBountryToReferals(address _referralsOf, uint256 _amount) private {\n', '    var refs = referrals[_referralsOf];\n', '    \n', '    if (refs[0] != 0) {\n', '     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\n', '      if (refs[1] != 0) {\n', '        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\n', '        if (refs[2] != 0) {\n', '          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\n', '       }\n', '      }\n', '    }\n', '  }\n', '\n', '  /*\n', '   * OWNER ONLY; EXTERNAL METHOD\n', '   * Santa is coming! Who ever made impact to promote the Fish and can prove it will get the bonus\n', '   */\n', '  function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) {\n', '    require(_amount > 0); \n', '     \n', '    if (balances[_account] > 0 &&                                               // Account had participated already\n', '        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\n', '    ) {\n', '      issueTo(_account, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '}']
['pragma solidity ^ 0.4 .15;\n', '\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) revert();\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract owned {\n', '    address owner;\n', '\n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '}\n', '\n', 'contract Fish is owned, StandardToken {\n', '\n', '  string public constant TermsOfUse = "https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md";\n', '\n', '  /*\n', '   * State variables\n', '   */\n', '\n', '  string public constant symbol = "FSH";\n', '  string public constant name = "Fish";\n', '  uint8 public constant decimals = 3;\n', '\n', '  /*\n', '   * Constructor function\n', '   */\n', '\n', '  function Fish() {\n', '    owner = msg.sender;\n', '    balances[msg.sender] = 1;                                                   // Owner can now be a referral\n', '    totalSupply = 1;\n', '    buyPrice_wie= 100000000000000;                                              // 100 szabo per one token. One unit = 1000 tokens. 1 ether = 10 units\n', '    sellPrice_wie = buyPrice_wie * sell_ppc / 100;\n', '  }\n', '\n', '  function () payable { revert(); }\n', '\n', '  /*\n', '   * SECTION: PRICE GROWTH\n', '   *\n', '   * This section is responsible for daily price increase. Once per day the buy price will be increased \n', '   * through adjustPrice modifier. The price update happens before buy and sell functions are executed.\n', '   * Contract owner has only one way to control the growth rate here - setGrowth.\n', '   */\n', '\n', '  // Growth rate is present in parts per million (ppm)\n', '  uint32 public dailyGrowth_ppm = 6100;                                         // default growth is 20% (0.61% per day)\n', "  uint public dailyGrowthUpdated_date = now;                                    // Don't update it on first day of contract\n", '  \n', '  uint32 private constant dailyGrowthMin_ppm =  6096;                           // 20% every month in price growth or 0.00610 daily\n', '  uint32 private constant dailyGrowthMax_ppm = 23374;                           // 100% in growth every month or 0,02337 daily\n', '  \n', '  uint32 public constant sell_ppc = 90;                                         // Sell price is 90% of buy price\n', '\n', '  event DailyGrowthUpdate(uint _newRate_ppm);\n', '  event PriceAdjusted(uint _newBuyPrice_wei, uint _newSellPrice_wei);\n', '\n', '  /*\n', '   * MODIFIER\n', '   * If last update happened more than one day ago, update the price, save the time of current price update\n', '   * Adjust sell price and log the event\n', '   */\n', '  modifier adjustPrice() {\n', '    if ( (dailyGrowthUpdated_date + 1 days) < now ) {\n', '      dailyGrowthUpdated_date = now;\n', '      buyPrice_wie = buyPrice_wie * (1000000 + dailyGrowth_ppm) / 1000000;\n', '      sellPrice_wie = buyPrice_wie * sell_ppc / 100;\n', '      PriceAdjusted(buyPrice_wie, sellPrice_wie);\n', '    }\n', '    _;\n', '  }\n', '\n', '  /* \n', '   * OWNER ONLY; EXTERNAL METHOD\n', '   * setGrowth can accept values within range from 20% to 100% of growth per month (based on 30 days per month assumption).\n', '   * \n', '   *   Formula is:\n', '   *\n', '   *       buyPrice_eth = buyPrice_eth * (1000000 + dailyGrowthMin_ppm) / 1000000;\n', '   *       ^new value     ^current value  ^1.0061 (if dailyGrowth_ppm == 6100)\n', '   *\n', '   *       1.0061^30 = 1.20 (if dailyGrowth_ppm == 6100)\n', '   *       1.023374^30 = 2 (if dailyGrowth_ppm == 23374)\n', '   * \n', '   *  Some other daily rates\n', '   *\n', '   *   Per month -> Value in ppm\n', '   *      1.3    ->  8783\n', '   *      1.4    -> 11278\n', '   *      1.5    -> 13607\n', '   *      1.6    -> 15790\n', '   *      1.7    -> 17844\n', '   *      1.8    -> 19786\n', '   */\n', '  function setGrowth(uint32 _newGrowth_ppm) onlyOwner external returns(bool result) {\n', '    if (_newGrowth_ppm >= dailyGrowthMin_ppm &&\n', '        _newGrowth_ppm <= dailyGrowthMax_ppm\n', '    ) {\n', '      dailyGrowth_ppm = _newGrowth_ppm;\n', '      DailyGrowthUpdate(_newGrowth_ppm);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* \n', '   * SECTION: TRADING\n', '   *\n', '   * This section is responsible purely for trading the tokens. User can buy tokens, user can sell tokens.\n', '   *\n', '   */\n', '\n', '  uint256 public sellPrice_wie;\n', '  uint256 public buyPrice_wie;\n', '\n', '  /*\n', '   * EXTERNAL METHOD\n', '   * User can buy arbitrary amount of tokens. Before amount of tokens will be calculated, the price of tokens \n', '   * has to be adjusted. This happens in adjustPrice modified before function call.\n', '   *\n', '   * Short description of this method\n', '   *\n', '   *   Calculate tokens that user is buying\n', '   *   Assign awards ro refereals\n', '   *   Add some bounty for new users who set referral before first buy\n', '   *   Send tokens that belong to contract or if there is non issue more and send them to user\n', '   *\n', '   * Read -> https://github.com/triangles-things/fish.project/blob/master/terms-of-use.md\n', '   */\n', '  function buy() adjustPrice payable external {\n', '    require(msg.value >= buyPrice_wie);\n', '    var amount = safeDiv(msg.value, buyPrice_wie);\n', '\n', '    assignBountryToReferals(msg.sender, amount);                                // First assign bounty\n', '\n', '    // Buy discount if User is a new user and has set referral\n', '    if ( balances[msg.sender] == 0 && referrals[msg.sender][0] != 0 ) {\n', '      // Check that user has to wait at least two weeks before he get break even on what he will get\n', '      amount = amount * (100 + landingDiscount_ppc) / 100;\n', '    }\n', '\n', '    issueTo(msg.sender, amount);\n', '  }\n', '\n', '  /*\n', '   * EXTERNAL METHOD\n', '   * User can sell tokens back to contract.\n', '   *\n', '   * Short description of this method\n', '   *\n', '   *   Adjust price\n', '   *   Calculate tokens price that user is selling \n', '   *   Make all possible checks\n', '   *   Transfer the money\n', '   */\n', '  function sell(uint256 _amount) adjustPrice external {\n', '    require(_amount > 0 && balances[msg.sender] >= _amount);\n', '    uint moneyWorth = safeMul(_amount, sellPrice_wie);\n', "    require(this.balance > moneyWorth);                                         // We can't sell if we don't have enough money\n", '    \n', '    if (\n', '        balances[this] + _amount > balances[this] &&\n', '        balances[msg.sender] - _amount < balances[msg.sender]\n', '    ) {\n', "      balances[this] = safeAdd(balances[this], _amount);                        // adds the amount to owner's balance\n", "      balances[msg.sender] = safeSub(balances[msg.sender], _amount);            // subtracts the amount from seller's balance\n", "      if (!msg.sender.send(moneyWorth)) {                                       // sends ether to the seller. It's important\n", '        revert();                                                               // to do this last to avoid recursion attacks\n', '      } else {\n', '        Transfer(msg.sender, this, _amount);                                    // executes an event reflecting on the change\n', '      }        \n', '    } else {\n', '      revert();                                                                 // checks if the sender has enough to sell\n', '    }  \n', '  }\n', '\n', '  /*\n', '   * PRIVATE METHOD\n', '   * Issue  new tokens to contract\n', '   */\n', '  function issueTo(address _beneficiary, uint256 _amount_tkns) private {\n', '    if (\n', '        balances[this] >= _amount_tkns\n', '    ) {\n', '      // All tokens are taken from balance\n', '      balances[this] = safeSub(balances[this], _amount_tkns);\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\n', '    } else {\n', '      // Balance will be lowered and new tokens will be issued\n', '      uint diff = safeSub(_amount_tkns, balances[this]);\n', '\n', '      totalSupply = safeAdd(totalSupply, diff);\n', '      balances[this] = 0;\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _amount_tkns);\n', '    }\n', '    \n', '    Transfer(this, _beneficiary, _amount_tkns);\n', '  }\n', '  \n', '  /*\n', '   * SECTION: BOUNTIES\n', '   *\n', '   * This section describes all possible awards.\n', '   */\n', '    \n', '  mapping(address => address[3]) referrals;\n', '  mapping(address => uint256) bounties;\n', '\n', '  uint32 public constant landingDiscount_ppc = 4;                               // Landing discount is 4%\n', '\n', '  /*\n', '   * EXTERNAL METHOD \n', '   * Set your referral first. You will get 4% more tokens on your first buy and trigger a\n', '   * reward of whoever told you about this contract. A win-win scenario.\n', '   */\n', '  function referral(address _referral) external returns(bool) {\n', '    if ( balances[_referral] > 0 &&                                              // Referral participated already\n', '         balances[msg.sender] == 0  &&                                          // Sender is a new user\n', '         referrals[msg.sender][0] == 0                                           // Not returning user. User can not reassign their referrals but they can assign them later on\n', '    ) {\n', '      var referral_referrals = referrals[_referral];\n', '      referrals[msg.sender] = [_referral, referral_referrals[0], referral_referrals[1]];\n', '      return true;\n', '    }\n', '    \n', '    return false;\n', '  }\n', '\n', '  /*\n', '   * PRIVATE METHOD\n', '   * Award bounties to referrals.\n', '   */ \n', '  function assignBountryToReferals(address _referralsOf, uint256 _amount) private {\n', '    var refs = referrals[_referralsOf];\n', '    \n', '    if (refs[0] != 0) {\n', '     issueTo(refs[0], (_amount * 4) / 100);                                     // 4% bounty to direct referral\n', '      if (refs[1] != 0) {\n', '        issueTo(refs[1], (_amount * 2) / 100);                                  // 2% bounty to referral of referral\n', '        if (refs[2] != 0) {\n', '          issueTo(refs[2], (_amount * 1) / 100);                                // 1% bounty to referral of referral of referral\n', '       }\n', '      }\n', '    }\n', '  }\n', '\n', '  /*\n', '   * OWNER ONLY; EXTERNAL METHOD\n', '   * Santa is coming! Who ever made impact to promote the Fish and can prove it will get the bonus\n', '   */\n', '  function assignBounty(address _account, uint256 _amount) onlyOwner external returns(bool) {\n', '    require(_amount > 0); \n', '     \n', '    if (balances[_account] > 0 &&                                               // Account had participated already\n', '        bounties[_account] + _amount <= 1000000                                 // no more than 100 token units per account\n', '    ) {\n', '      issueTo(_account, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '}']
