['pragma solidity ^0.4.1;\n', '\n', 'contract LeanFund {\n', '\n', '  // Poloniex Exchange Rate 2017-08-06: 266 USD / ETH\n', '  uint8 constant public version = 2;\n', '\n', '  address public beneficiary;\n', '\n', '  // These are for Ethereum backers only\n', '  mapping (address => uint) public contributionsETH;\n', '  mapping (address => uint) public payoutsETH;\n', '\n', '  uint public fundingGoal;     // in wei, the amount we&#39;re aiming for\n', '  uint public payoutETH;       // in wei, the amount withdrawn as fee\n', '  uint public amountRaised;    // in wei, the total amount raised\n', '\n', '  address public owner;\n', '  uint    public fee; // the contract fee is 1.5k USD, or ~5.63 ETH\n', '  uint    public feeWithdrawn; // in wei\n', '\n', '  uint public creationTime;\n', '  uint public deadlineBlockNumber;\n', '  bool public open;            // has the funding period started, and contract initialized\n', '\n', '  function LeanFund() {\n', '    owner = msg.sender;\n', '    creationTime = now;\n', '    open = false;\n', '  }\n', '\n', '  // We can only initialize once, but don&#39;t add beforeDeadline guard or check deadline\n', '  function initialize(uint _fundingGoalInWei, address _beneficiary, uint _deadlineBlockNumber) {\n', '    if (open || msg.sender != owner) throw; // we can only initialize once\n', '    if (_deadlineBlockNumber < block.number + 40) throw; // deadlines must be at least ten minutes hence\n', '    beneficiary = _beneficiary;\n', '    payoutETH = 0;\n', '    amountRaised = 0;\n', '    fee = 0;\n', '    feeWithdrawn = 0;\n', '    fundingGoal = _fundingGoalInWei;\n', '\n', '    // If we pass in a deadline in the past, set it to be 10 minutes from now.\n', '    deadlineBlockNumber = _deadlineBlockNumber;\n', '    open = true;\n', '  }\n', '\n', '  modifier beforeDeadline() { if ((block.number < deadlineBlockNumber) && open) _; else throw; }\n', '  modifier afterDeadline() { if ((block.number >= deadlineBlockNumber) && open) _; else throw; }\n', '\n', '  // Normal pay-in function, where msg.sender is the contributor\n', '  function() payable beforeDeadline {\n', '    if (msg.value != 1 ether) { throw; } // only accept payments of 1 ETH exactly\n', '    if (payoutsETH[msg.sender] == 0) { // defend against re-entrancy\n', '        contributionsETH[msg.sender] += msg.value; // allow multiple contributions\n', '        amountRaised += msg.value;\n', '    }\n', '  }\n', '\n', '  function getContribution() constant returns (uint retVal) {\n', '    return contributionsETH[msg.sender];\n', '  }\n', '\n', '  /* As a safeguard, if we were able to pay into account without being a contributor\n', '     allow contract owner to clean it up. */\n', '  function safeKill() afterDeadline {\n', '    if ((msg.sender == owner) && (this.balance > amountRaised)) {\n', '      uint amount = this.balance - amountRaised;\n', '      if (owner.send(amount)) {\n', '        open = false; // make this resettable to make testing easier\n', '      }\n', '    }\n', '  }\n', '\n', '  /* Each backer is responsible for their own safe withdrawal, because it costs gas */\n', '  function safeWithdrawal() afterDeadline {\n', '    uint amount = 0;\n', '    if (amountRaised < fundingGoal && payoutsETH[msg.sender] == 0) {\n', '      // Ethereum backers can only withdraw the full amount they put in, and only once\n', '      amount = contributionsETH[msg.sender];\n', '      payoutsETH[msg.sender] += amount;\n', '      contributionsETH[msg.sender] = 0;\n', '      if (!msg.sender.send(amount)) {\n', '        payoutsETH[msg.sender] = 0;\n', '        contributionsETH[msg.sender] = amount;\n', '      }\n', '    } else if (payoutETH == 0) {\n', '      // anyone can withdraw the crowdfunded amount to the beneficiary after the deadline\n', '      fee = amountRaised * 563 / 10000; // 5.63% fee, only after beneficiary has received payment\n', '      amount = amountRaised - fee;\n', '      payoutETH += amount;\n', '      if (!beneficiary.send(amount)) {\n', '        payoutETH = 0;\n', '      }\n', '    } else if (msg.sender == owner && feeWithdrawn == 0) {\n', '      // only the owner can withdraw the fee and any excess funds (rounding errors)\n', '      feeWithdrawn += fee;\n', '      selfdestruct(owner);\n', '    }\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.1;\n', '\n', 'contract LeanFund {\n', '\n', '  // Poloniex Exchange Rate 2017-08-06: 266 USD / ETH\n', '  uint8 constant public version = 2;\n', '\n', '  address public beneficiary;\n', '\n', '  // These are for Ethereum backers only\n', '  mapping (address => uint) public contributionsETH;\n', '  mapping (address => uint) public payoutsETH;\n', '\n', "  uint public fundingGoal;     // in wei, the amount we're aiming for\n", '  uint public payoutETH;       // in wei, the amount withdrawn as fee\n', '  uint public amountRaised;    // in wei, the total amount raised\n', '\n', '  address public owner;\n', '  uint    public fee; // the contract fee is 1.5k USD, or ~5.63 ETH\n', '  uint    public feeWithdrawn; // in wei\n', '\n', '  uint public creationTime;\n', '  uint public deadlineBlockNumber;\n', '  bool public open;            // has the funding period started, and contract initialized\n', '\n', '  function LeanFund() {\n', '    owner = msg.sender;\n', '    creationTime = now;\n', '    open = false;\n', '  }\n', '\n', "  // We can only initialize once, but don't add beforeDeadline guard or check deadline\n", '  function initialize(uint _fundingGoalInWei, address _beneficiary, uint _deadlineBlockNumber) {\n', '    if (open || msg.sender != owner) throw; // we can only initialize once\n', '    if (_deadlineBlockNumber < block.number + 40) throw; // deadlines must be at least ten minutes hence\n', '    beneficiary = _beneficiary;\n', '    payoutETH = 0;\n', '    amountRaised = 0;\n', '    fee = 0;\n', '    feeWithdrawn = 0;\n', '    fundingGoal = _fundingGoalInWei;\n', '\n', '    // If we pass in a deadline in the past, set it to be 10 minutes from now.\n', '    deadlineBlockNumber = _deadlineBlockNumber;\n', '    open = true;\n', '  }\n', '\n', '  modifier beforeDeadline() { if ((block.number < deadlineBlockNumber) && open) _; else throw; }\n', '  modifier afterDeadline() { if ((block.number >= deadlineBlockNumber) && open) _; else throw; }\n', '\n', '  // Normal pay-in function, where msg.sender is the contributor\n', '  function() payable beforeDeadline {\n', '    if (msg.value != 1 ether) { throw; } // only accept payments of 1 ETH exactly\n', '    if (payoutsETH[msg.sender] == 0) { // defend against re-entrancy\n', '        contributionsETH[msg.sender] += msg.value; // allow multiple contributions\n', '        amountRaised += msg.value;\n', '    }\n', '  }\n', '\n', '  function getContribution() constant returns (uint retVal) {\n', '    return contributionsETH[msg.sender];\n', '  }\n', '\n', '  /* As a safeguard, if we were able to pay into account without being a contributor\n', '     allow contract owner to clean it up. */\n', '  function safeKill() afterDeadline {\n', '    if ((msg.sender == owner) && (this.balance > amountRaised)) {\n', '      uint amount = this.balance - amountRaised;\n', '      if (owner.send(amount)) {\n', '        open = false; // make this resettable to make testing easier\n', '      }\n', '    }\n', '  }\n', '\n', '  /* Each backer is responsible for their own safe withdrawal, because it costs gas */\n', '  function safeWithdrawal() afterDeadline {\n', '    uint amount = 0;\n', '    if (amountRaised < fundingGoal && payoutsETH[msg.sender] == 0) {\n', '      // Ethereum backers can only withdraw the full amount they put in, and only once\n', '      amount = contributionsETH[msg.sender];\n', '      payoutsETH[msg.sender] += amount;\n', '      contributionsETH[msg.sender] = 0;\n', '      if (!msg.sender.send(amount)) {\n', '        payoutsETH[msg.sender] = 0;\n', '        contributionsETH[msg.sender] = amount;\n', '      }\n', '    } else if (payoutETH == 0) {\n', '      // anyone can withdraw the crowdfunded amount to the beneficiary after the deadline\n', '      fee = amountRaised * 563 / 10000; // 5.63% fee, only after beneficiary has received payment\n', '      amount = amountRaised - fee;\n', '      payoutETH += amount;\n', '      if (!beneficiary.send(amount)) {\n', '        payoutETH = 0;\n', '      }\n', '    } else if (msg.sender == owner && feeWithdrawn == 0) {\n', '      // only the owner can withdraw the fee and any excess funds (rounding errors)\n', '      feeWithdrawn += fee;\n', '      selfdestruct(owner);\n', '    }\n', '  }\n', '\n', '}']
