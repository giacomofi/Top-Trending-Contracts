['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Helps contracts guard agains rentrancy attacks.\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="7200171f111d3240">[email&#160;protected]</span>π.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// Minimal Bitcoineum interface for proxy mining\n', 'contract BitcoineumInterface {\n', '   function mine() payable;\n', '   function claim(uint256 _blockNumber, address forCreditTo);\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool);\n', '   function checkWinning(uint256 _blockNum) constant public returns (bool);\n', '   function transfer(address _to, uint256 _value) returns (bool);\n', '   function balanceOf(address _owner) constant returns (uint256 balance);\n', '   function currentDifficultyWei() constant public returns (uint256);\n', '   }\n', '\n', '// Sharkpool is a rolling window Bitcoineum miner\n', '// Smart contract based virtual mining\n', '// http://www.bitcoineum.com/\n', '\n', 'contract SharkPool is Ownable, ReentrancyGuard {\n', '\n', '    string constant public pool_name = "SharkPool 200";\n', '\n', '    // Percentage of BTE pool takes for operations\n', '    uint256 public pool_percentage = 5;\n', '\n', '    // Limiting users because of gas limits\n', '    // I would not increase this value it could make the pool unstable\n', '    uint256 constant public max_users = 100;\n', '\n', '    // Track total users to switch to degraded case when contract is full\n', '    uint256 public total_users = 0;\n', '\n', '    uint256 public constant divisible_units = 10000000;\n', '\n', '    // How long will a payment event mine blocks for you\n', '    uint256 public contract_period = 100;\n', '    uint256 public mined_blocks = 1;\n', '    uint256 public claimed_blocks = 1;\n', '    uint256 public blockCreationRate = 0;\n', '\n', '    BitcoineumInterface base_contract;\n', '\n', '    struct user {\n', '        uint256 start_block;\n', '        uint256 end_block;\n', '        uint256 proportional_contribution;\n', '    }\n', '\n', '    mapping (address => user) public users;\n', '    mapping (uint256 => uint256) public attempts;\n', '    mapping(address => uint256) balances;\n', '    uint8[] slots;\n', '    address[256] public active_users; // Should equal max_users\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '      return balances[_owner];\n', '    }\n', '\n', '    function set_pool_percentage(uint8 _percentage) external nonReentrant onlyOwner {\n', '       // Just in case owner is compromised\n', '       require(_percentage < 11);\n', '       pool_percentage = _percentage;\n', '    }\n', '\n', '\n', '    function find_contribution(address _who) constant external returns (uint256, uint256, uint256, uint256, uint256) {\n', '      if (users[_who].start_block > 0) {\n', '         user memory u = users[_who];\n', '         uint256 remaining_period= 0;\n', '         if (u.end_block > mined_blocks) {\n', '            remaining_period = u.end_block - mined_blocks;\n', '            } else {\n', '            remaining_period = 0;\n', '            }\n', '         return (u.start_block, u.end_block,\n', '                 u.proportional_contribution,\n', '                 u.proportional_contribution * contract_period,\n', '                 u.proportional_contribution * remaining_period);\n', '      }\n', '      return (0,0,0,0,0);\n', '    }\n', '\n', '    function allocate_slot(address _who) internal {\n', '       if(total_users < max_users) { \n', '            // Just push into active_users\n', '            active_users[total_users] = _who;\n', '            total_users += 1;\n', '          } else {\n', '            // The maximum users have been reached, can we allocate a free space?\n', '            if (slots.length == 0) {\n', '                // There isn&#39;t any room left\n', '                revert();\n', '            } else {\n', '               uint8 location = slots[slots.length-1];\n', '               active_users[location] = _who;\n', '               delete slots[slots.length-1];\n', '            }\n', '          }\n', '    }\n', '\n', '     function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\n', '        // blockCreationRate is > 0\n', '        return _externalBlockNum / blockCreationRate;\n', '     }\n', '\n', '     function available_slots() public constant returns (uint256) {\n', '        if (total_users < max_users) {\n', '            return max_users - total_users;\n', '        } else {\n', '          return slots.length;\n', '        }\n', '     }\n', '  \n', '   event LogEvent(\n', '       uint256 _info\n', '   );\n', '\n', '    function get_bitcoineum_contract_address() public constant returns (address) {\n', '       return 0x73dD069c299A5d691E9836243BcaeC9c8C1D8734; // Production\n', '    \n', '       // return 0x7e7a299da34a350d04d204cd80ab51d068ad530f; // Testing\n', '    }\n', '\n', '    // iterate over all account holders\n', '    // and balance transfer proportional bte\n', '    // balance should be 0 aftwards in a perfect world\n', '    function distribute_reward(uint256 _totalAttempt, uint256 _balance) internal {\n', '      uint256 remaining_balance = _balance;\n', '      for (uint8 i = 0; i < total_users; i++) {\n', '          address user_address = active_users[i];\n', '          if (user_address > 0 && remaining_balance != 0) {\n', '              uint256 proportion = users[user_address].proportional_contribution;\n', '              uint256 divided_portion = (proportion * divisible_units) / _totalAttempt;\n', '              uint256 payout = (_balance * divided_portion) / divisible_units;\n', '              if (payout > remaining_balance) {\n', '                 payout = remaining_balance;\n', '              }\n', '              balances[user_address] = balances[user_address] + payout;\n', '              remaining_balance = remaining_balance - payout;\n', '          }\n', '      }\n', '    }\n', '\n', '    function SharkPool() {\n', '      blockCreationRate = 50; // match bte\n', '      base_contract = BitcoineumInterface(get_bitcoineum_contract_address());\n', '    }\n', '\n', '    function current_external_block() public constant returns (uint256) {\n', '        return block.number;\n', '    }\n', '\n', '\n', '    function calculate_minimum_contribution() public constant returns (uint256)  {\n', '       return base_contract.currentDifficultyWei() / 10000000 * contract_period;\n', '    }\n', '\n', '    // A default ether tx without gas specified will fail.\n', '    function () payable {\n', '         require(msg.value >= calculate_minimum_contribution());\n', '\n', '         // Did the user already contribute\n', '         user storage current_user = users[msg.sender];\n', '\n', '         // Does user exist already\n', '         if (current_user.start_block > 0) {\n', '            if (current_user.end_block > mined_blocks) {\n', '                uint256 periods_left = current_user.end_block - mined_blocks;\n', '                uint256 amount_remaining = current_user.proportional_contribution * periods_left;\n', '                amount_remaining = amount_remaining + msg.value;\n', '                amount_remaining = amount_remaining / contract_period;\n', '                current_user.proportional_contribution = amount_remaining;\n', '            } else {\n', '               current_user.proportional_contribution = msg.value / contract_period;\n', '            }\n', '\n', '          // If the user exists and has a balance let&#39;s transfer it to them\n', '          do_redemption();\n', '\n', '          } else {\n', '               current_user.proportional_contribution = msg.value / contract_period;\n', '               allocate_slot(msg.sender);\n', '          }\n', '          current_user.start_block = mined_blocks;\n', '          current_user.end_block = mined_blocks + contract_period;\n', '         }\n', '\n', '    \n', '    // Proxy mining to token\n', '   function mine() external nonReentrant\n', '   {\n', '     // Did someone already try to mine this block?\n', '     uint256 _blockNum = external_to_internal_block_number(current_external_block());\n', '     require(!base_contract.checkMiningAttempt(_blockNum, this));\n', '\n', '     // Alright nobody mined lets iterate over our active_users\n', '\n', '     uint256 total_attempt = 0;\n', '     uint8 total_ejected = 0; \n', '\n', '     for (uint8 i=0; i < total_users; i++) {\n', '         address user_address = active_users[i];\n', '         if (user_address > 0) {\n', '             // This user exists\n', '             user memory u = users[user_address];\n', '             if (u.end_block <= mined_blocks) {\n', '                // This user needs to be ejected, no more attempts left\n', '                // but we limit to 20 to prevent gas issues on slot insert\n', '                if (total_ejected < 10) {\n', '                    delete active_users[i];\n', '                    slots.push(i);\n', '                    delete users[active_users[i]];\n', '                    total_ejected = total_ejected + 1;\n', '                }\n', '             } else {\n', '               // This user is still active\n', '               total_attempt = total_attempt + u.proportional_contribution;\n', '             }\n', '         }\n', '     }\n', '     if (total_attempt > 0) {\n', '        // Now we have a total contribution amount\n', '        attempts[_blockNum] = total_attempt;\n', '        base_contract.mine.value(total_attempt)();\n', '        mined_blocks = mined_blocks + 1;\n', '     }\n', '   }\n', '\n', '   function claim(uint256 _blockNumber, address forCreditTo)\n', '                  nonReentrant\n', '                  external returns (bool) {\n', '                  \n', '                  // Did we win the block in question\n', '                  require(base_contract.checkWinning(_blockNumber));\n', '\n', '                  uint256 initial_balance = base_contract.balanceOf(this);\n', '\n', '                  // We won let&#39;s get our reward\n', '                  base_contract.claim(_blockNumber, this);\n', '\n', '                  uint256 balance = base_contract.balanceOf(this);\n', '                  uint256 total_attempt = attempts[_blockNumber];\n', '\n', '                  distribute_reward(total_attempt, balance - initial_balance);\n', '                  claimed_blocks = claimed_blocks + 1;\n', '                  }\n', '\n', '   function do_redemption() internal {\n', '     uint256 balance = balances[msg.sender];\n', '     if (balance > 0) {\n', '        uint256 owner_cut = (balance / 100) * pool_percentage;\n', '        uint256 remainder = balance - owner_cut;\n', '        if (owner_cut > 0) {\n', '            base_contract.transfer(owner, owner_cut);\n', '        }\n', '        base_contract.transfer(msg.sender, remainder);\n', '        balances[msg.sender] = 0;\n', '    }\n', '   }\n', '\n', '   function redeem() external nonReentrant\n', '     {\n', '        do_redemption();\n', '     }\n', '\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\n', '      return base_contract.checkMiningAttempt(_blockNum, _sender);\n', '   }\n', '   \n', '   function checkWinning(uint256 _blockNum) constant public returns (bool) {\n', '     return base_contract.checkWinning(_blockNum);\n', '   }\n', '\n', '}']
['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Helps contracts guard agains rentrancy attacks.\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// Minimal Bitcoineum interface for proxy mining\n', 'contract BitcoineumInterface {\n', '   function mine() payable;\n', '   function claim(uint256 _blockNumber, address forCreditTo);\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool);\n', '   function checkWinning(uint256 _blockNum) constant public returns (bool);\n', '   function transfer(address _to, uint256 _value) returns (bool);\n', '   function balanceOf(address _owner) constant returns (uint256 balance);\n', '   function currentDifficultyWei() constant public returns (uint256);\n', '   }\n', '\n', '// Sharkpool is a rolling window Bitcoineum miner\n', '// Smart contract based virtual mining\n', '// http://www.bitcoineum.com/\n', '\n', 'contract SharkPool is Ownable, ReentrancyGuard {\n', '\n', '    string constant public pool_name = "SharkPool 200";\n', '\n', '    // Percentage of BTE pool takes for operations\n', '    uint256 public pool_percentage = 5;\n', '\n', '    // Limiting users because of gas limits\n', '    // I would not increase this value it could make the pool unstable\n', '    uint256 constant public max_users = 100;\n', '\n', '    // Track total users to switch to degraded case when contract is full\n', '    uint256 public total_users = 0;\n', '\n', '    uint256 public constant divisible_units = 10000000;\n', '\n', '    // How long will a payment event mine blocks for you\n', '    uint256 public contract_period = 100;\n', '    uint256 public mined_blocks = 1;\n', '    uint256 public claimed_blocks = 1;\n', '    uint256 public blockCreationRate = 0;\n', '\n', '    BitcoineumInterface base_contract;\n', '\n', '    struct user {\n', '        uint256 start_block;\n', '        uint256 end_block;\n', '        uint256 proportional_contribution;\n', '    }\n', '\n', '    mapping (address => user) public users;\n', '    mapping (uint256 => uint256) public attempts;\n', '    mapping(address => uint256) balances;\n', '    uint8[] slots;\n', '    address[256] public active_users; // Should equal max_users\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '      return balances[_owner];\n', '    }\n', '\n', '    function set_pool_percentage(uint8 _percentage) external nonReentrant onlyOwner {\n', '       // Just in case owner is compromised\n', '       require(_percentage < 11);\n', '       pool_percentage = _percentage;\n', '    }\n', '\n', '\n', '    function find_contribution(address _who) constant external returns (uint256, uint256, uint256, uint256, uint256) {\n', '      if (users[_who].start_block > 0) {\n', '         user memory u = users[_who];\n', '         uint256 remaining_period= 0;\n', '         if (u.end_block > mined_blocks) {\n', '            remaining_period = u.end_block - mined_blocks;\n', '            } else {\n', '            remaining_period = 0;\n', '            }\n', '         return (u.start_block, u.end_block,\n', '                 u.proportional_contribution,\n', '                 u.proportional_contribution * contract_period,\n', '                 u.proportional_contribution * remaining_period);\n', '      }\n', '      return (0,0,0,0,0);\n', '    }\n', '\n', '    function allocate_slot(address _who) internal {\n', '       if(total_users < max_users) { \n', '            // Just push into active_users\n', '            active_users[total_users] = _who;\n', '            total_users += 1;\n', '          } else {\n', '            // The maximum users have been reached, can we allocate a free space?\n', '            if (slots.length == 0) {\n', "                // There isn't any room left\n", '                revert();\n', '            } else {\n', '               uint8 location = slots[slots.length-1];\n', '               active_users[location] = _who;\n', '               delete slots[slots.length-1];\n', '            }\n', '          }\n', '    }\n', '\n', '     function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\n', '        // blockCreationRate is > 0\n', '        return _externalBlockNum / blockCreationRate;\n', '     }\n', '\n', '     function available_slots() public constant returns (uint256) {\n', '        if (total_users < max_users) {\n', '            return max_users - total_users;\n', '        } else {\n', '          return slots.length;\n', '        }\n', '     }\n', '  \n', '   event LogEvent(\n', '       uint256 _info\n', '   );\n', '\n', '    function get_bitcoineum_contract_address() public constant returns (address) {\n', '       return 0x73dD069c299A5d691E9836243BcaeC9c8C1D8734; // Production\n', '    \n', '       // return 0x7e7a299da34a350d04d204cd80ab51d068ad530f; // Testing\n', '    }\n', '\n', '    // iterate over all account holders\n', '    // and balance transfer proportional bte\n', '    // balance should be 0 aftwards in a perfect world\n', '    function distribute_reward(uint256 _totalAttempt, uint256 _balance) internal {\n', '      uint256 remaining_balance = _balance;\n', '      for (uint8 i = 0; i < total_users; i++) {\n', '          address user_address = active_users[i];\n', '          if (user_address > 0 && remaining_balance != 0) {\n', '              uint256 proportion = users[user_address].proportional_contribution;\n', '              uint256 divided_portion = (proportion * divisible_units) / _totalAttempt;\n', '              uint256 payout = (_balance * divided_portion) / divisible_units;\n', '              if (payout > remaining_balance) {\n', '                 payout = remaining_balance;\n', '              }\n', '              balances[user_address] = balances[user_address] + payout;\n', '              remaining_balance = remaining_balance - payout;\n', '          }\n', '      }\n', '    }\n', '\n', '    function SharkPool() {\n', '      blockCreationRate = 50; // match bte\n', '      base_contract = BitcoineumInterface(get_bitcoineum_contract_address());\n', '    }\n', '\n', '    function current_external_block() public constant returns (uint256) {\n', '        return block.number;\n', '    }\n', '\n', '\n', '    function calculate_minimum_contribution() public constant returns (uint256)  {\n', '       return base_contract.currentDifficultyWei() / 10000000 * contract_period;\n', '    }\n', '\n', '    // A default ether tx without gas specified will fail.\n', '    function () payable {\n', '         require(msg.value >= calculate_minimum_contribution());\n', '\n', '         // Did the user already contribute\n', '         user storage current_user = users[msg.sender];\n', '\n', '         // Does user exist already\n', '         if (current_user.start_block > 0) {\n', '            if (current_user.end_block > mined_blocks) {\n', '                uint256 periods_left = current_user.end_block - mined_blocks;\n', '                uint256 amount_remaining = current_user.proportional_contribution * periods_left;\n', '                amount_remaining = amount_remaining + msg.value;\n', '                amount_remaining = amount_remaining / contract_period;\n', '                current_user.proportional_contribution = amount_remaining;\n', '            } else {\n', '               current_user.proportional_contribution = msg.value / contract_period;\n', '            }\n', '\n', "          // If the user exists and has a balance let's transfer it to them\n", '          do_redemption();\n', '\n', '          } else {\n', '               current_user.proportional_contribution = msg.value / contract_period;\n', '               allocate_slot(msg.sender);\n', '          }\n', '          current_user.start_block = mined_blocks;\n', '          current_user.end_block = mined_blocks + contract_period;\n', '         }\n', '\n', '    \n', '    // Proxy mining to token\n', '   function mine() external nonReentrant\n', '   {\n', '     // Did someone already try to mine this block?\n', '     uint256 _blockNum = external_to_internal_block_number(current_external_block());\n', '     require(!base_contract.checkMiningAttempt(_blockNum, this));\n', '\n', '     // Alright nobody mined lets iterate over our active_users\n', '\n', '     uint256 total_attempt = 0;\n', '     uint8 total_ejected = 0; \n', '\n', '     for (uint8 i=0; i < total_users; i++) {\n', '         address user_address = active_users[i];\n', '         if (user_address > 0) {\n', '             // This user exists\n', '             user memory u = users[user_address];\n', '             if (u.end_block <= mined_blocks) {\n', '                // This user needs to be ejected, no more attempts left\n', '                // but we limit to 20 to prevent gas issues on slot insert\n', '                if (total_ejected < 10) {\n', '                    delete active_users[i];\n', '                    slots.push(i);\n', '                    delete users[active_users[i]];\n', '                    total_ejected = total_ejected + 1;\n', '                }\n', '             } else {\n', '               // This user is still active\n', '               total_attempt = total_attempt + u.proportional_contribution;\n', '             }\n', '         }\n', '     }\n', '     if (total_attempt > 0) {\n', '        // Now we have a total contribution amount\n', '        attempts[_blockNum] = total_attempt;\n', '        base_contract.mine.value(total_attempt)();\n', '        mined_blocks = mined_blocks + 1;\n', '     }\n', '   }\n', '\n', '   function claim(uint256 _blockNumber, address forCreditTo)\n', '                  nonReentrant\n', '                  external returns (bool) {\n', '                  \n', '                  // Did we win the block in question\n', '                  require(base_contract.checkWinning(_blockNumber));\n', '\n', '                  uint256 initial_balance = base_contract.balanceOf(this);\n', '\n', "                  // We won let's get our reward\n", '                  base_contract.claim(_blockNumber, this);\n', '\n', '                  uint256 balance = base_contract.balanceOf(this);\n', '                  uint256 total_attempt = attempts[_blockNumber];\n', '\n', '                  distribute_reward(total_attempt, balance - initial_balance);\n', '                  claimed_blocks = claimed_blocks + 1;\n', '                  }\n', '\n', '   function do_redemption() internal {\n', '     uint256 balance = balances[msg.sender];\n', '     if (balance > 0) {\n', '        uint256 owner_cut = (balance / 100) * pool_percentage;\n', '        uint256 remainder = balance - owner_cut;\n', '        if (owner_cut > 0) {\n', '            base_contract.transfer(owner, owner_cut);\n', '        }\n', '        base_contract.transfer(msg.sender, remainder);\n', '        balances[msg.sender] = 0;\n', '    }\n', '   }\n', '\n', '   function redeem() external nonReentrant\n', '     {\n', '        do_redemption();\n', '     }\n', '\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\n', '      return base_contract.checkMiningAttempt(_blockNum, _sender);\n', '   }\n', '   \n', '   function checkWinning(uint256 _blockNum) constant public returns (bool) {\n', '     return base_contract.checkWinning(_blockNum);\n', '   }\n', '\n', '}']
