['pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' *\n', ' *  STEAK TOKEN (BOV)\n', ' *\n', ' *  Make bank by eating flank. See https://steaktoken.com.\n', ' *\n', ' */\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', ' library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' contract Ownable {\n', '  address public owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract SteakToken is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public name = "Steak Token";\n', '  string public symbol = "BOV";\n', '  uint public decimals = 18;\n', '  uint public totalSupply;      // Total BOV in circulation.\n', '\n', '  mapping(address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed ownerAddress, address indexed spenderAddress, uint256 value);\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MineFinished();\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    if(msg.data.length < (2 * 32) + 4) { revert(); } // protect against short address attack\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '   function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '   function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '    /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will recieve the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '   function mint(address _to, uint256 _amount) internal returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AuctionCrowdsale \n', ' * @dev The owner starts and ends the crowdsale manually.\n', ' * Players can make token purchases during the crowdsale\n', ' * and their tokens can be claimed after the sale ends.\n', ' * Players receive an amount proportional to their investment.\n', ' */\n', ' contract AuctionCrowdsale is SteakToken {\n', '  using SafeMath for uint;\n', '\n', '  uint public initialSale;                  // Amount of BOV tokens being sold during crowdsale.\n', '\n', '  bool public saleStarted;\n', '  bool public saleEnded;\n', '\n', '  uint public absoluteEndBlock;             // Anybody can end the crowdsale and trigger token distribution if beyond this block number.\n', '\n', '  uint256 public weiRaised;                 // Total amount raised in crowdsale.\n', '\n', '  address[] public investors;               // Investor addresses\n', '  uint public numberOfInvestors;\n', '  mapping(address => uint256) public investments; // How much each address has invested.\n', '\n', '  mapping(address => bool) public claimed;      // Keep track of whether each investor has been awarded their BOV tokens.\n', '\n', '\n', '  bool public bovBatchDistributed;              // TODO: this can be removed with manual crowdsale end-time\n', '\n', '  uint public initialPrizeWeiValue;             // The first steaks mined will be awarded BOV equivalent to this ETH value. Set in Steak() initializer.\n', '  uint public initialPrizeBov;                  // Initial mining prize in BOV units. Set in endCrowdsale() or endCrowdsalePublic().\n', '\n', '  uint public dailyHashExpires;        // When the dailyHash expires. Will be roughly around 3am EST.\n', '\n', '\n', '\n', '\n', '\n', '  /**\n', '   * event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   */ \n', '   event TokenInvestment(address indexed purchaser, address indexed beneficiary, uint256 value);\n', '\n', '\n', '\n', '   // Sending ETH to this contract&#39;s address registers the investment.\n', '   function () payable {\n', '    invest(msg.sender);\n', '  }\n', '\n', '\n', '  // Participate in the crowdsale.\n', '  // Records how much each address has invested.\n', '  function invest(address beneficiary) payable {\n', '    require(beneficiary != 0x0);\n', '    require(validInvestment());\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    uint investedAmount = investments[beneficiary];\n', '\n', '    forwardFunds();\n', '\n', '    if (investedAmount > 0) { // If they&#39;ve already invested, increase their balance.\n', '      investments[beneficiary] = investedAmount + weiAmount; // investedAmount.add(weiAmount);\n', '    } else { // If new investor\n', '      investors.push(beneficiary);\n', '      numberOfInvestors += 1;\n', '      investments[beneficiary] = weiAmount;\n', '    }\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    TokenInvestment(msg.sender, beneficiary, weiAmount);\n', '  }\n', '\n', '\n', '\n', '  // @return true if the transaction can invest\n', '  function validInvestment() internal constant returns (bool) {\n', '    bool withinPeriod = saleStarted && !saleEnded;\n', '    bool nonZeroPurchase = (msg.value > 0);\n', '    return withinPeriod && nonZeroPurchase;\n', '  }\n', '\n', '\n', '\n', '\n', '  // Distribute 10M tokens proportionally amongst all investors. Can be called by anyone after the crowdsale ends.\n', '  // ClaimTokens() can be run by individuals to claim their tokens.\n', '  function distributeAllTokens() public {\n', '\n', '    require(!bovBatchDistributed);\n', '    require(crowdsaleHasEnded());\n', '\n', '    // Allocate BOV proportionally to each investor.\n', '\n', '    for (uint i=0; i < numberOfInvestors; i++) {\n', '      address investorAddr = investors[i];\n', '      if (!claimed[investorAddr]) { // If the investor hasn&#39;t already claimed their BOV.\n', '        claimed[investorAddr] = true;\n', '        uint amountInvested = investments[investorAddr];\n', '        uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\n', '        mint(investorAddr, bovEarned);\n', '      }\n', '    }\n', '\n', '    bovBatchDistributed = true;\n', '  }\n', '\n', '\n', '  // Claim your BOV; allocates BOV proportionally to this investor.\n', '  // Can be called by investors to claim their BOV after the crowdsale ends.\n', '  // distributeAllTokens() is a batch alternative to this.\n', '  function claimTokens(address origAddress) public {\n', '    require(crowdsaleHasEnded());\n', '    require(claimed[origAddress] == false);\n', '    uint amountInvested = investments[origAddress];\n', '    uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\n', '    claimed[origAddress] = true;\n', '    mint(origAddress, bovEarned);\n', '  }\n', '\n', '\n', '  // Investors: see how many BOV you are currently entitled to (before the end of the crowdsale and distribution of tokens).\n', '  function getCurrentShare(address addr) public constant returns (uint) {\n', '    require(!bovBatchDistributed && !claimed[addr]); // Tokens cannot have already been distributed.\n', '    uint amountInvested = investments[addr];\n', '    uint currentBovShare = amountInvested.mul(initialSale).div(weiRaised);\n', '    return currentBovShare;\n', '  }\n', '\n', '\n', '\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    owner.transfer(msg.value);\n', '  }\n', '\n', '\n', '  // The owner manually starts the crowdsale at a pre-determined time.\n', '  function startCrowdsale() onlyOwner {\n', '    require(!saleStarted && !saleEnded);\n', '    saleStarted = true;\n', '  }\n', '\n', '  // endCrowdsale() and endCrowdsalePublic() moved to Steak contract\n', '    // Normally, the owner will end the crowdsale at the pre-determined time.\n', '  function endCrowdsale() onlyOwner {\n', '    require(saleStarted && !saleEnded);\n', '    dailyHashExpires = now; // Will end crowdsale at 3am EST, so expiration time will roughly be around 3am.\n', '    saleEnded = true;\n', '    setInitialPrize();\n', '  }\n', '\n', '  // Normally, Madame BOV ends the crowdsale at the pre-determined time, but if Madame BOV fails to do so, anybody can trigger endCrowdsalePublic() after absoluteEndBlock.\n', '  function endCrowdsalePublic() public {\n', '    require(block.number > absoluteEndBlock);\n', '    require(saleStarted && !saleEnded);\n', '    dailyHashExpires = now;\n', '    saleEnded = true;\n', '    setInitialPrize();\n', '  }\n', '\n', '\n', '  // Calculate initial mining prize (0.0357 ether&#39;s worth of BOV). This is called in endCrowdsale().\n', '  function setInitialPrize() internal returns (uint) {\n', '    require(crowdsaleHasEnded());\n', '    require(initialPrizeBov == 0); // Can only be set once\n', '    uint tokenUnitsPerWei = initialSale.div(weiRaised);\n', '    initialPrizeBov = tokenUnitsPerWei.mul(initialPrizeWeiValue);\n', '    return initialPrizeBov;\n', '  }\n', '\n', '\n', '  // @return true if crowdsale event has ended\n', '  function crowdsaleHasEnded() public constant returns (bool) {\n', '    return saleStarted && saleEnded;\n', '  }\n', '\n', '  function getInvestors() public returns (address[]) {\n', '    return investors;\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Steak is AuctionCrowdsale {\n', '  // using SafeMath for uint;\n', '\n', '  bytes32 public dailyHash;            // The last five digits of the dailyHash must be included in steak pictures.\n', '\n', '\n', '  Submission[] public submissions;          // All steak pics\n', '  uint public numSubmissions;\n', '\n', '  Submission[] public approvedSubmissions;\n', '  mapping (address => uint) public memberId;    // Get member ID from address.\n', '  Member[] public members;                      // Index is memberId\n', '\n', '  uint public halvingInterval;                  // BOV award is halved every x steaks\n', '  uint public numberOfHalvings;                 // How many times the BOV reward per steak is halved before it returns 0. \n', '\n', '\n', '\n', '  uint public lastMiningBlock;                  // No mining after this block. Set in initializer.\n', '\n', '  bool public ownerCredited;    // Has the owner been credited BOV yet?\n', '\n', '  event PicAdded(address msgSender, uint submissionID, address recipient, bytes32 propUrl); // Need msgSender so we can watch for this event.\n', '  event Judged(uint submissionID, bool position, address voter, bytes32 justification);\n', '  event MembershipChanged(address member, bool isMember);\n', '\n', '  struct Submission {\n', '    address recipient;    // Would-be BOV recipient\n', '    bytes32 url;           // IMGUR url; 32-char max\n', '    bool judged;          // Has an admin voted?\n', '    bool submissionApproved;// Has it been approved?\n', '    address judgedBy;     // Admin who judged this steak\n', '    bytes32 adminComments; // Admin should leave feedback on non-approved steaks. 32-char max.\n', '    bytes32 todaysHash;   // The hash in the image should match this hash.\n', '    uint awarded;         // Amount awarded\n', '  }\n', '\n', '  // Members can vote on steak\n', '  struct Member {\n', '    address member;\n', '    bytes32 name;\n', '    uint memberSince;\n', '  }\n', '\n', '\n', '  modifier onlyMembers {\n', '    require(memberId[msg.sender] != 0); // member id must be in the mapping\n', '    _;\n', '  }\n', '\n', '\n', '  function Steak() {\n', '\n', '    owner = msg.sender;\n', '    initialSale = 10000000 * 1000000000000000000; // 10M BOV units are awarded in the crowdsale.\n', '\n', '    // Normally, the owner both starts and ends the crowdsale.\n', '    // To guarantee that the crowdsale ends at some maximum point (at that tokens are distributed),\n', '    // we calculate the absoluteEndBlock, the block beyond which anybody can end the crowdsale and distribute tokens.\n', '    uint blocksPerHour = 212;\n', '    uint maxCrowdsaleLifeFromLaunchDays = 40; // After about this many days from launch, anybody can end the crowdsale and distribute / claim their tokens. \n', '    absoluteEndBlock = block.number + (blocksPerHour * 24 * maxCrowdsaleLifeFromLaunchDays);\n', '\n', '    uint miningDays = 365; // Approximately how many days BOV can be mined from the launch of the contract.\n', '    lastMiningBlock = block.number + (blocksPerHour * 24 * miningDays);\n', '\n', '    dailyHashExpires = now;\n', '\n', '    halvingInterval = 500;    // How many steaks get awarded the given getSteakPrize() amount before the reward is halved.\n', '    numberOfHalvings = 8;      // How many times the steak prize gets halved before no more prize is awarded.\n', '\n', '    // initialPrizeWeiValue = 50 finney; // 0.05 ether == 50 finney == 2.80 USD * 5 == 14 USD\n', '    initialPrizeWeiValue = (357 finney / 10); // 0.0357 ether == 35.7 finney == 2.80 USD * 3.57 == 9.996 USD\n', '\n', '    // To finish initializing, owner calls initMembers() and creditOwner() after launch.\n', '  }\n', '\n', '\n', '  // Add Madame BOV as a beef judge.\n', '  function initMembers() onlyOwner {\n', '    addMember(0, &#39;&#39;);                        // Must add an empty first member\n', '    addMember(msg.sender, &#39;Madame BOV&#39;);\n', '  }\n', '\n', '\n', '\n', '  // Send 1M BOV to Madame BOV. \n', '  function creditOwner() onlyOwner {\n', '    require(!ownerCredited);\n', '    uint ownerAward = initialSale / 10;  // 10% of the crowdsale amount.\n', '    ownerCredited = true;   // Can only be run once.\n', '    mint(owner, ownerAward);\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '\n', '  /* Add beef judge */\n', '  function addMember(address targetMember, bytes32 memberName) onlyOwner {\n', '    uint id;\n', '    if (memberId[targetMember] == 0) {\n', '      memberId[targetMember] = members.length;\n', '      id = members.length++;\n', '      members[id] = Member({member: targetMember, memberSince: now, name: memberName});\n', '    } else {\n', '      id = memberId[targetMember];\n', '      // Member m = members[id];\n', '    }\n', '    MembershipChanged(targetMember, true);\n', '  }\n', '\n', '  function removeMember(address targetMember) onlyOwner {\n', '    if (memberId[targetMember] == 0) revert();\n', '\n', '    memberId[targetMember] = 0;\n', '\n', '    for (uint i = memberId[targetMember]; i<members.length-1; i++){\n', '      members[i] = members[i+1];\n', '    }\n', '    delete members[members.length-1];\n', '    members.length--;\n', '  }\n', '\n', '\n', '\n', '  /* Submit a steak picture. (After crowdsale has ended.)\n', '  *  WARNING: Before taking the picture, call getDailyHash() and  minutesToPost()\n', '  *  so you can be sure that you have the correct dailyHash and that it won&#39;t expire before you post it.\n', '  */\n', '  function submitSteak(address addressToAward, bytes32 steakPicUrl)  returns (uint submissionID) {\n', '    require(crowdsaleHasEnded());\n', '    require(block.number <= lastMiningBlock); // Cannot submit beyond this block.\n', '    submissionID = submissions.length++; // Increase length of array\n', '    Submission storage s = submissions[submissionID];\n', '    s.recipient = addressToAward;\n', '    s.url = steakPicUrl;\n', '    s.judged = false;\n', '    s.submissionApproved = false;\n', '    s.todaysHash = getDailyHash(); // Each submission saves the hash code the user should take picture of in steak picture.\n', '\n', '    PicAdded(msg.sender, submissionID, addressToAward, steakPicUrl);\n', '    numSubmissions = submissionID+1;\n', '\n', '    return submissionID;\n', '  }\n', '\n', '  // Retrieving any Submission must be done via this function, not `submissions()`\n', '  function getSubmission(uint submissionID) public constant returns (address recipient, bytes32 url, bool judged, bool submissionApproved, address judgedBy, bytes32 adminComments, bytes32 todaysHash, uint awarded) {\n', '    Submission storage s = submissions[submissionID];\n', '    recipient = s.recipient;\n', '    url = s.url;                 // IMGUR url\n', '    judged = s.judged;           // Has an admin voted?\n', '    submissionApproved = s.submissionApproved;  // Has it been approved?\n', '    judgedBy = s.judgedBy;           // Admin who judged this steak\n', '    adminComments = s.adminComments; // Admin should leave feedback on non-approved steaks\n', '    todaysHash = s.todaysHash;       // The hash in the image should match this hash.\n', '    awarded = s.awarded;         // Amount awarded   // return (users[index].salaryId, users[index].name, users[index].userAddress, users[index].salary);\n', '    // return (recipient, url, judged, submissionApproved, judgedBy, adminComments, todaysHash, awarded);\n', '  }\n', '\n', '\n', '\n', '  // Members judge steak pics, providing justification if necessary.\n', '  function judge(uint submissionNumber, bool supportsSubmission, bytes32 justificationText) onlyMembers {\n', '    Submission storage s = submissions[submissionNumber];         // Get the submission.\n', '    require(!s.judged);                                     // Musn&#39;t be judged.\n', '\n', '    s.judged = true;\n', '    s.judgedBy = msg.sender;\n', '    s.submissionApproved = supportsSubmission;\n', '    s.adminComments = justificationText;    // Admin can add comments whether approved or not\n', '\n', '    if (supportsSubmission) { // If it passed muster, credit the user and admin.\n', '      uint prizeAmount = getSteakPrize(); // Calculate BOV prize\n', '      s.awarded = prizeAmount;            // Record amount in the Submission\n', '      mint(s.recipient, prizeAmount);     // Credit the user&#39;s account\n', '\n', '      // Credit the member one-third of the prize amount.\n', '      uint adminAward = prizeAmount.div(3);\n', '      mint(msg.sender, adminAward);\n', '\n', '      approvedSubmissions.push(s);\n', '    }\n', '\n', '    Judged(submissionNumber, supportsSubmission, msg.sender, justificationText);\n', '  }\n', '\n', '\n', '  // Calculate how many BOV are rewarded per approved steak pic.\n', '  function getSteakPrize() public constant returns (uint) {\n', '    require(initialPrizeBov > 0); // crowdsale must be over (endCrowdsale() calls setInitialPrize())\n', '    uint halvings = numberOfApprovedSteaks().div(halvingInterval);\n', '    if (halvings > numberOfHalvings) {  // After 8 halvings, no more BOV is awarded.\n', '      return 0;\n', '    }\n', '\n', '    uint prize = initialPrizeBov;\n', '\n', '    prize = prize >> halvings; // Halve the initial prize "halvings"-number of times.\n', '    return prize;\n', '  }\n', '\n', '\n', '  function numberOfApprovedSteaks() public constant returns (uint) {\n', '    return approvedSubmissions.length;\n', '  }\n', '\n', '\n', '  // Always call this before calling dailyHash and submitting a steak.\n', '  // If expired, the new hash is set to the last block&#39;s hash.\n', '  function getDailyHash() public returns (bytes32) {\n', '    if (dailyHashExpires > now) { // If the hash hasn&#39;t expired yet, return it.\n', '      return dailyHash;\n', '    } else { // Udderwise, set the new dailyHash and dailyHashExpiration.\n', '\n', '      // Get hash from the last block.\n', '      bytes32 newHash = block.blockhash(block.number-1);\n', '      dailyHash = newHash;\n', '\n', '      // Set the new expiration, jumping ahead in 24-hour increments so the expiration time remains roughly constant from day to day (e.g. 3am).\n', '      uint nextExpiration = dailyHashExpires + 24 hours; // It will already be expired, so set it to next possible date.\n', '      while (nextExpiration < now) { // if it&#39;s still in the past, advance by 24 hours.\n', '        nextExpiration += 24 hours;\n', '      }\n', '      dailyHashExpires = nextExpiration;\n', '      return newHash;\n', '    }\n', '  }\n', '\n', '  // Returns the amount of minutes to post with the current dailyHash\n', '  function minutesToPost() public constant returns (uint) {\n', '    if (dailyHashExpires > now) {\n', '      return (dailyHashExpires - now) / 60; // returns minutes\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function currentBlock() public constant returns (uint) {\n', '    return block.number;\n', '  }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' *\n', ' *  STEAK TOKEN (BOV)\n', ' *\n', ' *  Make bank by eating flank. See https://steaktoken.com.\n', ' *\n', ' */\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', ' library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' contract Ownable {\n', '  address public owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract SteakToken is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public name = "Steak Token";\n', '  string public symbol = "BOV";\n', '  uint public decimals = 18;\n', '  uint public totalSupply;      // Total BOV in circulation.\n', '\n', '  mapping(address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed ownerAddress, address indexed spenderAddress, uint256 value);\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MineFinished();\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    if(msg.data.length < (2 * 32) + 4) { revert(); } // protect against short address attack\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '   function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '   function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '    /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will recieve the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '   function mint(address _to, uint256 _amount) internal returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AuctionCrowdsale \n', ' * @dev The owner starts and ends the crowdsale manually.\n', ' * Players can make token purchases during the crowdsale\n', ' * and their tokens can be claimed after the sale ends.\n', ' * Players receive an amount proportional to their investment.\n', ' */\n', ' contract AuctionCrowdsale is SteakToken {\n', '  using SafeMath for uint;\n', '\n', '  uint public initialSale;                  // Amount of BOV tokens being sold during crowdsale.\n', '\n', '  bool public saleStarted;\n', '  bool public saleEnded;\n', '\n', '  uint public absoluteEndBlock;             // Anybody can end the crowdsale and trigger token distribution if beyond this block number.\n', '\n', '  uint256 public weiRaised;                 // Total amount raised in crowdsale.\n', '\n', '  address[] public investors;               // Investor addresses\n', '  uint public numberOfInvestors;\n', '  mapping(address => uint256) public investments; // How much each address has invested.\n', '\n', '  mapping(address => bool) public claimed;      // Keep track of whether each investor has been awarded their BOV tokens.\n', '\n', '\n', '  bool public bovBatchDistributed;              // TODO: this can be removed with manual crowdsale end-time\n', '\n', '  uint public initialPrizeWeiValue;             // The first steaks mined will be awarded BOV equivalent to this ETH value. Set in Steak() initializer.\n', '  uint public initialPrizeBov;                  // Initial mining prize in BOV units. Set in endCrowdsale() or endCrowdsalePublic().\n', '\n', '  uint public dailyHashExpires;        // When the dailyHash expires. Will be roughly around 3am EST.\n', '\n', '\n', '\n', '\n', '\n', '  /**\n', '   * event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   */ \n', '   event TokenInvestment(address indexed purchaser, address indexed beneficiary, uint256 value);\n', '\n', '\n', '\n', "   // Sending ETH to this contract's address registers the investment.\n", '   function () payable {\n', '    invest(msg.sender);\n', '  }\n', '\n', '\n', '  // Participate in the crowdsale.\n', '  // Records how much each address has invested.\n', '  function invest(address beneficiary) payable {\n', '    require(beneficiary != 0x0);\n', '    require(validInvestment());\n', '\n', '    uint256 weiAmount = msg.value;\n', '\n', '    uint investedAmount = investments[beneficiary];\n', '\n', '    forwardFunds();\n', '\n', "    if (investedAmount > 0) { // If they've already invested, increase their balance.\n", '      investments[beneficiary] = investedAmount + weiAmount; // investedAmount.add(weiAmount);\n', '    } else { // If new investor\n', '      investors.push(beneficiary);\n', '      numberOfInvestors += 1;\n', '      investments[beneficiary] = weiAmount;\n', '    }\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    TokenInvestment(msg.sender, beneficiary, weiAmount);\n', '  }\n', '\n', '\n', '\n', '  // @return true if the transaction can invest\n', '  function validInvestment() internal constant returns (bool) {\n', '    bool withinPeriod = saleStarted && !saleEnded;\n', '    bool nonZeroPurchase = (msg.value > 0);\n', '    return withinPeriod && nonZeroPurchase;\n', '  }\n', '\n', '\n', '\n', '\n', '  // Distribute 10M tokens proportionally amongst all investors. Can be called by anyone after the crowdsale ends.\n', '  // ClaimTokens() can be run by individuals to claim their tokens.\n', '  function distributeAllTokens() public {\n', '\n', '    require(!bovBatchDistributed);\n', '    require(crowdsaleHasEnded());\n', '\n', '    // Allocate BOV proportionally to each investor.\n', '\n', '    for (uint i=0; i < numberOfInvestors; i++) {\n', '      address investorAddr = investors[i];\n', "      if (!claimed[investorAddr]) { // If the investor hasn't already claimed their BOV.\n", '        claimed[investorAddr] = true;\n', '        uint amountInvested = investments[investorAddr];\n', '        uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\n', '        mint(investorAddr, bovEarned);\n', '      }\n', '    }\n', '\n', '    bovBatchDistributed = true;\n', '  }\n', '\n', '\n', '  // Claim your BOV; allocates BOV proportionally to this investor.\n', '  // Can be called by investors to claim their BOV after the crowdsale ends.\n', '  // distributeAllTokens() is a batch alternative to this.\n', '  function claimTokens(address origAddress) public {\n', '    require(crowdsaleHasEnded());\n', '    require(claimed[origAddress] == false);\n', '    uint amountInvested = investments[origAddress];\n', '    uint bovEarned = amountInvested.mul(initialSale).div(weiRaised);\n', '    claimed[origAddress] = true;\n', '    mint(origAddress, bovEarned);\n', '  }\n', '\n', '\n', '  // Investors: see how many BOV you are currently entitled to (before the end of the crowdsale and distribution of tokens).\n', '  function getCurrentShare(address addr) public constant returns (uint) {\n', '    require(!bovBatchDistributed && !claimed[addr]); // Tokens cannot have already been distributed.\n', '    uint amountInvested = investments[addr];\n', '    uint currentBovShare = amountInvested.mul(initialSale).div(weiRaised);\n', '    return currentBovShare;\n', '  }\n', '\n', '\n', '\n', '  // send ether to the fund collection wallet\n', '  function forwardFunds() internal {\n', '    owner.transfer(msg.value);\n', '  }\n', '\n', '\n', '  // The owner manually starts the crowdsale at a pre-determined time.\n', '  function startCrowdsale() onlyOwner {\n', '    require(!saleStarted && !saleEnded);\n', '    saleStarted = true;\n', '  }\n', '\n', '  // endCrowdsale() and endCrowdsalePublic() moved to Steak contract\n', '    // Normally, the owner will end the crowdsale at the pre-determined time.\n', '  function endCrowdsale() onlyOwner {\n', '    require(saleStarted && !saleEnded);\n', '    dailyHashExpires = now; // Will end crowdsale at 3am EST, so expiration time will roughly be around 3am.\n', '    saleEnded = true;\n', '    setInitialPrize();\n', '  }\n', '\n', '  // Normally, Madame BOV ends the crowdsale at the pre-determined time, but if Madame BOV fails to do so, anybody can trigger endCrowdsalePublic() after absoluteEndBlock.\n', '  function endCrowdsalePublic() public {\n', '    require(block.number > absoluteEndBlock);\n', '    require(saleStarted && !saleEnded);\n', '    dailyHashExpires = now;\n', '    saleEnded = true;\n', '    setInitialPrize();\n', '  }\n', '\n', '\n', "  // Calculate initial mining prize (0.0357 ether's worth of BOV). This is called in endCrowdsale().\n", '  function setInitialPrize() internal returns (uint) {\n', '    require(crowdsaleHasEnded());\n', '    require(initialPrizeBov == 0); // Can only be set once\n', '    uint tokenUnitsPerWei = initialSale.div(weiRaised);\n', '    initialPrizeBov = tokenUnitsPerWei.mul(initialPrizeWeiValue);\n', '    return initialPrizeBov;\n', '  }\n', '\n', '\n', '  // @return true if crowdsale event has ended\n', '  function crowdsaleHasEnded() public constant returns (bool) {\n', '    return saleStarted && saleEnded;\n', '  }\n', '\n', '  function getInvestors() public returns (address[]) {\n', '    return investors;\n', '  }\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Steak is AuctionCrowdsale {\n', '  // using SafeMath for uint;\n', '\n', '  bytes32 public dailyHash;            // The last five digits of the dailyHash must be included in steak pictures.\n', '\n', '\n', '  Submission[] public submissions;          // All steak pics\n', '  uint public numSubmissions;\n', '\n', '  Submission[] public approvedSubmissions;\n', '  mapping (address => uint) public memberId;    // Get member ID from address.\n', '  Member[] public members;                      // Index is memberId\n', '\n', '  uint public halvingInterval;                  // BOV award is halved every x steaks\n', '  uint public numberOfHalvings;                 // How many times the BOV reward per steak is halved before it returns 0. \n', '\n', '\n', '\n', '  uint public lastMiningBlock;                  // No mining after this block. Set in initializer.\n', '\n', '  bool public ownerCredited;    // Has the owner been credited BOV yet?\n', '\n', '  event PicAdded(address msgSender, uint submissionID, address recipient, bytes32 propUrl); // Need msgSender so we can watch for this event.\n', '  event Judged(uint submissionID, bool position, address voter, bytes32 justification);\n', '  event MembershipChanged(address member, bool isMember);\n', '\n', '  struct Submission {\n', '    address recipient;    // Would-be BOV recipient\n', '    bytes32 url;           // IMGUR url; 32-char max\n', '    bool judged;          // Has an admin voted?\n', '    bool submissionApproved;// Has it been approved?\n', '    address judgedBy;     // Admin who judged this steak\n', '    bytes32 adminComments; // Admin should leave feedback on non-approved steaks. 32-char max.\n', '    bytes32 todaysHash;   // The hash in the image should match this hash.\n', '    uint awarded;         // Amount awarded\n', '  }\n', '\n', '  // Members can vote on steak\n', '  struct Member {\n', '    address member;\n', '    bytes32 name;\n', '    uint memberSince;\n', '  }\n', '\n', '\n', '  modifier onlyMembers {\n', '    require(memberId[msg.sender] != 0); // member id must be in the mapping\n', '    _;\n', '  }\n', '\n', '\n', '  function Steak() {\n', '\n', '    owner = msg.sender;\n', '    initialSale = 10000000 * 1000000000000000000; // 10M BOV units are awarded in the crowdsale.\n', '\n', '    // Normally, the owner both starts and ends the crowdsale.\n', '    // To guarantee that the crowdsale ends at some maximum point (at that tokens are distributed),\n', '    // we calculate the absoluteEndBlock, the block beyond which anybody can end the crowdsale and distribute tokens.\n', '    uint blocksPerHour = 212;\n', '    uint maxCrowdsaleLifeFromLaunchDays = 40; // After about this many days from launch, anybody can end the crowdsale and distribute / claim their tokens. \n', '    absoluteEndBlock = block.number + (blocksPerHour * 24 * maxCrowdsaleLifeFromLaunchDays);\n', '\n', '    uint miningDays = 365; // Approximately how many days BOV can be mined from the launch of the contract.\n', '    lastMiningBlock = block.number + (blocksPerHour * 24 * miningDays);\n', '\n', '    dailyHashExpires = now;\n', '\n', '    halvingInterval = 500;    // How many steaks get awarded the given getSteakPrize() amount before the reward is halved.\n', '    numberOfHalvings = 8;      // How many times the steak prize gets halved before no more prize is awarded.\n', '\n', '    // initialPrizeWeiValue = 50 finney; // 0.05 ether == 50 finney == 2.80 USD * 5 == 14 USD\n', '    initialPrizeWeiValue = (357 finney / 10); // 0.0357 ether == 35.7 finney == 2.80 USD * 3.57 == 9.996 USD\n', '\n', '    // To finish initializing, owner calls initMembers() and creditOwner() after launch.\n', '  }\n', '\n', '\n', '  // Add Madame BOV as a beef judge.\n', '  function initMembers() onlyOwner {\n', "    addMember(0, '');                        // Must add an empty first member\n", "    addMember(msg.sender, 'Madame BOV');\n", '  }\n', '\n', '\n', '\n', '  // Send 1M BOV to Madame BOV. \n', '  function creditOwner() onlyOwner {\n', '    require(!ownerCredited);\n', '    uint ownerAward = initialSale / 10;  // 10% of the crowdsale amount.\n', '    ownerCredited = true;   // Can only be run once.\n', '    mint(owner, ownerAward);\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '\n', '  /* Add beef judge */\n', '  function addMember(address targetMember, bytes32 memberName) onlyOwner {\n', '    uint id;\n', '    if (memberId[targetMember] == 0) {\n', '      memberId[targetMember] = members.length;\n', '      id = members.length++;\n', '      members[id] = Member({member: targetMember, memberSince: now, name: memberName});\n', '    } else {\n', '      id = memberId[targetMember];\n', '      // Member m = members[id];\n', '    }\n', '    MembershipChanged(targetMember, true);\n', '  }\n', '\n', '  function removeMember(address targetMember) onlyOwner {\n', '    if (memberId[targetMember] == 0) revert();\n', '\n', '    memberId[targetMember] = 0;\n', '\n', '    for (uint i = memberId[targetMember]; i<members.length-1; i++){\n', '      members[i] = members[i+1];\n', '    }\n', '    delete members[members.length-1];\n', '    members.length--;\n', '  }\n', '\n', '\n', '\n', '  /* Submit a steak picture. (After crowdsale has ended.)\n', '  *  WARNING: Before taking the picture, call getDailyHash() and  minutesToPost()\n', "  *  so you can be sure that you have the correct dailyHash and that it won't expire before you post it.\n", '  */\n', '  function submitSteak(address addressToAward, bytes32 steakPicUrl)  returns (uint submissionID) {\n', '    require(crowdsaleHasEnded());\n', '    require(block.number <= lastMiningBlock); // Cannot submit beyond this block.\n', '    submissionID = submissions.length++; // Increase length of array\n', '    Submission storage s = submissions[submissionID];\n', '    s.recipient = addressToAward;\n', '    s.url = steakPicUrl;\n', '    s.judged = false;\n', '    s.submissionApproved = false;\n', '    s.todaysHash = getDailyHash(); // Each submission saves the hash code the user should take picture of in steak picture.\n', '\n', '    PicAdded(msg.sender, submissionID, addressToAward, steakPicUrl);\n', '    numSubmissions = submissionID+1;\n', '\n', '    return submissionID;\n', '  }\n', '\n', '  // Retrieving any Submission must be done via this function, not `submissions()`\n', '  function getSubmission(uint submissionID) public constant returns (address recipient, bytes32 url, bool judged, bool submissionApproved, address judgedBy, bytes32 adminComments, bytes32 todaysHash, uint awarded) {\n', '    Submission storage s = submissions[submissionID];\n', '    recipient = s.recipient;\n', '    url = s.url;                 // IMGUR url\n', '    judged = s.judged;           // Has an admin voted?\n', '    submissionApproved = s.submissionApproved;  // Has it been approved?\n', '    judgedBy = s.judgedBy;           // Admin who judged this steak\n', '    adminComments = s.adminComments; // Admin should leave feedback on non-approved steaks\n', '    todaysHash = s.todaysHash;       // The hash in the image should match this hash.\n', '    awarded = s.awarded;         // Amount awarded   // return (users[index].salaryId, users[index].name, users[index].userAddress, users[index].salary);\n', '    // return (recipient, url, judged, submissionApproved, judgedBy, adminComments, todaysHash, awarded);\n', '  }\n', '\n', '\n', '\n', '  // Members judge steak pics, providing justification if necessary.\n', '  function judge(uint submissionNumber, bool supportsSubmission, bytes32 justificationText) onlyMembers {\n', '    Submission storage s = submissions[submissionNumber];         // Get the submission.\n', "    require(!s.judged);                                     // Musn't be judged.\n", '\n', '    s.judged = true;\n', '    s.judgedBy = msg.sender;\n', '    s.submissionApproved = supportsSubmission;\n', '    s.adminComments = justificationText;    // Admin can add comments whether approved or not\n', '\n', '    if (supportsSubmission) { // If it passed muster, credit the user and admin.\n', '      uint prizeAmount = getSteakPrize(); // Calculate BOV prize\n', '      s.awarded = prizeAmount;            // Record amount in the Submission\n', "      mint(s.recipient, prizeAmount);     // Credit the user's account\n", '\n', '      // Credit the member one-third of the prize amount.\n', '      uint adminAward = prizeAmount.div(3);\n', '      mint(msg.sender, adminAward);\n', '\n', '      approvedSubmissions.push(s);\n', '    }\n', '\n', '    Judged(submissionNumber, supportsSubmission, msg.sender, justificationText);\n', '  }\n', '\n', '\n', '  // Calculate how many BOV are rewarded per approved steak pic.\n', '  function getSteakPrize() public constant returns (uint) {\n', '    require(initialPrizeBov > 0); // crowdsale must be over (endCrowdsale() calls setInitialPrize())\n', '    uint halvings = numberOfApprovedSteaks().div(halvingInterval);\n', '    if (halvings > numberOfHalvings) {  // After 8 halvings, no more BOV is awarded.\n', '      return 0;\n', '    }\n', '\n', '    uint prize = initialPrizeBov;\n', '\n', '    prize = prize >> halvings; // Halve the initial prize "halvings"-number of times.\n', '    return prize;\n', '  }\n', '\n', '\n', '  function numberOfApprovedSteaks() public constant returns (uint) {\n', '    return approvedSubmissions.length;\n', '  }\n', '\n', '\n', '  // Always call this before calling dailyHash and submitting a steak.\n', "  // If expired, the new hash is set to the last block's hash.\n", '  function getDailyHash() public returns (bytes32) {\n', "    if (dailyHashExpires > now) { // If the hash hasn't expired yet, return it.\n", '      return dailyHash;\n', '    } else { // Udderwise, set the new dailyHash and dailyHashExpiration.\n', '\n', '      // Get hash from the last block.\n', '      bytes32 newHash = block.blockhash(block.number-1);\n', '      dailyHash = newHash;\n', '\n', '      // Set the new expiration, jumping ahead in 24-hour increments so the expiration time remains roughly constant from day to day (e.g. 3am).\n', '      uint nextExpiration = dailyHashExpires + 24 hours; // It will already be expired, so set it to next possible date.\n', "      while (nextExpiration < now) { // if it's still in the past, advance by 24 hours.\n", '        nextExpiration += 24 hours;\n', '      }\n', '      dailyHashExpires = nextExpiration;\n', '      return newHash;\n', '    }\n', '  }\n', '\n', '  // Returns the amount of minutes to post with the current dailyHash\n', '  function minutesToPost() public constant returns (uint) {\n', '    if (dailyHashExpires > now) {\n', '      return (dailyHashExpires - now) / 60; // returns minutes\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function currentBlock() public constant returns (uint) {\n', '    return block.number;\n', '  }\n', '}']
