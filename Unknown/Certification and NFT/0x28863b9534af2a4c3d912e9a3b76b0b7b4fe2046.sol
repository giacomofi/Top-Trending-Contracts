['pragma solidity ^0.4.13;\n', '\n', '// Viberate ICO buyer\n', '// Avtor: Janez\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract ViberateBuyer {\n', '  // Koliko ETH je vlozil vsak racun.\n', '  mapping (address => uint256) public balances;\n', '  // Nagrada za izvedbo nakupa.\n', '  uint256 public buy_bounty;\n', '  // Nagrada za dvig.\n', '  uint256 public withdraw_bounty;\n', '  // Podatek ali smo tokene uspesno kupili.\n', '  bool public bought_tokens;\n', '  // Vrednost tokenov v pogodbi.\n', '  uint256 public contract_eth_value;\n', '  // Varnostni kill switch v primeru da se najde kriticen hrosc in zelimo pogodbo prekiniti in vsem vrniti ETH.\n', '  bool public kill_switch;\n', '  \n', '  // SHA3 izvlecek gesla.\n', '  bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4;\n', '  // Kdaj najbolj zgodaj lahko kupimo.\n', '  uint256 public earliest_buy_time = 1504612800;\n', '  // Nas interni cap. Zato da ne gremo cez hard cap.\n', '  uint256 public eth_cap = 10000 ether;\n', '  // Naslov razvijalca.\n', '  address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882;\n', '  // Crowdsale naslov.  To lahko nastavi le razvijalec.\n', '  address public sale;\n', '  // Naslov tokena.  To lahko nastavi le razvijalec.\n', '  ERC20 public token;\n', '  \n', '  // Razvijalec s klicom te funkcije nastavi naslov crowdsale-a\n', '  function set_addresses(address _sale, address _token) {\n', '    // Samo razvijalec lahko nastavi naslov in token.\n', '    require(msg.sender == developer);\n', '    // Naslov se lahko nastavi le 1x.\n', '    require(sale == 0x0);\n', '    // Nastavljanje naslova in tokena.\n', '    sale = _sale;\n', '    token = ERC20(_token);\n', '  }\n', '  \n', '  // V skrajni sili lahko razvijalec ali pa kdorkoli s posebnim geslom aktivira &#39;kill switch&#39;. Po aktivaciji je mozen le se dvig sredstev.\n', '  function activate_kill_switch(string password) {\n', '    // Aktiviraj kill switch samo ce ga aktivira razvijalec, ali pa je geslo pravilno.\n', '    require(msg.sender == developer || sha3(password) == password_hash);\n', '    // Nagrado shranimo v zacasno spremenljivko.\n', '    uint256 claimed_bounty = buy_bounty;\n', '    // Nagrado nastavimo na 0.\n', '    buy_bounty = 0;\n', '    // Aktiviramo kill switch.\n', '    kill_switch = true;\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Poslje ETHje ali tokene klicatelju.\n', '  function personal_withdraw(){\n', '    // Ce uporabnik nima denarja koncamo.\n', '    if (balances[msg.sender] == 0) return;\n', '    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\n', '    if (!bought_tokens) {\n', '      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\n', '      uint256 eth_to_withdraw = balances[msg.sender];\n', '      // Uporabnik sedaj nima vec ETH.\n', '      balances[msg.sender] = 0;\n', '      // ETH vrnemo uporabniku.\n', '      msg.sender.transfer(eth_to_withdraw);\n', '    }\n', '    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\n', '    else {\n', '      // Preverimo koliko tokenov ima pogodba.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Ce se nimamo tokenov, potem ne dvigujemo.\n', '      require(contract_token_balance != 0);\n', '      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\n', '      uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value;\n', '      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\n', '      contract_eth_value -= balances[msg.sender];\n', '      // Odstejemo uporabnikovo vrednost.\n', '      balances[msg.sender] = 0;\n', '      // 1% strosek za pogodbo ce smo tokene kupili.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Poslji strosek razvijalcu.\n', '      require(token.transfer(developer, fee));\n', '      // Posljemo tokene uporabniku.\n', '      require(token.transfer(msg.sender, tokens_to_withdraw - fee));\n', '    }\n', '  }\n', '\n', '  // Poslje ETHje uporabniku ali pa tokene in nagradi klicatelja funkcije.\n', '  function withdraw(address user){\n', '    // Dvig dovoljen ce smo kupili tokene ali pa cez eno uro po crowdsalu (ce nismo), ali pa ce je aktiviran kill switch.\n', '    require(bought_tokens || now > earliest_buy_time + 1 hours || kill_switch);\n', '    // Ce uporabnik nima denarja koncamo.\n', '    if (balances[user] == 0) return;\n', '    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\n', '    if (!bought_tokens) {\n', '      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\n', '      uint256 eth_to_withdraw = balances[user];\n', '      // Uporabnik sedaj nima vec ETH.\n', '      balances[user] = 0;\n', '      // ETH vrnemo uporabniku.\n', '      user.transfer(eth_to_withdraw);\n', '    }\n', '    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\n', '    else {\n', '      // Preverimo koliko tokenov ima pogodba.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Ce se nimamo tokenov, potem ne dvigujemo.\n', '      require(contract_token_balance != 0);\n', '      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\n', '      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n', '      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\n', '      contract_eth_value -= balances[user];\n', '      // Odstejemo uporabnikovo vrednost.\n', '      balances[user] = 0;\n', '      // 1% strosek za pogodbo ce smo tokene kupili.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Poslji strosek razvijalcu.\n', '      require(token.transfer(developer, fee));\n', '      // Posljemo tokene uporabniku.\n', '      require(token.transfer(user, tokens_to_withdraw - fee));\n', '    }\n', '    // Vsak klic za dvig dobi 1% nagrade za dvig.\n', '    uint256 claimed_bounty = withdraw_bounty / 100;\n', '    // Zmanjsamo nagrado za dvig.\n', '    withdraw_bounty -= claimed_bounty;\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Razvijalec lahko doda ETH v nagrado za vplacilo.\n', '  function add_to_buy_bounty() payable {\n', '    // Samo razvijalec lahko doda nagrado.\n', '    require(msg.sender == developer);\n', '    // Povecaj nagrado.\n', '    buy_bounty += msg.value;\n', '  }\n', '  \n', '  // Razvijalec lahko doda nagrado za dvig.\n', '  function add_to_withdraw_bounty() payable {\n', '    // Samo razvijalec lahko doda nagrado za dvig.\n', '    require(msg.sender == developer);\n', '    // Povecaj nagrado za dvig.\n', '    withdraw_bounty += msg.value;\n', '  }\n', '  \n', '  // Kupi tokene v crowdsalu, nagradi klicatelja. To funkcijo lahko poklice kdorkoli.\n', '  function claim_bounty(){\n', '    // Ce smo ze kupili koncamo.\n', '    if (bought_tokens) return;\n', '    // Ce cas se ni dosezen, koncamo.\n', '    if (now < earliest_buy_time) return;\n', '    // Ce je aktiviran &#39;kill switch&#39;, koncamo.\n', '    if (kill_switch) return;\n', '    // Ce razvijalec se ni dodal naslova, potem ne kupujemo.\n', '    require(sale != 0x0);\n', '    // Zapomnimo si da smo kupili tokene.\n', '    bought_tokens = true;\n', '    // Nagrado shranemo v zacasno spremenljivko.\n', '    uint256 claimed_bounty = buy_bounty;\n', '    // Nagrade zdaj ni vec.\n', '    buy_bounty = 0;\n', '    // Zapomnimo si koliko ETH smo poslali na crowdsale (vse razen nagrad)\n', '    contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);\n', '    // Poslje celoten znesek ETH (brez nagrad) na crowdsale naslov.\n', '    require(sale.call.value(contract_eth_value)());\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Ta funkcija se poklice ko kdorkoli poslje ETH na pogodbo.\n', '  function () payable {\n', '    // Zavrnemo transakcijo, ce je kill switch aktiviran.\n', '    require(!kill_switch);\n', '    // Vplacila so dovoljena dokler se nismo kupili tokenov.\n', '    require(!bought_tokens);\n', '    // Vplacila so dovoljena dokler nismo dosegli nasega capa.\n', '    require(this.balance < eth_cap);\n', '    // Shranimo uporabnikov vlozek.\n', '    balances[msg.sender] += msg.value;\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', '// Viberate ICO buyer\n', '// Avtor: Janez\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract ViberateBuyer {\n', '  // Koliko ETH je vlozil vsak racun.\n', '  mapping (address => uint256) public balances;\n', '  // Nagrada za izvedbo nakupa.\n', '  uint256 public buy_bounty;\n', '  // Nagrada za dvig.\n', '  uint256 public withdraw_bounty;\n', '  // Podatek ali smo tokene uspesno kupili.\n', '  bool public bought_tokens;\n', '  // Vrednost tokenov v pogodbi.\n', '  uint256 public contract_eth_value;\n', '  // Varnostni kill switch v primeru da se najde kriticen hrosc in zelimo pogodbo prekiniti in vsem vrniti ETH.\n', '  bool public kill_switch;\n', '  \n', '  // SHA3 izvlecek gesla.\n', '  bytes32 password_hash = 0xfac0a99293c75e2f2ed76d4eb06030f4f3458f419a67ca0feac3dbe9791275b4;\n', '  // Kdaj najbolj zgodaj lahko kupimo.\n', '  uint256 public earliest_buy_time = 1504612800;\n', '  // Nas interni cap. Zato da ne gremo cez hard cap.\n', '  uint256 public eth_cap = 10000 ether;\n', '  // Naslov razvijalca.\n', '  address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882;\n', '  // Crowdsale naslov.  To lahko nastavi le razvijalec.\n', '  address public sale;\n', '  // Naslov tokena.  To lahko nastavi le razvijalec.\n', '  ERC20 public token;\n', '  \n', '  // Razvijalec s klicom te funkcije nastavi naslov crowdsale-a\n', '  function set_addresses(address _sale, address _token) {\n', '    // Samo razvijalec lahko nastavi naslov in token.\n', '    require(msg.sender == developer);\n', '    // Naslov se lahko nastavi le 1x.\n', '    require(sale == 0x0);\n', '    // Nastavljanje naslova in tokena.\n', '    sale = _sale;\n', '    token = ERC20(_token);\n', '  }\n', '  \n', "  // V skrajni sili lahko razvijalec ali pa kdorkoli s posebnim geslom aktivira 'kill switch'. Po aktivaciji je mozen le se dvig sredstev.\n", '  function activate_kill_switch(string password) {\n', '    // Aktiviraj kill switch samo ce ga aktivira razvijalec, ali pa je geslo pravilno.\n', '    require(msg.sender == developer || sha3(password) == password_hash);\n', '    // Nagrado shranimo v zacasno spremenljivko.\n', '    uint256 claimed_bounty = buy_bounty;\n', '    // Nagrado nastavimo na 0.\n', '    buy_bounty = 0;\n', '    // Aktiviramo kill switch.\n', '    kill_switch = true;\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Poslje ETHje ali tokene klicatelju.\n', '  function personal_withdraw(){\n', '    // Ce uporabnik nima denarja koncamo.\n', '    if (balances[msg.sender] == 0) return;\n', '    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\n', '    if (!bought_tokens) {\n', '      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\n', '      uint256 eth_to_withdraw = balances[msg.sender];\n', '      // Uporabnik sedaj nima vec ETH.\n', '      balances[msg.sender] = 0;\n', '      // ETH vrnemo uporabniku.\n', '      msg.sender.transfer(eth_to_withdraw);\n', '    }\n', '    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\n', '    else {\n', '      // Preverimo koliko tokenov ima pogodba.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Ce se nimamo tokenov, potem ne dvigujemo.\n', '      require(contract_token_balance != 0);\n', '      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\n', '      uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value;\n', '      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\n', '      contract_eth_value -= balances[msg.sender];\n', '      // Odstejemo uporabnikovo vrednost.\n', '      balances[msg.sender] = 0;\n', '      // 1% strosek za pogodbo ce smo tokene kupili.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Poslji strosek razvijalcu.\n', '      require(token.transfer(developer, fee));\n', '      // Posljemo tokene uporabniku.\n', '      require(token.transfer(msg.sender, tokens_to_withdraw - fee));\n', '    }\n', '  }\n', '\n', '  // Poslje ETHje uporabniku ali pa tokene in nagradi klicatelja funkcije.\n', '  function withdraw(address user){\n', '    // Dvig dovoljen ce smo kupili tokene ali pa cez eno uro po crowdsalu (ce nismo), ali pa ce je aktiviran kill switch.\n', '    require(bought_tokens || now > earliest_buy_time + 1 hours || kill_switch);\n', '    // Ce uporabnik nima denarja koncamo.\n', '    if (balances[user] == 0) return;\n', '    // Ce pogodbi ni uspelo kupiti, potem vrnemo ETH.\n', '    if (!bought_tokens) {\n', '      // Pred dvigom shranimo uporabnikov vlozek v zacasno spremenljivko.\n', '      uint256 eth_to_withdraw = balances[user];\n', '      // Uporabnik sedaj nima vec ETH.\n', '      balances[user] = 0;\n', '      // ETH vrnemo uporabniku.\n', '      user.transfer(eth_to_withdraw);\n', '    }\n', '    // Ce je pogodba uspesno kupila tokene, jih nakazemo uporabniku.\n', '    else {\n', '      // Preverimo koliko tokenov ima pogodba.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Ce se nimamo tokenov, potem ne dvigujemo.\n', '      require(contract_token_balance != 0);\n', '      // Shranimo stevilo uporabnikovih tokenov v zacasno spremenljivko.\n', '      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n', '      // Odstejemo uporabnikovo vrednost od vrednosti pogodbe.\n', '      contract_eth_value -= balances[user];\n', '      // Odstejemo uporabnikovo vrednost.\n', '      balances[user] = 0;\n', '      // 1% strosek za pogodbo ce smo tokene kupili.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Poslji strosek razvijalcu.\n', '      require(token.transfer(developer, fee));\n', '      // Posljemo tokene uporabniku.\n', '      require(token.transfer(user, tokens_to_withdraw - fee));\n', '    }\n', '    // Vsak klic za dvig dobi 1% nagrade za dvig.\n', '    uint256 claimed_bounty = withdraw_bounty / 100;\n', '    // Zmanjsamo nagrado za dvig.\n', '    withdraw_bounty -= claimed_bounty;\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Razvijalec lahko doda ETH v nagrado za vplacilo.\n', '  function add_to_buy_bounty() payable {\n', '    // Samo razvijalec lahko doda nagrado.\n', '    require(msg.sender == developer);\n', '    // Povecaj nagrado.\n', '    buy_bounty += msg.value;\n', '  }\n', '  \n', '  // Razvijalec lahko doda nagrado za dvig.\n', '  function add_to_withdraw_bounty() payable {\n', '    // Samo razvijalec lahko doda nagrado za dvig.\n', '    require(msg.sender == developer);\n', '    // Povecaj nagrado za dvig.\n', '    withdraw_bounty += msg.value;\n', '  }\n', '  \n', '  // Kupi tokene v crowdsalu, nagradi klicatelja. To funkcijo lahko poklice kdorkoli.\n', '  function claim_bounty(){\n', '    // Ce smo ze kupili koncamo.\n', '    if (bought_tokens) return;\n', '    // Ce cas se ni dosezen, koncamo.\n', '    if (now < earliest_buy_time) return;\n', "    // Ce je aktiviran 'kill switch', koncamo.\n", '    if (kill_switch) return;\n', '    // Ce razvijalec se ni dodal naslova, potem ne kupujemo.\n', '    require(sale != 0x0);\n', '    // Zapomnimo si da smo kupili tokene.\n', '    bought_tokens = true;\n', '    // Nagrado shranemo v zacasno spremenljivko.\n', '    uint256 claimed_bounty = buy_bounty;\n', '    // Nagrade zdaj ni vec.\n', '    buy_bounty = 0;\n', '    // Zapomnimo si koliko ETH smo poslali na crowdsale (vse razen nagrad)\n', '    contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);\n', '    // Poslje celoten znesek ETH (brez nagrad) na crowdsale naslov.\n', '    require(sale.call.value(contract_eth_value)());\n', '    // Klicatelju posljemo nagrado.\n', '    msg.sender.transfer(claimed_bounty);\n', '  }\n', '  \n', '  // Ta funkcija se poklice ko kdorkoli poslje ETH na pogodbo.\n', '  function () payable {\n', '    // Zavrnemo transakcijo, ce je kill switch aktiviran.\n', '    require(!kill_switch);\n', '    // Vplacila so dovoljena dokler se nismo kupili tokenov.\n', '    require(!bought_tokens);\n', '    // Vplacila so dovoljena dokler nismo dosegli nasega capa.\n', '    require(this.balance < eth_cap);\n', '    // Shranimo uporabnikov vlozek.\n', '    balances[msg.sender] += msg.value;\n', '  }\n', '}']
