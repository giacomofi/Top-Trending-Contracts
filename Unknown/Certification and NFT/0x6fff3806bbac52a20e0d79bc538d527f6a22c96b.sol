['/// auth.sol -- widely-used access control pattern for Ethereum\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'pragma solidity ^0.4.13;\n', '\n', 'contract Authority {\n', '    function canCall(address src, address dst, bytes4 sig) constant returns (bool);\n', '}\n', '\n', 'contract AuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '    event UnauthorizedAccess (address caller, bytes4 sig);\n', '}\n', '\n', 'contract Auth is AuthEvents {\n', '    Authority  public  authority;\n', '    address public owner;\n', '\n', '    function Auth() {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) auth {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(Authority authority_) auth {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner && authority == Authority(0)) {\n', '            /*the owner has privileges only as long as no Authority has been defined*/\n', '            return true;\n', '        } else if (authority == Authority(0)) {\n', '            UnauthorizedAccess(src, sig);\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '/*\n', '   Copyright 2017 DappHub, LLC\n', '\n', '   Licensed under the Apache License, Version 2.0 (the "License");\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '       http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an "AS IS" BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', '// Token standard API\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract ERC20Events {\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Events{\n', '    function totalSupply() constant returns (uint supply);\n', '    function balanceOf( address who ) constant returns (uint value);\n', '    function allowance( address owner, address spender ) constant returns (uint _allowance);\n', '\n', '    function transfer( address to, uint value) returns (bool ok);\n', '    function transferFrom( address from, address to, uint value) returns (bool ok);\n', '    function approve( address spender, uint value ) returns (bool ok);\n', '\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'contract Math {\n', '    \n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        require(z == 0 || z >= (x > y ? x : y));\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', '        // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        require((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', 'contract Migrations {\n', '  address public owner;\n', '  uint public last_completed_migration;\n', '\n', '  modifier restricted() {\n', '    if (msg.sender == owner) _;\n', '  }\n', '\n', '  function Migrations() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function setCompleted(uint completed) restricted {\n', '    last_completed_migration = completed;\n', '  }\n', '\n', '  function upgrade(address new_address) restricted {\n', '    Migrations upgraded = Migrations(new_address);\n', '    upgraded.setCompleted(last_completed_migration);\n', '  }\n', '}\n', '/// note.sol -- the `note&#39; modifier, for logging calls as events\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Note {\n', '    event LogNote(\n', '        bytes4   indexed sig,\n', '        address  indexed guy,\n', '        bytes32  indexed foo,\n', '        bytes32  indexed bar,\n', '        uint wad,\n', '        bytes fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '        foo := calldataload(4)\n', '        bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '/// stop.sol -- mixin for enable/disable functionality\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Stoppable is Auth, Note {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() auth note {\n', '        stopped = true;\n', '    }\n', '    function start() auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}// token.sol -- ERC20 implementation with minting and burning\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Token is ERC20, Stoppable {\n', '\n', '    bytes32 public symbol;    \n', '    string public name; // Optional token name\n', '    uint256 public decimals = 18; // standard token precision. override to customize\n', '    TokenLogic public logic;\n', '\n', '    function Token(string name_, bytes32 symbol_) {\n', '        name = name_;\n', '        symbol = symbol_;\n', '    }\n', '\n', '    function setLogic(TokenLogic logic_) auth note returns(bool){\n', '        logic = logic_;\n', '        return true;\n', '    }\n', '\n', '    function setOwner(address owner_) auth {\n', '        uint wad = balanceOf(owner);\n', '        logic.transfer(owner, owner_, wad);\n', '        Transfer(owner, owner_, wad);\n', '        logic.setOwner(owner_);\n', '        super.setOwner(owner_);\n', '    }\n', '\n', '\n', '    function totalSupply() constant returns (uint256){\n', '        return logic.totalSupply();\n', '    }\n', '\n', '    function balanceOf( address who ) constant returns (uint value) {\n', '        return logic.balanceOf(who);\n', '    }\n', '\n', '    function allowance( address owner, address spender ) constant returns (uint _allowance) {\n', '        return logic.allowance(owner, spender);\n', '    }\n', '\n', '    function transfer(address dst, uint wad) stoppable note returns (bool) {\n', '        bool retVal = logic.transfer(msg.sender, dst, wad);\n', '        Transfer(msg.sender, dst, wad);\n', '        return retVal;\n', '    }\n', '    \n', '    function transferFrom(address src, address dst, uint wad) stoppable note returns (bool) {\n', '        bool retVal = logic.transferFrom(src, dst, wad);\n', '        Transfer(src, dst, wad);\n', '        return retVal;\n', '    }\n', '\n', '    function approve(address guy, uint wad) stoppable note returns (bool) {\n', '        return logic.approve(msg.sender, guy, wad);\n', '    }\n', '\n', '    function push(address dst, uint128 wad) returns (bool) {\n', '        return transfer(dst, wad);\n', '    }\n', '\n', '    function pull(address src, uint128 wad) returns (bool) {\n', '        return transferFrom(src, msg.sender, wad);\n', '    }\n', '\n', '    function mint(uint128 wad) auth stoppable note {\n', '        logic.mint(wad);\n', '        Transfer(this, msg.sender, wad);\n', '    }\n', '\n', '    function burn(uint128 wad) auth stoppable note {\n', '        logic.burn(msg.sender, wad);\n', '    }\n', '\n', '    function setName(string name_) auth {\n', '        name = name_;\n', '    }\n', '\n', '    function setSymbol(bytes32 symbol_) auth {\n', '        symbol = symbol_;\n', '    }\n', '\n', '    function () payable {\n', '        require(msg.value > 0);\n', '        uint wad = logic.handlePayment(msg.sender, msg.value);\n', '        Transfer(this, msg.sender, wad);\n', '    }\n', '\n', '/*special functions for ICO*/\n', '    function transferEth(address dst, uint wad) {\n', '        require(msg.sender == address(logic));\n', '        require(wad < this.balance);\n', '        dst.transfer(wad);\n', '    }\n', '\n', '/*this function is called from logic to trigger the correct event upon receiving ETH*/\n', '    function triggerTansferEvent(address src,  address dst, uint wad) {\n', '        require(msg.sender == address(logic));\n', '        Transfer(src, dst, wad);\n', '    }\n', '\n', '    function payout(address dst) auth {\n', '        require(dst != address(0));\n', '        dst.transfer(this.balance);\n', '    }\n', '\n', '}\n', '\n', 'contract TokenData is Auth {\n', '    uint256 public supply;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public approvals;\n', '    address token;\n', '\n', '    modifier tokenOnly {\n', '        assert(msg.sender == token);\n', '        _;\n', '    }\n', '\n', '    function TokenData(address token_, uint supply_, address owner_) {\n', '        token = token_;\n', '        supply = supply_;\n', '        owner = owner_;\n', '        balances[owner] = supply;\n', '    }\n', '\n', '    function setOwner(address owner_) tokenOnly {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setToken(address token_) auth {\n', '        token = token_;\n', '    }\n', '\n', '    function setSupply(uint supply_) tokenOnly {\n', '        supply = supply_;\n', '    }\n', '\n', '    function setBalances(address guy, uint balance) tokenOnly {\n', '        balances[guy] = balance;\n', '    }\n', '\n', '    function setApprovals(address src, address guy, uint wad) tokenOnly {\n', '        approvals[src][guy] = wad;\n', '    }\n', '\n', '}/// base.sol -- basic ERC20 implementation\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'contract TokenLogic is ERC20Events, Math, Stoppable {\n', '\n', '    TokenData public data;\n', '    Token public token;\n', '    uint public tokensPerWei=300;\n', '    uint public icoStart=1503756000; // = Aug 26 2017 2pm GMT\n', '    uint public icoEnd;   //1504188000 = Aug 31 2017 2pm GMT\n', '    uint public icoSale; //the number of tokens sold during the ICO\n', '    uint public maxIco = 90000000000000000000000000; // the maximum number of tokens sold during ICO\n', '\n', '    address[] contributors;\n', '\n', '    function TokenLogic(Token token_, TokenData data_, uint icoStart_, uint icoHours_) {\n', '        require(token_ != Token(0x0));\n', '\n', '        if(data_ == address(0x0)) {\n', '            data = new TokenData(this, 120000000000000000000000000, msg.sender);\n', '        } else {\n', '            data = data_;\n', '        }\n', '        token = token_;\n', '        icoStart = icoStart_;\n', '        icoEnd = icoStart + icoHours_ * 3600;\n', '    }\n', '\n', '    modifier tokenOnly {\n', '        assert(msg.sender == address(token) || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    function contributorCount() constant returns(uint) {\n', '        return contributors.length;\n', '    }\n', '\n', '    function setOwner(address owner_) tokenOnly {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '        data.setOwner(owner);\n', '    }\n', '\n', '    function setToken(Token token_) auth {\n', '        token = token_;\n', '    }\n', '\n', '    function setIcoStart(uint icoStart_, uint icoHours_) auth {\n', '        icoStart = icoStart_;\n', '        icoEnd = icoStart + icoHours_ * 3600;\n', '    }\n', '\n', '    function setTokensPerWei(uint tokensPerWei_) auth {\n', '        require(tokensPerWei_ > 0);\n', '        tokensPerWei = tokensPerWei_;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return data.supply();\n', '    }\n', '\n', '    function balanceOf(address src) constant returns (uint256) {\n', '        return data.balances(src);\n', '    }\n', '\n', '    function allowance(address src, address guy) constant returns (uint256) {\n', '        return data.approvals(src, guy);\n', '    }\n', '    \n', '    function transfer(address src, address dst, uint wad) tokenOnly returns (bool) {\n', '        require(balanceOf(src) >= wad);\n', '        \n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setBalances(dst, add(data.balances(dst), wad));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address src, address dst, uint wad) tokenOnly returns (bool) {\n', '        require(data.balances(src) >= wad);\n', '        require(data.approvals(src, dst) >= wad);\n', '        \n', '        data.setApprovals(src, dst, sub(data.approvals(src, dst), wad));\n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setBalances(dst, add(data.balances(dst), wad));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address src, address guy, uint256 wad) tokenOnly returns (bool) {\n', '\n', '        data.setApprovals(src, guy, wad);\n', '        \n', '        Approval(src, guy, wad);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function mint(uint128 wad) tokenOnly {\n', '        data.setBalances(data.owner(), add(data.balances(data.owner()), wad));\n', '        data.setSupply(add(data.supply(), wad));\n', '    }\n', '\n', '    function burn(address src, uint128 wad) tokenOnly {\n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setSupply(sub(data.supply(), wad));\n', '    }\n', '\n', '    function returnIcoInvestments(uint contributorIndex) auth {\n', '        /*this can only be done after the ICO close date and if less than 20mio tokens were sold*/\n', '        require(now > icoEnd && icoSale < 20000000000000000000000000);\n', '\n', '        address src = contributors[contributorIndex];\n', '        require(src != address(0));\n', '\n', '        uint srcBalance = balanceOf(src);\n', '\n', '        /*transfer the sent ETH amount minus a 5 finney (0.005 ETH ~ 1USD) tax to pay for Gas*/\n', '        token.transferEth(src, sub(div(srcBalance, tokensPerWei), 5 finney));\n', '\n', '        /*give back the tokens*/\n', '        data.setBalances(src, sub(data.balances(src), srcBalance));\n', '        data.setBalances(owner, add(data.balances(owner), srcBalance));\n', '        token.triggerTansferEvent(src, owner, srcBalance);\n', '\n', '        /*reset the address after the transfer to avoid errors*/\n', '        contributors[contributorIndex] = address(0);\n', '    }\n', '\n', '    function handlePayment(address src, uint eth) tokenOnly returns (uint){\n', '        require(eth > 0);\n', '        /*the time stamp has to be between the start and end times of the ICO*/\n', '        require(now >= icoStart && now <= icoEnd);\n', '        /*no more than 90 mio tokens shall be sold in the ICO*/\n', '        require(icoSale < maxIco);\n', '\n', '        uint tokenAmount = mul(tokensPerWei, eth);\n', '//first 10 hours\n', '        if(now < icoStart + (10 * 3600)) {\n', '            tokenAmount = tokenAmount * 125 / 100;\n', '        }\n', '//10 to 34 hours\n', '        else if(now < icoStart + (34 * 3600)) {\n', '            tokenAmount = tokenAmount * 115 / 100;\n', '        }\n', '//34 to 58 hours\n', '        else if(now < icoStart + (58 * 3600)) {\n', '            tokenAmount = tokenAmount * 105 / 100;\n', '        }\n', '\n', '        icoSale += tokenAmount;\n', '        if(icoSale > maxIco) {\n', '            uint excess = sub(icoSale, maxIco);\n', '            tokenAmount = sub(tokenAmount, excess);\n', '            token.transferEth(src, div(excess, tokensPerWei));\n', '            icoSale = maxIco;\n', '        }\n', '\n', '        require(balanceOf(owner) >= tokenAmount);\n', '\n', '        data.setBalances(owner, sub(data.balances(owner), tokenAmount));\n', '        data.setBalances(src, add(data.balances(src), tokenAmount));\n', '        contributors.push(src);\n', '\n', '        token.triggerTansferEvent(owner, src, tokenAmount);\n', '\n', '        return tokenAmount;\n', '    }\n', '}']
['/// auth.sol -- widely-used access control pattern for Ethereum\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'pragma solidity ^0.4.13;\n', '\n', 'contract Authority {\n', '    function canCall(address src, address dst, bytes4 sig) constant returns (bool);\n', '}\n', '\n', 'contract AuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '    event UnauthorizedAccess (address caller, bytes4 sig);\n', '}\n', '\n', 'contract Auth is AuthEvents {\n', '    Authority  public  authority;\n', '    address public owner;\n', '\n', '    function Auth() {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) auth {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(Authority authority_) auth {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner && authority == Authority(0)) {\n', '            /*the owner has privileges only as long as no Authority has been defined*/\n', '            return true;\n', '        } else if (authority == Authority(0)) {\n', '            UnauthorizedAccess(src, sig);\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '/*\n', '   Copyright 2017 DappHub, LLC\n', '\n', '   Licensed under the Apache License, Version 2.0 (the "License");\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '       http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an "AS IS" BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '*/\n', '\n', '// Token standard API\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract ERC20Events {\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Events{\n', '    function totalSupply() constant returns (uint supply);\n', '    function balanceOf( address who ) constant returns (uint value);\n', '    function allowance( address owner, address spender ) constant returns (uint _allowance);\n', '\n', '    function transfer( address to, uint value) returns (bool ok);\n', '    function transferFrom( address from, address to, uint value) returns (bool ok);\n', '    function approve( address spender, uint value ) returns (bool ok);\n', '\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'contract Math {\n', '    \n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        require(z == 0 || z >= (x > y ? x : y));\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        require((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', 'contract Migrations {\n', '  address public owner;\n', '  uint public last_completed_migration;\n', '\n', '  modifier restricted() {\n', '    if (msg.sender == owner) _;\n', '  }\n', '\n', '  function Migrations() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function setCompleted(uint completed) restricted {\n', '    last_completed_migration = completed;\n', '  }\n', '\n', '  function upgrade(address new_address) restricted {\n', '    Migrations upgraded = Migrations(new_address);\n', '    upgraded.setCompleted(last_completed_migration);\n', '  }\n', '}\n', "/// note.sol -- the `note' modifier, for logging calls as events\n", '\n', '// Copyright (C) 2017  DappHub, LLC\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Note {\n', '    event LogNote(\n', '        bytes4   indexed sig,\n', '        address  indexed guy,\n', '        bytes32  indexed foo,\n', '        bytes32  indexed bar,\n', '        uint wad,\n', '        bytes fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '        foo := calldataload(4)\n', '        bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '/// stop.sol -- mixin for enable/disable functionality\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Stoppable is Auth, Note {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() auth note {\n', '        stopped = true;\n', '    }\n', '    function start() auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}// token.sol -- ERC20 implementation with minting and burning\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', 'contract Token is ERC20, Stoppable {\n', '\n', '    bytes32 public symbol;    \n', '    string public name; // Optional token name\n', '    uint256 public decimals = 18; // standard token precision. override to customize\n', '    TokenLogic public logic;\n', '\n', '    function Token(string name_, bytes32 symbol_) {\n', '        name = name_;\n', '        symbol = symbol_;\n', '    }\n', '\n', '    function setLogic(TokenLogic logic_) auth note returns(bool){\n', '        logic = logic_;\n', '        return true;\n', '    }\n', '\n', '    function setOwner(address owner_) auth {\n', '        uint wad = balanceOf(owner);\n', '        logic.transfer(owner, owner_, wad);\n', '        Transfer(owner, owner_, wad);\n', '        logic.setOwner(owner_);\n', '        super.setOwner(owner_);\n', '    }\n', '\n', '\n', '    function totalSupply() constant returns (uint256){\n', '        return logic.totalSupply();\n', '    }\n', '\n', '    function balanceOf( address who ) constant returns (uint value) {\n', '        return logic.balanceOf(who);\n', '    }\n', '\n', '    function allowance( address owner, address spender ) constant returns (uint _allowance) {\n', '        return logic.allowance(owner, spender);\n', '    }\n', '\n', '    function transfer(address dst, uint wad) stoppable note returns (bool) {\n', '        bool retVal = logic.transfer(msg.sender, dst, wad);\n', '        Transfer(msg.sender, dst, wad);\n', '        return retVal;\n', '    }\n', '    \n', '    function transferFrom(address src, address dst, uint wad) stoppable note returns (bool) {\n', '        bool retVal = logic.transferFrom(src, dst, wad);\n', '        Transfer(src, dst, wad);\n', '        return retVal;\n', '    }\n', '\n', '    function approve(address guy, uint wad) stoppable note returns (bool) {\n', '        return logic.approve(msg.sender, guy, wad);\n', '    }\n', '\n', '    function push(address dst, uint128 wad) returns (bool) {\n', '        return transfer(dst, wad);\n', '    }\n', '\n', '    function pull(address src, uint128 wad) returns (bool) {\n', '        return transferFrom(src, msg.sender, wad);\n', '    }\n', '\n', '    function mint(uint128 wad) auth stoppable note {\n', '        logic.mint(wad);\n', '        Transfer(this, msg.sender, wad);\n', '    }\n', '\n', '    function burn(uint128 wad) auth stoppable note {\n', '        logic.burn(msg.sender, wad);\n', '    }\n', '\n', '    function setName(string name_) auth {\n', '        name = name_;\n', '    }\n', '\n', '    function setSymbol(bytes32 symbol_) auth {\n', '        symbol = symbol_;\n', '    }\n', '\n', '    function () payable {\n', '        require(msg.value > 0);\n', '        uint wad = logic.handlePayment(msg.sender, msg.value);\n', '        Transfer(this, msg.sender, wad);\n', '    }\n', '\n', '/*special functions for ICO*/\n', '    function transferEth(address dst, uint wad) {\n', '        require(msg.sender == address(logic));\n', '        require(wad < this.balance);\n', '        dst.transfer(wad);\n', '    }\n', '\n', '/*this function is called from logic to trigger the correct event upon receiving ETH*/\n', '    function triggerTansferEvent(address src,  address dst, uint wad) {\n', '        require(msg.sender == address(logic));\n', '        Transfer(src, dst, wad);\n', '    }\n', '\n', '    function payout(address dst) auth {\n', '        require(dst != address(0));\n', '        dst.transfer(this.balance);\n', '    }\n', '\n', '}\n', '\n', 'contract TokenData is Auth {\n', '    uint256 public supply;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public approvals;\n', '    address token;\n', '\n', '    modifier tokenOnly {\n', '        assert(msg.sender == token);\n', '        _;\n', '    }\n', '\n', '    function TokenData(address token_, uint supply_, address owner_) {\n', '        token = token_;\n', '        supply = supply_;\n', '        owner = owner_;\n', '        balances[owner] = supply;\n', '    }\n', '\n', '    function setOwner(address owner_) tokenOnly {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setToken(address token_) auth {\n', '        token = token_;\n', '    }\n', '\n', '    function setSupply(uint supply_) tokenOnly {\n', '        supply = supply_;\n', '    }\n', '\n', '    function setBalances(address guy, uint balance) tokenOnly {\n', '        balances[guy] = balance;\n', '    }\n', '\n', '    function setApprovals(address src, address guy, uint wad) tokenOnly {\n', '        approvals[src][guy] = wad;\n', '    }\n', '\n', '}/// base.sol -- basic ERC20 implementation\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', 'contract TokenLogic is ERC20Events, Math, Stoppable {\n', '\n', '    TokenData public data;\n', '    Token public token;\n', '    uint public tokensPerWei=300;\n', '    uint public icoStart=1503756000; // = Aug 26 2017 2pm GMT\n', '    uint public icoEnd;   //1504188000 = Aug 31 2017 2pm GMT\n', '    uint public icoSale; //the number of tokens sold during the ICO\n', '    uint public maxIco = 90000000000000000000000000; // the maximum number of tokens sold during ICO\n', '\n', '    address[] contributors;\n', '\n', '    function TokenLogic(Token token_, TokenData data_, uint icoStart_, uint icoHours_) {\n', '        require(token_ != Token(0x0));\n', '\n', '        if(data_ == address(0x0)) {\n', '            data = new TokenData(this, 120000000000000000000000000, msg.sender);\n', '        } else {\n', '            data = data_;\n', '        }\n', '        token = token_;\n', '        icoStart = icoStart_;\n', '        icoEnd = icoStart + icoHours_ * 3600;\n', '    }\n', '\n', '    modifier tokenOnly {\n', '        assert(msg.sender == address(token) || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    function contributorCount() constant returns(uint) {\n', '        return contributors.length;\n', '    }\n', '\n', '    function setOwner(address owner_) tokenOnly {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '        data.setOwner(owner);\n', '    }\n', '\n', '    function setToken(Token token_) auth {\n', '        token = token_;\n', '    }\n', '\n', '    function setIcoStart(uint icoStart_, uint icoHours_) auth {\n', '        icoStart = icoStart_;\n', '        icoEnd = icoStart + icoHours_ * 3600;\n', '    }\n', '\n', '    function setTokensPerWei(uint tokensPerWei_) auth {\n', '        require(tokensPerWei_ > 0);\n', '        tokensPerWei = tokensPerWei_;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return data.supply();\n', '    }\n', '\n', '    function balanceOf(address src) constant returns (uint256) {\n', '        return data.balances(src);\n', '    }\n', '\n', '    function allowance(address src, address guy) constant returns (uint256) {\n', '        return data.approvals(src, guy);\n', '    }\n', '    \n', '    function transfer(address src, address dst, uint wad) tokenOnly returns (bool) {\n', '        require(balanceOf(src) >= wad);\n', '        \n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setBalances(dst, add(data.balances(dst), wad));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address src, address dst, uint wad) tokenOnly returns (bool) {\n', '        require(data.balances(src) >= wad);\n', '        require(data.approvals(src, dst) >= wad);\n', '        \n', '        data.setApprovals(src, dst, sub(data.approvals(src, dst), wad));\n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setBalances(dst, add(data.balances(dst), wad));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address src, address guy, uint256 wad) tokenOnly returns (bool) {\n', '\n', '        data.setApprovals(src, guy, wad);\n', '        \n', '        Approval(src, guy, wad);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function mint(uint128 wad) tokenOnly {\n', '        data.setBalances(data.owner(), add(data.balances(data.owner()), wad));\n', '        data.setSupply(add(data.supply(), wad));\n', '    }\n', '\n', '    function burn(address src, uint128 wad) tokenOnly {\n', '        data.setBalances(src, sub(data.balances(src), wad));\n', '        data.setSupply(sub(data.supply(), wad));\n', '    }\n', '\n', '    function returnIcoInvestments(uint contributorIndex) auth {\n', '        /*this can only be done after the ICO close date and if less than 20mio tokens were sold*/\n', '        require(now > icoEnd && icoSale < 20000000000000000000000000);\n', '\n', '        address src = contributors[contributorIndex];\n', '        require(src != address(0));\n', '\n', '        uint srcBalance = balanceOf(src);\n', '\n', '        /*transfer the sent ETH amount minus a 5 finney (0.005 ETH ~ 1USD) tax to pay for Gas*/\n', '        token.transferEth(src, sub(div(srcBalance, tokensPerWei), 5 finney));\n', '\n', '        /*give back the tokens*/\n', '        data.setBalances(src, sub(data.balances(src), srcBalance));\n', '        data.setBalances(owner, add(data.balances(owner), srcBalance));\n', '        token.triggerTansferEvent(src, owner, srcBalance);\n', '\n', '        /*reset the address after the transfer to avoid errors*/\n', '        contributors[contributorIndex] = address(0);\n', '    }\n', '\n', '    function handlePayment(address src, uint eth) tokenOnly returns (uint){\n', '        require(eth > 0);\n', '        /*the time stamp has to be between the start and end times of the ICO*/\n', '        require(now >= icoStart && now <= icoEnd);\n', '        /*no more than 90 mio tokens shall be sold in the ICO*/\n', '        require(icoSale < maxIco);\n', '\n', '        uint tokenAmount = mul(tokensPerWei, eth);\n', '//first 10 hours\n', '        if(now < icoStart + (10 * 3600)) {\n', '            tokenAmount = tokenAmount * 125 / 100;\n', '        }\n', '//10 to 34 hours\n', '        else if(now < icoStart + (34 * 3600)) {\n', '            tokenAmount = tokenAmount * 115 / 100;\n', '        }\n', '//34 to 58 hours\n', '        else if(now < icoStart + (58 * 3600)) {\n', '            tokenAmount = tokenAmount * 105 / 100;\n', '        }\n', '\n', '        icoSale += tokenAmount;\n', '        if(icoSale > maxIco) {\n', '            uint excess = sub(icoSale, maxIco);\n', '            tokenAmount = sub(tokenAmount, excess);\n', '            token.transferEth(src, div(excess, tokensPerWei));\n', '            icoSale = maxIco;\n', '        }\n', '\n', '        require(balanceOf(owner) >= tokenAmount);\n', '\n', '        data.setBalances(owner, sub(data.balances(owner), tokenAmount));\n', '        data.setBalances(src, add(data.balances(src), tokenAmount));\n', '        contributors.push(src);\n', '\n', '        token.triggerTansferEvent(owner, src, tokenAmount);\n', '\n', '        return tokenAmount;\n', '    }\n', '}']
