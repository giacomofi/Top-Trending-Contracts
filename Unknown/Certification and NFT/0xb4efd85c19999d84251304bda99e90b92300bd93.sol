['pragma solidity ^0.4.11;\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    \n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract SalesAgentInterface {\n', '     /**** Properties ***********/\n', '    // Main contract token address\n', '    address tokenContractAddress;\n', '    // Contributions per address\n', '    mapping (address => uint256) public contributions;    \n', '    // Total ETH contributed     \n', '    uint256 public contributedTotal;                       \n', '    /// @dev Only allow access from the main token contract\n', '    modifier onlyTokenContract() {_;}\n', '    /*** Events ****************/\n', '    event Contribute(address _agent, address _sender, uint256 _value);\n', '    event FinaliseSale(address _agent, address _sender, uint256 _value);\n', '    event Refund(address _agent, address _sender, uint256 _value);\n', '    event ClaimTokens(address _agent, address _sender, uint256 _value);  \n', '    /*** Methods ****************/\n', '    /// @dev The address used for the depositAddress must checkin with the contract to verify it can interact with this contract, must happen or it won&#39;t accept funds\n', '    function getDepositAddressVerify() public;\n', '    /// @dev Get the contribution total of ETH from a contributor\n', '    /// @param _owner The owners address\n', '    function getContributionOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '/// @title The main Rocket Pool Token (RPL) contract\n', '/// @author David Rugendyke - http://www.rocketpool.net\n', '\n', '/*****************************************************************\n', '*   This is the main Rocket Pool Token (RPL) contract. It features\n', '*   Smart Agent compatibility. The Sale Agent is a new type of \n', '*   contract that can authorise the minting of tokens on behalf of\n', '*   the traditional ERC20 token contract. This allows you to \n', '*   distribute your ICO tokens through multiple Sale Agents, \n', '*   at various times, of various token quantities and of varying\n', '*   fund targets. Once you’ve written a new Sale Agent contract,\n', '*   you can register him with the main ERC20 token contract, \n', '*   he’s then permitted to sell it’s tokens on your behalf using\n', '*   guidelines such as the amount of tokens he’s allowed to sell, \n', '*   the maximum ether he’s allowed to raise, the start block and\n', '*   end blocks he’s allowed to sell between and more.\n', '/****************************************************************/\n', '\n', 'contract RocketPoolToken is StandardToken, Owned {\n', '\n', '     /**** Properties ***********/\n', '\n', '    string public name = "Rocket Pool";\n', '    string public symbol = "RPL";\n', '    string public version = "1.0";\n', '    // Set our token units\n', '    uint8 public constant decimals = 18;\n', '    uint256 public exponent = 10**uint256(decimals);\n', '    uint256 public totalSupply = 0;                             // The total of tokens currently minted by sales agent contracts    \n', '    uint256 public totalSupplyCap = 18 * (10**6) * exponent;    // 18 Million tokens\n', '\n', '\n', '    /**** Libs *****************/\n', '    \n', '    using SafeMath for uint;                           \n', '    \n', '    \n', '    /*** Sale Addresses *********/\n', '       \n', '    mapping (address => SalesAgent) private salesAgents;   // Our contract addresses of our sales contracts \n', '    address[] private salesAgentsAddresses;                // Keep an array of all our sales agent addresses for iteration\n', '\n', '    /*** Structs ***************/\n', '             \n', '    struct SalesAgent {                     // These are contract addresses that are authorised to mint tokens\n', '        address saleContractAddress;        // Address of the contract\n', '        bytes32 saleContractType;           // Type of the contract ie. presale, crowdsale \n', '        uint256 targetEthMax;               // The max amount of ether the agent is allowed raise\n', '        uint256 targetEthMin;               // The min amount of ether to raise to consider this contracts sales a success\n', '        uint256 tokensLimit;                // The maximum amount of tokens this sale contract is allowed to distribute\n', '        uint256 tokensMinted;               // The current amount of tokens minted by this agent\n', '        uint256 minDeposit;                 // The minimum deposit amount allowed\n', '        uint256 maxDeposit;                 // The maximum deposit amount allowed\n', '        uint256 startBlock;                 // The start block when allowed to mint tokens\n', '        uint256 endBlock;                   // The end block when to finish minting tokens\n', '        address depositAddress;             // The address that receives the ether for that sale contract\n', '        bool depositAddressCheckedIn;       // The address that receives the ether for that sale contract must check in with its sale contract to verify its a valid address that can interact\n', '        bool finalised;                     // Has this sales contract been completed and the ether sent to the deposit address?\n', '        bool exists;                        // Check to see if the mapping exists\n', '    }\n', '\n', '    /*** Events ****************/\n', '\n', '    event MintToken(address _agent, address _address, uint256 _value);\n', '    event SaleFinalised(address _agent, address _address, uint256 _value);\n', '  \n', '    /*** Tests *****************/\n', '\n', '    event FlagUint(uint256 flag);\n', '    event FlagAddress(address flag);\n', '\n', '    \n', '    /*** Modifiers *************/\n', '\n', '    /// @dev Only allow access from the latest version of a sales contract\n', '    modifier isSalesContract(address _sender) {\n', '        // Is this an authorised sale contract?\n', '        assert(salesAgents[_sender].exists == true);\n', '        _;\n', '    }\n', '\n', '    \n', '    /**** Methods ***********/\n', '\n', '    /// @dev RPL Token Init\n', '    function RocketPoolToken() {}\n', '\n', '\n', '    // @dev General validation for a sales agent contract receiving a contribution, additional validation can be done in the sale contract if required\n', '    // @param _value The value of the contribution in wei\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function validateContribution(uint256 _value) isSalesContract(msg.sender) returns (bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Did they send anything from a proper address?\n', '        assert(_value > 0);  \n', '        // Check the depositAddress has been verified by the account holder\n', '        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\n', '        // Check if we&#39;re ok to receive contributions, have we started?\n', '        assert(block.number > salesAgents[msg.sender].startBlock);       \n', '        // Already ended? Or if the end block is 0, it&#39;s an open ended sale until finalised by the depositAddress\n', '        assert(block.number < salesAgents[msg.sender].endBlock || salesAgents[msg.sender].endBlock == 0); \n', '        // Is it above the min deposit amount?\n', '        assert(_value >= salesAgents[msg.sender].minDeposit); \n', '        // Is it below the max deposit allowed?\n', '        assert(_value <= salesAgents[msg.sender].maxDeposit); \n', '        // No contributions if the sale contract has finalised\n', '        assert(salesAgents[msg.sender].finalised == false);      \n', '        // Does this deposit put it over the max target ether for the sale contract?\n', '        assert(saleAgent.contributedTotal().add(_value) <= salesAgents[msg.sender].targetEthMax);       \n', '        // All good\n', '        return true;\n', '    }\n', '\n', '\n', '    // @dev General validation for a sales agent contract that requires the user claim the tokens after the sale has finished\n', '    // @param _sender The address sent the request\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function validateClaimTokens(address _sender) isSalesContract(msg.sender) returns (bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Must have previously contributed\n', '        assert(saleAgent.getContributionOf(_sender) > 0); \n', '        // Sale contract completed\n', '        assert(block.number > salesAgents[msg.sender].endBlock);  \n', '        // All good\n', '        return true;\n', '    }\n', '    \n', '\n', '    // @dev Mint the Rocket Pool Tokens (RPL)\n', '    // @param _to The address that will receive the minted tokens.\n', '    // @param _amount The amount of tokens to mint.\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function mint(address _to, uint _amount) isSalesContract(msg.sender) returns (bool) {\n', '        // Check if we&#39;re ok to mint new tokens, have we started?\n', '        // We dont check for the end block as some sale agents mint tokens during the sale, and some after its finished (proportional sales)\n', '        assert(block.number > salesAgents[msg.sender].startBlock);   \n', '        // Check the depositAddress has been verified by the designated account holder that will receive the funds from that agent\n', '        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\n', '        // No minting if the sale contract has finalised\n', '        assert(salesAgents[msg.sender].finalised == false);\n', '        // Check we don&#39;t exceed the assigned tokens of the sale agent\n', '        assert(salesAgents[msg.sender].tokensLimit >= salesAgents[msg.sender].tokensMinted.add(_amount));\n', '        // Verify ok balances and values\n', '        assert(_amount > 0);\n', '         // Check we don&#39;t exceed the supply limit\n', '        assert(totalSupply.add(_amount) <= totalSupplyCap);\n', '         // Ok all good, automatically checks for overflow with safeMath\n', '        balances[_to] = balances[_to].add(_amount);\n', '        // Add to the total minted for that agent, automatically checks for overflow with safeMath\n', '        salesAgents[msg.sender].tokensMinted = salesAgents[msg.sender].tokensMinted.add(_amount);\n', '        // Add to the overall total minted, automatically checks for overflow with safeMath\n', '        totalSupply = totalSupply.add(_amount);\n', '        // Fire the event\n', '        MintToken(msg.sender, _to, _amount);\n', '        // Fire the transfer event\n', '        Transfer(0x0, _to, _amount); \n', '        // Completed\n', '        return true; \n', '    }\n', '\n', '    /// @dev Returns the amount of tokens that can still be minted\n', '    function getRemainingTokens() public constant returns(uint256) {\n', '        return totalSupplyCap.sub(totalSupply);\n', '    }\n', '    \n', '    /// @dev Set the address of a new crowdsale/presale contract agent if needed, usefull for upgrading\n', '    /// @param _saleAddress The address of the new token sale contract\n', '    /// @param _saleContractType Type of the contract ie. presale, crowdsale, quarterly\n', '    /// @param _targetEthMin The min amount of ether to raise to consider this contracts sales a success\n', '    /// @param _targetEthMax The max amount of ether the agent is allowed raise\n', '    /// @param _tokensLimit The maximum amount of tokens this sale contract is allowed to distribute\n', '    /// @param _minDeposit The minimum deposit amount allowed\n', '    /// @param _maxDeposit The maximum deposit amount allowed\n', '    /// @param _startBlock The start block when allowed to mint tokens\n', '    /// @param _endBlock The end block when to finish minting tokens\n', '    /// @param _depositAddress The address that receives the ether for that sale contract\n', '    function setSaleAgentContract(\n', '        address _saleAddress, \n', '         string _saleContractType, \n', '        uint256 _targetEthMin, \n', '        uint256 _targetEthMax, \n', '        uint256 _tokensLimit, \n', '        uint256 _minDeposit,\n', '        uint256 _maxDeposit,\n', '        uint256 _startBlock, \n', '        uint256 _endBlock, \n', '        address _depositAddress\n', '    ) \n', '    // Only the owner can register a new sale agent\n', '    public onlyOwner  \n', '    {\n', '        // Valid addresses?\n', '        assert(_saleAddress != 0x0 && _depositAddress != 0x0);  \n', '        // Must have some available tokens\n', '        assert(_tokensLimit > 0 && _tokensLimit <= totalSupplyCap);\n', '        // Make sure the min deposit is less than or equal to the max\n', '        assert(_minDeposit <= _maxDeposit);\n', '        // Add the new sales contract\n', '        salesAgents[_saleAddress] = SalesAgent({\n', '            saleContractAddress: _saleAddress,\n', '            saleContractType: sha3(_saleContractType),\n', '            targetEthMin: _targetEthMin,\n', '            targetEthMax: _targetEthMax,\n', '            tokensLimit: _tokensLimit,\n', '            tokensMinted: 0,\n', '            minDeposit: _minDeposit,\n', '            maxDeposit: _maxDeposit,\n', '            startBlock: _startBlock,\n', '            endBlock: _endBlock,\n', '            depositAddress: _depositAddress,\n', '            depositAddressCheckedIn: false,\n', '            finalised: false,\n', '            exists: true                      \n', '        });\n', '        // Store our agent address so we can iterate over it if needed\n', '        salesAgentsAddresses.push(_saleAddress);\n', '    }\n', '\n', '\n', '    /// @dev Sets the contract sale agent process as completed, that sales agent is now retired\n', '    function setSaleContractFinalised(address _sender) isSalesContract(msg.sender) public returns(bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Finalise the crowdsale funds\n', '        assert(!salesAgents[msg.sender].finalised);                       \n', '        // The address that will receive this contracts deposit, should match the original senders\n', '        assert(salesAgents[msg.sender].depositAddress == _sender);            \n', '        // If the end block is 0, it means an open ended crowdsale, once it&#39;s finalised, the end block is set to the current one\n', '        if (salesAgents[msg.sender].endBlock == 0) {\n', '            salesAgents[msg.sender].endBlock = block.number;\n', '        }\n', '        // Not yet finished?\n', '        assert(block.number >= salesAgents[msg.sender].endBlock);         \n', '        // Not enough raised?\n', '        assert(saleAgent.contributedTotal() >= salesAgents[msg.sender].targetEthMin);\n', '        // We&#39;re done now\n', '        salesAgents[msg.sender].finalised = true;\n', '        // Fire the event\n', '        SaleFinalised(msg.sender, _sender, salesAgents[msg.sender].tokensMinted);\n', '        // All good\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Verifies if the current address matches the depositAddress\n', '    /// @param _verifyAddress The address to verify it matches the depositAddress given for the sales agent\n', '    function setSaleContractDepositAddressVerified(address _verifyAddress) isSalesContract(msg.sender) public {\n', '        // Check its verified\n', '        assert(salesAgents[msg.sender].depositAddress == _verifyAddress && _verifyAddress != 0x0);\n', '        // Ok set it now\n', '        salesAgents[msg.sender].depositAddressCheckedIn = true;\n', '    }\n', '\n', '    /// @dev Returns true if this sales contract has finalised\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractIsFinalised(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\n', '        return salesAgents[_salesAgentAddress].finalised;\n', '    }\n', '\n', '    /// @dev Returns the min target amount of ether the contract wants to raise\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTargetEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].targetEthMin;\n', '    }\n', '\n', '    /// @dev Returns the max target amount of ether the contract can raise\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTargetEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].targetEthMax;\n', '    }\n', '\n', '    /// @dev Returns the min deposit amount of ether\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].minDeposit;\n', '    }\n', '\n', '    /// @dev Returns the max deposit amount of ether\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].maxDeposit;\n', '    }\n', '\n', '    /// @dev Returns the address where the sale contracts ether will be deposited\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositAddress(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(address) {\n', '        return salesAgents[_salesAgentAddress].depositAddress;\n', '    }\n', '\n', '    /// @dev Returns the true if the sale agents deposit address has been verified\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositAddressVerified(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\n', '        return salesAgents[_salesAgentAddress].depositAddressCheckedIn;\n', '    }\n', '\n', '    /// @dev Returns the start block for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractStartBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].startBlock;\n', '    }\n', '\n', '    /// @dev Returns the start block for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractEndBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].endBlock;\n', '    }\n', '\n', '    /// @dev Returns the max tokens for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTokensLimit(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].tokensLimit;\n', '    }\n', '\n', '    /// @dev Returns the token total currently minted by the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTokensMinted(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].tokensMinted;\n', '    }\n', '\n', '    \n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    \n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract SalesAgentInterface {\n', '     /**** Properties ***********/\n', '    // Main contract token address\n', '    address tokenContractAddress;\n', '    // Contributions per address\n', '    mapping (address => uint256) public contributions;    \n', '    // Total ETH contributed     \n', '    uint256 public contributedTotal;                       \n', '    /// @dev Only allow access from the main token contract\n', '    modifier onlyTokenContract() {_;}\n', '    /*** Events ****************/\n', '    event Contribute(address _agent, address _sender, uint256 _value);\n', '    event FinaliseSale(address _agent, address _sender, uint256 _value);\n', '    event Refund(address _agent, address _sender, uint256 _value);\n', '    event ClaimTokens(address _agent, address _sender, uint256 _value);  \n', '    /*** Methods ****************/\n', "    /// @dev The address used for the depositAddress must checkin with the contract to verify it can interact with this contract, must happen or it won't accept funds\n", '    function getDepositAddressVerify() public;\n', '    /// @dev Get the contribution total of ETH from a contributor\n', '    /// @param _owner The owners address\n', '    function getContributionOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '/// @title The main Rocket Pool Token (RPL) contract\n', '/// @author David Rugendyke - http://www.rocketpool.net\n', '\n', '/*****************************************************************\n', '*   This is the main Rocket Pool Token (RPL) contract. It features\n', '*   Smart Agent compatibility. The Sale Agent is a new type of \n', '*   contract that can authorise the minting of tokens on behalf of\n', '*   the traditional ERC20 token contract. This allows you to \n', '*   distribute your ICO tokens through multiple Sale Agents, \n', '*   at various times, of various token quantities and of varying\n', '*   fund targets. Once you’ve written a new Sale Agent contract,\n', '*   you can register him with the main ERC20 token contract, \n', '*   he’s then permitted to sell it’s tokens on your behalf using\n', '*   guidelines such as the amount of tokens he’s allowed to sell, \n', '*   the maximum ether he’s allowed to raise, the start block and\n', '*   end blocks he’s allowed to sell between and more.\n', '/****************************************************************/\n', '\n', 'contract RocketPoolToken is StandardToken, Owned {\n', '\n', '     /**** Properties ***********/\n', '\n', '    string public name = "Rocket Pool";\n', '    string public symbol = "RPL";\n', '    string public version = "1.0";\n', '    // Set our token units\n', '    uint8 public constant decimals = 18;\n', '    uint256 public exponent = 10**uint256(decimals);\n', '    uint256 public totalSupply = 0;                             // The total of tokens currently minted by sales agent contracts    \n', '    uint256 public totalSupplyCap = 18 * (10**6) * exponent;    // 18 Million tokens\n', '\n', '\n', '    /**** Libs *****************/\n', '    \n', '    using SafeMath for uint;                           \n', '    \n', '    \n', '    /*** Sale Addresses *********/\n', '       \n', '    mapping (address => SalesAgent) private salesAgents;   // Our contract addresses of our sales contracts \n', '    address[] private salesAgentsAddresses;                // Keep an array of all our sales agent addresses for iteration\n', '\n', '    /*** Structs ***************/\n', '             \n', '    struct SalesAgent {                     // These are contract addresses that are authorised to mint tokens\n', '        address saleContractAddress;        // Address of the contract\n', '        bytes32 saleContractType;           // Type of the contract ie. presale, crowdsale \n', '        uint256 targetEthMax;               // The max amount of ether the agent is allowed raise\n', '        uint256 targetEthMin;               // The min amount of ether to raise to consider this contracts sales a success\n', '        uint256 tokensLimit;                // The maximum amount of tokens this sale contract is allowed to distribute\n', '        uint256 tokensMinted;               // The current amount of tokens minted by this agent\n', '        uint256 minDeposit;                 // The minimum deposit amount allowed\n', '        uint256 maxDeposit;                 // The maximum deposit amount allowed\n', '        uint256 startBlock;                 // The start block when allowed to mint tokens\n', '        uint256 endBlock;                   // The end block when to finish minting tokens\n', '        address depositAddress;             // The address that receives the ether for that sale contract\n', '        bool depositAddressCheckedIn;       // The address that receives the ether for that sale contract must check in with its sale contract to verify its a valid address that can interact\n', '        bool finalised;                     // Has this sales contract been completed and the ether sent to the deposit address?\n', '        bool exists;                        // Check to see if the mapping exists\n', '    }\n', '\n', '    /*** Events ****************/\n', '\n', '    event MintToken(address _agent, address _address, uint256 _value);\n', '    event SaleFinalised(address _agent, address _address, uint256 _value);\n', '  \n', '    /*** Tests *****************/\n', '\n', '    event FlagUint(uint256 flag);\n', '    event FlagAddress(address flag);\n', '\n', '    \n', '    /*** Modifiers *************/\n', '\n', '    /// @dev Only allow access from the latest version of a sales contract\n', '    modifier isSalesContract(address _sender) {\n', '        // Is this an authorised sale contract?\n', '        assert(salesAgents[_sender].exists == true);\n', '        _;\n', '    }\n', '\n', '    \n', '    /**** Methods ***********/\n', '\n', '    /// @dev RPL Token Init\n', '    function RocketPoolToken() {}\n', '\n', '\n', '    // @dev General validation for a sales agent contract receiving a contribution, additional validation can be done in the sale contract if required\n', '    // @param _value The value of the contribution in wei\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function validateContribution(uint256 _value) isSalesContract(msg.sender) returns (bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Did they send anything from a proper address?\n', '        assert(_value > 0);  \n', '        // Check the depositAddress has been verified by the account holder\n', '        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\n', "        // Check if we're ok to receive contributions, have we started?\n", '        assert(block.number > salesAgents[msg.sender].startBlock);       \n', "        // Already ended? Or if the end block is 0, it's an open ended sale until finalised by the depositAddress\n", '        assert(block.number < salesAgents[msg.sender].endBlock || salesAgents[msg.sender].endBlock == 0); \n', '        // Is it above the min deposit amount?\n', '        assert(_value >= salesAgents[msg.sender].minDeposit); \n', '        // Is it below the max deposit allowed?\n', '        assert(_value <= salesAgents[msg.sender].maxDeposit); \n', '        // No contributions if the sale contract has finalised\n', '        assert(salesAgents[msg.sender].finalised == false);      \n', '        // Does this deposit put it over the max target ether for the sale contract?\n', '        assert(saleAgent.contributedTotal().add(_value) <= salesAgents[msg.sender].targetEthMax);       \n', '        // All good\n', '        return true;\n', '    }\n', '\n', '\n', '    // @dev General validation for a sales agent contract that requires the user claim the tokens after the sale has finished\n', '    // @param _sender The address sent the request\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function validateClaimTokens(address _sender) isSalesContract(msg.sender) returns (bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Must have previously contributed\n', '        assert(saleAgent.getContributionOf(_sender) > 0); \n', '        // Sale contract completed\n', '        assert(block.number > salesAgents[msg.sender].endBlock);  \n', '        // All good\n', '        return true;\n', '    }\n', '    \n', '\n', '    // @dev Mint the Rocket Pool Tokens (RPL)\n', '    // @param _to The address that will receive the minted tokens.\n', '    // @param _amount The amount of tokens to mint.\n', '    // @return A boolean that indicates if the operation was successful.\n', '    function mint(address _to, uint _amount) isSalesContract(msg.sender) returns (bool) {\n', "        // Check if we're ok to mint new tokens, have we started?\n", '        // We dont check for the end block as some sale agents mint tokens during the sale, and some after its finished (proportional sales)\n', '        assert(block.number > salesAgents[msg.sender].startBlock);   \n', '        // Check the depositAddress has been verified by the designated account holder that will receive the funds from that agent\n', '        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\n', '        // No minting if the sale contract has finalised\n', '        assert(salesAgents[msg.sender].finalised == false);\n', "        // Check we don't exceed the assigned tokens of the sale agent\n", '        assert(salesAgents[msg.sender].tokensLimit >= salesAgents[msg.sender].tokensMinted.add(_amount));\n', '        // Verify ok balances and values\n', '        assert(_amount > 0);\n', "         // Check we don't exceed the supply limit\n", '        assert(totalSupply.add(_amount) <= totalSupplyCap);\n', '         // Ok all good, automatically checks for overflow with safeMath\n', '        balances[_to] = balances[_to].add(_amount);\n', '        // Add to the total minted for that agent, automatically checks for overflow with safeMath\n', '        salesAgents[msg.sender].tokensMinted = salesAgents[msg.sender].tokensMinted.add(_amount);\n', '        // Add to the overall total minted, automatically checks for overflow with safeMath\n', '        totalSupply = totalSupply.add(_amount);\n', '        // Fire the event\n', '        MintToken(msg.sender, _to, _amount);\n', '        // Fire the transfer event\n', '        Transfer(0x0, _to, _amount); \n', '        // Completed\n', '        return true; \n', '    }\n', '\n', '    /// @dev Returns the amount of tokens that can still be minted\n', '    function getRemainingTokens() public constant returns(uint256) {\n', '        return totalSupplyCap.sub(totalSupply);\n', '    }\n', '    \n', '    /// @dev Set the address of a new crowdsale/presale contract agent if needed, usefull for upgrading\n', '    /// @param _saleAddress The address of the new token sale contract\n', '    /// @param _saleContractType Type of the contract ie. presale, crowdsale, quarterly\n', '    /// @param _targetEthMin The min amount of ether to raise to consider this contracts sales a success\n', '    /// @param _targetEthMax The max amount of ether the agent is allowed raise\n', '    /// @param _tokensLimit The maximum amount of tokens this sale contract is allowed to distribute\n', '    /// @param _minDeposit The minimum deposit amount allowed\n', '    /// @param _maxDeposit The maximum deposit amount allowed\n', '    /// @param _startBlock The start block when allowed to mint tokens\n', '    /// @param _endBlock The end block when to finish minting tokens\n', '    /// @param _depositAddress The address that receives the ether for that sale contract\n', '    function setSaleAgentContract(\n', '        address _saleAddress, \n', '         string _saleContractType, \n', '        uint256 _targetEthMin, \n', '        uint256 _targetEthMax, \n', '        uint256 _tokensLimit, \n', '        uint256 _minDeposit,\n', '        uint256 _maxDeposit,\n', '        uint256 _startBlock, \n', '        uint256 _endBlock, \n', '        address _depositAddress\n', '    ) \n', '    // Only the owner can register a new sale agent\n', '    public onlyOwner  \n', '    {\n', '        // Valid addresses?\n', '        assert(_saleAddress != 0x0 && _depositAddress != 0x0);  \n', '        // Must have some available tokens\n', '        assert(_tokensLimit > 0 && _tokensLimit <= totalSupplyCap);\n', '        // Make sure the min deposit is less than or equal to the max\n', '        assert(_minDeposit <= _maxDeposit);\n', '        // Add the new sales contract\n', '        salesAgents[_saleAddress] = SalesAgent({\n', '            saleContractAddress: _saleAddress,\n', '            saleContractType: sha3(_saleContractType),\n', '            targetEthMin: _targetEthMin,\n', '            targetEthMax: _targetEthMax,\n', '            tokensLimit: _tokensLimit,\n', '            tokensMinted: 0,\n', '            minDeposit: _minDeposit,\n', '            maxDeposit: _maxDeposit,\n', '            startBlock: _startBlock,\n', '            endBlock: _endBlock,\n', '            depositAddress: _depositAddress,\n', '            depositAddressCheckedIn: false,\n', '            finalised: false,\n', '            exists: true                      \n', '        });\n', '        // Store our agent address so we can iterate over it if needed\n', '        salesAgentsAddresses.push(_saleAddress);\n', '    }\n', '\n', '\n', '    /// @dev Sets the contract sale agent process as completed, that sales agent is now retired\n', '    function setSaleContractFinalised(address _sender) isSalesContract(msg.sender) public returns(bool) {\n', '        // Get an instance of the sale agent contract\n', '        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\n', '        // Finalise the crowdsale funds\n', '        assert(!salesAgents[msg.sender].finalised);                       \n', '        // The address that will receive this contracts deposit, should match the original senders\n', '        assert(salesAgents[msg.sender].depositAddress == _sender);            \n', "        // If the end block is 0, it means an open ended crowdsale, once it's finalised, the end block is set to the current one\n", '        if (salesAgents[msg.sender].endBlock == 0) {\n', '            salesAgents[msg.sender].endBlock = block.number;\n', '        }\n', '        // Not yet finished?\n', '        assert(block.number >= salesAgents[msg.sender].endBlock);         \n', '        // Not enough raised?\n', '        assert(saleAgent.contributedTotal() >= salesAgents[msg.sender].targetEthMin);\n', "        // We're done now\n", '        salesAgents[msg.sender].finalised = true;\n', '        // Fire the event\n', '        SaleFinalised(msg.sender, _sender, salesAgents[msg.sender].tokensMinted);\n', '        // All good\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Verifies if the current address matches the depositAddress\n', '    /// @param _verifyAddress The address to verify it matches the depositAddress given for the sales agent\n', '    function setSaleContractDepositAddressVerified(address _verifyAddress) isSalesContract(msg.sender) public {\n', '        // Check its verified\n', '        assert(salesAgents[msg.sender].depositAddress == _verifyAddress && _verifyAddress != 0x0);\n', '        // Ok set it now\n', '        salesAgents[msg.sender].depositAddressCheckedIn = true;\n', '    }\n', '\n', '    /// @dev Returns true if this sales contract has finalised\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractIsFinalised(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\n', '        return salesAgents[_salesAgentAddress].finalised;\n', '    }\n', '\n', '    /// @dev Returns the min target amount of ether the contract wants to raise\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTargetEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].targetEthMin;\n', '    }\n', '\n', '    /// @dev Returns the max target amount of ether the contract can raise\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTargetEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].targetEthMax;\n', '    }\n', '\n', '    /// @dev Returns the min deposit amount of ether\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].minDeposit;\n', '    }\n', '\n', '    /// @dev Returns the max deposit amount of ether\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].maxDeposit;\n', '    }\n', '\n', '    /// @dev Returns the address where the sale contracts ether will be deposited\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositAddress(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(address) {\n', '        return salesAgents[_salesAgentAddress].depositAddress;\n', '    }\n', '\n', '    /// @dev Returns the true if the sale agents deposit address has been verified\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractDepositAddressVerified(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\n', '        return salesAgents[_salesAgentAddress].depositAddressCheckedIn;\n', '    }\n', '\n', '    /// @dev Returns the start block for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractStartBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].startBlock;\n', '    }\n', '\n', '    /// @dev Returns the start block for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractEndBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].endBlock;\n', '    }\n', '\n', '    /// @dev Returns the max tokens for the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTokensLimit(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].tokensLimit;\n', '    }\n', '\n', '    /// @dev Returns the token total currently minted by the sale agent\n', '    /// @param _salesAgentAddress The address of the token sale agent contract\n', '    function getSaleContractTokensMinted(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\n', '        return salesAgents[_salesAgentAddress].tokensMinted;\n', '    }\n', '\n', '    \n', '}']
