['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value);\n', '  function approve(address spender, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint256 size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/** \n', ' * @title Contracts that should not own Tokens\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This blocks incoming ERC23 tokens to prevent accidental loss of tokens.\n', ' * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\n', ' * owner to reclaim the tokens.\n', ' */\n', 'contract HasNoTokens is Ownable {\n', '\n', ' /** \n', '  * @dev Reject all ERC23 compatible tokens\n', '  * @param from_ address The address that is transferring the tokens\n', '  * @param value_ uint256 the amount of the specified token\n', '  * @param data_ Bytes The data passed from the caller.\n', '  */\n', '  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n', '    throw;\n', '  }\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param tokenAddr address The address of the token contract\n', '   */\n', '  function reclaimToken(address tokenAddr) external onlyOwner {\n', '    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\n', '    uint256 balance = tokenInst.balanceOf(this);\n', '    tokenInst.transfer(owner, balance);\n', '  }\n', '}\n', '\n', '/** \n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '/**\n', ' * MRV token, distributed by crowdsale. Token and crowdsale functionality are unified in a single\n', ' * contract, to make clear and restrict the conditions under which tokens can be created or destroyed.\n', ' * Derived from OpenZeppelin CrowdsaleToken template.\n', ' *\n', ' * Key Crowdsale Facts:\n', ' * \n', ' * * MRV tokens will be sold at a rate of 5,000 per ETH.\n', ' *\n', ' * * All MRV token sales are final. No refunds can be issued by the contract.\n', ' *\n', ' * * Unless adjusted later by the crowdsale operator, up to 100 million tokens will be available.\n', ' *\n', ' * * An additional 5,000 tokens are reserved. \n', ' *\n', ' * * Participate in the crowdsale by sending ETH to this contract, when the crowdsale is open.\n', ' *\n', ' * * Sending more ETH than required to purchase all the remaining tokens will fail.\n', ' *\n', ' * * Timers can be set to allow anyone to open/close the crowdsale at the proper time. The crowdsale\n', ' *   operator reserves the right to set, unset, and reset these timers at any time, for any reason,\n', ' *   and without notice.\n', ' *\n', ' * * The operator of the crowdsale has the ability to manually open it and close it, and reserves\n', ' *   the right to do so at any time, for any reason, and without notice.\n', ' *\n', ' * * The crowdsale cannot be reopened, and no tokens can be created, after the crowdsale closes.\n', ' *\n', ' * * The crowdsale operator reserves the right to adjust the decimal places of the MRV token at\n', ' *   any time after the crowdsale closes, for any reason, and without notice. MRV tokens are\n', ' *   initially divisible to 18 decimal places.\n', ' *\n', ' * * The crowdsale operator reserves the right to not open or close the crowdsale, not set the\n', ' *   open or close timer, and generally refrain from doing things that the contract would otherwise\n', ' *   authorize them to do.\n', ' *\n', ' * * The crowdsale operator reserves the right to claim and keep any ETH or tokens that end up in\n', " *   the contract's account. During normal crowdsale operation, ETH is not stored in the contract's\n", ' *   account, and is instead sent directly to the beneficiary.\n', ' */\n', 'contract MRVToken is StandardToken, Ownable, HasNoTokens, HasNoContracts {\n', '\n', '    // Token Parameters\n', '\n', '    // From StandardToken we inherit balances and totalSupply.\n', '    \n', '    // What is the full name of the token?\n', '    string public constant name = "Macroverse Token";\n', '    // What is its suggested symbol?\n', '    string public constant symbol = "MRV";\n', '    // How many of the low base-10 digits are to the right of the decimal point?\n', '    // Note that this is not constant! After the crowdsale, the contract owner can\n', '    // adjust the decimal places, allowing for 10-to-1 splits and merges.\n', '    uint8 public decimals;\n', '    \n', '    // Crowdsale Parameters\n', '    \n', '    // Where will funds collected during the crowdsale be sent?\n', '    address beneficiary;\n', '    // How many MRV can be sold in the crowdsale?\n', '    uint public maxCrowdsaleSupplyInWholeTokens;\n', '    // How many whole tokens are reserved for the beneficiary?\n', '    uint public constant wholeTokensReserved = 5000;\n', '    // How many tokens per ETH during the crowdsale?\n', '    uint public constant wholeTokensPerEth = 5000;\n', '    \n', '    // Set to true when the crowdsale starts\n', '    // Internal flag. Use isCrowdsaleActive instead().\n', '    bool crowdsaleStarted;\n', '    // Set to true when the crowdsale ends\n', '    // Internal flag. Use isCrowdsaleActive instead().\n', '    bool crowdsaleEnded;\n', '    // We can also set some timers to open and close the crowdsale. 0 = timer is not set.\n', '    // After this time, the crowdsale will open with a call to checkOpenTimer().\n', '    uint public openTimer = 0;\n', '    // After this time, no contributions will be accepted, and the crowdsale will close with a call to checkCloseTimer().\n', '    uint public closeTimer = 0;\n', '    \n', '    ////////////\n', '    // Constructor\n', '    ////////////\n', '    \n', '    /**\n', '    * Deploy a new MRVToken contract, paying crowdsale proceeds to the given address,\n', '    * and awarding reserved tokens to the other given address.\n', '    */\n', '    function MRVToken(address sendProceedsTo, address sendTokensTo) {\n', '        // Proceeds of the crowdsale go here.\n', '        beneficiary = sendProceedsTo;\n', '        \n', '        // Start with 18 decimals, same as ETH\n', '        decimals = 18;\n', '        \n', '        // Initially, the reserved tokens belong to the given address.\n', '        totalSupply = wholeTokensReserved * 10 ** 18;\n', '        balances[sendTokensTo] = totalSupply;\n', '        \n', '        // Initially the crowdsale has not yet started or ended.\n', '        crowdsaleStarted = false;\n', '        crowdsaleEnded = false;\n', '        // Default to a max supply of 100 million tokens available.\n', '        maxCrowdsaleSupplyInWholeTokens = 100000000;\n', '    }\n', '    \n', '    ////////////\n', '    // Fallback function\n', '    ////////////\n', '    \n', '    /**\n', '    * This is the MAIN CROWDSALE ENTRY POINT. You participate in the crowdsale by \n', '    * sending ETH to this contract. That calls this function, which credits tokens\n', '    * to the address or contract that sent the ETH.\n', '    *\n', '    * Since MRV tokens are sold at a rate of more than one per ether, and since\n', '    * they, like ETH, have 18 decimal places (at the time of sale), any fractional\n', '    * amount of ETH should be handled safely.\n', '    *\n', '    * Note that all orders are fill-or-kill. If you send in more ether than there are\n', '    * tokens remaining to be bought, your transaction will be rolled back and you will\n', '    * get no tokens and waste your gas.\n', '    */\n', '    function() payable onlyDuringCrowdsale {\n', '        createTokens(msg.sender);\n', '    }\n', '    \n', '    ////////////\n', '    // Events\n', '    ////////////\n', '    \n', '    // Fired when the crowdsale is recorded as started.\n', '    event CrowdsaleOpen(uint time);\n', '    // Fired when someone contributes to the crowdsale and buys MRV\n', '    event TokenPurchase(uint time, uint etherAmount, address from);\n', '    // Fired when the crowdsale is recorded as ended.\n', '    event CrowdsaleClose(uint time);\n', '    // Fired when the decimal point moves\n', '    event DecimalChange(uint8 newDecimals);\n', '    \n', '    ////////////\n', '    // Modifiers (encoding important crowdsale logic)\n', '    ////////////\n', '    \n', '    /**\n', "     * Only allow some actions before the crowdsale closes, whether it's open or not.\n", '     */\n', '    modifier onlyBeforeClosed {\n', '        checkCloseTimer();\n', '        if (crowdsaleEnded) throw;\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * Only allow some actions after the crowdsale is over.\n', '     * Will set the crowdsale closed if it should be.\n', '     */\n', '    modifier onlyAfterClosed {\n', '        checkCloseTimer();\n', '        if (!crowdsaleEnded) throw;\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * Only allow some actions before the crowdsale starts.\n', '     */\n', '    modifier onlyBeforeOpened {\n', '        checkOpenTimer();\n', '        if (crowdsaleStarted) throw;\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * Only allow some actions while the crowdsale is active.\n', '     * Will set the crowdsale open if it should be.\n', '     */\n', '    modifier onlyDuringCrowdsale {\n', '        checkOpenTimer();\n', '        checkCloseTimer();\n', '        if (crowdsaleEnded) throw;\n', '        if (!crowdsaleStarted) throw;\n', '        _;\n', '    }\n', '\n', '    ////////////\n', '    // Status and utility functions\n', '    ////////////\n', '    \n', '    /**\n', '     * Determine if the crowdsale should open by timer.\n', '     */\n', '    function openTimerElapsed() constant returns (bool) {\n', '        return (openTimer != 0 && now > openTimer);\n', '    }\n', '    \n', '    /**\n', '     * Determine if the crowdsale should close by timer.\n', '     */\n', '    function closeTimerElapsed() constant returns (bool) {\n', '        return (closeTimer != 0 && now > closeTimer);\n', '    }\n', '    \n', '    /**\n', '     * If the open timer has elapsed, start the crowdsale.\n', '     * Can be called by people, but also gets called when people try to contribute.\n', '     */\n', '    function checkOpenTimer() {\n', '        if (openTimerElapsed()) {\n', '            crowdsaleStarted = true;\n', '            openTimer = 0;\n', '            CrowdsaleOpen(now);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * If the close timer has elapsed, stop the crowdsale.\n', '     */\n', '    function checkCloseTimer() {\n', '        if (closeTimerElapsed()) {\n', '            crowdsaleEnded = true;\n', '            closeTimer = 0;\n', '            CrowdsaleClose(now);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Determine if the crowdsale is currently happening.\n', '     */\n', '    function isCrowdsaleActive() constant returns (bool) {\n', "        // The crowdsale is happening if it is open or due to open, and it isn't closed or due to close.\n", '        return ((crowdsaleStarted || openTimerElapsed()) && !(crowdsaleEnded || closeTimerElapsed()));\n', '    }\n', '    \n', '    ////////////\n', '    // Before the crowdsale: configuration\n', '    ////////////\n', '    \n', '    /**\n', '     * Before the crowdsale opens, the max token count can be configured.\n', '     */\n', '    function setMaxSupply(uint newMaxInWholeTokens) onlyOwner onlyBeforeOpened {\n', '        maxCrowdsaleSupplyInWholeTokens = newMaxInWholeTokens;\n', '    }\n', '    \n', '    /**\n', '     * Allow the owner to start the crowdsale manually.\n', '     */\n', '    function openCrowdsale() onlyOwner onlyBeforeOpened {\n', '        crowdsaleStarted = true;\n', '        openTimer = 0;\n', '        CrowdsaleOpen(now);\n', '    }\n', '    \n', '    /**\n', '     * Let the owner start the timer for the crowdsale start. Without further owner intervention,\n', '     * anyone will be able to open the crowdsale when the timer expires.\n', '     * Further calls will re-set the timer to count from the time the transaction is processed.\n', '     * The timer can be re-set after it has tripped, unless someone has already opened the crowdsale.\n', '     */\n', '    function setCrowdsaleOpenTimerFor(uint minutesFromNow) onlyOwner onlyBeforeOpened {\n', '        openTimer = now + minutesFromNow * 1 minutes;\n', '    }\n', '    \n', '    /**\n', '     * Let the owner stop the crowdsale open timer, as long as the crowdsale has not yet opened.\n', '     */\n', '    function clearCrowdsaleOpenTimer() onlyOwner onlyBeforeOpened {\n', '        openTimer = 0;\n', '    }\n', '    \n', '    /**\n', '     * Let the owner start the timer for the crowdsale end. Counts from when the function is called,\n', '     * *not* from the start of the crowdsale.\n', '     * It is possible, but a bad idea, to set this before the open timer.\n', '     */\n', '    function setCrowdsaleCloseTimerFor(uint minutesFromNow) onlyOwner onlyBeforeClosed {\n', '        closeTimer = now + minutesFromNow * 1 minutes;\n', '    }\n', '    \n', '    /**\n', '     * Let the owner stop the crowdsale close timer, as long as it has not yet expired.\n', '     */\n', '    function clearCrowdsaleCloseTimer() onlyOwner onlyBeforeClosed {\n', '        closeTimer = 0;\n', '    }\n', '    \n', '    \n', '    ////////////\n', '    // During the crowdsale\n', '    ////////////\n', '    \n', '    /**\n', '     * Create tokens for the given address, in response to a payment.\n', '     * Cannot be called by outside callers; use the fallback function, which will create tokens for whoever pays it.\n', '     */\n', '    function createTokens(address recipient) internal onlyDuringCrowdsale {\n', '        if (msg.value == 0) {\n', '            throw;\n', '        }\n', '\n', '        uint tokens = msg.value.mul(wholeTokensPerEth); // Exploits the fact that we have 18 decimals, like ETH.\n', '        \n', '        var newTotalSupply = totalSupply.add(tokens);\n', '        \n', '        if (newTotalSupply > (wholeTokensReserved + maxCrowdsaleSupplyInWholeTokens) * 10 ** 18) {\n', '            // This would be too many tokens issued.\n', "            // Don't mess around with partial order fills.\n", '            throw;\n', '        }\n', '        \n', '        // Otherwise, we can fill the order entirely, so make the tokens and put them in the specified account.\n', '        totalSupply = newTotalSupply;\n', '        balances[recipient] = balances[recipient].add(tokens);\n', '        \n', '        // Announce the purchase\n', '        TokenPurchase(now, msg.value, recipient);\n', '\n', '        // Lastly (after all state changes), send the money to the crowdsale beneficiary.\n', '        // This allows the crowdsale contract itself not to hold any ETH.\n', '        // It also means that ALL SALES ARE FINAL!\n', '        if (!beneficiary.send(msg.value)) {\n', '            throw;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Allow the owner to end the crowdsale manually.\n', '     */\n', '    function closeCrowdsale() onlyOwner onlyDuringCrowdsale {\n', '        crowdsaleEnded = true;\n', '        closeTimer = 0;\n', '        CrowdsaleClose(now);\n', '    }  \n', '    \n', '    ////////////\n', '    // After the crowdsale: token maintainance\n', '    ////////////\n', '    \n', '    /**\n', '     * When the crowdsale is finished, the contract owner may adjust the decimal places for display purposes.\n', '     * This should work like a 10-to-1 split or reverse-split.\n', '     * The point of this mechanism is to keep the individual MRV tokens from getting inconveniently valuable or cheap.\n', '     * However, it relies on the contract owner taking the time to update the decimal place value.\n', '     * Note that this changes the decimals IMMEDIATELY with NO NOTICE to users.\n', '     */\n', '    function setDecimals(uint8 newDecimals) onlyOwner onlyAfterClosed {\n', '        decimals = newDecimals;\n', '        // Announce the change\n', '        DecimalChange(decimals);\n', '    }\n', '    \n', '    /**\n', '     * If Ether somehow manages to get into this contract, provide a way to get it out again.\n', '     * During normal crowdsale operation, ETH is immediately forwarded to the beneficiary.\n', '     */\n', '    function reclaimEther() external onlyOwner {\n', '        // Send the ETH. Make sure it worked.\n', '        assert(owner.send(this.balance));\n', '    }\n', '\n', '}']