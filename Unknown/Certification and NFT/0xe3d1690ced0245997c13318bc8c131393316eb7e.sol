['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * Ethino Crowdsale Contract\n', ' *\n', ' * This is the crowdsale contract for the Ethino token. It utilizes Majoolr&#39;s\n', ' * CrowdsaleLib library to reduce custom source code surface area and increase overall\n', ' * security.Majoolr provides smart contract services\n', ' * and security reviews for contract deployments in addition to working on open\n', ' * source projects in the Ethereum community.\n', ' * For further information: ethino.com, majoolr.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'contract ENOCrowdsale {\n', '  using DirectCrowdsaleLib for DirectCrowdsaleLib.DirectCrowdsaleStorage;\n', '\n', '  DirectCrowdsaleLib.DirectCrowdsaleStorage sale;\n', '\n', '  function ENOCrowdsale(\n', '                address owner,\n', '                uint256 capAmountInCents,\n', '                uint256 startTime,\n', '                uint256 endTime,\n', '                uint256[] tokenPricePoints,\n', '                uint256 fallbackExchangeRate,\n', '                uint256 changeInterval,\n', '                uint8 percentBurn,\n', '                CrowdsaleToken token)\n', '  {\n', '  \tsale.init(owner, capAmountInCents, startTime, endTime, tokenPricePoints, fallbackExchangeRate, changeInterval, percentBurn, token);\n', '  }\n', '\n', '  /*EVENTS*/\n', '\n', '  event LogTokensBought(address indexed buyer, uint256 amount);\n', '  event LogErrorMsg(uint256 amount, string Msg);\n', '  event LogTokenPriceChange(uint256 amount, string Msg);\n', '  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n', '  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n', '  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n', '  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n', '  event LogErrorMsg(string Msg);\n', '\n', '  /*FUNCTIONS*/\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () payable {\n', '    sendPurchase();\n', '  }\n', '\n', '  function sendPurchase() payable returns (bool) {\n', '  \treturn sale.receivePurchase(msg.value);\n', '  }\n', '\n', '  function withdrawOwnerEth() returns (bool) {\n', '  \treturn sale.withdrawOwnerEth();\n', '  }\n', '\n', '  function setTokenExchangeRate(uint256 _exchangeRate) returns (bool) {\n', '    return sale.setTokenExchangeRate(_exchangeRate);\n', '  }\n', '\n', '  function setTokens() returns (bool) {\n', '    return sale.setTokens();\n', '  }\n', '\n', '  function withdrawTokens() returns (bool) {\n', '  \treturn sale.withdrawTokens();\n', '  }\n', '\n', '  function withdrawLeftoverWei() returns (bool) {\n', '    return sale.withdrawLeftoverWei();\n', '  }\n', '\n', '  /*GETTERS*/\n', '\n', '  function owner() constant returns (address) {\n', '    return sale.base.owner;\n', '  }\n', '\n', '  function tokensPerEth() constant returns (uint256) {\n', '    return sale.base.tokensPerEth;\n', '  }\n', '\n', '  function exchangeRate() constant returns (uint256) {\n', '    return sale.base.exchangeRate;\n', '  }\n', '\n', '  function capAmount() constant returns (uint256) {\n', '    return sale.base.capAmount;\n', '  }\n', '\n', '  function startTime() constant returns (uint256) {\n', '    return sale.base.startTime;\n', '  }\n', '\n', '  function endTime() constant returns (uint256) {\n', '    return sale.base.endTime;\n', '  }\n', '\n', '  function changeInterval() constant returns (uint256) {\n', '    return sale.changeInterval;\n', '  }\n', '\n', '  function crowdsaleActive() constant returns (bool) {\n', '  \treturn sale.crowdsaleActive();\n', '  }\n', '\n', '  function firstPriceChange() constant returns (uint256) {\n', '    return sale.tokenPricePoints[1];\n', '  }\n', '\n', '  function crowdsaleEnded() constant returns (bool) {\n', '  \treturn sale.crowdsaleEnded();\n', '  }\n', '\n', '  function ethRaised() constant returns (uint256) {\n', '    return sale.base.ownerBalance;\n', '  }\n', '\n', '  function tokensSold() constant returns (uint256) {\n', '    return sale.base.startingTokenBalance - sale.base.token.balanceOf(this);\n', '  }\n', '\n', '  function contributionAmount(address _buyer) constant returns (uint256) {\n', '  \treturn sale.base.hasContributed[_buyer];\n', '  }\n', '\n', '  function tokenPurchaseAmount(address _buyer) constant returns (uint256) {\n', '  \treturn sale.base.withdrawTokensMap[_buyer];\n', '  }\n', '\n', '  function leftoverWeiAmount(address _buyer) constant returns (uint256) {\n', '    return sale.base.leftoverWei[_buyer];\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title DirectCrowdsaleLib\n', ' * @author Majoolr.io\n', ' *\n', ' * version 1.0.0\n', ' * Copyright (c) 2017 Majoolr, LLC\n', ' * The MIT License (MIT)\n', ' * https://github.com/Majoolr/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The DirectCrowdsale Library provides functionality to create a initial coin offering\n', ' * for a standard token sale with high supply where there is a direct ether to\n', ' * token transfer.\n', ' *\n', ' * Majoolr provides smart contract services and security reviews for contract\n', ' * deployments in addition to working on open source projects in the Ethereum\n', ' * community. Our purpose is to test, document, and deploy reusable code onto the\n', ' * blockchain and improve both security and usability. We also educate non-profits,\n', ' * schools, and other community members about the application of blockchain\n', ' * technology. For further information: majoolr.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library DirectCrowdsaleLib {\n', '  using BasicMathLib for uint256;\n', '  using CrowdsaleLib for CrowdsaleLib.CrowdsaleStorage;\n', '\n', '  struct DirectCrowdsaleStorage {\n', '\n', '  \tCrowdsaleLib.CrowdsaleStorage base; // base storage from CrowdsaleLib\n', '\n', '    uint256[] tokenPricePoints;    // price points at each price change interval in cents/token.\n', '\n', '  \tuint256 changeInterval;      // amount of time between changes in the price of the token\n', '  \tuint256 lastPriceChangeTime;  // time of the last change in token cost\n', '  }\n', '\n', '  event LogTokensBought(address indexed buyer, uint256 amount);\n', '  event LogAddressCapExceeded(address indexed buyer, uint256 amount, string Msg);\n', '  event LogErrorMsg(uint256 amount, string Msg);\n', '  event LogTokenPriceChange(uint256 amount, string Msg);\n', '\n', '\n', '  /// @dev Called by a crowdsale contract upon creation.\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _owner Address of crowdsale owner\n', '  /// @param _capAmountInCents Total to be raised in cents\n', '  /// @param _startTime Timestamp of sale start time\n', '  /// @param _endTime Timestamp of sale end time\n', '  /// @param _tokenPricePoints Array of each price point during sale cents/token\n', '  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\n', '  /// @param _changeInterval The number of seconds between each step\n', '  /// @param _percentBurn Percentage of extra tokens to burn\n', '  /// @param _token Token being sold\n', '  function init(DirectCrowdsaleStorage storage self,\n', '                address _owner,\n', '                uint256 _capAmountInCents,\n', '                uint256 _startTime,\n', '                uint256 _endTime,\n', '                uint256[] _tokenPricePoints,\n', '                uint256 _fallbackExchangeRate,\n', '                uint256 _changeInterval,\n', '                uint8 _percentBurn,\n', '                CrowdsaleToken _token)\n', '  {\n', '  \tself.base.init(_owner,\n', '                _tokenPricePoints[0],\n', '                _fallbackExchangeRate,\n', '                _capAmountInCents,\n', '                _startTime,\n', '                _endTime,\n', '                _percentBurn,\n', '                _token);\n', '\n', '    require(_tokenPricePoints.length > 0);\n', '\n', '    // if there is no increase or decrease in price, the time interval should also be zero\n', '    if (_tokenPricePoints.length == 1) {\n', '    \trequire(_changeInterval == 0);\n', '    }\n', '    self.tokenPricePoints = _tokenPricePoints;\n', '  \tself.changeInterval = _changeInterval;\n', '  \tself.lastPriceChangeTime = _startTime;\n', '  }\n', '\n', '  /// @dev Called when an address wants to purchase tokens\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _amount amound of wei that the buyer is sending\n', '  /// @return true on succesful purchase\n', '  function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount) returns (bool) {\n', '    require(msg.sender != self.base.owner);\n', '  \trequire(self.base.validPurchase());\n', '\n', '    require((self.base.ownerBalance + _amount) <= self.base.capAmount);\n', '\n', '  \t// if the token price increase interval has passed, update the current day and change the token price\n', '  \tif ((self.changeInterval > 0) && (now >= (self.lastPriceChangeTime + self.changeInterval))) {\n', '  \t\tself.lastPriceChangeTime = self.lastPriceChangeTime + self.changeInterval;\n', '      uint256 index = (now-self.base.startTime)/self.changeInterval;\n', '\n', '      //prevents going out of bounds on the tokenPricePoints array\n', '      if (self.tokenPricePoints.length <= index)\n', '        index = self.tokenPricePoints.length - 1;\n', '\n', '      self.base.changeTokenPrice(self.tokenPricePoints[index]);\n', '\n', '      LogTokenPriceChange(self.base.tokensPerEth,"Token Price has changed!");\n', '  \t}\n', '\n', '  \tuint256 numTokens; //number of tokens that will be purchased\n', '  \tbool err;\n', '    uint256 newBalance; //the new balance of the owner of the crowdsale\n', '    uint256 weiTokens; //temp calc holder\n', '    uint256 zeros; //for calculating token\n', '    uint256 leftoverWei; //wei change for purchaser\n', '    uint256 remainder; //temp calc holder\n', '\n', '    // Find the number of tokens as a function in wei\n', '    (err,weiTokens) = _amount.times(self.base.tokensPerEth);\n', '    require(!err);\n', '\n', '    if(self.base.tokenDecimals <= 18){\n', '      zeros = 10**(18-uint256(self.base.tokenDecimals));\n', '      numTokens = weiTokens/zeros;\n', '      leftoverWei = weiTokens % zeros;\n', '      self.base.leftoverWei[msg.sender] += leftoverWei;\n', '    } else {\n', '      zeros = 10**(uint256(self.base.tokenDecimals)-18);\n', '      numTokens = weiTokens*zeros;\n', '    }\n', '\n', '    // can&#39;t overflow because it is under the cap\n', '    self.base.hasContributed[msg.sender] += _amount - leftoverWei;\n', '\n', '    require(numTokens <= self.base.token.balanceOf(this));\n', '\n', '    // calculate the amout of ether in the owners balance\n', '    (err,newBalance) = self.base.ownerBalance.plus(_amount-leftoverWei);\n', '    require(!err);\n', '\n', '    self.base.ownerBalance = newBalance;   // "deposit" the amount\n', '\n', '    // can&#39;t overflow because it will be under the cap\n', '\t  self.base.withdrawTokensMap[msg.sender] += numTokens;\n', '\n', '    //subtract tokens from owner&#39;s share\n', '    (err,remainder) = self.base.withdrawTokensMap[self.base.owner].minus(numTokens);\n', '    self.base.withdrawTokensMap[self.base.owner] = remainder;\n', '\n', '\t  LogTokensBought(msg.sender, numTokens);\n', '\n', '    return true;\n', '  }\n', '\n', '  /*Functions "inherited" from CrowdsaleLib library*/\n', '\n', '  function setTokenExchangeRate(DirectCrowdsaleStorage storage self, uint256 _exchangeRate) returns (bool) {\n', '    return self.base.setTokenExchangeRate(_exchangeRate);\n', '  }\n', '\n', '  function setTokens(DirectCrowdsaleStorage storage self) returns (bool) {\n', '    return self.base.setTokens();\n', '  }\n', '\n', '  function withdrawTokens(DirectCrowdsaleStorage storage self) returns (bool) {\n', '    return self.base.withdrawTokens();\n', '  }\n', '\n', '  function withdrawLeftoverWei(DirectCrowdsaleStorage storage self) returns (bool) {\n', '    return self.base.withdrawLeftoverWei();\n', '  }\n', '\n', '  function withdrawOwnerEth(DirectCrowdsaleStorage storage self) returns (bool) {\n', '    return self.base.withdrawOwnerEth();\n', '  }\n', '\n', '  function crowdsaleActive(DirectCrowdsaleStorage storage self) constant returns (bool) {\n', '    return self.base.crowdsaleActive();\n', '  }\n', '\n', '  function crowdsaleEnded(DirectCrowdsaleStorage storage self) constant returns (bool) {\n', '    return self.base.crowdsaleEnded();\n', '  }\n', '\n', '  function validPurchase(DirectCrowdsaleStorage storage self) constant returns (bool) {\n', '    return self.base.validPurchase();\n', '  }\n', '}\n', 'pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This is an example token contract built using the Majoolr token library at\n', ' * https://github.com/Majoolr/ethereum-libraries/tree/master/TokenLib. This\n', ' * example does not use all of the functionality available, it is only\n', ' * a barebones example of a basic ERC20 token contract.\n', ' *\n', ' * Majoolr provides smart contract services and security reviews for contract\n', ' * deployments in addition to working on open source projects in the Ethereum\n', ' * community. Our purpose is to test, document, and deploy reusable code onto the\n', ' * blockchain and improve both security and usability. We also educate non-profits,\n', ' * schools, and other community members about the application of blockchain\n', ' * technology. For further information: majoolr.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'contract CrowdsaleToken {\n', '  using TokenLib for TokenLib.TokenStorage;\n', '\n', '  TokenLib.TokenStorage public token;\n', '\n', '  function CrowdsaleToken(address owner,\n', '                                string name,\n', '                                string symbol,\n', '                                uint8 decimals,\n', '                                uint256 initialSupply,\n', '                                bool allowMinting)\n', '  {\n', '    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n', '  }\n', '\n', '  function name() constant returns (string) {\n', '    return token.name;\n', '  }\n', '\n', '  function symbol() constant returns (string) {\n', '    return token.symbol;\n', '  }\n', '\n', '  function decimals() constant returns (uint8) {\n', '    return token.decimals;\n', '  }\n', '\n', '  function totalSupply() constant returns (uint256) {\n', '    return token.totalSupply;\n', '  }\n', '\n', '  function initialSupply() constant returns (uint256) {\n', '    return token.INITIAL_SUPPLY;\n', '  }\n', '\n', '  function balanceOf(address who) constant returns (uint256) {\n', '    return token.balanceOf(who);\n', '  }\n', '\n', '  function allowance(address owner, address spender) constant returns (uint256) {\n', '    return token.allowance(owner, spender);\n', '  }\n', '\n', '  function transfer(address to, uint value) returns (bool ok) {\n', '    return token.transfer(to, value);\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint value) returns (bool ok) {\n', '    return token.transferFrom(from, to, value);\n', '  }\n', '\n', '  function approve(address spender, uint value) returns (bool ok) {\n', '    return token.approve(spender, value);\n', '  }\n', '\n', '  function changeOwner(address newOwner) returns (bool ok) {\n', '    return token.changeOwner(newOwner);\n', '  }\n', '\n', '  function burnToken(uint256 amount) returns (bool ok) {\n', '    return token.burnToken(amount);\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title CrowdsaleLib\n', ' * @author Majoolr.io\n', ' *\n', ' * version 1.0.0\n', ' * Copyright (c) 2017 Majoolr, LLC\n', ' * The MIT License (MIT)\n', ' * https://github.com/Majoolr/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The Crowdsale Library provides basic functionality to create an initial coin\n', ' * offering for different types of token sales.\n', ' *\n', ' * Majoolr provides smart contract services and security reviews for contract\n', ' * deployments in addition to working on open source projects in the Ethereum\n', ' * community. Our purpose is to test, document, and deploy reusable code onto the\n', ' * blockchain and improve both security and usability. We also educate non-profits,\n', ' * schools, and other community members about the application of blockchain\n', ' * technology. For further information: majoolr.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library CrowdsaleLib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct CrowdsaleStorage {\n', '  \taddress owner;     //owner of the crowdsale\n', '\n', '  \tuint256 tokensPerEth;  //number of tokens received per ether\n', '  \tuint256 capAmount; //Maximum amount to be raised in wei\n', '  \tuint256 startTime; //ICO start time, timestamp\n', '  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n', '    uint256 exchangeRate; //cents/ETH exchange rate at the time of the sale\n', '    uint256 ownerBalance; //owner wei Balance\n', '    uint256 startingTokenBalance; //initial amount of tokens for sale\n', '    uint8 tokenDecimals; //stored token decimals for calculation later\n', '    uint8 percentBurn; //percentage of extra tokens to burn\n', '    bool tokensSet; //true if tokens have been prepared for crowdsale\n', '    bool rateSet; //true if exchange rate has been set\n', '\n', '    //shows how much wei an address has contributed\n', '  \tmapping (address => uint256) hasContributed;\n', '\n', '    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n', '  \tmapping (address => uint256) withdrawTokensMap;\n', '\n', '    // any leftover wei that buyers contributed that didn&#39;t add up to a whole token amount\n', '    mapping (address => uint256) leftoverWei;\n', '\n', '  \tCrowdsaleToken token; //token being sold\n', '  }\n', '\n', '  // Indicates when an address has withdrawn their supply of tokens\n', '  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n', '\n', '  // Indicates when an address has withdrawn their supply of extra wei\n', '  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n', '\n', '  // Logs when owner has pulled eth\n', '  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n', '\n', '  // Generic Notice message that includes and address and number\n', '  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n', '\n', '  // Indicates when an error has occurred in the execution of a function\n', '  event LogErrorMsg(string Msg);\n', '\n', '  /// @dev Called by a crowdsale contract upon creation.\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _owner Address of crowdsale owner\n', '  /// @param _tokenPriceInCents Price of tokens in cents\n', '  /// @param _fallbackExchangeRate Exchange rate of cents/ETH\n', '  /// @param _capAmountInCents Total to be raised in cents\n', '  /// @param _startTime Timestamp of sale start time\n', '  /// @param _endTime Timestamp of sale end time\n', '  /// @param _percentBurn Percentage of extra tokens to burn\n', '  /// @param _token Token being sold\n', '  function init(CrowdsaleStorage storage self,\n', '                address _owner,\n', '                uint256 _tokenPriceInCents,\n', '                uint256 _fallbackExchangeRate,\n', '                uint256 _capAmountInCents,\n', '                uint256 _startTime,\n', '                uint256 _endTime,\n', '                uint8 _percentBurn,\n', '                CrowdsaleToken _token)\n', '  {\n', '  \trequire(self.capAmount == 0);\n', '  \trequire(self.owner == 0);\n', '    require(_endTime > _startTime);\n', '    require(_tokenPriceInCents > 0);\n', '    require(_capAmountInCents > 0);\n', '    require(_owner > 0);\n', '    require(_fallbackExchangeRate > 0);\n', '    require(_percentBurn <= 100);\n', '    self.owner = _owner;\n', '    self.capAmount = ((_capAmountInCents/_fallbackExchangeRate) + 1)*(10**18);\n', '    self.startTime = _startTime;\n', '    self.endTime = _endTime;\n', '    self.token = _token;\n', '    self.tokenDecimals = _token.decimals();\n', '    self.percentBurn = _percentBurn;\n', '    self.exchangeRate = _fallbackExchangeRate;\n', '    changeTokenPrice(self,_tokenPriceInCents);\n', '  }\n', '\n', '  /// @dev function to check if the crowdsale is currently active\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return success\n', '  function crowdsaleActive(CrowdsaleStorage storage self) constant returns (bool) {\n', '  \treturn (now >= self.startTime && now <= self.endTime);\n', '  }\n', '\n', '  /// @dev function to check if the crowdsale has ended\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return success\n', '  function crowdsaleEnded(CrowdsaleStorage storage self) constant returns (bool) {\n', '  \treturn now > self.endTime;\n', '  }\n', '\n', '  /// @dev function to check if a purchase is valid\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if the transaction can buy tokens\n', '  function validPurchase(CrowdsaleStorage storage self) internal constant returns (bool) {\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    if (crowdsaleActive(self) && nonZeroPurchase) {\n', '      return true;\n', '    } else {\n', '      LogErrorMsg("Invalid Purchase! Check send time and amount of ether.");\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /// @dev Function called by purchasers to pull tokens\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if tokens were withdrawn\n', '  function withdrawTokens(CrowdsaleStorage storage self) returns (bool) {\n', '    bool ok;\n', '\n', '    if (self.withdrawTokensMap[msg.sender] == 0) {\n', '      LogErrorMsg("Sender has no tokens to withdraw!");\n', '      return false;\n', '    }\n', '\n', '    if (msg.sender == self.owner) {\n', '      if((!crowdsaleEnded(self))){\n', '        LogErrorMsg("Owner cannot withdraw extra tokens until after the sale!");\n', '        return false;\n', '      } else {\n', '        if(self.percentBurn > 0){\n', '          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n', '          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n', '          ok = self.token.burnToken(_burnAmount);\n', '          require(ok);\n', '        }\n', '      }\n', '    }\n', '\n', '    var total = self.withdrawTokensMap[msg.sender];\n', '    self.withdrawTokensMap[msg.sender] = 0;\n', '    ok = self.token.transfer(msg.sender, total);\n', '    require(ok);\n', '    LogTokensWithdrawn(msg.sender, total);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Function called by purchasers to pull leftover wei from their purchases\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if wei was withdrawn\n', '  function withdrawLeftoverWei(CrowdsaleStorage storage self) returns (bool) {\n', '    require(self.hasContributed[msg.sender] > 0);\n', '    if (self.leftoverWei[msg.sender] == 0) {\n', '      LogErrorMsg("Sender has no extra wei to withdraw!");\n', '      return false;\n', '    }\n', '\n', '    var total = self.leftoverWei[msg.sender];\n', '    self.leftoverWei[msg.sender] = 0;\n', '    msg.sender.transfer(total);\n', '    LogWeiWithdrawn(msg.sender, total);\n', '    return true;\n', '  }\n', '\n', '  /// @dev send ether from the completed crowdsale to the owners wallet address\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if owner withdrew eth\n', '  function withdrawOwnerEth(CrowdsaleStorage storage self) returns (bool) {\n', '    if (!crowdsaleEnded(self)) {\n', '      LogErrorMsg("Cannot withdraw owner ether until after the sale!");\n', '      return false;\n', '    }\n', '\n', '    require(msg.sender == self.owner);\n', '    require(self.ownerBalance > 0);\n', '\n', '    uint256 amount = self.ownerBalance;\n', '    self.ownerBalance = 0;\n', '    self.owner.transfer(amount);\n', '    LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!");\n', '\n', '    return true;\n', '  }\n', '\n', '  /// @dev Function to change the price of the token\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _newPrice new token price (amount of tokens per ether)\n', '  /// @return true if the token price changed successfully\n', '  function changeTokenPrice(CrowdsaleStorage storage self,uint256 _newPrice) internal returns (bool) {\n', '  \trequire(_newPrice > 0);\n', '\n', '    uint256 result;\n', '    bool err;\n', '\n', '    (err,result) = self.exchangeRate.dividedBy(_newPrice);\n', '    require(!err);\n', '\n', '  \tself.tokensPerEth = result + 1;\n', '    return true;\n', '  }\n', '\n', '  /// @dev function that is called three days before the sale to set the token and price\n', '  /// @param self Stored Crowdsale from crowdsale contract\n', '  /// @param _exchangeRate  ETH exchange rate expressed in cents/ETH\n', '  /// @return true if the exchange rate has been set\n', '  function setTokenExchangeRate(CrowdsaleStorage storage self, uint256 _exchangeRate) returns (bool) {\n', '    require(msg.sender == self.owner);\n', '    require((now > (self.startTime - 3 days)) && (now < (self.startTime)));\n', '    require(!self.rateSet);   // the exchange rate can only be set once!\n', '    require(self.token.balanceOf(this) > 0);\n', '    require(_exchangeRate > 0);\n', '\n', '    uint256 _capAmountInCents;\n', '    uint256 _tokenPriceInCents;\n', '    uint256 _tokenBalance;\n', '    bool err;\n', '\n', '    (err, _capAmountInCents) = self.exchangeRate.times(self.capAmount);\n', '    require(!err);\n', '\n', '    (err, _tokenPriceInCents) = self.exchangeRate.dividedBy(self.tokensPerEth);\n', '    require(!err);\n', '\n', '    _tokenBalance = self.token.balanceOf(this);\n', '    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n', '    self.startingTokenBalance = _tokenBalance;\n', '    self.tokensSet = true;\n', '\n', '    self.exchangeRate = _exchangeRate;\n', '    self.capAmount = (_capAmountInCents/_exchangeRate) + 1;\n', '    changeTokenPrice(self,_tokenPriceInCents + 1);\n', '    self.rateSet = true;\n', '\n', '    LogNoticeMsg(msg.sender,self.tokensPerEth,"Owner has sent the exchange Rate and tokens bought per ETH!");\n', '    return true;\n', '  }\n', '\n', '  /// @dev fallback function to set tokens if the exchange rate function was not called\n', '  /// @param self Stored Crowdsale from crowdsale contract\n', '  /// @return true if tokens set successfully\n', '  function setTokens(CrowdsaleStorage storage self) returns (bool) {\n', '    require(msg.sender == self.owner);\n', '    require(!self.tokensSet);\n', '\n', '    uint256 _tokenBalance;\n', '\n', '    _tokenBalance = self.token.balanceOf(this);\n', '    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n', '    self.startingTokenBalance = _tokenBalance;\n', '    self.tokensSet = true;\n', '\n', '    return true;\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title TokenLib\n', ' * @author Majoolr.io\n', ' *\n', ' * version 1.1.0\n', ' * Copyright (c) 2017 Majoolr, LLC\n', ' * The MIT License (MIT)\n', ' * https://github.com/Majoolr/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The Token Library provides functionality to create a variety of ERC20 tokens.\n', ' * See https://github.com/Majoolr/ethereum-contracts for an example of how to\n', ' * create a basic ERC20 token.\n', ' *\n', ' * Majoolr works on open source projects in the Ethereum community with the\n', ' * purpose of testing, documenting, and deploying reusable code onto the\n', ' * blockchain to improve security and usability of smart contracts. Majoolr\n', ' * also strives to educate non-profits, schools, and other community members\n', ' * about the application of blockchain technology.\n', ' * For further information: majoolr.io\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library TokenLib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct TokenStorage {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    string name;\n', '    string symbol;\n', '    uint256 totalSupply;\n', '    uint256 INITIAL_SUPPLY;\n', '    address owner;\n', '    uint8 decimals;\n', '    bool stillMinting;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event OwnerChange(address from, address to);\n', '  event Burn(address indexed burner, uint256 value);\n', '  event MintingClosed(bool mintingClosed);\n', '\n', '  /// @dev Called by the Standard Token upon creation.\n', '  /// @param self Stored token from token contract\n', '  /// @param _name Name of the new token\n', '  /// @param _symbol Symbol of the new token\n', '  /// @param _decimals Decimal places for the token represented\n', '  /// @param _initial_supply The initial token supply\n', '  /// @param _allowMinting True if additional tokens can be created, false otherwise\n', '  function init(TokenStorage storage self,\n', '                address _owner,\n', '                string _name,\n', '                string _symbol,\n', '                uint8 _decimals,\n', '                uint256 _initial_supply,\n', '                bool _allowMinting)\n', '  {\n', '    require(self.INITIAL_SUPPLY == 0);\n', '    self.name = _name;\n', '    self.symbol = _symbol;\n', '    self.totalSupply = _initial_supply;\n', '    self.INITIAL_SUPPLY = _initial_supply;\n', '    self.decimals = _decimals;\n', '    self.owner = _owner;\n', '    self.stillMinting = _allowMinting;\n', '    self.balances[_owner] = _initial_supply;\n', '  }\n', '\n', '  /// @dev Transfer tokens from caller&#39;s account to another account.\n', '  /// @param self Stored token from token contract\n', '  /// @param _to Address to send tokens\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool) {\n', '    bool err;\n', '    uint256 balance;\n', '\n', '    (err,balance) = self.balances[msg.sender].minus(_value);\n', '    require(!err);\n', '    self.balances[msg.sender] = balance;\n', '    //It&#39;s not possible to overflow token supply\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Authorized caller transfers tokens from one account to another\n', '  /// @param self Stored token from token contract\n', '  /// @param _from Address to send tokens from\n', '  /// @param _to Address to send tokens to\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transferFrom(TokenStorage storage self,\n', '                        address _from,\n', '                        address _to,\n', '                        uint256 _value)\n', '                        returns (bool)\n', '  {\n', '    var _allowance = self.allowed[_from][msg.sender];\n', '    bool err;\n', '    uint256 balanceOwner;\n', '    uint256 balanceSpender;\n', '\n', '    (err,balanceOwner) = self.balances[_from].minus(_value);\n', '    require(!err);\n', '\n', '    (err,balanceSpender) = _allowance.minus(_value);\n', '    require(!err);\n', '\n', '    self.balances[_from] = balanceOwner;\n', '    self.allowed[_from][msg.sender] = balanceSpender;\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Retrieve token balance for an account\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address to retrieve balance of\n', '  /// @return balance The number of tokens in the subject account\n', '  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {\n', '    return self.balances[_owner];\n', '  }\n', '\n', '  /// @dev Authorize an account to send tokens on caller&#39;s behalf\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _value Number of tokens authorized account may send\n', '  /// @return True if completed\n', '  function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool) {\n', '    self.allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Remaining tokens third party spender has to send\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address of token holder\n', '  /// @param _spender Address of authorized spender\n', '  /// @return remaining Number of tokens spender has left in owner&#39;s account\n', '  function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return self.allowed[_owner][_spender];\n', '  }\n', '\n', '  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\n', '  /// @param _increase True if increasing allowance, false if decreasing allowance\n', '  /// @return True if completed\n', '  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n', '                          returns (bool)\n', '  {\n', '    uint256 _newAllowed;\n', '    bool err;\n', '\n', '    if(_increase) {\n', '      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n', '      require(!err);\n', '\n', '      self.allowed[msg.sender][_spender] = _newAllowed;\n', '    } else {\n', '      if (_valueChange > self.allowed[msg.sender][_spender]) {\n', '        self.allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n', '        self.allowed[msg.sender][_spender] = _newAllowed;\n', '      }\n', '    }\n', '\n', '    Approval(msg.sender, _spender, _newAllowed);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Change owning address of the token contract, specifically for minting\n', '  /// @param self Stored token from token contract\n', '  /// @param _newOwner Address for the new owner\n', '  /// @return True if completed\n', '  function changeOwner(TokenStorage storage self, address _newOwner) returns (bool) {\n', '    require((self.owner == msg.sender) && (_newOwner > 0));\n', '\n', '    self.owner = _newOwner;\n', '    OwnerChange(msg.sender, _newOwner);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Mints additional tokens, new tokens go to owner\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Number of tokens to mint\n', '  /// @return True if completed\n', '  function mintToken(TokenStorage storage self, uint256 _amount) returns (bool) {\n', '    require((self.owner == msg.sender) && self.stillMinting);\n', '    uint256 _newAmount;\n', '    bool err;\n', '\n', '    (err, _newAmount) = self.totalSupply.plus(_amount);\n', '    require(!err);\n', '\n', '    self.totalSupply =  _newAmount;\n', '    self.balances[self.owner] = self.balances[self.owner] + _amount;\n', '    Transfer(0x0, self.owner, _amount);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanent stops minting\n', '  /// @param self Stored token from token contract\n', '  /// @return True if completed\n', '  function closeMint(TokenStorage storage self) returns (bool) {\n', '    require(self.owner == msg.sender);\n', '\n', '    self.stillMinting = false;\n', '    MintingClosed(true);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanently burn tokens\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Amount of tokens to burn\n', '  /// @return True if completed\n', '  function burnToken(TokenStorage storage self, uint256 _amount) returns (bool) {\n', '      uint256 _newBalance;\n', '      bool err;\n', '\n', '      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n', '      require(!err);\n', '\n', '      self.balances[msg.sender] = _newBalance;\n', '      self.totalSupply = self.totalSupply - _amount;\n', '      Burn(msg.sender, _amount);\n', '      Transfer(msg.sender, 0x0, _amount);\n', '      return true;\n', '  }\n', '}\n', '\n', 'pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Basic Math Library\n', ' * @author Majoolr.io\n', ' *\n', ' * version 1.1.0\n', ' * Copyright (c) 2017 Majoolr, LLC\n', ' * The MIT License (MIT)\n', ' * https://github.com/Majoolr/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The Basic Math Library is inspired by the Safe Math library written by\n', ' * OpenZeppelin at https://github.com/OpenZeppelin/zeppelin-solidity/ .\n', ' * Majoolr works on open source projects in the Ethereum community with the\n', ' * purpose of testing, documenting, and deploying reusable code onto the\n', ' * blockchain to improve security and usability of smart contracts. Majoolr\n', ' * also strives to educate non-profits, schools, and other community members\n', ' * about the application of blockchain technology.\n', ' * For further information: majoolr.io, openzeppelin.org\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library BasicMathLib {\n', '  event Err(string typeErr);\n', '\n', '  /// @dev Multiplies two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The product of a and b, or 0 if there is overflow\n', '  function times(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := mul(a,b)\n', '      switch or(iszero(b), eq(div(res,b), a))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '    if (err)\n', '      Err("times func overflow");\n', '  }\n', '\n', '  /// @dev Divides two numbers but checks for 0 in the divisor first.\n', '  /// Does not throw but rather logs an Err event if 0 is in the divisor.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if `b` is 0\n', '  /// @return res The quotient of a and b, or 0 if `b` is 0\n', '  function dividedBy(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      switch iszero(b)\n', '      case 0 {\n', '        res := div(a,b)\n', '        mstore(add(mload(0x40),0x20),res)\n', '        return(mload(0x40),0x40)\n', '      }\n', '    }\n', '    Err("tried to divide by zero");\n', '    return (true, 0);\n', '  }\n', '\n', '  /// @dev Adds two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The sum of a and b, or 0 if there is overflow\n', '  function plus(uint256 a, uint256 b) constant returns (bool err, uint256 res) {\n', '    assembly{\n', '      res := add(a,b)\n', '      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '    if (err)\n', '      Err("plus func overflow");\n', '  }\n', '\n', '  /// @dev Subtracts two numbers and checks for underflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is underflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is underflow\n', '  /// @return res The difference between a and b, or 0 if there is underflow\n', '  function minus(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := sub(a,b)\n', '      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '    if (err)\n', '      Err("minus func underflow");\n', '  }\n', '}']