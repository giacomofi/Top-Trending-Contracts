['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public constant returns (address owner) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still need to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    We consider every contract to be a &#39;token holder&#39; since it&#39;s currently not possible\n', '    for a contract to deny receiving tokens.\n', '\n', '    The TokenHolder&#39;s contract sole purpose is to provide a safety mechanism that allows\n', '    the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '*/\n', 'contract TokenHolder is ITokenHolder, Owned {\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function TokenHolder() {\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '/*\n', '    EIP228 Token Changer interface\n', '*/\n', 'contract ITokenChanger {\n', '    function changeableTokenCount() public constant returns (uint16 count);\n', '    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);\n', '}\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is ITokenHolder, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Bancor Changer interface\n', '*/\n', 'contract IBancorChanger is ITokenChanger {\n', '    function token() public constant returns (ISmartToken _token) { _token; }\n', '    function getReserveBalance(IERC20Token _reserveToken) public constant returns (uint256 balance);\n', '}\n', '\n', '/*\n', '    Ether Token interface\n', '*/\n', 'contract IEtherToken is ITokenHolder, IERC20Token {\n', '    function deposit() public payable;\n', '    function withdraw(uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    BancorBuyer v0.1\n', '\n', '    The bancor buyer contract is a simple bancor changer wrapper that allows buying smart tokens with ETH\n', '\n', '    WARNING: the contract will make the purchase using the current price at transaction mining time\n', '*/\n', 'contract BancorBuyer is TokenHolder {\n', '    string public version = &#39;0.1&#39;;\n', '    IBancorChanger public tokenChanger; // bancor ETH <-> smart token changer\n', '    IEtherToken public etherToken;      // ether token\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _changer     bancor token changer that actually does the purchase\n', '        @param _etherToken  ether token used as a reserve in the token changer\n', '    */\n', '    function BancorBuyer(IBancorChanger _changer, IEtherToken _etherToken)\n', '        validAddress(_changer)\n', '        validAddress(_etherToken)\n', '    {\n', '        tokenChanger = _changer;\n', '        etherToken = _etherToken;\n', '\n', '        // ensure that the ether token is used as one of the changer&#39;s reserves\n', '        tokenChanger.getReserveBalance(etherToken);\n', '    }\n', '\n', '    /**\n', '        @dev buys the smart token with ETH\n', '        note that the purchase will use the price at the time of the purchase\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function buy() public payable returns (uint256 amount) {\n', '        etherToken.deposit.value(msg.value)(); // deposit ETH in the reserve\n', '        assert(etherToken.approve(tokenChanger, 0)); // need to reset the allowance to 0 before setting a new one\n', '        assert(etherToken.approve(tokenChanger, msg.value)); // approve the changer to use the ETH amount for the purchase\n', '\n', '        ISmartToken smartToken = tokenChanger.token();\n', '        uint256 returnAmount = tokenChanger.change(etherToken, smartToken, msg.value, 1); // do the actual change using the current price\n', '        assert(smartToken.transfer(msg.sender, returnAmount)); // transfer the tokens to the sender\n', '        return returnAmount;\n', '    }\n', '\n', '    // fallback\n', '    function() payable {\n', '        buy();\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public constant returns (address owner) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still need to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '/*\n', "    We consider every contract to be a 'token holder' since it's currently not possible\n", '    for a contract to deny receiving tokens.\n', '\n', "    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n", '    the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '*/\n', 'contract TokenHolder is ITokenHolder, Owned {\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function TokenHolder() {\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '/*\n', '    EIP228 Token Changer interface\n', '*/\n', 'contract ITokenChanger {\n', '    function changeableTokenCount() public constant returns (uint16 count);\n', '    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);\n', '}\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is ITokenHolder, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Bancor Changer interface\n', '*/\n', 'contract IBancorChanger is ITokenChanger {\n', '    function token() public constant returns (ISmartToken _token) { _token; }\n', '    function getReserveBalance(IERC20Token _reserveToken) public constant returns (uint256 balance);\n', '}\n', '\n', '/*\n', '    Ether Token interface\n', '*/\n', 'contract IEtherToken is ITokenHolder, IERC20Token {\n', '    function deposit() public payable;\n', '    function withdraw(uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    BancorBuyer v0.1\n', '\n', '    The bancor buyer contract is a simple bancor changer wrapper that allows buying smart tokens with ETH\n', '\n', '    WARNING: the contract will make the purchase using the current price at transaction mining time\n', '*/\n', 'contract BancorBuyer is TokenHolder {\n', "    string public version = '0.1';\n", '    IBancorChanger public tokenChanger; // bancor ETH <-> smart token changer\n', '    IEtherToken public etherToken;      // ether token\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _changer     bancor token changer that actually does the purchase\n', '        @param _etherToken  ether token used as a reserve in the token changer\n', '    */\n', '    function BancorBuyer(IBancorChanger _changer, IEtherToken _etherToken)\n', '        validAddress(_changer)\n', '        validAddress(_etherToken)\n', '    {\n', '        tokenChanger = _changer;\n', '        etherToken = _etherToken;\n', '\n', "        // ensure that the ether token is used as one of the changer's reserves\n", '        tokenChanger.getReserveBalance(etherToken);\n', '    }\n', '\n', '    /**\n', '        @dev buys the smart token with ETH\n', '        note that the purchase will use the price at the time of the purchase\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function buy() public payable returns (uint256 amount) {\n', '        etherToken.deposit.value(msg.value)(); // deposit ETH in the reserve\n', '        assert(etherToken.approve(tokenChanger, 0)); // need to reset the allowance to 0 before setting a new one\n', '        assert(etherToken.approve(tokenChanger, msg.value)); // approve the changer to use the ETH amount for the purchase\n', '\n', '        ISmartToken smartToken = tokenChanger.token();\n', '        uint256 returnAmount = tokenChanger.change(etherToken, smartToken, msg.value, 1); // do the actual change using the current price\n', '        assert(smartToken.transfer(msg.sender, returnAmount)); // transfer the tokens to the sender\n', '        return returnAmount;\n', '    }\n', '\n', '    // fallback\n', '    function() payable {\n', '        buy();\n', '    }\n', '}']
