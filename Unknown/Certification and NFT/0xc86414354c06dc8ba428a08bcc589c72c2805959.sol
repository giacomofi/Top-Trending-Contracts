['pragma solidity ^0.4.2;\n', '\n', 'contract owned \n', '{\n', '\taddress public owner;\n', '\n', '\tfunction owned() \n', '\t{\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner \n', '\t{\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner \n', '\t{\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract tokenRecipient \n', '{ \n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \n', '}\n', '\n', 'library MathFunction \n', '{\n', '    // standard uint256 functions\n', '\n', '    function plus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function minus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function multiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function divide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '    \n', '    // uint256 function\n', '\n', '    function hplus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hminus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function hdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    // BIG math\n', '\n', '    uint256 constant BIG = 10 ** 18;\n', '\n', '    function wplus(uint256 x, uint256 y) constant internal returns (uint256) {\n', '        return hplus(x, y);\n', '    }\n', '\n', '    function wminus(uint256 x, uint256 y) constant internal returns (uint256) {\n', '        return hminus(x, y);\n', '    }\n', '\n', '    function wmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = cast((uint256(x) * y + BIG / 2) / BIG);\n', '    }\n', '\n', '    function wdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = cast((uint256(x) * BIG + y / 2) / y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint256 z) {\n', '        assert((z = uint256(x)) == x);\n', '    }\n', '}\n', '\n', 'contract ERC20 \n', '{\n', '    function totalSupply() constant returns (uint _totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract token is owned, ERC20\n', '{\n', '\tusing MathFunction for uint256;\n', '\t\n', '\t// Public variables\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\t\n', '\tmapping (address => uint256) public contrubutedAmount;\n', '\tmapping (address => uint256) public balanceOf;\t\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all balances\n', '\tmapping (address => mapping (address => uint256)) public allowance;\t\t\t\t\t\t\t\t// Creates an array with allowed amount of tokens for sender\n', '\t\n', '\tmodifier onlyContributer\n', '\t{\n', '\t\trequire(balanceOf[msg.sender] > 0);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t// Initializes contract with name, symbol, decimal and total supply\n', '\tfunction token() \n', '\t{\t\t\n', '\t\ttotalSupply = 166000;  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Update total supply\n', '\t\ttotalSupply = totalSupply.multiply(10 ** 18);\n', '\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\tname = "Global Academy Place";               \t\t\t\t\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tsymbol = "GAP";                                \t\t\t\t\t\t\t\t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t\t\t\t\t\t\t\t\t// Amount of decimals for display purposes\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) \n', '\t{\n', '\t\treturn balanceOf[_owner];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Get the balance\n', '\t}\n', '\t\n', '\tfunction totalSupply() constant returns (uint256 _totalSupply)\n', '\t{\n', '\t    return totalSupply;\n', '\t}\n', '  \n', '\tfunction transfer(address _to, uint256 _value) returns (bool success) \n', '\t{\n', '\t\trequire(balanceOf[msg.sender] >= _value);\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough    \n', '\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\n', '\t\t\t\t\t\t\t\t\n', '\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(_value);                     \t\t\t// Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\n', '\t\t\n', '\t\tTransfer(msg.sender, _to, _value);                   \t\t\t\t\t\t\t\t\t\t// Notify anyone listening that this transfer took place\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t// A contract attempts to get the coins\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success)\t\t\t\n', '\t{\n', '\t\trequire(_value <= balanceOf[_from]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\n', '\t\trequire(_value <= allowance[_from][msg.sender]);\t\t\t\t\t\t\t\t\t\t\t// Check allowance\n', '  \t\t\t\t\t\t\t\t\t\n', '\t\tbalanceOf[_from] = balanceOf[_from].minus(_value);                          \t\t\t\t// Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\n', '\t\tallowance[_from][msg.sender] = allowance[_from][msg.sender].minus(_value);\t\t\t\t\t// Decrease the allowence of sender\n', '\t\t\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Allow another contract to spend some tokens in your behalf \n', '\tfunction approve(address _spender, uint256 _value)\treturns (bool success) \t\t\t\t\t\t\n', '\t{\n', '\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\n', '\t\t\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t// Approve and then communicate the approved contract in a single tx\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) \n', '\t{    \n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) \n', '\t\t{\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\t\n', '\t\n', '\t// Function to check the amount of tokens that an owner allowed to a spender\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) \n', '\t{\n', '\t\treturn allowance[_owner][_spender];\n', '\t}\n', '}\n', '\n', 'contract ICOToken is token\n', '{\n', '\t// Public variables\n', '\tstring public firstLevelPrice = "Token 0.0100 ETH per Token";\n', '\tstring public secondLevelPrice = "Token 0.0125 ETH per Token";\n', '\tstring public thirdLevelPrice = "Token 0.0166 ETH per Token";\n', '\tstring public CapLevelPrice = "Token 0.0250 ETH per Token";\n', '\tuint256 public _firstLevelEth;\n', '\tuint256 public _secondLevelEth;\n', '\tuint256 public _thirdLevelEth;\n', '\tuint256 public _capLevelEth;\n', '\tuint256 public buyPrice;\n', '\tuint256 public fundingGoal;\n', '\tuint256 public amountRaisedEth; \n', '\tuint256 public deadline;\n', '\tuint256 public maximumBuyBackPriceInCents;\n', '\tuint256 public maximumBuyBackAmountInCents;\n', '\tuint256 public maximumBuyBackAmountInWEI;\n', '\taddress public beneficiary;\t\n', '\t\n', '\tmapping (address => uint256) public KilledTokens;\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all killed tokens\n', '\t\n', '\t// Private variables\n', '\tuint256 _currentLevelEth;\n', '\tuint256 _currentLevelPrice;\n', '\tuint256 _nextLevelEth;\n', '\tuint256 _nextLevelPrice;\n', '\tuint256 _firstLevelPrice;\n', '\tuint256 _secondLevelPrice;\n', '\tuint256 _thirdLevelPrice;\n', '\tuint256 _capLevelPrice;\n', '\tuint256 _currentSupply;\n', '\tuint256 remainig;\n', '\tuint256 amount;\n', '\tuint256 TokensAmount;\n', '\tbool fundingGoalReached;\n', '\tbool crowdsaleClosed;\n', '\n', '\tevent GoalReached(address _beneficiary, uint amountRaised);\n', '\t\n', '\tmodifier afterDeadline() \n', '\t{\n', '\t\trequire(crowdsaleClosed);\n', '\t\t_;\n', '\t}\n', '\t \n', '\t// Initializes contract \n', '\t\n', '\tfunction ICOToken() token() \n', '\t{          \n', '\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\t\n', '\t\tbeneficiary = owner;\n', '\t\tfundingGoal = 1600 ether;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Funding Goal in Eth\n', '\t\tdeadline = 1506549600;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 54 720 minutes = 38 days\n', '\t\t\n', '\t\tfundingGoalReached = false;\n', '\t\tcrowdsaleClosed = false;\n', '\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_firstLevelEth = 600 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_firstLevelPrice = 10000000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_secondLevelEth = 1100 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_secondLevelPrice = 12500000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_thirdLevelEth = 1600 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_thirdLevelPrice = 16666666666666666;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_capLevelEth = 2501 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_capLevelPrice = 25000000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_currentLevelEth = _firstLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// In the beggining the current level is first level\n', '\t\t_currentLevelPrice = _firstLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Next level is the second one \n', '\t\t_nextLevelEth = _secondLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_nextLevelPrice = _secondLevelPrice;\t\t\t\t\t\t\t\t\t\t\n', '\t\t\n', '\t\tamountRaisedEth = 0;\n', '\t\tmaximumBuyBackAmountInWEI = 50000000000000000;\n', '\t}\n', '\t\n', '\t// Changes the level price when the current one is reached\n', '\t// Makes the current to be next \n', '\t// And next to be the following one\n', '\tfunction levelChanger() internal\t\t\t\t\t\t\n', '\t{\n', '\t\tif(_nextLevelPrice == _secondLevelPrice)\n', '\t\t{\n', '\t\t\t_currentLevelEth = _secondLevelEth;\n', '\t\t\t_currentLevelPrice = _secondLevelPrice;\n', '\t\t\t_nextLevelEth = _thirdLevelEth;\n', '\t\t\t_nextLevelPrice = _thirdLevelPrice;\n', '\t\t}\n', '\t\telse if(_nextLevelPrice == _thirdLevelPrice)\n', '\t\t{\n', '\t\t\t_currentLevelEth = _thirdLevelEth;\n', '\t\t\t_currentLevelPrice = _thirdLevelPrice;\n', '\t\t\t_nextLevelEth = _capLevelEth;\n', '\t\t\t_nextLevelPrice = _capLevelPrice;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t_currentLevelEth = _capLevelEth;\n', '\t\t\t_currentLevelPrice = _capLevelPrice;\n', '\t\t\t_nextLevelEth = _capLevelEth;\n', '\t\t\t_nextLevelPrice = _capLevelPrice;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Check if the tokens amount is bigger than total supply\n', '\tfunction safeCheck (uint256 _TokensAmount) internal\n', '\t{\n', '\t\trequire(_TokensAmount <= totalSupply);\n', '\t}\n', '\t\n', '\t// Calculates the tokens amount\n', '\tfunction tokensAmount() internal returns (uint256 _tokensAmount) \t\t\t\n', '\t{   \n', '\t\tamountRaisedEth = amountRaisedEth.wplus(amount);\n', '\t\tuint256 raisedForNextLevel = amountRaisedEth.wminus(_currentLevelEth);\n', '\t\tremainig = amount.minus(raisedForNextLevel);\n', '\t\tTokensAmount = (raisedForNextLevel.wdivide(_nextLevelPrice)).wplus(remainig.wdivide(_currentLevelPrice));\n', '\t\tbuyPrice = _nextLevelPrice;\n', '\t\tlevelChanger();\t\t\t\n', '\t\t\n', '\t\treturn TokensAmount;\n', '\t}\n', '\t\n', '\tfunction manualBuyPrice (uint256 _NewPrice) onlyOwner\n', '\t{\n', '\t\t_currentLevelPrice = _NewPrice;\n', '\t\tbuyPrice = _currentLevelPrice;\n', '\t}\n', '\t\n', '\t// The function without name is the default function that is called whenever anyone sends funds to a contract\n', '\tfunction buyTokens () payable         \t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tassert(!crowdsaleClosed);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the crowdsale is closed\n', '\t\n', '\t\tamount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Amount in ether\n', '\t\tassert(amountRaisedEth.plus(amount) <= _nextLevelEth);\t\t\t\t\t\t\t\t\t\t// Check if you are going to jump over one level (e.g. from first to third - not allowed)\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\n', '\t\tif(amountRaisedEth.plus(amount) > _currentLevelEth)\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t{\t\t\t\t\t\t\t\t\n', '\t\t\tTokensAmount = tokensAmount();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The current level is passed and calculate new buy price and change level\n', '\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\n', '\t\t}\t\t\t\t\t\t\n', '\t\telse\t\t\t\t\t\t\n', '\t\t{\t\t\t\t\t\t\n', '\t\t\tbuyPrice = _currentLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Use the current level buy price\n', '\t\t\tTokensAmount = amount.wdivide(buyPrice);\n', '\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\n', '\t\t\tamountRaisedEth = amountRaisedEth.plus(amount);\t\t\t\t\t\t\n', '\t\t}\t\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\n', '\t\t_currentSupply = _currentSupply.plus(TokensAmount);\n', '\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].plus(msg.value);\t\t\n', '\t\tbalanceOf[this] = balanceOf[this].minus(TokensAmount);\t\t\t\t\t\t\n', '\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].plus(TokensAmount);                   \t\t// Adds tokens amount to buyer&#39;s balance\n', '\t\tTransfer(this, msg.sender, TokensAmount);                \t\t\t\t\t\t\t\t\t// Execute an event reflecting the change\t\t\t\t\t\n', '\t\treturn;                                     \t            \t\t\t\t\t\t\t\t// Ends function and returns\n', '\t}\t\t\t\t\t\t\n', '\tfunction () payable   \n', '\t{\n', '\t\tbuyTokens();\n', '\t}\n', '\t// Checks if the goal or time limit has been reached and ends the campaign \n', '\tfunction CloseCrowdSale(uint256 _maximumBuyBackAmountInCents) internal \t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tif (amountRaisedEth >= fundingGoal)\n', '\t\t{\n', '\t\t\tfundingGoalReached = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the funding goal is reached\n', '\t\t\tGoalReached(beneficiary, amountRaisedEth);\n', '\t\t}\n', '\t\tcrowdsaleClosed = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Close the crowdsale\n', '\t\tmaximumBuyBackPriceInCents = _maximumBuyBackAmountInCents;            \t\t\t\t\t\t// Calculates the maximum buy back price\n', '\t\ttotalSupply = _currentSupply;\n', '\t\tbalanceOf[this] = 0;\n', '\t\tmaximumBuyBackAmountInCents = maximumBuyBackPriceInCents.multiply(totalSupply);\t\t\t\t// Calculates the max buy back amount in cents\n', '\t\tmaximumBuyBackAmountInWEI = maximumBuyBackAmountInWEI.multiply(totalSupply);\n', '\t}\n', '}\n', '\n', 'contract GAP is ICOToken\n', '{\t\n', '\t// Public variables\n', '\tstring public maximumBuyBack = "Token 0.05 ETH per Token";\t\t\t\t\t\t\t\t\t\t// Max price in ETH for buy back\n', '\tuint256 public KilledTillNow;\n', '\tuint256 public sellPrice;\n', '\tuint256 public mustToSellCourses;\n', '\tuint public depositsTillNow;\n', '\tuint public actualPriceInCents;\n', '\taddress public Killer;\t\n', '\t\n', '\tevent FundTransfer(address backer, uint amount, bool isContribution);\n', '\t\n', '\tfunction GAP() ICOToken()\n', '\t{\n', '\t\tKiller = 0;\n', '\t\tKilledTillNow = 0;\n', '\t\tsellPrice = 0;\n', '\t\tmustToSellCourses = 0;\n', '\t\tdepositsTillNow = 0;\n', '\t}\n', '\t\n', '\t// The contributers can check the actual price in wei before selling \n', '\tfunction checkActualPrice() returns (uint256 _sellPrice)\n', '\t{\n', '\t\treturn sellPrice;\n', '\t}\n', '\t\t\t\t\n', '\t// End the crowdsale and start buying back\t\t\t\n', '\t// Only owner can execute this function\t\t\t\n', '\tfunction BuyBackStart(uint256 actualSellPriceInWei, uint256 _mustToSellCourses, uint256 maxBuyBackPriceCents) onlyOwner\t\t\t\n', '\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\tCloseCrowdSale(maxBuyBackPriceCents);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\tsellPrice = actualSellPriceInWei;\n', '\t\tmustToSellCourses = _mustToSellCourses;\n', '\t}\t\t\t\n', '\t\n', '\tfunction deposit (uint _deposits, uint256 actualSellPriceInWei, uint _actualPriceInCents) onlyOwner payable\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tassert(_deposits < 100);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the deposits are less than 10\t\n', '\t\tdepositsTillNow = depositsTillNow.plus(_deposits);          \t\t\t\t\t\t\t\t// Increase the deposit counter\n', '\t\tassert(mustToSellCourses > 0);\n', '\t\tif(mustToSellCourses < _deposits)\n', '\t\t{\n', '\t\t\t_deposits = mustToSellCourses;\t\t\n', '\t\t}\n', '\t\tmustToSellCourses = mustToSellCourses.minus(_deposits);\t\t\t\t\t\t\t\t\t\t// Calculate the remaining amount of courses to sell\t\t\t\t\t\n', '\t\tsellPrice = actualSellPriceInWei;\n', '\t\tactualPriceInCents = _actualPriceInCents;\n', '\t}\t\n', '\t\t\t\t\n', '\tfunction sell(uint256 amount) onlyContributer returns (uint256 revenue)\t\t\t\n', '\t{\t\n', '\t    require(this.balance >= amount * sellPrice);                                                 // checks if the contract has enough ether to buy\n', '\t\trevenue = amount.multiply(sellPrice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The revenue you receive when you sell your tokens\n', '\t\tamount = amount.multiply(10 ** 18);\n', '\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(amount);                   \t\t\t\t// Subtracts the amount from seller&#39;s balance\n', '\t\tbalanceOf[Killer] = balanceOf[Killer].plus(amount);                         \t\t\t\t// Adds the amount to owner&#39;s balance\n', '\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(amount);\t\t\t\t\t\t\t// Calculates the killed tokens of the contibuter\n', '\t\tKilledTillNow = KilledTillNow.plus(amount);\t\t\t\t\t\t\t\t\t\t\t\t\t// Calculates all the killed tokens until now\n', '\t\t\t\n', '\t\tmsg.sender.transfer(revenue);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Sends ether to the seller: it&#39;s important // To do this last to prevent recursion attacks\n', '\t\t\n', '\t\tTransfer(msg.sender, Killer, amount);             \t\t\t\t\t\t\t\t\t\t\t// Executes an event reflecting on the change\n', '\t\treturn revenue;                                 \t\t\t\t\t\t\t\t\t\t\t// Ends function and returns the revenue\t\n', '\t}\n', '\t\n', '\tfunction ownerWithdrawal(uint256 amountInWei, address _to) onlyOwner\n', '\t{\t\t\t\t\t\t\n', '\t\tuint256 _value = amountInWei;\t\t\t\t\t\t\n', '\t\t_to.transfer(_value);\t\t\t\t\t\t\n', '\t}\n', '\t\n', '\tfunction safeWithdrawal() afterDeadline \t\t\t\n', '\t{\t\t\t\n', '\t\tif (!fundingGoalReached) \t\t\t\n', '\t\t{\t\t\t\n', '\t\t\tuint256 tokensAmount = balanceOf[msg.sender];\n', '\t\t\tuint256 amountForReturn = contrubutedAmount[msg.sender];\n', '\t\t\tbalanceOf[msg.sender] = 0;\n', '\t\t\tKilledTillNow = KilledTillNow.plus(tokensAmount);\n', '\t\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(tokensAmount);\n', '\t\t\trequire(tokensAmount > 0);\n', '\t\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].minus(amountForReturn);\n', '            msg.sender.transfer(amountForReturn);\n', '\t\t}\n', '\t\t\n', '\t\tif(fundingGoalReached && beneficiary == msg.sender)\n', '\t\t{\n', '\t\t\trequire(fundingGoalReached && beneficiary == msg.sender);\n', '\t\t\tbeneficiary.transfer(amountRaisedEth); \n', '\t\t}\n', '\t}\n', '}']
['pragma solidity ^0.4.2;\n', '\n', 'contract owned \n', '{\n', '\taddress public owner;\n', '\n', '\tfunction owned() \n', '\t{\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner \n', '\t{\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner \n', '\t{\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract tokenRecipient \n', '{ \n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \n', '}\n', '\n', 'library MathFunction \n', '{\n', '    // standard uint256 functions\n', '\n', '    function plus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function minus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function multiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function divide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '    \n', '    // uint256 function\n', '\n', '    function hplus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hminus(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function hdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    // BIG math\n', '\n', '    uint256 constant BIG = 10 ** 18;\n', '\n', '    function wplus(uint256 x, uint256 y) constant internal returns (uint256) {\n', '        return hplus(x, y);\n', '    }\n', '\n', '    function wminus(uint256 x, uint256 y) constant internal returns (uint256) {\n', '        return hminus(x, y);\n', '    }\n', '\n', '    function wmultiply(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = cast((uint256(x) * y + BIG / 2) / BIG);\n', '    }\n', '\n', '    function wdivide(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = cast((uint256(x) * BIG + y / 2) / y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint256 z) {\n', '        assert((z = uint256(x)) == x);\n', '    }\n', '}\n', '\n', 'contract ERC20 \n', '{\n', '    function totalSupply() constant returns (uint _totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract token is owned, ERC20\n', '{\n', '\tusing MathFunction for uint256;\n', '\t\n', '\t// Public variables\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\t\n', '\tmapping (address => uint256) public contrubutedAmount;\n', '\tmapping (address => uint256) public balanceOf;\t\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all balances\n', '\tmapping (address => mapping (address => uint256)) public allowance;\t\t\t\t\t\t\t\t// Creates an array with allowed amount of tokens for sender\n', '\t\n', '\tmodifier onlyContributer\n', '\t{\n', '\t\trequire(balanceOf[msg.sender] > 0);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t// Initializes contract with name, symbol, decimal and total supply\n', '\tfunction token() \n', '\t{\t\t\n', '\t\ttotalSupply = 166000;  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Update total supply\n', '\t\ttotalSupply = totalSupply.multiply(10 ** 18);\n', '\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\tname = "Global Academy Place";               \t\t\t\t\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tsymbol = "GAP";                                \t\t\t\t\t\t\t\t\t\t\t// Set the symbol for display purposes\n', '\t\tdecimals = 18;                            \t\t\t\t\t\t\t\t\t\t\t\t\t// Amount of decimals for display purposes\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) \n', '\t{\n', '\t\treturn balanceOf[_owner];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Get the balance\n', '\t}\n', '\t\n', '\tfunction totalSupply() constant returns (uint256 _totalSupply)\n', '\t{\n', '\t    return totalSupply;\n', '\t}\n', '  \n', '\tfunction transfer(address _to, uint256 _value) returns (bool success) \n', '\t{\n', '\t\trequire(balanceOf[msg.sender] >= _value);\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough    \n', '\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\n', '\t\t\t\t\t\t\t\t\n', '\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(_value);                     \t\t\t// Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\n', '\t\t\n', '\t\tTransfer(msg.sender, _to, _value);                   \t\t\t\t\t\t\t\t\t\t// Notify anyone listening that this transfer took place\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t// A contract attempts to get the coins\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success)\t\t\t\n', '\t{\n', '\t\trequire(_value <= balanceOf[_from]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(balanceOf[_to] <= balanceOf[_to].plus(_value));\t\t\t\t\t\t\t\t\t\t// Check for overflows\n', '\t\trequire(_value <= allowance[_from][msg.sender]);\t\t\t\t\t\t\t\t\t\t\t// Check allowance\n', '  \t\t\t\t\t\t\t\t\t\n', '\t\tbalanceOf[_from] = balanceOf[_from].minus(_value);                          \t\t\t\t// Subtract from the sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].plus(_value);                            \t\t\t\t\t// Add the same to the recipient\n', '\t\tallowance[_from][msg.sender] = allowance[_from][msg.sender].minus(_value);\t\t\t\t\t// Decrease the allowence of sender\n', '\t\t\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Allow another contract to spend some tokens in your behalf \n', '\tfunction approve(address _spender, uint256 _value)\treturns (bool success) \t\t\t\t\t\t\n', '\t{\n', '\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\n', '\t\t\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t// Approve and then communicate the approved contract in a single tx\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) \n', '\t{    \n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) \n', '\t\t{\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\t\n', '\t\n', '\t// Function to check the amount of tokens that an owner allowed to a spender\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) \n', '\t{\n', '\t\treturn allowance[_owner][_spender];\n', '\t}\n', '}\n', '\n', 'contract ICOToken is token\n', '{\n', '\t// Public variables\n', '\tstring public firstLevelPrice = "Token 0.0100 ETH per Token";\n', '\tstring public secondLevelPrice = "Token 0.0125 ETH per Token";\n', '\tstring public thirdLevelPrice = "Token 0.0166 ETH per Token";\n', '\tstring public CapLevelPrice = "Token 0.0250 ETH per Token";\n', '\tuint256 public _firstLevelEth;\n', '\tuint256 public _secondLevelEth;\n', '\tuint256 public _thirdLevelEth;\n', '\tuint256 public _capLevelEth;\n', '\tuint256 public buyPrice;\n', '\tuint256 public fundingGoal;\n', '\tuint256 public amountRaisedEth; \n', '\tuint256 public deadline;\n', '\tuint256 public maximumBuyBackPriceInCents;\n', '\tuint256 public maximumBuyBackAmountInCents;\n', '\tuint256 public maximumBuyBackAmountInWEI;\n', '\taddress public beneficiary;\t\n', '\t\n', '\tmapping (address => uint256) public KilledTokens;\t\t\t\t\t\t\t\t\t\t\t\t// This creates an array with all killed tokens\n', '\t\n', '\t// Private variables\n', '\tuint256 _currentLevelEth;\n', '\tuint256 _currentLevelPrice;\n', '\tuint256 _nextLevelEth;\n', '\tuint256 _nextLevelPrice;\n', '\tuint256 _firstLevelPrice;\n', '\tuint256 _secondLevelPrice;\n', '\tuint256 _thirdLevelPrice;\n', '\tuint256 _capLevelPrice;\n', '\tuint256 _currentSupply;\n', '\tuint256 remainig;\n', '\tuint256 amount;\n', '\tuint256 TokensAmount;\n', '\tbool fundingGoalReached;\n', '\tbool crowdsaleClosed;\n', '\n', '\tevent GoalReached(address _beneficiary, uint amountRaised);\n', '\t\n', '\tmodifier afterDeadline() \n', '\t{\n', '\t\trequire(crowdsaleClosed);\n', '\t\t_;\n', '\t}\n', '\t \n', '\t// Initializes contract \n', '\t\n', '\tfunction ICOToken() token() \n', '\t{          \n', '\t\tbalanceOf[msg.sender] = totalSupply;              \t\t\t\t\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\t\n', '\t\tbeneficiary = owner;\n', '\t\tfundingGoal = 1600 ether;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Funding Goal in Eth\n', '\t\tdeadline = 1506549600;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 54 720 minutes = 38 days\n', '\t\t\n', '\t\tfundingGoalReached = false;\n', '\t\tcrowdsaleClosed = false;\n', '\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_firstLevelEth = 600 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_firstLevelPrice = 10000000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_secondLevelEth = 1100 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_secondLevelPrice = 12500000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_thirdLevelEth = 1600 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_thirdLevelPrice = 16666666666666666;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_capLevelEth = 2501 ether;\t\t\t\t\t\t\t\t\t\t\n', '\t\t_capLevelPrice = 25000000000000000;\t\t\t\t\t\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_currentLevelEth = _firstLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// In the beggining the current level is first level\n', '\t\t_currentLevelPrice = _firstLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Next level is the second one \n', '\t\t_nextLevelEth = _secondLevelEth;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t_nextLevelPrice = _secondLevelPrice;\t\t\t\t\t\t\t\t\t\t\n', '\t\t\n', '\t\tamountRaisedEth = 0;\n', '\t\tmaximumBuyBackAmountInWEI = 50000000000000000;\n', '\t}\n', '\t\n', '\t// Changes the level price when the current one is reached\n', '\t// Makes the current to be next \n', '\t// And next to be the following one\n', '\tfunction levelChanger() internal\t\t\t\t\t\t\n', '\t{\n', '\t\tif(_nextLevelPrice == _secondLevelPrice)\n', '\t\t{\n', '\t\t\t_currentLevelEth = _secondLevelEth;\n', '\t\t\t_currentLevelPrice = _secondLevelPrice;\n', '\t\t\t_nextLevelEth = _thirdLevelEth;\n', '\t\t\t_nextLevelPrice = _thirdLevelPrice;\n', '\t\t}\n', '\t\telse if(_nextLevelPrice == _thirdLevelPrice)\n', '\t\t{\n', '\t\t\t_currentLevelEth = _thirdLevelEth;\n', '\t\t\t_currentLevelPrice = _thirdLevelPrice;\n', '\t\t\t_nextLevelEth = _capLevelEth;\n', '\t\t\t_nextLevelPrice = _capLevelPrice;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\t_currentLevelEth = _capLevelEth;\n', '\t\t\t_currentLevelPrice = _capLevelPrice;\n', '\t\t\t_nextLevelEth = _capLevelEth;\n', '\t\t\t_nextLevelPrice = _capLevelPrice;\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Check if the tokens amount is bigger than total supply\n', '\tfunction safeCheck (uint256 _TokensAmount) internal\n', '\t{\n', '\t\trequire(_TokensAmount <= totalSupply);\n', '\t}\n', '\t\n', '\t// Calculates the tokens amount\n', '\tfunction tokensAmount() internal returns (uint256 _tokensAmount) \t\t\t\n', '\t{   \n', '\t\tamountRaisedEth = amountRaisedEth.wplus(amount);\n', '\t\tuint256 raisedForNextLevel = amountRaisedEth.wminus(_currentLevelEth);\n', '\t\tremainig = amount.minus(raisedForNextLevel);\n', '\t\tTokensAmount = (raisedForNextLevel.wdivide(_nextLevelPrice)).wplus(remainig.wdivide(_currentLevelPrice));\n', '\t\tbuyPrice = _nextLevelPrice;\n', '\t\tlevelChanger();\t\t\t\n', '\t\t\n', '\t\treturn TokensAmount;\n', '\t}\n', '\t\n', '\tfunction manualBuyPrice (uint256 _NewPrice) onlyOwner\n', '\t{\n', '\t\t_currentLevelPrice = _NewPrice;\n', '\t\tbuyPrice = _currentLevelPrice;\n', '\t}\n', '\t\n', '\t// The function without name is the default function that is called whenever anyone sends funds to a contract\n', '\tfunction buyTokens () payable         \t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tassert(!crowdsaleClosed);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the crowdsale is closed\n', '\t\n', '\t\tamount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Amount in ether\n', '\t\tassert(amountRaisedEth.plus(amount) <= _nextLevelEth);\t\t\t\t\t\t\t\t\t\t// Check if you are going to jump over one level (e.g. from first to third - not allowed)\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\n', '\t\tif(amountRaisedEth.plus(amount) > _currentLevelEth)\t\t\t\t\t\t\t\t\t\t\t\n', '\t\t{\t\t\t\t\t\t\t\t\n', '\t\t\tTokensAmount = tokensAmount();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The current level is passed and calculate new buy price and change level\n', '\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\n', '\t\t}\t\t\t\t\t\t\n', '\t\telse\t\t\t\t\t\t\n', '\t\t{\t\t\t\t\t\t\n', '\t\t\tbuyPrice = _currentLevelPrice;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Use the current level buy price\n', '\t\t\tTokensAmount = amount.wdivide(buyPrice);\n', '\t\t\tsafeCheck(TokensAmount);\t\t\t\t\t\t\n', '\t\t\tamountRaisedEth = amountRaisedEth.plus(amount);\t\t\t\t\t\t\n', '\t\t}\t\t\t\t\t\t\n', '\t\t\t\t\t\t\t\t\n', '\t\t_currentSupply = _currentSupply.plus(TokensAmount);\n', '\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].plus(msg.value);\t\t\n', '\t\tbalanceOf[this] = balanceOf[this].minus(TokensAmount);\t\t\t\t\t\t\n', "\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].plus(TokensAmount);                   \t\t// Adds tokens amount to buyer's balance\n", '\t\tTransfer(this, msg.sender, TokensAmount);                \t\t\t\t\t\t\t\t\t// Execute an event reflecting the change\t\t\t\t\t\n', '\t\treturn;                                     \t            \t\t\t\t\t\t\t\t// Ends function and returns\n', '\t}\t\t\t\t\t\t\n', '\tfunction () payable   \n', '\t{\n', '\t\tbuyTokens();\n', '\t}\n', '\t// Checks if the goal or time limit has been reached and ends the campaign \n', '\tfunction CloseCrowdSale(uint256 _maximumBuyBackAmountInCents) internal \t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tif (amountRaisedEth >= fundingGoal)\n', '\t\t{\n', '\t\t\tfundingGoalReached = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Checks if the funding goal is reached\n', '\t\t\tGoalReached(beneficiary, amountRaisedEth);\n', '\t\t}\n', '\t\tcrowdsaleClosed = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Close the crowdsale\n', '\t\tmaximumBuyBackPriceInCents = _maximumBuyBackAmountInCents;            \t\t\t\t\t\t// Calculates the maximum buy back price\n', '\t\ttotalSupply = _currentSupply;\n', '\t\tbalanceOf[this] = 0;\n', '\t\tmaximumBuyBackAmountInCents = maximumBuyBackPriceInCents.multiply(totalSupply);\t\t\t\t// Calculates the max buy back amount in cents\n', '\t\tmaximumBuyBackAmountInWEI = maximumBuyBackAmountInWEI.multiply(totalSupply);\n', '\t}\n', '}\n', '\n', 'contract GAP is ICOToken\n', '{\t\n', '\t// Public variables\n', '\tstring public maximumBuyBack = "Token 0.05 ETH per Token";\t\t\t\t\t\t\t\t\t\t// Max price in ETH for buy back\n', '\tuint256 public KilledTillNow;\n', '\tuint256 public sellPrice;\n', '\tuint256 public mustToSellCourses;\n', '\tuint public depositsTillNow;\n', '\tuint public actualPriceInCents;\n', '\taddress public Killer;\t\n', '\t\n', '\tevent FundTransfer(address backer, uint amount, bool isContribution);\n', '\t\n', '\tfunction GAP() ICOToken()\n', '\t{\n', '\t\tKiller = 0;\n', '\t\tKilledTillNow = 0;\n', '\t\tsellPrice = 0;\n', '\t\tmustToSellCourses = 0;\n', '\t\tdepositsTillNow = 0;\n', '\t}\n', '\t\n', '\t// The contributers can check the actual price in wei before selling \n', '\tfunction checkActualPrice() returns (uint256 _sellPrice)\n', '\t{\n', '\t\treturn sellPrice;\n', '\t}\n', '\t\t\t\t\n', '\t// End the crowdsale and start buying back\t\t\t\n', '\t// Only owner can execute this function\t\t\t\n', '\tfunction BuyBackStart(uint256 actualSellPriceInWei, uint256 _mustToSellCourses, uint256 maxBuyBackPriceCents) onlyOwner\t\t\t\n', '\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\tCloseCrowdSale(maxBuyBackPriceCents);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t\tsellPrice = actualSellPriceInWei;\n', '\t\tmustToSellCourses = _mustToSellCourses;\n', '\t}\t\t\t\n', '\t\n', '\tfunction deposit (uint _deposits, uint256 actualSellPriceInWei, uint _actualPriceInCents) onlyOwner payable\t\t\t\t\t\t\t\t\t\t\t\t\n', '\t{\n', '\t\tassert(_deposits < 100);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the deposits are less than 10\t\n', '\t\tdepositsTillNow = depositsTillNow.plus(_deposits);          \t\t\t\t\t\t\t\t// Increase the deposit counter\n', '\t\tassert(mustToSellCourses > 0);\n', '\t\tif(mustToSellCourses < _deposits)\n', '\t\t{\n', '\t\t\t_deposits = mustToSellCourses;\t\t\n', '\t\t}\n', '\t\tmustToSellCourses = mustToSellCourses.minus(_deposits);\t\t\t\t\t\t\t\t\t\t// Calculate the remaining amount of courses to sell\t\t\t\t\t\n', '\t\tsellPrice = actualSellPriceInWei;\n', '\t\tactualPriceInCents = _actualPriceInCents;\n', '\t}\t\n', '\t\t\t\t\n', '\tfunction sell(uint256 amount) onlyContributer returns (uint256 revenue)\t\t\t\n', '\t{\t\n', '\t    require(this.balance >= amount * sellPrice);                                                 // checks if the contract has enough ether to buy\n', '\t\trevenue = amount.multiply(sellPrice);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The revenue you receive when you sell your tokens\n', '\t\tamount = amount.multiply(10 ** 18);\n', "\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].minus(amount);                   \t\t\t\t// Subtracts the amount from seller's balance\n", "\t\tbalanceOf[Killer] = balanceOf[Killer].plus(amount);                         \t\t\t\t// Adds the amount to owner's balance\n", '\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(amount);\t\t\t\t\t\t\t// Calculates the killed tokens of the contibuter\n', '\t\tKilledTillNow = KilledTillNow.plus(amount);\t\t\t\t\t\t\t\t\t\t\t\t\t// Calculates all the killed tokens until now\n', '\t\t\t\n', "\t\tmsg.sender.transfer(revenue);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Sends ether to the seller: it's important // To do this last to prevent recursion attacks\n", '\t\t\n', '\t\tTransfer(msg.sender, Killer, amount);             \t\t\t\t\t\t\t\t\t\t\t// Executes an event reflecting on the change\n', '\t\treturn revenue;                                 \t\t\t\t\t\t\t\t\t\t\t// Ends function and returns the revenue\t\n', '\t}\n', '\t\n', '\tfunction ownerWithdrawal(uint256 amountInWei, address _to) onlyOwner\n', '\t{\t\t\t\t\t\t\n', '\t\tuint256 _value = amountInWei;\t\t\t\t\t\t\n', '\t\t_to.transfer(_value);\t\t\t\t\t\t\n', '\t}\n', '\t\n', '\tfunction safeWithdrawal() afterDeadline \t\t\t\n', '\t{\t\t\t\n', '\t\tif (!fundingGoalReached) \t\t\t\n', '\t\t{\t\t\t\n', '\t\t\tuint256 tokensAmount = balanceOf[msg.sender];\n', '\t\t\tuint256 amountForReturn = contrubutedAmount[msg.sender];\n', '\t\t\tbalanceOf[msg.sender] = 0;\n', '\t\t\tKilledTillNow = KilledTillNow.plus(tokensAmount);\n', '\t\t\tKilledTokens[msg.sender] = KilledTokens[msg.sender].plus(tokensAmount);\n', '\t\t\trequire(tokensAmount > 0);\n', '\t\t\tcontrubutedAmount[msg.sender] = contrubutedAmount[msg.sender].minus(amountForReturn);\n', '            msg.sender.transfer(amountForReturn);\n', '\t\t}\n', '\t\t\n', '\t\tif(fundingGoalReached && beneficiary == msg.sender)\n', '\t\t{\n', '\t\t\trequire(fundingGoalReached && beneficiary == msg.sender);\n', '\t\t\tbeneficiary.transfer(amountRaisedEth); \n', '\t\t}\n', '\t}\n', '}']
