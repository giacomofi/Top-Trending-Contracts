['pragma solidity ^0.4.15;\n', '\n', '// MMMMWKkk0KNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMXl.....,cdOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo:,.....dNMMMM //\n', '// MMMWd.        .&#39;cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0d:&#39;.        .xMMMM //\n', '// MMMK,   ......   ..:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.    .....    :XMMM //\n', '// MMWd.   .;;;,,&#39;..   .&#39;lkXNWWNNNWMMMMMMMMMMWNNWWWNKkc..  ...&#39;,;;;,.   .kMMM //\n', '// MMNc   .,::::::;,&#39;..   ..,;;,,dNMMMMMMMMMMXl,;;;,..   ..&#39;;;::::::&#39;.  .lWMM //\n', '// MM0&#39;   .;:::::::;;&#39;..        ;0MMMMMMMMMMMWO&#39;        ..,;;:::::::;.   ;KMM //\n', '// MMx.  .&#39;;::::;,&#39;...        .:0MMMMMMMMMMMMMWO;.        ...&#39;;;::::;..  .OMM //\n', '// MWd.  .,:::;&#39;..          .,xNMMMMMMMMMMMMMMMMXd&#39;.          ..,;:::&#39;.  .xMM //\n', '// MNl.  .,:;&#39;..         .,ckNMMMMMMMMMMMMMMMMMMMMXxc&#39;.         ..&#39;;:,.  .dWM //\n', '// MNc   .,,..    .;:clox0NWXXWMMMMMMMMMMMMMMMMMMWXXWXOxolc:;.    ..,&#39;.  .oWM //\n', '// MNc   ...     .oWMMMNXNMW0odXMMMMMMMMMMMMMMMMKooKWMNXNMMMNc.     ...  .oWM //\n', '// MNc.          ;KMMMMNkokNMXlcKMMMMMMMMMMMMMM0coNMNxoOWMMMM0,          .oWM //\n', '// MNc         .;0MMMMMMWO:dNMNoxWMMMMMMMMMMMMNddNMNocKMMMMMMWO,         .oWM //\n', '// MX:        .lXMMMMMMMMM0lOMMNXWMMMMMMMMMMMMWXNMMklKMMMMMMMMM0:.       .lNM //\n', '// MX;      .;kWMMMMMMMMMMMXNMMMMMMMMMMMMMMMMMMMMMMNNMMMMMMMMMMMNx,.      cNM //\n', '// MO.    .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNx:.  . ,0M //\n', '// Wl..&#39;:dKWMMMMMMMWNK000KNMMMMMMMMMMMMMMMMMMMMMMMMMWNK000KNMMMMMMMMW0o;...dW //\n', '// NxdOXWMMMMMMMW0olcc::;,,cxXWMMMMMMMMMMMMMMMMMMWKd:,,;::ccld0WMMMMMMMWKkokW //\n', '// MMMMMMMMMMMWOlcd0XWWWN0x:.,OMMMMMMMMMMMMMMMMMWk,&#39;cxKNWWWXOdcl0MMMMMMMMMMMM //\n', '// MMMMMMMMMMMWKKWMMMMMMMMMWK0XMMMMMMMMMMMMMMMMMMXOXWMMMMMMMMMN0XMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWK0OOOO0KWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNo.......&#39;xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMNKOkkkk0XNMMMMMMMMMMMMMMMMMMWO;.    .:0WMMMMMMMMMMMMMMMMMWNKOkkkkOKNMMM //\n', '// MMWXOkxddoddxxkKWMMMMMMMMMMMMMMMMXo...&#39;dNMMMMMMMMMMMMMMMMN0kxxdodddxk0XMMM //\n', '// MMMMMMMMMMMMWNKKNMMMMMMMMMMMMMMMMWOc,,c0WMMMMMMMMMMMMMMMMXKKNWMMMMMMMMMMMM //\n', '// MMMMMMMMWXKKXXNWMMMMMMMMMMWWWWWX0xcclc:cxKNWWWWWMMMMMMMMMMWNXXKKXWMMMMMMMM //\n', '// MMMWXOxdoooddxkO0NMMMMMMMWKkxxdlloxKNX0dolodxxkXMMMMMMMWX0OkxddooddxOXWMMM //\n', '// MMMWXKKNNWMMMMMWWWMMMMMMMMMWNXXXNWMMMMMMWXXXXNWMMMMMMMMMWWWMMMMWWNXKKNWMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Lucky  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Number MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM ------ MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Random MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MM Contract design by MMMMMMMMMMM Ledger MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// => 0x7C601D5DCd97B680dd623ff816D233898e6AD8dC <=MMMMMMM +.+.+. -> MMXVII M //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '\n', '\n', '// Manages contract ownership.\n', 'contract Owned {\n', '    address public owner;\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Mortal is Owned {\n', '    /* Function to recover the funds on the contract */\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '}\n', '\n', '// Random is a block hash based random number generator.\n', '// this is public so requestors can validate thier numbers\n', '// independent of the native user interface\n', 'contract Random is SafeMath {\n', '    // Generates a random number from 1 to max based on the last block hash.\n', '    function getRand(uint blockNumber, uint max)\n', '    public\n', '    constant \n', '    returns(uint) {\n', '        // block.blockhash(uint blockNumber) returns (bytes32): hash of the given block\n', '        // only works for 256 most recent blocks excluding current\n', '        return(safeAdd(uint(sha3(block.blockhash(blockNumber))) % max, 1));\n', '    }\n', '}\n', '\n', '// LuckyNumber is the main public interface for a random number ledger.\n', '// To make a request:\n', '//   Step 1: Call requestNumber with the `cost` as the value\n', '//   Step 2: Wait waitTime in blocks past the block which mines transaction for requestNumber\n', '//   Step 3: Call revealNumber() to generate the number, and make it publicly accessable in the UI.\n', '//           this is required to create the Events which generate the Ledger. \n', 'contract LuckyNumber is Owned {\n', '    // cost to generate a random number in Wei.\n', '    uint256 public cost;\n', '    // waitTime is the number of blocks before random is generated.\n', '    uint8 public waitTime;\n', '    // set default max\n', '    uint256 public max;\n', '\n', '    // PendingNumber represents one number.\n', '    struct PendingNumber {\n', '        address proxy;\n', '        uint256 renderedNumber;\n', '        uint256 creationBlockNumber;\n', '        uint256 max;\n', '        // block to wait\n', '        // this will also be used as\n', '        // an active bool to save some storage\n', '        uint8 waitTime;\n', '    }\n', '\n', '    // for Number Config\n', '    event EventLuckyNumberUpdated(uint256 cost, uint256 max, uint8 waitTime);\n', '    // for Number Ledger\n', '    event EventLuckyNumberRequested(address requestor, uint256 max, uint256 creationBlockNumber, uint8 waitTime);\n', '    event EventLuckyNumberRevealed(address requestor, uint256 max, uint256 renderedNumber);\n', '    \n', '    mapping (address => PendingNumber) public pendingNumbers;\n', '    mapping (address => bool) public whiteList;\n', '\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;\n', '    function revealNumber(address _requestor) payable public;\n', '}\n', '\n', '// LuckyNumber Implementation\n', 'contract LuckyNumberImp is LuckyNumber, Mortal, Random {\n', '    \n', '    // Initialize state +.+.+.\n', '    function LuckyNumberImp() {\n', '        owned();\n', '        // defaults\n', '        cost = 20000000000000000; // 0.02 ether // 20 finney\n', '        max = 15; // generate number between 1 and 15\n', '        waitTime = 3; // 3 blocks\n', '    }\n', '\n', '    // Allow the owner to set proxy contracts\n', '    // which can accept tokens\n', '    // on behalf of this contract\n', '    function enableProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        // _cost\n', '        whiteList[_proxy] = true;\n', '        return whiteList[_proxy];\n', '    }\n', '\n', '    function removeProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        delete whiteList[_proxy];\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set max.\n', '    function setMax(uint256 _max)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        max = _max;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set waitTime. (in blocks)\n', '    function setWaitTime(uint8 _waitTime)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        waitTime = _waitTime;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set cost.\n', '    function setCost(uint256 _cost)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        cost = _cost;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '    \n', '    // Allow the owner to cash out the holdings of this contract.\n', '    function withdraw(address _recipient, uint256 _balance)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        _recipient.transfer(_balance);\n', '        return true;\n', '    }\n', '\n', '    // Assume that simple transactions are trying to request a number, unless it is\n', '    // from the owner.\n', '    function () payable public {\n', '        if (msg.sender != owner) {\n', '            requestNumber(msg.sender, max, waitTime);\n', '        }\n', '    }\n', '    \n', '    // Request a Number.\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime)\n', '    payable \n', '    public {\n', '        // external requirement: \n', '        // value must exceed cost\n', '        // unless address is whitelisted\n', '        if (!whiteList[msg.sender]) {\n', '            require(!(msg.value < cost));\n', '        }\n', '\n', '        // internal requirement: \n', '        // request address must not have pending number\n', '        assert(!checkNumber(_requestor));\n', '        // set pending number\n', '        pendingNumbers[_requestor] = PendingNumber({\n', '            proxy: tx.origin,\n', '            renderedNumber: 0,\n', '            max: max,\n', '            creationBlockNumber: block.number,\n', '            waitTime: waitTime\n', '        });\n', '        if (_max > 1) {\n', '            pendingNumbers[_requestor].max = _max;\n', '        }\n', '        // max 250 wait to leave a few blocks\n', '        // for the reveal transction to occur\n', '        // and write from the pending numbers block\n', '        // before it expires\n', '        if (_waitTime > 0 && _waitTime < 250) {\n', '            pendingNumbers[_requestor].waitTime = _waitTime;\n', '        }\n', '        EventLuckyNumberRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '    // Only requestor or proxy can generate the number\n', '    function revealNumber(address _requestor)\n', '    public\n', '    payable {\n', '        assert(_canReveal(_requestor, msg.sender));\n', '        _revealNumber(_requestor);\n', '    }\n', '\n', '    // Internal implementation of revealNumber().\n', '    function _revealNumber(address _requestor) \n', '    internal {\n', '        // waitTime has passed, render this requestor&#39;s number.\n', '        uint256 luckyBlock = _revealBlock(_requestor);\n', '        // \n', '        // TIME LIMITATION:\n', '        // blocks older than (currentBlock - 256) \n', '        // "expire" and read the same hash as most recent valid block\n', '        // \n', '        uint256 luckyNumber = getRand(luckyBlock, pendingNumbers[_requestor].max);\n', '\n', '        // set new values\n', '        pendingNumbers[_requestor].renderedNumber = luckyNumber;\n', '        // event\n', '        EventLuckyNumberRevealed(_requestor, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].renderedNumber);\n', '        // zero out wait blocks since this is now inactive\n', '        pendingNumbers[_requestor].waitTime = 0;\n', '        // update creation block as one use for number (record keeping)\n', '        pendingNumbers[_requestor].creationBlockNumber = 0;\n', '    }\n', '\n', '    function canReveal(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool, uint, uint, address, address) {\n', '        return (_canReveal(_requestor, msg.sender), _remainingBlocks(_requestor), _revealBlock(_requestor), _requestor, msg.sender);\n', '    }\n', '\n', '    function _canReveal(address _requestor, address _proxy) \n', '    internal\n', '    constant\n', '    returns (bool) {\n', '        // check for pending number request\n', '        if (checkNumber(_requestor)) {\n', '            // check for no remaining blocks to be mined\n', '            // must wait for `pendingNumbers[_requestor].waitTime` to be excceeded\n', '            if (_remainingBlocks(_requestor) == 0) {\n', '                // check for ownership\n', '                if (pendingNumbers[_requestor].proxy == _requestor || pendingNumbers[_requestor].proxy == _proxy) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _remainingBlocks(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        uint256 revealBlock = safeAdd(pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '        uint256 remainingBlocks = 0;\n', '        if (revealBlock > block.number) {\n', '            remainingBlocks = safeSubtract(revealBlock, block.number);\n', '        }\n', '        return remainingBlocks;\n', '    }\n', '\n', '    function _revealBlock(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        // add wait block time\n', '        // to creation block time\n', '        // then subtract 1\n', '        return safeAdd(pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '\n', '    function getNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (uint, uint, uint, address) {\n', '        return (pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, _requestor);\n', '    }\n', '\n', '    // is a number pending for this requestor?\n', '    // TRUE: there is a number pending\n', '    // can not request, can reveal\n', '    // FALSE: there is not a number yet pending\n', '    function checkNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool) {\n', '        if (pendingNumbers[_requestor].renderedNumber == 0 && pendingNumbers[_requestor].waitTime > 0) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '// 0xMMWKkk0KNM>HBBi\\MASSa\\DANTi\\LANTen.MI.MI.MI.M+.+.+.M->MMMWNKOkOKWJ.J.J.M //\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '// MMMMWKkk0KNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMXl.....,cdOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo:,.....dNMMMM //\n', "// MMMWd.        .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0d:'.        .xMMMM //\n", '// MMMK,   ......   ..:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.    .....    :XMMM //\n', "// MMWd.   .;;;,,'..   .'lkXNWWNNNWMMMMMMMMMMWNNWWWNKkc..  ...',;;;,.   .kMMM //\n", "// MMNc   .,::::::;,'..   ..,;;,,dNMMMMMMMMMMXl,;;;,..   ..';;::::::'.  .lWMM //\n", "// MM0'   .;:::::::;;'..        ;0MMMMMMMMMMMWO'        ..,;;:::::::;.   ;KMM //\n", "// MMx.  .';::::;,'...        .:0MMMMMMMMMMMMMWO;.        ...';;::::;..  .OMM //\n", "// MWd.  .,:::;'..          .,xNMMMMMMMMMMMMMMMMXd'.          ..,;:::'.  .xMM //\n", "// MNl.  .,:;'..         .,ckNMMMMMMMMMMMMMMMMMMMMXxc'.         ..';:,.  .dWM //\n", "// MNc   .,,..    .;:clox0NWXXWMMMMMMMMMMMMMMMMMMWXXWXOxolc:;.    ..,'.  .oWM //\n", '// MNc   ...     .oWMMMNXNMW0odXMMMMMMMMMMMMMMMMKooKWMNXNMMMNc.     ...  .oWM //\n', '// MNc.          ;KMMMMNkokNMXlcKMMMMMMMMMMMMMM0coNMNxoOWMMMM0,          .oWM //\n', '// MNc         .;0MMMMMMWO:dNMNoxWMMMMMMMMMMMMNddNMNocKMMMMMMWO,         .oWM //\n', '// MX:        .lXMMMMMMMMM0lOMMNXWMMMMMMMMMMMMWXNMMklKMMMMMMMMM0:.       .lNM //\n', '// MX;      .;kWMMMMMMMMMMMXNMMMMMMMMMMMMMMMMMMMMMMNNMMMMMMMMMMMNx,.      cNM //\n', '// MO.    .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNx:.  . ,0M //\n', "// Wl..':dKWMMMMMMMWNK000KNMMMMMMMMMMMMMMMMMMMMMMMMMWNK000KNMMMMMMMMW0o;...dW //\n", '// NxdOXWMMMMMMMW0olcc::;,,cxXWMMMMMMMMMMMMMMMMMMWKd:,,;::ccld0WMMMMMMMWKkokW //\n', "// MMMMMMMMMMMWOlcd0XWWWN0x:.,OMMMMMMMMMMMMMMMMMWk,'cxKNWWWXOdcl0MMMMMMMMMMMM //\n", '// MMMMMMMMMMMWKKWMMMMMMMMMWK0XMMMMMMMMMMMMMMMMMMXOXWMMMMMMMMMN0XMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWK0OOOO0KWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', "// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNo.......'xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n", '// MMMNKOkkkk0XNMMMMMMMMMMMMMMMMMMWO;.    .:0WMMMMMMMMMMMMMMMMMWNKOkkkkOKNMMM //\n', "// MMWXOkxddoddxxkKWMMMMMMMMMMMMMMMMXo...'dNMMMMMMMMMMMMMMMMN0kxxdodddxk0XMMM //\n", '// MMMMMMMMMMMMWNKKNMMMMMMMMMMMMMMMMWOc,,c0WMMMMMMMMMMMMMMMMXKKNWMMMMMMMMMMMM //\n', '// MMMMMMMMWXKKXXNWMMMMMMMMMMWWWWWX0xcclc:cxKNWWWWWMMMMMMMMMMWNXXKKXWMMMMMMMM //\n', '// MMMWXOxdoooddxkO0NMMMMMMMWKkxxdlloxKNX0dolodxxkXMMMMMMMWX0OkxddooddxOXWMMM //\n', '// MMMWXKKNNWMMMMMWWWMMMMMMMMMWNXXXNWMMMMMMWXXXXNWMMMMMMMMMWWWMMMMWWNXKKNWMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Lucky  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Number MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM ------ MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Random MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MM Contract design by MMMMMMMMMMM Ledger MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// => 0x7C601D5DCd97B680dd623ff816D233898e6AD8dC <=MMMMMMM +.+.+. -> MMXVII M //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '\n', '\n', '// Manages contract ownership.\n', 'contract Owned {\n', '    address public owner;\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Mortal is Owned {\n', '    /* Function to recover the funds on the contract */\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '}\n', '\n', '// Random is a block hash based random number generator.\n', '// this is public so requestors can validate thier numbers\n', '// independent of the native user interface\n', 'contract Random is SafeMath {\n', '    // Generates a random number from 1 to max based on the last block hash.\n', '    function getRand(uint blockNumber, uint max)\n', '    public\n', '    constant \n', '    returns(uint) {\n', '        // block.blockhash(uint blockNumber) returns (bytes32): hash of the given block\n', '        // only works for 256 most recent blocks excluding current\n', '        return(safeAdd(uint(sha3(block.blockhash(blockNumber))) % max, 1));\n', '    }\n', '}\n', '\n', '// LuckyNumber is the main public interface for a random number ledger.\n', '// To make a request:\n', '//   Step 1: Call requestNumber with the `cost` as the value\n', '//   Step 2: Wait waitTime in blocks past the block which mines transaction for requestNumber\n', '//   Step 3: Call revealNumber() to generate the number, and make it publicly accessable in the UI.\n', '//           this is required to create the Events which generate the Ledger. \n', 'contract LuckyNumber is Owned {\n', '    // cost to generate a random number in Wei.\n', '    uint256 public cost;\n', '    // waitTime is the number of blocks before random is generated.\n', '    uint8 public waitTime;\n', '    // set default max\n', '    uint256 public max;\n', '\n', '    // PendingNumber represents one number.\n', '    struct PendingNumber {\n', '        address proxy;\n', '        uint256 renderedNumber;\n', '        uint256 creationBlockNumber;\n', '        uint256 max;\n', '        // block to wait\n', '        // this will also be used as\n', '        // an active bool to save some storage\n', '        uint8 waitTime;\n', '    }\n', '\n', '    // for Number Config\n', '    event EventLuckyNumberUpdated(uint256 cost, uint256 max, uint8 waitTime);\n', '    // for Number Ledger\n', '    event EventLuckyNumberRequested(address requestor, uint256 max, uint256 creationBlockNumber, uint8 waitTime);\n', '    event EventLuckyNumberRevealed(address requestor, uint256 max, uint256 renderedNumber);\n', '    \n', '    mapping (address => PendingNumber) public pendingNumbers;\n', '    mapping (address => bool) public whiteList;\n', '\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;\n', '    function revealNumber(address _requestor) payable public;\n', '}\n', '\n', '// LuckyNumber Implementation\n', 'contract LuckyNumberImp is LuckyNumber, Mortal, Random {\n', '    \n', '    // Initialize state +.+.+.\n', '    function LuckyNumberImp() {\n', '        owned();\n', '        // defaults\n', '        cost = 20000000000000000; // 0.02 ether // 20 finney\n', '        max = 15; // generate number between 1 and 15\n', '        waitTime = 3; // 3 blocks\n', '    }\n', '\n', '    // Allow the owner to set proxy contracts\n', '    // which can accept tokens\n', '    // on behalf of this contract\n', '    function enableProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        // _cost\n', '        whiteList[_proxy] = true;\n', '        return whiteList[_proxy];\n', '    }\n', '\n', '    function removeProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        delete whiteList[_proxy];\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set max.\n', '    function setMax(uint256 _max)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        max = _max;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set waitTime. (in blocks)\n', '    function setWaitTime(uint8 _waitTime)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        waitTime = _waitTime;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set cost.\n', '    function setCost(uint256 _cost)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        cost = _cost;\n', '        EventLuckyNumberUpdated(cost, max, waitTime);\n', '        return true;\n', '    }\n', '    \n', '    // Allow the owner to cash out the holdings of this contract.\n', '    function withdraw(address _recipient, uint256 _balance)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        _recipient.transfer(_balance);\n', '        return true;\n', '    }\n', '\n', '    // Assume that simple transactions are trying to request a number, unless it is\n', '    // from the owner.\n', '    function () payable public {\n', '        if (msg.sender != owner) {\n', '            requestNumber(msg.sender, max, waitTime);\n', '        }\n', '    }\n', '    \n', '    // Request a Number.\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime)\n', '    payable \n', '    public {\n', '        // external requirement: \n', '        // value must exceed cost\n', '        // unless address is whitelisted\n', '        if (!whiteList[msg.sender]) {\n', '            require(!(msg.value < cost));\n', '        }\n', '\n', '        // internal requirement: \n', '        // request address must not have pending number\n', '        assert(!checkNumber(_requestor));\n', '        // set pending number\n', '        pendingNumbers[_requestor] = PendingNumber({\n', '            proxy: tx.origin,\n', '            renderedNumber: 0,\n', '            max: max,\n', '            creationBlockNumber: block.number,\n', '            waitTime: waitTime\n', '        });\n', '        if (_max > 1) {\n', '            pendingNumbers[_requestor].max = _max;\n', '        }\n', '        // max 250 wait to leave a few blocks\n', '        // for the reveal transction to occur\n', '        // and write from the pending numbers block\n', '        // before it expires\n', '        if (_waitTime > 0 && _waitTime < 250) {\n', '            pendingNumbers[_requestor].waitTime = _waitTime;\n', '        }\n', '        EventLuckyNumberRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '    // Only requestor or proxy can generate the number\n', '    function revealNumber(address _requestor)\n', '    public\n', '    payable {\n', '        assert(_canReveal(_requestor, msg.sender));\n', '        _revealNumber(_requestor);\n', '    }\n', '\n', '    // Internal implementation of revealNumber().\n', '    function _revealNumber(address _requestor) \n', '    internal {\n', "        // waitTime has passed, render this requestor's number.\n", '        uint256 luckyBlock = _revealBlock(_requestor);\n', '        // \n', '        // TIME LIMITATION:\n', '        // blocks older than (currentBlock - 256) \n', '        // "expire" and read the same hash as most recent valid block\n', '        // \n', '        uint256 luckyNumber = getRand(luckyBlock, pendingNumbers[_requestor].max);\n', '\n', '        // set new values\n', '        pendingNumbers[_requestor].renderedNumber = luckyNumber;\n', '        // event\n', '        EventLuckyNumberRevealed(_requestor, pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].renderedNumber);\n', '        // zero out wait blocks since this is now inactive\n', '        pendingNumbers[_requestor].waitTime = 0;\n', '        // update creation block as one use for number (record keeping)\n', '        pendingNumbers[_requestor].creationBlockNumber = 0;\n', '    }\n', '\n', '    function canReveal(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool, uint, uint, address, address) {\n', '        return (_canReveal(_requestor, msg.sender), _remainingBlocks(_requestor), _revealBlock(_requestor), _requestor, msg.sender);\n', '    }\n', '\n', '    function _canReveal(address _requestor, address _proxy) \n', '    internal\n', '    constant\n', '    returns (bool) {\n', '        // check for pending number request\n', '        if (checkNumber(_requestor)) {\n', '            // check for no remaining blocks to be mined\n', '            // must wait for `pendingNumbers[_requestor].waitTime` to be excceeded\n', '            if (_remainingBlocks(_requestor) == 0) {\n', '                // check for ownership\n', '                if (pendingNumbers[_requestor].proxy == _requestor || pendingNumbers[_requestor].proxy == _proxy) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _remainingBlocks(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        uint256 revealBlock = safeAdd(pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '        uint256 remainingBlocks = 0;\n', '        if (revealBlock > block.number) {\n', '            remainingBlocks = safeSubtract(revealBlock, block.number);\n', '        }\n', '        return remainingBlocks;\n', '    }\n', '\n', '    function _revealBlock(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        // add wait block time\n', '        // to creation block time\n', '        // then subtract 1\n', '        return safeAdd(pendingNumbers[_requestor].creationBlockNumber, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '\n', '    function getNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (uint, uint, uint, address) {\n', '        return (pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].max, pendingNumbers[_requestor].creationBlockNumber, _requestor);\n', '    }\n', '\n', '    // is a number pending for this requestor?\n', '    // TRUE: there is a number pending\n', '    // can not request, can reveal\n', '    // FALSE: there is not a number yet pending\n', '    function checkNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool) {\n', '        if (pendingNumbers[_requestor].renderedNumber == 0 && pendingNumbers[_requestor].waitTime > 0) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '// 0xMMWKkk0KNM>HBBi\\MASSa\\DANTi\\LANTen.MI.MI.MI.M+.+.+.M->MMMWNKOkOKWJ.J.J.M //\n', '}']
