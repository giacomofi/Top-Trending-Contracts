['// This software is a subject to Ambisafe License Agreement.\n', '// No use or distribution is allowed without written permission from Ambisafe.\n', '// https://ambisafe.com/terms.pdf\n', '\n', 'contract Ambi {\n', '    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n', '    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n', '    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n', '}\n', '\n', 'contract AmbiEnabled {\n', '    Ambi public ambiC;\n', '    bool public isImmortal;\n', '    bytes32 public name;\n', '\n', '    modifier checkAccess(bytes32 _role) {\n', '        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n', '            _\n', '        }\n', '    }\n', '    \n', '    function getAddress(bytes32 _name) constant returns (address) {\n', '        return ambiC.getNodeAddress(_name);\n', '    }\n', '\n', '    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n', '        if(address(ambiC) != 0x0){\n', '            return false;\n', '        }\n', '        Ambi ambiContract = Ambi(_ambi);\n', '        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n', '            if (!ambiContract.addNode(_name, address(this))){\n', '                return false;\n', '            }\n', '        }\n', '        name = _name;\n', '        ambiC = ambiContract;\n', '        return true;\n', '    }\n', '\n', '    function immortality() checkAccess("owner") returns(bool) {\n', '        isImmortal = true;\n', '        return true;\n', '    }\n', '\n', '    function remove() checkAccess("owner") returns(bool) {\n', '        if (isImmortal) {\n', '            return false;\n', '        }\n', '        selfdestruct(msg.sender);\n', '        return true;\n', '    }\n', '}\n', '\n', 'library StackDepthLib {\n', '    // This will probably work with a value of 390 but no need to cut it\n', '    // that close in the case that the optimizer changes slightly or\n', '    // something causing that number to rise slightly.\n', '    uint constant GAS_PER_DEPTH = 400;\n', '\n', '    function checkDepth(address self, uint n) constant returns(bool) {\n', '        if (n == 0) return true;\n', '        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n', '    }\n', '\n', '    function __dig(uint n) constant {\n', '        if (n == 0) return;\n', '        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n', '    }\n', '}\n', '\n', 'contract Safe {\n', '    // Should always be placed as first modifier!\n', '    modifier noValue {\n', '        if (msg.value > 0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: revert this transaction too;\n', '            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n', '            _safeSend(msg.sender, msg.value);\n', '        }\n', '        _\n', '    }\n', '\n', '    modifier onlyHuman {\n', '        if (_isHuman()) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier noCallback {\n', '        if (!isCall) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier immutable(address _address) {\n', '        if (_address == 0) {\n', '            _\n', '        }\n', '    }\n', '\n', '    address stackDepthLib;\n', '    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n', '        stackDepthLib = _stackDepthLib;\n', '        return true;\n', '    }\n', '\n', '    modifier requireStackDepth(uint16 _depth) {\n', '        if (stackDepthLib == 0x0) {\n', '            throw;\n', '        }\n', '        if (_depth > 1023) {\n', '            throw;\n', '        }\n', '        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n', '            throw;\n', '        }\n', '        _\n', '    }\n', '\n', '    // Must not be used inside the functions that have noValue() modifier!\n', '    function _safeFalse() internal noValue() returns(bool) {\n', '        return false;\n', '    }\n', '\n', '    function _safeSend(address _to, uint _value) internal {\n', '        if (!_unsafeSend(_to, _value)) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n', '        return _to.call.value(_value)();\n', '    }\n', '\n', '    function _isContract() constant internal returns(bool) {\n', '        return msg.sender != tx.origin;\n', '    }\n', '\n', '    function _isHuman() constant internal returns(bool) {\n', '        return !_isContract();\n', '    }\n', '\n', '    bool private isCall = false;\n', '    function _setupNoCallback() internal {\n', '        isCall = true;\n', '    }\n', '\n', '    function _finishNoCallback() internal {\n', '        isCall = false;\n', '    }\n', '}\n', '\n', 'contract RegistryICAP is AmbiEnabled, Safe {\n', '    function decodeIndirect(bytes _bban) constant returns(string, string, string) {\n', '        bytes memory asset = new bytes(3);\n', '        bytes memory institution = new bytes(4);\n', '        bytes memory client = new bytes(9);\n', '\n', '        uint8 k = 0;\n', '\n', '        for (uint8 i = 0; i < asset.length; i++) {\n', '            asset[i] = _bban[k++];\n', '        }\n', '        for (i = 0; i < institution.length; i++) {\n', '            institution[i] = _bban[k++];\n', '        }\n', '        for (i = 0; i < client.length; i++) {\n', '            client[i] = _bban[k++];\n', '        }\n', '        return (string(asset), string(institution), string(client));\n', '    }\n', '\n', '    function parse(bytes32 _icap) constant returns(address, bytes32, bool) {\n', '        // Should start with XE.\n', '        if (_icap[0] != 88 || _icap[1] != 69) {\n', '            return (0, 0, false);\n', '        }\n', '        // Should have 12 zero bytes at the end.\n', '        for (uint8 j = 20; j < 32; j++) {\n', '            if (_icap[j] != 0) {\n', '                return (0, 0, false);\n', '            }\n', '        }\n', '        bytes memory bban = new bytes(18);\n', '        for (uint8 i = 0; i < 16; i++) {\n', '             bban[i] = _icap[i + 4];\n', '        }\n', '        var (asset, institution, _) = decodeIndirect(bban);\n', '\n', '        bytes32 assetInstitutionHash = sha3(asset, institution);\n', '\n', '        uint8 parseChecksum = (uint8(_icap[2]) - 48) * 10 + (uint8(_icap[3]) - 48);\n', '        uint8 calcChecksum = 98 - mod9710(prepare(bban));\n', '        if (parseChecksum != calcChecksum) {\n', '            return (institutions[assetInstitutionHash], assets[sha3(asset)], false);\n', '        }\n', '        return (institutions[assetInstitutionHash], assets[sha3(asset)], registered[assetInstitutionHash]);\n', '    }\n', '\n', '    function prepare(bytes _bban) constant returns(bytes) {\n', '        for (uint8 i = 0; i < 16; i++) {\n', '            uint8 charCode = uint8(_bban[i]);\n', '            if (charCode >= 65 && charCode <= 90) {\n', '                _bban[i] = byte(charCode - 65 + 10);\n', '            }\n', '        }\n', '        _bban[16] = 33; // X\n', '        _bban[17] = 14; // E\n', '        //_bban[18] = 48; // 0\n', '        //_bban[19] = 48; // 0\n', '        return _bban;\n', '    }\n', '\n', '    function mod9710(bytes _prepared) constant returns(uint8) {\n', '        uint m = 0;\n', '        for (uint8 i = 0; i < 18; i++) {\n', '            uint8 charCode = uint8(_prepared[i]);\n', '            if (charCode >= 48) {\n', '                m *= 10;\n', '                m += charCode - 48; // number\n', '                m %= 97;\n', '            } else {\n', '                m *= 10;\n', '                m += charCode / 10; // part1\n', '                m %= 97;\n', '                m *= 10;\n', '                m += charCode % 10; // part2\n', '                m %= 97;\n', '            }\n', '        }\n', '        m *= 10;\n', '        //m += uint8(_prepared[18]) - 48;\n', '        m %= 97;\n', '        m *= 10;\n', '        //m += uint8(_prepared[19]) - 48;\n', '        m %= 97;\n', '        return uint8(m);\n', '    }\n', '\n', '    mapping(bytes32 => bool) public registered;\n', '    mapping(bytes32 => address) public institutions;\n', '    mapping(bytes32 => address) public institutionOwners;\n', '    mapping(bytes32 => bytes32) public assets;\n', '\n', '    modifier onlyInstitutionOwner(string _institution) {\n', '        if (msg.sender == institutionOwners[sha3(_institution)]) {\n', '            _\n', '        }\n', '    }\n', '\n', '    function changeInstitutionOwner(string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n', '        institutionOwners[sha3(_institution)] = _address;\n', '        return true;\n', '    }\n', '\n', '    // web3js sendIBANTransaction interface\n', '    function addr(bytes32 _institution) constant returns(address) {\n', '        return institutions[sha3("ETH", _institution[0], _institution[1], _institution[2], _institution[3])];\n', '    }\n', '\n', '    function registerInstitution(string _institution, address _address) noValue() checkAccess("admin") returns(bool) {\n', '        if (bytes(_institution).length != 4) {\n', '            return false;\n', '        }\n', '        if (institutionOwners[sha3(_institution)] != 0) {\n', '            return false;\n', '        }\n', '        institutionOwners[sha3(_institution)] = _address;\n', '        return true;\n', '    }\n', '\n', '    function registerInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n', '        if (!registered[sha3(_asset)]) {\n', '            return false;\n', '        }\n', '        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n', '        if (registered[assetInstitutionHash]) {\n', '            return false;\n', '        }\n', '        registered[assetInstitutionHash] = true;\n', '        institutions[assetInstitutionHash] = _address;\n', '        return true;\n', '    }\n', '\n', '    function updateInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n', '        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n', '        if (!registered[assetInstitutionHash]) {\n', '            return false;\n', '        }\n', '        institutions[assetInstitutionHash] = _address;\n', '        return true;\n', '    }\n', '\n', '    function removeInstitutionAsset(string _asset, string _institution) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n', '        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n', '        if (!registered[assetInstitutionHash]) {\n', '            return false;\n', '        }\n', '        delete registered[assetInstitutionHash];\n', '        delete institutions[assetInstitutionHash];\n', '        return true;\n', '    }\n', '\n', '    function registerAsset(string _asset, bytes32 _symbol) noValue() checkAccess("admin") returns(bool) {\n', '        if (bytes(_asset).length != 3) {\n', '            return false;\n', '        }\n', '        bytes32 asset = sha3(_asset);\n', '        if (registered[asset]) {\n', '            return false;\n', '        }\n', '        registered[asset] = true;\n', '        assets[asset] = _symbol;\n', '        return true;\n', '    }\n', '}']