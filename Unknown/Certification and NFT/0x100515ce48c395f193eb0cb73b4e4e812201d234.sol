['pragma solidity ^0.4.16;\n', '\n', 'contract SafeMath {\n', '     function safeMul(uint a, uint b) internal returns (uint) {\n', '          uint c = a * b;\n', '          assert(a == 0 || c / a == b);\n', '          return c;\n', '     }\n', '\n', '     function safeSub(uint a, uint b) internal returns (uint) {\n', '          assert(b <= a);\n', '          return a - b;\n', '     }\n', '\n', '     function safeAdd(uint a, uint b) internal returns (uint) {\n', '          uint c = a + b;\n', '          assert(c>=a && c>=b);\n', '          return c;\n', '     }\n', '}\n', '\n', '// Standard token interface (ERC 20)\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract Token is SafeMath {\n', '     // Functions:\n', '     /// @return total amount of tokens\n', '     function totalSupply() constant returns (uint256 supply) {}\n', '\n', '     /// @param _owner The address from which the balance will be retrieved\n', '     /// @return The balance\n', '     function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '     /// @notice send `_value` token to `_to` from `msg.sender`\n', '     /// @param _to The address of the recipient\n', '     /// @param _value The amount of token to be transferred\n', '     function transfer(address _to, uint256 _value) returns(bool) {}\n', '\n', '     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     /// @param _from The address of the sender\n', '     /// @param _to The address of the recipient\n', '     /// @param _value The amount of token to be transferred\n', '     /// @return Whether the transfer was successful or not\n', '     function transferFrom(address _from, address _to, uint256 _value)returns(bool){}\n', '\n', '     /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '     /// @param _spender The address of the account able to transfer the tokens\n', '     /// @param _value The amount of wei to be approved for transfer\n', '     /// @return Whether the approval was successful or not\n', '     function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '     /// @param _owner The address of the account owning tokens\n', '     /// @param _spender The address of the account able to transfer the tokens\n', '     /// @return Amount of remaining tokens allowed to spent\n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '     // Events:\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StdToken is Token {\n', '     // Fields:\n', '     mapping(address => uint256) balances;\n', '     mapping (address => mapping (address => uint256)) allowed;\n', '     uint public totalSupply = 0;\n', '\n', '     // Functions:\n', '     function transfer(address _to, uint256 _value) returns(bool){\n', '          require(balances[msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '          Transfer(msg.sender, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function transferFrom(address _from, address _to, uint256 _value) returns(bool){\n', '          require(balances[_from] >= _value);\n', '          require(allowed[_from][msg.sender] >= _value);\n', '          require(balances[_to] + _value > balances[_to]);\n', '\n', '          balances[_to] = safeAdd(balances[_to],_value);\n', '          balances[_from] = safeSub(balances[_from],_value);\n', '          allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '\n', '          Transfer(_from, _to, _value);\n', '          return true;\n', '     }\n', '\n', '     function balanceOf(address _owner) constant returns (uint256 balance) {\n', '          return balances[_owner];\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value) returns (bool success) {\n', '          allowed[msg.sender][_spender] = _value;\n', '          Approval(msg.sender, _spender, _value);\n', '          return true;\n', '     }\n', '\n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '          return allowed[_owner][_spender];\n', '     }\n', '\n', '     modifier onlyPayloadSize(uint _size) {\n', '          require(msg.data.length >= _size + 4);\n', '          _;\n', '     }\n', '}\n', '\n', 'contract MNTP is StdToken {\n', '/// Fields:\n', '     string public constant name = "Goldmint MNT Prelaunch Token";\n', '     string public constant symbol = "MNTP";\n', '     uint public constant decimals = 18;\n', '\n', '     address public creator = 0x0;\n', '     address public icoContractAddress = 0x0;\n', '     bool public lockTransfers = false;\n', '\n', '     // 10 mln\n', '     uint public constant TOTAL_TOKEN_SUPPLY = 10000000 * (1 ether / 1 wei);\n', '\n', '/// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender == creator); \n', '          _; \n', '     }\n', '\n', '     modifier byCreatorOrIcoContract() { \n', '          require((msg.sender == creator) || (msg.sender == icoContractAddress)); \n', '          _; \n', '     }\n', '\n', '     function setCreator(address _creator) onlyCreator {\n', '          creator = _creator;\n', '     }\n', '\n', '/// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '/// Functions:\n', '     /// @dev Constructor\n', '     function MNTP() {\n', '          creator = msg.sender;\n', '\n', '          // 10 mln tokens total\n', '          assert(TOTAL_TOKEN_SUPPLY == (10000000 * (1 ether / 1 wei)));\n', '     }\n', '\n', '     /// @dev Override\n', '     function transfer(address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transfer(_to,_value);\n', '     }\n', '\n', '     /// @dev Override\n', '     function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\n', '          require(!lockTransfers);\n', '          return super.transferFrom(_from,_to,_value);\n', '     }\n', '\n', '     function issueTokens(address _who, uint _tokens) byCreatorOrIcoContract {\n', '          require((totalSupply + _tokens) <= TOTAL_TOKEN_SUPPLY);\n', '\n', '          balances[_who] = safeAdd(balances[_who],_tokens);\n', '          totalSupply = safeAdd(totalSupply,_tokens);\n', '     }\n', '\n', '     function burnTokens(address _who, uint _tokens) byCreatorOrIcoContract {\n', '          balances[_who] = safeSub(balances[_who], _tokens);\n', '          totalSupply = safeSub(totalSupply, _tokens);\n', '     }\n', '\n', '     function lockTransfer(bool _lock) byCreatorOrIcoContract {\n', '          lockTransfers = _lock;\n', '     }\n', '\n', '     // Do not allow to send money directly to this contract\n', '     function() {\n', '          revert();\n', '     }\n', '}\n', '\n', '// This contract will hold all tokens that were unsold during ICO\n', '// (Goldmint should be able to withdraw them and sold only 1 year post-ICO)\n', 'contract GoldmintUnsold is SafeMath {\n', '     address public creator;\n', '     address public teamAccountAddress;\n', '     address public icoContractAddress;\n', '     uint64 public icoIsFinishedDate;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function GoldmintUnsold(address _teamAccountAddress,address _mntTokenAddress){\n', '          creator = msg.sender;\n', '          teamAccountAddress = _teamAccountAddress;\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '     }\n', '\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '\n', '     modifier onlyIcoContract() { \n', '          require(msg.sender==icoContractAddress); \n', '          _; \n', '     }\n', '\n', '/// Setters/Getters\n', '     function setIcoContractAddress(address _icoContractAddress) onlyCreator {\n', '          icoContractAddress = _icoContractAddress;\n', '     }\n', '\n', '     // only by Goldmint contract \n', '     function finishIco() public onlyIcoContract {\n', '          icoIsFinishedDate = uint64(now);\n', '     }\n', '\n', '     // can be called by anyone...\n', '     function withdrawTokens() public {\n', '          // wait for 1 year!\n', '          uint64 oneYearPassed = icoIsFinishedDate + 365 days;  \n', '          require(uint(now) >= oneYearPassed);\n', '\n', '          // transfer all tokens from this contract to the teamAccountAddress\n', '          uint total = mntToken.balanceOf(this);\n', '          mntToken.transfer(teamAccountAddress,total);\n', '     }\n', '\n', '     // Default fallback function\n', '     function() payable {\n', '          revert();\n', '     }\n', '}\n', '\n', 'contract FoundersVesting is SafeMath {\n', '     address public teamAccountAddress;\n', '     uint64 public lastWithdrawTime;\n', '\n', '     uint public withdrawsCount = 0;\n', '     uint public amountToSend = 0;\n', '\n', '     MNTP public mntToken;\n', '\n', '     function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){\n', '          teamAccountAddress = _teamAccountAddress;\n', '          lastWithdrawTime = uint64(now);\n', '\n', '          mntToken = MNTP(_mntTokenAddress);          \n', '     }\n', '\n', '     // can be called by anyone...\n', '     function withdrawTokens() public {\n', '          // 1 - wait for next month!\n', '          uint64 oneMonth = lastWithdrawTime + 30 days;  \n', '          require(uint(now) >= oneMonth);\n', '\n', '          // 2 - calculate amount (only first time)\n', '          if(withdrawsCount==0){\n', '               amountToSend = mntToken.balanceOf(this) / 10;\n', '          }\n', '\n', '          require(amountToSend!=0);\n', '\n', '          // 3 - send 1/10th\n', '          uint currentBalance = mntToken.balanceOf(this);\n', '          if(currentBalance<amountToSend){\n', '             amountToSend = currentBalance;  \n', '          }\n', '          mntToken.transfer(teamAccountAddress,amountToSend);\n', '\n', '          // 4 - update counter\n', '          withdrawsCount++;\n', '          lastWithdrawTime = uint64(now);\n', '     }\n', '\n', '     // Default fallback function\n', '     function() payable {\n', '          require(false);\n', '     }\n', '}\n', '\n', 'contract Goldmint is SafeMath {\n', '     address public creator = 0x0;\n', '     address public tokenManager = 0x0;\n', '     address public multisigAddress = 0x0;\n', '     address public otherCurrenciesChecker = 0x0;\n', '\n', '     uint64 public icoStartedTime = 0;\n', '\n', '     MNTP public mntToken; \n', '     GoldmintUnsold public unsoldContract;\n', '\n', '     struct TokenBuyer {\n', '          uint weiSent;\n', '          uint tokensGot;\n', '     }\n', '     mapping(address => TokenBuyer) buyers;\n', '\n', '     // These can be changed before ICO start ($7USD/MNTP)\n', '     uint constant STD_PRICE_USD_PER_1000_TOKENS = 7000;\n', '     // coinmarketcap.com 14.08.2017\n', '     uint constant ETH_PRICE_IN_USD = 300;\n', '     // price changes from block to block\n', '     //uint public constant SINGLE_BLOCK_LEN = 700000;\n', '\n', '     // TODO: only for tests. DO NOT merge this to master!!!\n', '     uint public constant SINGLE_BLOCK_LEN = 100;\n', '\n', '///////     \n', '     // 1 000 000 tokens\n', '     uint public constant BONUS_REWARD = 1000000 * (1 ether/ 1 wei);\n', '     // 2 000 000 tokens\n', '     uint public constant FOUNDERS_REWARD = 2000000 * (1 ether / 1 wei);\n', '     // 7 000 000 we sell only this amount of tokens during the ICO\n', '     //uint public constant ICO_TOKEN_SUPPLY_LIMIT = 7000000 * (1 ether / 1 wei); \n', '\n', '     // TODO: only for tests. DO NOT merge this to master!!!\n', '     // 150 - we sell only this amount of tokens during the ICO\n', '     uint public constant ICO_TOKEN_SUPPLY_LIMIT = 150 * (1 ether / 1 wei); \n', '\n', '     // 150 000 tokens soft cap\n', '     uint public constant ICO_TOKEN_SOFT_CAP = 150000 * (1 ether / 1 wei);\n', '     \n', '     // this is total number of tokens sold during ICO\n', '     uint public icoTokensSold = 0;\n', '     // this is total number of tokens sent to GoldmintUnsold contract after ICO is finished\n', '     uint public icoTokensUnsold = 0;\n', '\n', '     // this is total number of tokens that were issued by a scripts\n', '     uint public issuedExternallyTokens = 0;\n', '\n', '     bool public foundersRewardsMinted = false;\n', '     bool public restTokensMoved = false;\n', '\n', '     // this is where FOUNDERS_REWARD will be allocated\n', '     address public foundersRewardsAccount = 0x0;\n', '\n', '     enum State{\n', '          Init,\n', '\n', '          ICORunning,\n', '          ICOPaused,\n', '         \n', '          ICOFinished,\n', '\n', '          Refunding\n', '     }\n', '     State public currentState = State.Init;\n', '\n', '/// Modifiers:\n', '     modifier onlyCreator() { \n', '          require(msg.sender==creator); \n', '          _; \n', '     }\n', '     modifier onlyTokenManager() { \n', '          require(msg.sender==tokenManager); \n', '          _; \n', '     }\n', '     modifier onlyOtherCurrenciesChecker() { \n', '          require(msg.sender==otherCurrenciesChecker); \n', '          _; \n', '     }\n', '     modifier onlyInState(State state){ \n', '          require(state==currentState); \n', '          _; \n', '     }\n', '\n', '/// Events:\n', '     event LogStateSwitch(State newState);\n', '     event LogBuy(address indexed owner, uint value);\n', '     event LogBurn(address indexed owner, uint value);\n', '     \n', '/// Functions:\n', '     /// @dev Constructor\n', '     function Goldmint(\n', '          address _multisigAddress,\n', '          address _tokenManager,\n', '          address _otherCurrenciesChecker,\n', '\n', '          address _mntTokenAddress,\n', '          address _unsoldContractAddress,\n', '          address _foundersVestingAddress)\n', '     {\n', '          creator = msg.sender;\n', '\n', '          multisigAddress = _multisigAddress;\n', '          tokenManager = _tokenManager;\n', '          otherCurrenciesChecker = _otherCurrenciesChecker; \n', '\n', '          mntToken = MNTP(_mntTokenAddress);\n', '          unsoldContract = GoldmintUnsold(_unsoldContractAddress);\n', '\n', '          // slight rename\n', '          foundersRewardsAccount = _foundersVestingAddress;\n', '     }\n', '\n', '     /// @dev This function is automatically called when ICO is started\n', '     /// WARNING: can be called multiple times!\n', '     function startICO() internal onlyCreator {\n', '          mintFoundersRewards(foundersRewardsAccount);\n', '\n', '          mntToken.lockTransfer(true);\n', '\n', '          if(icoStartedTime==0){\n', '               icoStartedTime = uint64(now);\n', '          }\n', '     }\n', '\n', '     function pauseICO() internal onlyCreator {\n', '     }\n', '\n', '     function startRefunding() internal onlyCreator {\n', '          // only switch to this state if less than ICO_TOKEN_SOFT_CAP sold\n', '          require(icoTokensSold<ICO_TOKEN_SOFT_CAP);\n', '\n', '          // in this state tokens still shouldn&#39;t be transferred\n', '          assert(mntToken.lockTransfers());\n', '     }\n', '\n', '     /// @dev This function is automatically called when ICO is finished \n', '     /// WARNING: can be called multiple times!\n', '     function finishICO() internal {\n', '          mntToken.lockTransfer(false);\n', '\n', '          if(!restTokensMoved){\n', '               restTokensMoved = true;\n', '\n', '               // move all unsold tokens to unsoldTokens contract\n', '               icoTokensUnsold = safeSub(ICO_TOKEN_SUPPLY_LIMIT,icoTokensSold);\n', '               if(icoTokensUnsold>0){\n', '                    mntToken.issueTokens(unsoldContract,icoTokensUnsold);\n', '                    unsoldContract.finishIco();\n', '               }\n', '          }\n', '\n', '          // send all ETH to multisig\n', '          if(this.balance>0){\n', '               multisigAddress.transfer(this.balance);\n', '          }\n', '     }\n', '\n', '     function mintFoundersRewards(address _whereToMint) internal onlyCreator {\n', '          if(!foundersRewardsMinted){\n', '               foundersRewardsMinted = true;\n', '               mntToken.issueTokens(_whereToMint,FOUNDERS_REWARD);\n', '          }\n', '     }\n', '\n', '/// Access methods:\n', '     function setTokenManager(address _new) public onlyTokenManager {\n', '          tokenManager = _new;\n', '     }\n', '\n', '     function setOtherCurrenciesChecker(address _new) public onlyCreator {\n', '          otherCurrenciesChecker = _new;\n', '     }\n', '\n', '     function getTokensIcoSold() constant public returns (uint){\n', '          return icoTokensSold;\n', '     }\n', '\n', '     function getTotalIcoTokens() constant public returns (uint){\n', '          return ICO_TOKEN_SUPPLY_LIMIT;\n', '     }\n', '\n', '     function getMntTokenBalance(address _of) constant public returns (uint){\n', '          return mntToken.balanceOf(_of);\n', '     }\n', '\n', '     function getCurrentPrice()constant public returns (uint){\n', '          return getMntTokensPerEth(icoTokensSold);\n', '     }\n', '\n', '     function getBlockLength()constant public returns (uint){\n', '          return SINGLE_BLOCK_LEN;\n', '     }\n', '\n', '////\n', '     function isIcoFinished() public returns(bool){\n', '          if(icoStartedTime==0){return false;}          \n', '\n', '          // 1 - if time elapsed\n', '          uint64 oneMonth = icoStartedTime + 30 days;  \n', '          if(uint(now) > oneMonth){return true;}\n', '\n', '          // 2 - if all tokens are sold\n', '          if(icoTokensSold>=ICO_TOKEN_SUPPLY_LIMIT){\n', '               return true;\n', '          }\n', '\n', '          return false;\n', '     }\n', '\n', '     function setState(State _nextState) public {\n', '          // only creator can change state\n', '          // but in case ICOFinished -> anyone can do that after all time is elapsed\n', '          bool icoShouldBeFinished = isIcoFinished();\n', '          bool allow = (msg.sender==creator) || (icoShouldBeFinished && (State.ICOFinished==_nextState));\n', '          require(allow);\n', '\n', '          bool canSwitchState\n', '               =  (currentState == State.Init && _nextState == State.ICORunning)\n', '               || (currentState == State.ICORunning && _nextState == State.ICOPaused)\n', '               || (currentState == State.ICOPaused && _nextState == State.ICORunning)\n', '               || (currentState == State.ICORunning && _nextState == State.ICOFinished)\n', '               || (currentState == State.ICORunning && _nextState == State.Refunding);\n', '\n', '          require(canSwitchState);\n', '\n', '          currentState = _nextState;\n', '          LogStateSwitch(_nextState);\n', '\n', '          if(currentState==State.ICORunning){\n', '               startICO();\n', '          }else if(currentState==State.ICOFinished){\n', '               finishICO();\n', '          }else if(currentState==State.ICOPaused){\n', '               pauseICO();\n', '          }else if(currentState==State.Refunding){\n', '               startRefunding();\n', '          }\n', '     }\n', '\n', '     function getMntTokensPerEth(uint tokensSold) public constant returns (uint){\n', '          // 10 buckets\n', '          uint priceIndex = (tokensSold / (1 ether/ 1 wei)) / SINGLE_BLOCK_LEN;\n', '          assert(priceIndex>=0 && (priceIndex<=9));\n', '          \n', '          uint8[10] memory discountPercents = [20,15,10,8,6,4,2,0,0,0];\n', '\n', '          // We have to multiply by &#39;1 ether&#39; to avoid float truncations\n', '          // Example: ($7000 * 100) / 120 = $5833.33333\n', '          uint pricePer1000tokensUsd = \n', '               ((STD_PRICE_USD_PER_1000_TOKENS * 100) * (1 ether / 1 wei)) / (100 + discountPercents[priceIndex]);\n', '\n', '          // Correct: 300000 / 5833.33333333 = 51.42857142\n', '          // We have to multiply by &#39;1 ether&#39; to avoid float truncations\n', '          uint mntPerEth = (ETH_PRICE_IN_USD * 1000 * (1 ether / 1 wei) * (1 ether / 1 wei)) / pricePer1000tokensUsd;\n', '          return mntPerEth;\n', '     }\n', '\n', '     function buyTokens(address _buyer) public payable onlyInState(State.ICORunning) {\n', '          require(msg.value!=0);\n', '\n', '          // The price is selected based on current sold tokens.\n', '          // Price can &#39;overlap&#39;. For example:\n', '          //   1. if currently we sold 699950 tokens (the price is 10% discount)\n', '          //   2. buyer buys 1000 tokens\n', '          //   3. the price of all 1000 tokens would be with 10% discount!!!\n', '          uint newTokens = (msg.value * getMntTokensPerEth(icoTokensSold)) / (1 ether / 1 wei);\n', '\n', '          issueTokensInternal(_buyer,newTokens);\n', '\n', '          // update &#39;buyers&#39; map\n', '          // (only when buying from ETH)\n', '          TokenBuyer memory b = buyers[msg.sender];\n', '          b.weiSent = safeAdd(b.weiSent, msg.value);\n', '          b.tokensGot = safeAdd(b.tokensGot, newTokens);\n', '          buyers[msg.sender] = b;\n', '     }\n', '\n', '     /// @dev This is called by other currency processors to issue new tokens \n', '     function issueTokensFromOtherCurrency(address _to, uint _wei_count) onlyInState(State.ICORunning) public onlyOtherCurrenciesChecker {\n', '          require(_wei_count!=0);\n', '\n', '          uint newTokens = (_wei_count * getMntTokensPerEth(icoTokensSold)) / (1 ether / 1 wei);\n', '          issueTokensInternal(_to,newTokens);\n', '     }\n', '\n', '     /// @dev This can be called to manually issue new tokens \n', '     /// from the bonus reward\n', '     function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\n', '          // can not issue more than BONUS_REWARD\n', '          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);\n', '\n', '          mntToken.issueTokens(_to,_tokens);\n', '\n', '          issuedExternallyTokens = issuedExternallyTokens + _tokens;\n', '     }\n', '\n', '     function issueTokensInternal(address _to, uint _tokens) internal {\n', '          require((icoTokensSold + _tokens)<=ICO_TOKEN_SUPPLY_LIMIT);\n', '\n', '          mntToken.issueTokens(_to,_tokens);\n', '\n', '          icoTokensSold+=_tokens;\n', '\n', '          LogBuy(_to,_tokens);\n', '     }\n', '\n', '     function burnTokens(address _from, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {\n', '          mntToken.burnTokens(_from,_tokens);\n', '\n', '          LogBurn(_from,_tokens);\n', '     }\n', '\n', '     // anyone can call this and get his money back\n', '     function getMyRefund() public onlyInState(State.Refunding) {\n', '          address sender = msg.sender;\n', '\n', '          require(0!=buyers[sender].weiSent);\n', '          require(0!=buyers[sender].tokensGot);\n', '\n', '          // 1 - send money back\n', '          sender.transfer(buyers[sender].weiSent);\n', '\n', '          // 2 - burn tokens\n', '          mntToken.burnTokens(sender,buyers[sender].tokensGot);\n', '     }\n', '\n', '     // Default fallback function\n', '     function() payable {\n', '          // buyTokens -> issueTokensInternal\n', '          buyTokens(msg.sender);\n', '     }\n', '}']