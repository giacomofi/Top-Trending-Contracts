['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Contract to force hodl \n', '*/\n', 'contract Owned {\n', '    address public owner;\n', '    \n', '}\n', '\n', '/*\n', 'Master Contract for Forcing Users to Hodl.\n', '*/\n', 'contract HodlContract{\n', '    \n', '    HodlStruct[] public hodls; \n', '    address FeeAddress;\n', '    \n', '    event hodlAdded(uint hodlID, address recipient, uint amount, uint waitTime);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    \n', '    \n', '    struct HodlStruct {\n', '        address recipient;\n', '        uint amount;\n', '        uint waitTime;\n', '        bool executed;\n', '    }\n', '  \n', '   function HodlEth(address beneficiary, uint daysWait) public payable returns (uint hodlID) \n', '   {\n', '       uint FeeAmount;\n', '       FeeAddress = 0x9979cCFF79De92fbC1fb43bcD2a3a97Bb86b6920; \n', '        FeeAmount = msg.value * 1/100; //1% fee because you don&#39;t have the self control to hodl yourself.\n', '        FeeAddress.transfer(FeeAmount);\n', '        \n', '        hodlID = hodls.length++;\n', '        HodlStruct storage p = hodls[hodlID];\n', '        p.waitTime = now + daysWait * 1 days;\n', '        p.recipient = beneficiary;\n', '        p.amount = msg.value * 99/100;\n', '        p.executed = false;\n', '\n', '        hodlAdded(hodlID, beneficiary, msg.value, p.waitTime);\n', '        return hodlID;\n', '        \n', '    }\n', '    \n', '    function Realize(uint hodlID) public payable returns (uint amount){\n', '    HodlStruct storage p = hodls[hodlID];\n', '    require (now > p.waitTime  //Didn&#39;t wait long enough.\n', '    && !p.executed //Not already executed.\n', '    && msg.sender == p.recipient); //Only recipient as sender can get ether back.\n', '        \n', '        msg.sender.transfer(p.amount); // transfer the ether to the sender.\n', '        p.executed = true;\n', '        return p.amount;\n', '    }\n', '    \n', '    \n', '    function FindID(address beneficiary) public returns (uint hodlID){ //Emergency if user lost HodlID\n', '        HodlStruct storage p = hodls[hodlID];\n', '        \n', '        for (uint i = 0; i <  hodls.length; ++i) {\n', '            if (p.recipient == beneficiary && !p.executed ) {\n', '                return hodlID;\n', '            } else {\n', '                revert();\n', '            }\n', '        }\n', '        \n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Contract to force hodl \n', '*/\n', 'contract Owned {\n', '    address public owner;\n', '    \n', '}\n', '\n', '/*\n', 'Master Contract for Forcing Users to Hodl.\n', '*/\n', 'contract HodlContract{\n', '    \n', '    HodlStruct[] public hodls; \n', '    address FeeAddress;\n', '    \n', '    event hodlAdded(uint hodlID, address recipient, uint amount, uint waitTime);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    \n', '    \n', '    struct HodlStruct {\n', '        address recipient;\n', '        uint amount;\n', '        uint waitTime;\n', '        bool executed;\n', '    }\n', '  \n', '   function HodlEth(address beneficiary, uint daysWait) public payable returns (uint hodlID) \n', '   {\n', '       uint FeeAmount;\n', '       FeeAddress = 0x9979cCFF79De92fbC1fb43bcD2a3a97Bb86b6920; \n', "        FeeAmount = msg.value * 1/100; //1% fee because you don't have the self control to hodl yourself.\n", '        FeeAddress.transfer(FeeAmount);\n', '        \n', '        hodlID = hodls.length++;\n', '        HodlStruct storage p = hodls[hodlID];\n', '        p.waitTime = now + daysWait * 1 days;\n', '        p.recipient = beneficiary;\n', '        p.amount = msg.value * 99/100;\n', '        p.executed = false;\n', '\n', '        hodlAdded(hodlID, beneficiary, msg.value, p.waitTime);\n', '        return hodlID;\n', '        \n', '    }\n', '    \n', '    function Realize(uint hodlID) public payable returns (uint amount){\n', '    HodlStruct storage p = hodls[hodlID];\n', "    require (now > p.waitTime  //Didn't wait long enough.\n", '    && !p.executed //Not already executed.\n', '    && msg.sender == p.recipient); //Only recipient as sender can get ether back.\n', '        \n', '        msg.sender.transfer(p.amount); // transfer the ether to the sender.\n', '        p.executed = true;\n', '        return p.amount;\n', '    }\n', '    \n', '    \n', '    function FindID(address beneficiary) public returns (uint hodlID){ //Emergency if user lost HodlID\n', '        HodlStruct storage p = hodls[hodlID];\n', '        \n', '        for (uint i = 0; i <  hodls.length; ++i) {\n', '            if (p.recipient == beneficiary && !p.executed ) {\n', '                return hodlID;\n', '            } else {\n', '                revert();\n', '            }\n', '        }\n', '        \n', '    }\n', '    \n', '}']
