['pragma solidity ^0.4.11;\n', 'contract ERC20Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract SafeMath {\n', '    \n', '    /*\n', '    standard uint256 functions\n', '     */\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    int256 functions\n', '     */\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    WAD math\n', '     */\n', '    uint128 constant WAD = 10 ** 18;\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '    /*\n', '    RAY math\n', '     */\n', '    uint128 constant RAY = 10 ** 27;\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', '        // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '        z = n % 2 != 0 ? x : RAY;\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '}\n', 'contract Owned {\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner) ;\n', '        _;\n', '    }\n', '    address public owner;\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    address public newOwner;\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', 'contract StandardToken is ERC20Token {\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender,0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value!=0) && (allowed[msg.sender][_spender] !=0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', 'contract ATMToken is StandardToken, Owned {\n', '    // metadata\n', '    string public constant name = "Attention Token of Media";\n', '    string public constant symbol = "ATM";\n', '    string public version = "1.0";\n', '    uint256 public constant decimals = 8;\n', '    bool public disabled;\n', '    mapping(address => bool) public isATMHolder;\n', '    address[] public ATMHolders;\n', '    // constructor\n', '    function ATMToken(uint256 _amount) {\n', '        totalSupply = _amount; //设置当前ATM发行总量\n', '        balances[msg.sender] = _amount;\n', '    }\n', '    function getATMTotalSupply() external constant returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '    function getATMHoldersNumber() external constant returns(uint256) {\n', '        return ATMHolders.length;\n', '    }\n', '    //在数据迁移时,需要先停止ATM交易\n', '    function setDisabled(bool flag) external onlyOwner {\n', '        disabled = flag;\n', '    }\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(!disabled);\n', '        if(isATMHolder[_to] == false){\n', '            isATMHolder[_to] = true;\n', '            ATMHolders.push(_to);\n', '        }\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(!disabled);\n', '        if(isATMHolder[_to] == false){\n', '            isATMHolder[_to] = true;\n', '            ATMHolders.push(_to);\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    function kill() external onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', 'contract Contribution is SafeMath, Owned {\n', '    uint256 public constant MIN_FUND = (0.01 ether);\n', '    uint256 public constant CRAWDSALE_START_DAY = 1;\n', '    uint256 public constant CRAWDSALE_END_DAY = 7;\n', '    uint256 public dayCycle = 24 hours;\n', '    uint256 public fundingStartTime = 0;\n', '    address public ethFundDeposit = 0;\n', '    address public investorDeposit = 0;\n', '    bool public isFinalize = false;\n', '    bool public isPause = false;\n', '    mapping (uint => uint) public dailyTotals; //total eth per day\n', '    mapping (uint => mapping (address => uint)) public userBuys; // otal eth per day per user\n', '    uint256 public totalContributedETH = 0; //total eth of 7 days\n', '    // events\n', '    event LogBuy (uint window, address user, uint amount);\n', '    event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle);\n', '    event LogFinalize (uint finalizeTime);\n', '    event LogPause (uint finalizeTime, bool pause);\n', '    function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle)  {\n', '        require( now < _fundingStartTime );\n', '        require( _ethFundDeposit != address(0) );\n', '        fundingStartTime = _fundingStartTime;\n', '        dayCycle = _dayCycle;\n', '        ethFundDeposit = _ethFundDeposit;\n', '        investorDeposit = _investorDeposit;\n', '        LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle);\n', '    }\n', '    //crawdsale entry\n', '    function () payable {  \n', '        require(!isPause);\n', '        require(!isFinalize);\n', '        require( msg.value >= MIN_FUND ); //eth >= 0.01 at least\n', '        ethFundDeposit.transfer(msg.value);\n', '        buy(today(), msg.sender, msg.value);\n', '    }\n', '    function importExchangeSale(uint256 day, address _exchangeAddr, uint _amount) onlyOwner {\n', '        buy(day, _exchangeAddr, _amount);\n', '    }\n', '    function buy(uint256 day, address _addr, uint256 _amount) internal {\n', '        require( day >= CRAWDSALE_START_DAY && day <= CRAWDSALE_END_DAY ); \n', '        //record user&#39;s buy amount\n', '        userBuys[day][_addr] += _amount;\n', '        dailyTotals[day] += _amount;\n', '        totalContributedETH += _amount;\n', '        LogBuy(day, _addr, _amount);\n', '    }\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '    function pause(bool _isPause) onlyOwner {\n', '        isPause = _isPause;\n', '        LogPause(now,_isPause);\n', '    }\n', '    function finalize() onlyOwner {\n', '        isFinalize = true;\n', '        LogFinalize(now);\n', '    }\n', '    function today() constant returns (uint) {\n', '        return sub(now, fundingStartTime) / dayCycle + 1;\n', '    }\n', '}\n', 'contract ATMint is SafeMath, Owned {\n', '    ATMToken public atmToken; //ATM contract address\n', '    Contribution public contribution; //crawdSale contract address\n', '    uint128 public fundingStartTime = 0;\n', '    uint256 public lockStartTime = 0;\n', '    \n', '    uint256 public constant MIN_FUND = (0.01 ether);\n', '    uint256 public constant CRAWDSALE_START_DAY = 1;\n', '    uint256 public constant CRAWDSALE_EARLYBIRD_END_DAY = 3;\n', '    uint256 public constant CRAWDSALE_END_DAY = 7;\n', '    uint256 public constant THAW_CYCLE_USER = 6/*6*/;\n', '    uint256 public constant THAW_CYCLE_FUNDER = 6/*60*/;\n', '    uint256 public constant THAW_CYCLE_LENGTH = 30;\n', '    uint256 public constant decimals = 8; //ATM token decimals\n', '    uint256 public constant MILLION = (10**6 * 10**decimals);\n', '    uint256 public constant tokenTotal = 10000 * MILLION;  // 100 billion\n', '    uint256 public constant tokenToFounder = 800 * MILLION;  // 8 billion\n', '    uint256 public constant tokenToReserve = 5000 * MILLION;  // 50 billion\n', '    uint256 public constant tokenToContributor = 4000 * MILLION; // 40 billion\n', '    uint256[] public tokenToReward = [0, (120 * MILLION), (50 * MILLION), (30 * MILLION), 0, 0, 0, 0]; // 1.2 billion, 0.5 billion, 0.3 billion\n', '    bool doOnce = false;\n', '    \n', '    mapping (address => bool) public collected;\n', '    mapping (address => uint) public contributedToken;\n', '    mapping (address => uint) public unClaimedToken;\n', '    // events\n', '    event LogRegister (address contributionAddr, address ATMTokenAddr);\n', '    event LogCollect (address user, uint spendETHAmount, uint getATMAmount);\n', '    event LogMigrate (address user, uint balance);\n', '    event LogClaim (address user, uint claimNumberNow, uint unclaimedTotal, uint totalContributed);\n', '    event LogClaimReward (address user, uint claimNumber);\n', '    /*\n', '    ************************\n', '    deploy ATM and start Freeze cycle\n', '    ************************\n', '    */\n', '    function initialize (address _contribution) onlyOwner {\n', '        require( _contribution != address(0) );\n', '        contribution = Contribution(_contribution);\n', '        atmToken = new ATMToken(tokenTotal);\n', '        //Start thawing process\n', '        setLockStartTime(now);\n', '        // alloc reserve token to fund account (50 billion)\n', '        lockToken(contribution.ethFundDeposit(), tokenToReserve);\n', '        lockToken(contribution.investorDeposit(), tokenToFounder);\n', '        //help founder&fund to claim first 1/6 ATMs\n', '        claimUserToken(contribution.investorDeposit());\n', '        claimFoundationToken();\n', '        \n', '        LogRegister(_contribution, atmToken);\n', '    }\n', '    /*\n', '    ************************\n', '    calc ATM by eth per user\n', '    ************************\n', '    */\n', '    function collect(address _user) {\n', '        require(!collected[_user]);\n', '        \n', '        uint128 dailyContributedETH = 0;\n', '        uint128 userContributedETH = 0;\n', '        uint128 userTotalContributedETH = 0;\n', '        uint128 reward = 0;\n', '        uint128 rate = 0;\n', '        uint128 totalATMToken = 0;\n', '        uint128 rewardRate = 0;\n', '        collected[_user] = true;\n', '        for (uint day = CRAWDSALE_START_DAY; day <= CRAWDSALE_END_DAY; day++) {\n', '            dailyContributedETH = cast( contribution.dailyTotals(day) );\n', '            userContributedETH = cast( contribution.userBuys(day,_user) );\n', '            if (dailyContributedETH > 0 && userContributedETH > 0) {\n', '                //Calculate user rewards\n', '                rewardRate = wdiv(cast(tokenToReward[day]), dailyContributedETH);\n', '                reward += wmul(userContributedETH, rewardRate);\n', '                //Cumulative user purchase total\n', '                userTotalContributedETH += userContributedETH;\n', '            }\n', '        }\n', '        rate = wdiv(cast(tokenToContributor), cast(contribution.totalContributedETH()));\n', '        totalATMToken = wmul(rate, userTotalContributedETH);\n', '        totalATMToken += reward;\n', '        //Freeze all ATMs purchased\n', '        lockToken(_user, totalATMToken);\n', '        //help user to claim first 1/6 ATMs\n', '        claimUserToken(_user);\n', '        LogCollect(_user, userTotalContributedETH, totalATMToken);\n', '    }\n', '    function lockToken(\n', '        address _user,\n', '        uint256 _amount\n', '    ) internal {\n', '        require(_user != address(0));\n', '        contributedToken[_user] += _amount;\n', '        unClaimedToken[_user] += _amount;\n', '    }\n', '    function setLockStartTime(uint256 _time) internal {\n', '        lockStartTime = _time;\n', '    }\n', '    function cast(uint256 _x) constant internal returns (uint128 z) {\n', '        require((z = uint128(_x)) == _x);\n', '    }\n', '    /*\n', '    ************************\n', '    Claim ATM\n', '    ************************\n', '    */\n', '    function claimReward(address _founder) onlyOwner {\n', '        require(_founder != address(0));\n', '        require(lockStartTime != 0);\n', '        require(doOnce == false);\n', '        uint256 rewards = 0;\n', '        for (uint day = CRAWDSALE_START_DAY; day <= CRAWDSALE_EARLYBIRD_END_DAY; day++) {\n', '            if(contribution.dailyTotals(day) == 0){\n', '                rewards += tokenToReward[day];\n', '            }\n', '        }\n', '        atmToken.transfer(_founder, rewards);\n', '        doOnce = true;\n', '        LogClaimReward(_founder, rewards);\n', '    }\n', '    \n', '    function claimFoundationToken() {\n', '        require(msg.sender == owner || msg.sender == contribution.ethFundDeposit());\n', '        claimToken(contribution.ethFundDeposit(),THAW_CYCLE_FUNDER);\n', '    }\n', '    function claimUserToken(address _user) {\n', '        claimToken(_user,THAW_CYCLE_USER);\n', '    }\n', '    function claimToken(address _user, uint256 _stages) internal {\n', '        if (unClaimedToken[_user] == 0) {\n', '            return;\n', '        }\n', '        uint256 currentStage = sub(now, lockStartTime) / (60*60 /*contribution.dayCycle() * THAW_CYCLE_LENGTH*/) +1;\n', '        if (currentStage == 0) {\n', '            return;\n', '        } else if (currentStage > _stages) {\n', '            currentStage = _stages;\n', '        }\n', '        uint256 lockStages = _stages - currentStage;\n', '        uint256 unClaimed = (contributedToken[_user] * lockStages) / _stages;\n', '        if (unClaimedToken[_user] <= unClaimed) {\n', '            return;\n', '        }\n', '        uint256 tmp = unClaimedToken[_user] - unClaimed;\n', '        unClaimedToken[_user] = unClaimed;\n', '        atmToken.transfer(_user, tmp);\n', '        LogClaim(_user, tmp, unClaimed,contributedToken[_user]);\n', '    }\n', '    /*\n', '    ************************\n', '    migrate user data and suiside\n', '    ************************\n', '    */\n', '    function disableATMExchange() onlyOwner {\n', '        atmToken.setDisabled(true);\n', '    }\n', '    function enableATMExchange() onlyOwner {\n', '        atmToken.setDisabled(false);\n', '    }\n', '    function migrateUserData() onlyOwner {\n', '        for (var i=0; i< atmToken.getATMHoldersNumber(); i++){\n', '            LogMigrate(atmToken.ATMHolders(i), atmToken.balances(atmToken.ATMHolders(i)));\n', '        }\n', '    }\n', '    function kill() onlyOwner {\n', '        atmToken.kill();\n', '        selfdestruct(owner);\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', 'contract ERC20Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract SafeMath {\n', '    \n', '    /*\n', '    standard uint256 functions\n', '     */\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    int256 functions\n', '     */\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    /*\n', '    WAD math\n', '     */\n', '    uint128 constant WAD = 10 ** 18;\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '    /*\n', '    RAY math\n', '     */\n', '    uint128 constant RAY = 10 ** 27;\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '        z = n % 2 != 0 ? x : RAY;\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '}\n', 'contract Owned {\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner) ;\n', '        _;\n', '    }\n', '    address public owner;\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    address public newOwner;\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', 'contract StandardToken is ERC20Token {\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender,0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value!=0) && (allowed[msg.sender][_spender] !=0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', 'contract ATMToken is StandardToken, Owned {\n', '    // metadata\n', '    string public constant name = "Attention Token of Media";\n', '    string public constant symbol = "ATM";\n', '    string public version = "1.0";\n', '    uint256 public constant decimals = 8;\n', '    bool public disabled;\n', '    mapping(address => bool) public isATMHolder;\n', '    address[] public ATMHolders;\n', '    // constructor\n', '    function ATMToken(uint256 _amount) {\n', '        totalSupply = _amount; //设置当前ATM发行总量\n', '        balances[msg.sender] = _amount;\n', '    }\n', '    function getATMTotalSupply() external constant returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '    function getATMHoldersNumber() external constant returns(uint256) {\n', '        return ATMHolders.length;\n', '    }\n', '    //在数据迁移时,需要先停止ATM交易\n', '    function setDisabled(bool flag) external onlyOwner {\n', '        disabled = flag;\n', '    }\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(!disabled);\n', '        if(isATMHolder[_to] == false){\n', '            isATMHolder[_to] = true;\n', '            ATMHolders.push(_to);\n', '        }\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(!disabled);\n', '        if(isATMHolder[_to] == false){\n', '            isATMHolder[_to] = true;\n', '            ATMHolders.push(_to);\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    function kill() external onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', 'contract Contribution is SafeMath, Owned {\n', '    uint256 public constant MIN_FUND = (0.01 ether);\n', '    uint256 public constant CRAWDSALE_START_DAY = 1;\n', '    uint256 public constant CRAWDSALE_END_DAY = 7;\n', '    uint256 public dayCycle = 24 hours;\n', '    uint256 public fundingStartTime = 0;\n', '    address public ethFundDeposit = 0;\n', '    address public investorDeposit = 0;\n', '    bool public isFinalize = false;\n', '    bool public isPause = false;\n', '    mapping (uint => uint) public dailyTotals; //total eth per day\n', '    mapping (uint => mapping (address => uint)) public userBuys; // otal eth per day per user\n', '    uint256 public totalContributedETH = 0; //total eth of 7 days\n', '    // events\n', '    event LogBuy (uint window, address user, uint amount);\n', '    event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle);\n', '    event LogFinalize (uint finalizeTime);\n', '    event LogPause (uint finalizeTime, bool pause);\n', '    function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle)  {\n', '        require( now < _fundingStartTime );\n', '        require( _ethFundDeposit != address(0) );\n', '        fundingStartTime = _fundingStartTime;\n', '        dayCycle = _dayCycle;\n', '        ethFundDeposit = _ethFundDeposit;\n', '        investorDeposit = _investorDeposit;\n', '        LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle);\n', '    }\n', '    //crawdsale entry\n', '    function () payable {  \n', '        require(!isPause);\n', '        require(!isFinalize);\n', '        require( msg.value >= MIN_FUND ); //eth >= 0.01 at least\n', '        ethFundDeposit.transfer(msg.value);\n', '        buy(today(), msg.sender, msg.value);\n', '    }\n', '    function importExchangeSale(uint256 day, address _exchangeAddr, uint _amount) onlyOwner {\n', '        buy(day, _exchangeAddr, _amount);\n', '    }\n', '    function buy(uint256 day, address _addr, uint256 _amount) internal {\n', '        require( day >= CRAWDSALE_START_DAY && day <= CRAWDSALE_END_DAY ); \n', "        //record user's buy amount\n", '        userBuys[day][_addr] += _amount;\n', '        dailyTotals[day] += _amount;\n', '        totalContributedETH += _amount;\n', '        LogBuy(day, _addr, _amount);\n', '    }\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '    function pause(bool _isPause) onlyOwner {\n', '        isPause = _isPause;\n', '        LogPause(now,_isPause);\n', '    }\n', '    function finalize() onlyOwner {\n', '        isFinalize = true;\n', '        LogFinalize(now);\n', '    }\n', '    function today() constant returns (uint) {\n', '        return sub(now, fundingStartTime) / dayCycle + 1;\n', '    }\n', '}\n', 'contract ATMint is SafeMath, Owned {\n', '    ATMToken public atmToken; //ATM contract address\n', '    Contribution public contribution; //crawdSale contract address\n', '    uint128 public fundingStartTime = 0;\n', '    uint256 public lockStartTime = 0;\n', '    \n', '    uint256 public constant MIN_FUND = (0.01 ether);\n', '    uint256 public constant CRAWDSALE_START_DAY = 1;\n', '    uint256 public constant CRAWDSALE_EARLYBIRD_END_DAY = 3;\n', '    uint256 public constant CRAWDSALE_END_DAY = 7;\n', '    uint256 public constant THAW_CYCLE_USER = 6/*6*/;\n', '    uint256 public constant THAW_CYCLE_FUNDER = 6/*60*/;\n', '    uint256 public constant THAW_CYCLE_LENGTH = 30;\n', '    uint256 public constant decimals = 8; //ATM token decimals\n', '    uint256 public constant MILLION = (10**6 * 10**decimals);\n', '    uint256 public constant tokenTotal = 10000 * MILLION;  // 100 billion\n', '    uint256 public constant tokenToFounder = 800 * MILLION;  // 8 billion\n', '    uint256 public constant tokenToReserve = 5000 * MILLION;  // 50 billion\n', '    uint256 public constant tokenToContributor = 4000 * MILLION; // 40 billion\n', '    uint256[] public tokenToReward = [0, (120 * MILLION), (50 * MILLION), (30 * MILLION), 0, 0, 0, 0]; // 1.2 billion, 0.5 billion, 0.3 billion\n', '    bool doOnce = false;\n', '    \n', '    mapping (address => bool) public collected;\n', '    mapping (address => uint) public contributedToken;\n', '    mapping (address => uint) public unClaimedToken;\n', '    // events\n', '    event LogRegister (address contributionAddr, address ATMTokenAddr);\n', '    event LogCollect (address user, uint spendETHAmount, uint getATMAmount);\n', '    event LogMigrate (address user, uint balance);\n', '    event LogClaim (address user, uint claimNumberNow, uint unclaimedTotal, uint totalContributed);\n', '    event LogClaimReward (address user, uint claimNumber);\n', '    /*\n', '    ************************\n', '    deploy ATM and start Freeze cycle\n', '    ************************\n', '    */\n', '    function initialize (address _contribution) onlyOwner {\n', '        require( _contribution != address(0) );\n', '        contribution = Contribution(_contribution);\n', '        atmToken = new ATMToken(tokenTotal);\n', '        //Start thawing process\n', '        setLockStartTime(now);\n', '        // alloc reserve token to fund account (50 billion)\n', '        lockToken(contribution.ethFundDeposit(), tokenToReserve);\n', '        lockToken(contribution.investorDeposit(), tokenToFounder);\n', '        //help founder&fund to claim first 1/6 ATMs\n', '        claimUserToken(contribution.investorDeposit());\n', '        claimFoundationToken();\n', '        \n', '        LogRegister(_contribution, atmToken);\n', '    }\n', '    /*\n', '    ************************\n', '    calc ATM by eth per user\n', '    ************************\n', '    */\n', '    function collect(address _user) {\n', '        require(!collected[_user]);\n', '        \n', '        uint128 dailyContributedETH = 0;\n', '        uint128 userContributedETH = 0;\n', '        uint128 userTotalContributedETH = 0;\n', '        uint128 reward = 0;\n', '        uint128 rate = 0;\n', '        uint128 totalATMToken = 0;\n', '        uint128 rewardRate = 0;\n', '        collected[_user] = true;\n', '        for (uint day = CRAWDSALE_START_DAY; day <= CRAWDSALE_END_DAY; day++) {\n', '            dailyContributedETH = cast( contribution.dailyTotals(day) );\n', '            userContributedETH = cast( contribution.userBuys(day,_user) );\n', '            if (dailyContributedETH > 0 && userContributedETH > 0) {\n', '                //Calculate user rewards\n', '                rewardRate = wdiv(cast(tokenToReward[day]), dailyContributedETH);\n', '                reward += wmul(userContributedETH, rewardRate);\n', '                //Cumulative user purchase total\n', '                userTotalContributedETH += userContributedETH;\n', '            }\n', '        }\n', '        rate = wdiv(cast(tokenToContributor), cast(contribution.totalContributedETH()));\n', '        totalATMToken = wmul(rate, userTotalContributedETH);\n', '        totalATMToken += reward;\n', '        //Freeze all ATMs purchased\n', '        lockToken(_user, totalATMToken);\n', '        //help user to claim first 1/6 ATMs\n', '        claimUserToken(_user);\n', '        LogCollect(_user, userTotalContributedETH, totalATMToken);\n', '    }\n', '    function lockToken(\n', '        address _user,\n', '        uint256 _amount\n', '    ) internal {\n', '        require(_user != address(0));\n', '        contributedToken[_user] += _amount;\n', '        unClaimedToken[_user] += _amount;\n', '    }\n', '    function setLockStartTime(uint256 _time) internal {\n', '        lockStartTime = _time;\n', '    }\n', '    function cast(uint256 _x) constant internal returns (uint128 z) {\n', '        require((z = uint128(_x)) == _x);\n', '    }\n', '    /*\n', '    ************************\n', '    Claim ATM\n', '    ************************\n', '    */\n', '    function claimReward(address _founder) onlyOwner {\n', '        require(_founder != address(0));\n', '        require(lockStartTime != 0);\n', '        require(doOnce == false);\n', '        uint256 rewards = 0;\n', '        for (uint day = CRAWDSALE_START_DAY; day <= CRAWDSALE_EARLYBIRD_END_DAY; day++) {\n', '            if(contribution.dailyTotals(day) == 0){\n', '                rewards += tokenToReward[day];\n', '            }\n', '        }\n', '        atmToken.transfer(_founder, rewards);\n', '        doOnce = true;\n', '        LogClaimReward(_founder, rewards);\n', '    }\n', '    \n', '    function claimFoundationToken() {\n', '        require(msg.sender == owner || msg.sender == contribution.ethFundDeposit());\n', '        claimToken(contribution.ethFundDeposit(),THAW_CYCLE_FUNDER);\n', '    }\n', '    function claimUserToken(address _user) {\n', '        claimToken(_user,THAW_CYCLE_USER);\n', '    }\n', '    function claimToken(address _user, uint256 _stages) internal {\n', '        if (unClaimedToken[_user] == 0) {\n', '            return;\n', '        }\n', '        uint256 currentStage = sub(now, lockStartTime) / (60*60 /*contribution.dayCycle() * THAW_CYCLE_LENGTH*/) +1;\n', '        if (currentStage == 0) {\n', '            return;\n', '        } else if (currentStage > _stages) {\n', '            currentStage = _stages;\n', '        }\n', '        uint256 lockStages = _stages - currentStage;\n', '        uint256 unClaimed = (contributedToken[_user] * lockStages) / _stages;\n', '        if (unClaimedToken[_user] <= unClaimed) {\n', '            return;\n', '        }\n', '        uint256 tmp = unClaimedToken[_user] - unClaimed;\n', '        unClaimedToken[_user] = unClaimed;\n', '        atmToken.transfer(_user, tmp);\n', '        LogClaim(_user, tmp, unClaimed,contributedToken[_user]);\n', '    }\n', '    /*\n', '    ************************\n', '    migrate user data and suiside\n', '    ************************\n', '    */\n', '    function disableATMExchange() onlyOwner {\n', '        atmToken.setDisabled(true);\n', '    }\n', '    function enableATMExchange() onlyOwner {\n', '        atmToken.setDisabled(false);\n', '    }\n', '    function migrateUserData() onlyOwner {\n', '        for (var i=0; i< atmToken.getATMHoldersNumber(); i++){\n', '            LogMigrate(atmToken.ATMHolders(i), atmToken.balances(atmToken.ATMHolders(i)));\n', '        }\n', '    }\n', '    function kill() onlyOwner {\n', '        atmToken.kill();\n', '        selfdestruct(owner);\n', '    }\n', '}']
