['contract ParallelGambling {\n', '    \n', '    //--------parameters\n', '    uint[3] private deposit;\n', '    uint private feesThousandth = 10;       //1% of fees !\n', '    uint private time_max = 6 * 60 * 60;   //6 hours in seconds, time to wait before you can cancel the round\n', '    uint private fees = 0; \n', '    \n', '    //percentage of attribution of differents prizes\n', '    uint private first_prize = 170;     //Big winner gets 160 %\n', '    uint private second_prize = 130;    //Little winner gets 140 %\n', '    uint private third_prize = 0;       //looser gets nothing !\n', '    \n', '    //--Contract ledger for the 3 "play zones"\n', '    \n', '    uint[3] private Balance;\n', '    uint[3] private id;\n', '    uint[3] private cursor;\n', '    uint[3] private nb_player ;\n', '    uint[3] private last_time ;\n', '    \n', '    // -- random uniformers -\n', '\tuint256 private toss1;\n', '\tuint256 private toss2;\n', '\t\n', '\t\n', '    address private admin;\n', '    \n', '    //Constructor - executed on creation only\n', '    function ParallelGambling() {\n', '        admin = msg.sender;\n', '        uint i;\n', '        //*****initiate everything properly****\n', '        for(i=0;i<3;i++){\n', '            Balance[i]=0;\n', '            last_time[i] = block.timestamp;\n', '            nb_player[i]=0;\n', '            id[i]=0;\n', '\t\t\tcursor[i]=0;\n', '        }\n', '        deposit[0]= 100 finney; // ZONE 1\n', '        deposit[1]= 1 ether;    // ZONE 2\n', '        deposit[2]= 5 ether;    // ZONE 3\n', '    }\n', '\n', '    modifier onlyowner {if (msg.sender == admin) _  }\n', '\n', '    \n', '    struct Player { //for each entry\n', '        address addr;\n', '        uint payout; //this section is filled when payout are done !\n', '        bool paid;\n', '    }\n', '    \n', '    Player[][3] private players;\n', '\t\n', '\t\n', '\tstruct GamblerStats { //for each address, to keep a record\n', '\t\tuint bets;\n', '\t\tuint deposits;\n', '\t\tuint paid;\n', '\t}\n', '\tmapping(address => GamblerStats) private gamblers;\n', '\n', '    \n', '    function() {\n', '        init();\n', '    }\n', '\n', '    \n', '    function init() private {\n', '        //------ Verifications to select play zone-----\n', '        uint256 actual_deposit = msg.value;\n', '        uint zone_selected;\n', '        \n', '        if (actual_deposit < deposit[0]) { //not enough for any zones !\n', '            msg.sender.send(actual_deposit);\n', '            return;\n', '        }\n', '        if(actual_deposit >= deposit[0] && actual_deposit < deposit[1]){   // GAME ZONE 1\n', '\t\t\tif( actual_deposit-deposit[0] >0){\n', '\t\t\t\tmsg.sender.send(actual_deposit-deposit[0]);\n', '\t\t\t}\n', '            actual_deposit=deposit[0];\n', '            zone_selected=0;\n', '        }\n', '        if(actual_deposit >= deposit[1] && actual_deposit < deposit[2]){   // GAME ZONE 2\n', '\t\t\tif( actual_deposit-deposit[1] >0){\n', '\t\t\t\tmsg.sender.send(actual_deposit-deposit[1]);\n', '\t\t\t}\n', '            actual_deposit=deposit[1];\n', '            zone_selected=1;\n', '        }\n', '        if(actual_deposit >= deposit[2]){                             // GAME ZONE 3\n', '\t\t\tif( actual_deposit-deposit[2] >0){\n', '\t\t\t\tmsg.sender.send(actual_deposit-deposit[2]);\n', '\t\t\t}\n', '            actual_deposit=deposit[2];\n', '            zone_selected=2;\n', '        }\n', '        \n', '        //----update balances and ledger according to the playing zone selected---\n', '        \n', '        fees += (actual_deposit * feesThousandth) / 1000;      // collect 1% fee\n', '        Balance[zone_selected] += (actual_deposit * (1000 - feesThousandth )) / 1000; //update balance\n', '        \n', '        last_time[zone_selected] = block.timestamp;\n', '        \n', '        players[zone_selected].length++;\n', '        players[zone_selected][cursor[zone_selected]]=(Player(msg.sender,  0 , false));\n', '\t\tcursor[zone_selected]++;\n', '        nb_player[zone_selected]++;\n', '\t\t\n', '\t\t//update stats\n', '\t\tgamblers[msg.sender].bets++;\n', '\t\tgamblers[msg.sender].deposits += actual_deposit;\n', '\t\t\n', '\t\t//random\n', '\t\tif(nb_player[zone_selected]%2 ==0)\ttoss1 = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\n', '\t\telse toss2 = uint256(sha3(tx.gasprice+block.difficulty)); \n', '        \n', '        //-check if end of the round\n', '        if(nb_player[zone_selected] == 3){ //end of a round\n', '            EndRound(zone_selected);\n', '        }\n', '    }\n', '    \n', '    function EndRound(uint zone) private{\n', '        \n', '        //randomness is created here from previous toss\n', '        uint256 toss = toss1+toss2+msg.value; //send a value higher than the required deposit to create more randomness if you are the third player (ending round).\n', '\t\t//indices of players\n', '        uint i_big_winner;\n', '        uint i_small_winner;\n', '        uint i_looser;\n', '        \n', '        if( toss % 3 == 0 ){\n', '            i_big_winner=id[zone];\n', '            i_small_winner=id[zone]+1;\n', '            i_looser =id[zone]+2;\n', '        }\n', '        else if( toss % 3 == 1){\n', '            i_big_winner=id[zone]+2;\n', '            i_small_winner=id[zone];\n', '            i_looser =id[zone]+1;\n', '        }\n', '        else{\n', '            i_big_winner=id[zone]+1;\n', '            i_small_winner=id[zone]+2;\n', '            i_looser =id[zone];\n', '        }\n', '        \n', '        uint256 effective_bet = (deposit[zone] * (1000 - feesThousandth )) / 1000;\n', '        \n', '        players[zone][i_big_winner].addr.send(effective_bet*first_prize/100);     //big win\n', '        players[zone][i_small_winner].addr.send(effective_bet*second_prize/100);    //small win\n', '        if(third_prize > 0){\n', '            players[zone][i_small_winner].addr.send(effective_bet*third_prize/100);    //looser\n', '        }\n', '        \n', '        //update zone information\n', '        players[zone][i_big_winner].payout=effective_bet*first_prize/100;\n', '        players[zone][i_small_winner].payout=effective_bet*second_prize/100;\n', '        players[zone][i_looser].payout=effective_bet*third_prize/100;\n', '        players[zone][id[zone]].paid=true;\n', '        players[zone][id[zone]+1].paid=true;\n', '        players[zone][id[zone]+2].paid=true;\n', '\t\t//update gamblers ledger\n', '\t\tgamblers[players[zone][i_big_winner].addr].paid += players[zone][i_big_winner].payout;\n', '\t\tgamblers[players[zone][i_small_winner].addr].paid += players[zone][i_small_winner].payout;\n', '\t\tgamblers[players[zone][i_looser].addr].paid += players[zone][i_looser].payout;\n', '\t\t\n', '        Balance[zone]=0;\n', '        nb_player[zone]=0;\n', '        id[zone] += 3;\n', '    }\n', '\n', '    \n', '    function CancelRoundAndRefundAll(uint zone) { //refund every participants in a zone, anyone can call this !\n', '        if(zone<0 && zone>3) throw;\n', '        if(nb_player[zone]==0) return;\n', '        \n', '        uint256 pay=(deposit[zone] * (1000 - feesThousandth )) / 1000;\n', '        \n', '        if (last_time[zone] + time_max < block.timestamp) {\n', '            for(uint i=id[zone]; i<(id[zone]+nb_player[zone]); i++){\n', '                players[zone][i].addr.send(pay);\n', '                players[zone][i].paid=true;\n', '                players[zone][i].payout=pay;\n', '\t\t\t\t\n', '\t\t\t\tgamblers[players[zone][i].addr].bets--;\n', '\t\t\t\tgamblers[players[zone][i].addr].deposits -= pay;\n', '            }\n', '            id[zone] += nb_player[zone];\n', '            nb_player[zone]=0;\n', '\t\t\tBalance[zone]=0;\n', '\t\t\t//remove informations from stats - cancelling = removing\n', '\t\t\t\n', '        }\n', '    }\n', '    \n', '    //------------ Contract informations -----------------------------------\n', '    \n', '    \n', '    function LookAtBalance() constant returns(uint BalanceOfZone1,uint BalanceOfZone2,uint BalanceOfZone3, string info) {\n', '        BalanceOfZone1 = Balance[0] /  1 finney;\n', '        BalanceOfZone2 = Balance[1] /  1 finney;\n', '        BalanceOfZone3 = Balance[2] /  1 finney;\n', "        info ='Balances of all play zones in finney';\n", '    }\n', '    \n', '    function PlayerInfoPerZone(uint id, uint zone) constant returns(address Address, uint Payout, bool UserPaid, string info) {\n', '        if(zone<0 && zone>3) throw;\n', '        if (id <= players[zone].length) {\n', '            Address = players[zone][id].addr;\n', '            Payout = (players[zone][id].payout) / 1 finney;\n', '            UserPaid= players[zone][id].paid;\n', '        }\n', '\t\t\n', "\t\tinfo = 'Select zone between 0 and 2, then use the id to look trough this zone';\n", '    }\n', '    \n', '    function LookAtLastTimePerZone(uint zone) constant returns(uint LastTimeForSelectedZone,uint TimeToWaitEnablingRefund, string info) {\n', '        if(zone<0 && zone>3) throw;\n', '        LastTimeForSelectedZone = last_time[zone];\n', '        TimeToWaitEnablingRefund = time_max;\n', "        info ='Timestamps, use this to know when you can cancel a round to get back funds, TimeToWait in seconds !';\n", '    }\n', '\n', '    function LookAtCollectedFees() constant returns(uint Fees, string info) {\n', '        Fees = fees / 1 finney;\n', "\t\tinfo = 'Fees collected, in finney.';\n", '    }\n', '    \n', '    \n', '    function LookAtDepositsToPlay() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n', '        InZone1 = deposit[0] / 1 finney;\n', '        InZone2 = deposit[1] / 1 finney;\n', '        InZone3 = deposit[2] / 1 finney;\n', "\t\tinfo = 'Deposit for each zones, in finney. Surpus are always refunded.';\n", '    }\n', '\n', '    function LookAtPrizes() constant returns(uint FirstPrize,uint SecondPrize,uint LooserPrize, string info) {\n', '\t\tFirstPrize=first_prize;\n', '\t\tSecondPrize=second_prize;\n', '\t\tLooserPrize=third_prize;\n', '\t\n', "\t\tinfo = 'Prizes in percent of the deposit';\n", '    }\n', '\t\n', '\tfunction GamblerPerAddress(address addr) constant returns(uint Bets, uint Deposited, uint PaidOut, string info) {\n', '\t\tBets      = gamblers[addr].bets;\n', '\t\tDeposited = gamblers[addr].deposits / 1 finney;\n', '\t\tPaidOut   = gamblers[addr].paid / 1 finney;\n', "\t\tinfo ='Bets is the number of time you participated, no matter the zone.';\n", '\t}\n', '\t\n', '    function LookAtNumberOfPlayers() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n', '        InZone1 = nb_player[0];\n', '        InZone2 = nb_player[1];\n', '        InZone3 = nb_player[2];\n', '\t\t\n', "\t\tinfo = 'Players in a round, in each zones.';\n", '    }\n', '    //----------- Contract management functions -------------------------\n', '    \n', '    function ChangeOwnership(address _owner) onlyowner {\n', '        admin = _owner;\n', '    }\n', '\t\n', '\t\n', '    function ModifyFeeFraction(uint new_fee) onlyowner {\n', '\t\tif( new_fee>=0 && new_fee<=20 ){ //admin can only set the fee percentage between 0 and 2%, initially 1%\n', '\t\t\tfeesThousandth = new_fee;\n', '\t\t}\n', '    }\n', '    \n', '    //function to modify settings, only if no player in a round !\n', '    function ModifySettings(uint new_time_max, uint new_first_prize, uint new_second_prize, uint new_third_prize,\n', '                            uint deposit_1,uint deposit_2,uint deposit_3) onlyowner {\n', '        if(nb_player[0]!=0 || nb_player[1]!=0 || nb_player[2]!=0 ) throw; //can only modify if nobody plays !\n', '        \n', '        if(new_time_max>=(1 * 60 * 60) && new_time_max<=(24 * 60 * 60) ) time_max=new_time_max;\n', '\t\t\n', '\t\tif((new_first_prize+new_second_prize+new_third_prize)==300){ //the total must be distributed in a correct way\n', '\t\t\tif(new_first_prize>=130 && new_first_prize<=190){\t\t\t\n', '\t\t\t\tfirst_prize=new_first_prize;\n', '\t\t\t\tif(new_second_prize>100 && new_second_prize<=130){\n', '\t\t\t\t\tsecond_prize=new_second_prize;\n', '\t\t\t\t\tif(new_third_prize>=0 && new_third_prize<=50) third_prize=new_third_prize;\n', '\t\t\t\t}\n', '\t\t\t}\n', '        }\n', '        if(deposit_1>=(1 finney) && deposit_1<(1 ether)) deposit[0]=deposit_1;\n', '        if(deposit_2>=(1 ether) && deposit_2<(5 ether)) deposit[1]=deposit_2;\n', '        if(deposit_3>=(5 ether) && deposit_3<=(20 ether)) deposit[2]=deposit_3;\n', '        \n', '    }\n', '    \n', "    function CollectAllFees() onlyowner { //it just send fees, that's all folks !\n", '        if (fees == 0) throw;\n', '        admin.send(fees);\n', '        fees = this.balance -Balance[0]-Balance[1]-Balance[2]; //just in case there is lost ethers.\n', '    }\n', '}']