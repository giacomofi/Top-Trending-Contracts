['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/// @title Mid-Team Holding Incentive Program\n', '/// @author Daniel Wang - <<span class="__cf_email__" data-cfemail="593d3837303c3519353636292b30373e77362b3e">[email&#160;protected]</span>>, Kongliang Zhong - <<span class="__cf_email__" data-cfemail="ff9490919893969e9198bf9390908f8d969198d1908d98">[email&#160;protected]</span>>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract LRCMidTermHoldingContract {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '\n', '    // During the first 60 days of deployment, this contract opens for deposit of LRC\n', '    // in exchange of ETH.\n', '    uint public constant DEPOSIT_WINDOW                 = 60 days;\n', '\n', '    // For each address, its LRC can only be withdrawn between 180 and 270 days after LRC deposit,\n', '    // which means:\n', '    //    1) LRC are locked during the first 180 days,\n', '    //    2) LRC will be sold to the `owner` with the specified `RATE` 270 days after the deposit.\n', '    uint public constant WITHDRAWAL_DELAY               = 180 days;\n', '    uint public constant WITHDRAWAL_WINDOW              = 90  days;\n', '\n', '    uint public constant MAX_LRC_DEPOSIT_PER_ADDRESS    = 150000 ether; // = 20 ETH * 7500\n', '\n', '    // 7500 LRC for 1 ETH. This is the best token sale rate ever.\n', '    uint public constant RATE       = 7500;\n', '\n', '    address public lrcTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '\n', '    // Some stats\n', '    uint public lrcReceived         = 0;\n', '    uint public lrcSent             = 0;\n', '    uint public ethReceived         = 0;\n', '    uint public ethSent             = 0;\n', '\n', '    uint public depositStartTime    = 0;\n', '    uint public depositStopTime     = 0;\n', '\n', '    bool public closed              = false;\n', '\n', '    struct Record {\n', '        uint lrcAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) records;\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful withdrawal.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when this contract is closed.\n', '    event Closed(uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when ETH are drained.\n', '    event Drained(uint _ethAmount);\n', '\n', '    /// CONSTRUCTOR\n', '    /// @dev Initialize and start the contract.\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    /// @param _owner Owner of this contract\n', '    function LRCMidTermHoldingContract(address _lrcTokenAddress, address _owner) {\n', '        require(_lrcTokenAddress != address(0));\n', '        require(_owner != address(0));\n', '\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param ethAmount Amount of ETH to drain back to owner\n', '    function drain(uint ethAmount) public payable {\n', '        require(!closed);\n', '        require(msg.sender == owner);\n', '\n', '        uint amount = ethAmount.min256(this.balance);\n', '        require(amount > 0);\n', '        owner.transfer(amount);\n', '\n', '        Drained(amount);\n', '    }\n', '\n', '    /// @dev Set depositStartTime\n', '    function start() public {\n', '        require(msg.sender == owner);\n', '        require(depositStartTime == 0);\n', '\n', '        depositStartTime = now;\n', '        depositStopTime  = now + DEPOSIT_WINDOW;\n', '\n', '        Started(depositStartTime);\n', '    }\n', '\n', '    /// @dev Get all ETH and LRC back to `owner`.\n', '    function close() public payable {\n', '        require(!closed);\n', '        require(msg.sender == owner);\n', '        require(now > depositStopTime + WITHDRAWAL_DELAY + WITHDRAWAL_WINDOW);\n', '\n', '        uint ethAmount = this.balance;\n', '        if (ethAmount > 0) {\n', '            owner.transfer(ethAmount);\n', '        }\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken.balanceOf(address(this));\n', '        if (lrcAmount > 0) {\n', '            require(lrcToken.transfer(owner, lrcAmount));\n', '        }\n', '\n', '        closed = true;\n', '        Closed(ethAmount, lrcAmount);\n', '    }\n', '\n', '    /// @dev This default function allows simple usage.\n', '    function () payable {\n', '        require(!closed);\n', '\n', '        if (msg.sender != owner) {\n', '            if (now <= depositStopTime) depositLRC();\n', '            else withdrawLRC();\n', '        }\n', '    }\n', '\n', '\n', '    /// @dev Deposit LRC for ETH.\n', '    /// If user send x ETH, this method will try to transfer `x * 100 * 6500` LRC from\n', '    /// the user&#39;s address and send `x * 100` ETH to the user.\n', '    function depositLRC() payable {\n', '        require(!closed && msg.sender != owner);\n', '        require(now <= depositStopTime);\n', '        require(msg.value == 0);\n', '\n', '        var record = records[msg.sender];\n', '        var lrcToken = Token(lrcTokenAddress);\n', '\n', '        uint lrcAmount = this.balance.mul(RATE)\n', '            .min256(lrcToken.balanceOf(msg.sender))\n', '            .min256(lrcToken.allowance(msg.sender, address(this)))\n', '            .min256(MAX_LRC_DEPOSIT_PER_ADDRESS - record.lrcAmount);\n', '\n', '        uint ethAmount = lrcAmount.div(RATE);\n', '        lrcAmount = ethAmount.mul(RATE);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '\n', '        record.lrcAmount += lrcAmount;\n', '        record.timestamp = now;\n', '        records[msg.sender] = record;\n', '\n', '        lrcReceived += lrcAmount;\n', '        ethSent += ethAmount;\n', '\n', '\n', '        Deposit(\n', '                depositId++,\n', '                msg.sender,\n', '                ethAmount,\n', '                lrcAmount\n', '                );\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount));\n', '        msg.sender.transfer(ethAmount);\n', '    }\n', '\n', '    /// @dev Withdrawal LRC with ETH transfer.\n', '    function withdrawLRC() payable {\n', '        require(!closed && msg.sender != owner);\n', '        require(now > depositStopTime);\n', '        require(msg.value > 0);\n', '\n', '        var record = records[msg.sender];\n', '        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n', '        require(now <= record.timestamp + WITHDRAWAL_DELAY + WITHDRAWAL_WINDOW);\n', '\n', '        uint ethAmount = msg.value.min256(record.lrcAmount.div(RATE));\n', '        uint lrcAmount = ethAmount.mul(RATE);\n', '\n', '        record.lrcAmount -= lrcAmount;\n', '        if (record.lrcAmount == 0) {\n', '            delete records[msg.sender];\n', '        } else {\n', '            records[msg.sender] = record;\n', '        }\n', '\n', '        lrcSent += lrcAmount;\n', '        ethReceived += ethAmount;\n', '\n', '        Withdrawal(\n', '                   withdrawId++,\n', '                   msg.sender,\n', '                   ethAmount,\n', '                   lrcAmount\n', '                   );\n', '\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '\n', '        uint ethRefund = msg.value - ethAmount;\n', '        if (ethRefund > 0) {\n', '            msg.sender.transfer(ethRefund);\n', '        }\n', '    }\n', '\n', '    function getLRCAmount(address addr) public constant returns (uint) {\n', '        return records[addr].lrcAmount;\n', '    }\n', '\n', '    function getTimestamp(address addr) public constant returns (uint) {\n', '        return records[addr].timestamp;\n', '    }\n', '}']
['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/// @title Mid-Team Holding Incentive Program\n', '/// @author Daniel Wang - <daniel@loopring.org>, Kongliang Zhong - <kongliang@loopring.org>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract LRCMidTermHoldingContract {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '\n', '    // During the first 60 days of deployment, this contract opens for deposit of LRC\n', '    // in exchange of ETH.\n', '    uint public constant DEPOSIT_WINDOW                 = 60 days;\n', '\n', '    // For each address, its LRC can only be withdrawn between 180 and 270 days after LRC deposit,\n', '    // which means:\n', '    //    1) LRC are locked during the first 180 days,\n', '    //    2) LRC will be sold to the `owner` with the specified `RATE` 270 days after the deposit.\n', '    uint public constant WITHDRAWAL_DELAY               = 180 days;\n', '    uint public constant WITHDRAWAL_WINDOW              = 90  days;\n', '\n', '    uint public constant MAX_LRC_DEPOSIT_PER_ADDRESS    = 150000 ether; // = 20 ETH * 7500\n', '\n', '    // 7500 LRC for 1 ETH. This is the best token sale rate ever.\n', '    uint public constant RATE       = 7500;\n', '\n', '    address public lrcTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '\n', '    // Some stats\n', '    uint public lrcReceived         = 0;\n', '    uint public lrcSent             = 0;\n', '    uint public ethReceived         = 0;\n', '    uint public ethSent             = 0;\n', '\n', '    uint public depositStartTime    = 0;\n', '    uint public depositStopTime     = 0;\n', '\n', '    bool public closed              = false;\n', '\n', '    struct Record {\n', '        uint lrcAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) records;\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful withdrawal.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when this contract is closed.\n', '    event Closed(uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when ETH are drained.\n', '    event Drained(uint _ethAmount);\n', '\n', '    /// CONSTRUCTOR\n', '    /// @dev Initialize and start the contract.\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    /// @param _owner Owner of this contract\n', '    function LRCMidTermHoldingContract(address _lrcTokenAddress, address _owner) {\n', '        require(_lrcTokenAddress != address(0));\n', '        require(_owner != address(0));\n', '\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param ethAmount Amount of ETH to drain back to owner\n', '    function drain(uint ethAmount) public payable {\n', '        require(!closed);\n', '        require(msg.sender == owner);\n', '\n', '        uint amount = ethAmount.min256(this.balance);\n', '        require(amount > 0);\n', '        owner.transfer(amount);\n', '\n', '        Drained(amount);\n', '    }\n', '\n', '    /// @dev Set depositStartTime\n', '    function start() public {\n', '        require(msg.sender == owner);\n', '        require(depositStartTime == 0);\n', '\n', '        depositStartTime = now;\n', '        depositStopTime  = now + DEPOSIT_WINDOW;\n', '\n', '        Started(depositStartTime);\n', '    }\n', '\n', '    /// @dev Get all ETH and LRC back to `owner`.\n', '    function close() public payable {\n', '        require(!closed);\n', '        require(msg.sender == owner);\n', '        require(now > depositStopTime + WITHDRAWAL_DELAY + WITHDRAWAL_WINDOW);\n', '\n', '        uint ethAmount = this.balance;\n', '        if (ethAmount > 0) {\n', '            owner.transfer(ethAmount);\n', '        }\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken.balanceOf(address(this));\n', '        if (lrcAmount > 0) {\n', '            require(lrcToken.transfer(owner, lrcAmount));\n', '        }\n', '\n', '        closed = true;\n', '        Closed(ethAmount, lrcAmount);\n', '    }\n', '\n', '    /// @dev This default function allows simple usage.\n', '    function () payable {\n', '        require(!closed);\n', '\n', '        if (msg.sender != owner) {\n', '            if (now <= depositStopTime) depositLRC();\n', '            else withdrawLRC();\n', '        }\n', '    }\n', '\n', '\n', '    /// @dev Deposit LRC for ETH.\n', '    /// If user send x ETH, this method will try to transfer `x * 100 * 6500` LRC from\n', "    /// the user's address and send `x * 100` ETH to the user.\n", '    function depositLRC() payable {\n', '        require(!closed && msg.sender != owner);\n', '        require(now <= depositStopTime);\n', '        require(msg.value == 0);\n', '\n', '        var record = records[msg.sender];\n', '        var lrcToken = Token(lrcTokenAddress);\n', '\n', '        uint lrcAmount = this.balance.mul(RATE)\n', '            .min256(lrcToken.balanceOf(msg.sender))\n', '            .min256(lrcToken.allowance(msg.sender, address(this)))\n', '            .min256(MAX_LRC_DEPOSIT_PER_ADDRESS - record.lrcAmount);\n', '\n', '        uint ethAmount = lrcAmount.div(RATE);\n', '        lrcAmount = ethAmount.mul(RATE);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '\n', '        record.lrcAmount += lrcAmount;\n', '        record.timestamp = now;\n', '        records[msg.sender] = record;\n', '\n', '        lrcReceived += lrcAmount;\n', '        ethSent += ethAmount;\n', '\n', '\n', '        Deposit(\n', '                depositId++,\n', '                msg.sender,\n', '                ethAmount,\n', '                lrcAmount\n', '                );\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount));\n', '        msg.sender.transfer(ethAmount);\n', '    }\n', '\n', '    /// @dev Withdrawal LRC with ETH transfer.\n', '    function withdrawLRC() payable {\n', '        require(!closed && msg.sender != owner);\n', '        require(now > depositStopTime);\n', '        require(msg.value > 0);\n', '\n', '        var record = records[msg.sender];\n', '        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n', '        require(now <= record.timestamp + WITHDRAWAL_DELAY + WITHDRAWAL_WINDOW);\n', '\n', '        uint ethAmount = msg.value.min256(record.lrcAmount.div(RATE));\n', '        uint lrcAmount = ethAmount.mul(RATE);\n', '\n', '        record.lrcAmount -= lrcAmount;\n', '        if (record.lrcAmount == 0) {\n', '            delete records[msg.sender];\n', '        } else {\n', '            records[msg.sender] = record;\n', '        }\n', '\n', '        lrcSent += lrcAmount;\n', '        ethReceived += ethAmount;\n', '\n', '        Withdrawal(\n', '                   withdrawId++,\n', '                   msg.sender,\n', '                   ethAmount,\n', '                   lrcAmount\n', '                   );\n', '\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '\n', '        uint ethRefund = msg.value - ethAmount;\n', '        if (ethRefund > 0) {\n', '            msg.sender.transfer(ethRefund);\n', '        }\n', '    }\n', '\n', '    function getLRCAmount(address addr) public constant returns (uint) {\n', '        return records[addr].lrcAmount;\n', '    }\n', '\n', '    function getTimestamp(address addr) public constant returns (uint) {\n', '        return records[addr].timestamp;\n', '    }\n', '}']
