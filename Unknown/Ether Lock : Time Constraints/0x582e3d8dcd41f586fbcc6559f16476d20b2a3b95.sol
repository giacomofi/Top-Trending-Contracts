['contract Token { \n', '    function issue(address _recipient, uint256 _value) returns (bool success) {} \n', '    function totalSupply() constant returns (uint256 supply) {}\n', '    function unlock() returns (bool success) {}\n', '}\n', '\n', 'contract SCLCrowdsale {\n', '\n', '    // Crowdsale details\n', '    address public beneficiary; // Company address multisig (95% funding)\n', '    address public creator; // Creator (5% funding)\n', '    address public confirmedBy; // Address that confirmed beneficiary\n', '    uint256 public minAmount = 294 ether; // ≈ 250k SCL\n', '    uint256 public maxAmount = 100000 ether; // ≈ 50 mln SCL\n', '    uint256 public maxSupply = 50000000 * 10**8; // 50 mln SCL\n', '    uint256 public minAcceptedAmount = 40 finney; // 1/25 ether\n', '\n', '    // Eth to SCL rate\n', '    uint256 public ratePreICO = 850;\n', '    uint256 public rateWaiting = 0;\n', '    uint256 public rateAngelDay = 750;\n', '    uint256 public rateFirstWeek = 700;\n', '    uint256 public rateSecondWeek = 650;\n', '    uint256 public rateThirdWeek = 600;\n', '    uint256 public rateLastWeek = 550;\n', '\n', '    uint256 public ratePreICOEnd = 10 days;\n', '    uint256 public rateWaitingEnd = 20 days;\n', '    uint256 public rateAngelDayEnd = 21 days;\n', '    uint256 public rateFirstWeekEnd = 28 days;\n', '    uint256 public rateSecondWeekEnd = 35 days;\n', '    uint256 public rateThirdWeekEnd = 42 days;\n', '    uint256 public rateLastWeekEnd = 49 days;\n', '\n', '    enum Stages {\n', '        InProgress,\n', '        Ended,\n', '        Withdrawn\n', '    }\n', '\n', '    Stages public stage = Stages.InProgress;\n', '\n', '    // Crowdsale state\n', '    uint256 public start;\n', '    uint256 public end;\n', '    uint256 public raised;\n', '\n', '    // SCL token\n', '    Token public sclToken;\n', '\n', '    // Invested balances\n', '    mapping (address => uint256) balances;\n', '\n', '\n', '    /**\n', '     * Throw if at stage other than current stage\n', '     * \n', '     * @param _stage expected stage to test for\n', '     */\n', '    modifier atStage(Stages _stage) {\n', '        if (stage != _stage) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '    \n', '\n', '    /**\n', '     * Throw if sender is not beneficiary\n', '     */\n', '    modifier onlyBeneficiary() {\n', '        if (beneficiary != msg.sender) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get balance of `_investor` \n', '     * \n', '     * @param _investor The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _investor) constant returns (uint256 balance) {\n', '        return balances[_investor];\n', '    }\n', '\n', '\n', '    /**\n', '     * Construct\n', '     *\n', '     * @param _tokenAddress The address of the SCL token contact\n', '     */\n', '    function SCLCrowdsale(address _tokenAddress, address _beneficiary, address _creator, uint256 _start) {\n', '        sclToken = Token(_tokenAddress);\n', '        beneficiary = _beneficiary;\n', '        creator = _creator;\n', '        start = _start;\n', '        end = start + rateLastWeekEnd;\n', '    }\n', '\n', '\n', '    /**\n', '     * For testing purposes\n', '     *\n', '     * @return The beneficiary address\n', '     */\n', '    function confirmBeneficiary() onlyBeneficiary {\n', '        confirmedBy = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in SCL using \n', '     * the current rate\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @return The amount in SCL\n', '     */\n', '    function toSCL(uint256 _wei) returns (uint256 amount) {\n', '        uint256 rate = 0;\n', '        if (stage != Stages.Ended && now >= start && now <= end) {\n', '\n', '            // Check for preico\n', '            if (now <= start + ratePreICOEnd) {\n', '                rate = ratePreICO;\n', '            }\n', '\n', '            // Check for waiting period\n', '            else if (now <= start + rateWaitingEnd) {\n', '                rate = rateWaiting;\n', '            }\n', '\n', '            // Check for angelday\n', '            else if (now <= start + rateAngelDayEnd) {\n', '                rate = rateAngelDay;\n', '            }\n', '\n', '            // Check first week\n', '            else if (now <= start + rateFirstWeekEnd) {\n', '                rate = rateFirstWeek;\n', '            }\n', '\n', '            // Check second week\n', '            else if (now <= start + rateSecondWeekEnd) {\n', '                rate = rateSecondWeek;\n', '            }\n', '\n', '            // Check third week\n', '            else if (now <= start + rateThirdWeekEnd) {\n', '                rate = rateThirdWeek;\n', '            }\n', '\n', '            // Check last week\n', '            else if (now <= start + rateLastWeekEnd) {\n', '                rate = rateLastWeek;\n', '            }\n', '        }\n', '\n', '        return _wei * rate * 10**8 / 1 ether; // 10**8 for 8 decimals\n', '    }\n', '\n', '\n', '    /**\n', '     * Function to end the crowdsale by setting \n', '     * the stage to Ended\n', '     */\n', '    function endCrowdsale() atStage(Stages.InProgress) {\n', '\n', '        // Crowdsale not ended yet\n', '        if (now < end) {\n', '            throw;\n', '        }\n', '\n', '        stage = Stages.Ended;\n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer appropriate percentage of raised amount \n', '     * to the company address\n', '     */\n', '    function withdraw() onlyBeneficiary atStage(Stages.Ended) {\n', '\n', '        // Confirm that minAmount is raised\n', '        if (raised < minAmount) {\n', '            throw;\n', '        }\n', '\n', '        if (!sclToken.unlock()) {\n', '            throw;\n', '        }\n', '\n', '        uint256 ethBalance = this.balance;\n', '\n', '        // 5% eth\n', '        uint256 ethFees = ethBalance * 5 / 10**2;\n', '        if (!creator.send(ethFees)) {\n', '            throw;\n', '        }\n', '\n', '        // 95% eth\n', '        if (!beneficiary.send(ethBalance - ethFees)) {\n', '            throw;\n', '        }\n', '\n', '        stage = Stages.Withdrawn;\n', '    }\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end\n', '     */\n', '    function refund() atStage(Stages.Ended) {\n', '\n', '        // Only allow refunds if minAmount is not raised\n', '        if (raised >= minAmount) {\n', '            throw;\n', '        }\n', '\n', '        uint256 receivedAmount = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '\n', '        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {\n', '            balances[msg.sender] = receivedAmount;\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '     * Receives Eth and issue SCL tokens to the sender\n', '     */\n', '    function () payable atStage(Stages.InProgress) {\n', '\n', '        // Crowdsale not started yet\n', '        if (now < start) {\n', '            throw;\n', '        }\n', '\n', '        // Crowdsale expired\n', '        if (now > end) {\n', '            throw;\n', '        }\n', '\n', '        // Enforce min amount\n', '        if (msg.value < minAcceptedAmount) {\n', '            throw;\n', '        }\n', ' \n', '        uint256 received = msg.value;\n', '        uint256 valueInSCL = toSCL(msg.value);\n', '\n', '        // Period between pre-ico and ico\n', '        if (valueInSCL == 0) {\n', '            throw;\n', '        }\n', '\n', '        if (!sclToken.issue(msg.sender, valueInSCL)) {\n', '            throw;\n', '        }\n', '\n', '        // Fees\n', '        uint256 sclFees = valueInSCL * 5 / 10**2;\n', '\n', '        // 5% tokens\n', '        if (!sclToken.issue(creator, sclFees)) {\n', '            throw;\n', '        }\n', '\n', '        if (now <= start + ratePreICOEnd) {\n', '\n', '            // Fees\n', '            uint256 ethFees = received * 5 / 10**2;\n', '\n', '            // 5% eth\n', '            if (!creator.send(ethFees)) {\n', '                throw;\n', '            }\n', '\n', '            // During pre-ico - Non-Refundable\n', '            if (!beneficiary.send(received - ethFees)) {\n', '                throw;\n', '            }\n', '\n', '        } else {\n', '\n', '            // During the ICO\n', '            balances[msg.sender] += received; // 100% refundable\n', '        }\n', '\n', '        raised += received;\n', '\n', '        // Check maxAmount raised\n', '        if (raised >= maxAmount || sclToken.totalSupply() >= maxSupply) {\n', '            stage = Stages.Ended;\n', '        }\n', '    }\n', '}']
['contract Token { \n', '    function issue(address _recipient, uint256 _value) returns (bool success) {} \n', '    function totalSupply() constant returns (uint256 supply) {}\n', '    function unlock() returns (bool success) {}\n', '}\n', '\n', 'contract SCLCrowdsale {\n', '\n', '    // Crowdsale details\n', '    address public beneficiary; // Company address multisig (95% funding)\n', '    address public creator; // Creator (5% funding)\n', '    address public confirmedBy; // Address that confirmed beneficiary\n', '    uint256 public minAmount = 294 ether; // ≈ 250k SCL\n', '    uint256 public maxAmount = 100000 ether; // ≈ 50 mln SCL\n', '    uint256 public maxSupply = 50000000 * 10**8; // 50 mln SCL\n', '    uint256 public minAcceptedAmount = 40 finney; // 1/25 ether\n', '\n', '    // Eth to SCL rate\n', '    uint256 public ratePreICO = 850;\n', '    uint256 public rateWaiting = 0;\n', '    uint256 public rateAngelDay = 750;\n', '    uint256 public rateFirstWeek = 700;\n', '    uint256 public rateSecondWeek = 650;\n', '    uint256 public rateThirdWeek = 600;\n', '    uint256 public rateLastWeek = 550;\n', '\n', '    uint256 public ratePreICOEnd = 10 days;\n', '    uint256 public rateWaitingEnd = 20 days;\n', '    uint256 public rateAngelDayEnd = 21 days;\n', '    uint256 public rateFirstWeekEnd = 28 days;\n', '    uint256 public rateSecondWeekEnd = 35 days;\n', '    uint256 public rateThirdWeekEnd = 42 days;\n', '    uint256 public rateLastWeekEnd = 49 days;\n', '\n', '    enum Stages {\n', '        InProgress,\n', '        Ended,\n', '        Withdrawn\n', '    }\n', '\n', '    Stages public stage = Stages.InProgress;\n', '\n', '    // Crowdsale state\n', '    uint256 public start;\n', '    uint256 public end;\n', '    uint256 public raised;\n', '\n', '    // SCL token\n', '    Token public sclToken;\n', '\n', '    // Invested balances\n', '    mapping (address => uint256) balances;\n', '\n', '\n', '    /**\n', '     * Throw if at stage other than current stage\n', '     * \n', '     * @param _stage expected stage to test for\n', '     */\n', '    modifier atStage(Stages _stage) {\n', '        if (stage != _stage) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '    \n', '\n', '    /**\n', '     * Throw if sender is not beneficiary\n', '     */\n', '    modifier onlyBeneficiary() {\n', '        if (beneficiary != msg.sender) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '\n', '    /** \n', '     * Get balance of `_investor` \n', '     * \n', '     * @param _investor The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _investor) constant returns (uint256 balance) {\n', '        return balances[_investor];\n', '    }\n', '\n', '\n', '    /**\n', '     * Construct\n', '     *\n', '     * @param _tokenAddress The address of the SCL token contact\n', '     */\n', '    function SCLCrowdsale(address _tokenAddress, address _beneficiary, address _creator, uint256 _start) {\n', '        sclToken = Token(_tokenAddress);\n', '        beneficiary = _beneficiary;\n', '        creator = _creator;\n', '        start = _start;\n', '        end = start + rateLastWeekEnd;\n', '    }\n', '\n', '\n', '    /**\n', '     * For testing purposes\n', '     *\n', '     * @return The beneficiary address\n', '     */\n', '    function confirmBeneficiary() onlyBeneficiary {\n', '        confirmedBy = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in SCL using \n', '     * the current rate\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @return The amount in SCL\n', '     */\n', '    function toSCL(uint256 _wei) returns (uint256 amount) {\n', '        uint256 rate = 0;\n', '        if (stage != Stages.Ended && now >= start && now <= end) {\n', '\n', '            // Check for preico\n', '            if (now <= start + ratePreICOEnd) {\n', '                rate = ratePreICO;\n', '            }\n', '\n', '            // Check for waiting period\n', '            else if (now <= start + rateWaitingEnd) {\n', '                rate = rateWaiting;\n', '            }\n', '\n', '            // Check for angelday\n', '            else if (now <= start + rateAngelDayEnd) {\n', '                rate = rateAngelDay;\n', '            }\n', '\n', '            // Check first week\n', '            else if (now <= start + rateFirstWeekEnd) {\n', '                rate = rateFirstWeek;\n', '            }\n', '\n', '            // Check second week\n', '            else if (now <= start + rateSecondWeekEnd) {\n', '                rate = rateSecondWeek;\n', '            }\n', '\n', '            // Check third week\n', '            else if (now <= start + rateThirdWeekEnd) {\n', '                rate = rateThirdWeek;\n', '            }\n', '\n', '            // Check last week\n', '            else if (now <= start + rateLastWeekEnd) {\n', '                rate = rateLastWeek;\n', '            }\n', '        }\n', '\n', '        return _wei * rate * 10**8 / 1 ether; // 10**8 for 8 decimals\n', '    }\n', '\n', '\n', '    /**\n', '     * Function to end the crowdsale by setting \n', '     * the stage to Ended\n', '     */\n', '    function endCrowdsale() atStage(Stages.InProgress) {\n', '\n', '        // Crowdsale not ended yet\n', '        if (now < end) {\n', '            throw;\n', '        }\n', '\n', '        stage = Stages.Ended;\n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer appropriate percentage of raised amount \n', '     * to the company address\n', '     */\n', '    function withdraw() onlyBeneficiary atStage(Stages.Ended) {\n', '\n', '        // Confirm that minAmount is raised\n', '        if (raised < minAmount) {\n', '            throw;\n', '        }\n', '\n', '        if (!sclToken.unlock()) {\n', '            throw;\n', '        }\n', '\n', '        uint256 ethBalance = this.balance;\n', '\n', '        // 5% eth\n', '        uint256 ethFees = ethBalance * 5 / 10**2;\n', '        if (!creator.send(ethFees)) {\n', '            throw;\n', '        }\n', '\n', '        // 95% eth\n', '        if (!beneficiary.send(ethBalance - ethFees)) {\n', '            throw;\n', '        }\n', '\n', '        stage = Stages.Withdrawn;\n', '    }\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end\n', '     */\n', '    function refund() atStage(Stages.Ended) {\n', '\n', '        // Only allow refunds if minAmount is not raised\n', '        if (raised >= minAmount) {\n', '            throw;\n', '        }\n', '\n', '        uint256 receivedAmount = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '\n', '        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {\n', '            balances[msg.sender] = receivedAmount;\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '     * Receives Eth and issue SCL tokens to the sender\n', '     */\n', '    function () payable atStage(Stages.InProgress) {\n', '\n', '        // Crowdsale not started yet\n', '        if (now < start) {\n', '            throw;\n', '        }\n', '\n', '        // Crowdsale expired\n', '        if (now > end) {\n', '            throw;\n', '        }\n', '\n', '        // Enforce min amount\n', '        if (msg.value < minAcceptedAmount) {\n', '            throw;\n', '        }\n', ' \n', '        uint256 received = msg.value;\n', '        uint256 valueInSCL = toSCL(msg.value);\n', '\n', '        // Period between pre-ico and ico\n', '        if (valueInSCL == 0) {\n', '            throw;\n', '        }\n', '\n', '        if (!sclToken.issue(msg.sender, valueInSCL)) {\n', '            throw;\n', '        }\n', '\n', '        // Fees\n', '        uint256 sclFees = valueInSCL * 5 / 10**2;\n', '\n', '        // 5% tokens\n', '        if (!sclToken.issue(creator, sclFees)) {\n', '            throw;\n', '        }\n', '\n', '        if (now <= start + ratePreICOEnd) {\n', '\n', '            // Fees\n', '            uint256 ethFees = received * 5 / 10**2;\n', '\n', '            // 5% eth\n', '            if (!creator.send(ethFees)) {\n', '                throw;\n', '            }\n', '\n', '            // During pre-ico - Non-Refundable\n', '            if (!beneficiary.send(received - ethFees)) {\n', '                throw;\n', '            }\n', '\n', '        } else {\n', '\n', '            // During the ICO\n', '            balances[msg.sender] += received; // 100% refundable\n', '        }\n', '\n', '        raised += received;\n', '\n', '        // Check maxAmount raised\n', '        if (raised >= maxAmount || sclToken.totalSupply() >= maxSupply) {\n', '            stage = Stages.Ended;\n', '        }\n', '    }\n', '}']
