['pragma solidity ^0.4.8;\n', '\n', '// folio.ninja ERC20 Token & Crowdsale Contract\n', '// Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1c75727a735c7a7370757332727572767d">[email&#160;protected]</a>\n', '// Cap of 12,632,000 Tokens\n', '// 632,000 Tokens to Foundation\n', '// 25,000 ETH Cap that goes to Developers\n', '// Allows subsequent contribution / minting if cap not reached.\n', '\n', 'contract Assertive {\n', '  function assert(bool assertion) internal {\n', '      if (!assertion) throw;\n', '  }\n', '}\n', '\n', 'contract SafeMath is Assertive{\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20Protocol {\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ERC20 is ERC20Protocol {\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    uint256 public totalSupply;\n', '}\n', '\n', '// Folio Ninja Token Contract\n', 'contract FolioNinjaToken is ERC20, SafeMath {\n', '    // Consant token specific fields\n', '    string public constant name = "folio.ninja";\n', '    string public constant symbol = "FLN";\n', '    uint public constant decimals = 18;\n', '    uint public constant MAX_TOTAL_TOKEN_AMOUNT = 12632000 * 10 ** decimals;\n', '\n', '    // Fields that are only changed in constructor\n', '    address public minter; // Contribution contract\n', '    address public FOUNDATION_WALLET; // Can change to other minting contribution contracts but only until total amount of token minted\n', '    uint public startTime; // Contribution start time in seconds\n', '    uint public endTime; // Contribution end time in seconds\n', '\n', '    // MODIFIERS\n', '    modifier only_minter {\n', '        assert(msg.sender == minter);\n', '        _;\n', '    }\n', '\n', '    modifier only_foundation {\n', '        assert(msg.sender == FOUNDATION_WALLET);\n', '        _;\n', '    }\n', '\n', '    modifier is_later_than(uint x) {\n', '        assert(now > x);\n', '        _;\n', '    }\n', '\n', '    modifier max_total_token_amount_not_reached(uint amount) {\n', '        assert(safeAdd(totalSupply, amount) <= MAX_TOTAL_TOKEN_AMOUNT);\n', '        _;\n', '    }\n', '\n', '    // METHODS\n', '    function FolioNinjaToken(address setMinter, address setFoundation, uint setStartTime, uint setEndTime) {\n', '        minter = setMinter;\n', '        FOUNDATION_WALLET = setFoundation;\n', '        startTime = setStartTime;\n', '        endTime = setEndTime;\n', '    }\n', '\n', '    /// Pre: Address of contribution contract (minter) is set\n', '    /// Post: Mints token\n', '    function mintToken(address recipient, uint amount)\n', '        external\n', '        only_minter\n', '        max_total_token_amount_not_reached(amount)\n', '    {\n', '        balances[recipient] = safeAdd(balances[recipient], amount);\n', '        totalSupply = safeAdd(totalSupply, amount);\n', '    }\n', '\n', '    /// Pre: Prevent transfers until contribution period is over.\n', '    /// Post: Transfer FLN from msg.sender\n', '    /// Note: ERC20 interface\n', '    function transfer(address recipient, uint amount)\n', '        is_later_than(endTime)\n', '        returns (bool success)\n', '    {\n', '        return super.transfer(recipient, amount);\n', '    }\n', '\n', '    /// Pre: Prevent transfers until contribution period is over.\n', '    /// Post: Transfer FLN from arbitrary address\n', '    /// Note: ERC20 interface\n', '    function transferFrom(address sender, address recipient, uint amount)\n', '        is_later_than(endTime)\n', '        returns (bool success)\n', '    {\n', '        return super.transferFrom(sender, recipient, amount);\n', '    }\n', '\n', '    /// Pre: minting address is set. Restricted to foundation.\n', '    /// Post: New minter can now create tokens up to MAX_TOTAL_TOKEN_AMOUNT.\n', '    /// Note: This allows additional contribution periods at a later stage, while still using the same ERC20 compliant contract.\n', '    function changeMintingAddress(address newMintingAddress) only_foundation { minter = newMintingAddress; }\n', '\n', '    /// Pre: foundation address is set. Restricted to foundation.\n', '    /// Post: New address set. This address controls the setting of the minter address\n', '    function changeFoundationAddress(address newFoundationAddress) only_foundation { FOUNDATION_WALLET = newFoundationAddress; }\n', '}\n', '\n', '/// @title Contribution Contract\n', 'contract Contribution is SafeMath {\n', '    // FIELDS\n', '\n', '    // Constant fields\n', '    uint public constant ETHER_CAP = 25000 ether; // Max amount raised during first contribution; targeted amount AUD 7M\n', '    uint public constant MAX_CONTRIBUTION_DURATION = 8 weeks; // Max amount in seconds of contribution period\n', '\n', '    // Price Rates\n', '    uint public constant PRICE_RATE_FIRST = 480;\n', '    uint public constant PRICE_RATE_SECOND = 460;\n', '    uint public constant PRICE_RATE_THIRD = 440;\n', '    uint public constant PRICE_RATE_FOURTH = 400;\n', '\n', '    // Foundation Holdings\n', '    uint public constant FOUNDATION_TOKENS = 632000 ether;\n', '\n', '    // Fields that are only changed in constructor\n', '    address public FOUNDATION_WALLET; // folio.ninja foundation wallet\n', '    address public DEV_WALLET; // folio.ninja multisig wallet\n', '\n', '    uint public startTime; // Contribution start time in seconds\n', '    uint public endTime; // Contribution end time in seconds\n', '\n', '    FolioNinjaToken public folioToken; // Contract of the ERC20 compliant folio.ninja token\n', '\n', '    // Fields that can be changed by functions\n', '    uint public etherRaised; // This will keep track of the Ether raised during the contribution\n', '    bool public halted; // The foundation address can set this to true to halt the contribution due to an emergency\n', '\n', '    // EVENTS\n', '    event TokensBought(address indexed sender, uint eth, uint amount);\n', '\n', '    // MODIFIERS\n', '    modifier only_foundation {\n', '        assert(msg.sender == FOUNDATION_WALLET);\n', '        _;\n', '    }\n', '\n', '    modifier is_not_halted {\n', '        assert(!halted);\n', '        _;\n', '    }\n', '\n', '    modifier ether_cap_not_reached {\n', '        assert(safeAdd(etherRaised, msg.value) <= ETHER_CAP);\n', '        _;\n', '    }\n', '\n', '    modifier is_not_earlier_than(uint x) {\n', '        assert(now >= x);\n', '        _;\n', '    }\n', '\n', '    modifier is_earlier_than(uint x) {\n', '        assert(now < x);\n', '        _;\n', '    }\n', '\n', '    // CONSTANT METHODS\n', '\n', '    /// Pre: startTime, endTime specified in constructor,\n', '    /// Post: Price rate at given blockTime; One ether equals priceRate() of FLN tokens\n', '    function priceRate() constant returns (uint) {\n', '        // Four price tiers\n', '        if (startTime <= now && now < startTime + 1 weeks)\n', '            return PRICE_RATE_FIRST;\n', '        if (startTime + 1 weeks <= now && now < startTime + 2 weeks)\n', '            return PRICE_RATE_SECOND;\n', '        if (startTime + 2 weeks <= now && now < startTime + 3 weeks)\n', '            return PRICE_RATE_THIRD;\n', '        if (startTime + 3 weeks <= now && now < endTime)\n', '            return PRICE_RATE_FOURTH;\n', '        // Should not be called before or after contribution period\n', '        assert(false);\n', '    }\n', '\n', '    // NON-CONSTANT METHODS\n', '    function Contribution(address setDevWallet, address setFoundationWallet, uint setStartTime) {\n', '        DEV_WALLET = setDevWallet;\n', '        FOUNDATION_WALLET = setFoundationWallet;\n', '        startTime = setStartTime;\n', '        endTime = startTime + MAX_CONTRIBUTION_DURATION;\n', '        folioToken = new FolioNinjaToken(this, FOUNDATION_WALLET, startTime, endTime); // Create Folio Ninja Token Contract\n', '\n', '        // Mint folio.ninja foundation tokens\n', '        folioToken.mintToken(FOUNDATION_WALLET, FOUNDATION_TOKENS);\n', '    }\n', '\n', '    /// Pre: N/a\n', '    /// Post: Bought folio.ninja tokens according to priceRate() and msg.value\n', '    function () payable { buyRecipient(msg.sender); }\n', '\n', '    /// Pre: N/a\n', '    /// Post: Bought folio ninja tokens according to priceRate() and msg.value on behalf of recipient\n', '    function buyRecipient(address recipient)\n', '        payable\n', '        is_not_earlier_than(startTime)\n', '        is_earlier_than(endTime)\n', '        is_not_halted\n', '        ether_cap_not_reached\n', '    {\n', '        uint amount = safeMul(msg.value, priceRate());\n', '        folioToken.mintToken(recipient, amount);\n', '        etherRaised = safeAdd(etherRaised, msg.value);\n', '        assert(DEV_WALLET.send(msg.value));\n', '        TokensBought(recipient, msg.value, amount);\n', '    }\n', '\n', '    /// Pre: Emergency situation that requires contribution period to stop.\n', '    /// Post: Contributing not possible anymore.\n', '    function halt() only_foundation { halted = true; }\n', '\n', '    /// Pre: Emergency situation resolved.\n', '    /// Post: Contributing becomes possible again.\n', '    function unhalt() only_foundation { halted = false; }\n', '\n', '    /// Pre: Restricted to foundation.\n', '    /// Post: New address set. To halt contribution and/or change minter in FolioNinjaToken contract.\n', '    function changeFoundationAddress(address newFoundationAddress) only_foundation { FOUNDATION_WALLET = newFoundationAddress; }\n', '\n', '    /// Pre: Restricted to foundation.\n', '    /// Post: New address set. To change beneficiary of contributions\n', '    function changeDevAddress(address newDevAddress) only_foundation { DEV_WALLET = newDevAddress; }\n', '}']