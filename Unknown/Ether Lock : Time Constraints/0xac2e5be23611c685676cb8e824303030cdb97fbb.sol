['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Shareable\n', ' * @dev inheritable "property" contract that enables methods to be protected by requiring the\n', ' * acquiescence of either a single, or, crucially, each of a number of, designated owners.\n', ' * @dev Usage: use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by some number (specified in constructor) of the set of owners (specified in the constructor) before the interior is executed.\n', ' */\n', 'contract Shareable {\n', '\n', '  // struct for the status of a pending operation.\n', '  struct PendingState {\n', '    uint yetNeeded;\n', '    uint ownersDone;\n', '    uint index;\n', '  }\n', '\n', '  // the number of owners that must confirm the same operation before it is run.\n', '  uint public required;\n', '\n', '  // list of owners\n', '  address[256] owners;\n', '  // index on the list of owners to allow reverse lookup\n', '  mapping(address => uint) ownerIndex;\n', '  // the ongoing operations.\n', '  mapping(bytes32 => PendingState) pendings;\n', '  bytes32[] pendingsIndex;\n', '\n', '\n', '  // this contract only has six types of events: it can accept a confirmation, in which case\n', '  // we record owner and operation (hash) alongside it.\n', '  event Confirmation(address owner, bytes32 operation);\n', '  event Revoke(address owner, bytes32 operation);\n', '\n', '\n', '  // simple single-sig function modifier.\n', '  modifier onlyOwner {\n', '    if (!isOwner(msg.sender)) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier for multisig functions.\n', '   * @param _operation The operation must have an intrinsic hash in order that later attempts can be\n', '   * realised as the same underlying operation and thus count as confirmations.\n', '   */\n', '  modifier onlymanyowners(bytes32 _operation) {\n', '    if (confirmAndCheck(_operation)) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Constructor is given the number of sigs required to do protected "onlymanyowners"\n', '   * transactions as well as the selection of addresses capable of confirming them.\n', '   * @param _owners A list of owners.\n', '   * @param _required The amount required for a transaction to be approved.\n', '   */\n', '  function Shareable(address[] _owners, uint _required) {\n', '    owners[1] = msg.sender;\n', '    ownerIndex[msg.sender] = 1;\n', '    for (uint i = 0; i < _owners.length; ++i) {\n', '      owners[2 + i] = _owners[i];\n', '      ownerIndex[_owners[i]] = 2 + i;\n', '    }\n', '    required = _required;\n', '    if (required > owners.length) {\n', '      throw;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Revokes a prior confirmation of the given operation.\n', '   * @param _operation A string identifying the operation.\n', '   */\n', '  function revoke(bytes32 _operation) external {\n', '    uint index = ownerIndex[msg.sender];\n', '    // make sure they&#39;re an owner\n', '    if (index == 0) {\n', '      return;\n', '    }\n', '    uint ownerIndexBit = 2**index;\n', '    var pending = pendings[_operation];\n', '    if (pending.ownersDone & ownerIndexBit > 0) {\n', '      pending.yetNeeded++;\n', '      pending.ownersDone -= ownerIndexBit;\n', '      Revoke(msg.sender, _operation);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets an owner by 0-indexed position (using numOwners as the count)\n', '   * @param ownerIndex Uint The index of the owner\n', '   * @return The address of the owner\n', '   */\n', '  function getOwner(uint ownerIndex) external constant returns (address) {\n', '    return address(owners[ownerIndex + 1]);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if given address is an owner.\n', '   * @param _addr address The address which you want to check.\n', '   * @return True if the address is an owner and fase otherwise.\n', '   */\n', '  function isOwner(address _addr) constant returns (bool) {\n', '    return ownerIndex[_addr] > 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check is specific owner has already confirme the operation.\n', '   * @param _operation The operation identifier.\n', '   * @param _owner The owner address.\n', '   * @return True if the owner has confirmed and false otherwise.\n', '   */\n', '  function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n', '    var pending = pendings[_operation];\n', '    uint index = ownerIndex[_owner];\n', '\n', '    // make sure they&#39;re an owner\n', '    if (index == 0) {\n', '      return false;\n', '    }\n', '\n', '    // determine the bit to set for this owner.\n', '    uint ownerIndexBit = 2**index;\n', '    return !(pending.ownersDone & ownerIndexBit == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Confirm and operation and checks if it&#39;s already executable.\n', '   * @param _operation The operation identifier.\n', '   * @return Returns true when operation can be executed.\n', '   */\n', '  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n', '    // determine what index the present sender is:\n', '    uint index = ownerIndex[msg.sender];\n', '    // make sure they&#39;re an owner\n', '    if (index == 0) {\n', '      throw;\n', '    }\n', '\n', '    var pending = pendings[_operation];\n', '    // if we&#39;re not yet working on this operation, switch over and reset the confirmation status.\n', '    if (pending.yetNeeded == 0) {\n', '      // reset count of confirmations needed.\n', '      pending.yetNeeded = required;\n', '      // reset which owners have confirmed (none) - set our bitmap to 0.\n', '      pending.ownersDone = 0;\n', '      pending.index = pendingsIndex.length++;\n', '      pendingsIndex[pending.index] = _operation;\n', '    }\n', '    // determine the bit to set for this owner.\n', '    uint ownerIndexBit = 2**index;\n', '    // make sure we (the message sender) haven&#39;t confirmed this operation previously.\n', '    if (pending.ownersDone & ownerIndexBit == 0) {\n', '      Confirmation(msg.sender, _operation);\n', '      // ok - check if count is enough to go ahead.\n', '      if (pending.yetNeeded <= 1) {\n', '        // enough confirmations: reset and run interior.\n', '        delete pendingsIndex[pendings[_operation].index];\n', '        delete pendings[_operation];\n', '        return true;\n', '      } else {\n', '        // not enough: record that this owner in particular confirmed.\n', '        pending.yetNeeded--;\n', '        pending.ownersDone |= ownerIndexBit;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Clear the pending list.\n', '   */\n', '  function clearPending() internal {\n', '    uint length = pendingsIndex.length;\n', '    for (uint i = 0; i < length; ++i) {\n', '      if (pendingsIndex[i] != 0) {\n', '        delete pendings[pendingsIndex[i]];\n', '      }\n', '    }\n', '    delete pendingsIndex;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title BTH\n', ' * @notice BTC + ETH = BTH\n', ' */\n', '\n', 'contract BTH is StandardToken, Shareable {\n', '  using SafeMath for uint256;\n', '\n', '  /*\n', '   * Constants\n', '   */\n', '  string public constant name = "Bether";\n', '  string public constant symbol = "BTH";\n', '  uint256 public constant decimals = 18;\n', '  string public version = "1.0";\n', '\n', '  uint256 public constant INITIAL_SUBSIDY = 50 * 10**decimals;\n', '  uint256 public constant HASH_RATE_MULTIPLIER = 1;\n', '\n', '  /*\n', '   * Events\n', '   */\n', '  event LogContribution(address indexed _miner, uint256 _value, uint256 _hashRate, uint256 _block, uint256 _halving);\n', '  event LogClaimHalvingSubsidy(address indexed _miner, uint256 _block, uint256 _halving, uint256 _value);\n', '  event LogRemainingHalvingSubsidy(uint256 _halving, uint256 _value);\n', '  event LogPause(bytes32 indexed _hash);\n', '  event LogUnPause(bytes32 indexed _hash);\n', '  event LogBTHFoundationWalletChanged(address indexed _wallet);\n', '  event LogPollCreated(bytes32 indexed _hash);\n', '  event LogPollDeleted(bytes32 indexed _hash);\n', '  event LogPollVoted(bytes32 indexed _hash, address indexed _miner, uint256 _hashRate);\n', '  event LogPollApproved(bytes32 indexed _hash);\n', '\n', '  /*\n', '   * Storage vars\n', '   */\n', '  mapping (uint256 => HalvingHashRate) halvingsHashRate; // Holds the accumulated hash rate per halving\n', '  mapping (uint256 => Subsidy) halvingsSubsidies; // Stores the remaining subsidy per halving\n', '  mapping (address => Miner) miners; // Miners data\n', '  mapping (bytes32 => Poll) polls; // Contract polls\n', '\n', '  address public bthFoundationWallet;\n', '  uint256 public subsidyHalvingInterval;\n', '  uint256 public maxHalvings;\n', '  uint256 public genesis;\n', '  uint256 public totalHashRate;\n', '  bool public paused;\n', '\n', '  struct HalvingHashRate {\n', '    bool carried; // Indicates that the previous hash rate have been added to the halving\n', '    uint256 rate; // Hash rate of the halving\n', '  }\n', '\n', '  struct Miner {\n', '    uint256 block; // Miner block, used to calculate in which halving is the miner\n', '    uint256 totalHashRate; // Accumulated miner hash rate\n', '    mapping (uint256 => MinerHashRate) hashRate;\n', '  }\n', '\n', '  struct MinerHashRate {\n', '    bool carried;\n', '    uint256 rate;\n', '  }\n', '\n', '  struct Subsidy {\n', '    bool claimed;  // Flag that indicates that the subsidy has been claimed at least one time, just to\n', '                   // compute the initial halving subsidy value\n', '    uint256 value; // Remaining subsidy of a halving\n', '  }\n', '\n', '  struct Poll {\n', '    bool exists;  // Indicates that the poll is created\n', '    string title; // Title of the poll, it&#39;s the poll indentifier so it must be unique\n', '    mapping (address => bool) votes; // Control who have voted\n', '    uint8 percentage; // Percentage which determines if the poll has been approved\n', '    uint256 hashRate; // Summed hash rate of all the voters\n', '    bool approved; // True if the poll has been approved\n', '    uint256 approvalBlock; // Block in which the poll was approved\n', '    uint256 approvalHashRate; // Hash rate that caused the poll approval\n', '    uint256 approvalTotalHashRate; // Total has rate in when the poll was approved\n', '  }\n', '\n', '  /*\n', '   * Modifiers\n', '   */\n', '  modifier notBeforeGenesis() {\n', '    require(block.number >= genesis);\n', '    _;\n', '  }\n', '\n', '  modifier nonZero(uint256 _value) {\n', '    require(_value > 0);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address _address) {\n', '    require(_address != address(0));\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroValued() {\n', '    require(msg.value != 0);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroLength(address[] array) {\n', '    require(array.length != 0);\n', '    _;\n', '  }\n', '\n', '  modifier notPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier notGreaterThanCurrentBlock(uint256 _block) {\n', '    require(_block <= currentBlock());\n', '    _;\n', '  }\n', '\n', '  modifier isMiner(address _address) {\n', '    require(miners[_address].block != 0);\n', '    _;\n', '  }\n', '\n', '  modifier pollApproved(bytes32 _hash) {\n', '    require(polls[_hash].approved);\n', '    _;\n', '  }\n', '\n', '  /*\n', '   * Public functions\n', '   */\n', '\n', '  /**\n', '    @notice Contract constructor\n', '    @param _bthFoundationMembers are the addresses that control the BTH contract\n', '    @param _required number of memers needed to execute management functions of the contract\n', '    @param _bthFoundationWallet wallet that holds all the contract contributions\n', '    @param _genesis block number in which the BTH contract will be active\n', '    @param _subsidyHalvingInterval number of blocks which comprises a halving\n', '    @param _maxHalvings number of halvings that will generate BTH\n', '  **/\n', '  function BTH(\n', '    address[] _bthFoundationMembers,\n', '    uint256 _required,\n', '    address _bthFoundationWallet,\n', '    uint256 _genesis,\n', '    uint256 _subsidyHalvingInterval,\n', '    uint256 _maxHalvings\n', '  ) Shareable( _bthFoundationMembers, _required)\n', '    nonZeroLength(_bthFoundationMembers)\n', '    nonZero(_required)\n', '    nonZeroAddress(_bthFoundationWallet)\n', '    nonZero(_genesis)\n', '    nonZero(_subsidyHalvingInterval)\n', '    nonZero(_maxHalvings)\n', '  {\n', '    // Genesis block must be greater or equal than the current block\n', '    if (_genesis < block.number) throw;\n', '\n', '    bthFoundationWallet = _bthFoundationWallet;\n', '    subsidyHalvingInterval = _subsidyHalvingInterval;\n', '    maxHalvings = _maxHalvings;\n', '\n', '    genesis = _genesis;\n', '    totalSupply = 0;\n', '    totalHashRate = 0;\n', '    paused = false;\n', '  }\n', '\n', '  /**\n', '    @notice Contract desctruction function\n', '    @param _hash poll hash that authorizes the function call\n', '  **/\n', '  function kill(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    selfdestruct(bthFoundationWallet);\n', '  }\n', '\n', '  /**\n', '    @notice Contract desctruction function with ethers redirection\n', '    @param _hash poll hash that authorizes the function call\n', '  **/\n', '  function killTo(address _to, bytes32 _hash)\n', '    external\n', '    nonZeroAddress(_to)\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    selfdestruct(_to);\n', '  }\n', '\n', '  /**\n', '    @notice Pause the contract operations\n', '    @param _hash poll hash that authorizes the pause\n', '  **/\n', '  function pause(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '    notBeforeGenesis\n', '  {\n', '    if (!paused) {\n', '      paused = true;\n', '      LogPause(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Unpause the contract operations\n', '    @param _hash poll hash that authorizes the unpause\n', '  **/\n', '  function unPause(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '    notBeforeGenesis\n', '  {\n', '    if (paused) {\n', '      paused = false;\n', '      LogUnPause(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Set the bthFoundation wallet\n', '    @param _wallet new wallet address\n', '  **/\n', '  function setBTHFoundationWallet(address _wallet)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '    nonZeroAddress(_wallet)\n', '  {\n', '    bthFoundationWallet = _wallet;\n', '    LogBTHFoundationWalletChanged(_wallet);\n', '  }\n', '\n', '  /**\n', '    @notice Returns the current BTH block\n', '    @return current bth block number\n', '  **/\n', '  function currentBlock()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return block.number.sub(genesis);\n', '  }\n', '\n', '   /**\n', '    @notice Calculates the halving number of a given block\n', '    @param _block block number\n', '    @return the halving of the block\n', '  **/\n', '  function blockHalving(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _block.div(subsidyHalvingInterval);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the offset of a given block\n', '    @return the offset of the block in a halving\n', '  **/\n', '  function blockOffset(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _block % subsidyHalvingInterval;\n', '  }\n', '\n', '  /**\n', '    @notice Determine the current halving number\n', '    @return the current halving\n', '  **/\n', '  function currentHalving()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return blockHalving(currentBlock());\n', '  }\n', '\n', '  /**\n', '    @notice Compute the starting block of a halving\n', '    @return the initial halving block\n', '  **/\n', '  function halvingStartBlock(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _halving.mul(subsidyHalvingInterval);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the total subsidy of a block\n', '    @param _block block number\n', '    @return the total amount that will be shared with the miners\n', '  **/\n', '  function blockSubsidy(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    uint256 halvings = _block.div(subsidyHalvingInterval);\n', '\n', '    if (halvings >= maxHalvings) return 0;\n', '\n', '    uint256 subsidy = INITIAL_SUBSIDY >> halvings;\n', '\n', '    return subsidy;\n', '  }\n', '\n', '  /**\n', '    @notice Computes the subsidy of a full halving\n', '    @param _halving halving\n', '    @return the total amount that will be shared with the miners in this halving\n', '  **/\n', '  function halvingSubsidy(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    uint256 startBlock = halvingStartBlock(_halving);\n', '\n', '    return blockSubsidy(startBlock).mul(subsidyHalvingInterval);\n', '  }\n', '\n', '  /// @notice Fallback function which implements how miners participate in BTH\n', '  function()\n', '    payable\n', '  {\n', '    contribute(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Contribute to the mining of BTH on behalf of another miner\n', '    @param _miner address that will receive the subsidies\n', '    @return true if success\n', '  **/\n', '  function proxiedContribution(address _miner)\n', '    public\n', '    payable\n', '    returns (bool)\n', '  {\n', '    if (_miner == address(0)) {\n', '      // In case the _miner parameter is invalid, redirect the asignment\n', '      // to the transaction sender\n', '      return contribute(msg.sender);\n', '    } else {\n', '      return contribute(_miner);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Contribute to the mining of BTH\n', '    @param _miner address that will receive the subsidies\n', '    @return true if success\n', '  **/\n', '  function contribute(address _miner)\n', '    internal\n', '    notBeforeGenesis\n', '    nonZeroValued\n', '    notPaused\n', '    returns (bool)\n', '  {\n', '    uint256 block = currentBlock();\n', '    uint256 halving = currentHalving();\n', '    uint256 hashRate = HASH_RATE_MULTIPLIER.mul(msg.value);\n', '    Miner miner = miners[_miner];\n', '\n', '    // First of all use the contribute to synchronize the hash rate of the previous halvings\n', '    if (halving != 0 && halving < maxHalvings) {\n', '      uint256 I;\n', '      uint256 n = 0;\n', '      for (I = halving - 1; I > 0; I--) {\n', '        if (!halvingsHashRate[I].carried) {\n', '          n = n.add(1);\n', '        } else {\n', '          break;\n', '        }\n', '      }\n', '\n', '      for (I = halving - n; I < halving; I++) {\n', '        if (!halvingsHashRate[I].carried) {\n', '          halvingsHashRate[I].carried = true;\n', '          halvingsHashRate[I].rate = halvingsHashRate[I].rate.add(halvingsHashRate[I - 1].rate);\n', '        }\n', '      }\n', '    }\n', '\n', '    // Increase the halving hash rate accordingly, after maxHalvings the halvings hash rate are not needed and therefore not updated\n', '    if (halving < maxHalvings) {\n', '      halvingsHashRate[halving].rate = halvingsHashRate[halving].rate.add(hashRate);\n', '    }\n', '\n', '    // After updating the halving hash rate, do the miner contribution\n', '\n', '    // If it&#39;s the very first time the miner participates in the BTH token, assign an initial block\n', '    // This block is used with two porpouses:\n', '    //    - To account in which halving the miner is\n', '    //    - To know the offset inside the halving and allow only claimings after the miner offset\n', '    if (miner.block == 0) {\n', '      miner.block = block;\n', '    }\n', '\n', '    // Add this hash rate to the miner at the current halving\n', '    miner.hashRate[halving].rate = miner.hashRate[halving].rate.add(hashRate);\n', '    miner.totalHashRate = miner.totalHashRate.add(hashRate);\n', '\n', '    // Increase the total hash rate\n', '    totalHashRate = totalHashRate.add(hashRate);\n', '\n', '    // Send contribution to the BTH foundation multisig wallet\n', '    if (!bthFoundationWallet.send(msg.value)) {\n', '      throw;\n', '    }\n', '\n', '    // Log the contribute call\n', '    LogContribution(_miner, msg.value, hashRate, block, halving);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    @notice Miners subsidies must be claimed by the miners calling claimHalvingsSubsidies(_n)\n', '    @param _n number of halvings to claim\n', '    @return the total amount claimed and successfully assigned as BTH to the miner\n', '  **/\n', '  function claimHalvingsSubsidies(uint256 _n)\n', '    public\n', '    notBeforeGenesis\n', '    notPaused\n', '    isMiner(msg.sender)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[msg.sender];\n', '    uint256 start = blockHalving(miner.block);\n', '    uint256 end = start.add(_n);\n', '\n', '    if (end > currentHalving()) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 subsidy = 0;\n', '    uint256 totalSubsidy = 0;\n', '    uint256 unclaimed = 0;\n', '    uint256 hashRate = 0;\n', '    uint256 K;\n', '\n', '    // Claim each unclaimed halving subsidy\n', '    for(K = start; K < end && K < maxHalvings; K++) {\n', '      // Check if the total hash rate has been carried, otherwise the current halving\n', '      // hash rate needs to be updated carrying the total from the last carried\n', '      HalvingHashRate halvingHashRate = halvingsHashRate[K];\n', '\n', '      if (!halvingHashRate.carried) {\n', '        halvingHashRate.carried = true;\n', '        halvingHashRate.rate = halvingHashRate.rate.add(halvingsHashRate[K-1].rate);\n', '      }\n', '\n', '      // Accumulate the miner hash rate as all the contributions are accounted in the contribution\n', '      // and needs to be summed up to reflect the accumulated value\n', '      MinerHashRate minerHashRate = miner.hashRate[K];\n', '      if (!minerHashRate.carried) {\n', '        minerHashRate.carried = true;\n', '        minerHashRate.rate = minerHashRate.rate.add(miner.hashRate[K-1].rate);\n', '      }\n', '\n', '      hashRate = minerHashRate.rate;\n', '\n', '      if (hashRate != 0){\n', '        // If the halving to claim is the last claimable, check the offsets\n', '        if (K == currentHalving().sub(1)) {\n', '          if (currentBlock() % subsidyHalvingInterval < miner.block % subsidyHalvingInterval) {\n', '            // Finish the loop\n', '            continue;\n', '          }\n', '        }\n', '\n', '        Subsidy sub = halvingsSubsidies[K];\n', '\n', '        if (!sub.claimed) {\n', '          sub.claimed = true;\n', '          sub.value = halvingSubsidy(K);\n', '        }\n', '\n', '        unclaimed = sub.value;\n', '        subsidy = halvingSubsidy(K).mul(hashRate).div(halvingHashRate.rate);\n', '\n', '        if (subsidy > unclaimed) {\n', '          subsidy = unclaimed;\n', '        }\n', '\n', '        totalSubsidy = totalSubsidy.add(subsidy);\n', '        sub.value = sub.value.sub(subsidy);\n', '\n', '        LogClaimHalvingSubsidy(msg.sender, miner.block, K, subsidy);\n', '        LogRemainingHalvingSubsidy(K, sub.value);\n', '      }\n', '\n', '      // Move the miner to the next halving\n', '      miner.block = miner.block.add(subsidyHalvingInterval);\n', '    }\n', '\n', '    // If K is less than end, the loop exited because K < maxHalvings, so\n', '    // move the miner end - K halvings\n', '    if (K < end) {\n', '      miner.block = miner.block.add(subsidyHalvingInterval.mul(end.sub(K)));\n', '    }\n', '\n', '    if (totalSubsidy != 0){\n', '      balances[msg.sender] = balances[msg.sender].add(totalSubsidy);\n', '      totalSupply = totalSupply.add(totalSubsidy);\n', '    }\n', '\n', '    return totalSubsidy;\n', '  }\n', '\n', '  /**\n', '    @notice Compute the number of halvings claimable by the miner caller\n', '    @return number of halvings that a miner is allowed to claim\n', '  **/\n', '  function claimableHalvings()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return claimableHalvingsOf(msg.sender);\n', '  }\n', '\n', '\n', '  /**\n', '    @notice Computes the number of halvings claimable by the miner\n', '    @return number of halvings that a miner is entitled claim\n', '  **/\n', '  function claimableHalvingsOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[_miner];\n', '    uint256 halving = currentHalving();\n', '    uint256 minerHalving = blockHalving(miner.block);\n', '\n', '    // Halvings can be claimed when they are finished\n', '    if (minerHalving == halving) {\n', '      return 0;\n', '    } else {\n', '      // Check the miner offset\n', '      if (currentBlock() % subsidyHalvingInterval < miner.block % subsidyHalvingInterval) {\n', '        // In this case the miner offset is behind the current block offset, so it must wait\n', '        // till the block offset is greater or equal than his offset\n', '        return halving.sub(minerHalving).sub(1);\n', '      } else {\n', '        return halving.sub(minerHalving);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Claim all the unclaimed halving subsidies of a miner\n', '    @return total amount of BTH assigned to the miner\n', '  **/\n', '  function claim()\n', '    public\n', '    notBeforeGenesis\n', '    notPaused\n', '    isMiner(msg.sender)\n', '    returns(uint256)\n', '  {\n', '    return claimHalvingsSubsidies(claimableHalvings());\n', '  }\n', '\n', '  /**\n', '    @notice ERC20 transfer function overridden to disable transfers when paused\n', '  **/\n', '  function transfer(address _to, uint _value)\n', '    public\n', '    notPaused\n', '  {\n', '    super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '    @notice ERC20 transferFrom function overridden to disable transfers when paused\n', '  **/\n', '  function transferFrom(address _from, address _to, uint _value)\n', '    public\n', '    notPaused\n', '  {\n', '    super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  // Poll functions\n', '\n', '  /**\n', '    @notice Create a new poll\n', '    @param _title poll title\n', '    @param _percentage percentage of hash rate that must vote to approve the poll\n', '  **/\n', '  function createPoll(string _title, uint8 _percentage)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    bytes32 hash = sha3(_title);\n', '    Poll poll = polls[hash];\n', '\n', '    if (poll.exists) {\n', '      throw;\n', '    }\n', '\n', '    if (_percentage < 1 || _percentage > 100) {\n', '      throw;\n', '    }\n', '\n', '    poll.exists = true;\n', '    poll.title = _title;\n', '    poll.percentage = _percentage;\n', '    poll.hashRate = 0;\n', '    poll.approved = false;\n', '    poll.approvalBlock = 0;\n', '    poll.approvalHashRate = 0;\n', '    poll.approvalTotalHashRate = 0;\n', '\n', '    LogPollCreated(hash);\n', '  }\n', '\n', '  /**\n', '    @notice Delete a poll\n', '    @param _hash sha3 of the poll title, also arg of LogPollCreated event\n', '  **/\n', '  function deletePoll(bytes32 _hash)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    if (poll.exists) {\n', '      delete polls[_hash];\n', '\n', '      LogPollDeleted(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Retreive the poll data\n', '    @param _hash sha3 of the poll title, also arg of LogPollCreated event\n', '    @return an array with the poll data\n', '  **/\n', '  function getPoll(bytes32 _hash)\n', '    external\n', '    constant\n', '    returns(bool, string, uint8, uint256, uint256, bool, uint256, uint256, uint256)\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    return (poll.exists, poll.title, poll.percentage, poll.hashRate, totalHashRate,\n', '      poll.approved, poll.approvalBlock, poll.approvalHashRate, poll.approvalTotalHashRate);\n', '  }\n', '\n', '  function vote(bytes32 _hash)\n', '    external\n', '    isMiner(msg.sender)\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    if (poll.exists) {\n', '      if (!poll.votes[msg.sender]) {\n', '        // msg.sender has not yet voted\n', '        Miner miner = miners[msg.sender];\n', '\n', '        poll.votes[msg.sender] = true;\n', '        poll.hashRate = poll.hashRate.add(miner.totalHashRate);\n', '\n', '        // Log the vote\n', '        LogPollVoted(_hash, msg.sender, miner.totalHashRate);\n', '\n', '        // Check if the poll has succeeded\n', '        if (!poll.approved) {\n', '          if (poll.hashRate.mul(100).div(totalHashRate) >= poll.percentage) {\n', '            poll.approved = true;\n', '\n', '            poll.approvalBlock = block.number;\n', '            poll.approvalHashRate = poll.hashRate;\n', '            poll.approvalTotalHashRate = totalHashRate;\n', '\n', '            LogPollApproved(_hash);\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /*\n', '   * Internal functions\n', '   */\n', '\n', '\n', '  /*\n', '   * Web3 call functions\n', '   */\n', '\n', '  /**\n', '    @notice Return the blocks per halving\n', '    @return blocks per halving\n', '  **/\n', '  function getHalvingBlocks()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return subsidyHalvingInterval;\n', '  }\n', '\n', '  /**\n', '    @notice Return the block in which the miner is\n', '    @return the last block number mined by the miner\n', '  **/\n', '  function getMinerBlock()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getBlockOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Return the block in which the miner is\n', '    @return the last block number mined by the miner\n', '  **/\n', '  function getBlockOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return miners[_miner].block;\n', '  }\n', '\n', '  /**\n', '    @notice Return the miner halving (starting halving or last claimed)\n', '    @return last claimed or starting halving of the miner\n', '  **/\n', '  function getHalvingOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return blockHalving(miners[_miner].block);\n', '  }\n', '\n', '  /**\n', '    @notice Return the miner halving (starting halving or last claimed)\n', '    @return last claimed or starting halving of the miner\n', '  **/\n', '  function getMinerHalving()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getHalvingOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner in a halving\n', '    @param _miner address of the miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getMinerHalvingHashRateOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[_miner];\n', '    uint256 halving = getMinerHalving();\n', '    MinerHashRate hashRate = miner.hashRate[halving];\n', '\n', '    if (halving == 0) {\n', '      return  hashRate.rate;\n', '    } else {\n', '      if (!hashRate.carried) {\n', '        return hashRate.rate.add(miner.hashRate[halving - 1].rate);\n', '      } else {\n', '        return hashRate.rate;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner in a halving\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getMinerHalvingHashRate()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getMinerHalvingHashRateOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Compute the miner halvings offset\n', '    @param _miner address of the miner\n', '    @return miner halving offset\n', '  **/\n', '  function getMinerOffsetOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return blockOffset(miners[_miner].block);\n', '  }\n', '\n', '  /**\n', '    @notice Compute the miner halvings offset\n', '    @return miner halving offset\n', '  **/\n', '  function getMinerOffset()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getMinerOffsetOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the hash rate of a miner in a halving\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _halving number of halving\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getHashRateOf(address _miner, uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(bool, uint256)\n', '  {\n', '    require(_halving <= currentHalving());\n', '\n', '    Miner miner = miners[_miner];\n', '    MinerHashRate hashRate = miner.hashRate[_halving];\n', '\n', '    return (hashRate.carried, hashRate.rate);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _miner address of the miner\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getHashRateOfCurrentHalving(address _miner)\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(_miner, currentHalving());\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _halving numer of the miner halving\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getMinerHashRate(uint256 _halving)\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(msg.sender, _halving);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getMinerHashRateCurrentHalving()\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(msg.sender, currentHalving());\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getTotalHashRateOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return miners[_miner].totalHashRate;\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getTotalHashRate()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getTotalHashRateOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Computes the remaining subsidy pending of being claimed for a given halving\n', '    @param _halving number of halving\n', '    @return the remaining subsidy of a halving\n', '  **/\n', '  function getUnclaimedHalvingSubsidy(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    require(_halving < currentHalving());\n', '\n', '    if (!halvingsSubsidies[_halving].claimed) {\n', '      // In the case that the halving subsidy hasn&#39;t been instantiated\n', '      // (.claimed is false) return the full halving subsidy\n', '      return halvingSubsidy(_halving);\n', '    } else {\n', '      // Otherwise return the remaining halving subsidy\n', '      halvingsSubsidies[_halving].value;\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Shareable\n', ' * @dev inheritable "property" contract that enables methods to be protected by requiring the\n', ' * acquiescence of either a single, or, crucially, each of a number of, designated owners.\n', ' * @dev Usage: use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by some number (specified in constructor) of the set of owners (specified in the constructor) before the interior is executed.\n', ' */\n', 'contract Shareable {\n', '\n', '  // struct for the status of a pending operation.\n', '  struct PendingState {\n', '    uint yetNeeded;\n', '    uint ownersDone;\n', '    uint index;\n', '  }\n', '\n', '  // the number of owners that must confirm the same operation before it is run.\n', '  uint public required;\n', '\n', '  // list of owners\n', '  address[256] owners;\n', '  // index on the list of owners to allow reverse lookup\n', '  mapping(address => uint) ownerIndex;\n', '  // the ongoing operations.\n', '  mapping(bytes32 => PendingState) pendings;\n', '  bytes32[] pendingsIndex;\n', '\n', '\n', '  // this contract only has six types of events: it can accept a confirmation, in which case\n', '  // we record owner and operation (hash) alongside it.\n', '  event Confirmation(address owner, bytes32 operation);\n', '  event Revoke(address owner, bytes32 operation);\n', '\n', '\n', '  // simple single-sig function modifier.\n', '  modifier onlyOwner {\n', '    if (!isOwner(msg.sender)) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier for multisig functions.\n', '   * @param _operation The operation must have an intrinsic hash in order that later attempts can be\n', '   * realised as the same underlying operation and thus count as confirmations.\n', '   */\n', '  modifier onlymanyowners(bytes32 _operation) {\n', '    if (confirmAndCheck(_operation)) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Constructor is given the number of sigs required to do protected "onlymanyowners"\n', '   * transactions as well as the selection of addresses capable of confirming them.\n', '   * @param _owners A list of owners.\n', '   * @param _required The amount required for a transaction to be approved.\n', '   */\n', '  function Shareable(address[] _owners, uint _required) {\n', '    owners[1] = msg.sender;\n', '    ownerIndex[msg.sender] = 1;\n', '    for (uint i = 0; i < _owners.length; ++i) {\n', '      owners[2 + i] = _owners[i];\n', '      ownerIndex[_owners[i]] = 2 + i;\n', '    }\n', '    required = _required;\n', '    if (required > owners.length) {\n', '      throw;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Revokes a prior confirmation of the given operation.\n', '   * @param _operation A string identifying the operation.\n', '   */\n', '  function revoke(bytes32 _operation) external {\n', '    uint index = ownerIndex[msg.sender];\n', "    // make sure they're an owner\n", '    if (index == 0) {\n', '      return;\n', '    }\n', '    uint ownerIndexBit = 2**index;\n', '    var pending = pendings[_operation];\n', '    if (pending.ownersDone & ownerIndexBit > 0) {\n', '      pending.yetNeeded++;\n', '      pending.ownersDone -= ownerIndexBit;\n', '      Revoke(msg.sender, _operation);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets an owner by 0-indexed position (using numOwners as the count)\n', '   * @param ownerIndex Uint The index of the owner\n', '   * @return The address of the owner\n', '   */\n', '  function getOwner(uint ownerIndex) external constant returns (address) {\n', '    return address(owners[ownerIndex + 1]);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if given address is an owner.\n', '   * @param _addr address The address which you want to check.\n', '   * @return True if the address is an owner and fase otherwise.\n', '   */\n', '  function isOwner(address _addr) constant returns (bool) {\n', '    return ownerIndex[_addr] > 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check is specific owner has already confirme the operation.\n', '   * @param _operation The operation identifier.\n', '   * @param _owner The owner address.\n', '   * @return True if the owner has confirmed and false otherwise.\n', '   */\n', '  function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n', '    var pending = pendings[_operation];\n', '    uint index = ownerIndex[_owner];\n', '\n', "    // make sure they're an owner\n", '    if (index == 0) {\n', '      return false;\n', '    }\n', '\n', '    // determine the bit to set for this owner.\n', '    uint ownerIndexBit = 2**index;\n', '    return !(pending.ownersDone & ownerIndexBit == 0);\n', '  }\n', '\n', '  /**\n', "   * @dev Confirm and operation and checks if it's already executable.\n", '   * @param _operation The operation identifier.\n', '   * @return Returns true when operation can be executed.\n', '   */\n', '  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n', '    // determine what index the present sender is:\n', '    uint index = ownerIndex[msg.sender];\n', "    // make sure they're an owner\n", '    if (index == 0) {\n', '      throw;\n', '    }\n', '\n', '    var pending = pendings[_operation];\n', "    // if we're not yet working on this operation, switch over and reset the confirmation status.\n", '    if (pending.yetNeeded == 0) {\n', '      // reset count of confirmations needed.\n', '      pending.yetNeeded = required;\n', '      // reset which owners have confirmed (none) - set our bitmap to 0.\n', '      pending.ownersDone = 0;\n', '      pending.index = pendingsIndex.length++;\n', '      pendingsIndex[pending.index] = _operation;\n', '    }\n', '    // determine the bit to set for this owner.\n', '    uint ownerIndexBit = 2**index;\n', "    // make sure we (the message sender) haven't confirmed this operation previously.\n", '    if (pending.ownersDone & ownerIndexBit == 0) {\n', '      Confirmation(msg.sender, _operation);\n', '      // ok - check if count is enough to go ahead.\n', '      if (pending.yetNeeded <= 1) {\n', '        // enough confirmations: reset and run interior.\n', '        delete pendingsIndex[pendings[_operation].index];\n', '        delete pendings[_operation];\n', '        return true;\n', '      } else {\n', '        // not enough: record that this owner in particular confirmed.\n', '        pending.yetNeeded--;\n', '        pending.ownersDone |= ownerIndexBit;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Clear the pending list.\n', '   */\n', '  function clearPending() internal {\n', '    uint length = pendingsIndex.length;\n', '    for (uint i = 0; i < length; ++i) {\n', '      if (pendingsIndex[i] != 0) {\n', '        delete pendings[pendingsIndex[i]];\n', '      }\n', '    }\n', '    delete pendingsIndex;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title BTH\n', ' * @notice BTC + ETH = BTH\n', ' */\n', '\n', 'contract BTH is StandardToken, Shareable {\n', '  using SafeMath for uint256;\n', '\n', '  /*\n', '   * Constants\n', '   */\n', '  string public constant name = "Bether";\n', '  string public constant symbol = "BTH";\n', '  uint256 public constant decimals = 18;\n', '  string public version = "1.0";\n', '\n', '  uint256 public constant INITIAL_SUBSIDY = 50 * 10**decimals;\n', '  uint256 public constant HASH_RATE_MULTIPLIER = 1;\n', '\n', '  /*\n', '   * Events\n', '   */\n', '  event LogContribution(address indexed _miner, uint256 _value, uint256 _hashRate, uint256 _block, uint256 _halving);\n', '  event LogClaimHalvingSubsidy(address indexed _miner, uint256 _block, uint256 _halving, uint256 _value);\n', '  event LogRemainingHalvingSubsidy(uint256 _halving, uint256 _value);\n', '  event LogPause(bytes32 indexed _hash);\n', '  event LogUnPause(bytes32 indexed _hash);\n', '  event LogBTHFoundationWalletChanged(address indexed _wallet);\n', '  event LogPollCreated(bytes32 indexed _hash);\n', '  event LogPollDeleted(bytes32 indexed _hash);\n', '  event LogPollVoted(bytes32 indexed _hash, address indexed _miner, uint256 _hashRate);\n', '  event LogPollApproved(bytes32 indexed _hash);\n', '\n', '  /*\n', '   * Storage vars\n', '   */\n', '  mapping (uint256 => HalvingHashRate) halvingsHashRate; // Holds the accumulated hash rate per halving\n', '  mapping (uint256 => Subsidy) halvingsSubsidies; // Stores the remaining subsidy per halving\n', '  mapping (address => Miner) miners; // Miners data\n', '  mapping (bytes32 => Poll) polls; // Contract polls\n', '\n', '  address public bthFoundationWallet;\n', '  uint256 public subsidyHalvingInterval;\n', '  uint256 public maxHalvings;\n', '  uint256 public genesis;\n', '  uint256 public totalHashRate;\n', '  bool public paused;\n', '\n', '  struct HalvingHashRate {\n', '    bool carried; // Indicates that the previous hash rate have been added to the halving\n', '    uint256 rate; // Hash rate of the halving\n', '  }\n', '\n', '  struct Miner {\n', '    uint256 block; // Miner block, used to calculate in which halving is the miner\n', '    uint256 totalHashRate; // Accumulated miner hash rate\n', '    mapping (uint256 => MinerHashRate) hashRate;\n', '  }\n', '\n', '  struct MinerHashRate {\n', '    bool carried;\n', '    uint256 rate;\n', '  }\n', '\n', '  struct Subsidy {\n', '    bool claimed;  // Flag that indicates that the subsidy has been claimed at least one time, just to\n', '                   // compute the initial halving subsidy value\n', '    uint256 value; // Remaining subsidy of a halving\n', '  }\n', '\n', '  struct Poll {\n', '    bool exists;  // Indicates that the poll is created\n', "    string title; // Title of the poll, it's the poll indentifier so it must be unique\n", '    mapping (address => bool) votes; // Control who have voted\n', '    uint8 percentage; // Percentage which determines if the poll has been approved\n', '    uint256 hashRate; // Summed hash rate of all the voters\n', '    bool approved; // True if the poll has been approved\n', '    uint256 approvalBlock; // Block in which the poll was approved\n', '    uint256 approvalHashRate; // Hash rate that caused the poll approval\n', '    uint256 approvalTotalHashRate; // Total has rate in when the poll was approved\n', '  }\n', '\n', '  /*\n', '   * Modifiers\n', '   */\n', '  modifier notBeforeGenesis() {\n', '    require(block.number >= genesis);\n', '    _;\n', '  }\n', '\n', '  modifier nonZero(uint256 _value) {\n', '    require(_value > 0);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address _address) {\n', '    require(_address != address(0));\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroValued() {\n', '    require(msg.value != 0);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroLength(address[] array) {\n', '    require(array.length != 0);\n', '    _;\n', '  }\n', '\n', '  modifier notPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier notGreaterThanCurrentBlock(uint256 _block) {\n', '    require(_block <= currentBlock());\n', '    _;\n', '  }\n', '\n', '  modifier isMiner(address _address) {\n', '    require(miners[_address].block != 0);\n', '    _;\n', '  }\n', '\n', '  modifier pollApproved(bytes32 _hash) {\n', '    require(polls[_hash].approved);\n', '    _;\n', '  }\n', '\n', '  /*\n', '   * Public functions\n', '   */\n', '\n', '  /**\n', '    @notice Contract constructor\n', '    @param _bthFoundationMembers are the addresses that control the BTH contract\n', '    @param _required number of memers needed to execute management functions of the contract\n', '    @param _bthFoundationWallet wallet that holds all the contract contributions\n', '    @param _genesis block number in which the BTH contract will be active\n', '    @param _subsidyHalvingInterval number of blocks which comprises a halving\n', '    @param _maxHalvings number of halvings that will generate BTH\n', '  **/\n', '  function BTH(\n', '    address[] _bthFoundationMembers,\n', '    uint256 _required,\n', '    address _bthFoundationWallet,\n', '    uint256 _genesis,\n', '    uint256 _subsidyHalvingInterval,\n', '    uint256 _maxHalvings\n', '  ) Shareable( _bthFoundationMembers, _required)\n', '    nonZeroLength(_bthFoundationMembers)\n', '    nonZero(_required)\n', '    nonZeroAddress(_bthFoundationWallet)\n', '    nonZero(_genesis)\n', '    nonZero(_subsidyHalvingInterval)\n', '    nonZero(_maxHalvings)\n', '  {\n', '    // Genesis block must be greater or equal than the current block\n', '    if (_genesis < block.number) throw;\n', '\n', '    bthFoundationWallet = _bthFoundationWallet;\n', '    subsidyHalvingInterval = _subsidyHalvingInterval;\n', '    maxHalvings = _maxHalvings;\n', '\n', '    genesis = _genesis;\n', '    totalSupply = 0;\n', '    totalHashRate = 0;\n', '    paused = false;\n', '  }\n', '\n', '  /**\n', '    @notice Contract desctruction function\n', '    @param _hash poll hash that authorizes the function call\n', '  **/\n', '  function kill(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    selfdestruct(bthFoundationWallet);\n', '  }\n', '\n', '  /**\n', '    @notice Contract desctruction function with ethers redirection\n', '    @param _hash poll hash that authorizes the function call\n', '  **/\n', '  function killTo(address _to, bytes32 _hash)\n', '    external\n', '    nonZeroAddress(_to)\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    selfdestruct(_to);\n', '  }\n', '\n', '  /**\n', '    @notice Pause the contract operations\n', '    @param _hash poll hash that authorizes the pause\n', '  **/\n', '  function pause(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '    notBeforeGenesis\n', '  {\n', '    if (!paused) {\n', '      paused = true;\n', '      LogPause(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Unpause the contract operations\n', '    @param _hash poll hash that authorizes the unpause\n', '  **/\n', '  function unPause(bytes32 _hash)\n', '    external\n', '    pollApproved(_hash)\n', '    onlymanyowners(sha3(msg.data))\n', '    notBeforeGenesis\n', '  {\n', '    if (paused) {\n', '      paused = false;\n', '      LogUnPause(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Set the bthFoundation wallet\n', '    @param _wallet new wallet address\n', '  **/\n', '  function setBTHFoundationWallet(address _wallet)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '    nonZeroAddress(_wallet)\n', '  {\n', '    bthFoundationWallet = _wallet;\n', '    LogBTHFoundationWalletChanged(_wallet);\n', '  }\n', '\n', '  /**\n', '    @notice Returns the current BTH block\n', '    @return current bth block number\n', '  **/\n', '  function currentBlock()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return block.number.sub(genesis);\n', '  }\n', '\n', '   /**\n', '    @notice Calculates the halving number of a given block\n', '    @param _block block number\n', '    @return the halving of the block\n', '  **/\n', '  function blockHalving(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _block.div(subsidyHalvingInterval);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the offset of a given block\n', '    @return the offset of the block in a halving\n', '  **/\n', '  function blockOffset(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _block % subsidyHalvingInterval;\n', '  }\n', '\n', '  /**\n', '    @notice Determine the current halving number\n', '    @return the current halving\n', '  **/\n', '  function currentHalving()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return blockHalving(currentBlock());\n', '  }\n', '\n', '  /**\n', '    @notice Compute the starting block of a halving\n', '    @return the initial halving block\n', '  **/\n', '  function halvingStartBlock(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return _halving.mul(subsidyHalvingInterval);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the total subsidy of a block\n', '    @param _block block number\n', '    @return the total amount that will be shared with the miners\n', '  **/\n', '  function blockSubsidy(uint256 _block)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    uint256 halvings = _block.div(subsidyHalvingInterval);\n', '\n', '    if (halvings >= maxHalvings) return 0;\n', '\n', '    uint256 subsidy = INITIAL_SUBSIDY >> halvings;\n', '\n', '    return subsidy;\n', '  }\n', '\n', '  /**\n', '    @notice Computes the subsidy of a full halving\n', '    @param _halving halving\n', '    @return the total amount that will be shared with the miners in this halving\n', '  **/\n', '  function halvingSubsidy(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    uint256 startBlock = halvingStartBlock(_halving);\n', '\n', '    return blockSubsidy(startBlock).mul(subsidyHalvingInterval);\n', '  }\n', '\n', '  /// @notice Fallback function which implements how miners participate in BTH\n', '  function()\n', '    payable\n', '  {\n', '    contribute(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Contribute to the mining of BTH on behalf of another miner\n', '    @param _miner address that will receive the subsidies\n', '    @return true if success\n', '  **/\n', '  function proxiedContribution(address _miner)\n', '    public\n', '    payable\n', '    returns (bool)\n', '  {\n', '    if (_miner == address(0)) {\n', '      // In case the _miner parameter is invalid, redirect the asignment\n', '      // to the transaction sender\n', '      return contribute(msg.sender);\n', '    } else {\n', '      return contribute(_miner);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Contribute to the mining of BTH\n', '    @param _miner address that will receive the subsidies\n', '    @return true if success\n', '  **/\n', '  function contribute(address _miner)\n', '    internal\n', '    notBeforeGenesis\n', '    nonZeroValued\n', '    notPaused\n', '    returns (bool)\n', '  {\n', '    uint256 block = currentBlock();\n', '    uint256 halving = currentHalving();\n', '    uint256 hashRate = HASH_RATE_MULTIPLIER.mul(msg.value);\n', '    Miner miner = miners[_miner];\n', '\n', '    // First of all use the contribute to synchronize the hash rate of the previous halvings\n', '    if (halving != 0 && halving < maxHalvings) {\n', '      uint256 I;\n', '      uint256 n = 0;\n', '      for (I = halving - 1; I > 0; I--) {\n', '        if (!halvingsHashRate[I].carried) {\n', '          n = n.add(1);\n', '        } else {\n', '          break;\n', '        }\n', '      }\n', '\n', '      for (I = halving - n; I < halving; I++) {\n', '        if (!halvingsHashRate[I].carried) {\n', '          halvingsHashRate[I].carried = true;\n', '          halvingsHashRate[I].rate = halvingsHashRate[I].rate.add(halvingsHashRate[I - 1].rate);\n', '        }\n', '      }\n', '    }\n', '\n', '    // Increase the halving hash rate accordingly, after maxHalvings the halvings hash rate are not needed and therefore not updated\n', '    if (halving < maxHalvings) {\n', '      halvingsHashRate[halving].rate = halvingsHashRate[halving].rate.add(hashRate);\n', '    }\n', '\n', '    // After updating the halving hash rate, do the miner contribution\n', '\n', "    // If it's the very first time the miner participates in the BTH token, assign an initial block\n", '    // This block is used with two porpouses:\n', '    //    - To account in which halving the miner is\n', '    //    - To know the offset inside the halving and allow only claimings after the miner offset\n', '    if (miner.block == 0) {\n', '      miner.block = block;\n', '    }\n', '\n', '    // Add this hash rate to the miner at the current halving\n', '    miner.hashRate[halving].rate = miner.hashRate[halving].rate.add(hashRate);\n', '    miner.totalHashRate = miner.totalHashRate.add(hashRate);\n', '\n', '    // Increase the total hash rate\n', '    totalHashRate = totalHashRate.add(hashRate);\n', '\n', '    // Send contribution to the BTH foundation multisig wallet\n', '    if (!bthFoundationWallet.send(msg.value)) {\n', '      throw;\n', '    }\n', '\n', '    // Log the contribute call\n', '    LogContribution(_miner, msg.value, hashRate, block, halving);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    @notice Miners subsidies must be claimed by the miners calling claimHalvingsSubsidies(_n)\n', '    @param _n number of halvings to claim\n', '    @return the total amount claimed and successfully assigned as BTH to the miner\n', '  **/\n', '  function claimHalvingsSubsidies(uint256 _n)\n', '    public\n', '    notBeforeGenesis\n', '    notPaused\n', '    isMiner(msg.sender)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[msg.sender];\n', '    uint256 start = blockHalving(miner.block);\n', '    uint256 end = start.add(_n);\n', '\n', '    if (end > currentHalving()) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 subsidy = 0;\n', '    uint256 totalSubsidy = 0;\n', '    uint256 unclaimed = 0;\n', '    uint256 hashRate = 0;\n', '    uint256 K;\n', '\n', '    // Claim each unclaimed halving subsidy\n', '    for(K = start; K < end && K < maxHalvings; K++) {\n', '      // Check if the total hash rate has been carried, otherwise the current halving\n', '      // hash rate needs to be updated carrying the total from the last carried\n', '      HalvingHashRate halvingHashRate = halvingsHashRate[K];\n', '\n', '      if (!halvingHashRate.carried) {\n', '        halvingHashRate.carried = true;\n', '        halvingHashRate.rate = halvingHashRate.rate.add(halvingsHashRate[K-1].rate);\n', '      }\n', '\n', '      // Accumulate the miner hash rate as all the contributions are accounted in the contribution\n', '      // and needs to be summed up to reflect the accumulated value\n', '      MinerHashRate minerHashRate = miner.hashRate[K];\n', '      if (!minerHashRate.carried) {\n', '        minerHashRate.carried = true;\n', '        minerHashRate.rate = minerHashRate.rate.add(miner.hashRate[K-1].rate);\n', '      }\n', '\n', '      hashRate = minerHashRate.rate;\n', '\n', '      if (hashRate != 0){\n', '        // If the halving to claim is the last claimable, check the offsets\n', '        if (K == currentHalving().sub(1)) {\n', '          if (currentBlock() % subsidyHalvingInterval < miner.block % subsidyHalvingInterval) {\n', '            // Finish the loop\n', '            continue;\n', '          }\n', '        }\n', '\n', '        Subsidy sub = halvingsSubsidies[K];\n', '\n', '        if (!sub.claimed) {\n', '          sub.claimed = true;\n', '          sub.value = halvingSubsidy(K);\n', '        }\n', '\n', '        unclaimed = sub.value;\n', '        subsidy = halvingSubsidy(K).mul(hashRate).div(halvingHashRate.rate);\n', '\n', '        if (subsidy > unclaimed) {\n', '          subsidy = unclaimed;\n', '        }\n', '\n', '        totalSubsidy = totalSubsidy.add(subsidy);\n', '        sub.value = sub.value.sub(subsidy);\n', '\n', '        LogClaimHalvingSubsidy(msg.sender, miner.block, K, subsidy);\n', '        LogRemainingHalvingSubsidy(K, sub.value);\n', '      }\n', '\n', '      // Move the miner to the next halving\n', '      miner.block = miner.block.add(subsidyHalvingInterval);\n', '    }\n', '\n', '    // If K is less than end, the loop exited because K < maxHalvings, so\n', '    // move the miner end - K halvings\n', '    if (K < end) {\n', '      miner.block = miner.block.add(subsidyHalvingInterval.mul(end.sub(K)));\n', '    }\n', '\n', '    if (totalSubsidy != 0){\n', '      balances[msg.sender] = balances[msg.sender].add(totalSubsidy);\n', '      totalSupply = totalSupply.add(totalSubsidy);\n', '    }\n', '\n', '    return totalSubsidy;\n', '  }\n', '\n', '  /**\n', '    @notice Compute the number of halvings claimable by the miner caller\n', '    @return number of halvings that a miner is allowed to claim\n', '  **/\n', '  function claimableHalvings()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return claimableHalvingsOf(msg.sender);\n', '  }\n', '\n', '\n', '  /**\n', '    @notice Computes the number of halvings claimable by the miner\n', '    @return number of halvings that a miner is entitled claim\n', '  **/\n', '  function claimableHalvingsOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[_miner];\n', '    uint256 halving = currentHalving();\n', '    uint256 minerHalving = blockHalving(miner.block);\n', '\n', '    // Halvings can be claimed when they are finished\n', '    if (minerHalving == halving) {\n', '      return 0;\n', '    } else {\n', '      // Check the miner offset\n', '      if (currentBlock() % subsidyHalvingInterval < miner.block % subsidyHalvingInterval) {\n', '        // In this case the miner offset is behind the current block offset, so it must wait\n', '        // till the block offset is greater or equal than his offset\n', '        return halving.sub(minerHalving).sub(1);\n', '      } else {\n', '        return halving.sub(minerHalving);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Claim all the unclaimed halving subsidies of a miner\n', '    @return total amount of BTH assigned to the miner\n', '  **/\n', '  function claim()\n', '    public\n', '    notBeforeGenesis\n', '    notPaused\n', '    isMiner(msg.sender)\n', '    returns(uint256)\n', '  {\n', '    return claimHalvingsSubsidies(claimableHalvings());\n', '  }\n', '\n', '  /**\n', '    @notice ERC20 transfer function overridden to disable transfers when paused\n', '  **/\n', '  function transfer(address _to, uint _value)\n', '    public\n', '    notPaused\n', '  {\n', '    super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '    @notice ERC20 transferFrom function overridden to disable transfers when paused\n', '  **/\n', '  function transferFrom(address _from, address _to, uint _value)\n', '    public\n', '    notPaused\n', '  {\n', '    super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  // Poll functions\n', '\n', '  /**\n', '    @notice Create a new poll\n', '    @param _title poll title\n', '    @param _percentage percentage of hash rate that must vote to approve the poll\n', '  **/\n', '  function createPoll(string _title, uint8 _percentage)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    bytes32 hash = sha3(_title);\n', '    Poll poll = polls[hash];\n', '\n', '    if (poll.exists) {\n', '      throw;\n', '    }\n', '\n', '    if (_percentage < 1 || _percentage > 100) {\n', '      throw;\n', '    }\n', '\n', '    poll.exists = true;\n', '    poll.title = _title;\n', '    poll.percentage = _percentage;\n', '    poll.hashRate = 0;\n', '    poll.approved = false;\n', '    poll.approvalBlock = 0;\n', '    poll.approvalHashRate = 0;\n', '    poll.approvalTotalHashRate = 0;\n', '\n', '    LogPollCreated(hash);\n', '  }\n', '\n', '  /**\n', '    @notice Delete a poll\n', '    @param _hash sha3 of the poll title, also arg of LogPollCreated event\n', '  **/\n', '  function deletePoll(bytes32 _hash)\n', '    external\n', '    onlymanyowners(sha3(msg.data))\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    if (poll.exists) {\n', '      delete polls[_hash];\n', '\n', '      LogPollDeleted(_hash);\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Retreive the poll data\n', '    @param _hash sha3 of the poll title, also arg of LogPollCreated event\n', '    @return an array with the poll data\n', '  **/\n', '  function getPoll(bytes32 _hash)\n', '    external\n', '    constant\n', '    returns(bool, string, uint8, uint256, uint256, bool, uint256, uint256, uint256)\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    return (poll.exists, poll.title, poll.percentage, poll.hashRate, totalHashRate,\n', '      poll.approved, poll.approvalBlock, poll.approvalHashRate, poll.approvalTotalHashRate);\n', '  }\n', '\n', '  function vote(bytes32 _hash)\n', '    external\n', '    isMiner(msg.sender)\n', '  {\n', '    Poll poll = polls[_hash];\n', '\n', '    if (poll.exists) {\n', '      if (!poll.votes[msg.sender]) {\n', '        // msg.sender has not yet voted\n', '        Miner miner = miners[msg.sender];\n', '\n', '        poll.votes[msg.sender] = true;\n', '        poll.hashRate = poll.hashRate.add(miner.totalHashRate);\n', '\n', '        // Log the vote\n', '        LogPollVoted(_hash, msg.sender, miner.totalHashRate);\n', '\n', '        // Check if the poll has succeeded\n', '        if (!poll.approved) {\n', '          if (poll.hashRate.mul(100).div(totalHashRate) >= poll.percentage) {\n', '            poll.approved = true;\n', '\n', '            poll.approvalBlock = block.number;\n', '            poll.approvalHashRate = poll.hashRate;\n', '            poll.approvalTotalHashRate = totalHashRate;\n', '\n', '            LogPollApproved(_hash);\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /*\n', '   * Internal functions\n', '   */\n', '\n', '\n', '  /*\n', '   * Web3 call functions\n', '   */\n', '\n', '  /**\n', '    @notice Return the blocks per halving\n', '    @return blocks per halving\n', '  **/\n', '  function getHalvingBlocks()\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    return subsidyHalvingInterval;\n', '  }\n', '\n', '  /**\n', '    @notice Return the block in which the miner is\n', '    @return the last block number mined by the miner\n', '  **/\n', '  function getMinerBlock()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getBlockOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Return the block in which the miner is\n', '    @return the last block number mined by the miner\n', '  **/\n', '  function getBlockOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return miners[_miner].block;\n', '  }\n', '\n', '  /**\n', '    @notice Return the miner halving (starting halving or last claimed)\n', '    @return last claimed or starting halving of the miner\n', '  **/\n', '  function getHalvingOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return blockHalving(miners[_miner].block);\n', '  }\n', '\n', '  /**\n', '    @notice Return the miner halving (starting halving or last claimed)\n', '    @return last claimed or starting halving of the miner\n', '  **/\n', '  function getMinerHalving()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getHalvingOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner in a halving\n', '    @param _miner address of the miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getMinerHalvingHashRateOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    Miner miner = miners[_miner];\n', '    uint256 halving = getMinerHalving();\n', '    MinerHashRate hashRate = miner.hashRate[halving];\n', '\n', '    if (halving == 0) {\n', '      return  hashRate.rate;\n', '    } else {\n', '      if (!hashRate.carried) {\n', '        return hashRate.rate.add(miner.hashRate[halving - 1].rate);\n', '      } else {\n', '        return hashRate.rate;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner in a halving\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getMinerHalvingHashRate()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getMinerHalvingHashRateOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Compute the miner halvings offset\n', '    @param _miner address of the miner\n', '    @return miner halving offset\n', '  **/\n', '  function getMinerOffsetOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return blockOffset(miners[_miner].block);\n', '  }\n', '\n', '  /**\n', '    @notice Compute the miner halvings offset\n', '    @return miner halving offset\n', '  **/\n', '  function getMinerOffset()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getMinerOffsetOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the hash rate of a miner in a halving\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _halving number of halving\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getHashRateOf(address _miner, uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(bool, uint256)\n', '  {\n', '    require(_halving <= currentHalving());\n', '\n', '    Miner miner = miners[_miner];\n', '    MinerHashRate hashRate = miner.hashRate[_halving];\n', '\n', '    return (hashRate.carried, hashRate.rate);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _miner address of the miner\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getHashRateOfCurrentHalving(address _miner)\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(_miner, currentHalving());\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @param _halving numer of the miner halving\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getMinerHashRate(uint256 _halving)\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(msg.sender, _halving);\n', '  }\n', '\n', '  /**\n', '    @notice Calculate the halving hash rate of a miner\n', '    @dev Take into account that the rate can be uncarried\n', '    @return (carried, rate) a tuple with the rate and if the value has been carried from previous halvings\n', '  **/\n', '  function getMinerHashRateCurrentHalving()\n', '    public\n', '    constant\n', '    returns(bool, uint256)\n', '  {\n', '    return getHashRateOf(msg.sender, currentHalving());\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getTotalHashRateOf(address _miner)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    isMiner(_miner)\n', '    returns(uint256)\n', '  {\n', '    return miners[_miner].totalHashRate;\n', '  }\n', '\n', '  /**\n', '    @notice Total hash rate of a miner\n', '    @return miner total accumulated hash rate\n', '  **/\n', '  function getTotalHashRate()\n', '    public\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return getTotalHashRateOf(msg.sender);\n', '  }\n', '\n', '  /**\n', '    @notice Computes the remaining subsidy pending of being claimed for a given halving\n', '    @param _halving number of halving\n', '    @return the remaining subsidy of a halving\n', '  **/\n', '  function getUnclaimedHalvingSubsidy(uint256 _halving)\n', '    public\n', '    constant\n', '    notBeforeGenesis\n', '    returns(uint256)\n', '  {\n', '    require(_halving < currentHalving());\n', '\n', '    if (!halvingsSubsidies[_halving].claimed) {\n', "      // In the case that the halving subsidy hasn't been instantiated\n", '      // (.claimed is false) return the full halving subsidy\n', '      return halvingSubsidy(_halving);\n', '    } else {\n', '      // Otherwise return the remaining halving subsidy\n', '      halvingsSubsidies[_halving].value;\n', '    }\n', '  }\n', '}']
