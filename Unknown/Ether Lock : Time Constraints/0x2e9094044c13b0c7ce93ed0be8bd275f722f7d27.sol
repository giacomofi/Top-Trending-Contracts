['pragma solidity ^0.4.7;\n', '\n', '/*\n', ' 1. Aim is to guess the closest Lottery number which is from 0 to 1000000. The closest gueser gets all the money!.\n', ' 2. 1% of the bet goes to the developer.\n', ' 3. Once 1000th user bet, the Lottery checks who guessed the closest number.\n', ' 4. Lottery number is based on the Random number.\n', ' 5. The user with closest number gets all money.\n', '*/\n', '\n', 'contract bet1000 {\n', '  enum State { Started, Locked }\n', '  State public state = State.Started;\n', '  struct Guess{\n', '    address addr;\n', '    uint    guess;\n', '  }\n', '  uint constant arraysize=1000;\n', '  uint constant maxguess=1000000;\n', '  uint bettingprice = 0.01 ether;\n', '  Guess[1000] guesses;\n', '  uint    numguesses = 0;\n', '  bytes32 curhash = &#39;&#39;;\n', '  \n', '  uint stasticsarrayitems = 20;\n', '  uint[20] statistics;\n', '\n', '  uint _gameindex = 1;\n', '  \n', '  struct Winner{\n', '    address addr;\n', '  }\n', '  Winner[1000] winnners;\n', '  uint    numwinners = 0;\n', '\n', '  modifier inState(State _state) {\n', '      require(state == _state);\n', '      _;\n', '  }\n', ' \n', '  address constant developer = 0x001973f023e4c03ef60ea34084b63e7790d463e595;\n', '  event SentPrizeToWinner(address winner, uint money, uint guess, uint gameindex, uint lotterynumber, uint timestamp);\n', '  event SentDeveloperFee(uint amount, uint balance);\n', '\n', '  function bet1000(uint _bettingprice) \n', '  {\n', '    bettingprice = _bettingprice;\n', '  }\n', '  \n', '//   function stringToUint(string s) constant returns (uint result) {\n', '//     bytes memory b = bytes(s);\n', '//     uint i;\n', '//     result = 0;\n', '//     for (i = 0; i < b.length; i++) {\n', '//       uint c = uint(b[i]);\n', '//       if (c >= 48 && c <= 57) {\n', '//         result = result * 10 + (c - 48);\n', '//       }\n', '//     }\n', '//   }\n', '  \n', '  function findWinners(uint value) returns (uint)\n', '  {\n', '    numwinners = 0;\n', '    uint lastdiff = maxguess;\n', '    uint i = 0;\n', '    int diff = 0;\n', '    uint guess = 0;\n', '    for (i = 0; i < numguesses; i++) {\n', '      diff = (int)((int)(value)-(int)(guesses[i].guess));\n', '      if(diff<0)\n', '        diff = diff*-1;\n', '      if(lastdiff>(uint)(diff)){\n', '        guess = guesses[i].guess;\n', '        lastdiff = (uint)(diff);\n', '      }\n', '    }\n', '    \n', '    for (i = 0; i < numguesses; i++) {\n', '      diff = (int)((int)(value)-(int)(guesses[i].guess));\n', '      if(diff<0)\n', '        diff = diff*-1;\n', '      if(lastdiff==uint(diff)){\n', '        winnners[numwinners++].addr = guesses[i].addr;\n', '      }\n', '    }\n', '    return guess;\n', '  }\n', '  \n', '  function getDeveloperFee() constant returns(uint)\n', '  {\n', '    uint developerfee = this.balance/100;\n', '    return developerfee;\n', '  }\n', '  \n', '  function getBalance() constant returns(uint)\n', '  {\n', '     return this.balance;\n', '  }\n', '  \n', '  function getLotteryMoney() constant returns(uint)\n', '  {\n', '    uint developerfee = getDeveloperFee();\n', '    uint prize = (this.balance - developerfee)/(numwinners<1?1:numwinners);\n', '    return prize;\n', '  }\n', '\n', '  function getBettingStastics() \n', '    payable\n', '    returns(uint[20])\n', '  {\n', '    require(msg.value == bettingprice*3);\n', '    return statistics;\n', '  }\n', '  \n', '  function getBettingStatus()\n', '    constant\n', '    returns (uint, uint, uint, uint, uint)\n', '  {\n', '    return ((uint)(state), numguesses, getLotteryMoney(), this.balance, bettingprice);\n', '  }\n', '  \n', '  function finish()\n', '  {\n', '    state = State.Locked;\n', '\n', '    uint lotterynumber = (uint(curhash)+block.timestamp)%(maxguess+1);\n', '    // now that we know the random number was safely generate, let&#39;s do something with the random number..\n', '    var guess = findWinners(lotterynumber);\n', '    uint prize = getLotteryMoney();\n', '    uint remain = this.balance - (prize*numwinners);\n', '    for (uint i = 0; i < numwinners; i++) {\n', '      address winner = winnners[i].addr;\n', '      winner.transfer(prize);\n', '      SentPrizeToWinner(winner, prize, guess, _gameindex, lotterynumber, block.timestamp);\n', '    }\n', '    // give delveoper the money left behind\n', '    SentDeveloperFee(remain, this.balance);\n', '    developer.transfer(remain); \n', '    \n', '    numguesses = 0;\n', '    for (i = 0; i < stasticsarrayitems; i++) {\n', '      statistics[i] = 0;\n', '    }\n', '    _gameindex++;\n', '    state = State.Started;\n', '  }\n', '\n', '  function addguess(uint guess) \n', '    inState(State.Started)\n', '    payable\n', '  {\n', '    require(msg.value == bettingprice);\n', '    \n', '    uint divideby = maxguess/stasticsarrayitems;\n', '    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);\n', '    if((uint)(numguesses+1)<=arraysize) {\n', '      guesses[numguesses++] = Guess(msg.sender, guess);\n', '      uint statindex = guess / divideby;\n', '      if(statindex>=stasticsarrayitems) statindex = stasticsarrayitems-1;\n', '      statistics[statindex] ++;\n', '      if((uint)(numguesses)>=arraysize){\n', '        finish();\n', '      }\n', '    }\n', '  }\n', '  \n', '//   function getCurHash() returns (uint)\n', '//   {\n', '//       Winner(this, 0, 0, (uint)(curhash));\n', '//       return (uint)(curhash);\n', '//   }\n', '}\n', '\n', 'contract bet1000_1eth is bet1000(1 ether){\n', '  function bet1000_1eth(){ \n', '  }\n', '}']