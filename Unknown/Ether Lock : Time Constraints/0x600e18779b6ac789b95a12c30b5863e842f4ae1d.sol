['pragma solidity ^0.4.8;\n', '\n', 'contract SmartRouletteToken \n', '{\n', '   uint8 public decimals;\n', '   function balanceOf( address who ) external constant returns (uint256);\n', '   function gameListOf( address who ) external constant returns (bool);\n', '   function getItemHolders(uint256 index) external constant returns(address);\n', '   function getCountHolders() external constant returns (uint256);\n', '   function getCountTempHolders() external constant returns(uint256);\n', '   function getItemTempHolders(uint256 index) external constant returns(address);\n', '   function tempTokensBalanceOf( address who ) external constant returns (uint256);\n', '}\n', '\n', 'contract SmartRouletteDividend {\n', '\n', '\taddress developer;\n', '\taddress manager;\n', '\n', '\tSmartRouletteToken smartToken;\n', '\tuint256 decimal;\n', '\n', '\tstruct DividendInfo\n', '\t{\n', '\t   uint256 amountDividend;\n', '\t   uint256 blockDividend;\n', '\t   bool AllPaymentsSent;\n', '\t}\n', '\n', '\tDividendInfo[] dividendHistory;\n', '\n', '\taddress public gameAddress;\n', '\n', '\tuint256 public tokensNeededToGetPayment = 1000;\n', '\n', '\n', '\tfunction SmartRouletteDividend() {\n', '\t\tdeveloper = msg.sender;\n', '\t\tmanager = msg.sender;\n', '\n', '\t\tsmartToken = SmartRouletteToken(0xcced5b8288086be8c38e23567e684c3740be4d48); //test 0xc46ed6ba652bd552671a46045b495748cd10fa04 main 0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18\n', '\t\tdecimal = 10**uint256(smartToken.decimals());\t\t\n', '\t}\n', '\t\n', '\n', '\tmodifier isDeveloper(){\n', '\t\tif (msg.sender!=developer) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier isManager(){\n', '\t\tif (msg.sender!=manager && msg.sender!=developer) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction changeTokensLimit(uint256 newTokensLimit) isDeveloper\n', '\t{\n', '\t\ttokensNeededToGetPayment = newTokensLimit;\n', '\t}\n', '\tfunction dividendCount() constant returns(uint256)\n', '\t{\n', '\t\treturn dividendHistory.length;\n', '\t}\n', '\n', '\tfunction SetAllPaymentsSent(uint256 DividendNo) isManager\n', '\t{\n', '\t\tdividendHistory[DividendNo].AllPaymentsSent = true;\n', '\t\t// all fees (30000 gas * tx.gasprice for each transaction)\n', '\t\tif (manager.send(this.balance) == false) throw;\n', '\t}\n', '\n', '\tfunction changeDeveloper(address new_developer)\n', '\tisDeveloper\n', '\t{\n', '\t\tif(new_developer == address(0x0)) throw;\n', '\t\tdeveloper = new_developer;\n', '\t}\n', '\n', '\tfunction changeManager(address new_manager)\n', '\tisDeveloper\n', '\t{\n', '\t\tif(new_manager == address(0x0)) throw;\n', '\t\tmanager = new_manager;\n', '\t}\n', '\n', '\tfunction kill() isDeveloper {\n', '\t\tsuicide(developer);\n', '\t}\n', '\n', '\tfunction getDividendInfo(uint256 index) constant returns(uint256 amountDividend, uint256 blockDividend, bool AllPaymentsSent)\n', '\t{\n', '\t\tamountDividend  = dividendHistory[index].amountDividend;\n', '\t\tblockDividend   = dividendHistory[index].blockDividend;\n', '\t\tAllPaymentsSent = dividendHistory[index].AllPaymentsSent;\n', '\t}\n', '\n', '\n', '\t//  get total count tokens (to calculate profit for one token)\n', '\tfunction get_CountProfitsToken() constant returns(uint256){\n', '\t\tuint256 countProfitsTokens = 0;\n', '\n', '\t\tmapping(address => bool) uniqueHolders;\n', '\n', '\t\tuint256 countHolders = smartToken.getCountHolders();\n', '\t\tfor(uint256 i=0; i<countHolders; i++)\n', '\t\t{\n', '\t\t\taddress holder = smartToken.getItemHolders(i);\n', '\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\n', '\t\t\t{\n', '\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\n', '\t\t\t\tif(holdersTokens>0)\n', '\t\t\t\t{\n', '\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\n', '\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuniqueHolders[holder]=true;\n', '\t\t\t\t\t\tcountProfitsTokens += (holdersTokens+tempTokens);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\n', '\t\tfor(uint256 j=0; j<countTempHolders; j++)\n', '\t\t{\n', '\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\n', '\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\n', '\t\t\t{\n', '\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\n', '\t\t\t\tif(token_balance==0)\n', '\t\t\t\t{\n', '\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\n', '\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuniqueHolders[temp_holder]=true;\n', '\t\t\t\t\t\tcountProfitsTokens += count_tempTokens;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\treturn countProfitsTokens;\n', '\t}\n', '\n', '\tfunction get_CountAllHolderForProfit() constant returns(uint256){\n', '\t\tuint256 countAllHolders = 0;\n', '\n', '\t\tmapping(address => bool) uniqueHolders;\n', '\n', '\t\tuint256 countHolders = smartToken.getCountHolders();\n', '\t\tfor(uint256 i=0; i<countHolders; i++)\n', '\t\t{\n', '\t\t\taddress holder = smartToken.getItemHolders(i);\n', '\t\t\tif(holder!=address(0x0) && !uniqueHolders[holder])\n', '\t\t\t{\n', '\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\n', '\t\t\t\tif(holdersTokens>0)\n', '\t\t\t\t{\n', '\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\n', '\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuniqueHolders[holder] = true;\n', '\t\t\t\t\t\tcountAllHolders += 1;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\n', '\t\tfor(uint256 j=0; j<countTempHolders; j++)\n', '\t\t{\n', '\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\n', '\t\t\tif(temp_holder!=address(0x0) && !uniqueHolders[temp_holder])\n', '\t\t\t{\n', '\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\n', '\t\t\t\tif(token_balance==0)\n', '\t\t\t\t{\n', '\t\t\t\t\tuint256 coun_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\n', '\t\t\t\t\tif(coun_tempTokens>0 && coun_tempTokens/decimal >= tokensNeededToGetPayment)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuniqueHolders[temp_holder] = true;\n', '\t\t\t\t\t\tcountAllHolders += 1;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\treturn countAllHolders;\n', '\t}\n', '\n', '\t// get holders addresses to make payment each of them\n', '\tfunction get_Holders(uint256 position) constant returns(address[64] listHolders, uint256 nextPosition) \n', '\t{\n', '\t\tuint8 n = 0;\t\t\n', '\t\tuint256 countHolders = smartToken.getCountHolders();\n', '\t\tfor(; position < countHolders; position++){\t\t\t\n', '\t\t\taddress holder = smartToken.getItemHolders(position);\n', '\t\t\tif(holder!=address(0x0)){\n', '\t\t\t\tuint256 holdersTokens = smartToken.balanceOf(holder);\n', '\t\t\t\tif(holdersTokens>0){\n', '\t\t\t\t\tuint256 tempTokens = smartToken.tempTokensBalanceOf(holder);\n', '\t\t\t\t\tif((holdersTokens+tempTokens)/decimal >= tokensNeededToGetPayment){\n', '\t\t\t\t\t\t//\n', '\t\t\t\t\t\tlistHolders[n++] = holder;\n', '\t\t\t\t\t\tif (n == 64) \n', '\t\t\t\t\t\t{\n', '\t\t\t\t\t\t\tnextPosition = position + 1;\n', '\t\t\t\t\t\t\treturn;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t\n', '\t\tif (position >= countHolders)\n', '\t\t{\t\t\t\n', '\t\t\tuint256 countTempHolders = smartToken.getCountTempHolders();\t\t\t\n', '\t\t\tfor(uint256 j=position-countHolders; j<countTempHolders; j++) \n', '\t\t\t{\t\t\t\t\t\t\t\n', '\t\t\t\taddress temp_holder = smartToken.getItemTempHolders(j);\n', '\t\t\t\tif(temp_holder!=address(0x0)){\n', '\t\t\t\t\tuint256 token_balance = smartToken.balanceOf(temp_holder);\n', '\t\t\t\t\tif(token_balance==0){\n', '\t\t\t\t\t\tuint256 count_tempTokens = smartToken.tempTokensBalanceOf(temp_holder);\n', '\t\t\t\t\t\tif(count_tempTokens>0 && count_tempTokens/decimal >= tokensNeededToGetPayment){\n', '\t\t\t\t\t\t\tlistHolders[n++] = temp_holder;\n', '\t\t\t\t\t\t\tif (n == 64) \n', '\t\t\t\t\t\t\t{\n', '\t\t\t\t\t\t\t\tnextPosition = position + 1;\n', '\t\t\t\t\t\t\t\treturn;\n', '\t\t\t\t\t\t\t}\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\n', '\t\t\t\tposition = position + 1;\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tnextPosition = 0;\n', '\t}\n', '\t// Get profit for specified token holder\n', '\t// Function should be executed in blockDividend ! (see struct DividendInfo)\n', "\t// Don't call this function via etherescan.io\n", '\t// Example how to call via JavaScript and web3\n', '\t// var abiDividend = [...];\n', '\t// var holderAddress = "0xdd94ddf50485f41491c415e7133100e670cd4ef3";\n', '\t// var dividendIndex = 1;       // starts from zero\n', '\t// var blockDividend = 3527958; // see function getDividendInfo\n', '\t// web3.eth.contract(abiDividend).at("0x600e18779b6aC789b95a12C30b5863E842F4ae1d").get_HoldersProfit(dividendIndex, holderAddress, blockDividend, function(err, profit){\n', '\t//    alert("Your profit " + web3.fromWei(profit).toString(10) + "ETH");\n', '\t// });\n', '\tfunction get_HoldersProfit(uint256 dividendPaymentNum, address holder) constant returns(uint256){\n', '\t\tuint256 profit = 0;\n', '\t\tif(holder != address(0x0) && dividendHistory.length > 0 && dividendPaymentNum < dividendHistory.length){\n', '\t\t\tuint256 count_tokens = smartToken.balanceOf(holder) + smartToken.tempTokensBalanceOf(holder);\n', '\t\t\tif(count_tokens/decimal >= tokensNeededToGetPayment){\n', '\t\t\t\tprofit = (count_tokens*dividendHistory[dividendPaymentNum].amountDividend)/get_CountProfitsToken();\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn profit;\n', '\t}\n', '\n', '\t// Since the full cycle of calculations in a smart contract costs a big amount of gas and the smart contract is not able to calculate the exact block\n', '\t// the major part of calculations is transferred to the server out of the smart contract (though using functions of reading the smart contract)\n', '\t// In order to confirm fairness of dividends distribution the validating interface with open source code is used (the open version is available at https://smartroulette.io/dividends)\n', '\t// The source code is available at the address https://github.com/Smartroulette/SmartRouletteDividends\n', '\tfunction send_DividendToAddress(address holder, uint256 amount) isManager \n', '\t{\n', '\t\tuint256 avgGasValue = 30000;\n', '\t\tif (amount < avgGasValue * tx.gasprice) throw;\n', '\t\tif(holder.send(amount - avgGasValue * tx.gasprice) == false) throw;\t\n', '\t}\n', '\n', '\tfunction () payable\n', '\t{\n', '\t\tif(smartToken.gameListOf(msg.sender))\n', '\t\t{\n', '\t\t\t// only the one game can be attached to this contract\n', '\t\t\tif (gameAddress == 0) \n', '\t\t\t\tgameAddress = msg.sender;\n', '\t\t\telse if (gameAddress != msg.sender)\n', '\t\t\t\tthrow;\n', '\n', '\t\t\t// do not send new payment until previous is done\n', '\t\t\tif (dividendHistory.length > 0 && dividendHistory[dividendHistory.length - 1].AllPaymentsSent == false) throw;\n', '\n', '\t\t\tdividendHistory.push(DividendInfo(msg.value, block.number, false));\t\t\t\n', '\t\t}\n', '\t\telse \n', '\t\t{\n', '\t\t\tthrow;\n', '\t\t}\n', '\t}\n', '}']