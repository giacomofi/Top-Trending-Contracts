['pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Token Holder\n', ' * Given a ERC20 compatible Token allows holding for a certain amount of time\n', ' * after that time, the beneficiar can acquire his Tokens\n', ' */\n', ' contract TokenHolder {\n', '    \n', '    \n', '    \n', '\n', '    uint256 constant MIN_TOKENS_TO_HOLD = 1000;\n', '\n', '    /**\n', '     * A single token deposit for a certain amount of time for a certain beneficiar\n', '     */\n', '    struct TokenDeposit {\n', '        uint256 tokens;\n', '        uint256 releaseTime;\n', '    }\n', '\n', '    /** Emited when Tokens where put on hold\n', '     * @param tokens - amount of Tokens\n', '     * @param beneficiar - the address that will be able to claim Tokens in the future\n', '     * @param depositor - the address deposited tokens\n', '     * @param releaseTime - timestamp of a moment which `beneficiar` would be able to claim Tokens after\n', '     */\n', '    event Deposited(address indexed depositor, address indexed beneficiar, uint256 tokens, uint256 releaseTime);\n', '\n', '    /** Emited when Tokens where claimed back\n', '     * @param tokens - amount of Tokens claimed\n', '     * @param beneficiar - who claimed the Tokens\n', '     */\n', '    event Claimed(address indexed beneficiar, uint256 tokens);\n', '\n', '    /** all the deposits made */\n', '    mapping(address => TokenDeposit[]) deposits;\n', '\n', '    /** Tokens contract instance */\n', '    ERC20Token public tokenContract;\n', '\n', '    /**\n', '     * Creates the Token Holder with the specifief `ERC20` Token Contract instance\n', '     * @param _tokenContract `ERC20` Token Contract instance to use\n', '     */\n', '    function TokenHolder (address _tokenContract)   {  \n', '        tokenContract = ERC20Token(_tokenContract);\n', '    }\n', '\n', '    /**\n', '     * Puts some amount of Tokens on hold to be retrieved later\n', '     * @param  tokenCount - amount of tokens\n', '     * @param  tokenBeneficiar - will be able to retrieve tokens in the future\n', '     * @param  depositTime - time to hold in seconds\n', '     */\n', '    function depositTokens (uint256 tokenCount, address tokenBeneficiar, uint256 depositTime)   {  \n', '        require(tokenCount >= MIN_TOKENS_TO_HOLD);\n', '        require(tokenContract.allowance(msg.sender, address(this)) >= tokenCount);\n', '\n', '        if(tokenContract.transferFrom(msg.sender, address(this), tokenCount)) {\n', '            deposits[tokenBeneficiar].push(TokenDeposit(tokenCount, now + depositTime));\n', '            Deposited(msg.sender, tokenBeneficiar, tokenCount, now + depositTime);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of deposits for `beneficiar`\n', '     */\n', '    function getDepositCount (address beneficiar)   constant   returns (uint count) {  \n', '        return deposits[beneficiar].length;\n', '    }\n', '\n', '    /**\n', '     * returns the `idx` deposit for `beneficiar`\n', '     */\n', '    function getDeposit (address beneficiar, uint idx)   constant   returns (uint256 deposit_dot_tokens, uint256 deposit_dot_releaseTime) {  \n', 'TokenDeposit memory deposit;\n', '\n', '        require(idx < deposits[beneficiar].length);\n', '        deposit = deposits[beneficiar][idx];\n', '    deposit_dot_tokens = uint256(deposit.tokens);\n', 'deposit_dot_releaseTime = uint256(deposit.releaseTime);}\n', '\n', '    /**\n', '     * Transfers all the Tokens already unlocked to `msg.sender`\n', '     */\n', '    function claimAllTokens ()   {  \n', '        uint256 toPay = 0;\n', '\n', '        TokenDeposit[] storage myDeposits = deposits[msg.sender];\n', '\n', '        uint idx = 0;\n', '        while(true) {\n', '            if(idx >= myDeposits.length) { break; }\n', '            if(now > myDeposits[idx].releaseTime) {\n', '                toPay += myDeposits[idx].tokens;\n', '                myDeposits[idx] = myDeposits[myDeposits.length - 1];\n', '                myDeposits.length--;\n', '            } else {\n', '                idx++;\n', '            }\n', '        }\n', '\n', '        if(toPay > 0) {\n', '            tokenContract.transfer(msg.sender, toPay);\n', '            Claimed(msg.sender, toPay);\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Token Holder\n', ' * Given a ERC20 compatible Token allows holding for a certain amount of time\n', ' * after that time, the beneficiar can acquire his Tokens\n', ' */\n', ' contract TokenHolder {\n', '    \n', '    \n', '    \n', '\n', '    uint256 constant MIN_TOKENS_TO_HOLD = 1000;\n', '\n', '    /**\n', '     * A single token deposit for a certain amount of time for a certain beneficiar\n', '     */\n', '    struct TokenDeposit {\n', '        uint256 tokens;\n', '        uint256 releaseTime;\n', '    }\n', '\n', '    /** Emited when Tokens where put on hold\n', '     * @param tokens - amount of Tokens\n', '     * @param beneficiar - the address that will be able to claim Tokens in the future\n', '     * @param depositor - the address deposited tokens\n', '     * @param releaseTime - timestamp of a moment which `beneficiar` would be able to claim Tokens after\n', '     */\n', '    event Deposited(address indexed depositor, address indexed beneficiar, uint256 tokens, uint256 releaseTime);\n', '\n', '    /** Emited when Tokens where claimed back\n', '     * @param tokens - amount of Tokens claimed\n', '     * @param beneficiar - who claimed the Tokens\n', '     */\n', '    event Claimed(address indexed beneficiar, uint256 tokens);\n', '\n', '    /** all the deposits made */\n', '    mapping(address => TokenDeposit[]) deposits;\n', '\n', '    /** Tokens contract instance */\n', '    ERC20Token public tokenContract;\n', '\n', '    /**\n', '     * Creates the Token Holder with the specifief `ERC20` Token Contract instance\n', '     * @param _tokenContract `ERC20` Token Contract instance to use\n', '     */\n', '    function TokenHolder (address _tokenContract)   {  \n', '        tokenContract = ERC20Token(_tokenContract);\n', '    }\n', '\n', '    /**\n', '     * Puts some amount of Tokens on hold to be retrieved later\n', '     * @param  tokenCount - amount of tokens\n', '     * @param  tokenBeneficiar - will be able to retrieve tokens in the future\n', '     * @param  depositTime - time to hold in seconds\n', '     */\n', '    function depositTokens (uint256 tokenCount, address tokenBeneficiar, uint256 depositTime)   {  \n', '        require(tokenCount >= MIN_TOKENS_TO_HOLD);\n', '        require(tokenContract.allowance(msg.sender, address(this)) >= tokenCount);\n', '\n', '        if(tokenContract.transferFrom(msg.sender, address(this), tokenCount)) {\n', '            deposits[tokenBeneficiar].push(TokenDeposit(tokenCount, now + depositTime));\n', '            Deposited(msg.sender, tokenBeneficiar, tokenCount, now + depositTime);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of deposits for `beneficiar`\n', '     */\n', '    function getDepositCount (address beneficiar)   constant   returns (uint count) {  \n', '        return deposits[beneficiar].length;\n', '    }\n', '\n', '    /**\n', '     * returns the `idx` deposit for `beneficiar`\n', '     */\n', '    function getDeposit (address beneficiar, uint idx)   constant   returns (uint256 deposit_dot_tokens, uint256 deposit_dot_releaseTime) {  \n', 'TokenDeposit memory deposit;\n', '\n', '        require(idx < deposits[beneficiar].length);\n', '        deposit = deposits[beneficiar][idx];\n', '    deposit_dot_tokens = uint256(deposit.tokens);\n', 'deposit_dot_releaseTime = uint256(deposit.releaseTime);}\n', '\n', '    /**\n', '     * Transfers all the Tokens already unlocked to `msg.sender`\n', '     */\n', '    function claimAllTokens ()   {  \n', '        uint256 toPay = 0;\n', '\n', '        TokenDeposit[] storage myDeposits = deposits[msg.sender];\n', '\n', '        uint idx = 0;\n', '        while(true) {\n', '            if(idx >= myDeposits.length) { break; }\n', '            if(now > myDeposits[idx].releaseTime) {\n', '                toPay += myDeposits[idx].tokens;\n', '                myDeposits[idx] = myDeposits[myDeposits.length - 1];\n', '                myDeposits.length--;\n', '            } else {\n', '                idx++;\n', '            }\n', '        }\n', '\n', '        if(toPay > 0) {\n', '            tokenContract.transfer(msg.sender, toPay);\n', '            Claimed(msg.sender, toPay);\n', '        }\n', '    }\n', '}']
