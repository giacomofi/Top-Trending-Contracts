['pragma solidity ^0.4.13;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', '/*\n', '    ERC20 compatible smart contract\n', '*/\n', 'contract LoggedERC20 is Ownable {\n', '    /* Structures */\n', '    struct LogValueBlock {\n', '    uint256 value;\n', '    uint256 block;\n', '    }\n', '\n', '    /* Public variables of the token */\n', "    string public standard = 'LogValueBlockToken 0.1';\n", '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    LogValueBlock[] public loggedTotalSupply;\n', '\n', '    bool public locked;\n', '\n', '    uint256 public creationBlock;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => LogValueBlock[]) public loggedBalances;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function LoggedERC20(\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    uint8 decimalUnits,\n', '    string tokenSymbol,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) {\n', '        LogValueBlock memory valueBlock = LogValueBlock(initialSupply, block.number);\n', '\n', '        loggedTotalSupply.push(valueBlock);\n', '\n', '        if(transferAllSupplyToOwner) {\n', '            loggedBalances[msg.sender].push(valueBlock);\n', '        }\n', '        else {\n', '            loggedBalances[this].push(valueBlock);\n', '        }\n', '\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '        decimals = decimalUnits;                            // Amount of decimals for display purposes\n', '        locked = _locked;\n', '    }\n', '\n', '    function valueAt(LogValueBlock [] storage checkpoints, uint256 block) internal returns (uint256) {\n', '        if(checkpoints.length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        LogValueBlock memory prevLogValueBlock;\n', '\n', '        for(uint256 i = 0; i < checkpoints.length; i++) {\n', '\n', '            LogValueBlock memory checkpoint = checkpoints[i];\n', '\n', '            if(checkpoint.block > block) {\n', '                return prevLogValueBlock.value;\n', '            }\n', '\n', '            prevLogValueBlock = checkpoint;\n', '        }\n', '\n', '        return prevLogValueBlock.value;\n', '    }\n', '\n', '    function setBalance(address _address, uint256 value) internal {\n', '        loggedBalances[_address].push(LogValueBlock(value, block.number));\n', '    }\n', '\n', '    function totalSupply() returns (uint256) {\n', '        return valueAt(loggedTotalSupply, block.number);\n', '    }\n', '\n', '    function balanceOf(address _address) returns (uint256) {\n', '        return valueAt(loggedBalances[_address], block.number);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 value) internal returns (bool success) {\n', '        uint256 balanceFrom = valueAt(loggedBalances[_from], block.number);\n', '        uint256 balanceTo = valueAt(loggedBalances[_to], block.number);\n', '\n', '        if(value == 0) {\n', '            return false;\n', '        }\n', '\n', '        if(frozenAccount[_from] == true) {\n', '            return false;\n', '        }\n', '\n', '        if(balanceFrom < value) {\n', '            return false;\n', '        }\n', '\n', '        if(balanceTo + value <= balanceTo) {\n', '            return false;\n', '        }\n', '\n', '        loggedBalances[_from].push(LogValueBlock(balanceFrom - value, block.number));\n', '        loggedBalances[_to].push(LogValueBlock(balanceTo + value, block.number));\n', '\n', '        Transfer(_from, _to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        require(locked == false);\n', '\n', '        bool status = transferInternal(msg.sender, _to, _value);\n', '\n', '        require(status == true);\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        if(allowance[_from][msg.sender] < _value) {\n', '            return false;\n', '        }\n', '\n', '        bool _success = transferInternal(_from, _to, _value);\n', '\n', '        if(_success) {\n', '            allowance[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        return _success;\n', '    }\n', '}\n', '\n', '/*\n', '    Reward distribution functionality\n', '*/\n', 'contract LoggedReward is Ownable, LoggedERC20 {\n', '    /* Structs */\n', '    struct Reward {\n', '    uint256 id;\n', '\n', '    uint256 block;\n', '    uint256 time;\n', '    uint256 amount;\n', '\n', '    uint256 claimedAmount;\n', '    uint256 transferedBack;\n', '\n', '    uint256 totalSupply;\n', '    uint256 recycleTime;\n', '\n', '    bool recycled;\n', '\n', '    mapping (address => bool) claimed;\n', '    }\n', '\n', '    /* variables */\n', '    Reward [] public rewards;\n', '\n', '    mapping (address => uint256) rewardsClaimed;\n', '\n', '    /* Events */\n', '    event RewardTransfered(uint256 id, address indexed _address, uint256 _block, uint256 _amount, uint256 _totalSupply);\n', '    event RewardClaimed(uint256 id, address indexed _address, uint256 _claim);\n', '    event UnclaimedRewardTransfer(uint256 id, uint256 _value);\n', '    event RewardRecycled(uint256 id, address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply);\n', '\n', '    function LoggedReward(\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    uint8 decimalUnits,\n', '    string tokenSymbol,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) LoggedERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked) {\n', '\n', '    }\n', '\n', '    function addReward(uint256 recycleTime) payable onlyOwner {\n', '        require(msg.sender == owner);\n', '        require(msg.value > 0);\n', '\n', '        uint256 id = rewards.length;\n', '        uint256 _totalSupply = valueAt(loggedTotalSupply, block.number);\n', '\n', '        rewards.push(\n', '        Reward(\n', '        id,\n', '        block.number,\n', '        now,\n', '        msg.value,\n', '        0,\n', '        0,\n', '        _totalSupply,\n', '        recycleTime,\n', '        false\n', '        )\n', '        );\n', '\n', '        RewardTransfered(id, msg.sender, block.number, msg.value, _totalSupply);\n', '    }\n', '\n', '    function claimedRewardHook(uint256 rewardId, address _address, uint256 claimed) internal {\n', '        RewardClaimed(rewardId, _address, claimed);\n', '    }\n', '\n', '    function claimReward(uint256 rewardId) public returns (bool) {\n', '        if(rewards.length - 1 < rewardId) {\n', '            return false;\n', '        }\n', '\n', '        Reward storage reward = rewards[rewardId];\n', '\n', '        if(reward.claimed[msg.sender] == true) {\n', '            return false;\n', '        }\n', '\n', '        if(reward.recycled == true) {\n', '            return false;\n', '        }\n', '\n', '        if(now >= reward.time + reward.recycleTime) {\n', '            return false;\n', '        }\n', '\n', '        uint256 balance = valueAt(loggedBalances[msg.sender], reward.block);\n', '\n', '        if(balance == 0) {\n', '            return false;\n', '        }\n', '\n', '        uint256 claim = balance * reward.amount / reward.totalSupply;\n', '\n', '        reward.claimed[msg.sender] = true;\n', '\n', '        reward.claimedAmount = reward.claimedAmount + claim;\n', '\n', '        if (claim > 0) {\n', '            claimedRewardHook(rewardId, msg.sender, claim);\n', '\n', '            msg.sender.transfer(claim);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function claimRewards() public {\n', '        require(rewardsClaimed[msg.sender] < rewards.length);\n', '        for (uint i = rewardsClaimed[msg.sender]; i < rewards.length; i++) {\n', '            if ((rewards[i].claimed[msg.sender] == false) && (rewards[i].recycled == false)) {\n', '                rewardsClaimed[msg.sender] = i + 1;\n', '                claimReward(i);\n', '            }\n', '        }\n', '    }\n', '\n', '    function recycleReward(uint256 rewardId) public onlyOwner returns (bool success) {\n', '        if(rewards.length - 1 < rewardId) {\n', '            return false;\n', '        }\n', '\n', '        Reward storage reward = rewards[rewardId];\n', '\n', '        if(reward.recycled) {\n', '            return false;\n', '        }\n', '\n', '        reward.recycled = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function refundUnclaimedEthers(uint256 rewardId) public onlyOwner returns (bool success) {\n', '        if(rewards.length - 1 < rewardId) {\n', '            return false;\n', '        }\n', '\n', '        Reward storage reward = rewards[rewardId];\n', '\n', '        if(reward.recycled == false) {\n', '            if(now < reward.time + reward.recycleTime) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        uint256 claimedBackAmount = reward.amount - reward.claimedAmount;\n', '\n', '        reward.transferedBack = claimedBackAmount;\n', '\n', '        if(claimedBackAmount > 0) {\n', '            owner.transfer(claimedBackAmount);\n', '\n', '            UnclaimedRewardTransfer(rewardId, claimedBackAmount);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '}\n', '\n', '/*\n', '    Smart contract with reward functionality & erc20 compatible interface\n', '*/\n', 'contract Inonit is LoggedReward {\n', '    /* events */\n', '    event AddressRecovered(address indexed from, address indexed to);\n', '    event InactivityHolderResetBalance(address indexed _holder);\n', '\n', '    function Inonit(\n', '    uint256 initialSupply,\n', '    string standardName,\n', '    string tokenName,\n', '    string tokenSymbol\n', '    ) LoggedReward(initialSupply, tokenName, 18, tokenSymbol, true, false) {\n', '        standard = standardName;\n', '    }\n', '\n', '    function balanceOf(address _address) returns (uint256) {\n', '        if(rewards.length > 0) {\n', '            Reward storage reward = rewards[0];\n', '\n', '            if(reward.recycled) {\n', '                return 0;\n', '            }\n', '\n', '            if(now >= reward.time + reward.recycleTime) {\n', '                return 0;\n', '            }\n', '        }\n', '\n', '        uint256 holderBalance = valueAt(loggedBalances[_address], block.number);\n', '\n', '        return holderBalance;\n', '    }\n', '\n', '    function claimedRewardHook(uint256 rewardId, address _address, uint256 claimed) internal {\n', '        setBalance(_address, 0);\n', '\n', '        super.claimedRewardHook(rewardId, _address, claimed);\n', '    }\n', '\n', '    function recover(address _from, address _to) onlyOwner {\n', '        uint256 tokens = balanceOf(_from);\n', '\n', '        setBalance(_from, 0);\n', '        setBalance(_to, tokens);\n', '\n', '        AddressRecovered(_from, _to);\n', '    }\n', '\n', '    function setLocked(bool _locked) onlyOwner {\n', '        locked = _locked;\n', '    }\n', '}']