['pragma solidity ^0.4.17;\n', '\n', 'library SafeMath {\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  address public owner; //owner\n', '  address public animator; //animator\n', '  function balanceOf(address who) constant public returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  function commitDividend(address who) internal; // pays remaining dividend\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant public returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '  mapping(address => uint) balances;\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '     assert(msg.data.length >= size + 4);\n', '     _;\n', '  }\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n', '    commitDividend(msg.sender);\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    if(_to == address(this)) {\n', '        commitDividend(owner);\n', '        balances[owner] = balances[owner].add(_value);\n', '        Transfer(msg.sender, owner, _value);\n', '    }\n', '    else {\n', '        commitDividend(_to);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '  }\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant public returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    commitDividend(_from);\n', '    commitDividend(_to);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) public {\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SmartBillions contract\n', ' */\n', 'contract SmartBillions is StandardToken {\n', '\n', '    // metadata\n', '    string public constant name = "SmartBillions Token";\n', '    string public constant symbol = "PLAY";\n', '    uint public constant decimals = 0;\n', '\n', '    // contract state\n', '    struct Wallet {\n', '        uint208 balance; // current balance of user\n', '    \tuint16 lastDividendPeriod; // last processed dividend period of user&#39;s tokens\n', '    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\n', '    }\n', '    mapping (address => Wallet) wallets;\n', '    struct Bet {\n', '        uint192 value; // bet size\n', '        uint32 betHash; // selected numbers\n', '        uint32 blockNum; // blocknumber when lottery runs\n', '    }\n', '    mapping (address => Bet) bets;\n', '\n', '    uint public walletBalance = 0; // sum of funds in wallets\n', '\n', '    // investment parameters\n', '    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\n', '    uint public investBalance = 0; // funding from investors\n', '    uint public investBalanceGot = 0; // funding collected\n', '    uint public investBalanceMax = 200000 ether; // maximum funding\n', '    uint public dividendPeriod = 1;\n', '    uint[] public dividends; // dividens collected per period, growing array\n', '\n', '    // betting parameters\n', '    uint public maxWin = 0; // maximum prize won\n', '    uint public hashFirst = 0; // start time of building hashes database\n', '    uint public hashLast = 0; // last saved block of hashes\n', '    uint public hashNext = 0; // next available bet block.number\n', '    uint public hashBetSum = 0; // used bet volume of next block\n', '    uint public hashBetMax = 5 ether; // maximum bet size per block\n', '    uint[] public hashes; // space for storing lottery results\n', '\n', '    // constants\n', '    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n', '    uint public constant hashesSize = 16384 ; // 30 days of blocks\n', '    uint public coldStoreLast = 0 ; // block of last cold store transfer\n', '\n', '    // events\n', '    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n', '    event LogLoss(address indexed player, uint bethash, uint hash);\n', '    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n', '    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n', '    event LogRecordWin(address indexed player, uint amount);\n', '    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n', '    event LogDividend(address indexed investor, uint amount, uint period);\n', '\n', '    modifier onlyOwner() {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAnimator() {\n', '        assert(msg.sender == animator);\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    function SmartBillions() public {\n', '        owner = msg.sender;\n', '        animator = msg.sender;\n', '        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n', '        dividends.push(0); // not used\n', '        dividends.push(0); // current dividend\n', '    }\n', '\n', '/* getters */\n', '    \n', '    /**\n', '     * @dev Show length of allocated swap space\n', '     */\n', '    function hashesLength() constant external returns (uint) {\n', '        return uint(hashes.length);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show balance of wallet\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletBalanceOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].balance);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show last dividend period processed\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletPeriodOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].lastDividendPeriod);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number when withdraw can continue\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletBlockOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].nextWithdrawBlock);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show bet size.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betValueOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].value);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number of lottery run for the bet.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betHashOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].betHash);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number of lottery run for the bet.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betBlockNumberOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].blockNum);\n', '    }\n', '    \n', '    /**\n', '     * @dev Print number of block till next expected dividend payment\n', '     */\n', '    function dividendsBlocks() constant external returns (uint) {\n', '        if(investStart > 0) {\n', '            return(0);\n', '        }\n', '        uint period = (block.number - hashFirst) / (10 * hashesSize);\n', '        if(period > dividendPeriod) {\n', '            return(0);\n', '        }\n', '        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n', '    }\n', '\n', '/* administrative functions */\n', '\n', '    /**\n', '     * @dev Change owner.\n', '     * @param _who The address of new owner.\n', '     */\n', '    function changeOwner(address _who) external onlyOwner {\n', '        assert(_who != address(0));\n', '        commitDividend(msg.sender);\n', '        commitDividend(_who);\n', '        owner = _who;\n', '    }\n', '\n', '    /**\n', '     * @dev Change animator.\n', '     * @param _who The address of new animator.\n', '     */\n', '    function changeAnimator(address _who) external onlyAnimator {\n', '        assert(_who != address(0));\n', '        commitDividend(msg.sender);\n', '        commitDividend(_who);\n', '        animator = _who;\n', '    }\n', '\n', '    /**\n', '     * @dev Set ICO Start block.\n', '     * @param _when The block number of the ICO.\n', '     */\n', '    function setInvestStart(uint _when) external onlyOwner {\n', '        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n', '        investStart = _when;\n', '    }\n', '\n', '    /**\n', '     * @dev Set maximum bet size per block\n', '     * @param _maxsum The maximum bet size in wei.\n', '     */\n', '    function setBetMax(uint _maxsum) external onlyOwner {\n', '        hashBetMax = _maxsum;\n', '    }\n', '\n', '    /**\n', '     * @dev Reset bet size accounting, to increase bet volume above safe limits\n', '     */\n', '    function resetBet() external onlyOwner {\n', '        hashNext = block.number + 3;\n', '        hashBetSum = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Move funds to cold storage\n', '     * @dev investBalance and walletBalance is protected from withdraw by owner\n', '     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\n', '     * @param _amount The amount of wei to move to cold storage\n', '     */\n', '    function coldStore(uint _amount) external onlyOwner {\n', '        houseKeeping();\n', '        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n', '        if(investBalance >= investBalanceGot / 2){ // additional jackpot protection\n', '            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n', '        }\n', '        msg.sender.transfer(_amount);\n', '        coldStoreLast = block.number;\n', '    }\n', '\n', '    /**\n', '     * @dev Move funds to contract jackpot\n', '     */\n', '    function hotStore() payable external {\n', '        walletBalance += msg.value;\n', '        wallets[msg.sender].balance += uint208(msg.value);\n', '        houseKeeping();\n', '    }\n', '\n', '/* housekeeping functions */\n', '\n', '    /**\n', '     * @dev Update accounting\n', '     */\n', '    function houseKeeping() public {\n', '        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\n', '            investStart = 0; // start dividend payments\n', '        }\n', '        else {\n', '            if(hashFirst > 0){\n', '\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n', '                if(period > dividends.length - 2) {\n', '                    dividends.push(0);\n', '                }\n', '                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n', '                    dividendPeriod++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '/* payments */\n', '\n', '    /**\n', '     * @dev Pay balance from wallet\n', '     */\n', '    function payWallet() public {\n', '        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n', '            uint balance = wallets[msg.sender].balance;\n', '            wallets[msg.sender].balance = 0;\n', '            walletBalance -= balance;\n', '            pay(balance);\n', '        }\n', '    }\n', '\n', '    function pay(uint _amount) private {\n', '        uint maxpay = this.balance / 2;\n', '        if(maxpay >= _amount) {\n', '            msg.sender.transfer(_amount);\n', '            if(_amount > 1 finney) {\n', '                houseKeeping();\n', '            }\n', '        }\n', '        else {\n', '            uint keepbalance = _amount - maxpay;\n', '            walletBalance += keepbalance;\n', '            wallets[msg.sender].balance += uint208(keepbalance);\n', '            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n', '            msg.sender.transfer(maxpay);\n', '        }\n', '    }\n', '\n', '/* investment functions */\n', '\n', '    /**\n', '     * @dev Buy tokens\n', '     */\n', '    function investDirect() payable external {\n', '        invest(owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy tokens with affiliate partner\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function invest(address _partner) payable public {\n', '        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n', '        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n', '        uint investing = msg.value;\n', '        if(investing > investBalanceMax - investBalance) {\n', '            investing = investBalanceMax - investBalance;\n', '            investBalance = investBalanceMax;\n', '            investBalanceGot = investBalanceMax;\n', '            investStart = 0; // close investment round\n', '            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\n', '        }\n', '        else{\n', '            investBalance += investing;\n', '            investBalanceGot += investing;\n', '        }\n', '        if(_partner == address(0) || _partner == owner){\n', '            walletBalance += investing / 10;\n', '            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\n', '        else{\n', '            walletBalance += (investing * 5 / 100) * 2;\n', '            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\n', '            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\n', '        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\n', '        uint senderBalance = investing / 10**15;\n', '        uint ownerBalance = investing * 16 / 10**17  ;\n', '        uint animatorBalance = investing * 10 / 10**17  ;\n', '        balances[msg.sender] += senderBalance;\n', '        balances[owner] += ownerBalance ; // 13% of shares go to developers\n', '        balances[animator] += animatorBalance ; // 8% of shares go to animator\n', '        totalSupply += senderBalance + ownerBalance + animatorBalance;\n', '        Transfer(address(0),msg.sender,senderBalance); // for etherscan\n', '        Transfer(address(0),owner,ownerBalance); // for etherscan\n', '        Transfer(address(0),animator,animatorBalance); // for etherscan\n', '        LogInvestment(msg.sender,_partner,investing);\n', '    }\n', '\n', '    /**\n', '     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\n', '     */\n', '    function disinvest() external {\n', '        require(investStart == 0);\n', '        commitDividend(msg.sender);\n', '        uint initialInvestment = balances[msg.sender] * 10**15;\n', '        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\n', '        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\n', '        investBalance -= initialInvestment;\n', '        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n', '        payWallet();\n', '    }\n', '\n', '    /**\n', '     * @dev Pay unpaid dividends\n', '     */\n', '    function payDividends() external {\n', '        require(investStart == 0);\n', '        commitDividend(msg.sender);\n', '        payWallet();\n', '    }\n', '\n', '    /**\n', '     * @dev Commit remaining dividends before transfer of tokens\n', '     */\n', '    function commitDividend(address _who) internal {\n', '        uint last = wallets[_who].lastDividendPeriod;\n', '        if((balances[_who]==0) || (last==0)){\n', '            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n', '            return;\n', '        }\n', '        if(last==dividendPeriod) {\n', '            return;\n', '        }\n', '        uint share = balances[_who] * 0xffffffff / totalSupply;\n', '        uint balance = 0;\n', '        for(;last<dividendPeriod;last++) {\n', '            balance += share * dividends[last];\n', '        }\n', '        balance = (balance / 0xffffffff);\n', '        walletBalance += balance;\n', '        wallets[_who].balance += uint208(balance);\n', '        wallets[_who].lastDividendPeriod = uint16(last);\n', '        LogDividend(_who,balance,last);\n', '    }\n', '\n', '/* lottery functions */\n', '\n', '    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\n', '        uint24 bethash = uint24(_player.betHash);\n', '        uint24 hit = bethash ^ _hash;\n', '        uint24 matches =\n', '            ((hit & 0xF) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF00000) == 0 ? 1 : 0 );\n', '        if(matches == 6){\n', '            return(uint(_player.value) * 7000000);\n', '        }\n', '        if(matches == 5){\n', '            return(uint(_player.value) * 20000);\n', '        }\n', '        if(matches == 4){\n', '            return(uint(_player.value) * 500);\n', '        }\n', '        if(matches == 3){\n', '            return(uint(_player.value) * 25);\n', '        }\n', '        if(matches == 2){\n', '            return(uint(_player.value) * 3);\n', '        }\n', '        return(0);\n', '    }\n', '    \n', '    /**\n', '     * @dev Check if won in lottery\n', '     */\n', '    function betOf(address _who) constant external returns (uint)  {\n', '        Bet memory player = bets[_who];\n', '        if( (player.value==0) ||\n', '            (player.blockNum<=1) ||\n', '            (block.number<player.blockNum) ||\n', '            (block.number>=player.blockNum + (10 * hashesSize))){\n', '            return(0);\n', '        }\n', '        if(block.number<player.blockNum+256){\n', '            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n', '        }\n', '        if(hashFirst>0){\n', '            uint32 hash = getHash(player.blockNum);\n', '            if(hash == 0x1000000) { // load hash failed :-(, return funds\n', '                return(uint(player.value));\n', '            }\n', '            else{\n', '                return(betPrize(player,uint24(hash)));\n', '            }\n', '\t}\n', '        return(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Check if won in lottery\n', '     */\n', '    function won() public {\n', '        Bet memory player = bets[msg.sender];\n', '        if(player.blockNum==0){ // create a new player\n', '            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '            return;\n', '        }\n', '        if((player.value==0) || (player.blockNum==1)){\n', '            payWallet();\n', '            return;\n', '        }\n', '        require(block.number>player.blockNum); // if there is an active bet, throw()\n', '        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\n', '            LogLate(msg.sender,player.blockNum,block.number);\n', '            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '            return;\n', '        }\n', '        uint prize = 0;\n', '        uint32 hash = 0;\n', '        if(block.number<player.blockNum+256){\n', '            hash = uint24(block.blockhash(player.blockNum));\n', '            prize = betPrize(player,uint24(hash));\n', '        }\n', '        else {\n', '            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n', '                hash = getHash(player.blockNum);\n', '                if(hash == 0x1000000) { // load hash failed :-(\n', '                    //prize = uint(player.value); no refunds anymore\n', '                    LogLate(msg.sender,player.blockNum,block.number);\n', '                    bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '                    return();\n', '                }\n', '                else{\n', '                    prize = betPrize(player,uint24(hash));\n', '                }\n', '\t    }\n', '            else{\n', '                LogLate(msg.sender,player.blockNum,block.number);\n', '                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '                return();\n', '            }\n', '        }\n', '        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '        if(prize>0) {\n', '            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n', '            if(prize > maxWin){\n', '                maxWin = prize;\n', '                LogRecordWin(msg.sender,prize);\n', '            }\n', '            pay(prize);\n', '        }\n', '        else{\n', '            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Send ether to buy tokens during ICO\n', '     * @dev or send less than 1 ether to contract to play\n', '     * @dev or send 0 to collect prize\n', '     */\n', '    function () payable external {\n', '        if(msg.value > 0){\n', '            if(investStart>1){ // during ICO payment to the contract is treated as investment\n', '                invest(owner);\n', '            }\n', '            else{ // if not ICO running payment to contract is treated as play\n', '                play();\n', '            }\n', '            return;\n', '        }\n', '        //check for dividends and other assets\n', '        if(investStart == 0 && balances[msg.sender]>0){\n', '            commitDividend(msg.sender);}\n', '        won(); // will run payWallet() if nothing else available\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery\n', '     */\n', '    function play() payable public returns (uint) {\n', '        return playSystem(uint(keccak256(msg.sender,block.number)), address(0));\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery with random numbers\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function playRandom(address _partner) payable public returns (uint) {\n', '        return playSystem(uint(keccak256(msg.sender,block.number)), _partner);\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery with own numbers\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n', '        won(); // check if player did not win \n', '        uint24 bethash = uint24(_hash);\n', '        require(msg.value <= 1 ether && msg.value < hashBetMax);\n', '        if(msg.value > 0){\n', '            if(investStart==0) { // dividends only after investment finished\n', '                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\n', '            }\n', '            if(_partner != address(0)) {\n', '                uint fee = msg.value / 100;\n', '                walletBalance += fee;\n', '                wallets[_partner].balance += uint208(fee); // 1% for affiliates\n', '            }\n', '            if(hashNext < block.number + 3) {\n', '                hashNext = block.number + 3;\n', '                hashBetSum = msg.value;\n', '            }\n', '            else{\n', '                if(hashBetSum > hashBetMax) {\n', '                    hashNext++;\n', '                    hashBetSum = msg.value;\n', '                }\n', '                else{\n', '                    hashBetSum += msg.value;\n', '                }\n', '            }\n', '            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n', '            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n', '        }\n', '        putHashes(25); // players help collecing data, now much more than in last contract\n', '        return(hashNext);\n', '    }\n', '\n', '/* database functions */\n', '\n', '    /**\n', '     * @dev Create hash data swap space\n', '     * @param _sadd Number of hashes to add (<=256)\n', '     */\n', '    function addHashes(uint _sadd) public returns (uint) {\n', '        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n', '        uint n = hashes.length;\n', '        if(n + _sadd > hashesSize){\n', '            hashes.length = hashesSize;\n', '        }\n', '        else{\n', '            hashes.length += _sadd;\n', '        }\n', '        for(;n<hashes.length;n++){ // make sure to burn gas\n', '            hashes[n] = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        }\n', '        if(hashes.length>=hashesSize) { // assume block.number > 10\n', '            hashFirst = block.number - ( block.number % 10);\n', '            hashLast = hashFirst;\n', '        }\n', '        return(hashes.length);\n', '    }\n', '\n', '    /**\n', '     * @dev Create hash data swap space, add 128 hashes\n', '     */\n', '    function addHashes128() external returns (uint) {\n', '        return(addHashes(128));\n', '    }\n', '\n', '    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n', '        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n', '            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n', '            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n', '            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n', '            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n', '            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n', '            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n', '            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n', '            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n', '            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n', '            | ( ( uint(_delta) / hashesSize) << 240)); \n', '    }\n', '\n', '    function getHash(uint _block) constant private returns (uint32) {\n', '        uint delta = (_block - hashFirst) / 10;\n', '        uint hash = hashes[delta % hashesSize];\n', '        if(delta / hashesSize != hash >> 240) {\n', '            return(0x1000000); // load failed, incorrect data in hashes\n', '        }\n', '        uint slotp = (_block - hashFirst) % 10; \n', '        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n', '    }\n', '    \n', '    /**\n', '     * @dev Fill hash data\n', '     */\n', '    function putHash() public returns (bool) {\n', '        uint lastb = hashLast;\n', '        if(lastb == 0 || block.number <= lastb + 10) {\n', '            return(false);\n', '        }\n', '        uint blockn256;\n', '        if(block.number<256) { // useless test for testnet :-(\n', '            blockn256 = 0;\n', '        }\n', '        else{\n', '            blockn256 = block.number - 255;\n', '        }\n', '        if(lastb < blockn256) {\n', '            uint num = blockn256;\n', '            num += num % 10;\n', '            lastb = num; \n', '        }\n', '        uint delta = (lastb - hashFirst) / 10;\n', '        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n', '        hashLast = lastb + 10;\n', '        return(true);\n', '    }\n', '\n', '    /**\n', '     * @dev Fill hash data many times\n', '     * @param _num Number of iterations\n', '     */\n', '    function putHashes(uint _num) public {\n', '        uint n=0;\n', '        for(;n<_num;n++){\n', '            if(!putHash()){\n', '                return;\n', '            }\n', '        }\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.17;\n', '\n', 'library SafeMath {\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  address public owner; //owner\n', '  address public animator; //animator\n', '  function balanceOf(address who) constant public returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  function commitDividend(address who) internal; // pays remaining dividend\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant public returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '  mapping(address => uint) balances;\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '     assert(msg.data.length >= size + 4);\n', '     _;\n', '  }\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n', '    commitDividend(msg.sender);\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    if(_to == address(this)) {\n', '        commitDividend(owner);\n', '        balances[owner] = balances[owner].add(_value);\n', '        Transfer(msg.sender, owner, _value);\n', '    }\n', '    else {\n', '        commitDividend(_to);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '  }\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant public returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    commitDividend(_from);\n', '    commitDividend(_to);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) public {\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SmartBillions contract\n', ' */\n', 'contract SmartBillions is StandardToken {\n', '\n', '    // metadata\n', '    string public constant name = "SmartBillions Token";\n', '    string public constant symbol = "PLAY";\n', '    uint public constant decimals = 0;\n', '\n', '    // contract state\n', '    struct Wallet {\n', '        uint208 balance; // current balance of user\n', "    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\n", '    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\n', '    }\n', '    mapping (address => Wallet) wallets;\n', '    struct Bet {\n', '        uint192 value; // bet size\n', '        uint32 betHash; // selected numbers\n', '        uint32 blockNum; // blocknumber when lottery runs\n', '    }\n', '    mapping (address => Bet) bets;\n', '\n', '    uint public walletBalance = 0; // sum of funds in wallets\n', '\n', '    // investment parameters\n', '    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\n', '    uint public investBalance = 0; // funding from investors\n', '    uint public investBalanceGot = 0; // funding collected\n', '    uint public investBalanceMax = 200000 ether; // maximum funding\n', '    uint public dividendPeriod = 1;\n', '    uint[] public dividends; // dividens collected per period, growing array\n', '\n', '    // betting parameters\n', '    uint public maxWin = 0; // maximum prize won\n', '    uint public hashFirst = 0; // start time of building hashes database\n', '    uint public hashLast = 0; // last saved block of hashes\n', '    uint public hashNext = 0; // next available bet block.number\n', '    uint public hashBetSum = 0; // used bet volume of next block\n', '    uint public hashBetMax = 5 ether; // maximum bet size per block\n', '    uint[] public hashes; // space for storing lottery results\n', '\n', '    // constants\n', '    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n', '    uint public constant hashesSize = 16384 ; // 30 days of blocks\n', '    uint public coldStoreLast = 0 ; // block of last cold store transfer\n', '\n', '    // events\n', '    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n', '    event LogLoss(address indexed player, uint bethash, uint hash);\n', '    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n', '    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n', '    event LogRecordWin(address indexed player, uint amount);\n', '    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n', '    event LogDividend(address indexed investor, uint amount, uint period);\n', '\n', '    modifier onlyOwner() {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAnimator() {\n', '        assert(msg.sender == animator);\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    function SmartBillions() public {\n', '        owner = msg.sender;\n', '        animator = msg.sender;\n', '        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n', '        dividends.push(0); // not used\n', '        dividends.push(0); // current dividend\n', '    }\n', '\n', '/* getters */\n', '    \n', '    /**\n', '     * @dev Show length of allocated swap space\n', '     */\n', '    function hashesLength() constant external returns (uint) {\n', '        return uint(hashes.length);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show balance of wallet\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletBalanceOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].balance);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show last dividend period processed\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletPeriodOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].lastDividendPeriod);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number when withdraw can continue\n', '     * @param _owner The address of the account.\n', '     */\n', '    function walletBlockOf(address _owner) constant external returns (uint) {\n', '        return uint(wallets[_owner].nextWithdrawBlock);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show bet size.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betValueOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].value);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number of lottery run for the bet.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betHashOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].betHash);\n', '    }\n', '    \n', '    /**\n', '     * @dev Show block number of lottery run for the bet.\n', '     * @param _owner The address of the player.\n', '     */\n', '    function betBlockNumberOf(address _owner) constant external returns (uint) {\n', '        return uint(bets[_owner].blockNum);\n', '    }\n', '    \n', '    /**\n', '     * @dev Print number of block till next expected dividend payment\n', '     */\n', '    function dividendsBlocks() constant external returns (uint) {\n', '        if(investStart > 0) {\n', '            return(0);\n', '        }\n', '        uint period = (block.number - hashFirst) / (10 * hashesSize);\n', '        if(period > dividendPeriod) {\n', '            return(0);\n', '        }\n', '        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n', '    }\n', '\n', '/* administrative functions */\n', '\n', '    /**\n', '     * @dev Change owner.\n', '     * @param _who The address of new owner.\n', '     */\n', '    function changeOwner(address _who) external onlyOwner {\n', '        assert(_who != address(0));\n', '        commitDividend(msg.sender);\n', '        commitDividend(_who);\n', '        owner = _who;\n', '    }\n', '\n', '    /**\n', '     * @dev Change animator.\n', '     * @param _who The address of new animator.\n', '     */\n', '    function changeAnimator(address _who) external onlyAnimator {\n', '        assert(_who != address(0));\n', '        commitDividend(msg.sender);\n', '        commitDividend(_who);\n', '        animator = _who;\n', '    }\n', '\n', '    /**\n', '     * @dev Set ICO Start block.\n', '     * @param _when The block number of the ICO.\n', '     */\n', '    function setInvestStart(uint _when) external onlyOwner {\n', '        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n', '        investStart = _when;\n', '    }\n', '\n', '    /**\n', '     * @dev Set maximum bet size per block\n', '     * @param _maxsum The maximum bet size in wei.\n', '     */\n', '    function setBetMax(uint _maxsum) external onlyOwner {\n', '        hashBetMax = _maxsum;\n', '    }\n', '\n', '    /**\n', '     * @dev Reset bet size accounting, to increase bet volume above safe limits\n', '     */\n', '    function resetBet() external onlyOwner {\n', '        hashNext = block.number + 3;\n', '        hashBetSum = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Move funds to cold storage\n', '     * @dev investBalance and walletBalance is protected from withdraw by owner\n', '     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\n', '     * @param _amount The amount of wei to move to cold storage\n', '     */\n', '    function coldStore(uint _amount) external onlyOwner {\n', '        houseKeeping();\n', '        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n', '        if(investBalance >= investBalanceGot / 2){ // additional jackpot protection\n', '            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n', '        }\n', '        msg.sender.transfer(_amount);\n', '        coldStoreLast = block.number;\n', '    }\n', '\n', '    /**\n', '     * @dev Move funds to contract jackpot\n', '     */\n', '    function hotStore() payable external {\n', '        walletBalance += msg.value;\n', '        wallets[msg.sender].balance += uint208(msg.value);\n', '        houseKeeping();\n', '    }\n', '\n', '/* housekeeping functions */\n', '\n', '    /**\n', '     * @dev Update accounting\n', '     */\n', '    function houseKeeping() public {\n', '        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\n', '            investStart = 0; // start dividend payments\n', '        }\n', '        else {\n', '            if(hashFirst > 0){\n', '\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n', '                if(period > dividends.length - 2) {\n', '                    dividends.push(0);\n', '                }\n', '                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n', '                    dividendPeriod++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '/* payments */\n', '\n', '    /**\n', '     * @dev Pay balance from wallet\n', '     */\n', '    function payWallet() public {\n', '        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n', '            uint balance = wallets[msg.sender].balance;\n', '            wallets[msg.sender].balance = 0;\n', '            walletBalance -= balance;\n', '            pay(balance);\n', '        }\n', '    }\n', '\n', '    function pay(uint _amount) private {\n', '        uint maxpay = this.balance / 2;\n', '        if(maxpay >= _amount) {\n', '            msg.sender.transfer(_amount);\n', '            if(_amount > 1 finney) {\n', '                houseKeeping();\n', '            }\n', '        }\n', '        else {\n', '            uint keepbalance = _amount - maxpay;\n', '            walletBalance += keepbalance;\n', '            wallets[msg.sender].balance += uint208(keepbalance);\n', '            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n', '            msg.sender.transfer(maxpay);\n', '        }\n', '    }\n', '\n', '/* investment functions */\n', '\n', '    /**\n', '     * @dev Buy tokens\n', '     */\n', '    function investDirect() payable external {\n', '        invest(owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy tokens with affiliate partner\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function invest(address _partner) payable public {\n', '        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n', '        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n', '        uint investing = msg.value;\n', '        if(investing > investBalanceMax - investBalance) {\n', '            investing = investBalanceMax - investBalance;\n', '            investBalance = investBalanceMax;\n', '            investBalanceGot = investBalanceMax;\n', '            investStart = 0; // close investment round\n', '            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\n', '        }\n', '        else{\n', '            investBalance += investing;\n', '            investBalanceGot += investing;\n', '        }\n', '        if(_partner == address(0) || _partner == owner){\n', '            walletBalance += investing / 10;\n', '            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\n', '        else{\n', '            walletBalance += (investing * 5 / 100) * 2;\n', '            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\n', '            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\n', '        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\n', '        uint senderBalance = investing / 10**15;\n', '        uint ownerBalance = investing * 16 / 10**17  ;\n', '        uint animatorBalance = investing * 10 / 10**17  ;\n', '        balances[msg.sender] += senderBalance;\n', '        balances[owner] += ownerBalance ; // 13% of shares go to developers\n', '        balances[animator] += animatorBalance ; // 8% of shares go to animator\n', '        totalSupply += senderBalance + ownerBalance + animatorBalance;\n', '        Transfer(address(0),msg.sender,senderBalance); // for etherscan\n', '        Transfer(address(0),owner,ownerBalance); // for etherscan\n', '        Transfer(address(0),animator,animatorBalance); // for etherscan\n', '        LogInvestment(msg.sender,_partner,investing);\n', '    }\n', '\n', '    /**\n', '     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\n', '     */\n', '    function disinvest() external {\n', '        require(investStart == 0);\n', '        commitDividend(msg.sender);\n', '        uint initialInvestment = balances[msg.sender] * 10**15;\n', '        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\n', '        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\n', '        investBalance -= initialInvestment;\n', '        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n', '        payWallet();\n', '    }\n', '\n', '    /**\n', '     * @dev Pay unpaid dividends\n', '     */\n', '    function payDividends() external {\n', '        require(investStart == 0);\n', '        commitDividend(msg.sender);\n', '        payWallet();\n', '    }\n', '\n', '    /**\n', '     * @dev Commit remaining dividends before transfer of tokens\n', '     */\n', '    function commitDividend(address _who) internal {\n', '        uint last = wallets[_who].lastDividendPeriod;\n', '        if((balances[_who]==0) || (last==0)){\n', '            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n', '            return;\n', '        }\n', '        if(last==dividendPeriod) {\n', '            return;\n', '        }\n', '        uint share = balances[_who] * 0xffffffff / totalSupply;\n', '        uint balance = 0;\n', '        for(;last<dividendPeriod;last++) {\n', '            balance += share * dividends[last];\n', '        }\n', '        balance = (balance / 0xffffffff);\n', '        walletBalance += balance;\n', '        wallets[_who].balance += uint208(balance);\n', '        wallets[_who].lastDividendPeriod = uint16(last);\n', '        LogDividend(_who,balance,last);\n', '    }\n', '\n', '/* lottery functions */\n', '\n', '    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\n', '        uint24 bethash = uint24(_player.betHash);\n', '        uint24 hit = bethash ^ _hash;\n', '        uint24 matches =\n', '            ((hit & 0xF) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n', '            ((hit & 0xF00000) == 0 ? 1 : 0 );\n', '        if(matches == 6){\n', '            return(uint(_player.value) * 7000000);\n', '        }\n', '        if(matches == 5){\n', '            return(uint(_player.value) * 20000);\n', '        }\n', '        if(matches == 4){\n', '            return(uint(_player.value) * 500);\n', '        }\n', '        if(matches == 3){\n', '            return(uint(_player.value) * 25);\n', '        }\n', '        if(matches == 2){\n', '            return(uint(_player.value) * 3);\n', '        }\n', '        return(0);\n', '    }\n', '    \n', '    /**\n', '     * @dev Check if won in lottery\n', '     */\n', '    function betOf(address _who) constant external returns (uint)  {\n', '        Bet memory player = bets[_who];\n', '        if( (player.value==0) ||\n', '            (player.blockNum<=1) ||\n', '            (block.number<player.blockNum) ||\n', '            (block.number>=player.blockNum + (10 * hashesSize))){\n', '            return(0);\n', '        }\n', '        if(block.number<player.blockNum+256){\n', '            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n', '        }\n', '        if(hashFirst>0){\n', '            uint32 hash = getHash(player.blockNum);\n', '            if(hash == 0x1000000) { // load hash failed :-(, return funds\n', '                return(uint(player.value));\n', '            }\n', '            else{\n', '                return(betPrize(player,uint24(hash)));\n', '            }\n', '\t}\n', '        return(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Check if won in lottery\n', '     */\n', '    function won() public {\n', '        Bet memory player = bets[msg.sender];\n', '        if(player.blockNum==0){ // create a new player\n', '            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '            return;\n', '        }\n', '        if((player.value==0) || (player.blockNum==1)){\n', '            payWallet();\n', '            return;\n', '        }\n', '        require(block.number>player.blockNum); // if there is an active bet, throw()\n', '        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\n', '            LogLate(msg.sender,player.blockNum,block.number);\n', '            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '            return;\n', '        }\n', '        uint prize = 0;\n', '        uint32 hash = 0;\n', '        if(block.number<player.blockNum+256){\n', '            hash = uint24(block.blockhash(player.blockNum));\n', '            prize = betPrize(player,uint24(hash));\n', '        }\n', '        else {\n', '            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n', '                hash = getHash(player.blockNum);\n', '                if(hash == 0x1000000) { // load hash failed :-(\n', '                    //prize = uint(player.value); no refunds anymore\n', '                    LogLate(msg.sender,player.blockNum,block.number);\n', '                    bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '                    return();\n', '                }\n', '                else{\n', '                    prize = betPrize(player,uint24(hash));\n', '                }\n', '\t    }\n', '            else{\n', '                LogLate(msg.sender,player.blockNum,block.number);\n', '                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '                return();\n', '            }\n', '        }\n', '        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n', '        if(prize>0) {\n', '            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n', '            if(prize > maxWin){\n', '                maxWin = prize;\n', '                LogRecordWin(msg.sender,prize);\n', '            }\n', '            pay(prize);\n', '        }\n', '        else{\n', '            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Send ether to buy tokens during ICO\n', '     * @dev or send less than 1 ether to contract to play\n', '     * @dev or send 0 to collect prize\n', '     */\n', '    function () payable external {\n', '        if(msg.value > 0){\n', '            if(investStart>1){ // during ICO payment to the contract is treated as investment\n', '                invest(owner);\n', '            }\n', '            else{ // if not ICO running payment to contract is treated as play\n', '                play();\n', '            }\n', '            return;\n', '        }\n', '        //check for dividends and other assets\n', '        if(investStart == 0 && balances[msg.sender]>0){\n', '            commitDividend(msg.sender);}\n', '        won(); // will run payWallet() if nothing else available\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery\n', '     */\n', '    function play() payable public returns (uint) {\n', '        return playSystem(uint(keccak256(msg.sender,block.number)), address(0));\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery with random numbers\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function playRandom(address _partner) payable public returns (uint) {\n', '        return playSystem(uint(keccak256(msg.sender,block.number)), _partner);\n', '    }\n', '\n', '    /**\n', '     * @dev Play in lottery with own numbers\n', '     * @param _partner Affiliate partner\n', '     */\n', '    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n', '        won(); // check if player did not win \n', '        uint24 bethash = uint24(_hash);\n', '        require(msg.value <= 1 ether && msg.value < hashBetMax);\n', '        if(msg.value > 0){\n', '            if(investStart==0) { // dividends only after investment finished\n', '                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\n', '            }\n', '            if(_partner != address(0)) {\n', '                uint fee = msg.value / 100;\n', '                walletBalance += fee;\n', '                wallets[_partner].balance += uint208(fee); // 1% for affiliates\n', '            }\n', '            if(hashNext < block.number + 3) {\n', '                hashNext = block.number + 3;\n', '                hashBetSum = msg.value;\n', '            }\n', '            else{\n', '                if(hashBetSum > hashBetMax) {\n', '                    hashNext++;\n', '                    hashBetSum = msg.value;\n', '                }\n', '                else{\n', '                    hashBetSum += msg.value;\n', '                }\n', '            }\n', '            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n', '            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n', '        }\n', '        putHashes(25); // players help collecing data, now much more than in last contract\n', '        return(hashNext);\n', '    }\n', '\n', '/* database functions */\n', '\n', '    /**\n', '     * @dev Create hash data swap space\n', '     * @param _sadd Number of hashes to add (<=256)\n', '     */\n', '    function addHashes(uint _sadd) public returns (uint) {\n', '        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n', '        uint n = hashes.length;\n', '        if(n + _sadd > hashesSize){\n', '            hashes.length = hashesSize;\n', '        }\n', '        else{\n', '            hashes.length += _sadd;\n', '        }\n', '        for(;n<hashes.length;n++){ // make sure to burn gas\n', '            hashes[n] = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        }\n', '        if(hashes.length>=hashesSize) { // assume block.number > 10\n', '            hashFirst = block.number - ( block.number % 10);\n', '            hashLast = hashFirst;\n', '        }\n', '        return(hashes.length);\n', '    }\n', '\n', '    /**\n', '     * @dev Create hash data swap space, add 128 hashes\n', '     */\n', '    function addHashes128() external returns (uint) {\n', '        return(addHashes(128));\n', '    }\n', '\n', '    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n', '        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n', '            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n', '            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n', '            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n', '            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n', '            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n', '            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n', '            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n', '            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n', '            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n', '            | ( ( uint(_delta) / hashesSize) << 240)); \n', '    }\n', '\n', '    function getHash(uint _block) constant private returns (uint32) {\n', '        uint delta = (_block - hashFirst) / 10;\n', '        uint hash = hashes[delta % hashesSize];\n', '        if(delta / hashesSize != hash >> 240) {\n', '            return(0x1000000); // load failed, incorrect data in hashes\n', '        }\n', '        uint slotp = (_block - hashFirst) % 10; \n', '        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n', '    }\n', '    \n', '    /**\n', '     * @dev Fill hash data\n', '     */\n', '    function putHash() public returns (bool) {\n', '        uint lastb = hashLast;\n', '        if(lastb == 0 || block.number <= lastb + 10) {\n', '            return(false);\n', '        }\n', '        uint blockn256;\n', '        if(block.number<256) { // useless test for testnet :-(\n', '            blockn256 = 0;\n', '        }\n', '        else{\n', '            blockn256 = block.number - 255;\n', '        }\n', '        if(lastb < blockn256) {\n', '            uint num = blockn256;\n', '            num += num % 10;\n', '            lastb = num; \n', '        }\n', '        uint delta = (lastb - hashFirst) / 10;\n', '        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n', '        hashLast = lastb + 10;\n', '        return(true);\n', '    }\n', '\n', '    /**\n', '     * @dev Fill hash data many times\n', '     * @param _num Number of iterations\n', '     */\n', '    function putHashes(uint _num) public {\n', '        uint n=0;\n', '        for(;n<_num;n++){\n', '            if(!putHash()){\n', '                return;\n', '            }\n', '        }\n', '    }\n', '    \n', '}']
