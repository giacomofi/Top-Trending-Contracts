['/* A contract to store goods with escrowed funds. */\n', '\n', '/* Deployment:\n', 'Contract:\n', 'Owner: seller\n', 'Last address: dynamic\n', 'ABI: [{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"escrows","outputs":[{"name":"buyer","type":"address"},{"name":"lockedFunds","type":"uint256"},{"name":"frozenFunds","type":"uint256"},{"name":"frozenTime","type":"uint64"},{"name":"count","type":"uint16"},{"name":"buyerNo","type":"bool"},{"name":"sellerNo","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"count","outputs":[{"name":"","type":"uint16"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"cancel","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"seller","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"freezePeriod","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"},{"name":"_count","type":"uint16"}],"name":"buy","outputs":[],"payable":true,"type":"function"},{"constant":true,"inputs":[],"name":"status","outputs":[{"name":"","type":"uint16"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"rewardPromille","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"}],"name":"getMoney","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"no","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"kill","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"reject","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"accept","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"totalEscrows","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_who","type":"address"},{"name":"_payment","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"arbYes","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"feeFunds","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_lockId","type":"uint256"},{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"yes","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"buyers","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"availableCount","outputs":[{"name":"","type":"uint16"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"price","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"contentCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"logsCount","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"unbuy","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"getFees","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"feePromille","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"pendingCount","outputs":[{"name":"","type":"uint16"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_dataInfo","type":"string"},{"name":"_version","type":"uint256"}],"name":"addDescription","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"arbiter","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"inputs":[{"name":"_arbiter","type":"address"},{"name":"_freezePeriod","type":"uint256"},{"name":"_feePromille","type":"uint256"},{"name":"_rewardPromille","type":"uint256"},{"name":"_count","type":"uint16"},{"name":"_price","type":"uint256"}],"type":"constructor"},{"payable":false,"type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"message","type":"string"}],"name":"LogDebug","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"lockId","type":"uint256"},{"indexed":false,"name":"dataInfo","type":"string"},{"indexed":true,"name":"version","type":"uint256"},{"indexed":false,"name":"eventType","type":"uint16"},{"indexed":true,"name":"sender","type":"address"},{"indexed":false,"name":"count","type":"uint256"},{"indexed":false,"name":"payment","type":"uint256"}],"name":"LogEvent","type":"event"}]\n', 'Optimized: yes\n', 'Solidity version: v0.4.4\n', '*/\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract EscrowGoods {\n', '\n', '    struct EscrowInfo {\n', '\n', '        address buyer;\n', '        uint lockedFunds;\n', '        uint frozenFunds;\n', '        uint64 frozenTime;\n', '        uint16 count;\n', '        bool buyerNo;\n', '        bool sellerNo;\n', '    }\n', '\n', '    //enum GoodsStatus\n', '    uint16 constant internal None = 0;\n', '    uint16 constant internal Available = 1;\n', '    uint16 constant internal Canceled = 2;\n', '\n', '    //enum EventTypes\n', '    uint16 constant internal Buy = 1;\n', '    uint16 constant internal Accept = 2;\n', '    uint16 constant internal Reject = 3;\n', '    uint16 constant internal Cancel = 4;\n', '    uint16 constant internal Description = 10;\n', '    uint16 constant internal Unlock = 11;\n', '    uint16 constant internal Freeze = 12;\n', '    uint16 constant internal Resolved = 13;\n', '\n', '    //data\n', '\n', '    uint constant arbitrationPeriod = 30 days;\n', '    uint constant safeGas = 25000;\n', '\n', '    //seller/owner of the goods\n', '    address public seller;\n', '\n', '    //event counters\n', '    uint public contentCount = 0;\n', '    uint public logsCount = 0;\n', '\n', '    //escrow related\n', '\n', '    address public arbiter;\n', '\n', '    uint public freezePeriod;\n', '    //each lock fee in promilles.\n', '    uint public feePromille;\n', '    //reward in promilles. promille = percent * 10, eg 1,5% reward = 15 rewardPromille\n', '    uint public rewardPromille;\n', '\n', '    uint public feeFunds;\n', '    uint public totalEscrows;\n', '\n', '    mapping (uint => EscrowInfo) public escrows;\n', '\n', '    //goods related\n', '\n', '    //status of the goods: see GoodsStatus enum\n', '    uint16 public status;\n', '    //how many for sale\n', '    uint16 public count;\n', '\n', '    uint16 public availableCount;\n', '    uint16 public pendingCount;\n', '\n', '    //price per item\n', '    uint public price;\n', '\n', '    mapping (address => bool) public buyers;\n', '\n', '    bool private atomicLock;\n', '\n', '    //events\n', '\n', '    event LogDebug(string message);\n', '    event LogEvent(uint indexed lockId, string dataInfo, uint indexed version, uint16 eventType, address indexed sender, uint count, uint payment);\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != seller)\n', '          throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyArbiter {\n', '        if (msg.sender != arbiter)\n', '          throw;\n', '        _;\n', '    }\n', '\n', '    //modules\n', '\n', '    function EscrowGoods(address _arbiter, uint _freezePeriod, uint _feePromille, uint _rewardPromille,\n', '                          uint16 _count, uint _price) {\n', '\n', '        seller = msg.sender;\n', '\n', '        // all variables are always initialized to 0, save gas\n', '\n', '        //escrow related\n', '\n', '        arbiter = _arbiter;\n', '        freezePeriod = _freezePeriod;\n', '        feePromille = _feePromille;\n', '        rewardPromille = _rewardPromille;\n', '\n', '        //goods related\n', '\n', '        status = Available;\n', '        count = _count;\n', '        price = _price;\n', '\n', '        availableCount = count;\n', '    }\n', '\n', '    //helpers for events with counter\n', '    function logDebug(string message) internal {\n', '        logsCount++;\n', '        LogDebug(message);\n', '    }\n', '\n', '    function logEvent(uint lockId, string dataInfo, uint version, uint16 eventType,\n', '                                address sender, uint count, uint payment) internal {\n', '        contentCount++;\n', '        LogEvent(lockId, dataInfo, version, eventType, sender, count, payment);\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '\n', '        //do not allow killing contract with active escrows\n', '        if(totalEscrows > 0) {\n', '            logDebug("totalEscrows > 0");\n', '            return;\n', '        }\n', '        //do not allow killing contract with unclaimed escrow fees\n', '        if(feeFunds > 0) {\n', '            logDebug("feeFunds > 0");\n', '            return;\n', '        }\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    function safeSend(address addr, uint value) internal {\n', '\n', '        if(atomicLock) throw;\n', '        atomicLock = true;\n', '        if (!(addr.call.gas(safeGas).value(value)())) {\n', '            atomicLock = false;\n', '            throw;\n', '        }\n', '        atomicLock = false;\n', '    }\n', '\n', '    //escrow API\n', '\n', '    //vote YES - immediately sends funds to the peer\n', '    function yes(uint _lockId, string _dataInfo, uint _version) {\n', '\n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        if(info.lockedFunds == 0) {\n', '            logDebug("info.lockedFunds == 0");\n', '            return;\n', '        }\n', '        if(msg.sender != info.buyer && msg.sender != seller) {\n', '            logDebug("msg.sender != info.buyer && msg.sender != seller");\n', '            return;\n', '        }\n', '\n', '        uint payment = info.lockedFunds;\n', '        if(payment > this.balance) {\n', '            //HACK: should not get here - funds cannot be unlocked in this case\n', '            logDebug("payment > this.balance");\n', '            return;\n', '        }\n', '\n', '        if(msg.sender == info.buyer) {\n', '\n', '            //send funds to seller\n', '            safeSend(seller, payment);\n', '        } else if(msg.sender == seller) {\n', '\n', '            //send funds to buyer\n', '            safeSend(info.buyer, payment);\n', '        } else {\n', '            //HACK: should not get here\n', '            logDebug("unknown msg.sender");\n', '            return;\n', '        }\n', '\n', '        //remove record from escrows\n', '        if(totalEscrows > 0) totalEscrows -= 1;\n', '        info.lockedFunds = 0;\n', '\n', '        logEvent(_lockId, _dataInfo, _version, Unlock, msg.sender, info.count, payment);\n', '    }\n', '\n', '    //vote NO - freeze funds for arbitration\n', '    function no(uint _lockId, string _dataInfo, uint _version) {\n', '\n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        if(info.lockedFunds == 0) {\n', '            logDebug("info.lockedFunds == 0");\n', '            return;\n', '        }\n', '        if(msg.sender != info.buyer && msg.sender != seller) {\n', '            logDebug("msg.sender != info.buyer && msg.sender != seller");\n', '            return;\n', '        }\n', '\n', '        //freeze funds\n', '        //only allow one time freeze\n', '        if(info.frozenFunds == 0) {\n', '            info.frozenFunds = info.lockedFunds;\n', '            info.frozenTime = uint64(now);\n', '        }\n', '\n', '        if(msg.sender == info.buyer) {\n', '            info.buyerNo = true;\n', '        }\n', '        else if(msg.sender == seller) {\n', '            info.sellerNo = true;\n', '        } else {\n', '            //HACK: should not get here\n', '            logDebug("unknown msg.sender");\n', '            return;\n', '        }\n', '\n', '        logEvent(_lockId, _dataInfo, _version, Freeze, msg.sender, info.count, info.lockedFunds);\n', '    }\n', '\n', '    //arbiter&#39;s decision on the case.\n', '    //arbiter can only decide when both buyer and seller voted NO\n', '    //arbiter decides on his own reward but not bigger than announced percentage (rewardPromille)\n', '    function arbYes(uint _lockId, address _who, uint _payment, string _dataInfo, uint _version) onlyArbiter {\n', '\n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        if(info.lockedFunds == 0) {\n', '            logDebug("info.lockedFunds == 0");\n', '            return;\n', '        }\n', '        if(info.frozenFunds == 0) {\n', '            logDebug("info.frozenFunds == 0");\n', '            return;\n', '        }\n', '\n', '        if(_who != seller && _who != info.buyer) {\n', '            logDebug("_who != seller && _who != info.buyer");\n', '            return;\n', '        }\n', '        //requires both NO to arbitration\n', '        if(!info.buyerNo || !info.sellerNo) {\n', '            logDebug("!info.buyerNo || !info.sellerNo");\n', '            return;\n', '        }\n', '\n', '        if(_payment > info.lockedFunds) {\n', '            logDebug("_payment > info.lockedFunds");\n', '            return;\n', '        }\n', '        if(_payment > this.balance) {\n', '            //HACK: should not get here - funds cannot be unlocked in this case\n', '            logDebug("_payment > this.balance");\n', '            return;\n', '        }\n', '\n', '        //limit payment\n', '        uint reward = (info.lockedFunds * rewardPromille) / 1000;\n', '        if(reward > (info.lockedFunds - _payment)) {\n', '            logDebug("reward > (info.lockedFunds - _payment)");\n', '            return;\n', '        }\n', '\n', '        //send funds to the winner\n', '        safeSend(_who, _payment);\n', '\n', '        //send the rest as reward\n', '        info.lockedFunds -= _payment;\n', '        feeFunds += info.lockedFunds;\n', '        info.lockedFunds = 0;\n', '\n', '        logEvent(_lockId, _dataInfo, _version, Resolved, msg.sender, info.count, _payment);\n', '    }\n', '\n', '    //allow arbiter to get his collected fees\n', '    function getFees() onlyArbiter {\n', '\n', '        if(feeFunds > this.balance) {\n', '            //HACK: should not get here - funds cannot be unlocked in this case\n', '            logDebug("feeFunds > this.balance");\n', '            return;\n', '        }\n', '        \n', '        safeSend(arbiter, feeFunds);\n', '\n', '        feeFunds = 0;\n', '    }\n', '\n', '    //allow buyer or seller to take timeouted funds.\n', '    //buyer can get funds if seller is silent and seller can get funds if buyer is silent (after freezePeriod)\n', '    //buyer can get back funds under arbitration if arbiter is silent (after arbitrationPeriod)\n', '    function getMoney(uint _lockId) {\n', '\n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        if(info.lockedFunds == 0) {\n', '            logDebug("info.lockedFunds == 0");\n', '            return;\n', '        }\n', '        //HACK: this check is necessary since frozenTime == 0 at escrow creation\n', '        if(info.frozenFunds == 0) {\n', '            logDebug("info.frozenFunds == 0");\n', '            return;\n', '        }\n', '\n', '        //timout for voting not over yet\n', '        if(now < (info.frozenTime + freezePeriod)) {\n', '            logDebug("now < (info.frozenTime + freezePeriod)");\n', '            return;\n', '        }\n', '\n', '        uint payment = info.lockedFunds;\n', '        if(payment > this.balance) {\n', '            //HACK: should not get here - funds cannot be unlocked in this case\n', '            logDebug("payment > this.balance");\n', '            return;\n', '        }\n', '\n', '        //both has voted - money is under arbitration\n', '        if(info.buyerNo && info.sellerNo) {\n', '\n', '            //arbitration timeout is not over yet\n', '            if(now < (info.frozenTime + freezePeriod + arbitrationPeriod)) {\n', '                logDebug("now < (info.frozenTime + freezePeriod + arbitrationPeriod)");\n', '                return;\n', '            }\n', '\n', '            //arbiter was silent so redeem the funds to the buyer\n', '            safeSend(info.buyer, payment);\n', '\n', '            info.lockedFunds = 0;\n', '            return;\n', '        }\n', '\n', '        if(info.buyerNo) {\n', '\n', '            safeSend(info.buyer, payment);\n', '\n', '            info.lockedFunds = 0;\n', '            return;\n', '        }\n', '        if(info.sellerNo) {\n', '\n', '            safeSend(seller, payment);\n', '\n', '            info.lockedFunds = 0;\n', '            return;\n', '        }\n', '    }\n', '\n', '    //goods API\n', '\n', '    //add new description to the goods\n', '    function addDescription(string _dataInfo, uint _version) onlyOwner {\n', '\n', '        //Accept order to event log\n', '        logEvent(0, _dataInfo, _version, Description, msg.sender, 0, 0);\n', '    }\n', '\n', '    //buy with escrow. id - escrow info id\n', '    function buy(uint _lockId, string _dataInfo, uint _version, uint16 _count) payable {\n', '\n', '        //reject money transfers for bad item status\n', '\n', '        if(status != Available) throw;\n', '        if(msg.value < (price * _count)) throw;\n', '        if(_count > availableCount) throw;\n', '        if(_count == 0) throw;\n', '        if(feePromille > 1000) throw;\n', '        if(rewardPromille > 1000) throw;\n', '        if((feePromille + rewardPromille) > 1000) throw;\n', '\n', '        //create default EscrowInfo struct or access existing\n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        //lock only once for a given id\n', '        if(info.lockedFunds > 0) throw;\n', '\n', '        //lock funds\n', '\n', '        uint fee = (msg.value * feePromille) / 1000;\n', '        //limit fees\n', '        if(fee > msg.value) throw;\n', '\n', '        uint funds = (msg.value - fee);\n', '        feeFunds += fee;\n', '        totalEscrows += 1;\n', '\n', '        info.buyer = msg.sender;\n', '        info.lockedFunds = funds;\n', '        info.frozenFunds = 0;\n', '        info.buyerNo = false;\n', '        info.sellerNo = false;\n', '        info.count = _count;\n', '\n', '        pendingCount += _count;\n', '        buyers[msg.sender] = true;\n', '\n', '        //Buy order to event log\n', '        logEvent(_lockId, _dataInfo, _version, Buy, msg.sender, _count, msg.value);\n', '    }\n', '\n', '    function accept(uint _lockId, string _dataInfo, uint _version) onlyOwner {\n', '\n', '        EscrowInfo info = escrows[_lockId];\n', '        \n', '        if(info.count > availableCount) {\n', '            logDebug("info.count > availableCount");\n', '            return;\n', '        }\n', '        if(info.count > pendingCount) {\n', '            logDebug("info.count > pendingCount");\n', '            return;\n', '        }\n', '\n', '        pendingCount -= info.count;\n', '        availableCount -= info.count;\n', '\n', '        //Accept order to event log\n', '        logEvent(_lockId, _dataInfo, _version, Accept, msg.sender, info.count, info.lockedFunds);\n', '    }\n', '\n', '    function reject(uint _lockId, string _dataInfo, uint _version) onlyOwner {\n', '        \n', '        EscrowInfo info = escrows[_lockId];\n', '\n', '        if(info.count > pendingCount) {\n', '            logDebug("info.count > pendingCount");\n', '            return;\n', '        }\n', '\n', '        pendingCount -= info.count;\n', '\n', '        //send money back\n', '        yes(_lockId, _dataInfo, _version);\n', '\n', '        //Reject order to event log\n', '        //HACK: "yes" call above may fail and this event will be non-relevant. Do not rely on it.\n', '        logEvent(_lockId, _dataInfo, _version, Reject, msg.sender, info.count, info.lockedFunds);\n', '    }\n', '\n', '    function cancel(string _dataInfo, uint _version) onlyOwner {\n', '\n', '        //Canceled status\n', '        status = Canceled;\n', '\n', '        //Cancel order to event log\n', '        logEvent(0, _dataInfo, _version, Cancel, msg.sender, availableCount, 0);\n', '    }\n', '\n', '    //remove buyer from the watchlist\n', '    function unbuy() {\n', '\n', '        buyers[msg.sender] = false;\n', '    }\n', '\n', '    function () {\n', '        throw;\n', '    }\n', '}']