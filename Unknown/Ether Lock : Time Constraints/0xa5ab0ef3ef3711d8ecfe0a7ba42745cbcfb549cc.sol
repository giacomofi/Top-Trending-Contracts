['/*************************************************************************\n', ' * This contract has been merged with solidify\n', ' * https://github.com/tiesnetwork/solidify\n', ' *************************************************************************/\n', ' \n', ' pragma solidity ^0.4.10;\n', '\n', '/*************************************************************************\n', ' * import "./ITokenPool.sol" : start\n', ' *************************************************************************/\n', '\n', '/*************************************************************************\n', ' * import "./ERC20StandardToken.sol" : start\n', ' *************************************************************************/\n', '\n', '/*************************************************************************\n', ' * import "./IERC20Token.sol" : start\n', ' *************************************************************************/\n', '\n', '/**@dev ERC20 compliant token interface. \n', 'https://theethereum.wiki/w/index.php/ERC20_Token_Standard \n', 'https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\n', 'contract IERC20Token {\n', '\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n", '    function name() public constant returns (string _name) { _name; }\n', '    function symbol() public constant returns (string _symbol) { _symbol; }\n', '    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n', '    \n', '    function totalSupply() constant returns (uint total) {total;}\n', '    function balanceOf(address _owner) constant returns (uint balance) {_owner; balance;}    \n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {_owner; _spender; remaining;}\n', '\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    \n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '/*************************************************************************\n', ' * import "./IERC20Token.sol" : end\n', ' *************************************************************************/\n', '/*************************************************************************\n', ' * import "../common/SafeMath.sol" : start\n', ' *************************************************************************/\n', '\n', '/**dev Utility methods for overflow-proof arithmetic operations \n', '*/\n', 'contract SafeMath {\n', '\n', '    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n', '    function safeAdd(uint256 a, uint256 b) internal returns (uint256) {        \n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n', '    function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '\n', '    function safeDiv(uint256 x, uint256 y) internal returns (uint256) {\n', '        assert(y != 0);\n', '        return x / y;\n', '    }\n', '}/*************************************************************************\n', ' * import "../common/SafeMath.sol" : end\n', ' *************************************************************************/\n', '\n', '/**@dev Standard ERC20 compliant token implementation */\n', 'contract ERC20StandardToken is IERC20Token, SafeMath {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    //tokens already issued\n', '    uint256 tokensIssued;\n', '    //balances for each account\n', '    mapping (address => uint256) balances;\n', '    //one account approves the transfer of an amount to another account\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function ERC20StandardToken() {\n', '     \n', '    }    \n', '\n', '    //\n', '    //IERC20Token implementation\n', '    // \n', '\n', '    function totalSupply() constant returns (uint total) {\n', '        total = tokensIssued;\n', '    }\n', ' \n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        require(_to != address(0));\n', '\n', '        // safeSub inside doTransfer will throw if there is not enough balance.\n', '        doTransfer(msg.sender, _to, _value);        \n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '        require(_to != address(0));\n', '        \n', '        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n', '        // safeSub inside doTransfer will throw if there is not enough balance.\n', '        doTransfer(_from, _to, _value);        \n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        remaining = allowed[_owner][_spender];\n', '    }    \n', '\n', '    //\n', '    // Additional functions\n', '    //\n', '    /**@dev Gets real token amount in the smallest token units */\n', '    function getRealTokenAmount(uint256 tokens) constant returns (uint256) {\n', '        return tokens * (uint256(10) ** decimals);\n', '    }\n', '\n', '    //\n', '    // Internal functions\n', '    //    \n', '    \n', '    function doTransfer(address _from, address _to, uint256 _value) internal {\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '    }\n', '}/*************************************************************************\n', ' * import "./ERC20StandardToken.sol" : end\n', ' *************************************************************************/\n', '\n', '/**@dev Token pool that manages its tokens by designating trustees */\n', 'contract ITokenPool {    \n', '\n', '    /**@dev Token to be managed */\n', '    ERC20StandardToken public token;\n', '\n', '    /**@dev Changes trustee state */\n', '    function setTrustee(address trustee, bool state);\n', '\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    /**@dev Returns remaining token amount */\n', '    function getTokenAmount() constant returns (uint256 tokens) {tokens;}\n', '}/*************************************************************************\n', ' * import "./ITokenPool.sol" : end\n', ' *************************************************************************/\n', '/*************************************************************************\n', ' * import "../common/Manageable.sol" : start\n', ' *************************************************************************/\n', '\n', '/*************************************************************************\n', ' * import "../common/Owned.sol" : start\n', ' *************************************************************************/\n', '\n', '\n', 'contract Owned {\n', '    address public owner;        \n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**@dev allows transferring the contract ownership. */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '/*************************************************************************\n', ' * import "../common/Owned.sol" : end\n', ' *************************************************************************/\n', '\n', '///A token that have an owner and a list of managers that can perform some operations\n', '///Owner is always a manager too\n', 'contract Manageable is Owned {\n', '\n', '    event ManagerSet(address manager, bool state);\n', '\n', '    mapping (address => bool) public managers;\n', '\n', '    function Manageable() Owned() {\n', '        managers[owner] = true;\n', '    }\n', '\n', '    /**@dev Allows execution by managers only */\n', '    modifier managerOnly {\n', '        assert(managers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        super.transferOwnership(_newOwner);\n', '\n', '        managers[_newOwner] = true;\n', '        managers[msg.sender] = false;\n', '    }\n', '\n', '    function setManager(address manager, bool state) ownerOnly {\n', '        managers[manager] = state;\n', '        ManagerSet(manager, state);\n', '    }\n', '}/*************************************************************************\n', ' * import "../common/Manageable.sol" : end\n', ' *************************************************************************/\n', '\n', '/**@dev Token pool that manages its tokens by designating trustees */\n', 'contract TokenPool is Manageable, ITokenPool {    \n', '\n', '    function TokenPool(ERC20StandardToken _token) {\n', '        token = _token;\n', '    }\n', '\n', '    /**@dev ITokenPool override */\n', '    function setTrustee(address trustee, bool state) managerOnly {\n', '        if (state) {\n', '            token.approve(trustee, token.balanceOf(this));\n', '        } else {\n', '            token.approve(trustee, 0);\n', '        }\n', '    }\n', '\n', '    /**@dev ITokenPool override */\n', '    function getTokenAmount() constant returns (uint256 tokens) {\n', '        tokens = token.balanceOf(this);\n', '    }\n', '\n', '    /**@dev Returns all tokens back to owner */\n', '    function returnTokensTo(address to) managerOnly {\n', '        token.transfer(to, token.balanceOf(this));\n', '    }\n', '}']