['pragma solidity ^0.4.10;\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract SMEToken is StandardToken {\n', '\n', '    struct Funder{\n', '        address addr;\n', '        uint amount;\n', '    }\n', '\t\n', '    Funder[] funder_list;\n', '\t\n', '    // metadata\n', '\tuint256 public constant DURATION = 30 days; \n', '    string public constant name = "SMET";\n', '    string public constant symbol = "SMET";\n', '    uint256 public constant decimals = 0;\n', '    string public version = "1.0";\n', '\t\n', "\taddress account1 = '0xcD4fC8e4DA5B25885c7d80b6C846afb6b170B49b';  //50%   Use Cases and Business Applications\n", "\taddress account2 = '0x005CD1194C1F088d9bd8BF9e70e5e44D2194C029';  //24%   Blockchain Technology\n", "    address account3 = '0x00d0ACA6D3D07B3546Fc76E60a90ccdccC7c0e0C';  //6%    Mobile APP,SDK Technology\n", "\taddress account4 = '0x5CA7F20427e4D202777Ea8006dc8f614a289Be2F';  //10%   Mobile Internet Technology\n", "\taddress account5 = '0x7d49c6a86FDE3dE9c47544c58b7b0F035197415b';  //10%   Marketing\n", '\n', '\n', '    uint256 val1 = 1 wei;    // 1\n', '    uint256 val2 = 1 szabo;  // 1 * 10 ** 12\n', '    uint256 val3 = 1 finney; // 1 * 10 ** 15\n', '    uint256 val4 = 1 ether;  // 1 * 10 ** 18\n', '\t\n', '\taddress public creator;\n', '\tuint256 public sellPrice;\n', '\tuint256 public totalSupply;\n', '\tuint256 public startTime = 0;   // unix timestamp seconds\n', '\tuint256 public endTime = 0;     // unix timestamp seconds\n', '\t\n', '    uint256 public constant tokenExchangeRate = 1000; // 1000 SME tokens per 1 ETH\n', '\n', '    function setPrices(uint256 newSellPrice) {\n', '        if (msg.sender != creator) throw;\n', '        sellPrice = newSellPrice;\n', '    }\n', '\t\n', '\tfunction issue(uint256 amount) {\n', '\t    if (msg.sender != creator) throw;\n', '\t\ttotalSupply += amount;\n', '\t}\n', '\t\n', '\tfunction burn(uint256 amount) {\n', '\t    if (msg.sender != creator) throw;\n', '\t\ttotalSupply -= amount;\n', '\t}\n', '\t\n', '\tfunction getBalance() returns (uint) {\n', '        return this.balance;\n', '    } \n', '\t\n', '\tfunction getFunder(uint index) public constant returns(address, uint) {\n', '        Funder f = funder_list[index];\n', '        \n', '        return (\n', '            f.addr,\n', '            f.amount\n', '        ); \n', '    }\n', '\n', '    // constructor\n', '    function SMEToken(\n', '\t    uint256 initialSupply,\n', '        uint256 initialPrice,\n', '\t\tuint256 initialStartTime\n', '\t\t) {\n', '\t    creator = msg.sender;\n', '\t\ttotalSupply = initialSupply;\n', '\t\tbalances[msg.sender] = initialSupply;\n', '\t\tsellPrice = initialPrice;\n', '\t\tstartTime = initialStartTime;\n', '\t\tendTime = initialStartTime + DURATION;\n', '    }\n', '\n', '    /// @dev Accepts ether and creates new SME tokens.\n', '    function createTokens() payable {\n', '\t    if (now < startTime) throw;\n', '\t\tif (now > endTime) throw;\n', '\t    if (msg.value < val4) throw;\n', '\t\tif (msg.value % val4 != 0) throw;\n', '\t\tvar new_funder = Funder({addr: msg.sender, amount: msg.value / val4});\n', '\t\tfunder_list.push(new_funder);\n', '\t\t\n', '\t    uint256 smecAmount = msg.value / sellPrice;\n', '        if (totalSupply < smecAmount) throw;\n', '        if (balances[msg.sender] + smecAmount < balances[msg.sender]) throw; \n', '        totalSupply -= smecAmount;                     \n', '        balances[msg.sender] += smecAmount;\n', '\t\t\n', '        if(!account1.send(msg.value*50/100)) throw;\n', '\t\tif(!account2.send(msg.value*24/100)) throw;\n', '\t\tif(!account3.send(msg.value*6/100)) throw;\n', '\t\tif(!account4.send(msg.value*10/100)) throw;\n', '\t\tif(!account5.send(msg.value*10/100)) throw;\n', '    }\n', '\t\n', '\t// fallback\n', '    function() payable {\n', '        createTokens();\n', '    }\n', '\n', '}']