['contract ElcoinDb {\n', '    address owner;\n', '    address caller;\n', '\n', '    event Transaction(bytes32 indexed hash, address indexed from, address indexed to, uint time, uint amount);\n', '\n', '    modifier checkOwner() { if(msg.sender == owner) { _ } else { return; } }\n', '    modifier checkCaller() { if(msg.sender == caller) { _ } else { return; } }\n', '    mapping (address => uint) public balances;\n', '\n', '    function ElcoinDb(address pCaller) {\n', '        owner = msg.sender;\n', '        caller = pCaller;\n', '    }\n', '\n', '    function getOwner() constant returns (address rv) {\n', '        return owner;\n', '    }\n', '\n', '    function getCaller() constant returns (address rv) {\n', '        return caller;\n', '    }\n', '\n', '    function setCaller(address pCaller) checkOwner() returns (bool _success) {\n', '        caller = pCaller;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setOwner(address pOwner) checkOwner() returns (bool _success) {\n', '        owner = pOwner;\n', '\n', '        return true;\n', '    }\n', '\n', '    function getBalance(address addr) constant returns(uint balance) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function deposit(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n', '        balances[addr] += amount;\n', '        Transaction(hash,0 , addr, time, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n', '        uint oldBalance = balances[addr];\n', '        if(oldBalance >= amount) {\n', '            msg.sender.send(amount);\n', '            balances[addr] = oldBalance - amount;\n', '            Transaction(hash, addr, 0, time, amount);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '}']