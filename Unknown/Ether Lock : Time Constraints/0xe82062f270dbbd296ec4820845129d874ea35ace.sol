['pragma solidity ^0.4.10;\n', '\n', 'contract ERC20 {\n', '  function balanceOf(address owner) constant returns (uint balance);\n', '  function transfer(address to, uint value) returns (bool success);\n', '}\n', '\n', 'contract TokenPool {\n', '  string public name;\n', '  uint public fundingLimit;\n', '  uint public rewardPercentage;\n', '  uint public amountRaised;\n', '  uint public tokensCreated;\n', '  ERC20 public tokenContract;\n', '  address public tokenCreateContract;\n', '  string public tokenCreateFunction;\n', '  mapping (address => uint) funders;\n', '  address public tokenCreator;\n', '  bytes4 tokenCreateFunctionHash;\n', '\n', '  function TokenPool(\n', '    TokenPoolList list,\n', '    string _name,\n', '    uint _fundingLimit,\n', '    uint _rewardPercentage,\n', '    ERC20 _tokenContract,\n', '    address _tokenCreateContract,\n', '    string _tokenCreateFunction)\n', '  {\n', '    list.add(this);\n', '    name = _name;\n', '    fundingLimit = _fundingLimit;\n', '    rewardPercentage = _rewardPercentage;\n', '    tokenContract = _tokenContract;\n', '    tokenCreateContract = _tokenCreateContract;\n', '    tokenCreateFunction = _tokenCreateFunction;\n', '    tokenCreateFunctionHash = bytes4(sha3(tokenCreateFunction));\n', '  }\n', '\n', '  function Fund() payable {\n', '    if (tokensCreated > 0) throw;\n', '    uint amount = msg.value;\n', '    amountRaised += amount;\n', '    if (amountRaised > fundingLimit) throw;\n', '    funders[msg.sender] += amount;\n', '  }\n', '\n', '  function() payable {\n', '    Fund();\n', '  }\n', '\n', '  function Withdraw() {\n', '    if (tokensCreated > 0) return;\n', '    uint amount = funders[msg.sender];\n', '    if (amount == 0) return;\n', '    funders[msg.sender] -= amount;\n', '    amountRaised -= amount;\n', '    if (!msg.sender.send(amount)) {\n', '      funders[msg.sender] += amount;\n', '      amountRaised += amount;\n', '    }\n', '  }\n', '\n', '  function CreateTokens() {\n', '    if (tokensCreated > 0) return;\n', '    uint amount = amountRaised * (100 - rewardPercentage) / 100;\n', '    if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n', '    tokensCreated = tokenContract.balanceOf(this);\n', '    tokenCreator = msg.sender;\n', '  }\n', '\n', '  function ClaimTokens() {\n', '    if (tokensCreated == 0) return;\n', '    uint amount = funders[msg.sender];\n', '    if (amount == 0) return;\n', '    uint tokens = tokensCreated * amount / amountRaised;\n', '    funders[msg.sender] = 0;\n', '    if (!tokenContract.transfer(msg.sender, tokens)) {\n', '      funders[msg.sender] = amount;\n', '    }\n', '  }\n', '\n', '  function ClaimReward() {\n', '    if (msg.sender != tokenCreator) return;\n', '    uint amount = amountRaised * (100 - rewardPercentage) / 100;\n', '    uint reward = amountRaised - amount;\n', '    if (msg.sender.send(reward)) {\n', '      tokenCreator = 0;\n', '    }\n', '  }\n', '\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract TokenPoolList {\n', '  address[] public list;\n', '\n', '  event Added(address x);\n', '\n', '  function add(address x) {\n', '    list.push(x);\n', '    Added(x);\n', '  }\n', '\n', '  function getCount() public constant returns(uint) {\n', '    return list.length;\n', '  }\n', '\n', '  function getAddress(uint index) public constant returns(address) {\n', '    return list[index];\n', '  }\n', '}']