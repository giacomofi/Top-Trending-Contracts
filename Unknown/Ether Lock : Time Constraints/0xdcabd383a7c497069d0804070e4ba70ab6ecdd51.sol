['contract BlockChainEnterprise {\n', '    \n', '        uint private BlockBalance = 0; //block balance (0 to BlockSize eth)\n', '        uint private NumberOfBlockMined = 0; \n', '        uint private BlockReward = 0;\n', '        uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH\n', '        uint private MaxDeposit = 5 ether;\n', '        uint private multiplier = 1200; // Multiplier\n', '        \n', '        \n', '        uint private fees = 0;      //Fees are just verly low : 1% !\n', '        uint private feeFrac = 5;  //Fraction for fees in "thousandth" --> only 0.5% !!\n', '        uint private RewardFrac = 30;  //Fraction for Reward in "thousandth"\n', '        \n', '        \n', '        uint private Payout_id = 0;\n', '        \n', '        address private admin;\n', '        \n', '        function BlockChainEnterprise() {\n', '            admin = msg.sender;\n', '        }\n', '\n', '        modifier onlyowner {if (msg.sender == admin) _  }\n', '\n', '        struct Miner {\n', '            address addr;\n', '            uint payout;\n', '            bool paid;\n', '        }\n', '\n', '        Miner[] private miners;\n', '\n', '        //--Fallback function\n', '        function() {\n', '            init();\n', '        }\n', '\n', '        //--initiated function\n', '        function init() private {\n', '            uint256 new_deposit=msg.value;\n', '            //------ Verifications on this new deposit ------\n', '            if (new_deposit < 100 finney) { //only >0.1 eth participation accepted\n', '                    msg.sender.send(new_deposit);\n', '                    return;\n', '            }\n', '            \n', '            if( new_deposit > MaxDeposit ){\n', '                msg.sender.send( msg.value - MaxDeposit );\n', '                new_deposit= MaxDeposit;\n', '            }\n', '            //-- enter the block ! --\n', '            Participate(new_deposit);\n', '        }\n', '\n', '        function Participate(uint deposit) private {\n', '            \n', '            if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks\n', '                uint256 fragment = BlockSize - BlockBalance;\n', '                miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block\n', '                miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one\n', '            }\n', '            else{\n', '                miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !\n', '            }\n', '                \n', '            //--- UPDATING CONTRACT STATS ----\n', '            BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !\n', '            fees += (deposit * feeFrac) / 1000;          // collect small fee\n', '            BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance\n', '\n', '            \n', '            //Mine the block first if possible !\n', '            if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !\n', '                PayMiners();\n', '                PayWinnerMiner(msg.sender,deposit);\n', '            }\n', '        }\n', '\n', '\n', '        function PayMiners() private{\n', '            NumberOfBlockMined +=1;\n', '            //Classic payout of all participants of the block\n', '            while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {\n', '                miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !\n', '                \n', '                BlockBalance -= miners[Payout_id].payout; //update the balance\n', '                miners[Payout_id].paid=true;\n', '                \n', '                Payout_id += 1;\n', '            }\n', '        }\n', '        \n', '        function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !\n', '            //Globally, EVERYONE CAN WIN by being smart and quick.\n', '            if(deposit >= 1 ether){ //only 1 ether, and you get it all !\n', '                winner.send(BlockReward);\n', '                BlockReward =0;\n', '            }\n', '            else{ // deposit is between 0.1 and 0.99 ether\n', '                uint256 pcent = deposit / 10 finney;\n', '                winner.send(BlockReward*pcent/100);\n', '                BlockReward -= BlockReward*pcent/100;\n', '            }\n', '        }\n', '    \n', '\n', '    //---Contract management functions\n', '    function ChangeOwnership(address _owner) onlyowner {\n', '        admin = _owner;\n', '    }\n', '    \n', '    \n', '    function CollectAllFees() onlyowner {\n', '        if (fees == 0) throw;\n', '        admin.send(fees);\n', '        fees = 0;\n', '    }\n', '    \n', '    function GetAndReduceFeesByFraction(uint p) onlyowner {\n', '        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.\n', '        admin.send(fees / 1000 * p);//send a percent of fees\n', '        fees -= fees / 1000 * p;\n', '    }\n', '        \n', '\n', '//---Contract informations\n', '\n', '\n', 'function WatchBalance() constant returns(uint TotalBalance, string info) {\n', '    TotalBalance = BlockBalance /  1 finney;\n', "    info ='Balance in finney';\n", '}\n', '\n', 'function WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {\n', '    BlockSizeInEther = BlockSize / 1 ether;\n', "    info ='Balance in ether';\n", '}\n', 'function WatchNextBlockReward() constant returns(uint Reward, string info) {\n', '    Reward = BlockReward / 1 finney;\n', "    info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';\n", '}\n', '\n', 'function NumberOfMiners() constant returns(uint NumberOfMiners, string info) {\n', '    NumberOfMiners = miners.length;\n', "    info ='Number of participations since the beginning of this wonderful blockchain';\n", '}\n', '\n', 'function WatchCurrentMultiplier() constant returns(uint Mult, string info) {\n', '    Mult = multiplier;\n', "    info ='Current multiplier';\n", '}\n', 'function NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {\n', '    NumberOfBlockMinedAlready = NumberOfBlockMined;\n', "    info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';\n", '}\n', 'function AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {\n', '    ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;\n', "    info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';\n", '}\n', 'function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n', '    if (id <= miners.length) {\n', '        Address = miners[id].addr;\n', '        Payout = (miners[id].payout) / 1 finney;\n', '        UserPaid=miners[id].paid;\n', '    }\n', '}\n', '\n', 'function WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {\n', '    CollectedFees = fees / 1 szabo;\n', '}\n', '\n', 'function NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {\n', '    QueueSize = miners.length - Payout_id;\n', "    info ='Number of participations in the current block.';\n", '}\n', '\n', '\n', '}']