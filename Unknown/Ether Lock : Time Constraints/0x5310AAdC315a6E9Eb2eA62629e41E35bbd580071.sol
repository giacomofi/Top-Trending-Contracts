['pragma solidity ^0.4.0;\n', '\n', ' /* \n', ' This Consulteum token contract is based on the ERC20 token contract. Additional \n', ' functionality has been integrated: \n', ' * the contract Lockable, which is used as a parent of the Token contract \n', ' * the function mintTokens(), which makes use of the currentSwapRate() and safeToAdd() helpers \n', ' * the function disableTokenSwapLock() \n', ' */ \n', ' \n', ' \n', ' contract Lockable {  \n', '     uint public creationTime;\n', '     bool public tokenSwapLock; \n', '     \n', '     address public dev;\n', ' \n', '     // This modifier should prevent tokens transfers while the tokenswap \n', '     // is still ongoing \n', '     modifier isTokenSwapOn { \n', '         if (tokenSwapLock) throw; \n', '        _;\n', '     }\n', '     \n', '  // This modifier should prevent ICO from being launched by an attacker\n', '     \n', '    modifier onlyDev{ \n', '       if (msg.sender != dev) throw; \n', '      _;\n', '   }\n', '\n', '     function Lockable() { \n', '       dev = msg.sender; \n', '     } \n', ' } \n', ' \n', '\n', ' \n', '\n', ' contract ERC20 { \n', '     function totalSupply() constant returns (uint); \n', '     function balanceOf(address who) constant returns (uint); \n', '     function allowance(address owner, address spender) constant returns (uint); \n', ' \n', '\n', '     function transfer(address to, uint value) returns (bool ok); \n', '     function transferFrom(address from, address to, uint value) returns (bool ok); \n', '     function approve(address spender, uint value) returns (bool ok); \n', ' \n', '     event Transfer(address indexed from, address indexed to, uint value); \n', '     event Approval(address indexed owner, address indexed spender, uint value); \n', ' } \n', ' \n', ' \n', ' contract Consulteth is ERC20, Lockable { \n', ' \n', '\n', '   mapping( address => uint ) _balances; \n', '   mapping( address => mapping( address => uint ) ) _approvals; \n', '   \n', '   uint public foundationAsset;\n', '   uint public CTX_Cap;\n', '   uint _supply; \n', '   \n', '   address public wallet_Mini_Address;\n', '   address public wallet_Address;\n', '   \n', '   uint public factorial_ICO;\n', '   \n', '   event TokenMint(address newTokenHolder, uint amountOfTokens); \n', '   event TokenSwapOver(); \n', ' \n', '   modifier onlyFromMiniWallet { \n', '       if (msg.sender != wallet_Mini_Address) throw;\n', '      _;\n', '   }\n', '   \n', '   modifier onlyFromWallet { \n', '       if (msg.sender != wallet_Address) throw; \n', '      _;\n', '   } \n', ' \n', '  \n', ' \n', '   function Consulteth(uint preMine, uint cap_CTX) { \n', '     _balances[msg.sender] = preMine; \n', '     foundationAsset = preMine;\n', '     CTX_Cap = cap_CTX;\n', '     \n', '     _supply += preMine;  \n', '      \n', '   } \n', ' \n', ' \n', '   function totalSupply() constant returns (uint supply) { \n', '     return _supply; \n', '   } \n', '\n', '\n', ' \n', '   function balanceOf( address who ) constant returns (uint value) { \n', '     return _balances[who]; \n', '   } \n', ' \n', ' \n', '   function allowance(address owner, address spender) constant returns (uint _allowance) { \n', '     return _approvals[owner][spender]; \n', '   } \n', ' \n', ' \n', '   // A helper to notify if overflow occurs \n', '   function safeToAdd(uint a, uint b) internal returns (bool) { \n', '     return (a + b >= a && a + b >= b); \n', '   } \n', ' \n', ' \n', '   function transfer(address to, uint value) isTokenSwapOn returns (bool ok) { \n', ' \n', ' \n', '     if( _balances[msg.sender] < value ) { \n', '         throw; \n', '     } \n', '     if( !safeToAdd(_balances[to], value) ) { \n', '         throw; \n', '     } \n', ' \n', ' \n', '     _balances[msg.sender] -= value; \n', '     _balances[to] += value; \n', '     Transfer( msg.sender, to, value ); \n', '     return true; \n', '   } \n', ' \n', ' \n', '   function transferFrom(address from, address to, uint value) isTokenSwapOn returns (bool ok) { \n', "     // if you don't have enough balance, throw \n", '     if( _balances[from] < value ) { \n', '         throw; \n', '     } \n', "     // if you don't have approval, throw \n", '     if( _approvals[from][msg.sender] < value ) { \n', '         throw; \n', '     } \n', '     if( !safeToAdd(_balances[to], value) ) { \n', '         throw; \n', '     } \n', '     // transfer and return true \n', '     _approvals[from][msg.sender] -= value; \n', '     _balances[from] -= value; \n', '     _balances[to] += value; \n', '     Transfer( from, to, value ); \n', '     return true; \n', '   } \n', ' \n', '   function approve(address spender, uint value) \n', '     isTokenSwapOn \n', '     returns (bool ok) { \n', '     _approvals[msg.sender][spender] = value; \n', '     Approval( msg.sender, spender, value ); \n', '     return true; \n', '   } \n', ' \n', ' \n', '   function kickStartMiniICO(address ico_Mini_Wallet) onlyDev  { \n', '    if (ico_Mini_Wallet == address(0x0)) throw; \n', '         // Allow setting only once \n', '    if (wallet_Mini_Address != address(0x0)) throw; \n', '         wallet_Mini_Address = ico_Mini_Wallet;\n', '         \n', '         creationTime = now; \n', '         tokenSwapLock = true;  \n', '   }\n', ' \n', '   // The function preICOSwapRate() returns the current exchange rate \n', '   // between consulteum tokens and Ether during the pre-ICO token swap period \n', '   \n', '   function preICOSwapRate() constant returns(uint) { \n', '       if (creationTime + 1 weeks > now) { \n', '           return 1000; \n', '       } \n', '       else if (creationTime + 3 weeks > now) { \n', '           return 850; \n', '       } \n', '        \n', '       else { \n', '           return 0; \n', '       } \n', '   } \n', '   \n', ' \n', '   \n', '   // The function mintMiniICOTokens is only usable by the chosen wallet \n', '   // contract to mint a number of tokens proportional to the \n', '   // amount of ether sent to the wallet contract. The function \n', '   // can only be called during the tokenswap period \n', '   \n', 'function mintMiniICOTokens(address newTokenHolder, uint etherAmount) onlyFromMiniWallet\n', '    external { \n', ' \n', ' \n', '         uint tokensAmount = preICOSwapRate() * etherAmount; \n', '         \n', '         if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; \n', '         if(!safeToAdd(_supply,tokensAmount)) throw; \n', ' \n', ' \n', '         _balances[newTokenHolder] += tokensAmount; \n', '         _supply += tokensAmount; \n', ' \n', ' \n', '         TokenMint(newTokenHolder, tokensAmount); \n', '   }\n', '   \n', '// The function disableMiniSwapLock() is called by the wallet \n', '   // contract once the token swap has reached its end conditions \n', '\n', '   function disableMiniSwapLock() onlyFromMiniWallet\n', '     external { \n', '         tokenSwapLock = false; \n', '         TokenSwapOver(); \n', '   }    \n', '  \n', '\n', '\n', 'function kickStartICO(address ico_Wallet, uint mint_Factorial) onlyDev  { \n', '    if (ico_Wallet == address(0x0)) throw; \n', '         // Allow setting only once \n', '    if (wallet_Address != address(0x0)) throw; \n', '         \n', '         wallet_Address = ico_Wallet;\n', '         factorial_ICO = mint_Factorial;\n', '         \n', '         creationTime = now; \n', '         tokenSwapLock = true;  \n', '   }\n', ' \n', '  \n', '   function ICOSwapRate() constant returns(uint) { \n', '       if (creationTime + 1 weeks > now) { \n', '           return factorial_ICO; \n', '       } \n', '       else if (creationTime + 2 weeks > now) { \n', '           return (factorial_ICO - 30); \n', '       } \n', '       else if (creationTime + 4 weeks > now) { \n', '           return (factorial_ICO - 70); \n', '       } \n', '       else { \n', '           return 0; \n', '       } \n', '   } \n', ' \n', '\n', ' \n', '   // The function mintICOTokens is only usable by the chosen wallet \n', '   // contract to mint a number of tokens proportional to the \n', '   // amount of ether sent to the wallet contract. The function \n', '   // can only be called during the tokenswap period \n', '   function mintICOTokens(address newTokenHolder, uint etherAmount) onlyFromWallet\n', '    external { \n', ' \n', ' \n', '         uint tokensAmount = ICOSwapRate() * etherAmount; \n', '\n', '         if((_supply + tokensAmount) > CTX_Cap) throw;\n', '         \n', '         if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; \n', '         if(!safeToAdd(_supply,tokensAmount)) throw; \n', ' \n', ' \n', '         _balances[newTokenHolder] += tokensAmount; \n', '         _supply += tokensAmount; \n', ' \n', ' \n', '         TokenMint(newTokenHolder, tokensAmount); \n', '   } \n', ' \n', ' \n', '   // The function disableICOSwapLock() is called by the wallet \n', '   // contract once the token swap has reached its end conditions \n', '   function disableICOSwapLock() onlyFromWallet\n', '     external { \n', '         tokenSwapLock = false; \n', '         TokenSwapOver(); \n', '   } \n', ' }']