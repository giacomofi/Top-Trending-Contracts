['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20_Transferable {\n', '    function balanceOf(address addr) public returns(uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '}\n', '\n', 'contract TimeLockedRewardFaucet {\n', '\n', '    // =========== CONFIG START =========== \n', '    address constant public MULTISIG_OWNER = 0xe18Af0dDA74fC4Ee90bCB37E45b4BD623dC6e099;\n', '    address constant public TEAM_WALLET = 0x008cdC9b89AD677CEf7F2C055efC97d3606a50Bd;\n', '\n', '    ERC20_Transferable public token = ERC20_Transferable(0x7C5A0CE9267ED19B22F8cae653F198e3E8daf098);\n', '    uint constant public LOCK_RELASE_TIME = 1502661351 + 15 minutes; //block.timestamp(4011221) == 1499846591\n', '    uint constant public WITHDRAWAL_END_TIME = LOCK_RELASE_TIME + 10 minutes;\n', '    // =========== CONFIG END ===========\n', '\n', '    address[] public team_accounts;\n', '    uint      public locked_since = 0;\n', '    uint      amount_to_distribute;\n', '\n', '    function all_team_accounts() external constant returns(address[]) {\n', '        return team_accounts;\n', '    }\n', '\n', '    function timeToUnlockDDHHMM() external constant returns(uint[3]) {\n', '        if (LOCK_RELASE_TIME > now) {\n', '            uint diff = LOCK_RELASE_TIME - now;\n', '            uint dd = diff / 1 days;\n', '            uint hh = diff % 1 days / 1 hours;\n', '            uint mm = diff % 1 hours / 1 minutes;\n', '            return [dd,hh,mm];\n', '        } else {\n', '            return [uint(0), uint(0), uint(0)];\n', '        }\n', '    }\n', '\n', '    function start() external\n', '    only(MULTISIG_OWNER)\n', '    inState(State.INIT){\n', '        locked_since = now;\n', '    }\n', '\n', '    function () payable {\n', '        msg.sender.transfer(msg.value); //pay back whole amount sent\n', '\n', '        State state = _state();\n', '        if (state==State.INIT) {\n', '            //collect addresses for payout\n', '            require(indexOf(team_accounts,msg.sender)==-1);\n', '            team_accounts.push(msg.sender);\n', '        } else if (state==State.WITHDRAWAL) {\n', '            // setup amount to distribute\n', '            if (amount_to_distribute==0) amount_to_distribute = token.balanceOf(this);\n', '            //payout processing\n', '            require(indexOf(team_accounts, msg.sender)>=0);\n', '            token.transfer(msg.sender,  amount_to_distribute / team_accounts.length);\n', '        } else if (state==State.CLOSED) {\n', '            //collect unclaimed token to team wallet\n', '            require(msg.sender == TEAM_WALLET);\n', '            var balance = token.balanceOf(this);\n', '            token.transfer(msg.sender, balance);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '\n', '    enum State {INIT, LOCKED, WITHDRAWAL, CLOSED}\n', '    string[4] labels = ["INIT", "LOCKED", "WITHDRAWAL", "CLOSED"];\n', '\n', '    function _state() internal returns(State) {\n', '        if (locked_since == 0)               return State.INIT;\n', '        else if (now < LOCK_RELASE_TIME)     return State.LOCKED;\n', '        else if (now < WITHDRAWAL_END_TIME)  return State.WITHDRAWAL;\n', '        else return State.CLOSED;\n', '    }\n', '\n', '    function state() constant public returns(string) {\n', '        return labels[uint(_state())];\n', '    }\n', '\n', '    function indexOf(address[] storage addrs, address addr) internal returns (int){\n', '         for(uint i=0; i<addrs.length; ++i) {\n', '            if (addr == addrs[i]) return int(i);\n', '        }\n', '        return -1;\n', '    }\n', '\n', "    //fails if state dosn't match\n", '    modifier inState(State s) {\n', '        if (_state() != s) revert();\n', '        _;\n', '    }\n', '\n', '    modifier only(address allowed) {\n', '        if (msg.sender != allowed) revert();\n', '        _;\n', '    }\n', '\n', '}']