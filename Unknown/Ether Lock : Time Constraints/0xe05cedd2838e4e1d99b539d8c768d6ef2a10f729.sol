['pragma solidity ^0.4.8;\n', '\n', '\n', 'contract SafeMath {\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) throw;\n', '  }\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract StandardTokenProtocol {\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transfer(address _recipient, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is StandardTokenProtocol {\n', '\n', '    modifier when_can_transfer(address _from, uint256 _value) {\n', '        if (balances[_from] >= _value) _;\n', '    }\n', '\n', '    modifier when_can_receive(address _recipient, uint256 _value) {\n', '        if (balances[_recipient] + _value > balances[_recipient]) _;\n', '    }\n', '\n', '    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\n', '        if (allowed[_from][_delegate] >= _value) _;\n', '    }\n', '\n', '    function transfer(address _recipient, uint256 _value)\n', '        when_can_transfer(msg.sender, _value)\n', '        when_can_receive(_recipient, _value)\n', '        returns (bool o_success)\n', '    {\n', '        balances[msg.sender] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(msg.sender, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _recipient, uint256 _value)\n', '        when_can_transfer(_from, _value)\n', '        when_can_receive(_recipient, _value)\n', '        when_is_allowed(_from, msg.sender, _value)\n', '        returns (bool o_success)\n', '    {\n', '        allowed[_from][msg.sender] -= _value;\n', '        balances[_from] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(_from, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool o_success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '}\n', '\n', 'contract GUPToken is StandardToken {\n', '\n', '\t//FIELDS\n', '\tstring public name = "Guppy";\n', '    string public symbol = "GUP";\n', '    uint public decimals = 3;\n', '\n', '\t//CONSTANTS\n', '\tuint public constant LOCKOUT_PERIOD = 1 years; //time after end date that illiquid GUP can be transferred\n', '\n', '\t//ASSIGNED IN INITIALIZATION\n', '\tuint public endMintingTime; //Timestamp after which no more tokens can be created\n', '\taddress public minter; //address of the account which may mint new tokens\n', '\n', "\tmapping (address => uint) public illiquidBalance; //Balance of 'Frozen funds'\n", '\n', '\t//MODIFIERS\n', '\t//Can only be called by contribution contract.\n', '\tmodifier only_minter {\n', '\t\tif (msg.sender != minter) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Can only be called if illiquid tokens may be transformed into liquid.\n', '\t// This happens when `LOCKOUT_PERIOD` of time passes after `endMintingTime`.\n', '\tmodifier when_thawable {\n', '\t\tif (now < endMintingTime + LOCKOUT_PERIOD) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Can only be called if (liquid) tokens may be transferred. Happens\n', '\t// immediately after `endMintingTime`.\n', '\tmodifier when_transferable {\n', '\t\tif (now < endMintingTime) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Can only be called if the `crowdfunder` is allowed to mint tokens. Any\n', '\t// time before `endMintingTime`.\n', '\tmodifier when_mintable {\n', '\t\tif (now >= endMintingTime) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Initialization contract assigns address of crowdfund contract and end time.\n', '\tfunction GUPToken(address _minter, uint _endMintingTime) {\n', '\t\tendMintingTime = _endMintingTime;\n', '\t\tminter = _minter;\n', '\t}\n', '\n', '\t// Create new tokens when called by the crowdfund contract.\n', '\t// Only callable before the end time.\n', '\tfunction createToken(address _recipient, uint _value)\n', '\t\twhen_mintable\n', '\t\tonly_minter\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\tbalances[_recipient] += _value;\n', '\t\ttotalSupply += _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Create an illiquidBalance which cannot be traded until end of lockout period.\n', '\t// Can only be called by crowdfund contract before the end time.\n', '\tfunction createIlliquidToken(address _recipient, uint _value)\n', '\t\twhen_mintable\n', '\t\tonly_minter\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\tilliquidBalance[_recipient] += _value;\n', '\t\ttotalSupply += _value;\n', '\t\treturn true;\n', '\t}\n', '\n', "\t// Make sender's illiquid balance liquid when called after lockout period.\n", '\tfunction makeLiquid()\n', '\t\twhen_thawable\n', '\t{\n', '\t\tbalances[msg.sender] += illiquidBalance[msg.sender];\n', '\t\tilliquidBalance[msg.sender] = 0;\n', '\t}\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '\t// Only callable after the crowd fund end date.\n', '\tfunction transfer(address _recipient, uint _amount)\n', '\t\twhen_transferable\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transfer(_recipient, _amount);\n', '\t}\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '\t// Only callable after the crowd fund end date.\n', '\tfunction transferFrom(address _from, address _recipient, uint _amount)\n', '\t\twhen_transferable\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transferFrom(_from, _recipient, _amount);\n', '\t}\n', '}\n', '\n', '\n', 'contract Contribution is SafeMath {\n', '\n', '\t//FIELDS\n', '\n', '\t//CONSTANTS\n', '\t//Time limits\n', '\tuint public constant STAGE_ONE_TIME_END = 5 hours;\n', '\tuint public constant STAGE_TWO_TIME_END = 72 hours;\n', '\tuint public constant STAGE_THREE_TIME_END = 2 weeks;\n', '\tuint public constant STAGE_FOUR_TIME_END = 4 weeks;\n', '\t//Prices of GUP\n', '\tuint public constant PRICE_STAGE_ONE   = 480000;\n', '\tuint public constant PRICE_STAGE_TWO   = 440000;\n', '\tuint public constant PRICE_STAGE_THREE = 400000;\n', '\tuint public constant PRICE_STAGE_FOUR  = 360000;\n', '\tuint public constant PRICE_BTCS        = 480000;\n', '\t//GUP Token Limits\n', '\tuint public constant MAX_SUPPLY =        100000000000;\n', '\tuint public constant ALLOC_ILLIQUID_TEAM = 8000000000;\n', '\tuint public constant ALLOC_LIQUID_TEAM =  13000000000;\n', '\tuint public constant ALLOC_BOUNTIES =      2000000000;\n', '\tuint public constant ALLOC_NEW_USERS =    17000000000;\n', '\tuint public constant ALLOC_CROWDSALE =    60000000000;\n', '\tuint public constant BTCS_PORTION_MAX = 31250 * PRICE_BTCS;\n', '\t//ASSIGNED IN INITIALIZATION\n', '\t//Start and end times\n', '\tuint public publicStartTime; //Time in seconds public crowd fund starts.\n', '\tuint public privateStartTime; //Time in seconds when BTCSuisse can purchase up to 31250 ETH worth of GUP;\n', '\tuint public publicEndTime; //Time in seconds crowdsale ends\n', '\t//Special Addresses\n', '\taddress public btcsAddress; //Address used by BTCSuisse\n', '\taddress public multisigAddress; //Address to which all ether flows.\n', '\taddress public matchpoolAddress; //Address to which ALLOC_BOUNTIES, ALLOC_LIQUID_TEAM, ALLOC_NEW_USERS, ALLOC_ILLIQUID_TEAM is sent to.\n', '\taddress public ownerAddress; //Address of the contract owner. Can halt the crowdsale.\n', '\t//Contracts\n', '\tGUPToken public gupToken; //External token contract hollding the GUP\n', '\t//Running totals\n', '\tuint public etherRaised; //Total Ether raised.\n', '\tuint public gupSold; //Total GUP created\n', '\tuint public btcsPortionTotal; //Total of Tokens purchased by BTC Suisse. Not to exceed BTCS_PORTION_MAX.\n', '\t//booleans\n', '\tbool public halted; //halts the crowd sale if true.\n', '\n', '\t//FUNCTION MODIFIERS\n', '\n', '\t//Is currently in the period after the private start time and before the public start time.\n', '\tmodifier is_pre_crowdfund_period() {\n', '\t\tif (now >= publicStartTime || now < privateStartTime) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t//Is currently the crowdfund period\n', '\tmodifier is_crowdfund_period() {\n', '\t\tif (now < publicStartTime || now >= publicEndTime) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t//May only be called by BTC Suisse\n', '\tmodifier only_btcs() {\n', '\t\tif (msg.sender != btcsAddress) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t//May only be called by the owner address\n', '\tmodifier only_owner() {\n', '\t\tif (msg.sender != ownerAddress) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t//May only be called if the crowdfund has not been halted\n', '\tmodifier is_not_halted() {\n', '\t\tif (halted) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// EVENTS\n', '\n', '\tevent PreBuy(uint _amount);\n', '\tevent Buy(address indexed _recipient, uint _amount);\n', '\n', '\n', '\t// FUNCTIONS\n', '\n', '\t//Initialization function. Deploys GUPToken contract assigns values, to all remaining fields, creates first entitlements in the GUP Token contract.\n', '\tfunction Contribution(\n', '\t\taddress _btcs,\n', '\t\taddress _multisig,\n', '\t\taddress _matchpool,\n', '\t\tuint _publicStartTime,\n', '\t\tuint _privateStartTime\n', '\t) {\n', '\t\townerAddress = msg.sender;\n', '\t\tpublicStartTime = _publicStartTime;\n', '\t\tprivateStartTime = _privateStartTime;\n', '\t\tpublicEndTime = _publicStartTime + 4 weeks;\n', '\t\tbtcsAddress = _btcs;\n', '\t\tmultisigAddress = _multisig;\n', '\t\tmatchpoolAddress = _matchpool;\n', '\t\tgupToken = new GUPToken(this, publicEndTime);\n', '\t\tgupToken.createIlliquidToken(matchpoolAddress, ALLOC_ILLIQUID_TEAM);\n', '\t\tgupToken.createToken(matchpoolAddress, ALLOC_BOUNTIES);\n', '\t\tgupToken.createToken(matchpoolAddress, ALLOC_LIQUID_TEAM);\n', '\t\tgupToken.createToken(matchpoolAddress, ALLOC_NEW_USERS);\n', '\t}\n', '\n', '\t//May be used by owner of contract to halt crowdsale and no longer except ether.\n', '\tfunction toggleHalt(bool _halted)\n', '\t\tonly_owner\n', '\t{\n', '\t\thalted = _halted;\n', '\t}\n', '\n', '\t//constant function returns the current GUP price.\n', '\tfunction getPriceRate()\n', '\t\tconstant\n', '\t\treturns (uint o_rate)\n', '\t{\n', '\t\tif (now <= publicStartTime + STAGE_ONE_TIME_END) return PRICE_STAGE_ONE;\n', '\t\tif (now <= publicStartTime + STAGE_TWO_TIME_END) return PRICE_STAGE_TWO;\n', '\t\tif (now <= publicStartTime + STAGE_THREE_TIME_END) return PRICE_STAGE_THREE;\n', '\t\tif (now <= publicStartTime + STAGE_FOUR_TIME_END) return PRICE_STAGE_FOUR;\n', '\t\telse return 0;\n', '\t}\n', '\n', '\t// Given the rate of a purchase and the remaining tokens in this tranche, it\n', '\t// will throw if the sale would take it past the limit of the tranche.\n', '\t// It executes the purchase for the appropriate amount of tokens, which\n', '\t// involves adding it to the total, minting GUP tokens and stashing the\n', '\t// ether.\n', '\t// Returns `amount` in scope as the number of GUP tokens that it will\n', '\t// purchase.\n', '\tfunction processPurchase(uint _rate, uint _remaining)\n', '\t\tinternal\n', '\t\treturns (uint o_amount)\n', '\t{\n', '\t\to_amount = safeDiv(safeMul(msg.value, _rate), 1 ether);\n', '\t\tif (o_amount > _remaining) throw;\n', '\t\tif (!multisigAddress.send(msg.value)) throw;\n', '\t\tif (!gupToken.createToken(msg.sender, o_amount)) throw;\n', '\t\tgupSold += o_amount;\n', '\t\tetherRaised += msg.value;\n', '\t}\n', '\n', '\t//Special Function can only be called by BTC Suisse and only during the pre-crowdsale period.\n', '\t//Allows the purchase of up to 125000 Ether worth of GUP Tokens.\n', '\tfunction preBuy()\n', '\t\tpayable\n', '\t\tis_pre_crowdfund_period\n', '\t\tonly_btcs\n', '\t\tis_not_halted\n', '\t{\n', '\t\tuint amount = processPurchase(PRICE_BTCS, BTCS_PORTION_MAX - btcsPortionTotal);\n', '\t\tbtcsPortionTotal += amount;\n', '\t\tPreBuy(amount);\n', '\t}\n', '\n', '\t//Default function called by sending Ether to this address with no arguments.\n', '\t//Results in creation of new GUP Tokens if transaction would not exceed hard limit of GUP Token.\n', '\tfunction()\n', '\t\tpayable\n', '\t\tis_crowdfund_period\n', '\t\tis_not_halted\n', '\t{\n', '\t\tuint amount = processPurchase(getPriceRate(), ALLOC_CROWDSALE - gupSold);\n', '\t\tBuy(msg.sender, amount);\n', '\t}\n', '\n', '\t//failsafe drain\n', '\tfunction drain()\n', '\t\tonly_owner\n', '\t{\n', '\t\tif (!ownerAddress.send(this.balance)) throw;\n', '\t}\n', '}']