['library SafeMath {\n', '    function mul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '     }\n', '    function add(uint a, uint b) internal returns (uint) {\n', '         uint c = a + b;\n', '         assert(c >= a);\n', '         return c;\n', '     }\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '     }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract tokenPCT {\n', '    /* Public variables of the token */\n', '        string public name;\n', '        string public symbol;\n', '        uint8 public decimals;\n', '        uint256 public totalSupply = 0;\n', '\n', '\n', '        function tokenPCT (string _name, string _symbol, uint8 _decimals){\n', '            name = _name;\n', '            symbol = _symbol;\n', '            decimals = _decimals;\n', '\n', '        }\n', '    /* This creates an array with all balances */\n', '        mapping (address => uint256) public balanceOf;\n', '\n', '}\n', '\n', 'contract Presale is tokenPCT {\n', '\n', '        using SafeMath for uint;\n', '        string name = &#39;Presale CryptoTickets Token&#39;;\n', '        string symbol = &#39;PCT&#39;;\n', '        uint8 decimals = 18;\n', '        address manager;\n', '        address public ico;\n', '\n', '        function Presale (address _manager) tokenPCT (name, symbol, decimals){\n', '             manager = _manager;\n', '\n', '        }\n', '\n', '        event Transfer(address _from, address _to, uint256 amount);\n', '        event Burn(address _from, uint256 amount);\n', '\n', '        modifier onlyManager{\n', '             require(msg.sender == manager);\n', '            _;\n', '        }\n', '\n', '        modifier onlyIco{\n', '             require(msg.sender == ico);\n', '            _;\n', '        }\n', '        function mintTokens(address _investor, uint256 _mintedAmount) public onlyManager {\n', '             balanceOf[_investor] = balanceOf[_investor].add(_mintedAmount);\n', '             totalSupply = totalSupply.add(_mintedAmount);\n', '             Transfer(this, _investor, _mintedAmount);\n', '\n', '        }\n', '\n', '        function burnTokens(address _owner) public onlyIco{\n', '             uint  tokens = balanceOf[_owner];\n', '             require(balanceOf[_owner] != 0);\n', '             balanceOf[_owner] = 0;\n', '             totalSupply = totalSupply.sub(tokens);\n', '             Burn(_owner, tokens);\n', '        }\n', '\n', '        function setIco(address _ico) onlyManager{\n', '            ico = _ico;\n', '        }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '} // Functions of ERC20 standard\n', '\n', '\n', '\n', 'contract CryptoTicketsICO {\n', '    using SafeMath for uint;\n', '\n', '    uint public constant Tokens_For_Sale = 525000000*1e18; // Tokens for Sale without bonuses(HardCap)\n', '\n', '    // Style: Caps should not be used for vars, only for consts!\n', '    uint public Rate_Eth = 298; // Rate USD per ETH\n', '    uint public Token_Price = 25 * Rate_Eth; // TKT per ETH\n', '    uint public SoldNoBonuses = 0; //Sold tokens without bonuses\n', '\n', '\n', '    event LogStartICO();\n', '    event LogPauseICO();\n', '    event LogFinishICO(address bountyFund, address advisorsFund, address itdFund, address storageFund);\n', '    event LogBuyForInvestor(address investor, uint tktValue, string txHash);\n', '    event LogReplaceToken(address investor, uint tktValue);\n', '\n', '    TKT public tkt = new TKT(this);\n', '    Presale public presale;\n', '\n', '    address public Company;\n', '    address public BountyFund;\n', '    address public AdvisorsFund;\n', '    address public ItdFund;\n', '    address public StorageFund;\n', '\n', '    address public Manager; // Manager controls contract\n', '    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\n', '    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\n', '    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\n', '    modifier managerOnly { require(msg.sender == Manager); _; }\n', '    modifier controllersOnly { require((msg.sender == Controller_Address1) || (msg.sender == Controller_Address2) || (msg.sender == Controller_Address3)); _; }\n', '\n', '    uint startTime = 0;\n', '    uint bountyPart = 2; // 2% of TotalSupply for BountyFund\n', '    uint advisorsPart = 35; //3,5% of TotalSupply for AdvisorsFund\n', '    uint itdPart = 15; //15% of TotalSupply for ItdFund\n', '    uint storagePart = 3; //3% of TotalSupply for StorageFund\n', '    uint icoAndPOfPart = 765; // 76,5% of TotalSupply for PublicICO and PrivateOffer\n', '    enum StatusICO { Created, Started, Paused, Finished }\n', '    StatusICO statusICO = StatusICO.Created;\n', '\n', '\n', '    function CryptoTicketsICO(address _presale, address _Company, address _BountyFund, address _AdvisorsFund, address _ItdFund, address _StorageFund, address _Manager, address _Controller_Address1, address _Controller_Address2, address _Controller_Address3){\n', '       presale = Presale(_presale);\n', '       Company = _Company;\n', '       BountyFund = _BountyFund;\n', '       AdvisorsFund = _AdvisorsFund;\n', '       ItdFund = _ItdFund;\n', '       StorageFund = _StorageFund;\n', '       Manager = _Manager;\n', '       Controller_Address1 = _Controller_Address1;\n', '       Controller_Address2 = _Controller_Address2;\n', '       Controller_Address3 = _Controller_Address3;\n', '    }\n', '\n', '// function for changing rate of ETH and price of token\n', '\n', '\n', '    function setRate(uint _RateEth) external managerOnly {\n', '       Rate_Eth = _RateEth;\n', '       Token_Price = 25*Rate_Eth;\n', '    }\n', '\n', '\n', '//ICO status functions\n', '\n', '    function startIco() external managerOnly {\n', '       require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);\n', '       if(statusICO == StatusICO.Created)\n', '       {\n', '         startTime = now;\n', '       }\n', '       LogStartICO();\n', '       statusICO = StatusICO.Started;\n', '    }\n', '\n', '    function pauseIco() external managerOnly {\n', '       require(statusICO == StatusICO.Started);\n', '       statusICO = StatusICO.Paused;\n', '       LogPauseICO();\n', '    }\n', '\n', '\n', '    function finishIco() external managerOnly { // Funds for minting of tokens\n', '\n', '       require(statusICO == StatusICO.Started);\n', '\n', '       uint alreadyMinted = tkt.totalSupply(); //=PublicICO+PrivateOffer\n', '       uint totalAmount = alreadyMinted * 1000 / icoAndPOfPart;\n', '\n', '\n', '       tkt.mint(BountyFund, bountyPart * totalAmount / 100); // 2% for Bounty\n', '       tkt.mint(AdvisorsFund, advisorsPart * totalAmount / 1000); // 3.5% for Advisors\n', '       tkt.mint(ItdFund, itdPart * totalAmount / 100); // 15% for Ticketscloud ltd\n', '       tkt.mint(StorageFund, storagePart * totalAmount / 100); // 3% for Storage\n', '\n', '       tkt.defrost();\n', '\n', '       statusICO = StatusICO.Finished;\n', '       LogFinishICO(BountyFund, AdvisorsFund, ItdFund, StorageFund);\n', '    }\n', '\n', '// function that buys tokens when investor sends ETH to address of ICO\n', '    function() external payable {\n', '\n', '       buy(msg.sender, msg.value * Token_Price);\n', '    }\n', '\n', '// function for buying tokens to investors who paid in other cryptos\n', '\n', '    function buyForInvestor(address _investor, uint _tktValue, string _txHash) external controllersOnly {\n', '       buy(_investor, _tktValue);\n', '       LogBuyForInvestor(_investor, _tktValue, _txHash);\n', '    }\n', '\n', '//function for buying tokens for presale investors\n', '\n', '    function replaceToken(address _investor) managerOnly{\n', '         require(statusICO != StatusICO.Finished);\n', '         uint pctTokens = presale.balanceOf(_investor);\n', '         require(pctTokens > 0);\n', '         presale.burnTokens(_investor);\n', '         tkt.mint(_investor, pctTokens);\n', '\n', '         LogReplaceToken(_investor, pctTokens);\n', '    }\n', '// internal function for buying tokens\n', '\n', '    function buy(address _investor, uint _tktValue) internal {\n', '       require(statusICO == StatusICO.Started);\n', '       require(_tktValue > 0);\n', '\n', '\n', '       uint bonus = getBonus(_tktValue);\n', '\n', '       uint _total = _tktValue.add(bonus);\n', '\n', '       require(SoldNoBonuses + _tktValue <= Tokens_For_Sale);\n', '       tkt.mint(_investor, _total);\n', '\n', '       SoldNoBonuses = SoldNoBonuses.add(_tktValue);\n', '    }\n', '\n', '// function that calculates bonus\n', '    function getBonus(uint _value) public constant returns (uint) {\n', '       uint bonus = 0;\n', '       uint time = now;\n', '       if(time >= startTime && time <= startTime + 48 hours)\n', '       {\n', '\n', '            bonus = _value * 20/100;\n', '        }\n', '\n', '       if(time > startTime + 48 hours && time <= startTime + 96 hours)\n', '       {\n', '            bonus = _value * 10/100;\n', '       }\n', '\n', '       if(time > startTime + 96 hours && time <= startTime + 168 hours)\n', '       {\n', '\n', '            bonus = _value * 5/100;\n', '        }\n', '\n', '       return bonus;\n', '    }\n', '\n', '//function to withdraw ETH from smart contract\n', '\n', '    // SUGGESTION:\n', '    // even if you lose you manager keys -> you still will be able to get ETH\n', '    function withdrawEther(uint256 _value) external managerOnly {\n', '       require(statusICO == StatusICO.Finished);\n', '       Company.transfer(_value);\n', '    }\n', '\n', '}\n', '\n', 'contract TKT  is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "CryptoTickets COIN";\n', '    string public symbol = "TKT";\n', '    uint public decimals = 18;\n', '\n', '    address public ico;\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    bool public tokensAreFrozen = true;\n', '\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '\n', '    function TKT(address _ico) {\n', '       ico = _ico;\n', '    }\n', '\n', '\n', '    function mint(address _holder, uint _value) external icoOnly {\n', '       require(_value != 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '\n', '    function defrost() external icoOnly {\n', '       tokensAreFrozen = false;\n', '    }\n', '\n', '    function burn(uint256 _value) {\n', '       require(!tokensAreFrozen);\n', '       balances[msg.sender] = balances[msg.sender].sub(_value);\n', '       totalSupply = totalSupply.sub(_value);\n', '       Burn(msg.sender, _value);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '         return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '     }\n', '\n', '\n', '    function approve(address _spender, uint256 _amount) returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']
['library SafeMath {\n', '    function mul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '     }\n', '    function add(uint a, uint b) internal returns (uint) {\n', '         uint c = a + b;\n', '         assert(c >= a);\n', '         return c;\n', '     }\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '     }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract tokenPCT {\n', '    /* Public variables of the token */\n', '        string public name;\n', '        string public symbol;\n', '        uint8 public decimals;\n', '        uint256 public totalSupply = 0;\n', '\n', '\n', '        function tokenPCT (string _name, string _symbol, uint8 _decimals){\n', '            name = _name;\n', '            symbol = _symbol;\n', '            decimals = _decimals;\n', '\n', '        }\n', '    /* This creates an array with all balances */\n', '        mapping (address => uint256) public balanceOf;\n', '\n', '}\n', '\n', 'contract Presale is tokenPCT {\n', '\n', '        using SafeMath for uint;\n', "        string name = 'Presale CryptoTickets Token';\n", "        string symbol = 'PCT';\n", '        uint8 decimals = 18;\n', '        address manager;\n', '        address public ico;\n', '\n', '        function Presale (address _manager) tokenPCT (name, symbol, decimals){\n', '             manager = _manager;\n', '\n', '        }\n', '\n', '        event Transfer(address _from, address _to, uint256 amount);\n', '        event Burn(address _from, uint256 amount);\n', '\n', '        modifier onlyManager{\n', '             require(msg.sender == manager);\n', '            _;\n', '        }\n', '\n', '        modifier onlyIco{\n', '             require(msg.sender == ico);\n', '            _;\n', '        }\n', '        function mintTokens(address _investor, uint256 _mintedAmount) public onlyManager {\n', '             balanceOf[_investor] = balanceOf[_investor].add(_mintedAmount);\n', '             totalSupply = totalSupply.add(_mintedAmount);\n', '             Transfer(this, _investor, _mintedAmount);\n', '\n', '        }\n', '\n', '        function burnTokens(address _owner) public onlyIco{\n', '             uint  tokens = balanceOf[_owner];\n', '             require(balanceOf[_owner] != 0);\n', '             balanceOf[_owner] = 0;\n', '             totalSupply = totalSupply.sub(tokens);\n', '             Burn(_owner, tokens);\n', '        }\n', '\n', '        function setIco(address _ico) onlyManager{\n', '            ico = _ico;\n', '        }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '} // Functions of ERC20 standard\n', '\n', '\n', '\n', 'contract CryptoTicketsICO {\n', '    using SafeMath for uint;\n', '\n', '    uint public constant Tokens_For_Sale = 525000000*1e18; // Tokens for Sale without bonuses(HardCap)\n', '\n', '    // Style: Caps should not be used for vars, only for consts!\n', '    uint public Rate_Eth = 298; // Rate USD per ETH\n', '    uint public Token_Price = 25 * Rate_Eth; // TKT per ETH\n', '    uint public SoldNoBonuses = 0; //Sold tokens without bonuses\n', '\n', '\n', '    event LogStartICO();\n', '    event LogPauseICO();\n', '    event LogFinishICO(address bountyFund, address advisorsFund, address itdFund, address storageFund);\n', '    event LogBuyForInvestor(address investor, uint tktValue, string txHash);\n', '    event LogReplaceToken(address investor, uint tktValue);\n', '\n', '    TKT public tkt = new TKT(this);\n', '    Presale public presale;\n', '\n', '    address public Company;\n', '    address public BountyFund;\n', '    address public AdvisorsFund;\n', '    address public ItdFund;\n', '    address public StorageFund;\n', '\n', '    address public Manager; // Manager controls contract\n', '    address public Controller_Address1; // First address that is used to buy tokens for other cryptos\n', '    address public Controller_Address2; // Second address that is used to buy tokens for other cryptos\n', '    address public Controller_Address3; // Third address that is used to buy tokens for other cryptos\n', '    modifier managerOnly { require(msg.sender == Manager); _; }\n', '    modifier controllersOnly { require((msg.sender == Controller_Address1) || (msg.sender == Controller_Address2) || (msg.sender == Controller_Address3)); _; }\n', '\n', '    uint startTime = 0;\n', '    uint bountyPart = 2; // 2% of TotalSupply for BountyFund\n', '    uint advisorsPart = 35; //3,5% of TotalSupply for AdvisorsFund\n', '    uint itdPart = 15; //15% of TotalSupply for ItdFund\n', '    uint storagePart = 3; //3% of TotalSupply for StorageFund\n', '    uint icoAndPOfPart = 765; // 76,5% of TotalSupply for PublicICO and PrivateOffer\n', '    enum StatusICO { Created, Started, Paused, Finished }\n', '    StatusICO statusICO = StatusICO.Created;\n', '\n', '\n', '    function CryptoTicketsICO(address _presale, address _Company, address _BountyFund, address _AdvisorsFund, address _ItdFund, address _StorageFund, address _Manager, address _Controller_Address1, address _Controller_Address2, address _Controller_Address3){\n', '       presale = Presale(_presale);\n', '       Company = _Company;\n', '       BountyFund = _BountyFund;\n', '       AdvisorsFund = _AdvisorsFund;\n', '       ItdFund = _ItdFund;\n', '       StorageFund = _StorageFund;\n', '       Manager = _Manager;\n', '       Controller_Address1 = _Controller_Address1;\n', '       Controller_Address2 = _Controller_Address2;\n', '       Controller_Address3 = _Controller_Address3;\n', '    }\n', '\n', '// function for changing rate of ETH and price of token\n', '\n', '\n', '    function setRate(uint _RateEth) external managerOnly {\n', '       Rate_Eth = _RateEth;\n', '       Token_Price = 25*Rate_Eth;\n', '    }\n', '\n', '\n', '//ICO status functions\n', '\n', '    function startIco() external managerOnly {\n', '       require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);\n', '       if(statusICO == StatusICO.Created)\n', '       {\n', '         startTime = now;\n', '       }\n', '       LogStartICO();\n', '       statusICO = StatusICO.Started;\n', '    }\n', '\n', '    function pauseIco() external managerOnly {\n', '       require(statusICO == StatusICO.Started);\n', '       statusICO = StatusICO.Paused;\n', '       LogPauseICO();\n', '    }\n', '\n', '\n', '    function finishIco() external managerOnly { // Funds for minting of tokens\n', '\n', '       require(statusICO == StatusICO.Started);\n', '\n', '       uint alreadyMinted = tkt.totalSupply(); //=PublicICO+PrivateOffer\n', '       uint totalAmount = alreadyMinted * 1000 / icoAndPOfPart;\n', '\n', '\n', '       tkt.mint(BountyFund, bountyPart * totalAmount / 100); // 2% for Bounty\n', '       tkt.mint(AdvisorsFund, advisorsPart * totalAmount / 1000); // 3.5% for Advisors\n', '       tkt.mint(ItdFund, itdPart * totalAmount / 100); // 15% for Ticketscloud ltd\n', '       tkt.mint(StorageFund, storagePart * totalAmount / 100); // 3% for Storage\n', '\n', '       tkt.defrost();\n', '\n', '       statusICO = StatusICO.Finished;\n', '       LogFinishICO(BountyFund, AdvisorsFund, ItdFund, StorageFund);\n', '    }\n', '\n', '// function that buys tokens when investor sends ETH to address of ICO\n', '    function() external payable {\n', '\n', '       buy(msg.sender, msg.value * Token_Price);\n', '    }\n', '\n', '// function for buying tokens to investors who paid in other cryptos\n', '\n', '    function buyForInvestor(address _investor, uint _tktValue, string _txHash) external controllersOnly {\n', '       buy(_investor, _tktValue);\n', '       LogBuyForInvestor(_investor, _tktValue, _txHash);\n', '    }\n', '\n', '//function for buying tokens for presale investors\n', '\n', '    function replaceToken(address _investor) managerOnly{\n', '         require(statusICO != StatusICO.Finished);\n', '         uint pctTokens = presale.balanceOf(_investor);\n', '         require(pctTokens > 0);\n', '         presale.burnTokens(_investor);\n', '         tkt.mint(_investor, pctTokens);\n', '\n', '         LogReplaceToken(_investor, pctTokens);\n', '    }\n', '// internal function for buying tokens\n', '\n', '    function buy(address _investor, uint _tktValue) internal {\n', '       require(statusICO == StatusICO.Started);\n', '       require(_tktValue > 0);\n', '\n', '\n', '       uint bonus = getBonus(_tktValue);\n', '\n', '       uint _total = _tktValue.add(bonus);\n', '\n', '       require(SoldNoBonuses + _tktValue <= Tokens_For_Sale);\n', '       tkt.mint(_investor, _total);\n', '\n', '       SoldNoBonuses = SoldNoBonuses.add(_tktValue);\n', '    }\n', '\n', '// function that calculates bonus\n', '    function getBonus(uint _value) public constant returns (uint) {\n', '       uint bonus = 0;\n', '       uint time = now;\n', '       if(time >= startTime && time <= startTime + 48 hours)\n', '       {\n', '\n', '            bonus = _value * 20/100;\n', '        }\n', '\n', '       if(time > startTime + 48 hours && time <= startTime + 96 hours)\n', '       {\n', '            bonus = _value * 10/100;\n', '       }\n', '\n', '       if(time > startTime + 96 hours && time <= startTime + 168 hours)\n', '       {\n', '\n', '            bonus = _value * 5/100;\n', '        }\n', '\n', '       return bonus;\n', '    }\n', '\n', '//function to withdraw ETH from smart contract\n', '\n', '    // SUGGESTION:\n', '    // even if you lose you manager keys -> you still will be able to get ETH\n', '    function withdrawEther(uint256 _value) external managerOnly {\n', '       require(statusICO == StatusICO.Finished);\n', '       Company.transfer(_value);\n', '    }\n', '\n', '}\n', '\n', 'contract TKT  is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "CryptoTickets COIN";\n', '    string public symbol = "TKT";\n', '    uint public decimals = 18;\n', '\n', '    address public ico;\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    bool public tokensAreFrozen = true;\n', '\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '\n', '    function TKT(address _ico) {\n', '       ico = _ico;\n', '    }\n', '\n', '\n', '    function mint(address _holder, uint _value) external icoOnly {\n', '       require(_value != 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '\n', '    function defrost() external icoOnly {\n', '       tokensAreFrozen = false;\n', '    }\n', '\n', '    function burn(uint256 _value) {\n', '       require(!tokensAreFrozen);\n', '       balances[msg.sender] = balances[msg.sender].sub(_value);\n', '       totalSupply = totalSupply.sub(_value);\n', '       Burn(msg.sender, _value);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '         return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '     }\n', '\n', '\n', '    function approve(address _spender, uint256 _amount) returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']
