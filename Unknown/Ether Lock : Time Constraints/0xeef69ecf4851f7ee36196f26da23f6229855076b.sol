['pragma solidity ^0.4.11;\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function balanceOf(address _owner) constant returns (uint256 balance) ;\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '\n', '    struct LCBalance{\n', '        uint lcValue;\n', '        uint lockTime;\n', '        uint ethValue;\n', '\n', '        uint index;\n', '        bytes32 indexHash;\n', '        uint8 lotteryNum;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender].lcValue >= _value && _value > 0&&  balances[msg.sender].lockTime!=0) {       \n', '            balances[msg.sender].lcValue -= _value;\n', '            balances[_to].lcValue += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '         else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].lcValue;\n', '    }\n', '\n', '    function balanceOfEth(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].ethValue;\n', '    }\n', '\n', '    function balanceOfLockTime(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].lockTime;\n', '    }\n', '\n', '    mapping (address => LCBalance) balances;\n', '}\n', '\n', 'contract LCToken is StandardToken {\n', '    // metadata\n', '    string public constant name = "Lottery Coin";\n', '    string public constant symbol = "SaberLC";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // constant\n', '    uint256 val1 = 1 wei;    // 1\n', '    uint256 val2 = 1 szabo;  // 1 * 10 ** 12\n', '    uint256 val3 = 1 finney; // 1 * 10 ** 15\n', '    uint256 val4 = 1 ether;  // 1 * 10 ** 18\n', '\n', '    // contact setting\n', '    address public creator;\n', '\n', '    uint256 public constant LOCKPERIOD          = 365 days;\n', '    uint256 public constant ICOPERIOD           = 120 days;\n', '    uint256 public constant SHAREPERIOD           = 30 days;\n', '    uint256 public constant LOCKAMOUNT          = 3000000 * 10**decimals;\n', '    uint256 public constant AMOUNT_ICO          = 5000000 * 10**decimals;\n', '    uint256 public constant AMOUNT_TeamSupport  = 2000000 * 10**decimals;\n', '\n', '    uint256 public gcStartTime = 0;     //ico begin time, unix timestamp seconds\n', '    uint256 public gcEndTime = 0;       //ico end time, unix timestamp seconds\n', '\n', '    \n', '    // LC: 30% lock , 20% for Team, 50% for ico          \n', '    address account_lock = 0x9AD7aeBe8811b0E3071C627403B38803D91BC1ac;  //30%  lock\n', '    address account_team = 0xc96c3da8bc6381DB296959Ec3e1Fe1e430a4B65B;  //20%  team\n', '\n', '    uint256 public gcSupply = 5000000 * 10**decimals;                 // ico 50% (5000000) total LC supply\n', '    uint256 public constant gcExchangeRate=1000;                       // 1000 LC per 1 ETH\n', '\n', '    \n', '    // Play\n', '    bytes32[1000]   blockhash;\n', '    uint            firstIndex;\n', '    uint            endIndex;\n', '\n', '    uint256 public totalLotteryValue = 0;\n', '    uint256 public currentLotteryValue = 0;\n', '    uint256 public currentProfit = 0;\n', '    uint256 public shareTime = 0;\n', '    uint256 public shareLimit = 10000*val4;\n', '\n', '\n', '    function addHash (bytes32 _hashValue) {\n', '        if(endIndex+1==firstIndex)\n', '        {\n', '            endIndex++;\n', '            blockhash[endIndex]=_hashValue;\n', '            if(firstIndex<999)\n', '            {\n', '                firstIndex++;\n', '            }\n', '            else\n', '            {\n', '                firstIndex=0;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            if(firstIndex==0 && 999==endIndex)\n', '            {\n', '                endIndex=0;\n', '                blockhash[endIndex]=_hashValue;\n', '                firstIndex=1;\n', '            }\n', '            else\n', '            {\n', '                if(999<=endIndex)\n', '                {\n', '                    endIndex=0;\n', '                }\n', '                else\n', '                {\n', '                    endIndex++;\n', '                }\n', '                blockhash[endIndex]=_hashValue;\n', '            }\n', '        }\n', '    }\n', '\n', '    function buyLottery (uint8 _lotteryNum) payable {\n', '        if ( msg.value >=val3*10 && _lotteryNum>=0 &&  _lotteryNum<=9 )\n', '        {\n', '            bytes32 currentHash=block.blockhash(block.number-1);\n', '            if(blockhash[endIndex]!=currentHash)\n', '            {\n', '                addHash(currentHash);\n', '            }\n', '            balances[msg.sender].ethValue+=msg.value;\n', '            balances[msg.sender].index=endIndex;\n', '            balances[msg.sender].lotteryNum=_lotteryNum;\n', '            balances[msg.sender].indexHash=currentHash;\n', '            totalLotteryValue+=msg.value;\n', '            currentLotteryValue+=msg.value;\n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function openLottery () {\n', '\n', '        bytes32 currentHash=block.blockhash(block.number-1);\n', '        if(blockhash[endIndex]!=currentHash)\n', '        {\n', '            addHash(currentHash);\n', '        }\n', '        if ( balances[msg.sender].ethValue >=val3*10 && balances[msg.sender].indexHash!=currentHash)\n', '        {\n', '            currentLotteryValue-=balances[msg.sender].ethValue;\n', '\n', '            uint temuint = balances[msg.sender].index;\n', '            if(balances[msg.sender].lotteryNum>=0 && balances[msg.sender].lotteryNum<=9 && balances[msg.sender].indexHash==blockhash[temuint])\n', '            {\n', '                temuint++;\n', '                if(temuint>999)\n', '                {\n', '                    temuint=0;\n', '                }\n', '                temuint = uint(blockhash[temuint]);\n', '                temuint = temuint%10;\n', '                if(temuint==balances[msg.sender].lotteryNum)\n', '                {\n', '                    uint _tosend=balances[msg.sender].ethValue*90/100;\n', '                    if(_tosend>totalLotteryValue)\n', '                    {\n', '                        _tosend=totalLotteryValue;\n', '                    }\n', '                    totalLotteryValue-=_tosend;\n', '                    balances[msg.sender].ethValue=0;\n', '                    msg.sender.transfer(_tosend);\n', '                }\n', '                else\n', '                {\n', '                    balances[msg.sender].ethValue=0;\n', '                }\n', '            }\n', '            else\n', '            {\n', '                balances[msg.sender].ethValue=0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getShare ()  {\n', '\n', '        if(shareTime+SHAREPERIOD<now)\n', '        {\n', '            while(shareTime+SHAREPERIOD<now)\n', '            {\n', '                shareTime+=SHAREPERIOD;\n', '            }\n', '            if(totalLotteryValue>currentLotteryValue)\n', '            {\n', '                currentProfit=totalLotteryValue-currentLotteryValue;\n', '            }\n', '            else\n', '            {\n', '                currentProfit=0;\n', '            }\n', '        }\n', '\n', '        if (balances[msg.sender].lockTime!=0 && balances[msg.sender].lockTime+SHAREPERIOD <=shareTime && currentLotteryValue<totalLotteryValue && balances[msg.sender].lcValue >=shareLimit)\n', '        {\n', '            uint _sharevalue=balances[msg.sender].lcValue/val4*currentProfit/1000;\n', '            if(_sharevalue>totalLotteryValue)\n', '            {\n', '                _sharevalue=totalLotteryValue;\n', '            }\n', '            totalLotteryValue-=_sharevalue;\n', '            msg.sender.transfer(_sharevalue);\n', '            balances[msg.sender].lockTime=now;\n', '        }\n', '    }\n', '\n', '\n', '    function Add_totalLotteryValue () payable {\n', '        if(msg.value>0)\n', '        {\n', '            totalLotteryValue+=msg.value;\n', '        }\n', '    }\n', '\n', '    //\n', '    function lockAccount ()  {\n', '        balances[msg.sender].lockTime=now;\n', '    }\n', '\n', '    function unlockAccount ()  {\n', '        balances[msg.sender].lockTime=0;\n', '    }\n', '\n', '    \n', '    //+ buy lc,1eth=1000lc, 30%eth send to owner, 70% keep in contact\n', '    function buyLC () payable {\n', '        if(now < gcEndTime)\n', '        {\n', '            uint256 lcAmount;\n', '            if ( msg.value >=0){\n', '                lcAmount = msg.value * gcExchangeRate;\n', '                if (gcSupply < lcAmount) revert();\n', '                gcSupply -= lcAmount;          \n', '                balances[msg.sender].lcValue += lcAmount;\n', '            }\n', '            if(!creator.send(msg.value*30/100)) revert();\n', '        }\n', '        else\n', '        {    \n', '            balances[account_team].lcValue += gcSupply;\n', '            account_team.transfer((AMOUNT_ICO-gcSupply)*699/1000/gcExchangeRate);\n', '            gcSupply = 0;     \n', '        }\n', '    }\n', '\n', '    // exchange lc to eth, 1000lc =0.7eth, 30% for fee\n', '    function clearLC ()  {\n', '        if(now < gcEndTime)\n', '        {\n', '            uint256 ethAmount;\n', '            if ( balances[msg.sender].lcValue >0 && balances[msg.sender].lockTime==0){\n', '                if(msg.sender == account_lock && now < gcStartTime + LOCKPERIOD)\n', '                {\n', '                    revert();\n', '                }\n', '                ethAmount = balances[msg.sender].lcValue *70/100/ gcExchangeRate;\n', '                gcSupply += balances[msg.sender].lcValue;          \n', '                balances[msg.sender].lcValue = 0;\n', '                msg.sender.transfer(ethAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    //+ transfer\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender].lcValue >= _value && _value > 0 && balances[msg.sender].lockTime==0 ) { \n', '            if(msg.sender == account_lock ){\n', '                if(now < gcStartTime + LOCKPERIOD){\n', '                    return false;\n', '                }\n', '            }\n', '            else{\n', '                balances[msg.sender].lcValue -= _value;\n', '                if(address(this)==_to)\n', '                {\n', '                    balances[creator].lcValue += _value;\n', '                }\n', '                else\n', '                {\n', '                    balances[_to].lcValue += _value;\n', '                }\n', '                Transfer(msg.sender, _to, _value);\n', '                return true;\n', '            }\n', '        \n', '        } \n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function endThisContact () {\n', '        if(msg.sender==creator && balances[msg.sender].lcValue >=9000000 * val4)\n', '        {\n', '            selfdestruct(creator);\n', '        }\n', '    }\n', '\n', '    // constructor\n', '    function LCToken( ) {\n', '        creator = msg.sender;\n', '        balances[account_team].lcValue = AMOUNT_TeamSupport;    //for team\n', '        balances[account_lock].lcValue = LOCKAMOUNT;            //30%   lock 365 days\n', '        gcStartTime = now;\n', '        gcEndTime=now+ICOPERIOD;\n', '\n', '\n', '        totalLotteryValue=0;\n', '\n', '        firstIndex=0;\n', '        endIndex=0;\n', '        blockhash[0] = block.blockhash(block.number-1);\n', '\n', '        shareTime=now+SHAREPERIOD;\n', '    }\n', '    \n', '\n', '    \n', '    // fallback\n', '    function() payable {\n', '        buyLC();\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function balanceOf(address _owner) constant returns (uint256 balance) ;\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '\n', '    struct LCBalance{\n', '        uint lcValue;\n', '        uint lockTime;\n', '        uint ethValue;\n', '\n', '        uint index;\n', '        bytes32 indexHash;\n', '        uint8 lotteryNum;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender].lcValue >= _value && _value > 0&&  balances[msg.sender].lockTime!=0) {       \n', '            balances[msg.sender].lcValue -= _value;\n', '            balances[_to].lcValue += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '         else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].lcValue;\n', '    }\n', '\n', '    function balanceOfEth(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].ethValue;\n', '    }\n', '\n', '    function balanceOfLockTime(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner].lockTime;\n', '    }\n', '\n', '    mapping (address => LCBalance) balances;\n', '}\n', '\n', 'contract LCToken is StandardToken {\n', '    // metadata\n', '    string public constant name = "Lottery Coin";\n', '    string public constant symbol = "SaberLC";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // constant\n', '    uint256 val1 = 1 wei;    // 1\n', '    uint256 val2 = 1 szabo;  // 1 * 10 ** 12\n', '    uint256 val3 = 1 finney; // 1 * 10 ** 15\n', '    uint256 val4 = 1 ether;  // 1 * 10 ** 18\n', '\n', '    // contact setting\n', '    address public creator;\n', '\n', '    uint256 public constant LOCKPERIOD          = 365 days;\n', '    uint256 public constant ICOPERIOD           = 120 days;\n', '    uint256 public constant SHAREPERIOD           = 30 days;\n', '    uint256 public constant LOCKAMOUNT          = 3000000 * 10**decimals;\n', '    uint256 public constant AMOUNT_ICO          = 5000000 * 10**decimals;\n', '    uint256 public constant AMOUNT_TeamSupport  = 2000000 * 10**decimals;\n', '\n', '    uint256 public gcStartTime = 0;     //ico begin time, unix timestamp seconds\n', '    uint256 public gcEndTime = 0;       //ico end time, unix timestamp seconds\n', '\n', '    \n', '    // LC: 30% lock , 20% for Team, 50% for ico          \n', '    address account_lock = 0x9AD7aeBe8811b0E3071C627403B38803D91BC1ac;  //30%  lock\n', '    address account_team = 0xc96c3da8bc6381DB296959Ec3e1Fe1e430a4B65B;  //20%  team\n', '\n', '    uint256 public gcSupply = 5000000 * 10**decimals;                 // ico 50% (5000000) total LC supply\n', '    uint256 public constant gcExchangeRate=1000;                       // 1000 LC per 1 ETH\n', '\n', '    \n', '    // Play\n', '    bytes32[1000]   blockhash;\n', '    uint            firstIndex;\n', '    uint            endIndex;\n', '\n', '    uint256 public totalLotteryValue = 0;\n', '    uint256 public currentLotteryValue = 0;\n', '    uint256 public currentProfit = 0;\n', '    uint256 public shareTime = 0;\n', '    uint256 public shareLimit = 10000*val4;\n', '\n', '\n', '    function addHash (bytes32 _hashValue) {\n', '        if(endIndex+1==firstIndex)\n', '        {\n', '            endIndex++;\n', '            blockhash[endIndex]=_hashValue;\n', '            if(firstIndex<999)\n', '            {\n', '                firstIndex++;\n', '            }\n', '            else\n', '            {\n', '                firstIndex=0;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            if(firstIndex==0 && 999==endIndex)\n', '            {\n', '                endIndex=0;\n', '                blockhash[endIndex]=_hashValue;\n', '                firstIndex=1;\n', '            }\n', '            else\n', '            {\n', '                if(999<=endIndex)\n', '                {\n', '                    endIndex=0;\n', '                }\n', '                else\n', '                {\n', '                    endIndex++;\n', '                }\n', '                blockhash[endIndex]=_hashValue;\n', '            }\n', '        }\n', '    }\n', '\n', '    function buyLottery (uint8 _lotteryNum) payable {\n', '        if ( msg.value >=val3*10 && _lotteryNum>=0 &&  _lotteryNum<=9 )\n', '        {\n', '            bytes32 currentHash=block.blockhash(block.number-1);\n', '            if(blockhash[endIndex]!=currentHash)\n', '            {\n', '                addHash(currentHash);\n', '            }\n', '            balances[msg.sender].ethValue+=msg.value;\n', '            balances[msg.sender].index=endIndex;\n', '            balances[msg.sender].lotteryNum=_lotteryNum;\n', '            balances[msg.sender].indexHash=currentHash;\n', '            totalLotteryValue+=msg.value;\n', '            currentLotteryValue+=msg.value;\n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function openLottery () {\n', '\n', '        bytes32 currentHash=block.blockhash(block.number-1);\n', '        if(blockhash[endIndex]!=currentHash)\n', '        {\n', '            addHash(currentHash);\n', '        }\n', '        if ( balances[msg.sender].ethValue >=val3*10 && balances[msg.sender].indexHash!=currentHash)\n', '        {\n', '            currentLotteryValue-=balances[msg.sender].ethValue;\n', '\n', '            uint temuint = balances[msg.sender].index;\n', '            if(balances[msg.sender].lotteryNum>=0 && balances[msg.sender].lotteryNum<=9 && balances[msg.sender].indexHash==blockhash[temuint])\n', '            {\n', '                temuint++;\n', '                if(temuint>999)\n', '                {\n', '                    temuint=0;\n', '                }\n', '                temuint = uint(blockhash[temuint]);\n', '                temuint = temuint%10;\n', '                if(temuint==balances[msg.sender].lotteryNum)\n', '                {\n', '                    uint _tosend=balances[msg.sender].ethValue*90/100;\n', '                    if(_tosend>totalLotteryValue)\n', '                    {\n', '                        _tosend=totalLotteryValue;\n', '                    }\n', '                    totalLotteryValue-=_tosend;\n', '                    balances[msg.sender].ethValue=0;\n', '                    msg.sender.transfer(_tosend);\n', '                }\n', '                else\n', '                {\n', '                    balances[msg.sender].ethValue=0;\n', '                }\n', '            }\n', '            else\n', '            {\n', '                balances[msg.sender].ethValue=0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getShare ()  {\n', '\n', '        if(shareTime+SHAREPERIOD<now)\n', '        {\n', '            while(shareTime+SHAREPERIOD<now)\n', '            {\n', '                shareTime+=SHAREPERIOD;\n', '            }\n', '            if(totalLotteryValue>currentLotteryValue)\n', '            {\n', '                currentProfit=totalLotteryValue-currentLotteryValue;\n', '            }\n', '            else\n', '            {\n', '                currentProfit=0;\n', '            }\n', '        }\n', '\n', '        if (balances[msg.sender].lockTime!=0 && balances[msg.sender].lockTime+SHAREPERIOD <=shareTime && currentLotteryValue<totalLotteryValue && balances[msg.sender].lcValue >=shareLimit)\n', '        {\n', '            uint _sharevalue=balances[msg.sender].lcValue/val4*currentProfit/1000;\n', '            if(_sharevalue>totalLotteryValue)\n', '            {\n', '                _sharevalue=totalLotteryValue;\n', '            }\n', '            totalLotteryValue-=_sharevalue;\n', '            msg.sender.transfer(_sharevalue);\n', '            balances[msg.sender].lockTime=now;\n', '        }\n', '    }\n', '\n', '\n', '    function Add_totalLotteryValue () payable {\n', '        if(msg.value>0)\n', '        {\n', '            totalLotteryValue+=msg.value;\n', '        }\n', '    }\n', '\n', '    //\n', '    function lockAccount ()  {\n', '        balances[msg.sender].lockTime=now;\n', '    }\n', '\n', '    function unlockAccount ()  {\n', '        balances[msg.sender].lockTime=0;\n', '    }\n', '\n', '    \n', '    //+ buy lc,1eth=1000lc, 30%eth send to owner, 70% keep in contact\n', '    function buyLC () payable {\n', '        if(now < gcEndTime)\n', '        {\n', '            uint256 lcAmount;\n', '            if ( msg.value >=0){\n', '                lcAmount = msg.value * gcExchangeRate;\n', '                if (gcSupply < lcAmount) revert();\n', '                gcSupply -= lcAmount;          \n', '                balances[msg.sender].lcValue += lcAmount;\n', '            }\n', '            if(!creator.send(msg.value*30/100)) revert();\n', '        }\n', '        else\n', '        {    \n', '            balances[account_team].lcValue += gcSupply;\n', '            account_team.transfer((AMOUNT_ICO-gcSupply)*699/1000/gcExchangeRate);\n', '            gcSupply = 0;     \n', '        }\n', '    }\n', '\n', '    // exchange lc to eth, 1000lc =0.7eth, 30% for fee\n', '    function clearLC ()  {\n', '        if(now < gcEndTime)\n', '        {\n', '            uint256 ethAmount;\n', '            if ( balances[msg.sender].lcValue >0 && balances[msg.sender].lockTime==0){\n', '                if(msg.sender == account_lock && now < gcStartTime + LOCKPERIOD)\n', '                {\n', '                    revert();\n', '                }\n', '                ethAmount = balances[msg.sender].lcValue *70/100/ gcExchangeRate;\n', '                gcSupply += balances[msg.sender].lcValue;          \n', '                balances[msg.sender].lcValue = 0;\n', '                msg.sender.transfer(ethAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    //+ transfer\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender].lcValue >= _value && _value > 0 && balances[msg.sender].lockTime==0 ) { \n', '            if(msg.sender == account_lock ){\n', '                if(now < gcStartTime + LOCKPERIOD){\n', '                    return false;\n', '                }\n', '            }\n', '            else{\n', '                balances[msg.sender].lcValue -= _value;\n', '                if(address(this)==_to)\n', '                {\n', '                    balances[creator].lcValue += _value;\n', '                }\n', '                else\n', '                {\n', '                    balances[_to].lcValue += _value;\n', '                }\n', '                Transfer(msg.sender, _to, _value);\n', '                return true;\n', '            }\n', '        \n', '        } \n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function endThisContact () {\n', '        if(msg.sender==creator && balances[msg.sender].lcValue >=9000000 * val4)\n', '        {\n', '            selfdestruct(creator);\n', '        }\n', '    }\n', '\n', '    // constructor\n', '    function LCToken( ) {\n', '        creator = msg.sender;\n', '        balances[account_team].lcValue = AMOUNT_TeamSupport;    //for team\n', '        balances[account_lock].lcValue = LOCKAMOUNT;            //30%   lock 365 days\n', '        gcStartTime = now;\n', '        gcEndTime=now+ICOPERIOD;\n', '\n', '\n', '        totalLotteryValue=0;\n', '\n', '        firstIndex=0;\n', '        endIndex=0;\n', '        blockhash[0] = block.blockhash(block.number-1);\n', '\n', '        shareTime=now+SHAREPERIOD;\n', '    }\n', '    \n', '\n', '    \n', '    // fallback\n', '    function() payable {\n', '        buyLC();\n', '    }\n', '\n', '}']
