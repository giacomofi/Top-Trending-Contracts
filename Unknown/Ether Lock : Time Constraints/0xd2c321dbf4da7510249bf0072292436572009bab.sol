['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '\n', '/// @title Long-Team Holding Incentive Program\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b4d0d5daddd1d8f4d8dbdbc4c6dddad39adbc6d3">[email&#160;protected]</a>>, Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b6064656c67626a656c4b6764647b7962656c2564796c">[email&#160;protected]</a>>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract LRCLongTermHoldingContract {\n', '    using SafeMath for uint;\n', '    using Math for uint;\n', '    \n', '    // During the first 60 days of deployment, this contract opens for deposit of LRC.\n', '    uint public constant DEPOSIT_PERIOD             = 60 days; // = 2 months\n', '\n', '    // 18 months after deposit, user can withdrawal all or part of his/her LRC with bonus.\n', '    // The bonus is this contract&#39;s initial LRC balance.\n', '    uint public constant WITHDRAWAL_DELAY           = 540 days; // = 1 year and 6 months\n', '\n', '    // This implies a 0.001ETH fee per 10000 LRC partial withdrawal;\n', '    // for a once-for-all withdrawal, the fee is 0.\n', '    uint public constant WITHDRAWAL_SCALE           = 1E7; // 1ETH for withdrawal of 10,000,000 LRC.\n', '    \n', '    address public lrcTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '\n', '    uint public lrcDeposited        = 0;\n', '    uint public depositStartTime    = 0;\n', '    uint public depositStopTime     = 0;\n', '\n', '    struct Record {\n', '        uint lrcAmount;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (address => Record) records;\n', '    \n', '    /* \n', '     * EVENTS\n', '     */\n', '\n', '    /// Emitted when program starts.\n', '    event Started(uint _time);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address indexed _addr, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address indexed _addr, uint _lrcAmount);\n', '\n', '    /// @dev Initialize the contract\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    function LRCLongTermHoldingContract(address _lrcTokenAddress, address _owner) {\n', '        require(_lrcTokenAddress != address(0));\n', '        require(_owner != address(0));\n', '\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev start the program.\n', '    function start() public {\n', '        require(msg.sender == owner);\n', '        require(depositStartTime == 0);\n', '\n', '        depositStartTime = now;\n', '        depositStopTime  = depositStartTime + DEPOSIT_PERIOD;\n', '\n', '        Started(depositStartTime);\n', '    }\n', '\n', '    function () payable {\n', '        require(depositStartTime > 0);\n', '\n', '        if (now >= depositStartTime && now <= depositStopTime) {\n', '            depositLRC();\n', '        } else if (now > depositStopTime){\n', '            withdrawLRC();\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @return Current LRC balance.\n', '    function lrcBalance() public constant returns (uint) {\n', '        return Token(lrcTokenAddress).balanceOf(address(this));\n', '    }\n', '\n', '    /// @dev Deposit LRC.\n', '    function depositLRC() payable {\n', '        require(depositStartTime > 0);\n', '        require(msg.value == 0);\n', '        require(now >= depositStartTime && now <= depositStopTime);\n', '        \n', '        var lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken\n', '            .balanceOf(msg.sender)\n', '            .min256(lrcToken.allowance(msg.sender, address(this)));\n', '\n', '        require(lrcAmount > 0);\n', '\n', '        var record = records[msg.sender];\n', '        record.lrcAmount += lrcAmount;\n', '        record.timestamp = now;\n', '        records[msg.sender] = record;\n', '\n', '        lrcDeposited += lrcAmount;\n', '\n', '        Deposit(depositId++, msg.sender, lrcAmount);\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount));\n', '    }\n', '\n', '    /// @dev Withdrawal LRC.\n', '    function withdrawLRC() payable {\n', '        require(depositStartTime > 0);\n', '        require(lrcDeposited > 0);\n', '\n', '        var record = records[msg.sender];\n', '        require(now >= record.timestamp + WITHDRAWAL_DELAY);\n', '        require(record.lrcAmount > 0);\n', '\n', '        uint lrcWithdrawalBase = record.lrcAmount;\n', '        if (msg.value > 0) {\n', '            lrcWithdrawalBase = lrcWithdrawalBase\n', '                .min256(msg.value.mul(WITHDRAWAL_SCALE));\n', '        }\n', '\n', '        uint lrcBonus = getBonus(lrcWithdrawalBase);\n', '        uint balance = lrcBalance();\n', '        uint lrcAmount = balance.min256(lrcWithdrawalBase + lrcBonus);\n', '        \n', '        lrcDeposited -= lrcWithdrawalBase;\n', '        record.lrcAmount -= lrcWithdrawalBase;\n', '\n', '        if (record.lrcAmount == 0) {\n', '            delete records[msg.sender];\n', '        } else {\n', '            records[msg.sender] = record;\n', '        }\n', '\n', '        Withdrawal(withdrawId++, msg.sender, lrcAmount);\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '    }\n', '\n', '    function getBonus(uint _lrcWithdrawalBase) constant returns (uint) {\n', '        return internalCalculateBonus(lrcBalance() - lrcDeposited,lrcDeposited, _lrcWithdrawalBase);\n', '    }\n', '\n', '    function internalCalculateBonus(uint _totalBonusRemaining, uint _lrcDeposited, uint _lrcWithdrawalBase) internal constant returns (uint) {\n', '        require(_lrcDeposited > 0);\n', '        require(_totalBonusRemaining >= 0);\n', '\n', '        // The bonus is non-linear function to incentivize later withdrawal.\n', '        // bonus = _totalBonusRemaining * power(_lrcWithdrawalBase/_lrcDeposited, 1.0625)\n', '        return _totalBonusRemaining\n', '            .mul(_lrcWithdrawalBase.mul(sqrt(sqrt(sqrt(sqrt(_lrcWithdrawalBase))))))\n', '            .div(_lrcDeposited.mul(sqrt(sqrt(sqrt(sqrt(_lrcDeposited))))));\n', '    }\n', '\n', '    function sqrt(uint x) internal constant returns (uint) {\n', '        uint y = x;\n', '        while (true) {\n', '            uint z = (y + (x / y)) / 2;\n', '            uint w = (z + (x / z)) / 2;\n', '            if (w == y) {\n', '                if (w < y) return w;\n', '                else return y;\n', '            }\n', '            y = w;\n', '        }\n', '    }\n', '}']