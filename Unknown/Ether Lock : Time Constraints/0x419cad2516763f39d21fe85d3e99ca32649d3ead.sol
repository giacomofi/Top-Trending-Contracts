['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @dev send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @dev send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @dev `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    /// Event for a successful transfer.\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    /// Event for a successful Approval.\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/// @title Mid-Team Holding Incentive Program\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b7d3d6d9ded2dbf7dbd8d8c7c5ded9d099d8c5d0">[email&#160;protected]</a>>, Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="791216171e151018171e39151616090b10171e57160b1e">[email&#160;protected]</a>>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract LRCMidTermHoldingContract {\n', '    using SafeMath for uint;\n', '\n', '    address public lrcTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '    uint    public rate             = 7500; \n', '\n', '    // Some stats\n', '    uint public lrcReceived         = 0;\n', '    uint public lrcSent             = 0;\n', '    uint public ethReceived         = 0;\n', '    uint public ethSent             = 0;\n', '\n', '    mapping (address => uint) lrcBalances; // each user&#39;s lrc balance\n', '    \n', '    /* \n', '     * EVENTS\n', '     */\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful withdrawal.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when ETH are drained and LRC are drained by owner.\n', '    event Drained(uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when rate changed by owner.\n', '    event RateChanged(uint _oldRate, uint _newRate);\n', '\n', '    /// CONSTRUCTOR \n', '    /// @dev Initialize and start the contract.\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    /// @param _owner Owner of this contract\n', '    function LRCMidTermHoldingContract(address _lrcTokenAddress, address _owner) {\n', '        require(_lrcTokenAddress != 0x0);\n', '        require(_owner != 0x0);\n', '\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param _rate New rate\n', '    function setRate(uint _rate) public  {\n', '        require(msg.sender == owner);\n', '        require(rate > 0);\n', '        \n', '        RateChanged(rate, _rate);\n', '        rate = _rate;\n', '    }\n', '\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param _ethAmount Amount of ETH to drain back to owner\n', '    function drain(uint _ethAmount) public payable {\n', '        require(msg.sender == owner);\n', '        require(_ethAmount >= 0);\n', '        \n', '        uint ethAmount = _ethAmount.min256(this.balance);\n', '        if (ethAmount > 0){\n', '            require(owner.send(ethAmount));\n', '        }\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken.balanceOf(address(this)) - lrcReceived + lrcSent;\n', '        if (lrcAmount > 0){\n', '            require(lrcToken.transfer(owner, lrcAmount));\n', '        }\n', '\n', '        Drained(ethAmount, lrcAmount);\n', '    }\n', '\n', '    /// @dev This default function allows simple usage.\n', '    function () payable {\n', '        if (msg.sender != owner) {\n', '            if (msg.value == 0) depositLRC();\n', '            else withdrawLRC();\n', '        }\n', '    }\n', '\n', '  \n', '    /// @dev Deposit LRC for ETH.\n', '    /// If user send x ETH, this method will try to transfer `x * 100 * 6500` LRC from\n', '    /// the user&#39;s address and send `x * 100` ETH to the user.\n', '    function depositLRC() payable {\n', '        require(msg.sender != owner);\n', '        require(msg.value == 0);\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '\n', '        uint lrcAmount = this.balance.mul(rate)\n', '            .min256(lrcToken.balanceOf(msg.sender))\n', '            .min256(lrcToken.allowance(msg.sender, address(this)));\n', '\n', '        uint ethAmount = lrcAmount.div(rate);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '        require(ethAmount.mul(rate) <= lrcAmount);\n', '\n', '        lrcBalances[msg.sender] += lrcAmount;\n', '\n', '        lrcReceived += lrcAmount;\n', '        ethSent += ethAmount;\n', '\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount));\n', '        require(msg.sender.send(ethAmount));\n', '\n', '        Deposit(\n', '             depositId++,\n', '             msg.sender,\n', '             ethAmount,\n', '             lrcAmount\n', '        );      \n', '    }\n', '\n', '    /// @dev Withdrawal LRC with ETH transfer.\n', '    function withdrawLRC() payable {\n', '        require(msg.sender != owner);\n', '        require(msg.value > 0);\n', '\n', '        uint lrcAmount = msg.value.mul(rate)\n', '            .min256(lrcBalances[msg.sender]);\n', '\n', '        uint ethAmount = lrcAmount.div(rate);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '\n', '        lrcBalances[msg.sender] -= lrcAmount;\n', '\n', '        lrcSent += lrcAmount;\n', '        ethReceived += ethAmount;\n', '\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '\n', '        uint ethRefund = msg.value - ethAmount;\n', '        if (ethRefund > 0) {\n', '            require(msg.sender.send(ethRefund));\n', '        }\n', '\n', '        Withdrawal(\n', '             withdrawId++,\n', '             msg.sender,\n', '             ethAmount,\n', '             lrcAmount\n', '        ); \n', '    }\n', '}']
['/*\n', '\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @dev send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @dev send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @dev `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    /// Event for a successful transfer.\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    /// Event for a successful Approval.\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/// @title Mid-Team Holding Incentive Program\n', '/// @author Daniel Wang - <daniel@loopring.org>, Kongliang Zhong - <kongliang@loopring.org>.\n', '/// For more information, please visit https://loopring.org.\n', 'contract LRCMidTermHoldingContract {\n', '    using SafeMath for uint;\n', '\n', '    address public lrcTokenAddress  = 0x0;\n', '    address public owner            = 0x0;\n', '    uint    public rate             = 7500; \n', '\n', '    // Some stats\n', '    uint public lrcReceived         = 0;\n', '    uint public lrcSent             = 0;\n', '    uint public ethReceived         = 0;\n', '    uint public ethSent             = 0;\n', '\n', "    mapping (address => uint) lrcBalances; // each user's lrc balance\n", '    \n', '    /* \n', '     * EVENTS\n', '     */\n', '    /// Emitted for each sucuessful deposit.\n', '    uint public depositId = 0;\n', '    event Deposit(uint _depositId, address _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted for each sucuessful withdrawal.\n', '    uint public withdrawId = 0;\n', '    event Withdrawal(uint _withdrawId, address _addr, uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when ETH are drained and LRC are drained by owner.\n', '    event Drained(uint _ethAmount, uint _lrcAmount);\n', '\n', '    /// Emitted when rate changed by owner.\n', '    event RateChanged(uint _oldRate, uint _newRate);\n', '\n', '    /// CONSTRUCTOR \n', '    /// @dev Initialize and start the contract.\n', '    /// @param _lrcTokenAddress LRC ERC20 token address\n', '    /// @param _owner Owner of this contract\n', '    function LRCMidTermHoldingContract(address _lrcTokenAddress, address _owner) {\n', '        require(_lrcTokenAddress != 0x0);\n', '        require(_owner != 0x0);\n', '\n', '        lrcTokenAddress = _lrcTokenAddress;\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param _rate New rate\n', '    function setRate(uint _rate) public  {\n', '        require(msg.sender == owner);\n', '        require(rate > 0);\n', '        \n', '        RateChanged(rate, _rate);\n', '        rate = _rate;\n', '    }\n', '\n', '    /// @dev Get back ETH to `owner`.\n', '    /// @param _ethAmount Amount of ETH to drain back to owner\n', '    function drain(uint _ethAmount) public payable {\n', '        require(msg.sender == owner);\n', '        require(_ethAmount >= 0);\n', '        \n', '        uint ethAmount = _ethAmount.min256(this.balance);\n', '        if (ethAmount > 0){\n', '            require(owner.send(ethAmount));\n', '        }\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '        uint lrcAmount = lrcToken.balanceOf(address(this)) - lrcReceived + lrcSent;\n', '        if (lrcAmount > 0){\n', '            require(lrcToken.transfer(owner, lrcAmount));\n', '        }\n', '\n', '        Drained(ethAmount, lrcAmount);\n', '    }\n', '\n', '    /// @dev This default function allows simple usage.\n', '    function () payable {\n', '        if (msg.sender != owner) {\n', '            if (msg.value == 0) depositLRC();\n', '            else withdrawLRC();\n', '        }\n', '    }\n', '\n', '  \n', '    /// @dev Deposit LRC for ETH.\n', '    /// If user send x ETH, this method will try to transfer `x * 100 * 6500` LRC from\n', "    /// the user's address and send `x * 100` ETH to the user.\n", '    function depositLRC() payable {\n', '        require(msg.sender != owner);\n', '        require(msg.value == 0);\n', '\n', '        var lrcToken = Token(lrcTokenAddress);\n', '\n', '        uint lrcAmount = this.balance.mul(rate)\n', '            .min256(lrcToken.balanceOf(msg.sender))\n', '            .min256(lrcToken.allowance(msg.sender, address(this)));\n', '\n', '        uint ethAmount = lrcAmount.div(rate);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '        require(ethAmount.mul(rate) <= lrcAmount);\n', '\n', '        lrcBalances[msg.sender] += lrcAmount;\n', '\n', '        lrcReceived += lrcAmount;\n', '        ethSent += ethAmount;\n', '\n', '        require(lrcToken.transferFrom(msg.sender, address(this), lrcAmount));\n', '        require(msg.sender.send(ethAmount));\n', '\n', '        Deposit(\n', '             depositId++,\n', '             msg.sender,\n', '             ethAmount,\n', '             lrcAmount\n', '        );      \n', '    }\n', '\n', '    /// @dev Withdrawal LRC with ETH transfer.\n', '    function withdrawLRC() payable {\n', '        require(msg.sender != owner);\n', '        require(msg.value > 0);\n', '\n', '        uint lrcAmount = msg.value.mul(rate)\n', '            .min256(lrcBalances[msg.sender]);\n', '\n', '        uint ethAmount = lrcAmount.div(rate);\n', '\n', '        require(lrcAmount > 0 && ethAmount > 0);\n', '\n', '        lrcBalances[msg.sender] -= lrcAmount;\n', '\n', '        lrcSent += lrcAmount;\n', '        ethReceived += ethAmount;\n', '\n', '        require(Token(lrcTokenAddress).transfer(msg.sender, lrcAmount));\n', '\n', '        uint ethRefund = msg.value - ethAmount;\n', '        if (ethRefund > 0) {\n', '            require(msg.sender.send(ethRefund));\n', '        }\n', '\n', '        Withdrawal(\n', '             withdrawId++,\n', '             msg.sender,\n', '             ethAmount,\n', '             lrcAmount\n', '        ); \n', '    }\n', '}']
