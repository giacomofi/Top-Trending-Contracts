['pragma solidity ^0.4.11;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', '\n', 'contract queue {\n', '    Queue public q;\n', '\n', '    struct BuyTicket {\n', '        address account;\n', '        uint amount;\n', '        uint time;\n', '    }\n', '\n', '    struct Queue {\n', '        BuyTicket[] data;\n', '        uint front;\n', '        uint back;\n', '    }\n', '\n', '    function queueSize() constant returns (uint r) {\n', '        r = q.back - q.front;\n', '    }\n', '\n', '    function queue() {\n', '        q.data.length = 600000;\n', '    }\n', '\n', '    function pushQueue(BuyTicket ticket) internal {\n', '        require((q.back + 1) % q.data.length != q.front);\n', '\n', '        q.data[q.back] = ticket;\n', '        q.back = (q.back + 1) % q.data.length;\n', '    }\n', '\n', '    function peekQueue() internal returns (BuyTicket r) {\n', '        require(q.back != q.front);\n', '\n', '        r = q.data[q.front];\n', '    }\n', '\n', '    function popQueue() internal {\n', '        require(q.back != q.front);\n', '\n', '        delete q.data[q.front];\n', '        q.front = (q.front + 1) % q.data.length;\n', '    }\n', '}\n', '\n', 'contract DeCenterToken is owned, queue, DSMath {\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;DeCenter&#39;;\n', '    string public symbol = &#39;DC&#39;;\n', '    uint8 public decimals = 8;\n', '\n', '    uint256 public totalSupply = 10000000000000000; // 100 million\n', '    uint256 public availableTokens = 6000000000000000; // 60 million\n', '    uint256 public teamAndExpertsTokens = 4000000000000000; // 40 million\n', '    uint256 public price = 0.0000000001 ether; // 0.01 ether per token\n', '\n', '    uint public startTime;\n', '    uint public refundStartTime;\n', '    uint public refundDuration = 3 days; // 3 years\n', '    uint public firstStageDuration = 3 days; // 31 days\n', '    uint public lastScheduledTopUp;\n', '    uint public lastProcessedDay = 3;\n', '\n', '    uint public maxDailyCap = 3333300000000; // 33 333 DC\n', '    mapping (uint => uint) public dailyTotals;\n', '\n', '    uint public queuedAmount;\n', '\n', '    address public beneficiary;\n', '    address public expertsAccount;\n', '    address public teamAccount;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // for testing\n', '    uint public cTime = 0;\n', '    function setCTime(uint _cTime) onlyOwner {\n', '        cTime = _cTime;\n', '    }\n', '\n', '    function DeCenterToken(\n', '    address _beneficiary,\n', '    address _expertsAccount,\n', '    address _teamAccount,\n', '    uint _startTime,\n', '    uint _refundStartTime\n', '    ) {\n', '        beneficiary = _beneficiary;\n', '        expertsAccount = _expertsAccount;\n', '        teamAccount = _teamAccount;\n', '\n', '        startTime = _startTime;\n', '        refundStartTime = _refundStartTime;\n', '\n', '        balanceOf[this] = totalSupply;\n', '\n', '        scheduledTopUp();\n', '    }\n', '\n', '    function time() constant returns (uint) {\n', '        // for testing\n', '        if(cTime > 0) {\n', '            return cTime;\n', '        }\n', '\n', '        return block.timestamp;\n', '    }\n', '\n', '    function today() constant returns (uint) {\n', '        return dayFor(time());\n', '    }\n', '\n', '    function dayFor(uint timestamp) constant returns (uint) {\n', '        return sub(timestamp, startTime) / 24 hours;\n', '    }\n', '\n', '    function lowerLimitForToday() constant returns (uint) {\n', '        return today() * 1 ether;\n', '    }\n', '\n', '    function scheduledTopUp() onlyOwner {\n', '        uint payment = 400000000000000; // 4 million tokens\n', '\n', '        require(sub(time(), lastScheduledTopUp) >= 1 years);\n', '        require(teamAndExpertsTokens >= payment * 2);\n', '\n', '        lastScheduledTopUp = time();\n', '\n', '        teamAndExpertsTokens -= payment;\n', '        balanceOf[this] = sub(balanceOf[this], payment);\n', '        balanceOf[expertsAccount] = add(balanceOf[expertsAccount], payment);\n', '\n', '        teamAndExpertsTokens -= payment;\n', '        balanceOf[this] = sub(balanceOf[this], payment);\n', '        balanceOf[teamAccount] = add(balanceOf[teamAccount], payment);\n', '\n', '        Transfer(this, expertsAccount, payment); // execute an event reflecting the change\n', '        Transfer(this, teamAccount, payment); // execute an event reflecting the change\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        return true;\n', '    }\n', '\n', '    function refund(uint256 _value) internal {\n', '        require(time() > refundStartTime);\n', '        require(this.balance >= _value * price);\n', '\n', '        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\n', '        balanceOf[this] = add(balanceOf[this], _value);\n', '        availableTokens = add(availableTokens, _value);\n', '\n', '        msg.sender.transfer(_value * price);\n', '\n', '        Transfer(msg.sender, this, _value); // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    /* Send tokens */\n', '    function transfer(address _to, uint256 _value) {\n', '        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n', '\n', '        if (_to == address(this)) {\n', '            refund(_value);\n', '            return;\n', '        }\n', '\n', '        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\n', '        balanceOf[_to] = add(balanceOf[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    /* A contract attempts to get the tokens */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(balanceOf[_from] >= _value); // Check if the sender has enough\n', '        require(_value <= allowance[_from][msg.sender]); // Check allowance\n', '\n', '        allowance[_from][msg.sender] = sub(allowance[_from][msg.sender], _value); //  Subtract from the allowance\n', '        balanceOf[_from] = sub(balanceOf[_from], _value); // Subtract from the sender\n', '        balanceOf[_to] = add(balanceOf[_to], _value); // Add the same to the recipient\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function closeRefund() onlyOwner {\n', '        require(time() - refundStartTime > refundDuration);\n', '\n', '        beneficiary.transfer(this.balance);\n', '    }\n', '\n', '    /*\n', '     *    Token purchasing has 2 stages:\n', '     *       - First stage holds 31 days. There is no limit of buying.\n', '     *       - Second stage holds ~5 years after. There will be limit of 333.33 ether per day.\n', '     */\n', '    function buy() payable {\n', '        require(startTime <= time()); // check if ICO is going\n', '\n', '        uint amount = div(msg.value, price);\n', '\n', '        if (time() - startTime > firstStageDuration) { // second stage\n', '            require(1 ether <= msg.value); // check min. limit\n', '            require(msg.value <= 300 ether); // check max. limit\n', '\n', '            // send 80% to beneficiary account, another 20% stays for refunding\n', '            beneficiary.transfer(mul(div(msg.value, 5), 4));\n', '\n', '            uint currentDay = lastProcessedDay + 1;\n', '            uint limit = maxDailyCap - dailyTotals[currentDay];\n', '\n', '            if (limit >= amount) {\n', '                availableTokens = sub(availableTokens, amount);\n', '                balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller&#39;s balance\n', '                dailyTotals[currentDay] = add(dailyTotals[currentDay], amount);\n', '                balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer&#39;s balance\n', '\n', '                Transfer(this, msg.sender, amount); // execute an event reflecting the change\n', '            } else {\n', '                queuedAmount = add(queuedAmount, amount);\n', '                require(queuedAmount <= availableTokens);\n', '                BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()});\n', '                pushQueue(ticket);\n', '            }\n', '\n', '        } else { // first stage\n', '            require(lowerLimitForToday() <= msg.value); // check min. limit\n', '            require(amount <= availableTokens);\n', '\n', '            // send 80% to beneficiary account, another 20% stays for refunding\n', '            beneficiary.transfer(mul(div(msg.value, 5), 4));\n', '\n', '            availableTokens = sub(availableTokens, amount);\n', '            balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller&#39;s balance\n', '            balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer&#39;s balance\n', '\n', '            Transfer(this, msg.sender, amount); // execute an event reflecting the change\n', '        }\n', '    }\n', '\n', '    function processPendingTickets() onlyOwner {\n', '\n', '        uint size = queueSize();\n', '        uint ptr = 0;\n', '        uint currentDay;\n', '        uint limit;\n', '        BuyTicket memory ticket;\n', '\n', '        while (ptr < size) {\n', '            currentDay = lastProcessedDay + 1;\n', '            limit = maxDailyCap - dailyTotals[currentDay];\n', '\n', '            // stop then trying to process future\n', '            if (startTime + (currentDay - 1) * 1 days > time()) {\n', '                return;\n', '            }\n', '\n', '            // limit to prevent out of gas error\n', '            if (ptr > 50) {\n', '                return;\n', '            }\n', '\n', '            ticket = peekQueue();\n', '\n', '            if (limit < ticket.amount || ticket.time - 1000 seconds > startTime + (currentDay - 1) * 1 days) {\n', '                lastProcessedDay += 1;\n', '                continue;\n', '            }\n', '\n', '            popQueue();\n', '            ptr += 1;\n', '\n', '            availableTokens = sub(availableTokens, ticket.amount);\n', '            queuedAmount = sub(queuedAmount, ticket.amount);\n', '            dailyTotals[currentDay] = add(dailyTotals[currentDay], ticket.amount);\n', '            balanceOf[this] = sub(balanceOf[this], ticket.amount);\n', '            balanceOf[ticket.account] = add(balanceOf[ticket.account], ticket.amount); // adds the amount to buyer&#39;s balance\n', '\n', '            Transfer(this, ticket.account, ticket.amount); // execute an event reflecting the change\n', '        }\n', '    }\n', '\n', '    function() payable {\n', '        buy();\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', '\n', 'contract queue {\n', '    Queue public q;\n', '\n', '    struct BuyTicket {\n', '        address account;\n', '        uint amount;\n', '        uint time;\n', '    }\n', '\n', '    struct Queue {\n', '        BuyTicket[] data;\n', '        uint front;\n', '        uint back;\n', '    }\n', '\n', '    function queueSize() constant returns (uint r) {\n', '        r = q.back - q.front;\n', '    }\n', '\n', '    function queue() {\n', '        q.data.length = 600000;\n', '    }\n', '\n', '    function pushQueue(BuyTicket ticket) internal {\n', '        require((q.back + 1) % q.data.length != q.front);\n', '\n', '        q.data[q.back] = ticket;\n', '        q.back = (q.back + 1) % q.data.length;\n', '    }\n', '\n', '    function peekQueue() internal returns (BuyTicket r) {\n', '        require(q.back != q.front);\n', '\n', '        r = q.data[q.front];\n', '    }\n', '\n', '    function popQueue() internal {\n', '        require(q.back != q.front);\n', '\n', '        delete q.data[q.front];\n', '        q.front = (q.front + 1) % q.data.length;\n', '    }\n', '}\n', '\n', 'contract DeCenterToken is owned, queue, DSMath {\n', "    string public standard = 'Token 0.1';\n", "    string public name = 'DeCenter';\n", "    string public symbol = 'DC';\n", '    uint8 public decimals = 8;\n', '\n', '    uint256 public totalSupply = 10000000000000000; // 100 million\n', '    uint256 public availableTokens = 6000000000000000; // 60 million\n', '    uint256 public teamAndExpertsTokens = 4000000000000000; // 40 million\n', '    uint256 public price = 0.0000000001 ether; // 0.01 ether per token\n', '\n', '    uint public startTime;\n', '    uint public refundStartTime;\n', '    uint public refundDuration = 3 days; // 3 years\n', '    uint public firstStageDuration = 3 days; // 31 days\n', '    uint public lastScheduledTopUp;\n', '    uint public lastProcessedDay = 3;\n', '\n', '    uint public maxDailyCap = 3333300000000; // 33 333 DC\n', '    mapping (uint => uint) public dailyTotals;\n', '\n', '    uint public queuedAmount;\n', '\n', '    address public beneficiary;\n', '    address public expertsAccount;\n', '    address public teamAccount;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // for testing\n', '    uint public cTime = 0;\n', '    function setCTime(uint _cTime) onlyOwner {\n', '        cTime = _cTime;\n', '    }\n', '\n', '    function DeCenterToken(\n', '    address _beneficiary,\n', '    address _expertsAccount,\n', '    address _teamAccount,\n', '    uint _startTime,\n', '    uint _refundStartTime\n', '    ) {\n', '        beneficiary = _beneficiary;\n', '        expertsAccount = _expertsAccount;\n', '        teamAccount = _teamAccount;\n', '\n', '        startTime = _startTime;\n', '        refundStartTime = _refundStartTime;\n', '\n', '        balanceOf[this] = totalSupply;\n', '\n', '        scheduledTopUp();\n', '    }\n', '\n', '    function time() constant returns (uint) {\n', '        // for testing\n', '        if(cTime > 0) {\n', '            return cTime;\n', '        }\n', '\n', '        return block.timestamp;\n', '    }\n', '\n', '    function today() constant returns (uint) {\n', '        return dayFor(time());\n', '    }\n', '\n', '    function dayFor(uint timestamp) constant returns (uint) {\n', '        return sub(timestamp, startTime) / 24 hours;\n', '    }\n', '\n', '    function lowerLimitForToday() constant returns (uint) {\n', '        return today() * 1 ether;\n', '    }\n', '\n', '    function scheduledTopUp() onlyOwner {\n', '        uint payment = 400000000000000; // 4 million tokens\n', '\n', '        require(sub(time(), lastScheduledTopUp) >= 1 years);\n', '        require(teamAndExpertsTokens >= payment * 2);\n', '\n', '        lastScheduledTopUp = time();\n', '\n', '        teamAndExpertsTokens -= payment;\n', '        balanceOf[this] = sub(balanceOf[this], payment);\n', '        balanceOf[expertsAccount] = add(balanceOf[expertsAccount], payment);\n', '\n', '        teamAndExpertsTokens -= payment;\n', '        balanceOf[this] = sub(balanceOf[this], payment);\n', '        balanceOf[teamAccount] = add(balanceOf[teamAccount], payment);\n', '\n', '        Transfer(this, expertsAccount, payment); // execute an event reflecting the change\n', '        Transfer(this, teamAccount, payment); // execute an event reflecting the change\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        return true;\n', '    }\n', '\n', '    function refund(uint256 _value) internal {\n', '        require(time() > refundStartTime);\n', '        require(this.balance >= _value * price);\n', '\n', '        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\n', '        balanceOf[this] = add(balanceOf[this], _value);\n', '        availableTokens = add(availableTokens, _value);\n', '\n', '        msg.sender.transfer(_value * price);\n', '\n', '        Transfer(msg.sender, this, _value); // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    /* Send tokens */\n', '    function transfer(address _to, uint256 _value) {\n', '        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n', '\n', '        if (_to == address(this)) {\n', '            refund(_value);\n', '            return;\n', '        }\n', '\n', '        balanceOf[msg.sender] = sub(balanceOf[msg.sender], _value);\n', '        balanceOf[_to] = add(balanceOf[_to], _value);\n', '\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    /* A contract attempts to get the tokens */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(balanceOf[_from] >= _value); // Check if the sender has enough\n', '        require(_value <= allowance[_from][msg.sender]); // Check allowance\n', '\n', '        allowance[_from][msg.sender] = sub(allowance[_from][msg.sender], _value); //  Subtract from the allowance\n', '        balanceOf[_from] = sub(balanceOf[_from], _value); // Subtract from the sender\n', '        balanceOf[_to] = add(balanceOf[_to], _value); // Add the same to the recipient\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function closeRefund() onlyOwner {\n', '        require(time() - refundStartTime > refundDuration);\n', '\n', '        beneficiary.transfer(this.balance);\n', '    }\n', '\n', '    /*\n', '     *    Token purchasing has 2 stages:\n', '     *       - First stage holds 31 days. There is no limit of buying.\n', '     *       - Second stage holds ~5 years after. There will be limit of 333.33 ether per day.\n', '     */\n', '    function buy() payable {\n', '        require(startTime <= time()); // check if ICO is going\n', '\n', '        uint amount = div(msg.value, price);\n', '\n', '        if (time() - startTime > firstStageDuration) { // second stage\n', '            require(1 ether <= msg.value); // check min. limit\n', '            require(msg.value <= 300 ether); // check max. limit\n', '\n', '            // send 80% to beneficiary account, another 20% stays for refunding\n', '            beneficiary.transfer(mul(div(msg.value, 5), 4));\n', '\n', '            uint currentDay = lastProcessedDay + 1;\n', '            uint limit = maxDailyCap - dailyTotals[currentDay];\n', '\n', '            if (limit >= amount) {\n', '                availableTokens = sub(availableTokens, amount);\n', "                balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller's balance\n", '                dailyTotals[currentDay] = add(dailyTotals[currentDay], amount);\n', "                balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer's balance\n", '\n', '                Transfer(this, msg.sender, amount); // execute an event reflecting the change\n', '            } else {\n', '                queuedAmount = add(queuedAmount, amount);\n', '                require(queuedAmount <= availableTokens);\n', '                BuyTicket memory ticket = BuyTicket({account: msg.sender, amount: amount, time: time()});\n', '                pushQueue(ticket);\n', '            }\n', '\n', '        } else { // first stage\n', '            require(lowerLimitForToday() <= msg.value); // check min. limit\n', '            require(amount <= availableTokens);\n', '\n', '            // send 80% to beneficiary account, another 20% stays for refunding\n', '            beneficiary.transfer(mul(div(msg.value, 5), 4));\n', '\n', '            availableTokens = sub(availableTokens, amount);\n', "            balanceOf[this] = sub(balanceOf[this], amount); // subtracts amount from seller's balance\n", "            balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); // adds the amount to buyer's balance\n", '\n', '            Transfer(this, msg.sender, amount); // execute an event reflecting the change\n', '        }\n', '    }\n', '\n', '    function processPendingTickets() onlyOwner {\n', '\n', '        uint size = queueSize();\n', '        uint ptr = 0;\n', '        uint currentDay;\n', '        uint limit;\n', '        BuyTicket memory ticket;\n', '\n', '        while (ptr < size) {\n', '            currentDay = lastProcessedDay + 1;\n', '            limit = maxDailyCap - dailyTotals[currentDay];\n', '\n', '            // stop then trying to process future\n', '            if (startTime + (currentDay - 1) * 1 days > time()) {\n', '                return;\n', '            }\n', '\n', '            // limit to prevent out of gas error\n', '            if (ptr > 50) {\n', '                return;\n', '            }\n', '\n', '            ticket = peekQueue();\n', '\n', '            if (limit < ticket.amount || ticket.time - 1000 seconds > startTime + (currentDay - 1) * 1 days) {\n', '                lastProcessedDay += 1;\n', '                continue;\n', '            }\n', '\n', '            popQueue();\n', '            ptr += 1;\n', '\n', '            availableTokens = sub(availableTokens, ticket.amount);\n', '            queuedAmount = sub(queuedAmount, ticket.amount);\n', '            dailyTotals[currentDay] = add(dailyTotals[currentDay], ticket.amount);\n', '            balanceOf[this] = sub(balanceOf[this], ticket.amount);\n', "            balanceOf[ticket.account] = add(balanceOf[ticket.account], ticket.amount); // adds the amount to buyer's balance\n", '\n', '            Transfer(this, ticket.account, ticket.amount); // execute an event reflecting the change\n', '        }\n', '    }\n', '\n', '    function() payable {\n', '        buy();\n', '    }\n', '}']
