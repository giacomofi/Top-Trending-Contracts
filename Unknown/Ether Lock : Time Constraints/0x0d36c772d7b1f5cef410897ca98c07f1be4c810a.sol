['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address newOwner;\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            newOwner = _newOwner;\n', '        }\n', '    }\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract ERC20 is Ownable {\n', '    /* Public variables of the token */\n', '    string public standard;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public initialSupply;\n', '    bool public locked;\n', '    uint256 public creationBlock;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length == numwords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function ERC20(\n', '    uint256 _initialSupply,\n', '    string tokenName,\n', '    uint8 decimalUnits,\n', '    string tokenSymbol,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) {\n', "        standard = 'ERC20 0.1';\n", '\n', '        initialSupply = _initialSupply;\n', '\n', '        if (transferAllSupplyToOwner) {\n', '            setBalance(msg.sender, initialSupply);\n', '        }\n', '        else {\n', '            setBalance(this, initialSupply);\n', '        }\n', '\n', '        name = tokenName;\n', '        // Set the name for display purposes\n', '        symbol = tokenSymbol;\n', '        // Set the symbol for display purposes\n', '        decimals = decimalUnits;\n', '        // Amount of decimals for display purposes\n', '        locked = _locked;\n', '        creationBlock = block.number;\n', '    }\n', '\n', '    /* internal balances */\n', '\n', '    function setBalance(address holder, uint256 amount) internal {\n', '        balances[holder] = amount;\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 value) internal returns (bool success) {\n', '        if (value == 0) {\n', '            return true;\n', '        }\n', '\n', '        if (balances[_from] < value) {\n', '            return false;\n', '        }\n', '\n', '        if (balances[_to] + value <= balances[_to]) {\n', '            return false;\n', '        }\n', '\n', '        setBalance(_from, balances[_from] - value);\n', '        setBalance(_to, balances[_to] + value);\n', '\n', '        Transfer(_from, _to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* public methods */\n', '    function totalSupply() public returns (uint256) {\n', '        return initialSupply;\n', '    }\n', '\n', '    function balanceOf(address _address) public returns (uint256) {\n', '        return balances[_address];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool) {\n', '        require(locked == false);\n', '\n', '        bool status = transferInternal(msg.sender, _to, _value);\n', '\n', '        require(status == true);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        if (locked) {\n', '            return false;\n', '        }\n', '\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (locked) {\n', '            return false;\n', '        }\n', '\n', '        if (allowance[_from][msg.sender] < _value) {\n', '            return false;\n', '        }\n', '\n', '        bool _success = transferInternal(_from, _to, _value);\n', '\n', '        if (_success) {\n', '            allowance[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        return _success;\n', '    }\n', '\n', '}\n', '\n', 'contract MintingERC20 is ERC20 {\n', '\n', '    mapping (address => bool) public minters;\n', '\n', '    uint256 public maxSupply;\n', '\n', '    function MintingERC20(\n', '    uint256 _initialSupply,\n', '    uint256 _maxSupply,\n', '    string _tokenName,\n', '    uint8 _decimals,\n', '    string _symbol,\n', '    bool _transferAllSupplyToOwner,\n', '    bool _locked\n', '    )\n', '    ERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\n', '\n', '    {\n', '        standard = "MintingERC20 0.1";\n', '        minters[msg.sender] = true;\n', '        maxSupply = _maxSupply;\n', '    }\n', '\n', '\n', '    function addMinter(address _newMinter) onlyOwner {\n', '        minters[_newMinter] = true;\n', '    }\n', '\n', '\n', '    function removeMinter(address _minter) onlyOwner {\n', '        minters[_minter] = false;\n', '    }\n', '\n', '\n', '    function mint(address _addr, uint256 _amount) onlyMinters returns (uint256) {\n', '        if (locked == true) {\n', '            return uint256(0);\n', '        }\n', '\n', '        if (_amount == uint256(0)) {\n', '            return uint256(0);\n', '        }\n', '        if (initialSupply + _amount <= initialSupply){\n', '            return uint256(0);\n', '        }\n', '        if (initialSupply + _amount > maxSupply) {\n', '            return uint256(0);\n', '        }\n', '\n', '        initialSupply += _amount;\n', '        balances[_addr] += _amount;\n', '        Transfer(this, _addr, _amount);\n', '        return _amount;\n', '    }\n', '\n', '\n', '    modifier onlyMinters () {\n', '        require(true == minters[msg.sender]);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Lamden is MintingERC20 {\n', '\n', '\n', '    uint8 public decimals = 18;\n', '\n', '    string public tokenName = "Lamden Tau";\n', '\n', '    string public tokenSymbol = "TAU";\n', '\n', '    uint256 public  maxSupply = 500 * 10 ** 6 * uint(10) ** decimals; // 500,000,000\n', '\n', '    // We block token transfers till ICO end.\n', '    bool public transferFrozen = true;\n', '\n', '    function Lamden(\n', '    uint256 initialSupply,\n', '    bool _locked\n', '    ) MintingERC20(initialSupply, maxSupply, tokenName, decimals, tokenSymbol, false, _locked) {\n', "        standard = 'Lamden 0.1';\n", '    }\n', '\n', '    function setLocked(bool _locked) onlyOwner {\n', '        locked = _locked;\n', '    }\n', '\n', '    // Allow token transfer.\n', '    function freezing(bool _transferFrozen) onlyOwner {\n', '        transferFrozen = _transferFrozen;\n', '    }\n', '\n', '    // ERC20 functions\n', '    // =========================\n', '\n', '    function transfer(address _to, uint _value) returns (bool) {\n', '        require(!transferFrozen);\n', '        return super.transfer(_to, _value);\n', '\n', '    }\n', '\n', '    // should  not have approve/transferFrom\n', '    function approve(address, uint) returns (bool success)  {\n', '        require(false);\n', '        return false;\n', '        //        super.approve(_spender, _value);\n', '    }\n', '\n', '    function approveAndCall(address, uint256, bytes) returns (bool success) {\n', '        require(false);\n', '        return false;\n', '    }\n', '\n', '    function transferFrom(address, address, uint)  returns (bool success) {\n', '        require(false);\n', '        return false;\n', '        //        super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', 'contract LamdenTokenAllocation is Ownable {\n', '\n', '    Lamden public tau;\n', '\n', '    uint256 public constant LAMDEN_DECIMALS = 10 ** 18;\n', '\n', '    uint256 allocatedTokens = 0;\n', '\n', '    Allocation[] allocations;\n', '\n', '    struct Allocation {\n', '    address _address;\n', '    uint256 amount;\n', '    }\n', '\n', '\n', '    function LamdenTokenAllocation(\n', '    address _tau,\n', '    address[] addresses\n', '    ){\n', '        require(uint8(addresses.length) == uint8(14));\n', '        allocations.push(Allocation(addresses[0], 20000000 * LAMDEN_DECIMALS)); //Stu\n', '        allocations.push(Allocation(addresses[1], 12500000 * LAMDEN_DECIMALS)); //Nick\n', '        allocations.push(Allocation(addresses[2], 8750000 * LAMDEN_DECIMALS)); //James\n', '        allocations.push(Allocation(addresses[3], 8750000 * LAMDEN_DECIMALS)); //Mario\n', '        allocations.push(Allocation(addresses[4], 250000 * LAMDEN_DECIMALS));     // Advisor\n', '        allocations.push(Allocation(addresses[5], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[6], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[7], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[8], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[9], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[10], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[11], 250000 * LAMDEN_DECIMALS));  // Advisor\n', '        allocations.push(Allocation(addresses[12], 48000000 * LAMDEN_DECIMALS));  // enterpriseCaseStudies\n', '        allocations.push(Allocation(addresses[13], 50000000  * LAMDEN_DECIMALS));  // AKA INNOVATION FUND\n', '        tau = Lamden(_tau);\n', '    }\n', '\n', '    function allocateTokens(){\n', '        require(uint8(allocations.length) == uint8(14));\n', '        require(address(tau) != 0x0);\n', '        require(allocatedTokens == 0);\n', '        for (uint8 i = 0; i < allocations.length; i++) {\n', '            Allocation storage allocation = allocations[i];\n', '            uint256 mintedAmount = tau.mint(allocation._address, allocation.amount);\n', '            require(mintedAmount == allocation.amount);\n', '            allocatedTokens += allocation.amount;\n', '        }\n', '    }\n', '\n', '    function setTau(address _tau) onlyOwner {\n', '        tau = Lamden(_tau);\n', '    }\n', '}']