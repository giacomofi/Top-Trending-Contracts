['pragma solidity ^0.4.13;\n', '\n', 'contract BTCRelay {\n', '    function getLastBlockHeight() returns (int);\n', '    function getBlockchainHead() returns (int);\n', '    function getFeeAmount(int blockHash) returns (int);\n', '    function getBlockHeader(int blockHash) returns (bytes32[3]);\n', '}\n', '\n', 'contract PoissonData {\n', '    function lookup(int blocks) constant returns (uint);\n', '}\n', '\n', 'contract Escrow {\n', '    function deposit(address recipient) payable;\n', '}\n', '\n', 'contract EthereumLottery {\n', '    uint constant INACTIVITY_TIMEOUT = 2 weeks;\n', '    uint constant GAS_LIMIT = 300000;\n', '\n', '    struct Lottery {\n', '        uint jackpot;\n', '        int decidingBlock;\n', '        uint numTickets;\n', '        uint numTicketsSold;\n', '        uint ticketPrice;\n', '        uint cutoffTimestamp;\n', '        int winningTicket;\n', '        address winner;\n', '        uint finalizationBlock;\n', '        address finalizer;\n', '        string message;\n', '        mapping (uint => address) tickets;\n', '        int nearestKnownBlock;\n', '        int nearestKnownBlockHash;\n', '    }\n', '\n', '    address public owner;\n', '    address public admin;\n', '    address public proposedOwner;\n', '\n', '    int public id = -1;\n', '    uint public lastInitTimestamp;\n', '    uint public lastSaleTimestamp;\n', '\n', '    uint public recentActivityIdx;\n', '    uint[1000] public recentActivity;\n', '\n', '    mapping (int => Lottery) public lotteries;\n', '\n', '    address public btcRelay;\n', '    address public poissonData;\n', '    address public escrow;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdminOrOwner {\n', '        require(msg.sender == owner || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier afterInitialization {\n', '        require(id >= 0);\n', '        _;\n', '    }\n', '\n', '    function EthereumLottery(address _btcRelay,\n', '                             address _poissonData,\n', '                             address _escrow) {\n', '        owner = msg.sender;\n', '        admin = msg.sender;\n', '        btcRelay = _btcRelay;\n', '        poissonData = _poissonData;\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function needsInitialization() constant returns (bool) {\n', '        return id == -1 || lotteries[id].finalizationBlock > 0;\n', '    }\n', '\n', '    function initLottery(uint _jackpot, uint _numTickets,\n', '                         uint _ticketPrice, int _durationInBlocks)\n', '             payable onlyAdminOrOwner {\n', '        require(needsInitialization());\n', '        require(msg.value > 0);\n', '        require(msg.value == _jackpot);\n', '        require(_numTickets * _ticketPrice > _jackpot);\n', '\n', '        // Look up precomputed timespan in seconds where the\n', '        // probability for n or more blocks occuring within\n', '        // that timespan is just 1 %. This is based on\n', '        // assuming an actual block time of 9 minutes. We\n', '        // can use this data to figure out for how long it\n', '        // is safe to keep selling tickets.\n', '        uint ticketSaleDuration =\n', '            PoissonData(poissonData).lookup(_durationInBlocks - 1);\n', '        require(ticketSaleDuration > 0);\n', '\n', '        id += 1;\n', '        lotteries[id].jackpot = _jackpot;\n', '        lotteries[id].decidingBlock =\n', '            BTCRelay(btcRelay).getLastBlockHeight() + _durationInBlocks;\n', '        lotteries[id].numTickets = _numTickets;\n', '        lotteries[id].ticketPrice = _ticketPrice;\n', '        lotteries[id].cutoffTimestamp = now + ticketSaleDuration;\n', '        lotteries[id].winningTicket = -1;\n', '\n', '        lastInitTimestamp = now;\n', '    }\n', '\n', '    function buyTickets(uint[] _tickets)\n', '             payable afterInitialization {\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        require(blockHeight + 1 < lotteries[id].decidingBlock);\n', '        require(now < lotteries[id].cutoffTimestamp);\n', '\n', '        require(_tickets.length > 0);\n', '        require(msg.value == _tickets.length * lotteries[id].ticketPrice);\n', '\n', '        for (uint i = 0; i < _tickets.length; i++) {\n', '            uint ticket = _tickets[i];\n', '            require(ticket >= 0);\n', '            require(ticket < lotteries[id].numTickets);\n', '            require(lotteries[id].tickets[ticket] == 0);\n', '\n', '            lotteries[id].tickets[ticket] = msg.sender;\n', '            recentActivity[recentActivityIdx] = ticket;\n', '\n', '            recentActivityIdx += 1;\n', '            if (recentActivityIdx >= recentActivity.length) {\n', '                recentActivityIdx = 0;\n', '            }\n', '        }\n', '        lotteries[id].numTicketsSold += _tickets.length;\n', '        lastSaleTimestamp = now;\n', '\n', '        // Maybe shorten ticket sale timespan if we are running ahead.\n', '        int remainingDurationInBlocks =\n', '            lotteries[id].decidingBlock - blockHeight;\n', '        uint ticketSaleDuration =\n', '            PoissonData(poissonData).lookup(remainingDurationInBlocks - 1);\n', '        if (now + ticketSaleDuration < lotteries[id].cutoffTimestamp) {\n', '            lotteries[id].cutoffTimestamp = now + ticketSaleDuration;\n', '        }\n', '    }\n', '\n', '    function needsFinalization()\n', '             afterInitialization constant returns (bool) {\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        return blockHeight >= lotteries[id].decidingBlock + 6 &&\n', '               lotteries[id].finalizationBlock == 0;\n', '    }\n', '\n', '    function finalizeLottery(uint _steps)\n', '             afterInitialization {\n', '        require(needsFinalization());\n', '\n', '        if (lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock) {\n', '            walkTowardsBlock(_steps);\n', '        } else {\n', '            int winningTicket = lotteries[id].nearestKnownBlockHash %\n', '                                int(lotteries[id].numTickets);\n', '            address winner = lotteries[id].tickets[uint(winningTicket)];\n', '\n', '            lotteries[id].winningTicket = winningTicket;\n', '            lotteries[id].winner = winner;\n', '            lotteries[id].finalizationBlock = block.number;\n', '            lotteries[id].finalizer = tx.origin;\n', '\n', '            if (winner != 0) {\n', '                uint value = lotteries[id].jackpot;\n', '                bool successful = winner.call.gas(GAS_LIMIT).value(value)();\n', '                if (!successful) {\n', '                    Escrow(escrow).deposit.value(value)(winner);\n', '                }\n', '            }\n', '\n', '            var _ = admin.call.gas(GAS_LIMIT).value(this.balance)();\n', '        }\n', '    }\n', '\n', '    function walkTowardsBlock(uint _steps) internal {\n', '        int blockHeight;\n', '        int blockHash;\n', '        if (lotteries[id].nearestKnownBlock == 0) {\n', '            blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '            blockHash = BTCRelay(btcRelay).getBlockchainHead();\n', '        } else {\n', '            blockHeight = lotteries[id].nearestKnownBlock;\n', '            blockHash = lotteries[id].nearestKnownBlockHash;\n', '        }\n', '\n', '        // Walk only a few steps to keep an upper limit on gas costs.\n', '        for (uint step = 0; step < _steps; step++) {\n', '            // We expect free access to BTCRelay.\n', '            int fee = BTCRelay(btcRelay).getFeeAmount(blockHash);\n', '            require(fee == 0);\n', '\n', '            bytes32 blockHeader =\n', '                BTCRelay(btcRelay).getBlockHeader(blockHash)[2];\n', '            bytes32 temp;\n', '\n', '            assembly {\n', '                let x := mload(0x40)\n', '                mstore(x, blockHeader)\n', '                temp := mload(add(x, 0x04))\n', '            }\n', '\n', '            blockHeight -= 1;\n', '            blockHash = 0;\n', '            for (uint i = 0; i < 32; i++) {\n', '                blockHash = blockHash | int(temp[uint(i)]) * int(256 ** i);\n', '            }\n', '\n', '            if (blockHeight == lotteries[id].decidingBlock) { break; }\n', '        }\n', '\n', '        // Store the progress to pick up from there next time.\n', '        lotteries[id].nearestKnownBlock = blockHeight;\n', '        lotteries[id].nearestKnownBlockHash = blockHash;\n', '    }\n', '\n', '    function getMessageLength(string _message) constant returns (uint) {\n', '        return bytes(_message).length;\n', '    }\n', '\n', '    function setMessage(int _id, string _message)\n', '             afterInitialization {\n', '        require(lotteries[_id].winner != 0);\n', '        require(lotteries[_id].winner == msg.sender);\n', '        require(getMessageLength(_message) <= 500);\n', '        lotteries[_id].message = _message;\n', '    }\n', '\n', '    function getLotteryDetailsA(int _id)\n', '             constant returns (int _actualId, uint _jackpot,\n', '                               int _decidingBlock,\n', '                               uint _numTickets, uint _numTicketsSold,\n', '                               uint _lastSaleTimestamp, uint _ticketPrice,\n', '                               uint _cutoffTimestamp) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _jackpot = lotteries[_actualId].jackpot;\n', '        _decidingBlock = lotteries[_actualId].decidingBlock;\n', '        _numTickets = lotteries[_actualId].numTickets;\n', '        _numTicketsSold = lotteries[_actualId].numTicketsSold;\n', '        _lastSaleTimestamp = lastSaleTimestamp;\n', '        _ticketPrice = lotteries[_actualId].ticketPrice;\n', '        _cutoffTimestamp = lotteries[_actualId].cutoffTimestamp;\n', '    }\n', '\n', '    function getLotteryDetailsB(int _id)\n', '             constant returns (int _actualId,\n', '                               int _winningTicket, address _winner,\n', '                               uint _finalizationBlock, address _finalizer,\n', '                               string _message,\n', '                               int _prevLottery, int _nextLottery,\n', '                               int _blockHeight) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _winningTicket = lotteries[_actualId].winningTicket;\n', '        _winner = lotteries[_actualId].winner;\n', '        _finalizationBlock = lotteries[_actualId].finalizationBlock;\n', '        _finalizer = lotteries[_actualId].finalizer;\n', '        _message = lotteries[_actualId].message;\n', '\n', '        if (_actualId == 0) {\n', '            _prevLottery = -1;\n', '        } else {\n', '            _prevLottery = _actualId - 1;\n', '        }\n', '        if (_actualId == id) {\n', '            _nextLottery = -1;\n', '        } else {\n', '            _nextLottery = _actualId + 1;\n', '        }\n', '\n', '        _blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '    }\n', '\n', '    function getTicketDetails(int _id, uint _offset, uint _n, address _addr)\n', '             constant returns (uint8[] details) {\n', '        require(_offset + _n <= lotteries[_id].numTickets);\n', '\n', '        details = new uint8[](_n);\n', '        for (uint i = 0; i < _n; i++) {\n', '            address addr = lotteries[_id].tickets[_offset + i];\n', '            if (addr == _addr && _addr != 0) {\n', '                details[i] = 2;\n', '            } else if (addr != 0) {\n', '                details[i] = 1;\n', '            } else {\n', '                details[i] = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    function getTicketOwner(int _id, uint _ticket) constant returns (address) {\n', '        require(_id >= 0);\n', '        return lotteries[_id].tickets[_ticket];\n', '    }\n', '\n', '    function getRecentActivity()\n', '             constant returns (int _id, uint _idx, uint[1000] _recentActivity) {\n', '        _id = id;\n', '        _idx = recentActivityIdx;\n', '        for (uint i = 0; i < recentActivity.length; i++) {\n', '            _recentActivity[i] = recentActivity[i];\n', '        }\n', '    }\n', '\n', '    function setAdmin(address _admin) onlyOwner {\n', '        admin = _admin;\n', '    }\n', '\n', '    function proposeOwner(address _owner) onlyOwner {\n', '        proposedOwner = _owner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        require(proposedOwner != 0);\n', '        require(msg.sender == proposedOwner);\n', '        owner = proposedOwner;\n', '    }\n', '\n', '    function destruct() onlyOwner {\n', '        require(now - lastInitTimestamp > INACTIVITY_TIMEOUT);\n', '        selfdestruct(owner);\n', '    }\n', '}']