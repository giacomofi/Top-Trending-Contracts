['pragma solidity ^0.4.16;\n', '\n', '/**\n', ' * @title Provides overflow safe arithmetic\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Does subtract in safe manner\n', '     *\n', '     * @return result of (_subtrahend - _subtractor) or 0 if overflow occurs\n', '     */\n', '    function sub(uint256 _subtrahend, uint256 _subtractor) internal returns (uint256) {\n', '\n', '        // overflow check\n', '        if (_subtractor > _subtrahend)\n', '            return 0;\n', '\n', '        return _subtrahend - _subtractor;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Contract owner definition\n', ' */\n', 'contract Owned {\n', '\n', '    /* Owner&#39;s address */\n', '    address owner;\n', '\n', '    /**\n', '     * @dev Constructor, records msg.sender as contract owner\n', '     */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Validates if msg.sender is an owner\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '/** \n', ' * @title Standard token interface (ERC 20)\n', ' * \n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20 {\n', '    \n', '// Functions:\n', '    \n', '    /**\n', '     * @return total amount of tokens\n', '     */\n', '    function totalSupply() constant returns (uint256);\n', '\n', '    /** \n', '     * @param _owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256);\n', '\n', '    /** \n', '     * @notice send `_value` token to `_to` from `msg.sender`\n', '     * \n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     * \n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '     * \n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of wei to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256);\n', '\n', '// Events:\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Implementation of ERC 20 interface with holders list\n', ' */\n', 'contract Token is ERC20 {\n', '\n', '    /// Name of the token\n', '    string public name;\n', '    /// Token symbol\n', '    string public symbol;\n', '\n', '    /// Fixed point description\n', '    uint8 public decimals;\n', '\n', '    /// Qty of supplied tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// Token holders list\n', '    address[] public holders;\n', '    /* address => index in array of hodlers, index starts from 1 */\n', '    mapping(address => uint256) index;\n', '\n', '    /* Token holders map */\n', '    mapping(address => uint256) balances;\n', '    /* Token transfer approvals */\n', '    mapping(address => mapping(address => uint256)) allowances;\n', '\n', '    /**\n', '     * @dev Constructs Token with given `_name`, `_symbol` and `_decimals`\n', '     */\n', '    function Token(string _name, string _symbol, uint8 _decimals) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Get balance of given address\n', '     *\n', '     * @param _owner The address to request balance from\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer own tokens to given address\n', '     * @notice send `_value` token to `_to` from `msg.sender`\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '\n', '        // balance check\n', '        if (balances[msg.sender] >= _value) {\n', '\n', '            // transfer\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '\n', '            // push new holder if _value > 0\n', '            if (_value > 0 && index[_to] == 0) {\n', '                index[_to] = holders.push(_to);\n', '            }\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens between addresses using approvals\n', '     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '\n', '        // approved balance check\n', '        if (allowances[_from][msg.sender] >= _value &&\n', '            balances[_from] >= _value ) {\n', '\n', '            // hit approved amount\n', '            allowances[_from][msg.sender] -= _value;\n', '\n', '            // transfer\n', '            balances[_from] -= _value;\n', '            balances[_to] += _value;\n', '\n', '            // push new holder if _value > 0\n', '            if (_value > 0 && index[_to] == 0) {\n', '                index[_to] = holders.push(_to);\n', '            }\n', '\n', '            Transfer(_from, _to, _value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve token transfer with specific amount\n', '     * @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '     *\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of wei to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Get amount of tokens approved for transfer\n', '     *\n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Convenient way to reset approval for given address, not a part of ERC20\n', '     *\n', '     * @param _spender the address\n', '     */\n', '    function unapprove(address _spender) {\n', '        allowances[msg.sender][_spender] = 0;\n', '    }\n', '\n', '    /**\n', '     * @return total amount of tokens\n', '     */\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns count of token holders\n', '     */\n', '    function holderCount() constant returns (uint256) {\n', '        return holders.length;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Cat&#39;s Token, miaow!!!\n', ' *\n', ' * @dev Defines token with name "Cat&#39;s Token", symbol "CTS"\n', ' * and 3 digits after the point\n', ' */\n', 'contract Cat is Token("Test&#39;s Token", "TTS", 3), Owned {\n', '\n', '    /**\n', '     * @dev Emits specified number of tokens. Only owner can emit.\n', '     * Emitted tokens are credited to owner&#39;s account\n', '     *\n', '     * @param _value number of emitting tokens\n', '     * @return true if emission succeeded, false otherwise\n', '     */\n', '    function emit(uint256 _value) onlyOwner returns (bool) {\n', '\n', '        // overflow check\n', '        assert(totalSupply + _value >= totalSupply);\n', '\n', '        // emission\n', '        totalSupply += _value;\n', '        balances[owner] += _value;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Drives Cat&#39;s Token ICO\n', ' */\n', 'contract CatICO {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /// Starts at 21 Sep 2017 05:00:00 UTC\n', '    // uint256 public start = 1505970000;\n', '    uint256 public start = 1503970000;\n', '    /// Ends at 21 Nov 2017 05:00:00 UTC\n', '    uint256 public end = 1511240400;\n', '\n', '    /// Keeps supplied ether\n', '    address public wallet;\n', '\n', '    /// Cat&#39;s Token\n', '    Cat public cat;\n', '\n', '    struct Stage {\n', '        /* price in weis for one milliCTS */\n', '        uint256 price;\n', '        /* supply cap in milliCTS */\n', '        uint256 cap;\n', '    }\n', '\n', '    /* Stage 1: Cat Simulator */\n', '    Stage simulator = Stage(0.01 ether / 1000, 900000000);\n', '    /* Stage 2: Cats Online */\n', '    Stage online = Stage(0.0125 ether / 1000, 2500000000);\n', '    /* Stage 3: Cat Sequels */\n', '    Stage sequels = Stage(0.016 ether / 1000, 3750000000);\n', '\n', '    /**\n', '     * @dev Cat&#39;s ICO constructor. It spawns a Cat contract.\n', '     *\n', '     * @param _wallet the address of the ICO wallet\n', '     */\n', '    function CatICO(address _wallet) {\n', '        cat = new Cat();\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function, works only if ICO is running\n', '     */\n', '    function() payable onlyRunning {\n', '\n', '        var supplied = cat.totalSupply();\n', '        var tokens = tokenEmission(msg.value, supplied);\n', '\n', '        // revert if nothing to emit\n', '        require(tokens > 0);\n', '\n', '        // emit tokens\n', '        bool success = cat.emit(tokens);\n', '        assert(success);\n', '\n', '        // transfer new tokens to its owner\n', '        success = cat.transfer(msg.sender, tokens);\n', '        assert(success);\n', '\n', '        // send value to the wallet\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates number of tokens to emit\n', '     *\n', '     * @param _value received ETH\n', '     * @param _supplied tokens qty supplied at the moment\n', '     * @return tokens count which is accepted for emission\n', '     */\n', '    function tokenEmission(uint256 _value, uint256 _supplied) private returns (uint256) {\n', '\n', '        uint256 emission = 0;\n', '        uint256 stageTokens;\n', '\n', '        Stage[3] memory stages = [simulator, online, sequels];\n', '\n', '        /* Stage 1 and 2 */\n', '        for (uint8 i = 0; i < 2; i++) {\n', '            (stageTokens, _value, _supplied) = stageEmission(_value, _supplied, stages[i]);\n', '            emission += stageTokens;\n', '        }\n', '\n', '        /* Stage 3, spend remainder value */\n', '        emission += _value / stages[2].price;\n', '\n', '        return emission;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates token emission in terms of given stage\n', '     *\n', '     * @param _value consuming ETH value\n', '     * @param _supplied tokens qty supplied within tokens supplied for prev stages\n', '     * @param _stage the stage\n', '     *\n', '     * @return tokens emitted in the stage, returns 0 if stage is passed or not enough _value\n', '     * @return valueRemainder the value remaining after emission in the stage\n', '     * @return newSupply total supplied tokens after emission in the stage\n', '     */\n', '    function stageEmission(uint256 _value, uint256 _supplied, Stage _stage)\n', '        private\n', '        returns (uint256 tokens, uint256 valueRemainder, uint256 newSupply)\n', '    {\n', '\n', '        /* Check if there is space left in the stage */\n', '        if (_supplied >= _stage.cap) {\n', '            return (0, _value, _supplied);\n', '        }\n', '\n', '        /* Check if there is enough value for at least one milliCTS */\n', '        if (_value < _stage.price) {\n', '            return (0, _value, _supplied);\n', '        }\n', '\n', '        /* Potential emission */\n', '        var _tokens = _value / _stage.price;\n', '\n', '        /* Adjust to the space left in the stage */\n', '        var remainder = _stage.cap.sub(_supplied);\n', '        _tokens = _tokens > remainder ? remainder : _tokens;\n', '\n', '        /* Update value and supply */\n', '        var _valueRemainder = _value.sub(_tokens * _stage.price);\n', '        var _newSupply = _supplied + _tokens;\n', '\n', '        return (_tokens, _valueRemainder, _newSupply);\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if ICO is still running\n', '     *\n', '     * @return true if ICO is running, false otherwise\n', '     */\n', '    function isRunning() constant returns (bool) {\n', '\n', '        /* Timeframes */\n', '        if (now < start) return false;\n', '        if (now >= end) return false;\n', '\n', '        /* Total cap, held by Stage 3 */\n', '        if (cat.totalSupply() >= sequels.cap) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Validates ICO timeframes and total cap\n', '     */\n', '    modifier onlyRunning() {\n', '\n', '        /* Check timeframes */\n', '        require(now >= start);\n', '        require(now < end);\n', '\n', '        /* Check Stage 3 cap */\n', '        require(cat.totalSupply() < sequels.cap);\n', '\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '/**\n', ' * @title Provides overflow safe arithmetic\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Does subtract in safe manner\n', '     *\n', '     * @return result of (_subtrahend - _subtractor) or 0 if overflow occurs\n', '     */\n', '    function sub(uint256 _subtrahend, uint256 _subtractor) internal returns (uint256) {\n', '\n', '        // overflow check\n', '        if (_subtractor > _subtrahend)\n', '            return 0;\n', '\n', '        return _subtrahend - _subtractor;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Contract owner definition\n', ' */\n', 'contract Owned {\n', '\n', "    /* Owner's address */\n", '    address owner;\n', '\n', '    /**\n', '     * @dev Constructor, records msg.sender as contract owner\n', '     */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Validates if msg.sender is an owner\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '/** \n', ' * @title Standard token interface (ERC 20)\n', ' * \n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20 {\n', '    \n', '// Functions:\n', '    \n', '    /**\n', '     * @return total amount of tokens\n', '     */\n', '    function totalSupply() constant returns (uint256);\n', '\n', '    /** \n', '     * @param _owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256);\n', '\n', '    /** \n', '     * @notice send `_value` token to `_to` from `msg.sender`\n', '     * \n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     * \n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '     * \n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of wei to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool);\n', '\n', '    /** \n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256);\n', '\n', '// Events:\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Implementation of ERC 20 interface with holders list\n', ' */\n', 'contract Token is ERC20 {\n', '\n', '    /// Name of the token\n', '    string public name;\n', '    /// Token symbol\n', '    string public symbol;\n', '\n', '    /// Fixed point description\n', '    uint8 public decimals;\n', '\n', '    /// Qty of supplied tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// Token holders list\n', '    address[] public holders;\n', '    /* address => index in array of hodlers, index starts from 1 */\n', '    mapping(address => uint256) index;\n', '\n', '    /* Token holders map */\n', '    mapping(address => uint256) balances;\n', '    /* Token transfer approvals */\n', '    mapping(address => mapping(address => uint256)) allowances;\n', '\n', '    /**\n', '     * @dev Constructs Token with given `_name`, `_symbol` and `_decimals`\n', '     */\n', '    function Token(string _name, string _symbol, uint8 _decimals) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Get balance of given address\n', '     *\n', '     * @param _owner The address to request balance from\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer own tokens to given address\n', '     * @notice send `_value` token to `_to` from `msg.sender`\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '\n', '        // balance check\n', '        if (balances[msg.sender] >= _value) {\n', '\n', '            // transfer\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '\n', '            // push new holder if _value > 0\n', '            if (_value > 0 && index[_to] == 0) {\n', '                index[_to] = holders.push(_to);\n', '            }\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens between addresses using approvals\n', '     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value The amount of token to be transferred\n', '     * @return Whether the transfer was successful or not\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '\n', '        // approved balance check\n', '        if (allowances[_from][msg.sender] >= _value &&\n', '            balances[_from] >= _value ) {\n', '\n', '            // hit approved amount\n', '            allowances[_from][msg.sender] -= _value;\n', '\n', '            // transfer\n', '            balances[_from] -= _value;\n', '            balances[_to] += _value;\n', '\n', '            // push new holder if _value > 0\n', '            if (_value > 0 && index[_to] == 0) {\n', '                index[_to] = holders.push(_to);\n', '            }\n', '\n', '            Transfer(_from, _to, _value);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve token transfer with specific amount\n', '     * @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '     *\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @param _value The amount of wei to be approved for transfer\n', '     * @return Whether the approval was successful or not\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Get amount of tokens approved for transfer\n', '     *\n', '     * @param _owner The address of the account owning tokens\n', '     * @param _spender The address of the account able to transfer the tokens\n', '     * @return Amount of remaining tokens allowed to spent\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Convenient way to reset approval for given address, not a part of ERC20\n', '     *\n', '     * @param _spender the address\n', '     */\n', '    function unapprove(address _spender) {\n', '        allowances[msg.sender][_spender] = 0;\n', '    }\n', '\n', '    /**\n', '     * @return total amount of tokens\n', '     */\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns count of token holders\n', '     */\n', '    function holderCount() constant returns (uint256) {\n', '        return holders.length;\n', '    }\n', '}\n', '\n', '/**\n', " * @title Cat's Token, miaow!!!\n", ' *\n', ' * @dev Defines token with name "Cat\'s Token", symbol "CTS"\n', ' * and 3 digits after the point\n', ' */\n', 'contract Cat is Token("Test\'s Token", "TTS", 3), Owned {\n', '\n', '    /**\n', '     * @dev Emits specified number of tokens. Only owner can emit.\n', "     * Emitted tokens are credited to owner's account\n", '     *\n', '     * @param _value number of emitting tokens\n', '     * @return true if emission succeeded, false otherwise\n', '     */\n', '    function emit(uint256 _value) onlyOwner returns (bool) {\n', '\n', '        // overflow check\n', '        assert(totalSupply + _value >= totalSupply);\n', '\n', '        // emission\n', '        totalSupply += _value;\n', '        balances[owner] += _value;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', " * @title Drives Cat's Token ICO\n", ' */\n', 'contract CatICO {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /// Starts at 21 Sep 2017 05:00:00 UTC\n', '    // uint256 public start = 1505970000;\n', '    uint256 public start = 1503970000;\n', '    /// Ends at 21 Nov 2017 05:00:00 UTC\n', '    uint256 public end = 1511240400;\n', '\n', '    /// Keeps supplied ether\n', '    address public wallet;\n', '\n', "    /// Cat's Token\n", '    Cat public cat;\n', '\n', '    struct Stage {\n', '        /* price in weis for one milliCTS */\n', '        uint256 price;\n', '        /* supply cap in milliCTS */\n', '        uint256 cap;\n', '    }\n', '\n', '    /* Stage 1: Cat Simulator */\n', '    Stage simulator = Stage(0.01 ether / 1000, 900000000);\n', '    /* Stage 2: Cats Online */\n', '    Stage online = Stage(0.0125 ether / 1000, 2500000000);\n', '    /* Stage 3: Cat Sequels */\n', '    Stage sequels = Stage(0.016 ether / 1000, 3750000000);\n', '\n', '    /**\n', "     * @dev Cat's ICO constructor. It spawns a Cat contract.\n", '     *\n', '     * @param _wallet the address of the ICO wallet\n', '     */\n', '    function CatICO(address _wallet) {\n', '        cat = new Cat();\n', '        wallet = _wallet;\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function, works only if ICO is running\n', '     */\n', '    function() payable onlyRunning {\n', '\n', '        var supplied = cat.totalSupply();\n', '        var tokens = tokenEmission(msg.value, supplied);\n', '\n', '        // revert if nothing to emit\n', '        require(tokens > 0);\n', '\n', '        // emit tokens\n', '        bool success = cat.emit(tokens);\n', '        assert(success);\n', '\n', '        // transfer new tokens to its owner\n', '        success = cat.transfer(msg.sender, tokens);\n', '        assert(success);\n', '\n', '        // send value to the wallet\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates number of tokens to emit\n', '     *\n', '     * @param _value received ETH\n', '     * @param _supplied tokens qty supplied at the moment\n', '     * @return tokens count which is accepted for emission\n', '     */\n', '    function tokenEmission(uint256 _value, uint256 _supplied) private returns (uint256) {\n', '\n', '        uint256 emission = 0;\n', '        uint256 stageTokens;\n', '\n', '        Stage[3] memory stages = [simulator, online, sequels];\n', '\n', '        /* Stage 1 and 2 */\n', '        for (uint8 i = 0; i < 2; i++) {\n', '            (stageTokens, _value, _supplied) = stageEmission(_value, _supplied, stages[i]);\n', '            emission += stageTokens;\n', '        }\n', '\n', '        /* Stage 3, spend remainder value */\n', '        emission += _value / stages[2].price;\n', '\n', '        return emission;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates token emission in terms of given stage\n', '     *\n', '     * @param _value consuming ETH value\n', '     * @param _supplied tokens qty supplied within tokens supplied for prev stages\n', '     * @param _stage the stage\n', '     *\n', '     * @return tokens emitted in the stage, returns 0 if stage is passed or not enough _value\n', '     * @return valueRemainder the value remaining after emission in the stage\n', '     * @return newSupply total supplied tokens after emission in the stage\n', '     */\n', '    function stageEmission(uint256 _value, uint256 _supplied, Stage _stage)\n', '        private\n', '        returns (uint256 tokens, uint256 valueRemainder, uint256 newSupply)\n', '    {\n', '\n', '        /* Check if there is space left in the stage */\n', '        if (_supplied >= _stage.cap) {\n', '            return (0, _value, _supplied);\n', '        }\n', '\n', '        /* Check if there is enough value for at least one milliCTS */\n', '        if (_value < _stage.price) {\n', '            return (0, _value, _supplied);\n', '        }\n', '\n', '        /* Potential emission */\n', '        var _tokens = _value / _stage.price;\n', '\n', '        /* Adjust to the space left in the stage */\n', '        var remainder = _stage.cap.sub(_supplied);\n', '        _tokens = _tokens > remainder ? remainder : _tokens;\n', '\n', '        /* Update value and supply */\n', '        var _valueRemainder = _value.sub(_tokens * _stage.price);\n', '        var _newSupply = _supplied + _tokens;\n', '\n', '        return (_tokens, _valueRemainder, _newSupply);\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if ICO is still running\n', '     *\n', '     * @return true if ICO is running, false otherwise\n', '     */\n', '    function isRunning() constant returns (bool) {\n', '\n', '        /* Timeframes */\n', '        if (now < start) return false;\n', '        if (now >= end) return false;\n', '\n', '        /* Total cap, held by Stage 3 */\n', '        if (cat.totalSupply() >= sequels.cap) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Validates ICO timeframes and total cap\n', '     */\n', '    modifier onlyRunning() {\n', '\n', '        /* Check timeframes */\n', '        require(now >= start);\n', '        require(now < end);\n', '\n', '        /* Check Stage 3 cap */\n', '        require(cat.totalSupply() < sequels.cap);\n', '\n', '        _;\n', '    }\n', '}']
