['pragma solidity 0.4.15;\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' * allows creating contracts with up to 16 owners with their shares\n', ' */\n', 'contract MultiOwnable {\n', '    /** a single owner record */\n', '    struct Owner {\n', '        address recipient;\n', '        uint share;\n', '    }\n', '\n', '    /** contract owners */\n', '    Owner[] public owners;\n', '\n', '    /**\n', '     * Returns total owners count\n', '     * @return count - owners count\n', '     */\n', '    function ownersCount ()   constant   returns (uint count) {  \n', '        return owners.length;\n', '    }\n', '\n', '    /**\n', '     * Returns owner&#39;s info\n', '     * @param  idx - index of the owner\n', '     * @return owner - owner&#39;s info\n', '     */\n', '    function owner (uint idx)   constant   returns (address owner_dot_recipient, uint owner_dot_share) {  \n', 'Owner memory owner;\n', '\n', '        owner = owners[idx];\n', '    owner_dot_recipient = address(owner.recipient);\n', 'owner_dot_share = uint(owner.share);}\n', '\n', '    /** reverse lookup helper */\n', '    mapping (address => bool) ownersIdx;\n', '\n', '    /**\n', '     * Creates the contract with up to 16 owners\n', '     * shares must be > 0\n', '     */\n', '    function MultiOwnable (address[16] _owners_dot_recipient, uint[16] _owners_dot_share)   {  \n', 'Owner[16] memory _owners;\n', '\n', 'for(uint __recipient_iterator__ = 0; __recipient_iterator__ < _owners_dot_recipient.length;__recipient_iterator__++)\n', '  _owners[__recipient_iterator__].recipient = address(_owners_dot_recipient[__recipient_iterator__]);\n', 'for(uint __share_iterator__ = 0; __share_iterator__ < _owners_dot_share.length;__share_iterator__++)\n', '  _owners[__share_iterator__].share = uint(_owners_dot_share[__share_iterator__]);\n', '        for(var idx = 0; idx < _owners_dot_recipient.length; idx++) {\n', '            if(_owners[idx].recipient != 0) {\n', '                owners.push(_owners[idx]);\n', '                assert(owners[idx].share > 0);\n', '                ownersIdx[_owners[idx].recipient] = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Function with this modifier can be called only by one of owners\n', '     */\n', '    modifier onlyOneOfOwners() {\n', '        require(ownersIdx[msg.sender]);\n', '        _;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'pragma solidity 0.4.15;\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', '/**\n', ' * @title Blind Croupier Token\n', ' * WIN fixed supply Token, used for Blind Croupier TokenDistribution\n', ' */\n', ' contract WIN is ERC20Token {\n', '    \n', '\n', '    string public constant symbol = "WIN";\n', '    string public constant name = "WIN";\n', '\n', '    uint8 public constant decimals = 7;\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '    uint256 public totalTokenSupply = 500 * MILLION * TOKEN;\n', '\n', '    /** balances of each accounts */\n', '    mapping(address => uint256) balances;\n', '\n', '    /** amount of tokens approved for transfer */\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /** Triggered when `owner` destroys `amount` tokens */\n', '    event Destroyed(address indexed owner, uint256 amount);\n', '\n', '    /**\n', '     * Constucts the token, and supplies the creator with `totalTokenSupply` tokens\n', '     */\n', '    function WIN ()   { \n', '        balances[msg.sender] = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return result - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply ()  constant  returns (uint256 result) { \n', '        result = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '    * Returns `owner` balance of tokens\n', '    * @param owner address to request balance for\n', '    * @return balance - token balance of `owner`\n', '    */\n', '    function balanceOf (address owner)  constant  returns (uint256 balance) { \n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  amount - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer (address to, uint256 amount)   returns (bool success) { \n', '        if(balances[msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount <= 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  amount - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom (address from, address to, uint256 amount)   returns (bool success) { \n', '        if (balances[from] < amount)\n', '            return false;\n', '\n', '        if(allowed[from][msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount == 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[from] -= amount;\n', '        allowed[from][msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the amount amount.\n', '     * If this function is called again it overwrites the current allowance with `amount`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param amount - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve (address spender, uint256 amount)   returns (bool success) { \n', '       allowed[msg.sender][spender] = amount;\n', '       Approval(msg.sender, spender, amount);\n', '       return true;\n', '   }\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance (address owner, address spender)  constant  returns (uint256 remaining) { \n', '        return allowed[owner][spender];\n', '    }\n', '\n', '     /**\n', '      * Destroys `amount` of tokens permanently, they cannot be restored\n', '      * @return success - `true` if `amount` of tokens were destroyed, `false` otherwise\n', '      */\n', '    function destroy (uint256 amount)   returns (bool success) { \n', '        if(amount == 0) return false;\n', '        if(balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalTokenSupply -= amount;\n', '        Destroyed(msg.sender, amount);\n', '    }\n', '}\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title Various Math utilities\n', ' */\n', 'library Math {\n', '     /** 1/1000, 1000 uint = 1 */\n', '\n', '    /**\n', '     * Returns `promille` promille of `value`\n', '     * e.g. `takePromille(5000, 1) == 5`\n', '     * @param value - uint to take promille value\n', '     * @param promille - promille value\n', '     * @return result - `value * promille / 1000`\n', '     */\n', '    function takePromille (uint value, uint promille)  constant  returns (uint result) { \n', '        result = value * promille / 1000;\n', '    }\n', '\n', '    /**\n', '     * Returns `value` with added `promille` promille\n', '     * @param value - uint to add promille to\n', '     * @param promille - promille value to add\n', '     * @return result - `value + value * promille / 1000`\n', '     */\n', '    function addPromille (uint value, uint promille)  constant  returns (uint result) { \n', '        result = value + takePromille(value, promille);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Blind Croupier TokenDistribution\n', ' * It possesses some `WIN` tokens.\n', ' * The distribution is divided into many &#39;periods&#39;.\n', ' * The zero one is `Presale` with `TOKENS_FOR_PRESALE` tokens\n', ' * It&#39;s ended when all tokens are sold or manually with `endPresale()` function\n', ' * The length of first period is `FIRST_PERIOD_DURATION`.\n', ' * The length of other periods is `PERIOD_DURATION`.\n', ' * During each period, `TOKENS_PER_PERIOD` are offered for sale (`TOKENS_PER_FIRST_PERIOD` for the first one)\n', ' * Investors send their money to the contract\n', ' * and call `claimAllTokens()` function to get `WIN` tokens.\n', ' * Period 0 Token price is `PRESALE_TOKEN_PRICE`\n', ' * Period 1 Token price is `SALE_INITIAL_TOKEN_PRICE`\n', ' * Period 2+ price is determined by the following rules:\n', ' * If more than `TOKENS_TO_INCREASE_NEXT_PRICE * TOKENS_PER_PERIOD / 1000`\n', ' * were sold during the period, the price of the Tokens for the next period\n', ' * is increased by `PERIOD_PRICE_INCREASE` promille,\n', ' * if ALL tokens were sold, price is increased by `FULLY_SOLD_PRICE_INCREASE` promille\n', ' * Otherwise, the price remains the same.\n', ' */\n', 'contract BlindCroupierTokenDistribution is MultiOwnable {\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '\n', '    uint256 constant MINIMUM_DEPOSIT = 100 finney; /** minimum deposit accepted to bank */\n', '    uint256 constant PRESALE_TOKEN_PRICE = 0.00035 ether / TOKEN;\n', '    uint256 constant SALE_INITIAL_TOKEN_PRICE = 0.0005 ether / TOKEN;\n', '\n', '    uint256 constant TOKENS_FOR_PRESALE = 5 * MILLION * TOKEN; /** 5M tokens */\n', '    uint256 constant TOKENS_PER_FIRST_PERIOD = 15 * MILLION * TOKEN; /** 15M tokens */\n', '    uint256 constant TOKENS_PER_PERIOD = 1 * MILLION * TOKEN; /** 1M tokens */\n', '    uint256 constant FIRST_PERIOD_DURATION = 161 hours; /** duration of 1st sale period */\n', '    uint256 constant PERIOD_DURATION = 23 hours; /** duration of all other sale periods */\n', '    uint256 constant PERIOD_PRICE_INCREASE = 5; /** `next_token_price = old_token_price + old_token_price * PERIOD_PRICE_INCREASE / 1000` */\n', '    uint256 constant FULLY_SOLD_PRICE_INCREASE = 10; /** to increase price if ALL tokens sold */\n', '    uint256 constant TOKENS_TO_INCREASE_NEXT_PRICE = 800; /** the price is increased if `sold_tokens > period_tokens * TOKENS_TO_INCREASE_NEXT_PRICE / 1000` */\n', '\n', '    uint256 constant NEVER = 0;\n', '    uint16 constant UNKNOWN_COUNTRY = 0;\n', '\n', '    /**\n', '     * State of Blind Croupier crowdsale\n', '     */\n', '    enum State {\n', '        NotStarted,\n', '        Presale,\n', '        Sale\n', '    }\n', '\n', '    uint256 public totalUnclaimedTokens; /** total amount of tokens, TokenDistribution owns to investors */\n', '    uint256 public totalTokensSold; /** total amount of Tokens sold during the TokenDistribution */\n', '    uint256 public totalTokensDestroyed; /** total amount of Tokens destroyed by this contract */\n', '\n', '    mapping(address => uint256) public unclaimedTokensForInvestor; /** unclaimed tokens for each investor */\n', '\n', '    /**\n', '     * One token sale period information\n', '     */\n', '    struct Period {\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        uint256 tokenPrice;\n', '        uint256 tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Emited when `investor` sends `amount` of money to the Bank\n', '     * @param investor - address, sending the money\n', '     * @param amount - Wei sent\n', '     */\n', '    event Deposited(address indexed investor, uint256 amount, uint256 tokenCount);\n', '\n', '    /**\n', '     * Emited when a new period is opened\n', '     * @param periodIndex - index of new period\n', '     * @param tokenPrice - price of WIN Token in new period\n', '     */\n', '    event PeriodStarted(uint periodIndex, uint256 tokenPrice, uint256 tokensToSale, uint256 startTime, uint256 endTime, uint256 now);\n', '\n', '    /**\n', '     * Emited when `investor` claims `claimed` tokens\n', '     * @param investor - address getting the Tokens\n', '     * @param claimed - amount of Tokens claimed\n', '     */\n', '    event TokensClaimed(address indexed investor, uint256 claimed);\n', '\n', '    /** current Token sale period */\n', '    uint public currentPeriod = 0;\n', '\n', '    /** information about past and current periods, by periods index, starting from `0` */\n', '    mapping(uint => Period) periods;\n', '\n', '    /** WIN tokens contract  */\n', '    WIN public win;\n', '\n', '    /** The state of the crowdsale - `NotStarted`, `Presale`, `Sale` */\n', '    State public state;\n', '\n', '    /** the counter of investment by a country code (3-digit ISO 3166 code) */\n', '    mapping(uint16 => uint256) investmentsByCountries;\n', '\n', '    /**\n', '     * Returns amount of Wei invested by the specified country\n', '     * @param country - 3-digit country code\n', '     */\n', '    function getInvestmentsByCountry (uint16 country)   constant   returns (uint256 investment) {  \n', '        investment = investmentsByCountries[country];\n', '    }\n', '\n', '    /**\n', '     * Returns the Token price in the current period\n', '     * @return tokenPrice - current Token price\n', '     */\n', '    function getTokenPrice ()   constant   returns (uint256 tokenPrice) {  \n', '        tokenPrice = periods[currentPeriod].tokenPrice;\n', '    }\n', '\n', '    /**\n', '     * Returns the Token price for the period requested\n', '     * @param periodIndex - the period index\n', '     * @return tokenPrice - Token price for the period\n', '     */\n', '    function getTokenPriceForPeriod (uint periodIndex)   constant   returns (uint256 tokenPrice) {  \n', '        tokenPrice = periods[periodIndex].tokenPrice;\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of Tokens sold\n', '     * @param period - period index to get tokens for\n', '     * @return tokensSold - amount of tokens sold\n', '     */\n', '    function getTokensSold (uint period)   constant   returns (uint256 tokensSold) {  \n', '        return periods[period].tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if TokenDistribution has enough tokens for the current period\n', '     * and thus going on\n', '     * @return active - `true` if TokenDistribution is going on, `false` otherwise\n', '     */\n', '    function isActive ()   constant   returns (bool active) {  \n', '        return win.balanceOf(this) >= totalUnclaimedTokens + tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Accepts money deposit and makes record\n', '     * minimum deposit is MINIMUM_DEPOSIT\n', '     * @param beneficiar - the address to receive Tokens\n', '     * @param countryCode - 3-digit country code\n', '     * @dev if `msg.value < MINIMUM_DEPOSIT` throws\n', '     */\n', '    function deposit (address beneficiar, uint16 countryCode)   payable  {  \n', '        require(msg.value >= MINIMUM_DEPOSIT);\n', '        require(state == State.Sale || state == State.Presale);\n', '\n', '        /* this should end any finished period before starting any operations */\n', '        tick();\n', '\n', '        /* check if have enough tokens for the current period\n', '         * if not, the call fails until tokens are deposited to the contract\n', '         */\n', '        require(isActive());\n', '\n', '        uint256 tokensBought = msg.value / getTokenPrice();\n', '\n', '        if(periods[currentPeriod].tokensSold + tokensBought >= tokensForPeriod(currentPeriod)) {\n', '            tokensBought = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', '        }\n', '\n', '        uint256 moneySpent = getTokenPrice() * tokensBought;\n', '\n', '        investmentsByCountries[countryCode] += moneySpent;\n', '\n', '        if(tokensBought > 0) {\n', '            assert(moneySpent <= msg.value);\n', '\n', '            /* return the rest */\n', '            if(msg.value > moneySpent) {\n', '                msg.sender.transfer(msg.value - moneySpent);\n', '            }\n', '\n', '            periods[currentPeriod].tokensSold += tokensBought;\n', '            unclaimedTokensForInvestor[beneficiar] += tokensBought;\n', '            totalUnclaimedTokens += tokensBought;\n', '            totalTokensSold += tokensBought;\n', '            Deposited(msg.sender, moneySpent, tokensBought);\n', '        }\n', '\n', '        /* if all tokens are sold, get to the next period */\n', '        tick();\n', '    }\n', '\n', '    /**\n', '     * See `deposit` function\n', '     */\n', '    function() payable {\n', '        deposit(msg.sender, UNKNOWN_COUNTRY);\n', '    }\n', '\n', '    /**\n', '     * Creates the contract and sets the owners\n', '     * @param owners_dot_recipient - array of 16 owner records  (MultiOwnable.Owner.recipient fields)\n', '* @param owners_dot_share - array of 16 owner records  (MultiOwnable.Owner.share fields)\n', '     */\n', '    function BlindCroupierTokenDistribution (address[16] owners_dot_recipient, uint[16] owners_dot_share)   MultiOwnable(owners_dot_recipient, owners_dot_share)  {  \n', 'MultiOwnable.Owner[16] memory owners;\n', '\n', 'for(uint __recipient_iterator__ = 0; __recipient_iterator__ < owners_dot_recipient.length;__recipient_iterator__++)\n', '  owners[__recipient_iterator__].recipient = address(owners_dot_recipient[__recipient_iterator__]);\n', 'for(uint __share_iterator__ = 0; __share_iterator__ < owners_dot_share.length;__share_iterator__++)\n', '  owners[__share_iterator__].share = uint(owners_dot_share[__share_iterator__]);\n', '        state = State.NotStarted;\n', '    }\n', '\n', '    /**\n', '     * Begins the crowdsale (presale period)\n', '     * @param tokenContractAddress - address of the `WIN` contract (token holder)\n', '     * @dev must be called by one of owners\n', '     */\n', '    function startPresale (address tokenContractAddress)   onlyOneOfOwners  {  \n', '        require(state == State.NotStarted);\n', '\n', '        win = WIN(tokenContractAddress);\n', '\n', '        assert(win.balanceOf(this) >= tokensForPeriod(0));\n', '\n', '        periods[0] = Period(now, NEVER, PRESALE_TOKEN_PRICE, 0);\n', '        PeriodStarted(0,\n', '            PRESALE_TOKEN_PRICE,\n', '            tokensForPeriod(currentPeriod),\n', '            now,\n', '            NEVER,\n', '            now);\n', '        state = State.Presale;\n', '    }\n', '\n', '    /**\n', '     * Ends the presale and begins period 1 of the crowdsale\n', '     * @dev must be called by one of owners\n', '     */\n', '    function endPresale ()   onlyOneOfOwners  {  \n', '        require(state == State.Presale);\n', '        state = State.Sale;\n', '        nextPeriod();\n', '    }\n', '\n', '    /**\n', '     * Returns a time interval for a specific `period`\n', '     * @param  period - period index to count interval for\n', '     * @return startTime - timestamp of period start time (INCLUSIVE)\n', '     * @return endTime - timestamp of period end time (INCLUSIVE)\n', '     */\n', '    function periodTimeFrame (uint period)   constant   returns (uint256 startTime, uint256 endTime) {  \n', '        require(period <= currentPeriod);\n', '\n', '        startTime = periods[period].startTime;\n', '        endTime = periods[period].endTime;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if the time for the `period` has already passed\n', '     */\n', '    function isPeriodTimePassed (uint period)   constant   returns (bool finished) {  \n', '        require(periods[period].startTime > 0);\n', '\n', '        uint256 endTime = periods[period].endTime;\n', '\n', '        if(endTime == NEVER) {\n', '            return false;\n', '        }\n', '\n', '        return (endTime < now);\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if `period` has already finished (time passed or tokens sold)\n', '     */\n', '    function isPeriodClosed (uint period)   constant   returns (bool finished) {  \n', '        return period < currentPeriod;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if all tokens for the `period` has been sold\n', '     */\n', '    function isPeriodAllTokensSold (uint period)   constant   returns (bool finished) {  \n', '        return periods[period].tokensSold == tokensForPeriod(period);\n', '    }\n', '\n', '    /**\n', '     * Returns unclaimed Tokens count for the caller\n', '     * @return tokens - amount of unclaimed Tokens for the caller\n', '     */\n', '    function unclaimedTokens ()   constant   returns (uint256 tokens) {  \n', '        return unclaimedTokensForInvestor[msg.sender];\n', '    }\n', '\n', '    /**\n', '     * Transfers all the tokens stored for this `investor` to his address\n', '     * @param investor - investor to claim tokens for\n', '     */\n', '    function claimAllTokensForInvestor (address investor)   {  \n', '        assert(totalUnclaimedTokens >= unclaimedTokensForInvestor[investor]);\n', '        totalUnclaimedTokens -= unclaimedTokensForInvestor[investor];\n', '        win.transfer(investor, unclaimedTokensForInvestor[investor]);\n', '        TokensClaimed(investor, unclaimedTokensForInvestor[investor]);\n', '        unclaimedTokensForInvestor[investor] = 0;\n', '    }\n', '\n', '    /**\n', '     * Claims all the tokens for the sender\n', '     * @dev efficiently calling `claimAllForInvestor(msg.sender)`\n', '     */\n', '    function claimAllTokens ()   {  \n', '        claimAllTokensForInvestor(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Returns the total token count for the period specified\n', '     * @param  period - period number\n', '     * @return tokens - total tokens count\n', '     */\n', '    function tokensForPeriod (uint period)   constant   returns (uint256 tokens) {  \n', '        if(period == 0) {\n', '            return TOKENS_FOR_PRESALE;\n', '        } else if(period == 1) {\n', '            return TOKENS_PER_FIRST_PERIOD;\n', '        } else {\n', '            return TOKENS_PER_PERIOD;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the duration of the sale (not presale) period\n', '     * @param  period - the period number\n', '     * @return duration - duration in seconds\n', '     */\n', '    function periodDuration (uint period)   constant   returns (uint256 duration) {  \n', '        require(period > 0);\n', '\n', '        if(period == 1) {\n', '            return FIRST_PERIOD_DURATION;\n', '        } else {\n', '            return PERIOD_DURATION;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Finishes the current period and starts a new one\n', '     */\n', '    function nextPeriod() internal {\n', '        uint256 oldPrice = periods[currentPeriod].tokenPrice;\n', '        uint256 newPrice;\n', '        if(currentPeriod == 0) {\n', '            newPrice = SALE_INITIAL_TOKEN_PRICE;\n', '        } else if(periods[currentPeriod].tokensSold  == tokensForPeriod(currentPeriod)) {\n', '            newPrice = Math.addPromille(oldPrice, FULLY_SOLD_PRICE_INCREASE);\n', '        } else if(periods[currentPeriod].tokensSold >= Math.takePromille(tokensForPeriod(currentPeriod), TOKENS_TO_INCREASE_NEXT_PRICE)) {\n', '            newPrice = Math.addPromille(oldPrice, PERIOD_PRICE_INCREASE);\n', '        } else {\n', '            newPrice = oldPrice;\n', '        }\n', '\n', '        /* destroy unsold tokens */\n', '        if(periods[currentPeriod].tokensSold < tokensForPeriod(currentPeriod)) {\n', '            uint256 toDestroy = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', '            /* do not destroy if we don&#39;t have enough to pay investors */\n', '            uint256 balance = win.balanceOf(this);\n', '            if(balance < toDestroy + totalUnclaimedTokens) {\n', '                toDestroy = (balance - totalUnclaimedTokens);\n', '            }\n', '            win.destroy(toDestroy);\n', '            totalTokensDestroyed += toDestroy;\n', '        }\n', '\n', '        /* if we are force ending the period set in the future or without end time,\n', '         * set end time to now\n', '         */\n', '        if(periods[currentPeriod].endTime > now ||\n', '            periods[currentPeriod].endTime == NEVER) {\n', '            periods[currentPeriod].endTime = now;\n', '        }\n', '\n', '        uint256 duration = periodDuration(currentPeriod + 1);\n', '\n', '        periods[currentPeriod + 1] = Period(\n', '            periods[currentPeriod].endTime,\n', '            periods[currentPeriod].endTime + duration,\n', '            newPrice,\n', '            0);\n', '\n', '        currentPeriod++;\n', '\n', '        PeriodStarted(currentPeriod,\n', '            newPrice,\n', '            tokensForPeriod(currentPeriod),\n', '            periods[currentPeriod].startTime,\n', '            periods[currentPeriod].endTime,\n', '            now);\n', '    }\n', '\n', '    /**\n', '     * To be called as frequently as required by any external party\n', '     * Will check if 1 or more periods have finished and move on to the next\n', '     */\n', '    function tick ()   {  \n', '        if(!isActive()) {\n', '            return;\n', '        }\n', '\n', '        while(state == State.Sale &&\n', '            (isPeriodTimePassed(currentPeriod) ||\n', '            isPeriodAllTokensSold(currentPeriod))) {\n', '            nextPeriod();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Withdraws the money to be spent to Blind Croupier Project needs\n', '     * @param  amount - amount of Wei to withdraw (total)\n', '     */\n', '    function withdraw (uint256 amount)   onlyOneOfOwners  {  \n', '        require(this.balance >= amount);\n', '\n', '        uint totalShares = 0;\n', '        for(var idx = 0; idx < owners.length; idx++) {\n', '            totalShares += owners[idx].share;\n', '        }\n', '\n', '        for(idx = 0; idx < owners.length; idx++) {\n', '            owners[idx].recipient.transfer(amount * owners[idx].share / totalShares);\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.15;\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title MultiOwnable\n', ' * allows creating contracts with up to 16 owners with their shares\n', ' */\n', 'contract MultiOwnable {\n', '    /** a single owner record */\n', '    struct Owner {\n', '        address recipient;\n', '        uint share;\n', '    }\n', '\n', '    /** contract owners */\n', '    Owner[] public owners;\n', '\n', '    /**\n', '     * Returns total owners count\n', '     * @return count - owners count\n', '     */\n', '    function ownersCount ()   constant   returns (uint count) {  \n', '        return owners.length;\n', '    }\n', '\n', '    /**\n', "     * Returns owner's info\n", '     * @param  idx - index of the owner\n', "     * @return owner - owner's info\n", '     */\n', '    function owner (uint idx)   constant   returns (address owner_dot_recipient, uint owner_dot_share) {  \n', 'Owner memory owner;\n', '\n', '        owner = owners[idx];\n', '    owner_dot_recipient = address(owner.recipient);\n', 'owner_dot_share = uint(owner.share);}\n', '\n', '    /** reverse lookup helper */\n', '    mapping (address => bool) ownersIdx;\n', '\n', '    /**\n', '     * Creates the contract with up to 16 owners\n', '     * shares must be > 0\n', '     */\n', '    function MultiOwnable (address[16] _owners_dot_recipient, uint[16] _owners_dot_share)   {  \n', 'Owner[16] memory _owners;\n', '\n', 'for(uint __recipient_iterator__ = 0; __recipient_iterator__ < _owners_dot_recipient.length;__recipient_iterator__++)\n', '  _owners[__recipient_iterator__].recipient = address(_owners_dot_recipient[__recipient_iterator__]);\n', 'for(uint __share_iterator__ = 0; __share_iterator__ < _owners_dot_share.length;__share_iterator__++)\n', '  _owners[__share_iterator__].share = uint(_owners_dot_share[__share_iterator__]);\n', '        for(var idx = 0; idx < _owners_dot_recipient.length; idx++) {\n', '            if(_owners[idx].recipient != 0) {\n', '                owners.push(_owners[idx]);\n', '                assert(owners[idx].share > 0);\n', '                ownersIdx[_owners[idx].recipient] = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Function with this modifier can be called only by one of owners\n', '     */\n', '    modifier onlyOneOfOwners() {\n', '        require(ownersIdx[msg.sender]);\n', '        _;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'pragma solidity 0.4.15;\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', '\n', '/**\n', ' * @title Blind Croupier Token\n', ' * WIN fixed supply Token, used for Blind Croupier TokenDistribution\n', ' */\n', ' contract WIN is ERC20Token {\n', '    \n', '\n', '    string public constant symbol = "WIN";\n', '    string public constant name = "WIN";\n', '\n', '    uint8 public constant decimals = 7;\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '    uint256 public totalTokenSupply = 500 * MILLION * TOKEN;\n', '\n', '    /** balances of each accounts */\n', '    mapping(address => uint256) balances;\n', '\n', '    /** amount of tokens approved for transfer */\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /** Triggered when `owner` destroys `amount` tokens */\n', '    event Destroyed(address indexed owner, uint256 amount);\n', '\n', '    /**\n', '     * Constucts the token, and supplies the creator with `totalTokenSupply` tokens\n', '     */\n', '    function WIN ()   { \n', '        balances[msg.sender] = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return result - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply ()  constant  returns (uint256 result) { \n', '        result = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '    * Returns `owner` balance of tokens\n', '    * @param owner address to request balance for\n', '    * @return balance - token balance of `owner`\n', '    */\n', '    function balanceOf (address owner)  constant  returns (uint256 balance) { \n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  amount - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer (address to, uint256 amount)   returns (bool success) { \n', '        if(balances[msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount <= 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  amount - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom (address from, address to, uint256 amount)   returns (bool success) { \n', '        if (balances[from] < amount)\n', '            return false;\n', '\n', '        if(allowed[from][msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount == 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[from] -= amount;\n', '        allowed[from][msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the amount amount.\n', '     * If this function is called again it overwrites the current allowance with `amount`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param amount - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve (address spender, uint256 amount)   returns (bool success) { \n', '       allowed[msg.sender][spender] = amount;\n', '       Approval(msg.sender, spender, amount);\n', '       return true;\n', '   }\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance (address owner, address spender)  constant  returns (uint256 remaining) { \n', '        return allowed[owner][spender];\n', '    }\n', '\n', '     /**\n', '      * Destroys `amount` of tokens permanently, they cannot be restored\n', '      * @return success - `true` if `amount` of tokens were destroyed, `false` otherwise\n', '      */\n', '    function destroy (uint256 amount)   returns (bool success) { \n', '        if(amount == 0) return false;\n', '        if(balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalTokenSupply -= amount;\n', '        Destroyed(msg.sender, amount);\n', '    }\n', '}\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title Various Math utilities\n', ' */\n', 'library Math {\n', '     /** 1/1000, 1000 uint = 1 */\n', '\n', '    /**\n', '     * Returns `promille` promille of `value`\n', '     * e.g. `takePromille(5000, 1) == 5`\n', '     * @param value - uint to take promille value\n', '     * @param promille - promille value\n', '     * @return result - `value * promille / 1000`\n', '     */\n', '    function takePromille (uint value, uint promille)  constant  returns (uint result) { \n', '        result = value * promille / 1000;\n', '    }\n', '\n', '    /**\n', '     * Returns `value` with added `promille` promille\n', '     * @param value - uint to add promille to\n', '     * @param promille - promille value to add\n', '     * @return result - `value + value * promille / 1000`\n', '     */\n', '    function addPromille (uint value, uint promille)  constant  returns (uint result) { \n', '        result = value + takePromille(value, promille);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Blind Croupier TokenDistribution\n', ' * It possesses some `WIN` tokens.\n', " * The distribution is divided into many 'periods'.\n", ' * The zero one is `Presale` with `TOKENS_FOR_PRESALE` tokens\n', " * It's ended when all tokens are sold or manually with `endPresale()` function\n", ' * The length of first period is `FIRST_PERIOD_DURATION`.\n', ' * The length of other periods is `PERIOD_DURATION`.\n', ' * During each period, `TOKENS_PER_PERIOD` are offered for sale (`TOKENS_PER_FIRST_PERIOD` for the first one)\n', ' * Investors send their money to the contract\n', ' * and call `claimAllTokens()` function to get `WIN` tokens.\n', ' * Period 0 Token price is `PRESALE_TOKEN_PRICE`\n', ' * Period 1 Token price is `SALE_INITIAL_TOKEN_PRICE`\n', ' * Period 2+ price is determined by the following rules:\n', ' * If more than `TOKENS_TO_INCREASE_NEXT_PRICE * TOKENS_PER_PERIOD / 1000`\n', ' * were sold during the period, the price of the Tokens for the next period\n', ' * is increased by `PERIOD_PRICE_INCREASE` promille,\n', ' * if ALL tokens were sold, price is increased by `FULLY_SOLD_PRICE_INCREASE` promille\n', ' * Otherwise, the price remains the same.\n', ' */\n', 'contract BlindCroupierTokenDistribution is MultiOwnable {\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '\n', '    uint256 constant MINIMUM_DEPOSIT = 100 finney; /** minimum deposit accepted to bank */\n', '    uint256 constant PRESALE_TOKEN_PRICE = 0.00035 ether / TOKEN;\n', '    uint256 constant SALE_INITIAL_TOKEN_PRICE = 0.0005 ether / TOKEN;\n', '\n', '    uint256 constant TOKENS_FOR_PRESALE = 5 * MILLION * TOKEN; /** 5M tokens */\n', '    uint256 constant TOKENS_PER_FIRST_PERIOD = 15 * MILLION * TOKEN; /** 15M tokens */\n', '    uint256 constant TOKENS_PER_PERIOD = 1 * MILLION * TOKEN; /** 1M tokens */\n', '    uint256 constant FIRST_PERIOD_DURATION = 161 hours; /** duration of 1st sale period */\n', '    uint256 constant PERIOD_DURATION = 23 hours; /** duration of all other sale periods */\n', '    uint256 constant PERIOD_PRICE_INCREASE = 5; /** `next_token_price = old_token_price + old_token_price * PERIOD_PRICE_INCREASE / 1000` */\n', '    uint256 constant FULLY_SOLD_PRICE_INCREASE = 10; /** to increase price if ALL tokens sold */\n', '    uint256 constant TOKENS_TO_INCREASE_NEXT_PRICE = 800; /** the price is increased if `sold_tokens > period_tokens * TOKENS_TO_INCREASE_NEXT_PRICE / 1000` */\n', '\n', '    uint256 constant NEVER = 0;\n', '    uint16 constant UNKNOWN_COUNTRY = 0;\n', '\n', '    /**\n', '     * State of Blind Croupier crowdsale\n', '     */\n', '    enum State {\n', '        NotStarted,\n', '        Presale,\n', '        Sale\n', '    }\n', '\n', '    uint256 public totalUnclaimedTokens; /** total amount of tokens, TokenDistribution owns to investors */\n', '    uint256 public totalTokensSold; /** total amount of Tokens sold during the TokenDistribution */\n', '    uint256 public totalTokensDestroyed; /** total amount of Tokens destroyed by this contract */\n', '\n', '    mapping(address => uint256) public unclaimedTokensForInvestor; /** unclaimed tokens for each investor */\n', '\n', '    /**\n', '     * One token sale period information\n', '     */\n', '    struct Period {\n', '        uint256 startTime;\n', '        uint256 endTime;\n', '        uint256 tokenPrice;\n', '        uint256 tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Emited when `investor` sends `amount` of money to the Bank\n', '     * @param investor - address, sending the money\n', '     * @param amount - Wei sent\n', '     */\n', '    event Deposited(address indexed investor, uint256 amount, uint256 tokenCount);\n', '\n', '    /**\n', '     * Emited when a new period is opened\n', '     * @param periodIndex - index of new period\n', '     * @param tokenPrice - price of WIN Token in new period\n', '     */\n', '    event PeriodStarted(uint periodIndex, uint256 tokenPrice, uint256 tokensToSale, uint256 startTime, uint256 endTime, uint256 now);\n', '\n', '    /**\n', '     * Emited when `investor` claims `claimed` tokens\n', '     * @param investor - address getting the Tokens\n', '     * @param claimed - amount of Tokens claimed\n', '     */\n', '    event TokensClaimed(address indexed investor, uint256 claimed);\n', '\n', '    /** current Token sale period */\n', '    uint public currentPeriod = 0;\n', '\n', '    /** information about past and current periods, by periods index, starting from `0` */\n', '    mapping(uint => Period) periods;\n', '\n', '    /** WIN tokens contract  */\n', '    WIN public win;\n', '\n', '    /** The state of the crowdsale - `NotStarted`, `Presale`, `Sale` */\n', '    State public state;\n', '\n', '    /** the counter of investment by a country code (3-digit ISO 3166 code) */\n', '    mapping(uint16 => uint256) investmentsByCountries;\n', '\n', '    /**\n', '     * Returns amount of Wei invested by the specified country\n', '     * @param country - 3-digit country code\n', '     */\n', '    function getInvestmentsByCountry (uint16 country)   constant   returns (uint256 investment) {  \n', '        investment = investmentsByCountries[country];\n', '    }\n', '\n', '    /**\n', '     * Returns the Token price in the current period\n', '     * @return tokenPrice - current Token price\n', '     */\n', '    function getTokenPrice ()   constant   returns (uint256 tokenPrice) {  \n', '        tokenPrice = periods[currentPeriod].tokenPrice;\n', '    }\n', '\n', '    /**\n', '     * Returns the Token price for the period requested\n', '     * @param periodIndex - the period index\n', '     * @return tokenPrice - Token price for the period\n', '     */\n', '    function getTokenPriceForPeriod (uint periodIndex)   constant   returns (uint256 tokenPrice) {  \n', '        tokenPrice = periods[periodIndex].tokenPrice;\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of Tokens sold\n', '     * @param period - period index to get tokens for\n', '     * @return tokensSold - amount of tokens sold\n', '     */\n', '    function getTokensSold (uint period)   constant   returns (uint256 tokensSold) {  \n', '        return periods[period].tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if TokenDistribution has enough tokens for the current period\n', '     * and thus going on\n', '     * @return active - `true` if TokenDistribution is going on, `false` otherwise\n', '     */\n', '    function isActive ()   constant   returns (bool active) {  \n', '        return win.balanceOf(this) >= totalUnclaimedTokens + tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', '    }\n', '\n', '    /**\n', '     * Accepts money deposit and makes record\n', '     * minimum deposit is MINIMUM_DEPOSIT\n', '     * @param beneficiar - the address to receive Tokens\n', '     * @param countryCode - 3-digit country code\n', '     * @dev if `msg.value < MINIMUM_DEPOSIT` throws\n', '     */\n', '    function deposit (address beneficiar, uint16 countryCode)   payable  {  \n', '        require(msg.value >= MINIMUM_DEPOSIT);\n', '        require(state == State.Sale || state == State.Presale);\n', '\n', '        /* this should end any finished period before starting any operations */\n', '        tick();\n', '\n', '        /* check if have enough tokens for the current period\n', '         * if not, the call fails until tokens are deposited to the contract\n', '         */\n', '        require(isActive());\n', '\n', '        uint256 tokensBought = msg.value / getTokenPrice();\n', '\n', '        if(periods[currentPeriod].tokensSold + tokensBought >= tokensForPeriod(currentPeriod)) {\n', '            tokensBought = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', '        }\n', '\n', '        uint256 moneySpent = getTokenPrice() * tokensBought;\n', '\n', '        investmentsByCountries[countryCode] += moneySpent;\n', '\n', '        if(tokensBought > 0) {\n', '            assert(moneySpent <= msg.value);\n', '\n', '            /* return the rest */\n', '            if(msg.value > moneySpent) {\n', '                msg.sender.transfer(msg.value - moneySpent);\n', '            }\n', '\n', '            periods[currentPeriod].tokensSold += tokensBought;\n', '            unclaimedTokensForInvestor[beneficiar] += tokensBought;\n', '            totalUnclaimedTokens += tokensBought;\n', '            totalTokensSold += tokensBought;\n', '            Deposited(msg.sender, moneySpent, tokensBought);\n', '        }\n', '\n', '        /* if all tokens are sold, get to the next period */\n', '        tick();\n', '    }\n', '\n', '    /**\n', '     * See `deposit` function\n', '     */\n', '    function() payable {\n', '        deposit(msg.sender, UNKNOWN_COUNTRY);\n', '    }\n', '\n', '    /**\n', '     * Creates the contract and sets the owners\n', '     * @param owners_dot_recipient - array of 16 owner records  (MultiOwnable.Owner.recipient fields)\n', '* @param owners_dot_share - array of 16 owner records  (MultiOwnable.Owner.share fields)\n', '     */\n', '    function BlindCroupierTokenDistribution (address[16] owners_dot_recipient, uint[16] owners_dot_share)   MultiOwnable(owners_dot_recipient, owners_dot_share)  {  \n', 'MultiOwnable.Owner[16] memory owners;\n', '\n', 'for(uint __recipient_iterator__ = 0; __recipient_iterator__ < owners_dot_recipient.length;__recipient_iterator__++)\n', '  owners[__recipient_iterator__].recipient = address(owners_dot_recipient[__recipient_iterator__]);\n', 'for(uint __share_iterator__ = 0; __share_iterator__ < owners_dot_share.length;__share_iterator__++)\n', '  owners[__share_iterator__].share = uint(owners_dot_share[__share_iterator__]);\n', '        state = State.NotStarted;\n', '    }\n', '\n', '    /**\n', '     * Begins the crowdsale (presale period)\n', '     * @param tokenContractAddress - address of the `WIN` contract (token holder)\n', '     * @dev must be called by one of owners\n', '     */\n', '    function startPresale (address tokenContractAddress)   onlyOneOfOwners  {  \n', '        require(state == State.NotStarted);\n', '\n', '        win = WIN(tokenContractAddress);\n', '\n', '        assert(win.balanceOf(this) >= tokensForPeriod(0));\n', '\n', '        periods[0] = Period(now, NEVER, PRESALE_TOKEN_PRICE, 0);\n', '        PeriodStarted(0,\n', '            PRESALE_TOKEN_PRICE,\n', '            tokensForPeriod(currentPeriod),\n', '            now,\n', '            NEVER,\n', '            now);\n', '        state = State.Presale;\n', '    }\n', '\n', '    /**\n', '     * Ends the presale and begins period 1 of the crowdsale\n', '     * @dev must be called by one of owners\n', '     */\n', '    function endPresale ()   onlyOneOfOwners  {  \n', '        require(state == State.Presale);\n', '        state = State.Sale;\n', '        nextPeriod();\n', '    }\n', '\n', '    /**\n', '     * Returns a time interval for a specific `period`\n', '     * @param  period - period index to count interval for\n', '     * @return startTime - timestamp of period start time (INCLUSIVE)\n', '     * @return endTime - timestamp of period end time (INCLUSIVE)\n', '     */\n', '    function periodTimeFrame (uint period)   constant   returns (uint256 startTime, uint256 endTime) {  \n', '        require(period <= currentPeriod);\n', '\n', '        startTime = periods[period].startTime;\n', '        endTime = periods[period].endTime;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if the time for the `period` has already passed\n', '     */\n', '    function isPeriodTimePassed (uint period)   constant   returns (bool finished) {  \n', '        require(periods[period].startTime > 0);\n', '\n', '        uint256 endTime = periods[period].endTime;\n', '\n', '        if(endTime == NEVER) {\n', '            return false;\n', '        }\n', '\n', '        return (endTime < now);\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if `period` has already finished (time passed or tokens sold)\n', '     */\n', '    function isPeriodClosed (uint period)   constant   returns (bool finished) {  \n', '        return period < currentPeriod;\n', '    }\n', '\n', '    /**\n', '     * Returns `true` if all tokens for the `period` has been sold\n', '     */\n', '    function isPeriodAllTokensSold (uint period)   constant   returns (bool finished) {  \n', '        return periods[period].tokensSold == tokensForPeriod(period);\n', '    }\n', '\n', '    /**\n', '     * Returns unclaimed Tokens count for the caller\n', '     * @return tokens - amount of unclaimed Tokens for the caller\n', '     */\n', '    function unclaimedTokens ()   constant   returns (uint256 tokens) {  \n', '        return unclaimedTokensForInvestor[msg.sender];\n', '    }\n', '\n', '    /**\n', '     * Transfers all the tokens stored for this `investor` to his address\n', '     * @param investor - investor to claim tokens for\n', '     */\n', '    function claimAllTokensForInvestor (address investor)   {  \n', '        assert(totalUnclaimedTokens >= unclaimedTokensForInvestor[investor]);\n', '        totalUnclaimedTokens -= unclaimedTokensForInvestor[investor];\n', '        win.transfer(investor, unclaimedTokensForInvestor[investor]);\n', '        TokensClaimed(investor, unclaimedTokensForInvestor[investor]);\n', '        unclaimedTokensForInvestor[investor] = 0;\n', '    }\n', '\n', '    /**\n', '     * Claims all the tokens for the sender\n', '     * @dev efficiently calling `claimAllForInvestor(msg.sender)`\n', '     */\n', '    function claimAllTokens ()   {  \n', '        claimAllTokensForInvestor(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Returns the total token count for the period specified\n', '     * @param  period - period number\n', '     * @return tokens - total tokens count\n', '     */\n', '    function tokensForPeriod (uint period)   constant   returns (uint256 tokens) {  \n', '        if(period == 0) {\n', '            return TOKENS_FOR_PRESALE;\n', '        } else if(period == 1) {\n', '            return TOKENS_PER_FIRST_PERIOD;\n', '        } else {\n', '            return TOKENS_PER_PERIOD;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the duration of the sale (not presale) period\n', '     * @param  period - the period number\n', '     * @return duration - duration in seconds\n', '     */\n', '    function periodDuration (uint period)   constant   returns (uint256 duration) {  \n', '        require(period > 0);\n', '\n', '        if(period == 1) {\n', '            return FIRST_PERIOD_DURATION;\n', '        } else {\n', '            return PERIOD_DURATION;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Finishes the current period and starts a new one\n', '     */\n', '    function nextPeriod() internal {\n', '        uint256 oldPrice = periods[currentPeriod].tokenPrice;\n', '        uint256 newPrice;\n', '        if(currentPeriod == 0) {\n', '            newPrice = SALE_INITIAL_TOKEN_PRICE;\n', '        } else if(periods[currentPeriod].tokensSold  == tokensForPeriod(currentPeriod)) {\n', '            newPrice = Math.addPromille(oldPrice, FULLY_SOLD_PRICE_INCREASE);\n', '        } else if(periods[currentPeriod].tokensSold >= Math.takePromille(tokensForPeriod(currentPeriod), TOKENS_TO_INCREASE_NEXT_PRICE)) {\n', '            newPrice = Math.addPromille(oldPrice, PERIOD_PRICE_INCREASE);\n', '        } else {\n', '            newPrice = oldPrice;\n', '        }\n', '\n', '        /* destroy unsold tokens */\n', '        if(periods[currentPeriod].tokensSold < tokensForPeriod(currentPeriod)) {\n', '            uint256 toDestroy = tokensForPeriod(currentPeriod) - periods[currentPeriod].tokensSold;\n', "            /* do not destroy if we don't have enough to pay investors */\n", '            uint256 balance = win.balanceOf(this);\n', '            if(balance < toDestroy + totalUnclaimedTokens) {\n', '                toDestroy = (balance - totalUnclaimedTokens);\n', '            }\n', '            win.destroy(toDestroy);\n', '            totalTokensDestroyed += toDestroy;\n', '        }\n', '\n', '        /* if we are force ending the period set in the future or without end time,\n', '         * set end time to now\n', '         */\n', '        if(periods[currentPeriod].endTime > now ||\n', '            periods[currentPeriod].endTime == NEVER) {\n', '            periods[currentPeriod].endTime = now;\n', '        }\n', '\n', '        uint256 duration = periodDuration(currentPeriod + 1);\n', '\n', '        periods[currentPeriod + 1] = Period(\n', '            periods[currentPeriod].endTime,\n', '            periods[currentPeriod].endTime + duration,\n', '            newPrice,\n', '            0);\n', '\n', '        currentPeriod++;\n', '\n', '        PeriodStarted(currentPeriod,\n', '            newPrice,\n', '            tokensForPeriod(currentPeriod),\n', '            periods[currentPeriod].startTime,\n', '            periods[currentPeriod].endTime,\n', '            now);\n', '    }\n', '\n', '    /**\n', '     * To be called as frequently as required by any external party\n', '     * Will check if 1 or more periods have finished and move on to the next\n', '     */\n', '    function tick ()   {  \n', '        if(!isActive()) {\n', '            return;\n', '        }\n', '\n', '        while(state == State.Sale &&\n', '            (isPeriodTimePassed(currentPeriod) ||\n', '            isPeriodAllTokensSold(currentPeriod))) {\n', '            nextPeriod();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Withdraws the money to be spent to Blind Croupier Project needs\n', '     * @param  amount - amount of Wei to withdraw (total)\n', '     */\n', '    function withdraw (uint256 amount)   onlyOneOfOwners  {  \n', '        require(this.balance >= amount);\n', '\n', '        uint totalShares = 0;\n', '        for(var idx = 0; idx < owners.length; idx++) {\n', '            totalShares += owners[idx].share;\n', '        }\n', '\n', '        for(idx = 0; idx < owners.length; idx++) {\n', '            owners[idx].recipient.transfer(amount * owners[idx].share / totalShares);\n', '        }\n', '    }\n', '}']
