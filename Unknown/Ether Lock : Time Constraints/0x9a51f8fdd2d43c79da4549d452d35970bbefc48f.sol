['pragma solidity ^0.4.11;\n', '\n', '//MOLD Bonus contract\n', '\n', 'contract SafeMath {\n', '  //internals\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '      assert(b > 0);\n', '      uint c = a / b;\n', '      assert(a == b * c + a % b);\n', '      return c;\n', '  }\n', '}\n', '\n', '// ERC 20 Token\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '\n', '/**\n', ' * MoldCoin pre-sell contract.\n', ' *\n', ' */\n', 'contract MoldCoin is StandardToken, SafeMath {\n', '\n', '    string public name = "MOLD";\n', '    string public symbol = "MLD";\n', '    uint public decimals = 18;\n', '\n', '    uint public startDatetime; //pre-sell start datetime seconds\n', '    uint public firstStageDatetime; //first 120 hours pre-sell in seconds\n', '    uint public secondStageDatetime; //second stage, 240 hours of pre-sell in seconds.\n', '    uint public endDatetime; //pre-sell end datetime seconds (set in constructor)\n', '\n', '    // Initial founder address (set in constructor)\n', '    // All deposited ETH will be instantly forwarded to this address.\n', '    address public founder;\n', '\n', '    // administrator address\n', '    address public admin;\n', '\n', '    uint public coinAllocation = 20 * 10**8 * 10**decimals; //2000M tokens supply for pre-sell\n', '    uint public angelAllocation = 2 * 10**8 * 10**decimals; // 200M of token supply allocated angel investor\n', '    uint public founderAllocation = 3 * 10**8 * 10**decimals; //300M of token supply allocated for the founder allocation\n', '\n', '    bool public founderAllocated = false; //this will change to true when the founder fund is allocated\n', '\n', '    uint public saleTokenSupply = 0; //this will keep track of the token supply created during the pre-sell\n', '    uint public salesVolume = 0; //this will keep track of the Ether raised during the pre-sell\n', '\n', '    uint public angelTokenSupply = 0; //this will keep track of the token angel supply\n', '\n', '    bool public halted = false; //the admin address can set this to true to halt the pre-sell due to emergency\n', '\n', '    event Buy(address indexed sender, uint eth, uint tokens);\n', '    event AllocateFounderTokens(address indexed sender, uint tokens);\n', '    event AllocateAngelTokens(address indexed sender, address to, uint tokens);\n', '    event AllocateUnsoldTokens(address indexed sender, address holder, uint tokens);\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier duringCrowdSale {\n', '        require(block.timestamp >= startDatetime && block.timestamp <= endDatetime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *\n', '     * Integer value representing the number of seconds since 1 January 1970 00:00:00 UTC\n', '     */\n', '    function MoldCoin(uint startDatetimeInSeconds, address founderWallet) {\n', '\n', '        admin = msg.sender;\n', '        founder = founderWallet;\n', '        startDatetime = startDatetimeInSeconds;\n', '        firstStageDatetime = startDatetime + 120 * 1 hours;\n', '        secondStageDatetime = firstStageDatetime + 240 * 1 hours;\n', '        endDatetime = secondStageDatetime + 2040 * 1 hours;\n', '\n', '    }\n', '\n', '    /**\n', '     * Price for crowdsale by time\n', '     */\n', '    function price(uint timeInSeconds) constant returns(uint) {\n', '        if (timeInSeconds < startDatetime) return 0;\n', '        if (timeInSeconds <= firstStageDatetime) return 15000; //120 hours\n', '        if (timeInSeconds <= secondStageDatetime) return 12000; //240 hours\n', '        if (timeInSeconds <= endDatetime) return 10000; //2040 hours\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * allow anyone sends funds to the contract\n', '     */\n', '    function buy() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    function() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Main token buy function.\n', '     * Buy for the sender itself or buy on the behalf of somebody else (third party address).\n', '     */\n', '    function buyRecipient(address recipient) duringCrowdSale payable {\n', '        require(!halted);\n', '\n', '        uint tokens = safeMul(msg.value, price(block.timestamp));\n', '        require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );\n', '\n', '        balances[recipient] = safeAdd(balances[recipient], tokens);\n', '\n', '        totalSupply = safeAdd(totalSupply, tokens);\n', '        saleTokenSupply = safeAdd(saleTokenSupply, tokens);\n', '        salesVolume = safeAdd(salesVolume, msg.value);\n', '\n', '        if (!founder.call.value(msg.value)()) revert(); //immediately send Ether to founder address\n', '\n', '        Buy(recipient, msg.value, tokens);\n', '    }\n', '\n', '    /**\n', '     * Set up founder address token balance.\n', '     */\n', '    function allocateFounderTokens() onlyAdmin {\n', '        require( block.timestamp > endDatetime );\n', '        require(!founderAllocated);\n', '\n', '        balances[founder] = safeAdd(balances[founder], founderAllocation);\n', '        totalSupply = safeAdd(totalSupply, founderAllocation);\n', '        founderAllocated = true;\n', '\n', '        AllocateFounderTokens(msg.sender, founderAllocation);\n', '    }\n', '\n', '    /**\n', '     * Set up angel address token balance.\n', '     */\n', '    function allocateAngelTokens(address angel, uint tokens) onlyAdmin {\n', '\n', '        require(safeAdd(angelTokenSupply,tokens) <= angelAllocation );\n', '\n', '        balances[angel] = safeAdd(balances[angel], tokens);\n', '        angelTokenSupply = safeAdd(angelTokenSupply, tokens);\n', '        totalSupply = safeAdd(totalSupply, tokens);\n', '\n', '        AllocateAngelTokens(msg.sender, angel, tokens);\n', '    }\n', '\n', '    /**\n', '     * Emergency Stop crowdsale.\n', '     */\n', '    function halt() onlyAdmin {\n', '        halted = true;\n', '    }\n', '\n', '    function unhalt() onlyAdmin {\n', '        halted = false;\n', '    }\n', '\n', '    /**\n', '     * Change admin address.\n', '     */\n', '    function changeAdmin(address newAdmin) onlyAdmin  {\n', '        admin = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * arrange unsold coins\n', '     */\n', '    function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin {\n', '        require( block.timestamp > endDatetime );\n', '        require( safeAdd(saleTokenSupply,tokens) <= coinAllocation );\n', '        require( balances[holder] >0 );\n', '\n', '        balances[holder] = safeAdd(balances[holder], tokens);\n', '        saleTokenSupply = safeAdd(saleTokenSupply, tokens);\n', '        totalSupply = safeAdd(totalSupply, tokens);\n', '\n', '        AllocateUnsoldTokens(msg.sender, holder, tokens);\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract MoldCoinBonus is SafeMath {\n', '\n', '    function bonusBalanceOf(address _owner) constant returns (uint256 balance) {\n', '        return bonusBalances[_owner];\n', '    }\n', '\n', '    mapping (address => uint256) bonusBalances;\n', '\n', '    // administrator address\n', '    address public admin;\n', '\n', '    // crowdfund address\n', '    MoldCoin public fundAddress;\n', '    uint public rate = 10;\n', '    uint public totalSupply = 0;\n', '\n', '    bool public halted = false; //the admin address can set this to true to halt the pre-sell due to emergency\n', '\n', '    event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus);\n', '    event BuyForFriend(address indexed sender, address indexed friend, uint eth, uint tokens, uint bonus);\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier validSale {\n', '        require(!halted);\n', '        require(!fundAddress.halted());\n', '        _;\n', '    }\n', '\n', '    function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) {\n', '\n', '        admin = msg.sender;\n', '        fundAddress = _fundAddress;\n', '        rate = _rate;\n', '\n', '    }\n', '\n', '    function buyWithBonus(address inviter) validSale payable {\n', '\n', '        require( msg.sender != inviter );\n', '\n', '        uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp));\n', '        uint bonus = safeDiv(safeMul(tokens, rate), 100);\n', '\n', '        fundAddress.buyRecipient.value(msg.value)(msg.sender); //send Ether to pre-sale contract address\n', '\n', '        totalSupply = safeAdd(totalSupply, bonus*2);\n', '\n', '        bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus);\n', '        bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus);\n', '        BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus);\n', '\n', '    }\n', '\n', '\n', '    /**\n', '     * Emergency Stop.\n', '     */\n', '    function halt() onlyAdmin {\n', '        halted = true;\n', '    }\n', '\n', '    function unhalt() onlyAdmin {\n', '        halted = false;\n', '    }\n', '\n', '    /**\n', '     * Change admin address.\n', '     */\n', '    function changeAdmin(address newAdmin) onlyAdmin  {\n', '        admin = newAdmin;\n', '    }\n', '\n', '    function changeRate(uint _rate) onlyAdmin  {\n', '        rate = _rate;\n', '    }\n', '\n', '}']