['pragma solidity ^0.4.13;\n', '\n', 'contract owned {\n', ' address public owner;\n', '\n', ' function owned() {\n', '     owner = msg.sender;\n', ' }\n', '\n', ' modifier onlyOwner {\n', '     require(msg.sender == owner);\n', '     _;\n', ' }\n', '\n', ' function transferOwnership(address newOwner) onlyOwner {\n', '     owner = newOwner;\n', ' }\n', '}\n', '\n', 'contract ICO_CONTRACT is owned {\n', '\n', '   event WithdrawEther (address indexed from, uint256 amount, uint256 balance);\n', '   event ReceivedEther (address indexed sender, uint256 amount);  \n', '   \n', '   uint256 minimunInputEther;\n', '   uint256 maximumInputEther;\n', '   \n', '   uint icoStartTime;\n', '   uint icoEndTime;\n', '   \n', '   bool isStopFunding;\n', '   \n', '   function ICO_CONTRACT() {\n', '       minimunInputEther = 1 ether;\n', '       maximumInputEther = 500 ether;\n', '       \n', '       icoStartTime = now;\n', '       icoEndTime = now + 14 * 1 days;\n', '       \n', '       isStopFunding = false;\n', '   }\n', '   \n', '   function getBalance() constant returns (uint256){\n', '       return address(this).balance;\n', '   }\n', '   \n', '   function withdrawEther(uint256 _amount) onlyOwner returns (bool){\n', '       \n', '       if(_amount > getBalance()) {\n', '           return false;\n', '       }\n', '       owner.transfer(_amount);\n', '       WithdrawEther(msg.sender, _amount, getBalance());\n', '       return true;\n', '   }\n', '   \n', '   function withdrawEtherAll() onlyOwner returns (bool){\n', '       uint256 _tempBal = getBalance();\n', '       owner.transfer(getBalance());\n', '       WithdrawEther(msg.sender, _tempBal, getBalance());\n', '       return true;\n', '   }\n', '\n', '   function setMiniumInputEther (uint256 _minimunInputEther) onlyOwner {\n', '       minimunInputEther = _minimunInputEther;\n', '   }\n', '   \n', '   function getMiniumInputEther() constant returns (uint256) {\n', '       return minimunInputEther;\n', '   }\n', '   \n', '   function setMaxiumInputEther (uint256 _maximumInputEther) onlyOwner {\n', '       maximumInputEther = _maximumInputEther;\n', '   }\n', '   \n', '   function getMaxiumInputEther() constant returns (uint256) {\n', '       return maximumInputEther;\n', '   }\n', '   \n', '   function setIcoStartTime(uint _startTime) onlyOwner {\n', '       icoStartTime = _startTime;\n', '   }\n', '   \n', '   function setIcoEndTime(uint _endTime) onlyOwner {\n', '       icoEndTime = _endTime;\n', '   }\n', '   \n', '   function setIcoTimeStartEnd(uint _startTime, uint _endTime) onlyOwner {\n', '       if(_startTime > _endTime) {\n', '           return;\n', '       }\n', '       \n', '       icoStartTime = _startTime;\n', '       icoEndTime = _endTime;\n', '   }\n', '   \n', '   function setStopFunding(bool _isStopFunding) onlyOwner {\n', '       isStopFunding = _isStopFunding;\n', '   }\n', '   \n', '   function getIcoTime() constant returns (uint, uint) {\n', '       return (icoStartTime, icoEndTime);\n', '   }\n', '\n', '   function () payable {\n', '       \n', '       if(msg.value < minimunInputEther) {\n', '           throw;\n', '       }\n', '       \n', '       if(msg.value > maximumInputEther) {\n', '           throw;\n', '       }\n', '       \n', '       if(!isFundingNow()) {\n', '           throw;\n', '       }\n', '       \n', '       if(isStopFunding) {\n', '           throw;\n', '       }\n', '       \n', '       ReceivedEther(msg.sender, msg.value);\n', '   }\n', '   \n', '   function isFundingNow() constant returns (bool) {\n', '       return (now > icoStartTime && now < icoEndTime);\n', '   }\n', '   \n', '   function getIsStopFunding() constant returns (bool) {\n', '       return isStopFunding;\n', '   }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract owned {\n', ' address public owner;\n', '\n', ' function owned() {\n', '     owner = msg.sender;\n', ' }\n', '\n', ' modifier onlyOwner {\n', '     require(msg.sender == owner);\n', '     _;\n', ' }\n', '\n', ' function transferOwnership(address newOwner) onlyOwner {\n', '     owner = newOwner;\n', ' }\n', '}\n', '\n', 'contract ICO_CONTRACT is owned {\n', '\n', '   event WithdrawEther (address indexed from, uint256 amount, uint256 balance);\n', '   event ReceivedEther (address indexed sender, uint256 amount);  \n', '   \n', '   uint256 minimunInputEther;\n', '   uint256 maximumInputEther;\n', '   \n', '   uint icoStartTime;\n', '   uint icoEndTime;\n', '   \n', '   bool isStopFunding;\n', '   \n', '   function ICO_CONTRACT() {\n', '       minimunInputEther = 1 ether;\n', '       maximumInputEther = 500 ether;\n', '       \n', '       icoStartTime = now;\n', '       icoEndTime = now + 14 * 1 days;\n', '       \n', '       isStopFunding = false;\n', '   }\n', '   \n', '   function getBalance() constant returns (uint256){\n', '       return address(this).balance;\n', '   }\n', '   \n', '   function withdrawEther(uint256 _amount) onlyOwner returns (bool){\n', '       \n', '       if(_amount > getBalance()) {\n', '           return false;\n', '       }\n', '       owner.transfer(_amount);\n', '       WithdrawEther(msg.sender, _amount, getBalance());\n', '       return true;\n', '   }\n', '   \n', '   function withdrawEtherAll() onlyOwner returns (bool){\n', '       uint256 _tempBal = getBalance();\n', '       owner.transfer(getBalance());\n', '       WithdrawEther(msg.sender, _tempBal, getBalance());\n', '       return true;\n', '   }\n', '\n', '   function setMiniumInputEther (uint256 _minimunInputEther) onlyOwner {\n', '       minimunInputEther = _minimunInputEther;\n', '   }\n', '   \n', '   function getMiniumInputEther() constant returns (uint256) {\n', '       return minimunInputEther;\n', '   }\n', '   \n', '   function setMaxiumInputEther (uint256 _maximumInputEther) onlyOwner {\n', '       maximumInputEther = _maximumInputEther;\n', '   }\n', '   \n', '   function getMaxiumInputEther() constant returns (uint256) {\n', '       return maximumInputEther;\n', '   }\n', '   \n', '   function setIcoStartTime(uint _startTime) onlyOwner {\n', '       icoStartTime = _startTime;\n', '   }\n', '   \n', '   function setIcoEndTime(uint _endTime) onlyOwner {\n', '       icoEndTime = _endTime;\n', '   }\n', '   \n', '   function setIcoTimeStartEnd(uint _startTime, uint _endTime) onlyOwner {\n', '       if(_startTime > _endTime) {\n', '           return;\n', '       }\n', '       \n', '       icoStartTime = _startTime;\n', '       icoEndTime = _endTime;\n', '   }\n', '   \n', '   function setStopFunding(bool _isStopFunding) onlyOwner {\n', '       isStopFunding = _isStopFunding;\n', '   }\n', '   \n', '   function getIcoTime() constant returns (uint, uint) {\n', '       return (icoStartTime, icoEndTime);\n', '   }\n', '\n', '   function () payable {\n', '       \n', '       if(msg.value < minimunInputEther) {\n', '           throw;\n', '       }\n', '       \n', '       if(msg.value > maximumInputEther) {\n', '           throw;\n', '       }\n', '       \n', '       if(!isFundingNow()) {\n', '           throw;\n', '       }\n', '       \n', '       if(isStopFunding) {\n', '           throw;\n', '       }\n', '       \n', '       ReceivedEther(msg.sender, msg.value);\n', '   }\n', '   \n', '   function isFundingNow() constant returns (bool) {\n', '       return (now > icoStartTime && now < icoEndTime);\n', '   }\n', '   \n', '   function getIsStopFunding() constant returns (bool) {\n', '       return isStopFunding;\n', '   }\n', '}']
