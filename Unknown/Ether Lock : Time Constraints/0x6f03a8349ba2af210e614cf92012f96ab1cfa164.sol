['pragma solidity ^0.4.9;\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title MainstreetToken\n', ' */\n', 'contract MainstreetToken is ERC20 {\n', "    string public name = 'Mainstreet Token';             //The Token's name: e.g. DigixDAO Tokens\n", '    uint8 public decimals = 18;             // 1Token ¨= 1$ (1ETH ¨= 10$)\n', "    string public symbol = 'MIT';           //An identifier: e.g. REP\n", "    string public version = 'MIT_0.1';\n", '\n', '    mapping (address => uint) ownerMIT;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public totalMIT;\n', '    uint public start;\n', '\n', '    address public mainstreetCrowdfund;\n', '\n', '    address public intellisys;\n', '\n', '    bool public testing;\n', '\n', '    modifier fromCrowdfund() {\n', '        if (msg.sender != mainstreetCrowdfund) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isActive() {\n', '        if (block.timestamp < start) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isNotActive() {\n', '        if (!testing && block.timestamp >= start) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier recipientIsValid(address recipient) {\n', '        if (recipient == 0 || recipient == address(this)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier allowanceIsZero(address spender, uint value) {\n', '        // To change the approve amount you first have to reduce the addresses´\n', '        // allowance to zero by calling `approve(_spender,0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((value != 0) && (allowed[msg.sender][spender] != 0)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _mainstreetCrowdfund Address of crowdfund contract.\n', "     * @param _intellisys Address to receive intellisys' tokens.\n", '     * @param _start Timestamp when the token becomes active.\n', '     */\n', '    function MainstreetToken(address _mainstreetCrowdfund, address _intellisys, uint _start, bool _testing) {\n', '        mainstreetCrowdfund = _mainstreetCrowdfund;\n', '        intellisys = _intellisys;\n', '        start = _start;\n', '        testing = _testing;\n', '    }\n', '\n', '    /**\n', '     * @dev Add to token balance on address. Must be from crowdfund.\n', '     * @param recipient Address to add tokens to.\n', '     * @return MIT Amount of MIT to add.\n', '     */\n', '    function addTokens(address recipient, uint MIT) external isNotActive fromCrowdfund {\n', '        ownerMIT[recipient] += MIT;\n', '        uint intellisysMIT = MIT / 10;\n', '        ownerMIT[intellisys] += intellisysMIT;\n', '        totalMIT += MIT + intellisysMIT;\n', '        Transfer(0x0, recipient, MIT);\n', '        Transfer(0x0, intellisys, intellisysMIT);\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 totalSupply()\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        totalSupply = totalMIT;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 balanceOf()\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        balance = ownerMIT[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 transfer()\n', '     */\n', '    function transfer(address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\n', '        if (ownerMIT[msg.sender] >= _value) {\n', '            ownerMIT[msg.sender] -= _value;\n', '            ownerMIT[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 transferFrom()\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\n', '        if (allowed[_from][msg.sender] >= _value && ownerMIT[_from] >= _value) {\n', '            ownerMIT[_to] += _value;\n', '            ownerMIT[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 approve()\n', '     */\n', '    function approve(address _spender, uint256 _value) isActive allowanceIsZero(_spender, _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 allowance()\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        remaining = allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title MainstreetCrowdfund\n', ' */\n', 'contract MainstreetCrowdfund {\n', '\n', '    uint public start;\n', '    uint public end;\n', '\n', '    mapping (address => uint) public senderETH;\n', '    mapping (address => uint) public senderMIT;\n', '    mapping (address => uint) public recipientETH;\n', '    mapping (address => uint) public recipientMIT;\n', '    mapping (address => uint) public recipientExtraMIT;\n', '\n', '    uint public totalETH;\n', '    uint public limitETH;\n', '\n', '    uint public bonus1StartETH;\n', '    uint public bonus2StartETH;\n', '\n', '    mapping (address => bool) public whitelistedAddresses;\n', '\n', '    address public exitAddress;\n', '    address public creator;\n', '\n', '    MainstreetToken public mainstreetToken;\n', '\n', '    event MITPurchase(address indexed sender, address indexed recipient, uint ETH, uint MIT);\n', '\n', '    modifier saleActive() {\n', '        if (address(mainstreetToken) == 0) {\n', '            throw;\n', '        }\n', '        if (block.timestamp < start || block.timestamp >= end) {\n', '            throw;\n', '        }\n', '        if (totalETH + msg.value > limitETH) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier hasValue() {\n', '        if (msg.value == 0) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier senderIsWhitelisted() {\n', '        if (whitelistedAddresses[msg.sender] != true) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier recipientIsValid(address recipient) {\n', '        if (recipient == 0 || recipient == address(this)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier tokenContractNotSet() {\n', '        if (address(mainstreetToken) != 0) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _start Timestamp of when the crowdsale will start.\n', '     * @param _end Timestamp of when the crowdsale will end.\n', '     * @param _limitETH Maximum amount of ETH that can be sent to the contract in total. Denominated in wei.\n', '     * @param _bonus1StartETH Amount of Ether (denominated in wei) that is required to qualify for the first bonus.\n', '     * @param _bonus1StartETH Amount of Ether (denominated in wei) that is required to qualify for the second bonus.\n', '     * @param _exitAddress Address that all ETH should be forwarded to.\n', '     * @param whitelist1 First address that can send ETH.\n', '     * @param whitelist2 Second address that can send ETH.\n', '     * @param whitelist3 Third address that can send ETH.\n', '     */\n', '    function MainstreetCrowdfund(uint _start, uint _end, uint _limitETH, uint _bonus1StartETH, uint _bonus2StartETH, address _exitAddress, address whitelist1, address whitelist2, address whitelist3) {\n', '        creator = msg.sender;\n', '        start = _start;\n', '        end = _end;\n', '        limitETH = _limitETH;\n', '        bonus1StartETH = _bonus1StartETH;\n', '        bonus2StartETH = _bonus2StartETH;\n', '\n', '        whitelistedAddresses[whitelist1] = true;\n', '        whitelistedAddresses[whitelist2] = true;\n', '        whitelistedAddresses[whitelist3] = true;\n', '        exitAddress = _exitAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address of the token contract. Must be called by creator of this. Can only be set once.\n', '     * @param _mainstreetToken Address of the token contract.\n', '     */\n', '    function setTokenContract(MainstreetToken _mainstreetToken) external isCreator tokenContractNotSet {\n', '        mainstreetToken = _mainstreetToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Forward Ether to the exit address. Store all ETH and MIT information in public state and logs.\n', '     * @param recipient Address that tokens should be attributed to.\n', '     * @return MIT Amount of MIT purchased. This does not include the per-recipient quantity bonus.\n', '     */\n', '    function purchaseMIT(address recipient) external senderIsWhitelisted payable saleActive hasValue recipientIsValid(recipient) returns (uint increaseMIT) {\n', '\n', '        // Attempt to send the ETH to the exit address.\n', '        if (!exitAddress.send(msg.value)) {\n', '            throw;\n', '        }\n', '\n', '        // Update ETH amounts.\n', '        senderETH[msg.sender] += msg.value;\n', '        recipientETH[recipient] += msg.value;\n', '        totalETH += msg.value;\n', '\n', '        // Calculate MIT purchased directly in this transaction.\n', '        uint MIT = msg.value * 10;   // $1 / MIT based on $10 / ETH value\n', '\n', '        // Calculate time-based bonus.\n', '        if (block.timestamp - start < 2 weeks) {\n', '            MIT += MIT / 10;    // 10% bonus\n', '        }\n', '        else if (block.timestamp - start < 5 weeks) {\n', '            MIT += MIT / 20;    // 5% bonus\n', '        }\n', '\n', '        // Record directly-purchased MIT.\n', '        senderMIT[msg.sender] += MIT;\n', '        recipientMIT[recipient] += MIT;\n', '\n', '        // Store previous value-based bonus for this address.\n', '        uint oldExtra = recipientExtraMIT[recipient];\n', '\n', '        // Calculate new value-based bonus.\n', '        if (recipientETH[recipient] >= bonus2StartETH) {\n', '            recipientExtraMIT[recipient] = (recipientMIT[recipient] * 75) / 1000;      // 7.5% bonus\n', '        }\n', '        else if (recipientETH[recipient] >= bonus1StartETH) {\n', '            recipientExtraMIT[recipient] = (recipientMIT[recipient] * 375) / 10000;      // 3.75% bonus\n', '        }\n', '\n', '        // Calculate MIT increase for this address from this transaction.\n', '        increaseMIT = MIT + (recipientExtraMIT[recipient] - oldExtra);\n', '\n', '        // Tell the token contract about the increase.\n', '        mainstreetToken.addTokens(recipient, increaseMIT);\n', '\n', '        // Log this purchase.\n', '        MITPurchase(msg.sender, recipient, msg.value, increaseMIT);\n', '    }\n', '\n', '}']