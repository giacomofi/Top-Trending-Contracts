['pragma solidity ^0.4.0;\n', '\n', 'contract Owned\n', '{\n', '    address creator = msg.sender;\n', '    address owner01 = msg.sender;\n', '    address owner02;\n', '    address owner03;\n', '    \n', '    function\n', '    isCreator()\n', '    internal\n', '    returns (bool)\n', '    {\n', '       return(msg.sender == creator);\n', '    }\n', '    \n', '    function\n', '    isOwner()\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return(msg.sender == owner01 || msg.sender == owner02 || msg.sender == owner03);\n', '    }\n', '\n', '    event NewOwner(address indexed old, address indexed current);\n', '    \n', '    function\n', '    setOwner(uint owner, address _addr)\n', '    internal\n', '    {\n', '        if (address(0x0) != _addr)\n', '        {\n', '            if (isOwner() || isCreator())\n', '            {\n', '                if (0 == owner)\n', '                {\n', '                    NewOwner(owner01, _addr);\n', '                    owner01 = _addr;\n', '                }\n', '                else if (1 == owner)\n', '                {\n', '                    NewOwner(owner02, _addr);\n', '                    owner02 = _addr;\n', '                }\n', '                else {\n', '                    NewOwner(owner03, _addr);\n', '                    owner03 = _addr;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function\n', '    setOwnerOne(address _new)\n', '    public\n', '    {\n', '        setOwner(0, _new);\n', '    }\n', '    \n', '    function\n', '    setOwnerTwo(address _new)\n', '    public\n', '    {\n', '        setOwner(1, _new);\n', '    }\n', '    \n', '    function\n', '    setOwnerThree(address _new)\n', '    public\n', '    {\n', '        setOwner(2, _new);\n', '    }\n', '}\n', '\n', 'contract Bank is Owned\n', '{\n', '    struct Depositor {\n', '        uint amount;\n', '        uint time;\n', '    }\n', '\n', '    event Deposit(address indexed depositor, uint amount);\n', '    \n', '    event Donation(address indexed donator, uint amount);\n', '    \n', '    event Withdrawal(address indexed to, uint amount);\n', '    \n', '    event DepositReturn(address indexed depositor, uint amount);\n', '    \n', '    address owner0l;\n', '    uint numDeposits;\n', '    uint releaseDate;\n', '    mapping (address => Depositor) public Deposits;\n', '    address[] public Depositors;\n', '    \n', '    function\n', '    initBank(uint daysUntilRelease)\n', '    public\n', '    {\n', '        numDeposits = 0;\n', '        owner0l = msg.sender;\n', '        releaseDate = now;\n', '        if (daysUntilRelease > 0 && daysUntilRelease < (1 years * 5))\n', '        {\n', '            releaseDate += daysUntilRelease * 1 days;\n', '        }\n', '        else\n', '        {\n', '            // default 1 day\n', '            releaseDate += 1 days;\n', '        }\n', '    }\n', '\n', '    // Accept donations and deposits\n', '    function\n', '    ()\n', '    public\n', '    payable\n', '    {\n', '        if (msg.value > 0)\n', '        {\n', '            if (msg.value < 1 ether)\n', '                Donation(msg.sender, msg.value);\n', '            else\n', '                deposit();\n', '        }\n', '    }\n', '    \n', '    // Accept deposit and create Depositor record\n', '    function\n', '    deposit()\n', '    public\n', '    payable\n', '    returns (uint)\n', '    {\n', '        if (msg.value > 0)\n', '            addDeposit();\n', '        return getNumberOfDeposits();\n', '    }\n', '    \n', '    // Track deposits\n', '    function\n', '    addDeposit()\n', '    private\n', '    {\n', '        Depositors.push(msg.sender);\n', '        Deposits[msg.sender].amount = msg.value;\n', '        Deposits[msg.sender].time = now;\n', '        numDeposits++;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    function\n', '    returnDeposit()\n', '    public\n', '    {\n', '        if (now > releaseDate)\n', '        {\n', '            if (Deposits[msg.sender].amount > 1) {\n', '                uint _wei = Deposits[msg.sender].amount;\n', '                Deposits[msg.sender].amount = 0;\n', '                msg.sender.send(_wei);\n', '                DepositReturn(msg.sender, _wei);\n', '            }\n', '        }\n', '    }\n', '\n', '    // Depositor funds to be withdrawn after release period\n', '    function\n', '    withdrawDepositorFunds(address _to, uint _wei)\n', '    public\n', '    returns (bool)\n', '    {\n', '        if (_wei > 0)\n', '        {\n', '            if (isOwner() && Deposits[_to].amount > 0)\n', '            {\n', '                Withdrawal(_to, _wei);\n', '                return _to.send(_wei);\n', '            }\n', '        }\n', '    }\n', '\n', '    function\n', '    withdraw()\n', '    public\n', '    {\n', '        if (isCreator() && now >= releaseDate)\n', '        {\n', '            Withdrawal(creator, this.balance);\n', '            creator.send(this.balance);\n', '        }\n', '    }\n', '\n', '    function\n', '    getNumberOfDeposits()\n', '    public\n', '    constant\n', '    returns (uint)\n', '    {\n', '        return numDeposits;\n', '    }\n', '\n', '    function\n', '    kill()\n', '    public\n', '    {\n', '        if (isOwner() || isCreator())\n', '            selfdestruct(creator);\n', '    }\n', '}']
['pragma solidity ^0.4.0;\n', '\n', 'contract Owned\n', '{\n', '    address creator = msg.sender;\n', '    address owner01 = msg.sender;\n', '    address owner02;\n', '    address owner03;\n', '    \n', '    function\n', '    isCreator()\n', '    internal\n', '    returns (bool)\n', '    {\n', '       return(msg.sender == creator);\n', '    }\n', '    \n', '    function\n', '    isOwner()\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return(msg.sender == owner01 || msg.sender == owner02 || msg.sender == owner03);\n', '    }\n', '\n', '    event NewOwner(address indexed old, address indexed current);\n', '    \n', '    function\n', '    setOwner(uint owner, address _addr)\n', '    internal\n', '    {\n', '        if (address(0x0) != _addr)\n', '        {\n', '            if (isOwner() || isCreator())\n', '            {\n', '                if (0 == owner)\n', '                {\n', '                    NewOwner(owner01, _addr);\n', '                    owner01 = _addr;\n', '                }\n', '                else if (1 == owner)\n', '                {\n', '                    NewOwner(owner02, _addr);\n', '                    owner02 = _addr;\n', '                }\n', '                else {\n', '                    NewOwner(owner03, _addr);\n', '                    owner03 = _addr;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function\n', '    setOwnerOne(address _new)\n', '    public\n', '    {\n', '        setOwner(0, _new);\n', '    }\n', '    \n', '    function\n', '    setOwnerTwo(address _new)\n', '    public\n', '    {\n', '        setOwner(1, _new);\n', '    }\n', '    \n', '    function\n', '    setOwnerThree(address _new)\n', '    public\n', '    {\n', '        setOwner(2, _new);\n', '    }\n', '}\n', '\n', 'contract Bank is Owned\n', '{\n', '    struct Depositor {\n', '        uint amount;\n', '        uint time;\n', '    }\n', '\n', '    event Deposit(address indexed depositor, uint amount);\n', '    \n', '    event Donation(address indexed donator, uint amount);\n', '    \n', '    event Withdrawal(address indexed to, uint amount);\n', '    \n', '    event DepositReturn(address indexed depositor, uint amount);\n', '    \n', '    address owner0l;\n', '    uint numDeposits;\n', '    uint releaseDate;\n', '    mapping (address => Depositor) public Deposits;\n', '    address[] public Depositors;\n', '    \n', '    function\n', '    initBank(uint daysUntilRelease)\n', '    public\n', '    {\n', '        numDeposits = 0;\n', '        owner0l = msg.sender;\n', '        releaseDate = now;\n', '        if (daysUntilRelease > 0 && daysUntilRelease < (1 years * 5))\n', '        {\n', '            releaseDate += daysUntilRelease * 1 days;\n', '        }\n', '        else\n', '        {\n', '            // default 1 day\n', '            releaseDate += 1 days;\n', '        }\n', '    }\n', '\n', '    // Accept donations and deposits\n', '    function\n', '    ()\n', '    public\n', '    payable\n', '    {\n', '        if (msg.value > 0)\n', '        {\n', '            if (msg.value < 1 ether)\n', '                Donation(msg.sender, msg.value);\n', '            else\n', '                deposit();\n', '        }\n', '    }\n', '    \n', '    // Accept deposit and create Depositor record\n', '    function\n', '    deposit()\n', '    public\n', '    payable\n', '    returns (uint)\n', '    {\n', '        if (msg.value > 0)\n', '            addDeposit();\n', '        return getNumberOfDeposits();\n', '    }\n', '    \n', '    // Track deposits\n', '    function\n', '    addDeposit()\n', '    private\n', '    {\n', '        Depositors.push(msg.sender);\n', '        Deposits[msg.sender].amount = msg.value;\n', '        Deposits[msg.sender].time = now;\n', '        numDeposits++;\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    function\n', '    returnDeposit()\n', '    public\n', '    {\n', '        if (now > releaseDate)\n', '        {\n', '            if (Deposits[msg.sender].amount > 1) {\n', '                uint _wei = Deposits[msg.sender].amount;\n', '                Deposits[msg.sender].amount = 0;\n', '                msg.sender.send(_wei);\n', '                DepositReturn(msg.sender, _wei);\n', '            }\n', '        }\n', '    }\n', '\n', '    // Depositor funds to be withdrawn after release period\n', '    function\n', '    withdrawDepositorFunds(address _to, uint _wei)\n', '    public\n', '    returns (bool)\n', '    {\n', '        if (_wei > 0)\n', '        {\n', '            if (isOwner() && Deposits[_to].amount > 0)\n', '            {\n', '                Withdrawal(_to, _wei);\n', '                return _to.send(_wei);\n', '            }\n', '        }\n', '    }\n', '\n', '    function\n', '    withdraw()\n', '    public\n', '    {\n', '        if (isCreator() && now >= releaseDate)\n', '        {\n', '            Withdrawal(creator, this.balance);\n', '            creator.send(this.balance);\n', '        }\n', '    }\n', '\n', '    function\n', '    getNumberOfDeposits()\n', '    public\n', '    constant\n', '    returns (uint)\n', '    {\n', '        return numDeposits;\n', '    }\n', '\n', '    function\n', '    kill()\n', '    public\n', '    {\n', '        if (isOwner() || isCreator())\n', '            selfdestruct(creator);\n', '    }\n', '}']
