['//                       , ; ,   .-\'"""\'-.   , ; ,\n', "//                       \\\\|/  .'         '.  \\|//\n", '//                        \\-;-/   ()   ()   \\-;-/\n', '//                        // ;               ; \\\\\n', '//                       //__; :.         .; ;__\\\\\n', "//                      `-----\\'.'-.....-'.'/-----'\n", "//                             '.'.-.-,_.'.'\n", "//                               '(  (..-'\n", "//                                 '-'\n", '//   WHYSOS3RIOUS   PRESENTS :                          \n', '//                                                                \n', '//   MATCHING ETHERS                              \n', '//   a Strategy and Luck DaapGame          \n', '//   www.matching-ethers.com                 \n', '//\n', '//\n', '// *** coded by WhySoS3rious, 2016.                                       ***//\n', '// *** please do not copy without authorization                       ***//\n', '// *** contact : reddit    /u/WhySoS3rious                                ***//\n', '\n', '//VERSION : 1.0\n', '\n', '// GAME MODE : MATCHING FINNEYS\n', '// STAKE : 0.1 ETH\n', '\n', ' contract Matching_Finneys\n', '{\n', '    enum State{Active, Deactivated}\n', '    State public state;\n', '\n', '    modifier onlyOwner() {\n', '\t    if (msg.sender!=owner) throw;\n', '\t    _\n', '    }\n', '    modifier onlyActive() {\n', '         if (state!=State.Active) throw;\n', '         _\n', '    }\n', '    modifier onlyInactive() {\n', '         if (state!=State.Deactivated) throw;\n', '         _\n', '    }\n', '    modifier equalGambleValue() {\n', '\tif (msg.value < gamble_value) throw;\n', '        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n', '\t_\n', '    }\n', '    modifier resolvePendingRound{\n', '        blockLastPlayer=block.number+1;    \n', '        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n', '\telse if (pendingRound && blockLastPlayer==blockEndRound) throw;\n', '\t_\n', '    }\n', '\n', '    uint blockLastPlayer;\n', '    address private owner;\n', '    uint gamble_value;\n', '    uint information_cost;\n', '    uint round_max_size ;\n', '    uint round_min_size  ;  \n', '    uint index_player;\n', '    uint index_round_ended;\n', '    uint index_player_in_round;\n', '    bool pendingRound = false;\n', '    uint blockEndRound;\n', '    struct Gamble  {\n', '\t    address player;\n', '\t    bool flipped;\n', '    }\n', '    Gamble[] matchers; \n', '    Gamble[] contrarians;\n', '    struct Result  {\n', '\t    address player_matcher;\n', '\t    bool flipped_matcher;\n', '\t    uint256 payout_matcher;\n', '\t    address player_contrarian;\n', '\t    bool flipped_contrarian;\n', '\t    uint256 payout_contrarian;\n', '    }\n', '    Result[] results; \n', '    mapping (address => uint) payout_history;\n', '    mapping (address => uint) times_played_history;    \n', '     \n', '    //Contract Construtor\n', '    function Matching_Ethers() { //Initial settings\n', '\t    owner = msg.sender; \n', '\t    round_min_size = 16;\n', '\t    round_max_size = 20;\n', '\t    information_cost= 500 szabo; //0.0005 ether, 0.5 finney\n', '            gamble_value = 100000 szabo; //0.1 ether\n', '    }\n', '    //FallBack Function (play by sending a transaction)\n', '    function () { \n', '        bool flipped;\n', '        if (msg.value == gamble_value) flipped=false; \n', '        if (msg.value > gamble_value) {\n', '            flipped=true;\n', '        }\n', '        Play(flipped); \n', '    }\n', '    //Play Function (play by contract function call)\n', '    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n', '        if ( index_player_in_round%2==0 ) {   //first is matcher\n', '\t    matchers.push(Gamble(msg.sender, flipped));\n', '\t}\n', '\telse {\n', '\t    contrarians.push(Gamble(msg.sender, flipped));\n', '\t}\n', '        index_player+=1;\n', '        index_player_in_round+=1;\n', '\ttimes_played_history[msg.sender]+=1;\n', '        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n', '\t            bool end = randomEnd();\n', '\t\t    if (end) {\n', '\t\t        pendingRound=true;\n', '\t\t\tblockEndRound=block.number;}\n', '        }\n', '    }\n', '    //Random Number Generator (between 1 and range)\n', '    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n', '        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n', '    }\n', '    //Function that determines randomly when the round should be ended\n', '    function randomEnd() private returns(bool) {\n', '\tif (index_player_in_round==round_max_size) return true; //end if max_size\n', '\telse{\n', '\t    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n', '\t    if (random==1) return true;\n', '\t    else return false;\n', '\t    }\n', '    }\n', '    //Function to end Round and pay winners\n', '    function endRound() private {\n', '        delete results;\n', '        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n', '        uint256 payout_total;\n', '        for (var k = 0; k < (index_player_in_round)/2; k++) {\n', '            uint256 index_contrarian;\n', '\t    if (k+random_start_contrarian<(index_player_in_round)/2){\n', '\t        index_contrarian=k+random_start_contrarian;\n', '            }\n', '\t    else{\n', '\t        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n', '\t    }\n', '\t    uint256 information_cost_matcher = information_cost * k;\n', '\t    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n', '\t    uint256 information_cost_contrarian = information_cost * index_contrarian;\n', '\t    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n', '\t    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n', '\t    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n', '\t        matchers[k].player.send(payout_matcher);\n', '\t\tpayout_total+=payout_matcher;\n', '\t\tpayout_history[matchers[k].player]+=payout_matcher;\n', '\t    }\n', '\t    else {\n', '\t        contrarians[index_contrarian].player.send(payout_contrarian);\n', '\t\tpayout_total+=payout_contrarian;\n', '\t\tpayout_history[contrarians[k].player]+=payout_contrarian;\n', '\t    }\n', '\t}\n', '        index_round_ended+=1;\n', '        owner.send(index_player_in_round*gamble_value-payout_total);\n', '\tpayout_total=0;\n', '        index_player_in_round=0;\n', '        delete matchers;\n', '        delete contrarians;\n', '\tpendingRound=false;\n', '\tif (terminate_after_round==true) state=State.Deactivated;\n', '    }\n', '    //Full Refund of Current Round (if needed)\n', '    function refundRound() \n', '    onlyActive\n', '    onlyOwner noEthSent{  \n', '        uint totalRefund;\n', '\tuint balanceBeforeRefund=this.balance;\n', '        for (var k = 0;  k< matchers.length; k++) {\n', '\t            matchers[k].player.send(gamble_value);\n', '\t\t    totalRefund+=gamble_value;\n', '        }\n', '        for (var j = 0;  j< contrarians.length ; j++) {\t\n', '\t            contrarians[j].player.send(gamble_value);\n', '\t\t    totalRefund+=gamble_value;\t\t    \n', '        }\n', '\tdelete matchers;\n', '\tdelete contrarians;\n', '\tstate=State.Deactivated;\n', '\tindex_player_in_round=0;\n', '        uint balanceLeft = balanceBeforeRefund-totalRefund;\n', '\tif (balanceLeft >0) owner.send(balanceLeft);\n', '    }\n', '    //Function Pause contract after next round (for new contract or to change settings) \n', '    bool terminate_after_round=false;\n', '    function deactivate()\n', '    onlyOwner noEthSent{\n', '\t    terminate_after_round=true;\n', '    }\n', '    //Function Reactivates contract (after change of settings for instance or a refound)\n', '    function reactivate()\n', '    onlyOwner noEthSent{\n', '        state=State.Active;\n', '        terminate_after_round=false;\n', '    }\n', '    //Function to change game settings (within limits)\n', '    //(to adapt to community feedback, popularity)\n', '    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n', '\t    onlyOwner\n', '\t    onlyInactive noEthSent{\n', '\t    if (new_max_round<new_min_round) throw;\n', '\t    if (new_information_cost > new_gamble_value/100) throw;\n', '\t    round_max_size = new_max_round;\n', '\t    round_min_size = new_min_round;\n', '\t    information_cost= new_information_cost;\n', '\t    gamble_value = new_gamble_value;\n', '    }\n', '    function changeOwner(address new_owner)\n', '\t    onlyOwner noEthSent{\n', '\t    owner=new_owner;\n', '    }\n', '    \n', '\n', '    modifier noEthSent(){\n', '        if (msg.value>0) throw;\n', '\t_\n', '    }\n', '    //JSON GLOBAL STATS\n', '    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n', '    {\n', '         number_of_player_in_round = index_player_in_round;\n', '\t total_number_of_player = index_player;\n', '\t number_of_round_ended = index_round_ended;\n', '\t pending_round_to_resolve = pendingRound;\n', '\t block_end_last_round = blockEndRound;\n', '\t block_last_player = blockLastPlayer;\n', '\t state = state;\n', '\t pause_contract_after_round = terminate_after_round;\n', '     }\n', '     //JSON CURRENT SETTINGS\n', '     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n', '\t _gamble_value = gamble_value;\n', '\t _information_cost = information_cost;\n', '\t _round_min_size = round_min_size;\n', '\t _round_max_size = round_max_size;\n', '     }\n', '\n', '    //JSON MATCHER TEAM\n', '    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n', '        _address=matchers[_index].player;\n', '\t_flipped = matchers[_index].flipped;\n', '    }\n', '    //JSON CONTRARIAN TEAM\n', '    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n', '        _address=contrarians[_index].player;\n', '\t_flipped = contrarians[_index].flipped;\n', '    }\n', '    //JSON LAST ROUND RESULT\n', '    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n', '        _address_matcher=results[_index].player_matcher;\n', '        _address_contrarian=results[_index].player_contrarian;\n', '\t_flipped_matcher = results[_index].flipped_matcher;\n', '\t_flipped_contrarian = results[_index].flipped_contrarian;\n', '\t_payout_matcher =  results[_index].payout_matcher;\n', '\t_payout_contrarian =  results[_index].payout_contrarian;\n', '    }\n', '    //User set nickname for the website\n', '     mapping (address => string) nicknames;\n', '     function setNickname(string name) noEthSent{\n', '         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n', '             nicknames[msg.sender] = name;\n', '     }\n', '     function getNickname(address _address) noEthSent constant returns(string _name) {\n', '             _name = nicknames[_address];\n', '     }\n', '     //JSON HISTORY\n', '     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n', '             _payout = payout_history[_address]; \n', '     }\n', '     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n', '             _count = times_played_history[_address]; \n', '     }\n', '\n', '}']