['pragma solidity ^0.4.9;\n', '\n', '\n', '/***\n', ' * VIP Token and Crowdfunding contracts.\n', ' */\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title LegendsCrowdfund\n', ' */\n', 'contract LegendsCrowdfund {\n', '\n', '    address public creator;\n', '    address public exitAddress;\n', '\n', '    uint public start;\n', '    uint public limitVIP;\n', '\n', '    LegendsToken public legendsToken;\n', '\n', '    mapping (address => uint) public recipientETH;\n', '    mapping (address => uint) public recipientVIP;\n', '\n', '    uint public totalETH;\n', '    uint public totalVIP;\n', '\n', '    event VIPPurchase(address indexed sender, address indexed recipient, uint ETH, uint VIP);\n', '\n', '    modifier saleActive() {\n', '        if (address(legendsToken) == 0) {\n', '            throw;\n', '        }\n', '        if (block.timestamp < start) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier hasValue() {\n', '        if (msg.value == 0) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier recipientIsValid(address recipient) {\n', '        if (recipient == 0 || recipient == address(this)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier tokenContractNotSet() {\n', '        if (address(legendsToken) != 0) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _exitAddress Address that all ETH should be forwarded to.\n', '     * @param _start Timestamp of when the crowdsale will start.\n', '     * @param _limitVIP Maximum amount of VIP that can be allocated in total. Denominated in wei.\n', '     */\n', '    function LegendsCrowdfund(address _exitAddress, uint _start, uint _limitVIP) {\n', '        creator = msg.sender;\n', '        exitAddress = _exitAddress;\n', '        start = _start;\n', '        limitVIP = _limitVIP;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address of the token contract. Must be called by creator of this. Can only be set once.\n', '     * @param _legendsToken Address of the token contract.\n', '     */\n', '    function setTokenContract(LegendsToken _legendsToken) external isCreator tokenContractNotSet {\n', '        legendsToken = _legendsToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Forward Ether to the exit address. Store all ETH and VIP information in public state and logs.\n', '     * @param recipient Address that tokens should be attributed to.\n', '     */\n', '    function purchaseMembership(address sender, address recipient) external payable saleActive hasValue recipientIsValid(recipient) {\n', '\n', '        if (msg.sender != address(legendsToken)) {\n', '            throw;\n', '        }\n', '        // Attempt to send the ETH to the exit address.\n', '        if (!exitAddress.send(msg.value)) {\n', '            throw;\n', '        }\n', '\n', '        // Update ETH amounts.\n', '        recipientETH[recipient] += msg.value;\n', '        totalETH += msg.value;\n', '\n', '        // Calculate VIP amount.\n', '        uint VIP = msg.value * 12;  // $1 / VIP based on $10 / ETH value.\n', '\n', '        // Are we in the pre-sale?\n', '        if (block.timestamp - start < 2 weeks) {\n', '            VIP = (VIP * 10) / 9;   // 10% discount.\n', '        }\n', '\n', '        // Update VIP amounts.\n', '        recipientVIP[recipient] += VIP;\n', '        totalVIP += VIP;\n', '\n', '        // Check we have not exceeded the maximum VIP.\n', '        if (totalVIP > limitVIP) {\n', '            throw;\n', '        }\n', '\n', '        // Tell the token contract about the increase.\n', '        legendsToken.addTokens(recipient, VIP);\n', '\n', '        // Log this purchase.\n', '        VIPPurchase(sender, recipient, msg.value, VIP);\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title LegendsToken\n', ' */\n', 'contract LegendsToken is ERC20 {\n', "    string public name = 'VIP';             //The Token's name: e.g. DigixDAO Tokens\n", '    uint8 public decimals = 18;             // 1Token ¨= 1$ (1ETH ¨= 10$)\n', "    string public symbol = 'VIP';           //An identifier: e.g. REP\n", "    string public version = 'VIP_0.1';\n", '\n', '    mapping (address => uint) ownerVIP;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public totalVIP;\n', '    uint public start;\n', '\n', '    address public legendsCrowdfund;\n', '\n', '    bool public testing;\n', '\n', '    modifier fromCrowdfund() {\n', '        if (msg.sender != legendsCrowdfund) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isActive() {\n', '        if (block.timestamp < start) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier isNotActive() {\n', '        if (!testing && block.timestamp >= start) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier recipientIsValid(address recipient) {\n', '        if (recipient == 0 || recipient == address(this)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier allowanceIsZero(address spender, uint value) {\n', '        // To change the approve amount you first have to reduce the addresses´\n', '        // allowance to zero by calling `approve(_spender,0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((value != 0) && (allowed[msg.sender][spender] != 0)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _legendsCrowdfund Address of crowdfund contract.\n', '     * @param _preallocation Address to receive the pre-allocation.\n', '     * @param _start Timestamp when the token becomes active.\n', '     */\n', '    function LegendsToken(address _legendsCrowdfund, address _preallocation, uint _start, bool _testing) {\n', '        legendsCrowdfund = _legendsCrowdfund;\n', '        start = _start;\n', '        testing = _testing;\n', '        totalVIP = ownerVIP[_preallocation] = 25000 ether;\n', '    }\n', '\n', '    /**\n', '     * @dev Add to token balance on address. Must be from crowdfund.\n', '     * @param recipient Address to add tokens to.\n', '     * @return VIP Amount of VIP to add.\n', '     */\n', '    function addTokens(address recipient, uint VIP) external isNotActive fromCrowdfund {\n', '        ownerVIP[recipient] += VIP;\n', '        totalVIP += VIP;\n', '        Transfer(0x0, recipient, VIP);\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 totalSupply()\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        totalSupply = totalVIP;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 balanceOf()\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        balance = ownerVIP[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 transfer()\n', '     */\n', '    function transfer(address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\n', '        if (ownerVIP[msg.sender] >= _value) {\n', '            ownerVIP[msg.sender] -= _value;\n', '            ownerVIP[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 transferFrom()\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) isActive recipientIsValid(_to) returns (bool success) {\n', '        if (allowed[_from][msg.sender] >= _value && ownerVIP[_from] >= _value) {\n', '            ownerVIP[_to] += _value;\n', '            ownerVIP[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 approve()\n', '     */\n', '    function approve(address _spender, uint256 _value) isActive allowanceIsZero(_spender, _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements ERC20 allowance()\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        remaining = allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Direct Buy\n', '     */\n', '    function () payable {\n', '        LegendsCrowdfund(legendsCrowdfund).purchaseMembership.value(msg.value)(msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Proxy Buy\n', '     */\n', '    function purchaseMembership(address recipient) payable {\n', '        LegendsCrowdfund(legendsCrowdfund).purchaseMembership.value(msg.value)(msg.sender, recipient);\n', '    }\n', '\n', '}']