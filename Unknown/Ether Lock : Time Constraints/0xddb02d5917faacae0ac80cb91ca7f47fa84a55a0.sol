['pragma solidity ^0.4.8;\n', '\n', 'contract Owned {\n', '  address public owner;\n', '\n', '  function Owned() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) external onlyOwner {\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract FidgetSpinner is Owned {\n', '  int omega;\n', '  int theta;\n', '  uint public lastUpdate;\n', '\n', '  uint public decayRate;\n', '  uint public omegaPerEther;\n', '\n', '  int public largestRetro;\n', '  int public largestPro;\n', '\n', '  event Spin(\n', '    address indexed from,\n', '    int indexed direction,\n', '    uint amount\n', '  );\n', '\n', '  /*\n', '   * Creates a new FidgetSpinner whose spin decays at a rate of _decayNumerator/_decayDenominator% per second\n', '   * and who gains _omegaPerEther spin per Ether spent on spinning it.\n', '   */\n', '\tfunction FidgetSpinner(uint _decayRate, uint _omegaPerEther) {\n', '    lastUpdate = now;\n', '\t\tdecayRate = _decayRate;\n', '    omegaPerEther = _omegaPerEther;\n', '\t}\n', '\n', '\n', '  /*\n', '   * This makes it easy to override deltaTime in FidgetSpinnerTest so we can test that velocity/displacement decay is\n', '   * working correctly\n', '   */\n', '  function deltaTime() constant returns(uint) {\n', '    return now - lastUpdate;\n', '  }\n', '\n', '  /*\n', '   * Returns the velocity of the spinner during this specific block in the chain\n', '   */\n', '  function getCurrentVelocity() constant returns(int) {\n', '    int dir = -1;\n', '    if(omega == 0) {\n', '      return 0;\n', '    } else if(omega < 0) {\n', '      dir = 1;\n', '    }\n', '\n', '    uint timeElapsed = deltaTime();\n', '    uint deltaOmega = timeElapsed * decayRate;\n', '    int newOmega = omega + (int(deltaOmega) * dir);\n', '\n', '    // make sure we didn&#39;t cross zero\n', '    if((omega > 0 && newOmega < 0) || (omega < 0 && newOmega > 0)) {\n', '      return 0;\n', '    }\n', '\n', '    return newOmega;\n', '  }\n', '\n', '  /*\n', '   * Returns the displacement of the spinner during this specific block in the chain\n', '   */\n', '  function getCurrentDisplacement() constant returns(int) {\n', '    // integrates omega over time\n', '    int timeElapsed = int(deltaTime());\n', '\n', '    // find max time elapsed before v=0 (becomes max-height of trapezoid)\n', '    int maxTime = omega / int(decayRate);\n', '\n', '    if (maxTime < 0) {\n', '      maxTime *= -1;\n', '    }\n', '\n', '    if(timeElapsed > maxTime) {\n', '      timeElapsed = maxTime;\n', '    }\n', '\n', '    int deltaTheta = ((omega + getCurrentVelocity()) * timeElapsed) / 2;\n', '    return theta + deltaTheta;\n', '  }\n', '\n', '  /*\n', '   * Adds or subtracts from the spin of the spinner\n', '   *\n', '   * All changes to the spinner state should happen at the end of the current block. So multiple spins in the same block\n', '   * should be additive with their effects only becoming apparent in the next block.\n', '   */\n', '  function spin(int direction) payable {\n', '    require(direction == -1 || direction == 1);\n', '\n', '    int deltaOmega = (int(msg.value) * direction * int(omegaPerEther)) / 1 ether;\n', '    int newOmega = getCurrentVelocity() + deltaOmega;\n', '    int newTheta = getCurrentDisplacement();\n', '\n', '    omega = newOmega;\n', '    theta = newTheta;\n', '\n', '    if(-omega > largestRetro) {\n', '      largestRetro = -omega;\n', '    } else if(omega > largestPro) {\n', '      largestPro = omega;\n', '    }\n', '\n', '    Spin(msg.sender, direction, msg.value);\n', '    lastUpdate = now;\n', '  }\n', '\n', '  /*\n', '   * Withdraws all the money from the contract\n', '   */\n', '  function withdrawAll() onlyOwner {\n', '    withdraw(address(this).balance);\n', '  }\n', '\n', '  /*\n', '   * Withdraws a given amount of money from the contract\n', '   */\n', '  function withdraw(uint amount) onlyOwner {\n', '    owner.transfer(amount);\n', '  }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', 'contract Owned {\n', '  address public owner;\n', '\n', '  function Owned() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) external onlyOwner {\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract FidgetSpinner is Owned {\n', '  int omega;\n', '  int theta;\n', '  uint public lastUpdate;\n', '\n', '  uint public decayRate;\n', '  uint public omegaPerEther;\n', '\n', '  int public largestRetro;\n', '  int public largestPro;\n', '\n', '  event Spin(\n', '    address indexed from,\n', '    int indexed direction,\n', '    uint amount\n', '  );\n', '\n', '  /*\n', '   * Creates a new FidgetSpinner whose spin decays at a rate of _decayNumerator/_decayDenominator% per second\n', '   * and who gains _omegaPerEther spin per Ether spent on spinning it.\n', '   */\n', '\tfunction FidgetSpinner(uint _decayRate, uint _omegaPerEther) {\n', '    lastUpdate = now;\n', '\t\tdecayRate = _decayRate;\n', '    omegaPerEther = _omegaPerEther;\n', '\t}\n', '\n', '\n', '  /*\n', '   * This makes it easy to override deltaTime in FidgetSpinnerTest so we can test that velocity/displacement decay is\n', '   * working correctly\n', '   */\n', '  function deltaTime() constant returns(uint) {\n', '    return now - lastUpdate;\n', '  }\n', '\n', '  /*\n', '   * Returns the velocity of the spinner during this specific block in the chain\n', '   */\n', '  function getCurrentVelocity() constant returns(int) {\n', '    int dir = -1;\n', '    if(omega == 0) {\n', '      return 0;\n', '    } else if(omega < 0) {\n', '      dir = 1;\n', '    }\n', '\n', '    uint timeElapsed = deltaTime();\n', '    uint deltaOmega = timeElapsed * decayRate;\n', '    int newOmega = omega + (int(deltaOmega) * dir);\n', '\n', "    // make sure we didn't cross zero\n", '    if((omega > 0 && newOmega < 0) || (omega < 0 && newOmega > 0)) {\n', '      return 0;\n', '    }\n', '\n', '    return newOmega;\n', '  }\n', '\n', '  /*\n', '   * Returns the displacement of the spinner during this specific block in the chain\n', '   */\n', '  function getCurrentDisplacement() constant returns(int) {\n', '    // integrates omega over time\n', '    int timeElapsed = int(deltaTime());\n', '\n', '    // find max time elapsed before v=0 (becomes max-height of trapezoid)\n', '    int maxTime = omega / int(decayRate);\n', '\n', '    if (maxTime < 0) {\n', '      maxTime *= -1;\n', '    }\n', '\n', '    if(timeElapsed > maxTime) {\n', '      timeElapsed = maxTime;\n', '    }\n', '\n', '    int deltaTheta = ((omega + getCurrentVelocity()) * timeElapsed) / 2;\n', '    return theta + deltaTheta;\n', '  }\n', '\n', '  /*\n', '   * Adds or subtracts from the spin of the spinner\n', '   *\n', '   * All changes to the spinner state should happen at the end of the current block. So multiple spins in the same block\n', '   * should be additive with their effects only becoming apparent in the next block.\n', '   */\n', '  function spin(int direction) payable {\n', '    require(direction == -1 || direction == 1);\n', '\n', '    int deltaOmega = (int(msg.value) * direction * int(omegaPerEther)) / 1 ether;\n', '    int newOmega = getCurrentVelocity() + deltaOmega;\n', '    int newTheta = getCurrentDisplacement();\n', '\n', '    omega = newOmega;\n', '    theta = newTheta;\n', '\n', '    if(-omega > largestRetro) {\n', '      largestRetro = -omega;\n', '    } else if(omega > largestPro) {\n', '      largestPro = omega;\n', '    }\n', '\n', '    Spin(msg.sender, direction, msg.value);\n', '    lastUpdate = now;\n', '  }\n', '\n', '  /*\n', '   * Withdraws all the money from the contract\n', '   */\n', '  function withdrawAll() onlyOwner {\n', '    withdraw(address(this).balance);\n', '  }\n', '\n', '  /*\n', '   * Withdraws a given amount of money from the contract\n', '   */\n', '  function withdraw(uint amount) onlyOwner {\n', '    owner.transfer(amount);\n', '  }\n', '}']
