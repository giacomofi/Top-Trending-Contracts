['pragma solidity ^0.4.10;\n', '\n', 'contract Metronome {\n', '\n', '    // This is the constructor whose code is\n', '    // run only when the contract is created.\n', '    function Metronome() {\n', '    }\n', '    \n', '    \n', '    // total amount invested\n', '    uint public invested = 0;\n', '    \n', '    // stores the last ping of every participants\n', '    mapping (address => uint) public lastPing;\n', '    // stores the balance of each participant\n', '    mapping (address => uint) public balanceOf;\n', '    // stores the value of rewards the last time a player collected rewards\n', '    mapping (address => uint) public lastRewards;\n', '\n', '    uint public constant largeConstant = 1000000 ether;\n', '    // cumulative ratio of rewards over invested (multiplied by largeConstant)\n', '    uint public cumulativeRatios = 0;\n', '    \n', '    // this array is not used in the rules of the game\n', '    // it enables players to check the state of other players more easily\n', '    mapping (uint => address) public participants;\n', '    uint public countParticipants = 0;\n', '    \n', '    \n', '    /** Private and Constant functions */\n', '    \n', '    // adds a player to the array of participants\n', '    function addPlayer(address a) private {\n', '        if (lastPing[a] == 0) {\n', '            participants[countParticipants] = a;\n', '            countParticipants = countParticipants + 1;\n', '        }\n', '        lastPing[a] = now;\n', '    }\n', '    \n', '    \n', '    // updates the balance and updates the total invested amount\n', '    function modifyBalance(address a, uint x) private {\n', '        balanceOf[a] = balanceOf[a] + x;\n', '        invested = invested + x;\n', '    }\n', '    \n', '    // creates a new reward that can be claimed by users\n', '    function createReward(uint value, uint oldTotal) private {\n', '        if (oldTotal > 0)\n', '            cumulativeRatios = cumulativeRatios + (value * largeConstant) / oldTotal;\n', '    }\n', '    \n', '    // function called to forbid a player from claiming all past rewards\n', '    function forbid(address a) private {\n', '        lastRewards[a] = cumulativeRatios;\n', '    }\n', '    \n', '    // function to compute the next reward of a player\n', '    function getReward(address a) constant returns (uint) {\n', '        uint rewardsDifference = cumulativeRatios - lastRewards[a];\n', '        return (rewardsDifference * balanceOf[a]) / largeConstant;\n', '    }\n', '    \n', '    // function to compute the lost amount\n', '    function losingAmount(address a, uint toShare) constant returns (uint) {\n', '        return toShare - (((toShare*largeConstant)/invested)*balanceOf[a]) / largeConstant;\n', '    }\n', '    \n', '    /** Public functions */\n', '    \n', '    // to be called every day\n', '    function idle() {\n', '        lastPing[msg.sender] = now;\n', '    }\n', '    \n', '    // function called when a user wants to invest in the contract\n', '    // after calling this function you cannot claim past rewards\n', '    function invest() payable {\n', '        uint reward = getReward(msg.sender);\n', '        addPlayer(msg.sender);\n', '        modifyBalance(msg.sender, msg.value);\n', '        forbid(msg.sender);\n', '        createReward(reward, invested);\n', '    }\n', '    \n', '    // function called when a user wants to divest\n', '    function divest(uint256 value) {\n', '        require(value <= balanceOf[msg.sender]);\n', '        \n', '        uint reward = getReward(msg.sender);\n', '        modifyBalance(msg.sender, -value);\n', '        forbid(msg.sender);\n', '        createReward(reward, invested);\n', '        msg.sender.transfer(value);\n', '    }\n', '    \n', '    // claims the rewards\n', '    function claimRewards() {\n', '        uint reward = getReward(msg.sender);\n', '        modifyBalance(msg.sender,reward);\n', '        forbid(msg.sender);\n', '    }\n', '    \n', '    // used to take create a reward from the funds of someone who has not\n', '    // idled in the last 10 minutes\n', '    function poke(address a) {\n', '        require(now > lastPing[a] + 14 hours && balanceOf[a] > 0);\n', '        \n', '        uint missed = getReward(a);\n', '        uint toShare = balanceOf[a] / 10;\n', '        uint toLose = losingAmount(a, toShare);\n', '        \n', '        createReward(toShare, invested);\n', '        modifyBalance(a, -toLose);\n', '        forbid(a);\n', '        lastPing[a] = now;\n', '        createReward(missed, invested);\n', '    }\n', '}']