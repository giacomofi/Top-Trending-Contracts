['pragma solidity 0.4.4;\n', '\n', '\n', '/// @title Abstract token contract - Functions to be implemented by token contracts.\n', 'contract Token {\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '}\n', '\n', '\n', '/// @title Dutch auction contract - creation of Gnosis tokens.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', 'contract DutchAuction {\n', '\n', '    /*\n', '     *  Events\n', '     */\n', '    event BidSubmission(address indexed sender, uint256 amount);\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    uint constant public MAX_TOKENS_SOLD = 9000000 * 10**18; // 9M\n', '    uint constant public WAITING_PERIOD = 7 days;\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    Token public gnosisToken;\n', '    address public wallet;\n', '    address public owner;\n', '    uint public ceiling;\n', '    uint public priceFactor;\n', '    uint public startBlock;\n', '    uint public endTime;\n', '    uint public totalReceived;\n', '    uint public finalPrice;\n', '    mapping (address => uint) public bids;\n', '    Stages public stage;\n', '\n', '    /*\n', '     *  Enums\n', '     */\n', '    enum Stages {\n', '        AuctionDeployed,\n', '        AuctionStarted,\n', '        AuctionEnded,\n', '        TradingStarted\n', '    }\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier atStage(Stages _stage) {\n', '        if (stage != _stage)\n', '            // Contract not in expected state\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier isOwner() {\n', '        if (msg.sender != owner)\n', '            // Only owner is allowed to proceed\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier isWallet() {\n', '        if (msg.sender != wallet)\n', '            // Only owner is allowed to proceed\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier timedTransitions() {\n', '        if (stage == Stages.AuctionStarted && calcTokenPrice() <= calcStopPrice())\n', '            finalizeAuction();\n', '        if (stage == Stages.AuctionEnded && now > endTime + WAITING_PERIOD)\n', '            stage = Stages.TradingStarted;\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    /// @dev Contract constructor function sets owner.\n', '    /// @param _wallet Gnosis wallet.\n', '    /// @param _ceiling Auction ceiling.\n', '    /// @param _priceFactor Auction price factor.\n', '    function DutchAuction(address _wallet, uint _ceiling, uint _priceFactor)\n', '        public\n', '    {\n', '        if (_wallet == 0 || _ceiling == 0 || _priceFactor == 0)\n', '            // Arguments are null.\n', '            throw;\n', '        owner = msg.sender;\n', '        wallet = _wallet;\n', '        ceiling = _ceiling;\n', '        priceFactor = _priceFactor;\n', '        stage = Stages.AuctionDeployed;\n', '    }\n', '\n', "    /// @dev Setup function sets external contracts' addresses.\n", '    /// @param _gnosisToken Gnosis token address.\n', '    function setup(address _gnosisToken)\n', '        public\n', '        isOwner\n', '    {\n', '        if (address(gnosisToken) != 0 || _gnosisToken == 0)\n', '            // Setup was executed already or arguments are null.\n', '            throw;\n', '        gnosisToken = Token(_gnosisToken);\n', '    }\n', '\n', '    /// @dev Starts auction and sets startBlock.\n', '    function startAuction()\n', '        public\n', '        isWallet\n', '        atStage(Stages.AuctionDeployed)\n', '    {\n', '        stage = Stages.AuctionStarted;\n', '        startBlock = block.number;\n', '    }\n', '\n', '    /// @dev Changes auction ceiling and start price factor before auction is started.\n', '    /// @param _ceiling Updated auction ceiling.\n', '    /// @param _priceFactor Updated start price factor.\n', '    function changeSettings(uint _ceiling, uint _priceFactor)\n', '        public\n', '        isWallet\n', '        atStage(Stages.AuctionDeployed)\n', '    {\n', '        ceiling = _ceiling;\n', '        priceFactor = _priceFactor;\n', '    }\n', '\n', '    /// @dev Calculates current token price.\n', '    /// @return Returns token price.\n', '    function calcCurrentTokenPrice()\n', '        public\n', '        timedTransitions\n', '        returns (uint)\n', '    {\n', '        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)\n', '            return finalPrice;\n', '        return calcTokenPrice();\n', '    }\n', '\n', '    /// @dev Returns correct stage, even if a function with timedTransitions modifier has not yet been called yet.\n', '    /// @return Returns current auction stage.\n', '    function updateStage()\n', '        public\n', '        timedTransitions\n', '        returns (Stages)\n', '    {\n', '        return stage;\n', '    }\n', '\n', '    /// @dev Allows to send a bid to the auction.\n', '    /// @param receiver Bid will be assigned to this address if set.\n', '    function bid(address receiver)\n', '        public\n', '        payable\n', '        timedTransitions\n', '        atStage(Stages.AuctionStarted)\n', '        returns (uint amount)\n', '    {\n', '        // If a bid is done on behalf of a user via ShapeShift, the receiver address is set.\n', '        if (receiver == 0)\n', '            receiver = msg.sender;\n', '        amount = msg.value;\n', '        // Prevent that more than 90% of tokens are sold. Only relevant if cap not reached.\n', '        uint maxEther = (MAX_TOKENS_SOLD / 10**18) * calcTokenPrice() - totalReceived;\n', '        uint maxEtherBasedOnTotalReceived = ceiling - totalReceived;\n', '        if (maxEtherBasedOnTotalReceived < maxEther)\n', '            maxEther = maxEtherBasedOnTotalReceived;\n', '        // Only invest maximum possible amount.\n', '        if (amount > maxEther) {\n', '            amount = maxEther;\n', '            // Send change back to receiver address. In case of a ShapeShift bid the user receives the change back directly.\n', '            if (!receiver.send(msg.value - amount))\n', '                // Sending failed\n', '                throw;\n', '        }\n', '        // Forward funding to ether wallet\n', '        if (amount == 0 || !wallet.send(amount))\n', '            // No amount sent or sending failed\n', '            throw;\n', '        bids[receiver] += amount;\n', '        totalReceived += amount;\n', '        if (maxEther == amount)\n', '            // When maxEther is equal to the big amount the auction is ended and finalizeAuction is triggered.\n', '            finalizeAuction();\n', '        BidSubmission(receiver, amount);\n', '    }\n', '\n', '    /// @dev Claims tokens for bidder after auction.\n', '    /// @param receiver Tokens will be assigned to this address if set.\n', '    function claimTokens(address receiver)\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.TradingStarted)\n', '    {\n', '        if (receiver == 0)\n', '            receiver = msg.sender;\n', '        uint tokenCount = bids[receiver] * 10**18 / finalPrice;\n', '        bids[receiver] = 0;\n', '        gnosisToken.transfer(receiver, tokenCount);\n', '    }\n', '\n', '    /// @dev Calculates stop price.\n', '    /// @return Returns stop price.\n', '    function calcStopPrice()\n', '        constant\n', '        public\n', '        returns (uint)\n', '    {\n', '        return totalReceived * 10**18 / MAX_TOKENS_SOLD + 1;\n', '    }\n', '\n', '    /// @dev Calculates token price.\n', '    /// @return Returns token price.\n', '    function calcTokenPrice()\n', '        constant\n', '        public\n', '        returns (uint)\n', '    {\n', '        return priceFactor * 1 ether / (block.number - startBlock + 7500) + 1;\n', '    }\n', '\n', '    /*\n', '     *  Private functions\n', '     */\n', '    function finalizeAuction()\n', '        private\n', '    {\n', '        stage = Stages.AuctionEnded;\n', '        if (totalReceived == ceiling)\n', '            finalPrice = calcTokenPrice();\n', '        else\n', '            finalPrice = calcStopPrice();\n', '        uint soldTokens = totalReceived * 10**18 / finalPrice;\n', '        // Auction contract transfers all unsold tokens to Gnosis inventory multisig\n', '        gnosisToken.transfer(wallet, MAX_TOKENS_SOLD - soldTokens);\n', '        endTime = now;\n', '    }\n', '}']