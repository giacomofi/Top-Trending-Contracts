['pragma solidity ^0.4.15;\n', '\n', 'contract BTCRelay {\n', '    function getLastBlockHeight() public returns (int);\n', '    function getBlockchainHead() public returns (int);\n', '    function getFeeAmount(int blockHash) public returns (int);\n', '    function getBlockHeader(int blockHash) public returns (bytes32[5]);\n', '    function storeBlockHeader(bytes blockHeader) public returns (int);\n', '}\n', '\n', 'contract Escrow {\n', '    function deposit(address recipient) payable;\n', '}\n', '\n', 'contract EthereumLottery {\n', '    uint constant GAS_LIMIT_DEPOSIT = 300000;\n', '    uint constant GAS_LIMIT_BUY = 450000;\n', '\n', '    struct Lottery {\n', '        uint jackpot;\n', '        int decidingBlock;\n', '        uint numTickets;\n', '        uint numTicketsSold;\n', '        uint ticketPrice;\n', '        int winningTicket;\n', '        address winner;\n', '        uint finalizationBlock;\n', '        address finalizer;\n', '        string message;\n', '        mapping (uint => address) tickets;\n', '        int nearestKnownBlock;\n', '        int nearestKnownBlockHash;\n', '    }\n', '\n', '    address public owner;\n', '    address public admin;\n', '    address public proposedOwner;\n', '\n', '    int public id = -1;\n', '    uint public lastInitTimestamp;\n', '    uint public lastSaleTimestamp;\n', '\n', '    uint public recentActivityIdx;\n', '    uint[1000] public recentActivity;\n', '\n', '    mapping (int => Lottery) public lotteries;\n', '\n', '    address public btcRelay;\n', '    address public escrow;\n', '\n', '    enum Reason { TicketSaleClosed, TicketAlreadySold, InsufficientGas }\n', '    event PurchaseFailed(address indexed buyer, uint mark, Reason reason);\n', '    event PurchaseSuccessful(address indexed buyer, uint mark);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdminOrOwner {\n', '        require(msg.sender == owner || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier afterInitialization {\n', '        require(id >= 0);\n', '        _;\n', '    }\n', '\n', '    function EthereumLottery(address _btcRelay,\n', '                             address _escrow) {\n', '        owner = msg.sender;\n', '        admin = msg.sender;\n', '        btcRelay = _btcRelay;\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function needsInitialization() constant returns (bool) {\n', '        return id == -1 || lotteries[id].finalizationBlock > 0;\n', '    }\n', '\n', '    function initLottery(uint _jackpot, uint _numTickets, uint _ticketPrice)\n', '             onlyAdminOrOwner {\n', '        require(needsInitialization());\n', '        require(_numTickets * _ticketPrice > _jackpot);\n', '\n', '        id += 1;\n', '        lotteries[id].jackpot = _jackpot;\n', '        lotteries[id].decidingBlock = -1;\n', '        lotteries[id].numTickets = _numTickets;\n', '        lotteries[id].ticketPrice = _ticketPrice;\n', '        lotteries[id].winningTicket = -1;\n', '\n', '        lastInitTimestamp = block.timestamp;\n', '        lastSaleTimestamp = 0;\n', '    }\n', '\n', '    function buyTickets(uint[] _tickets, uint _mark, bytes _extraData)\n', '             payable afterInitialization {\n', '        if (msg.gas < GAS_LIMIT_BUY) {\n', '            PurchaseFailed(msg.sender, _mark, Reason.InsufficientGas);\n', '            return;\n', '        }\n', '\n', '        if (lotteries[id].numTicketsSold == lotteries[id].numTickets) {\n', '            PurchaseFailed(msg.sender, _mark, Reason.TicketSaleClosed);\n', '            return;\n', '        }\n', '\n', '        require(_tickets.length > 0);\n', '        require(msg.value == _tickets.length * lotteries[id].ticketPrice);\n', '\n', '        for (uint i = 0; i < _tickets.length; i++) {\n', '            uint ticket = _tickets[i];\n', '            require(ticket >= 0);\n', '            require(ticket < lotteries[id].numTickets);\n', '\n', '            if (lotteries[id].tickets[ticket] != 0) {\n', '                PurchaseFailed(msg.sender, _mark, Reason.TicketAlreadySold);\n', '                return;\n', '            }\n', '        }\n', '\n', '        for (i = 0; i < _tickets.length; i++) {\n', '            ticket = _tickets[i];\n', '            lotteries[id].tickets[ticket] = msg.sender;\n', '            recentActivity[recentActivityIdx] = ticket;\n', '\n', '            recentActivityIdx += 1;\n', '            if (recentActivityIdx >= recentActivity.length) {\n', '                recentActivityIdx = 0;\n', '            }\n', '        }\n', '\n', '        lotteries[id].numTicketsSold += _tickets.length;\n', '        lastSaleTimestamp = block.timestamp;\n', '\n', '        BTCRelay(btcRelay).storeBlockHeader(_extraData);\n', '\n', '        PurchaseSuccessful(msg.sender, _mark);\n', '    }\n', '\n', '    function needsBlockFinalization()\n', '             afterInitialization constant returns (bool) {\n', '        // Check the timestamp of the latest block known to BTCRelay\n', '        // and require it to be no more than 2 hours older than the\n', '        // timestamp of our block. This should ensure that BTCRelay\n', '        // is reasonably up to date.\n', '        uint btcTimestamp;\n', '        int blockHash = BTCRelay(btcRelay).getBlockchainHead();\n', '        (,btcTimestamp) = getBlockHeader(blockHash);\n', '\n', '        uint delta = 0;\n', '        if (btcTimestamp < block.timestamp) {\n', '            delta = block.timestamp - btcTimestamp;\n', '        }\n', '\n', '        return delta < 2 * 60 * 60 &&\n', '               lotteries[id].numTicketsSold == lotteries[id].numTickets &&\n', '               lotteries[id].decidingBlock == -1;\n', '    }\n', '\n', '    function finalizeBlock()\n', '             afterInitialization {\n', '        require(needsBlockFinalization());\n', '\n', '        // At this point we know that the timestamp of the latest block\n', '        // known to BTCRelay is within 2 hours of what the Ethereum network\n', '        // considers &#39;now&#39;. If we assume this to be correct within +/- 3 hours,\n', '        // we can conclude that &#39;out there&#39; in the real world at most 5 hours\n', '        // have passed. Assuming an actual block time of 9 minutes for Bitcoin,\n', '        // we can use the Poisson distribution to calculate, that if we wait for\n', '        // 54 more blocks, then the probability for all of these 54 blocks\n', '        // having already been mined in 5 hours is less than 0.1 %.\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        lotteries[id].decidingBlock = blockHeight + 54;\n', '    }\n', '\n', '    function needsLotteryFinalization()\n', '             afterInitialization constant returns (bool) {\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        return lotteries[id].decidingBlock != -1 &&\n', '               blockHeight >= lotteries[id].decidingBlock + 6 &&\n', '               lotteries[id].finalizationBlock == 0;\n', '    }\n', '\n', '    function finalizeLottery(uint _steps)\n', '             afterInitialization {\n', '        require(needsLotteryFinalization());\n', '\n', '        if (lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock) {\n', '            walkTowardsBlock(_steps);\n', '        } else {\n', '            int winningTicket = lotteries[id].nearestKnownBlockHash %\n', '                                int(lotteries[id].numTickets);\n', '            address winner = lotteries[id].tickets[uint(winningTicket)];\n', '\n', '            lotteries[id].winningTicket = winningTicket;\n', '            lotteries[id].winner = winner;\n', '            lotteries[id].finalizationBlock = block.number;\n', '            lotteries[id].finalizer = tx.origin;\n', '\n', '            if (winner != 0) {\n', '                uint value = lotteries[id].jackpot;\n', '                bool successful =\n', '                    winner.call.gas(GAS_LIMIT_DEPOSIT).value(value)();\n', '                if (!successful) {\n', '                    Escrow(escrow).deposit.value(value)(winner);\n', '                }\n', '            }\n', '\n', '            var _ = admin.call.gas(GAS_LIMIT_DEPOSIT).value(this.balance)();\n', '        }\n', '    }\n', '\n', '    function walkTowardsBlock(uint _steps) internal {\n', '        int blockHeight;\n', '        int blockHash;\n', '        if (lotteries[id].nearestKnownBlock == 0) {\n', '            blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '            blockHash = BTCRelay(btcRelay).getBlockchainHead();\n', '        } else {\n', '            blockHeight = lotteries[id].nearestKnownBlock;\n', '            blockHash = lotteries[id].nearestKnownBlockHash;\n', '        }\n', '\n', '        // Walk only a few steps to keep an upper limit on gas costs.\n', '        for (uint step = 0; step < _steps; step++) {\n', '            blockHeight -= 1;\n', '            (blockHash,) = getBlockHeader(blockHash);\n', '\n', '            if (blockHeight == lotteries[id].decidingBlock) { break; }\n', '        }\n', '\n', '        // Store the progress to pick up from there next time.\n', '        lotteries[id].nearestKnownBlock = blockHeight;\n', '        lotteries[id].nearestKnownBlockHash = blockHash;\n', '    }\n', '\n', '    function getBlockHeader(int blockHash)\n', '             internal returns (int prevBlockHash, uint timestamp) {\n', '        // We expect free access to BTCRelay.\n', '        int fee = BTCRelay(btcRelay).getFeeAmount(blockHash);\n', '        require(fee == 0);\n', '\n', '        // Code is based on tjade273&#39;s BTCRelayTools.\n', '        bytes32[5] memory blockHeader =\n', '            BTCRelay(btcRelay).getBlockHeader(blockHash);\n', '\n', '        prevBlockHash = 0;\n', '        for (uint i = 0; i < 32; i++) {\n', '            uint pos = 68 + i;  // prev. block hash starts at position 68\n', '            byte data = blockHeader[pos / 32][pos % 32];\n', '            prevBlockHash = prevBlockHash | int(data) * int(0x100 ** i);\n', '        }\n', '\n', '        timestamp = 0;\n', '        for (i = 0; i < 4; i++) {\n', '            pos = 132 + i;  // timestamp starts at position 132\n', '            data = blockHeader[pos / 32][pos % 32];\n', '            timestamp = timestamp | uint(data) * uint(0x100 ** i);\n', '        }\n', '\n', '        return (prevBlockHash, timestamp);\n', '    }\n', '\n', '    function getMessageLength(string _message) constant returns (uint) {\n', '        return bytes(_message).length;\n', '    }\n', '\n', '    function setMessage(int _id, string _message)\n', '             afterInitialization {\n', '        require(lotteries[_id].winner != 0);\n', '        require(lotteries[_id].winner == msg.sender);\n', '        require(getMessageLength(_message) <= 500);\n', '        lotteries[_id].message = _message;\n', '    }\n', '\n', '    function getLotteryDetailsA(int _id)\n', '             constant returns (int _actualId, uint _jackpot,\n', '                               int _decidingBlock,\n', '                               uint _numTickets, uint _numTicketsSold,\n', '                               uint _lastSaleTimestamp, uint _ticketPrice) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _jackpot = lotteries[_actualId].jackpot;\n', '        _decidingBlock = lotteries[_actualId].decidingBlock;\n', '        _numTickets = lotteries[_actualId].numTickets;\n', '        _numTicketsSold = lotteries[_actualId].numTicketsSold;\n', '        _lastSaleTimestamp = lastSaleTimestamp;\n', '        _ticketPrice = lotteries[_actualId].ticketPrice;\n', '    }\n', '\n', '    function getLotteryDetailsB(int _id)\n', '             constant returns (int _actualId,\n', '                               int _winningTicket, address _winner,\n', '                               uint _finalizationBlock, address _finalizer,\n', '                               string _message,\n', '                               int _prevLottery, int _nextLottery,\n', '                               int _blockHeight) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _winningTicket = lotteries[_actualId].winningTicket;\n', '        _winner = lotteries[_actualId].winner;\n', '        _finalizationBlock = lotteries[_actualId].finalizationBlock;\n', '        _finalizer = lotteries[_actualId].finalizer;\n', '        _message = lotteries[_actualId].message;\n', '\n', '        if (_actualId == 0) {\n', '            _prevLottery = -1;\n', '        } else {\n', '            _prevLottery = _actualId - 1;\n', '        }\n', '        if (_actualId == id) {\n', '            _nextLottery = -1;\n', '        } else {\n', '            _nextLottery = _actualId + 1;\n', '        }\n', '\n', '        _blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '    }\n', '\n', '    function getTicketDetails(int _id, uint _offset, uint _n, address _addr)\n', '             constant returns (uint8[] details) {\n', '        require(_offset + _n <= lotteries[_id].numTickets);\n', '\n', '        details = new uint8[](_n);\n', '        for (uint i = 0; i < _n; i++) {\n', '            address addr = lotteries[_id].tickets[_offset + i];\n', '            if (addr == _addr && _addr != 0) {\n', '                details[i] = 2;\n', '            } else if (addr != 0) {\n', '                details[i] = 1;\n', '            } else {\n', '                details[i] = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getTicketOwner(int _id, uint _ticket) constant returns (address) {\n', '        require(_id >= 0);\n', '        return lotteries[_id].tickets[_ticket];\n', '    }\n', '\n', '    function getRecentActivity()\n', '             constant returns (int _id, uint _idx, uint[1000] _recentActivity) {\n', '        _id = id;\n', '        _idx = recentActivityIdx;\n', '        for (uint i = 0; i < recentActivity.length; i++) {\n', '            _recentActivity[i] = recentActivity[i];\n', '        }\n', '    }\n', '\n', '    function setAdmin(address _admin) onlyOwner {\n', '        admin = _admin;\n', '    }\n', '\n', '    function proposeOwner(address _owner) onlyOwner {\n', '        proposedOwner = _owner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        require(proposedOwner != 0);\n', '        require(msg.sender == proposedOwner);\n', '        owner = proposedOwner;\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'contract BTCRelay {\n', '    function getLastBlockHeight() public returns (int);\n', '    function getBlockchainHead() public returns (int);\n', '    function getFeeAmount(int blockHash) public returns (int);\n', '    function getBlockHeader(int blockHash) public returns (bytes32[5]);\n', '    function storeBlockHeader(bytes blockHeader) public returns (int);\n', '}\n', '\n', 'contract Escrow {\n', '    function deposit(address recipient) payable;\n', '}\n', '\n', 'contract EthereumLottery {\n', '    uint constant GAS_LIMIT_DEPOSIT = 300000;\n', '    uint constant GAS_LIMIT_BUY = 450000;\n', '\n', '    struct Lottery {\n', '        uint jackpot;\n', '        int decidingBlock;\n', '        uint numTickets;\n', '        uint numTicketsSold;\n', '        uint ticketPrice;\n', '        int winningTicket;\n', '        address winner;\n', '        uint finalizationBlock;\n', '        address finalizer;\n', '        string message;\n', '        mapping (uint => address) tickets;\n', '        int nearestKnownBlock;\n', '        int nearestKnownBlockHash;\n', '    }\n', '\n', '    address public owner;\n', '    address public admin;\n', '    address public proposedOwner;\n', '\n', '    int public id = -1;\n', '    uint public lastInitTimestamp;\n', '    uint public lastSaleTimestamp;\n', '\n', '    uint public recentActivityIdx;\n', '    uint[1000] public recentActivity;\n', '\n', '    mapping (int => Lottery) public lotteries;\n', '\n', '    address public btcRelay;\n', '    address public escrow;\n', '\n', '    enum Reason { TicketSaleClosed, TicketAlreadySold, InsufficientGas }\n', '    event PurchaseFailed(address indexed buyer, uint mark, Reason reason);\n', '    event PurchaseSuccessful(address indexed buyer, uint mark);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdminOrOwner {\n', '        require(msg.sender == owner || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier afterInitialization {\n', '        require(id >= 0);\n', '        _;\n', '    }\n', '\n', '    function EthereumLottery(address _btcRelay,\n', '                             address _escrow) {\n', '        owner = msg.sender;\n', '        admin = msg.sender;\n', '        btcRelay = _btcRelay;\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function needsInitialization() constant returns (bool) {\n', '        return id == -1 || lotteries[id].finalizationBlock > 0;\n', '    }\n', '\n', '    function initLottery(uint _jackpot, uint _numTickets, uint _ticketPrice)\n', '             onlyAdminOrOwner {\n', '        require(needsInitialization());\n', '        require(_numTickets * _ticketPrice > _jackpot);\n', '\n', '        id += 1;\n', '        lotteries[id].jackpot = _jackpot;\n', '        lotteries[id].decidingBlock = -1;\n', '        lotteries[id].numTickets = _numTickets;\n', '        lotteries[id].ticketPrice = _ticketPrice;\n', '        lotteries[id].winningTicket = -1;\n', '\n', '        lastInitTimestamp = block.timestamp;\n', '        lastSaleTimestamp = 0;\n', '    }\n', '\n', '    function buyTickets(uint[] _tickets, uint _mark, bytes _extraData)\n', '             payable afterInitialization {\n', '        if (msg.gas < GAS_LIMIT_BUY) {\n', '            PurchaseFailed(msg.sender, _mark, Reason.InsufficientGas);\n', '            return;\n', '        }\n', '\n', '        if (lotteries[id].numTicketsSold == lotteries[id].numTickets) {\n', '            PurchaseFailed(msg.sender, _mark, Reason.TicketSaleClosed);\n', '            return;\n', '        }\n', '\n', '        require(_tickets.length > 0);\n', '        require(msg.value == _tickets.length * lotteries[id].ticketPrice);\n', '\n', '        for (uint i = 0; i < _tickets.length; i++) {\n', '            uint ticket = _tickets[i];\n', '            require(ticket >= 0);\n', '            require(ticket < lotteries[id].numTickets);\n', '\n', '            if (lotteries[id].tickets[ticket] != 0) {\n', '                PurchaseFailed(msg.sender, _mark, Reason.TicketAlreadySold);\n', '                return;\n', '            }\n', '        }\n', '\n', '        for (i = 0; i < _tickets.length; i++) {\n', '            ticket = _tickets[i];\n', '            lotteries[id].tickets[ticket] = msg.sender;\n', '            recentActivity[recentActivityIdx] = ticket;\n', '\n', '            recentActivityIdx += 1;\n', '            if (recentActivityIdx >= recentActivity.length) {\n', '                recentActivityIdx = 0;\n', '            }\n', '        }\n', '\n', '        lotteries[id].numTicketsSold += _tickets.length;\n', '        lastSaleTimestamp = block.timestamp;\n', '\n', '        BTCRelay(btcRelay).storeBlockHeader(_extraData);\n', '\n', '        PurchaseSuccessful(msg.sender, _mark);\n', '    }\n', '\n', '    function needsBlockFinalization()\n', '             afterInitialization constant returns (bool) {\n', '        // Check the timestamp of the latest block known to BTCRelay\n', '        // and require it to be no more than 2 hours older than the\n', '        // timestamp of our block. This should ensure that BTCRelay\n', '        // is reasonably up to date.\n', '        uint btcTimestamp;\n', '        int blockHash = BTCRelay(btcRelay).getBlockchainHead();\n', '        (,btcTimestamp) = getBlockHeader(blockHash);\n', '\n', '        uint delta = 0;\n', '        if (btcTimestamp < block.timestamp) {\n', '            delta = block.timestamp - btcTimestamp;\n', '        }\n', '\n', '        return delta < 2 * 60 * 60 &&\n', '               lotteries[id].numTicketsSold == lotteries[id].numTickets &&\n', '               lotteries[id].decidingBlock == -1;\n', '    }\n', '\n', '    function finalizeBlock()\n', '             afterInitialization {\n', '        require(needsBlockFinalization());\n', '\n', '        // At this point we know that the timestamp of the latest block\n', '        // known to BTCRelay is within 2 hours of what the Ethereum network\n', "        // considers 'now'. If we assume this to be correct within +/- 3 hours,\n", "        // we can conclude that 'out there' in the real world at most 5 hours\n", '        // have passed. Assuming an actual block time of 9 minutes for Bitcoin,\n', '        // we can use the Poisson distribution to calculate, that if we wait for\n', '        // 54 more blocks, then the probability for all of these 54 blocks\n', '        // having already been mined in 5 hours is less than 0.1 %.\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        lotteries[id].decidingBlock = blockHeight + 54;\n', '    }\n', '\n', '    function needsLotteryFinalization()\n', '             afterInitialization constant returns (bool) {\n', '        int blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '        return lotteries[id].decidingBlock != -1 &&\n', '               blockHeight >= lotteries[id].decidingBlock + 6 &&\n', '               lotteries[id].finalizationBlock == 0;\n', '    }\n', '\n', '    function finalizeLottery(uint _steps)\n', '             afterInitialization {\n', '        require(needsLotteryFinalization());\n', '\n', '        if (lotteries[id].nearestKnownBlock != lotteries[id].decidingBlock) {\n', '            walkTowardsBlock(_steps);\n', '        } else {\n', '            int winningTicket = lotteries[id].nearestKnownBlockHash %\n', '                                int(lotteries[id].numTickets);\n', '            address winner = lotteries[id].tickets[uint(winningTicket)];\n', '\n', '            lotteries[id].winningTicket = winningTicket;\n', '            lotteries[id].winner = winner;\n', '            lotteries[id].finalizationBlock = block.number;\n', '            lotteries[id].finalizer = tx.origin;\n', '\n', '            if (winner != 0) {\n', '                uint value = lotteries[id].jackpot;\n', '                bool successful =\n', '                    winner.call.gas(GAS_LIMIT_DEPOSIT).value(value)();\n', '                if (!successful) {\n', '                    Escrow(escrow).deposit.value(value)(winner);\n', '                }\n', '            }\n', '\n', '            var _ = admin.call.gas(GAS_LIMIT_DEPOSIT).value(this.balance)();\n', '        }\n', '    }\n', '\n', '    function walkTowardsBlock(uint _steps) internal {\n', '        int blockHeight;\n', '        int blockHash;\n', '        if (lotteries[id].nearestKnownBlock == 0) {\n', '            blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '            blockHash = BTCRelay(btcRelay).getBlockchainHead();\n', '        } else {\n', '            blockHeight = lotteries[id].nearestKnownBlock;\n', '            blockHash = lotteries[id].nearestKnownBlockHash;\n', '        }\n', '\n', '        // Walk only a few steps to keep an upper limit on gas costs.\n', '        for (uint step = 0; step < _steps; step++) {\n', '            blockHeight -= 1;\n', '            (blockHash,) = getBlockHeader(blockHash);\n', '\n', '            if (blockHeight == lotteries[id].decidingBlock) { break; }\n', '        }\n', '\n', '        // Store the progress to pick up from there next time.\n', '        lotteries[id].nearestKnownBlock = blockHeight;\n', '        lotteries[id].nearestKnownBlockHash = blockHash;\n', '    }\n', '\n', '    function getBlockHeader(int blockHash)\n', '             internal returns (int prevBlockHash, uint timestamp) {\n', '        // We expect free access to BTCRelay.\n', '        int fee = BTCRelay(btcRelay).getFeeAmount(blockHash);\n', '        require(fee == 0);\n', '\n', "        // Code is based on tjade273's BTCRelayTools.\n", '        bytes32[5] memory blockHeader =\n', '            BTCRelay(btcRelay).getBlockHeader(blockHash);\n', '\n', '        prevBlockHash = 0;\n', '        for (uint i = 0; i < 32; i++) {\n', '            uint pos = 68 + i;  // prev. block hash starts at position 68\n', '            byte data = blockHeader[pos / 32][pos % 32];\n', '            prevBlockHash = prevBlockHash | int(data) * int(0x100 ** i);\n', '        }\n', '\n', '        timestamp = 0;\n', '        for (i = 0; i < 4; i++) {\n', '            pos = 132 + i;  // timestamp starts at position 132\n', '            data = blockHeader[pos / 32][pos % 32];\n', '            timestamp = timestamp | uint(data) * uint(0x100 ** i);\n', '        }\n', '\n', '        return (prevBlockHash, timestamp);\n', '    }\n', '\n', '    function getMessageLength(string _message) constant returns (uint) {\n', '        return bytes(_message).length;\n', '    }\n', '\n', '    function setMessage(int _id, string _message)\n', '             afterInitialization {\n', '        require(lotteries[_id].winner != 0);\n', '        require(lotteries[_id].winner == msg.sender);\n', '        require(getMessageLength(_message) <= 500);\n', '        lotteries[_id].message = _message;\n', '    }\n', '\n', '    function getLotteryDetailsA(int _id)\n', '             constant returns (int _actualId, uint _jackpot,\n', '                               int _decidingBlock,\n', '                               uint _numTickets, uint _numTicketsSold,\n', '                               uint _lastSaleTimestamp, uint _ticketPrice) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _jackpot = lotteries[_actualId].jackpot;\n', '        _decidingBlock = lotteries[_actualId].decidingBlock;\n', '        _numTickets = lotteries[_actualId].numTickets;\n', '        _numTicketsSold = lotteries[_actualId].numTicketsSold;\n', '        _lastSaleTimestamp = lastSaleTimestamp;\n', '        _ticketPrice = lotteries[_actualId].ticketPrice;\n', '    }\n', '\n', '    function getLotteryDetailsB(int _id)\n', '             constant returns (int _actualId,\n', '                               int _winningTicket, address _winner,\n', '                               uint _finalizationBlock, address _finalizer,\n', '                               string _message,\n', '                               int _prevLottery, int _nextLottery,\n', '                               int _blockHeight) {\n', '        if (_id == -1) {\n', '            _actualId = id;\n', '        } else {\n', '            _actualId = _id;\n', '        }\n', '        _winningTicket = lotteries[_actualId].winningTicket;\n', '        _winner = lotteries[_actualId].winner;\n', '        _finalizationBlock = lotteries[_actualId].finalizationBlock;\n', '        _finalizer = lotteries[_actualId].finalizer;\n', '        _message = lotteries[_actualId].message;\n', '\n', '        if (_actualId == 0) {\n', '            _prevLottery = -1;\n', '        } else {\n', '            _prevLottery = _actualId - 1;\n', '        }\n', '        if (_actualId == id) {\n', '            _nextLottery = -1;\n', '        } else {\n', '            _nextLottery = _actualId + 1;\n', '        }\n', '\n', '        _blockHeight = BTCRelay(btcRelay).getLastBlockHeight();\n', '    }\n', '\n', '    function getTicketDetails(int _id, uint _offset, uint _n, address _addr)\n', '             constant returns (uint8[] details) {\n', '        require(_offset + _n <= lotteries[_id].numTickets);\n', '\n', '        details = new uint8[](_n);\n', '        for (uint i = 0; i < _n; i++) {\n', '            address addr = lotteries[_id].tickets[_offset + i];\n', '            if (addr == _addr && _addr != 0) {\n', '                details[i] = 2;\n', '            } else if (addr != 0) {\n', '                details[i] = 1;\n', '            } else {\n', '                details[i] = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getTicketOwner(int _id, uint _ticket) constant returns (address) {\n', '        require(_id >= 0);\n', '        return lotteries[_id].tickets[_ticket];\n', '    }\n', '\n', '    function getRecentActivity()\n', '             constant returns (int _id, uint _idx, uint[1000] _recentActivity) {\n', '        _id = id;\n', '        _idx = recentActivityIdx;\n', '        for (uint i = 0; i < recentActivity.length; i++) {\n', '            _recentActivity[i] = recentActivity[i];\n', '        }\n', '    }\n', '\n', '    function setAdmin(address _admin) onlyOwner {\n', '        admin = _admin;\n', '    }\n', '\n', '    function proposeOwner(address _owner) onlyOwner {\n', '        proposedOwner = _owner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        require(proposedOwner != 0);\n', '        require(msg.sender == proposedOwner);\n', '        owner = proposedOwner;\n', '    }\n', '}']
