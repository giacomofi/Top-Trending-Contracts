['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Constant {\n', '    function balanceOf( address who ) constant returns (uint value);\n', '}\n', 'contract ERC20Stateful {\n', '    function transfer( address to, uint value) returns (bool ok);\n', '}\n', 'contract ERC20Events {\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', 'contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract WhitelistSale is Owned {\n', '\n', '    ERC20 public manaToken;\n', '\n', '    // Amount of MANA received per ETH\n', '    uint256 public manaPerEth;\n', '\n', '    // Sales start at this timestamp\n', '    uint256 public initialTimestamp;\n', '\n', '    // The sale goes on through 6 days.\n', '    // Each day, users are allowed to buy up to a certain (cummulative) limit of MANA.\n', '\n', '    // This mapping stores the addresses for whitelisted users\n', '    mapping(address => bool) public whitelisted;\n', '\n', '    // Used to calculate the current limit\n', '    mapping(address => uint256) public bought;\n', '\n', '    // The initial values allowed per day are copied from this array\n', '    uint256[6] public limitPerDay;\n', '\n', '    // Forwarding address\n', '    address public receiver;\n', '\n', '    event LogWithdrawal(uint256 _value);\n', '    event LogBought(uint orderInMana);\n', '    event LogUserAdded(address user);\n', '    event LogUserRemoved(address user);\n', '\n', '    function WhitelistSale (\n', '        ERC20 _manaToken,\n', '        uint256 _initialTimestamp,\n', '        address _receiver\n', '    )\n', '        Owned()\n', '    {\n', '        manaToken        = _manaToken;\n', '        initialTimestamp = _initialTimestamp;\n', '        receiver         = _receiver;\n', '\n', '        manaPerEth       = 11954;\n', '        limitPerDay[0]   = 3.3 ether;\n', '        limitPerDay[1]   = 10 ether   + limitPerDay[0];\n', '        limitPerDay[2]   = 30 ether   + limitPerDay[1];\n', '        limitPerDay[3]   = 90 ether   + limitPerDay[2];\n', '        limitPerDay[4]   = 450 ether  + limitPerDay[3];\n', '        limitPerDay[5]   = 1500 ether + limitPerDay[4];\n', '    }\n', '\n', '    // Withdraw Mana (only owner)\n', '    function withdrawMana(uint256 _value) onlyOwner returns (bool ok) {\n', '        return withdrawToken(manaToken, _value);\n', '    }\n', '\n', '    // Withdraw any ERC20 token (just in case)\n', '    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok) {\n', '        return ERC20(_token).transfer(owner,_value);\n', '        LogWithdrawal(_value);\n', '    }\n', '\n', '    // Change address where funds are received\n', '    function changeReceiver(address _receiver) onlyOwner {\n', '        require(_receiver != 0);\n', '        receiver = _receiver;\n', '    }\n', '\n', '    // Calculate which day into the sale are we.\n', '    function getDay() constant returns (uint256) {\n', '        return SafeMath.sub(block.timestamp, initialTimestamp) / 1 days;\n', '    }\n', '\n', '    modifier onlyIfActive {\n', '        require(getDay() >= 0);\n', '        require(getDay() < 6);\n', '        _;\n', '    }\n', '\n', '    function buy(address beneficiary) payable onlyIfActive {\n', '        require(beneficiary != 0);\n', '        require(whitelisted[msg.sender]);\n', '\n', '        uint day = getDay();\n', '        uint256 allowedForSender = limitPerDay[day] - bought[msg.sender];\n', '\n', '        if (msg.value > allowedForSender) revert();\n', '\n', '        uint256 balanceInMana = manaToken.balanceOf(address(this));\n', '\n', '        uint orderInMana = msg.value * manaPerEth;\n', '        if (orderInMana > balanceInMana) revert();\n', '\n', '        bought[msg.sender] = SafeMath.add(bought[msg.sender], msg.value);\n', '        manaToken.transfer(beneficiary, orderInMana);\n', '        receiver.transfer(msg.value);\n', '\n', '        LogBought(orderInMana);\n', '    }\n', '\n', '    // Add a user to the whitelist\n', '    function addUser(address user) onlyOwner {\n', '        whitelisted[user] = true;\n', '        LogUserAdded(user);\n', '    }\n', '\n', '    // Remove an user from the whitelist\n', '    function removeUser(address user) onlyOwner {\n', '        whitelisted[user] = false;\n', '        LogUserRemoved(user);\n', '    }\n', '\n', '    // Batch add users\n', '    function addManyUsers(address[] users) onlyOwner {\n', '        require(users.length < 10000);\n', '        for (uint index = 0; index < users.length; index++) {\n', '             whitelisted[users[index]] = true;\n', '             LogUserAdded(users[index]);\n', '        }\n', '    }\n', '\n', '    function() payable {\n', '        buy(msg.sender);\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Constant {\n', '    function balanceOf( address who ) constant returns (uint value);\n', '}\n', 'contract ERC20Stateful {\n', '    function transfer( address to, uint value) returns (bool ok);\n', '}\n', 'contract ERC20Events {\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', 'contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract WhitelistSale is Owned {\n', '\n', '    ERC20 public manaToken;\n', '\n', '    // Amount of MANA received per ETH\n', '    uint256 public manaPerEth;\n', '\n', '    // Sales start at this timestamp\n', '    uint256 public initialTimestamp;\n', '\n', '    // The sale goes on through 6 days.\n', '    // Each day, users are allowed to buy up to a certain (cummulative) limit of MANA.\n', '\n', '    // This mapping stores the addresses for whitelisted users\n', '    mapping(address => bool) public whitelisted;\n', '\n', '    // Used to calculate the current limit\n', '    mapping(address => uint256) public bought;\n', '\n', '    // The initial values allowed per day are copied from this array\n', '    uint256[6] public limitPerDay;\n', '\n', '    // Forwarding address\n', '    address public receiver;\n', '\n', '    event LogWithdrawal(uint256 _value);\n', '    event LogBought(uint orderInMana);\n', '    event LogUserAdded(address user);\n', '    event LogUserRemoved(address user);\n', '\n', '    function WhitelistSale (\n', '        ERC20 _manaToken,\n', '        uint256 _initialTimestamp,\n', '        address _receiver\n', '    )\n', '        Owned()\n', '    {\n', '        manaToken        = _manaToken;\n', '        initialTimestamp = _initialTimestamp;\n', '        receiver         = _receiver;\n', '\n', '        manaPerEth       = 11954;\n', '        limitPerDay[0]   = 3.3 ether;\n', '        limitPerDay[1]   = 10 ether   + limitPerDay[0];\n', '        limitPerDay[2]   = 30 ether   + limitPerDay[1];\n', '        limitPerDay[3]   = 90 ether   + limitPerDay[2];\n', '        limitPerDay[4]   = 450 ether  + limitPerDay[3];\n', '        limitPerDay[5]   = 1500 ether + limitPerDay[4];\n', '    }\n', '\n', '    // Withdraw Mana (only owner)\n', '    function withdrawMana(uint256 _value) onlyOwner returns (bool ok) {\n', '        return withdrawToken(manaToken, _value);\n', '    }\n', '\n', '    // Withdraw any ERC20 token (just in case)\n', '    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok) {\n', '        return ERC20(_token).transfer(owner,_value);\n', '        LogWithdrawal(_value);\n', '    }\n', '\n', '    // Change address where funds are received\n', '    function changeReceiver(address _receiver) onlyOwner {\n', '        require(_receiver != 0);\n', '        receiver = _receiver;\n', '    }\n', '\n', '    // Calculate which day into the sale are we.\n', '    function getDay() constant returns (uint256) {\n', '        return SafeMath.sub(block.timestamp, initialTimestamp) / 1 days;\n', '    }\n', '\n', '    modifier onlyIfActive {\n', '        require(getDay() >= 0);\n', '        require(getDay() < 6);\n', '        _;\n', '    }\n', '\n', '    function buy(address beneficiary) payable onlyIfActive {\n', '        require(beneficiary != 0);\n', '        require(whitelisted[msg.sender]);\n', '\n', '        uint day = getDay();\n', '        uint256 allowedForSender = limitPerDay[day] - bought[msg.sender];\n', '\n', '        if (msg.value > allowedForSender) revert();\n', '\n', '        uint256 balanceInMana = manaToken.balanceOf(address(this));\n', '\n', '        uint orderInMana = msg.value * manaPerEth;\n', '        if (orderInMana > balanceInMana) revert();\n', '\n', '        bought[msg.sender] = SafeMath.add(bought[msg.sender], msg.value);\n', '        manaToken.transfer(beneficiary, orderInMana);\n', '        receiver.transfer(msg.value);\n', '\n', '        LogBought(orderInMana);\n', '    }\n', '\n', '    // Add a user to the whitelist\n', '    function addUser(address user) onlyOwner {\n', '        whitelisted[user] = true;\n', '        LogUserAdded(user);\n', '    }\n', '\n', '    // Remove an user from the whitelist\n', '    function removeUser(address user) onlyOwner {\n', '        whitelisted[user] = false;\n', '        LogUserRemoved(user);\n', '    }\n', '\n', '    // Batch add users\n', '    function addManyUsers(address[] users) onlyOwner {\n', '        require(users.length < 10000);\n', '        for (uint index = 0; index < users.length; index++) {\n', '             whitelisted[users[index]] = true;\n', '             LogUserAdded(users[index]);\n', '        }\n', '    }\n', '\n', '    function() payable {\n', '        buy(msg.sender);\n', '    }\n', '}']
