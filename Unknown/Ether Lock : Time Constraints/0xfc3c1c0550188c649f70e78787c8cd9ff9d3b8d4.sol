['pragma solidity ^0.4.11;\n', '\n', '/**\n', '                +----+\n', '               /    /|\n', '   by cubic   +----+ |\n', '   2017       |    | +\n', '              |    |/\n', '              +----+\n', '*/\n', '\n', 'contract Cubic {\n', '\n', '    uint public creationTime = now;\n', '    address public owner = msg.sender;\n', '    uint256 public totalEthHandled = 0; \n', '    uint public rate = 0; \n', '    Cube[] public Cubes;\n', '\n', '    /*\n', '    Events\n', '    */\n', '\n', '    event Freeze(address indexed from, address indexed cubeAddress, uint amount, uint unlockedAfter, string api);\n', '    event Deliver(address indexed cube, address indexed destination, uint amount);\n', '\n', '    /*\n', '    Public/External functions\n', '    */\n', '\n', '    function() payable { }\n', '\n', '    function getCubeCount() external constant returns(uint) {\n', '        return Cubes.length;\n', '    }\n', '\n', '    function freeze(uint blocks) external payable {\n', '        secure(blocks, &#39;cubic&#39;);\n', '    }\n', '\n', '    function freezeAPI(uint blocks, string api) external payable {\n', '        secure(blocks, api);\n', '    }\n', '\n', '    function forgetCube(Cube iceCube) external {\n', '\n', '        uint id = iceCube.id();\n', '        require(msg.sender == address(Cubes[id]));\n', '\n', '        if (id != Cubes.length - 1) {\n', '            Cubes[id] = Cubes[Cubes.length - 1];\n', '            Cubes[id].setId(id);\n', '        }\n', '        Cubes.length--;        \n', '\n', '        Deliver(address(iceCube), iceCube.destination(), iceCube.balance);\n', '    }\n', '\n', '    /*\n', '    Only Owner\n', '    */\n', '\n', '    function withdraw() external {\n', '        require(msg.sender == owner);        \n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external {\n', '        require(msg.sender == owner);        \n', '        owner = newOwner;\n', '    }\n', '\n', '    /*\n', '    Private\n', '    */\n', '\n', '\tfunction secure(uint blocks, string api) private {\n', '\n', '        require(msg.value > 0);\n', '        uint amountToFreeze = msg.value; \n', '        totalEthHandled = add(totalEthHandled, amountToFreeze);\n', '          \n', '        /* \n', '         The rate starts at zero, over time as this \n', '         contract is trusted the higher the fee \n', '         becomes with an upward limit of half of one\n', '         percent (.50%). The owner of the contract CAN NOT \n', '         adjust this. \n', '        */\n', '        if (rate != 200 ) {\n', '\n', '            if (totalEthHandled > 5000 ether) {\n', '                setRate(200);  //.50 of one percent\n', '            } else if (totalEthHandled > 1000 ether) { \n', '                setRate(500);  //.20 of one percent\n', '            } else if (totalEthHandled > 100 ether) { \n', '                setRate(1000); //.10 of one percent\n', '            }\n', '        }\n', '\n', '        if (rate > 0) {\n', '            uint fee = div(amountToFreeze, rate);\n', '            amountToFreeze = sub(amountToFreeze, fee);\n', '        }\n', '\n', '        Cube newCube = (new Cube).value(amountToFreeze)(msg.sender, add(block.number, blocks), this);\n', '        newCube.setId(Cubes.push(newCube) - 1);\n', '        Freeze(msg.sender, address(newCube), amountToFreeze, add(block.number, blocks), api);\n', '\t}\n', '\n', '    function setRate(uint _newRate) private {\n', '        rate = _newRate; \n', '    }\n', '\n', '    function add(uint a, uint b) private returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) private returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) private returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '}\n', '\n', 'contract Cube {\n', '\n', '    address public destination;\n', '    Cubic public cubicContract;    \n', '    uint public unlockedAfter;\n', '    uint public id;\n', '    \n', '\tfunction Cube(address _destination, uint _unlockedAfter, Cubic _cubicContract) payable {\n', '\t\tdestination = _destination;\n', '\t\tunlockedAfter = _unlockedAfter;\n', '        cubicContract = _cubicContract;       \n', '\t}\n', '\n', '    function() payable {\n', '        require(msg.value == 0);\n', '    }\n', '\n', '    function setId(uint _id) external {\n', '        require(msg.sender == address(cubicContract));\n', '        id = _id; \n', '    }\n', '\n', '    function deliver() external {\n', '        assert(block.number > unlockedAfter); \n', '        cubicContract.forgetCube(this);\n', '\t\tselfdestruct(destination);\t\t\n', '\t}\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', '                +----+\n', '               /    /|\n', '   by cubic   +----+ |\n', '   2017       |    | +\n', '              |    |/\n', '              +----+\n', '*/\n', '\n', 'contract Cubic {\n', '\n', '    uint public creationTime = now;\n', '    address public owner = msg.sender;\n', '    uint256 public totalEthHandled = 0; \n', '    uint public rate = 0; \n', '    Cube[] public Cubes;\n', '\n', '    /*\n', '    Events\n', '    */\n', '\n', '    event Freeze(address indexed from, address indexed cubeAddress, uint amount, uint unlockedAfter, string api);\n', '    event Deliver(address indexed cube, address indexed destination, uint amount);\n', '\n', '    /*\n', '    Public/External functions\n', '    */\n', '\n', '    function() payable { }\n', '\n', '    function getCubeCount() external constant returns(uint) {\n', '        return Cubes.length;\n', '    }\n', '\n', '    function freeze(uint blocks) external payable {\n', "        secure(blocks, 'cubic');\n", '    }\n', '\n', '    function freezeAPI(uint blocks, string api) external payable {\n', '        secure(blocks, api);\n', '    }\n', '\n', '    function forgetCube(Cube iceCube) external {\n', '\n', '        uint id = iceCube.id();\n', '        require(msg.sender == address(Cubes[id]));\n', '\n', '        if (id != Cubes.length - 1) {\n', '            Cubes[id] = Cubes[Cubes.length - 1];\n', '            Cubes[id].setId(id);\n', '        }\n', '        Cubes.length--;        \n', '\n', '        Deliver(address(iceCube), iceCube.destination(), iceCube.balance);\n', '    }\n', '\n', '    /*\n', '    Only Owner\n', '    */\n', '\n', '    function withdraw() external {\n', '        require(msg.sender == owner);        \n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external {\n', '        require(msg.sender == owner);        \n', '        owner = newOwner;\n', '    }\n', '\n', '    /*\n', '    Private\n', '    */\n', '\n', '\tfunction secure(uint blocks, string api) private {\n', '\n', '        require(msg.value > 0);\n', '        uint amountToFreeze = msg.value; \n', '        totalEthHandled = add(totalEthHandled, amountToFreeze);\n', '          \n', '        /* \n', '         The rate starts at zero, over time as this \n', '         contract is trusted the higher the fee \n', '         becomes with an upward limit of half of one\n', '         percent (.50%). The owner of the contract CAN NOT \n', '         adjust this. \n', '        */\n', '        if (rate != 200 ) {\n', '\n', '            if (totalEthHandled > 5000 ether) {\n', '                setRate(200);  //.50 of one percent\n', '            } else if (totalEthHandled > 1000 ether) { \n', '                setRate(500);  //.20 of one percent\n', '            } else if (totalEthHandled > 100 ether) { \n', '                setRate(1000); //.10 of one percent\n', '            }\n', '        }\n', '\n', '        if (rate > 0) {\n', '            uint fee = div(amountToFreeze, rate);\n', '            amountToFreeze = sub(amountToFreeze, fee);\n', '        }\n', '\n', '        Cube newCube = (new Cube).value(amountToFreeze)(msg.sender, add(block.number, blocks), this);\n', '        newCube.setId(Cubes.push(newCube) - 1);\n', '        Freeze(msg.sender, address(newCube), amountToFreeze, add(block.number, blocks), api);\n', '\t}\n', '\n', '    function setRate(uint _newRate) private {\n', '        rate = _newRate; \n', '    }\n', '\n', '    function add(uint a, uint b) private returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) private returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) private returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '}\n', '\n', 'contract Cube {\n', '\n', '    address public destination;\n', '    Cubic public cubicContract;    \n', '    uint public unlockedAfter;\n', '    uint public id;\n', '    \n', '\tfunction Cube(address _destination, uint _unlockedAfter, Cubic _cubicContract) payable {\n', '\t\tdestination = _destination;\n', '\t\tunlockedAfter = _unlockedAfter;\n', '        cubicContract = _cubicContract;       \n', '\t}\n', '\n', '    function() payable {\n', '        require(msg.value == 0);\n', '    }\n', '\n', '    function setId(uint _id) external {\n', '        require(msg.sender == address(cubicContract));\n', '        id = _id; \n', '    }\n', '\n', '    function deliver() external {\n', '        assert(block.number > unlockedAfter); \n', '        cubicContract.forgetCube(this);\n', '\t\tselfdestruct(destination);\t\t\n', '\t}\n', '}']
