['/**\n', ' * The D-WALLET token contract complies with the ERC20 standard (see https://github.com/ethereum/EIPs/issues/20).\n', ' * Additionally tokens can be locked for a defined time interval by token holders.\n', ' * Except  1,024,000,000 tokens (D-WALLET Frozen Vault + Bounty) all unsold tokens will be burned.\n', ' * Author: D-WALLET TEAM\n', ' * */\n', '\n', 'pragma solidity ^0.4.6;\n', '\n', 'contract SafeMath {\n', '  //internals\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract DWalletToken is SafeMath {\n', '\n', '    /* Public variables of the token */\n', '    string public standard = &#39;ERC20&#39;;\n', '    string public name = &#39;D-WALLET TOKEN&#39;;\n', '    string public symbol = &#39;DWT&#39;;\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply;\n', '    address public owner;\n', '    /* ICO Start time 26 August, 2017 13:00:00 GMT*/\n', '    uint256 public startTime = 1503752400;\n', '\t/* ICO Start time 25 October, 2017 17:00:00 GMT*/\n', '\tuint256 public endTime = 1508950800;\n', '    /* tells if tokens have been burned already */\n', '    bool burned;\n', '\n', '    /* Create an array with all balances so that blockchain will know */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\n', '    /* Generate a public event on the blockchain to notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\tevent Burned(uint amount);\n', '\t  // fallback function\n', '    function () payable {\n', '     owner.transfer(msg.value);\n', '   }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function DWalletToken() {\n', '        owner = 0x1C46b45a7d6d28E27A755448e68c03248aefd18b;\n', '        balanceOf[owner] = 10000000000;              // Give the owner all initial tokens\n', '        totalSupply = 10000000000;                   // Update initial total supply\n', '    }\n', '\n', '    /* function to send tokens to a given address */\n', '    function transfer(address _to, uint256 _value) returns (bool success){\n', '        require (now < startTime); //check if the crowdsale is already over\n', '        require(msg.sender == owner && now < startTime + 1 years && safeSub(balanceOf[msg.sender],_value) < 1000000000); //prevent the owner of spending his share of tokens within the first year \n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);                     // Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    /* Function to allow spender to spend token on owners behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* Transferfrom function*/\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require (now < startTime && _from!=owner); //check if the crowdsale is already over \n', '        require(_from == owner && now < startTime + 1 years && safeSub(balanceOf[_from],_value) < 1000000000);\n', '        var _allowance = allowance[_from][msg.sender];\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value); // Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     // Add the same to the recipient\n', '        allowance[_from][msg.sender] = safeSub(_allowance,_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* To be called when ICO is closed, burns the remaining tokens but the D-WALLET FREEZE VAULT (1000000000) and the ones reserved\n', '    *  for the bounty program (24000000).\n', '    *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\n', '    *  this ensures that the owner will not posses a majority of the tokens. */\n', '    function burn(){\n', '    \t//if tokens have not been burned already and the ICO ended\n', '    \tif(!burned && now>endTime){\n', '    \t\tuint difference = safeSub(balanceOf[owner], 1024000000);//checked for overflow above\n', '    \t\tbalanceOf[owner] = 1024000000;\n', '    \t\ttotalSupply = safeSub(totalSupply, difference);\n', '    \t\tburned = true;\n', '    \t\tBurned(difference);\n', '    \t}\n', '    }\n', '\n', '}']
['/**\n', ' * The D-WALLET token contract complies with the ERC20 standard (see https://github.com/ethereum/EIPs/issues/20).\n', ' * Additionally tokens can be locked for a defined time interval by token holders.\n', ' * Except  1,024,000,000 tokens (D-WALLET Frozen Vault + Bounty) all unsold tokens will be burned.\n', ' * Author: D-WALLET TEAM\n', ' * */\n', '\n', 'pragma solidity ^0.4.6;\n', '\n', 'contract SafeMath {\n', '  //internals\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract DWalletToken is SafeMath {\n', '\n', '    /* Public variables of the token */\n', "    string public standard = 'ERC20';\n", "    string public name = 'D-WALLET TOKEN';\n", "    string public symbol = 'DWT';\n", '    uint8 public decimals = 0;\n', '    uint256 public totalSupply;\n', '    address public owner;\n', '    /* ICO Start time 26 August, 2017 13:00:00 GMT*/\n', '    uint256 public startTime = 1503752400;\n', '\t/* ICO Start time 25 October, 2017 17:00:00 GMT*/\n', '\tuint256 public endTime = 1508950800;\n', '    /* tells if tokens have been burned already */\n', '    bool burned;\n', '\n', '    /* Create an array with all balances so that blockchain will know */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '\n', '    /* Generate a public event on the blockchain to notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\tevent Burned(uint amount);\n', '\t  // fallback function\n', '    function () payable {\n', '     owner.transfer(msg.value);\n', '   }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function DWalletToken() {\n', '        owner = 0x1C46b45a7d6d28E27A755448e68c03248aefd18b;\n', '        balanceOf[owner] = 10000000000;              // Give the owner all initial tokens\n', '        totalSupply = 10000000000;                   // Update initial total supply\n', '    }\n', '\n', '    /* function to send tokens to a given address */\n', '    function transfer(address _to, uint256 _value) returns (bool success){\n', '        require (now < startTime); //check if the crowdsale is already over\n', '        require(msg.sender == owner && now < startTime + 1 years && safeSub(balanceOf[msg.sender],_value) < 1000000000); //prevent the owner of spending his share of tokens within the first year \n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);                     // Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    /* Function to allow spender to spend token on owners behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* Transferfrom function*/\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require (now < startTime && _from!=owner); //check if the crowdsale is already over \n', '        require(_from == owner && now < startTime + 1 years && safeSub(balanceOf[_from],_value) < 1000000000);\n', '        var _allowance = allowance[_from][msg.sender];\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value); // Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     // Add the same to the recipient\n', '        allowance[_from][msg.sender] = safeSub(_allowance,_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* To be called when ICO is closed, burns the remaining tokens but the D-WALLET FREEZE VAULT (1000000000) and the ones reserved\n', '    *  for the bounty program (24000000).\n', '    *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\n', '    *  this ensures that the owner will not posses a majority of the tokens. */\n', '    function burn(){\n', '    \t//if tokens have not been burned already and the ICO ended\n', '    \tif(!burned && now>endTime){\n', '    \t\tuint difference = safeSub(balanceOf[owner], 1024000000);//checked for overflow above\n', '    \t\tbalanceOf[owner] = 1024000000;\n', '    \t\ttotalSupply = safeSub(totalSupply, difference);\n', '    \t\tburned = true;\n', '    \t\tBurned(difference);\n', '    \t}\n', '    }\n', '\n', '}']
