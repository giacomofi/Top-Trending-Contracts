['pragma solidity ^0.4.2;\n', '\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\n', '\tfunction owned() {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) onlyOwner {\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', 'contract tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);}\n', '\n', '\n', 'contract Utils {\n', '\t/**\n', '\t\tconstructor\n', '\t*/\n', '\tfunction Utils() {\n', '\t}\n', '\n', '\t// validates an address - currently only checks that it isn&#39;t null\n', '\tmodifier validAddress(address _address) {\n', '\t\trequire(_address != 0x0);\n', '\t\t_;\n', '\t}\n', '\n', '\t// verifies that the address is different than this contract address\n', '\tmodifier notThis(address _address) {\n', '\t\trequire(_address != address(this));\n', '\t\t_;\n', '\t}\n', '\n', '\t// Overflow protected math functions\n', '\n', '\t/**\n', '\t\t@dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '\t\t@param _x   value 1\n', '\t\t@param _y   value 2\n', '\n', '\t\t@return sum\n', '\t*/\n', '\tfunction safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '\t\tuint256 z = _x + _y;\n', '\t\tassert(z >= _x);\n', '\t\treturn z;\n', '\t}\n', '\n', '\t/**\n', '\t\t@dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '\t\t@param _x   minuend\n', '\t\t@param _y   subtrahend\n', '\n', '\t\t@return difference\n', '\t*/\n', '\tfunction safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '\t\tassert(_x >= _y);\n', '\t\treturn _x - _y;\n', '\t}\n', '}\n', '\n', '\n', 'contract CSToken is owned, Utils {\n', '\tstruct Dividend {uint256 time; uint256 tenThousandth; uint256 countComplete;}\n', '\n', '\t/* Public variables of the token */\n', '\tstring public standard = &#39;Token 0.1&#39;;\n', '\n', '\tstring public name = &#39;KickCoin&#39;;\n', '\n', '\tstring public symbol = &#39;KC&#39;;\n', '\n', '\tuint8 public decimals = 8;\n', '\n', '\tuint256 _totalSupply = 0;\n', '\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) balances;\n', '\n', '\tmapping (address => mapping (uint256 => uint256)) public agingBalanceOf;\n', '\n', '\tuint[] agingTimes;\n', '\n', '\tDividend[] dividends;\n', '\n', '\tmapping (address => mapping (address => uint256)) allowed;\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\tevent AgingTransfer(address indexed from, address indexed to, uint256 value, uint256 agingTime);\n', '\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\t// triggered when the total supply is increased\n', '\tevent Issuance(uint256 _amount);\n', '\t// triggered when the total supply is decreased\n', '\tevent Destruction(uint256 _amount);\n', '\n', '\taddress[] public addressByIndex;\n', '\n', '\tmapping (address => bool) addressAddedToIndex;\n', '\n', '\tmapping (address => uint) agingTimesForPools;\n', '\n', '\tuint16 currentDividendIndex = 1;\n', '\n', '\tmapping (address => uint) calculatedDividendsIndex;\n', '\n', '\tbool public transfersEnabled = true;\n', '\n', '\tevent NewSmartToken(address _token);\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction CSToken() {\n', '\t\towner = msg.sender;\n', '\t\t// So that the index starts with 1\n', '\t\tdividends.push(Dividend(0, 0, 0));\n', '\t\t// 31.10.2017 09:00:00\n', '\t\tdividends.push(Dividend(1509440400, 30, 0));\n', '\t\t// 30.11.2017 09:00:00\n', '\t\tdividends.push(Dividend(1512032400, 20, 0));\n', '\t\t// 31.12.2017 09:00:00\n', '\t\tdividends.push(Dividend(1514710800, 10, 0));\n', '\t\t// 31.01.2018 09:00:00\n', '\t\tdividends.push(Dividend(1517389200, 5, 0));\n', '\t\t// 28.02.2018 09:00:00\n', '\t\tdividends.push(Dividend(1519808400, 10, 0));\n', '\t\t// 31.03.2018 09:00:00\n', '\t\tdividends.push(Dividend(1522486800, 20, 0));\n', '\t\t// 30.04.2018 09:00:00\n', '\t\tdividends.push(Dividend(1525078800, 30, 0));\n', '\t\t// 31.05.2018 09:00:00\n', '\t\tdividends.push(Dividend(1527757200, 50, 0));\n', '\t\t// 30.06.2018 09:00:00\n', '\t\tdividends.push(Dividend(1530349200, 30, 0));\n', '\t\t// 31.07.2018 09:00:00\n', '\t\tdividends.push(Dividend(1533027600, 20, 0));\n', '\t\t// 31.08.2018 09:00:00\n', '\t\tdividends.push(Dividend(1535706000, 10, 0));\n', '\t\t// 30.09.2018 09:00:00\n', '\t\tdividends.push(Dividend(1538298000, 5, 0));\n', '\t\t// 31.10.2018 09:00:00\n', '\t\tdividends.push(Dividend(1540976400, 10, 0));\n', '\t\t// 30.11.2018 09:00:00\n', '\t\tdividends.push(Dividend(1543568400, 20, 0));\n', '\t\t// 31.12.2018 09:00:00\n', '\t\tdividends.push(Dividend(1546246800, 30, 0));\n', '\t\t// 31.01.2019 09:00:00\n', '\t\tdividends.push(Dividend(1548925200, 60, 0));\n', '\t\t// 28.02.2019 09:00:00\n', '\t\tdividends.push(Dividend(1551344400, 30, 0));\n', '\t\t// 31.03.2019 09:00:00\n', '\t\tdividends.push(Dividend(1554022800, 20, 0));\n', '\t\t// 30.04.2019 09:00:00\n', '\t\tdividends.push(Dividend(1556614800, 10, 0));\n', '\t\t// 31.05.2019 09:00:00\n', '\t\tdividends.push(Dividend(1559307600, 20, 0));\n', '\t\t// 30.06.2019 09:00:00\n', '\t\tdividends.push(Dividend(1561885200, 30, 0));\n', '\t\t// 31.07.2019 09:00:00\n', '\t\tdividends.push(Dividend(1564563600, 20, 0));\n', '\t\t// 31.08.2019 09:00:00\n', '\t\tdividends.push(Dividend(1567242000, 10, 0));\n', '\t\t// 30.09.2019 09:00:00\n', '\t\tdividends.push(Dividend(1569834000, 5, 0));\n', '\n', '\t\tNewSmartToken(address(this));\n', '\t}\n', '\n', '\tmodifier transfersAllowed {\n', '\t\tassert(transfersEnabled);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction totalSupply() constant returns (uint256 totalSupply) {\n', '\t\ttotalSupply = _totalSupply;\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\tbool allAgingTimesHasBeenAdded = false;\n', '\tfunction addAgingTime(uint256 time) onlyOwner {\n', '\t\trequire(!allAgingTimesHasBeenAdded);\n', '\t\tagingTimes.push(time);\n', '\t}\n', '\n', '\tfunction allAgingTimesAdded() onlyOwner {\n', '\t\tallAgingTimesHasBeenAdded = true;\n', '\t}\n', '\n', '\tfunction calculateDividends(uint256 limit) {\n', '\t\trequire(now >= dividends[currentDividendIndex].time);\n', '\t\trequire(limit > 0);\n', '\n', '\t\tlimit = dividends[currentDividendIndex].countComplete + limit;\n', '\n', '\t\tif (limit > addressByIndex.length) {\n', '\t\t\tlimit = addressByIndex.length;\n', '\t\t}\n', '\n', '\t\tfor (uint256 i = dividends[currentDividendIndex].countComplete; i < limit; i++) {\n', '\t\t\taddDividendsForAddress(addressByIndex[i]);\n', '\t\t}\n', '\t\tif (limit == addressByIndex.length) {\n', '\t\t\tcurrentDividendIndex++;\n', '\t\t}\n', '\t\telse {\n', '\t\t\tdividends[currentDividendIndex].countComplete = limit;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction addDividendsForAddress(address _address) internal {\n', '\t\t// skip calculating dividends, if already calculated for this address\n', '\t\tif (calculatedDividendsIndex[_address] >= currentDividendIndex) return;\n', '\n', '\t\tuint256 add = balances[_address] * dividends[currentDividendIndex].tenThousandth / 1000;\n', '\t\tbalances[_address] += add;\n', '\t\tTransfer(this, _address, add);\n', '\t\tIssuance(add);\n', '\t\t_totalSupply = safeAdd(_totalSupply, add);\n', '\n', '\t\tif (agingBalanceOf[_address][0] > 0) {\n', '\t\t\tagingBalanceOf[_address][0] += agingBalanceOf[_address][0] * dividends[currentDividendIndex].tenThousandth / 1000;\n', '\t\t\tfor (uint256 k = 0; k < agingTimes.length; k++) {\n', '\t\t\t\tagingBalanceOf[_address][agingTimes[k]] += agingBalanceOf[_address][agingTimes[k]] * dividends[currentDividendIndex].tenThousandth / 1000;\n', '\t\t\t}\n', '\t\t}\n', '\t\tcalculatedDividendsIndex[_address] = currentDividendIndex;\n', '\t}\n', '\n', '\t/* Send coins */\n', '\tfunction transfer(address _to, uint256 _value) transfersAllowed returns (bool success) {\n', '\t\tcheckMyAging(msg.sender);\n', '\t\tif (now >= dividends[currentDividendIndex].time) {\n', '\t\t\taddDividendsForAddress(msg.sender);\n', '\t\t\taddDividendsForAddress(_to);\n', '\t\t}\n', '\n', '\t\trequire(accountBalance(msg.sender) >= _value);\n', '\n', '\t\t// Subtract from the sender\n', '\t\tbalances[msg.sender] -= _value;\n', '\n', '\t\tif (agingTimesForPools[msg.sender] > 0 && agingTimesForPools[msg.sender] > now) {\n', '\t\t\taddToAging(msg.sender, _to, agingTimesForPools[msg.sender], _value);\n', '\t\t}\n', '\n', '\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\n', '\t\taddIndex(_to);\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction mintToken(address target, uint256 mintedAmount, uint256 agingTime) onlyOwner {\n', '\t\tif (agingTime > now) {\n', '\t\t\taddToAging(owner, target, agingTime, mintedAmount);\n', '\t\t}\n', '\n', '\t\tbalances[target] += mintedAmount;\n', '\n', '\t\t_totalSupply += mintedAmount;\n', '\t\tIssuance(mintedAmount);\n', '\t\taddIndex(target);\n', '\t\tTransfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\tfunction addIndex(address _address) internal {\n', '\t\tif (!addressAddedToIndex[_address]) {\n', '\t\t\taddressAddedToIndex[_address] = true;\n', '\t\t\taddressByIndex.push(_address);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction addToAging(address from, address target, uint256 agingTime, uint256 amount) internal {\n', '\t\tagingBalanceOf[target][0] += amount;\n', '\t\tagingBalanceOf[target][agingTime] += amount;\n', '\t\tAgingTransfer(from, target, amount, agingTime);\n', '\t}\n', '\n', '\t/* Allow another contract to spend some tokens in your behalf */\n', '\tfunction approve(address _spender, uint256 _value) returns (bool success) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* Approve and then communicate the approved contract in a single tx */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t/* A contract attempts to get the coins */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) transfersAllowed returns (bool success) {\n', '\t\tcheckMyAging(_from);\n', '\t\tif (now >= dividends[currentDividendIndex].time) {\n', '\t\t\taddDividendsForAddress(_from);\n', '\t\t\taddDividendsForAddress(_to);\n', '\t\t}\n', '\t\t// Check if the sender has enough\n', '\t\trequire(accountBalance(_from) >= _value);\n', '\n', '\t\t// Check allowed\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\t// Subtract from the sender\n', '\t\tbalances[_from] -= _value;\n', '\t\t// Add the same to the recipient\n', '\t\tbalances[_to] = safeAdd(balances[_to], _value);\n', '\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\n', '\t\tif (agingTimesForPools[_from] > 0 && agingTimesForPools[_from] > now) {\n', '\t\t\taddToAging(_from, _to, agingTimesForPools[_from], _value);\n', '\t\t}\n', '\n', '\t\taddIndex(_to);\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* This unnamed function is called whenever someone tries to send ether to it */\n', '\tfunction() {\n', '\t\trevert();\n', '\t\t// Prevents accidental sending of ether\n', '\t}\n', '\n', '\tfunction checkMyAging(address sender) internal {\n', '\t\tif (agingBalanceOf[sender][0] == 0) return;\n', '\n', '\t\tfor (uint256 k = 0; k < agingTimes.length; k++) {\n', '\t\t\tif (agingTimes[k] < now) {\n', '\t\t\t\tagingBalanceOf[sender][0] -= agingBalanceOf[sender][agingTimes[k]];\n', '\t\t\t\tagingBalanceOf[sender][agingTimes[k]] = 0;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction addAgingTimesForPool(address poolAddress, uint256 agingTime) onlyOwner {\n', '\t\tagingTimesForPools[poolAddress] = agingTime;\n', '\t}\n', '\n', '\tfunction countAddresses() constant returns (uint256 length) {\n', '\t\treturn addressByIndex.length;\n', '\t}\n', '\n', '\tfunction accountBalance(address _address) constant returns (uint256 balance) {\n', '\t\treturn balances[_address] - agingBalanceOf[_address][0];\n', '\t}\n', '\n', '\tfunction disableTransfers(bool _disable) public onlyOwner {\n', '\t\ttransfersEnabled = !_disable;\n', '\t}\n', '\n', '\tfunction issue(address _to, uint256 _amount) public onlyOwner validAddress(_to) notThis(_to) {\n', '\t\t_totalSupply = safeAdd(_totalSupply, _amount);\n', '\t\tbalances[_to] = safeAdd(balances[_to], _amount);\n', '\n', '\t\taddIndex(_to);\n', '\t\tIssuance(_amount);\n', '\t\tTransfer(this, _to, _amount);\n', '\t}\n', '\n', '\tfunction destroy(address _from, uint256 _amount) public {\n', '\t\tcheckMyAging(msg.sender);\n', '\t\t// validate input\n', '\t\trequire(msg.sender == _from || msg.sender == owner);\n', '\t\trequire(accountBalance(_from) >= _amount);\n', '\n', '\t\tbalances[_from] = safeSub(balances[_from], _amount);\n', '\t\t_totalSupply = safeSub(_totalSupply, _amount);\n', '\n', '\t\tTransfer(_from, this, _amount);\n', '\t\tDestruction(_amount);\n', '\t}\n', '}']