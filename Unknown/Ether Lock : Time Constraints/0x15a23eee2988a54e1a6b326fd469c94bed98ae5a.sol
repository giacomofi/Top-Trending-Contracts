['pragma solidity ^0.4.4;\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'contract MichCoin is ERC20 {\n', '\n', '    string public constant name = "Mich Coin";\n', '    string public constant symbol = "MCH";\n', '    uint public constant decimals = 8;\n', '\n', '    uint public tokenToEtherRate;\n', '\n', '    uint public startTime;\n', '    uint public endTime;\n', '    uint public bonusEndTime;\n', '\n', '    uint public minTokens;\n', '    uint public maxTokens;\n', '    bool public frozen;\n', '\n', '    address owner;\n', '    address reserve;\n', '    address main;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) incomes;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    uint public tokenSold;\n', '\n', '    function MichCoin(uint _tokenCount, uint _minTokenCount, uint _tokenToEtherRate,\n', '                      uint _beginDurationInSec, uint _durationInSec, uint _bonusDurationInSec,\n', '                      address _mainAddress, address _reserveAddress) {\n', '        require(_minTokenCount <= _tokenCount);\n', '        require(_bonusDurationInSec <= _durationInSec);\n', '        require(_mainAddress != _reserveAddress);\n', '\n', '        tokenToEtherRate = _tokenToEtherRate;\n', '        totalSupply = _tokenCount*(10**decimals);\n', '        minTokens = _minTokenCount*(10**decimals);\n', '        maxTokens = totalSupply*85/100;\n', '\n', '        owner = msg.sender;\n', '        balances[this] = totalSupply;\n', '\n', '        startTime = now + _beginDurationInSec;\n', '        bonusEndTime = startTime + _bonusDurationInSec;\n', '        endTime = startTime + _durationInSec;\n', '\n', '        reserve = _reserveAddress;\n', '        main = _mainAddress;\n', '        frozen = false;\n', '        tokenSold = 0;\n', '    }\n', '\n', '    //modifiers\n', '\n', '    modifier ownerOnly {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier canFreeze {\n', '        require(frozen == false);\n', '        _;\n', '    }\n', '\n', '    modifier waitForICO {\n', '        require(now >= startTime);\n', '        _;\n', '    }\n', '\n', '    modifier afterICO {\n', '        //if ico period over or all token sold\n', '        require(now > endTime || balances[this] <= totalSupply - maxTokens);\n', '        _;\n', '    }\n', '\n', '    //owner functions\n', '\n', '    function freeze() ownerOnly {\n', '        frozen = true;\n', '    }\n', '\n', '    function unfreeze() ownerOnly {\n', '        frozen = false;\n', '    }\n', '\n', '    //erc20\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) canFreeze returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) canFreeze returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(allowed[_from][_to] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][_to] -= _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) canFreeze returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    //ether operations\n', '\n', '    function () payable canFreeze waitForICO {\n', '        uint tokenAmount = weiToToken(msg.value);\n', '        uint bonusAmount = 0;\n', '        //add bonus token if bought on bonus period\n', '        if (now < bonusEndTime) {\n', '            bonusAmount = tokenAmount / 10;\n', '            tokenAmount += bonusAmount;\n', '        }\n', '\n', '        require(now < endTime);\n', '        require(balances[this] >= tokenAmount);\n', '        require(balances[this] - tokenAmount >= totalSupply - maxTokens);\n', '        require(balances[msg.sender] + tokenAmount > balances[msg.sender]);\n', '\n', '        balances[this] -= tokenAmount;\n', '        balances[msg.sender] += tokenAmount;\n', '        incomes[msg.sender] += msg.value;\n', '        tokenSold += tokenAmount;\n', '    }\n', '\n', '    function refund(address _sender) canFreeze afterICO {\n', '        require(balances[this] >= totalSupply - minTokens);\n', '        require(incomes[_sender] > 0);\n', '\n', '        balances[_sender] = 0;\n', '        _sender.transfer(incomes[_sender]);\n', '        incomes[_sender] = 0;\n', '    }\n', '\n', '    function withdraw() canFreeze afterICO {\n', '        require(balances[this] < totalSupply - minTokens);\n', '        require(this.balance > 0);\n', '\n', '        balances[reserve] = (totalSupply - balances[this]) * 15 / 85;\n', '        balances[this] = 0;\n', '        main.transfer(this.balance);\n', '    }\n', '\n', '    //utility\n', '\n', '    function tokenToWei(uint _tokens) constant returns (uint) {\n', '        return _tokens * (10**18) / tokenToEtherRate / (10**decimals);\n', '    }\n', '\n', '    function weiToToken(uint _weis) constant returns (uint) {\n', '        return tokenToEtherRate * _weis * (10**decimals) / (10**18);\n', '    }\n', '\n', '    function tokenAvailable() constant returns (uint) {\n', '        uint available = balances[this] - (totalSupply - maxTokens);\n', '        if (balances[this] < (totalSupply - maxTokens)) {\n', '            available = 0;\n', '        }\n', '        return available;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.4;\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'contract MichCoin is ERC20 {\n', '\n', '    string public constant name = "Mich Coin";\n', '    string public constant symbol = "MCH";\n', '    uint public constant decimals = 8;\n', '\n', '    uint public tokenToEtherRate;\n', '\n', '    uint public startTime;\n', '    uint public endTime;\n', '    uint public bonusEndTime;\n', '\n', '    uint public minTokens;\n', '    uint public maxTokens;\n', '    bool public frozen;\n', '\n', '    address owner;\n', '    address reserve;\n', '    address main;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) incomes;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    uint public tokenSold;\n', '\n', '    function MichCoin(uint _tokenCount, uint _minTokenCount, uint _tokenToEtherRate,\n', '                      uint _beginDurationInSec, uint _durationInSec, uint _bonusDurationInSec,\n', '                      address _mainAddress, address _reserveAddress) {\n', '        require(_minTokenCount <= _tokenCount);\n', '        require(_bonusDurationInSec <= _durationInSec);\n', '        require(_mainAddress != _reserveAddress);\n', '\n', '        tokenToEtherRate = _tokenToEtherRate;\n', '        totalSupply = _tokenCount*(10**decimals);\n', '        minTokens = _minTokenCount*(10**decimals);\n', '        maxTokens = totalSupply*85/100;\n', '\n', '        owner = msg.sender;\n', '        balances[this] = totalSupply;\n', '\n', '        startTime = now + _beginDurationInSec;\n', '        bonusEndTime = startTime + _bonusDurationInSec;\n', '        endTime = startTime + _durationInSec;\n', '\n', '        reserve = _reserveAddress;\n', '        main = _mainAddress;\n', '        frozen = false;\n', '        tokenSold = 0;\n', '    }\n', '\n', '    //modifiers\n', '\n', '    modifier ownerOnly {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier canFreeze {\n', '        require(frozen == false);\n', '        _;\n', '    }\n', '\n', '    modifier waitForICO {\n', '        require(now >= startTime);\n', '        _;\n', '    }\n', '\n', '    modifier afterICO {\n', '        //if ico period over or all token sold\n', '        require(now > endTime || balances[this] <= totalSupply - maxTokens);\n', '        _;\n', '    }\n', '\n', '    //owner functions\n', '\n', '    function freeze() ownerOnly {\n', '        frozen = true;\n', '    }\n', '\n', '    function unfreeze() ownerOnly {\n', '        frozen = false;\n', '    }\n', '\n', '    //erc20\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) canFreeze returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) canFreeze returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(allowed[_from][_to] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][_to] -= _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) canFreeze returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    //ether operations\n', '\n', '    function () payable canFreeze waitForICO {\n', '        uint tokenAmount = weiToToken(msg.value);\n', '        uint bonusAmount = 0;\n', '        //add bonus token if bought on bonus period\n', '        if (now < bonusEndTime) {\n', '            bonusAmount = tokenAmount / 10;\n', '            tokenAmount += bonusAmount;\n', '        }\n', '\n', '        require(now < endTime);\n', '        require(balances[this] >= tokenAmount);\n', '        require(balances[this] - tokenAmount >= totalSupply - maxTokens);\n', '        require(balances[msg.sender] + tokenAmount > balances[msg.sender]);\n', '\n', '        balances[this] -= tokenAmount;\n', '        balances[msg.sender] += tokenAmount;\n', '        incomes[msg.sender] += msg.value;\n', '        tokenSold += tokenAmount;\n', '    }\n', '\n', '    function refund(address _sender) canFreeze afterICO {\n', '        require(balances[this] >= totalSupply - minTokens);\n', '        require(incomes[_sender] > 0);\n', '\n', '        balances[_sender] = 0;\n', '        _sender.transfer(incomes[_sender]);\n', '        incomes[_sender] = 0;\n', '    }\n', '\n', '    function withdraw() canFreeze afterICO {\n', '        require(balances[this] < totalSupply - minTokens);\n', '        require(this.balance > 0);\n', '\n', '        balances[reserve] = (totalSupply - balances[this]) * 15 / 85;\n', '        balances[this] = 0;\n', '        main.transfer(this.balance);\n', '    }\n', '\n', '    //utility\n', '\n', '    function tokenToWei(uint _tokens) constant returns (uint) {\n', '        return _tokens * (10**18) / tokenToEtherRate / (10**decimals);\n', '    }\n', '\n', '    function weiToToken(uint _weis) constant returns (uint) {\n', '        return tokenToEtherRate * _weis * (10**decimals) / (10**18);\n', '    }\n', '\n', '    function tokenAvailable() constant returns (uint) {\n', '        uint available = balances[this] - (totalSupply - maxTokens);\n', '        if (balances[this] < (totalSupply - maxTokens)) {\n', '            available = 0;\n', '        }\n', '        return available;\n', '    }\n', '\n', '}']
