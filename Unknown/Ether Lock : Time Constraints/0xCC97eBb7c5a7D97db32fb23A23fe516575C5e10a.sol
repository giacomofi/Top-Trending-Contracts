['/*\n', 'This file is part of the NeuroDAO Contract.\n', '\n', 'The NeuroDAO Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The NeuroDAO Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the NeuroDAO Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@nordavind.ru>\n', '\n', 'IF YOU ARE ENJOYED IT DONATE TO 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B ! :)\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function transfer(address to, uint value);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '    function transferFrom(address from, address to, uint value);\n', '    function approve(address spender, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ManualMigration is owned, ERC20 {\n', '\n', '    uint    public freezedMoment;\n', '    address public original;\n', '\n', '    modifier enabled {\n', '        require(original == 0);\n', '        _;\n', '    }\n', '    \n', '    struct SpecialTokenHolder {\n', '        uint limit;\n', '        bool isTeam;\n', '    }\n', '    mapping (address => SpecialTokenHolder) public specials;\n', '\n', '    struct TokenHolder {\n', '        uint balance;\n', '        uint balanceBeforeUpdate;\n', '        uint balanceUpdateTime;\n', '    }\n', '    mapping (address => TokenHolder) public holders;\n', '\n', '    function ManualMigration(address _original) payable owned() {\n', '        original = _original;\n', '        totalSupply = ERC20(original).totalSupply();\n', '        holders[this].balance = ERC20(original).balanceOf(original);\n', '        holders[original].balance = totalSupply - holders[this].balance;\n', '        Transfer(this, original, holders[original].balance);\n', '    }\n', '\n', '    function migrateManual(address _who, bool _isTeam) onlyOwner {\n', '        require(original != 0);\n', '        require(holders[_who].balance == 0);\n', '        uint balance = ERC20(original).balanceOf(_who);\n', '        holders[_who].balance = balance;\n', '        specials[_who] = SpecialTokenHolder({limit: balance, isTeam:_isTeam});\n', '        holders[original].balance -= balance;\n', '        Transfer(original, _who, balance);\n', '    }\n', '    \n', '    function sealManualMigration(bool force) onlyOwner {\n', '        require(force || holders[original].balance == 0);\n', '        delete original;\n', '    }\n', '\n', '    function beforeBalanceChanges(address _who) internal {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            holders[_who].balanceUpdateTime = now;\n', '            holders[_who].balanceBeforeUpdate = holders[_who].balance;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Crowdsale is ManualMigration {\n', '    \n', '    function Crowdsale(address _original) payable ManualMigration(_original) {}\n', '\n', '    function () payable enabled {\n', '        require(holders[this].balance > 0);\n', '        uint256 tokens = 5000 * msg.value / 1000000000000000000;\n', '        if (tokens > holders[this].balance) {\n', '            tokens = holders[this].balance;\n', '            uint valueWei = tokens * 1000000000000000000 / 5000;\n', '            msg.sender.transfer(msg.value - valueWei);\n', '        }\n', '        require(holders[msg.sender].balance + tokens > holders[msg.sender].balance); // overflow\n', '        require(tokens > 0);\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(this);\n', '        holders[msg.sender].balance += tokens;\n', '        specials[msg.sender].limit += tokens;\n', '        holders[this].balance -= tokens;\n', '        Transfer(this, msg.sender, tokens);\n', '    }\n', '}\n', '\n', 'contract Token is Crowdsale {\n', '\n', "    string  public standard    = 'Token 0.1';\n", "    string  public name        = 'NeuroDAO';\n", '    string  public symbol      = "NDAO";\n', '    uint8   public decimals    = 0;\n', '\n', '    uint    public startTime;\n', '\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event Burned(address indexed owner, uint256 value);\n', '\n', '    function Token(address _original, uint _startTime)\n', '        payable Crowdsale(_original) {\n', '        startTime = _startTime;    \n', '    }\n', '\n', '    function availableTokens(address _who) public constant returns (uint _avail) {\n', '        _avail = holders[_who].balance;\n', '        uint limit = specials[_who].limit;\n', '        if (limit != 0) {\n', '            uint blocked;\n', '            uint periods = firstYearPeriods();\n', '            if (specials[_who].isTeam) {\n', '                if (periods != 0) {\n', '                    blocked = limit * (500 - periods) / 500;\n', '                } else {\n', '                    periods = (now - startTime) / 1 years;\n', '                    ++periods;\n', '                    if (periods < 5) {\n', '                        blocked = limit * (100 - periods * 20) / 100;\n', '                    }\n', '                }\n', '            } else {\n', '                if (periods != 0) {\n', '                    blocked = limit * (100 - periods) / 100;\n', '                }\n', '            }\n', '            _avail -= blocked;\n', '        }\n', '    }\n', '    \n', '    function firstYearPeriods() internal constant returns (uint _periods) {\n', '        _periods = 0;\n', '        if (now < startTime + 1 years) {\n', '            uint8[12] memory logic = [1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10];\n', '            _periods = logic[(now - startTime) / 28 days];\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return holders[_who].balance;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public enabled {\n', '        require(availableTokens(msg.sender) >= _value);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(_to);\n', '        holders[msg.sender].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public enabled {\n', '        require(availableTokens(_from) >= _value);\n', '        require(holders[_to].balance + _value >= holders[_to].balance); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        beforeBalanceChanges(_from);\n', '        beforeBalanceChanges(_to);\n', '        holders[_from].balance -= _value;\n', '        holders[_to].balance += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant\n', '        returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function burn(uint256 _value) public enabled {\n', '        require(holders[msg.sender].balance >= _value);\n', '        beforeBalanceChanges(msg.sender);\n', '        holders[msg.sender].balance -= _value;\n', '        totalSupply -= _value;\n', '        Burned(msg.sender, _value);\n', '    }\n', '}\n', '\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '}\n', '\n', 'contract TokenMigration is Token {\n', '    \n', '    address public migrationAgent;\n', '    uint256 public totalMigrated;\n', '\n', '    event Migrate(address indexed from, address indexed to, uint256 value);\n', '\n', '    function TokenMigration(address _original, uint _startTime)\n', '        payable Token(_original, _startTime) {}\n', '\n', '    // Migrate _value of tokens to the new token contract\n', '    function migrate() external {\n', '        require(migrationAgent != 0);\n', '        uint value = holders[msg.sender].balance;\n', '        require(value != 0);\n', '        beforeBalanceChanges(msg.sender);\n', '        beforeBalanceChanges(this);\n', '        holders[msg.sender].balance -= value;\n', '        holders[this].balance += value;\n', '        totalMigrated += value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '        Transfer(msg.sender, this, value);\n', '        Migrate(msg.sender, migrationAgent, value);\n', '    }\n', '\n', '    function setMigrationAgent(address _agent) external onlyOwner enabled {\n', '        require(migrationAgent == 0);\n', '        migrationAgent = _agent;\n', '    }\n', '}\n', '\n', 'contract NeuroDAO is TokenMigration {\n', '\n', '    function NeuroDAO(address _original, uint _startTime)\n', '        payable TokenMigration(_original, _startTime) {}\n', '    \n', '    function withdraw() public onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function freezeTheMoment() public onlyOwner {\n', '        freezedMoment = now;\n', '    }\n', '\n', '    /** Get balance of _who for freezed moment\n', '     *  freezeTheMoment()\n', '     */\n', '    function freezedBalanceOf(address _who) constant public returns(uint) {\n', '        if (holders[_who].balanceUpdateTime <= freezedMoment) {\n', '            return holders[_who].balance;\n', '        } else {\n', '            return holders[_who].balanceBeforeUpdate;\n', '        }\n', '    }\n', '    \n', '    function killMe() public onlyOwner {\n', '        require(totalSupply == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', 'contract Adapter is owned {\n', '    \n', '    address public neuroDAO;\n', '    address public erc20contract;\n', '    address public masterHolder;\n', '    \n', '    mapping (address => bool) public alreadyUsed;\n', '    \n', '    function Adapter(address _neuroDAO, address _erc20contract, address _masterHolder)\n', '        payable owned() {\n', '        neuroDAO = _neuroDAO;\n', '        erc20contract = _erc20contract;\n', '        masterHolder = _masterHolder;\n', '    }\n', '    \n', '    function killMe() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', ' \n', '    /**\n', '     * Move tokens int erc20contract to NDAO tokens holder\n', '     * \n', '     * # Freeze balances in NeuroDAO smartcontract by calling freezeTheMoment() function.\n', '     * # Allow transferFrom masterHolder in ERC20 smartcontract by calling approve() function\n', '     *   from masterHolder address, gives this contract address as spender parameter.\n', '     * # ERC20 smartcontract must have enougth tokens on masterHolder balance.\n', '     */\n', '    function giveMeTokens() public {\n', '        require(!alreadyUsed[msg.sender]);\n', '        uint balance = NeuroDAO(neuroDAO).freezedBalanceOf(msg.sender);\n', '        ERC20(erc20contract).transferFrom(masterHolder, msg.sender, balance);\n', '        alreadyUsed[msg.sender] = true;\n', '    }\n', '}']