['pragma solidity ^0.4.6;\n', '\n', 'contract SafeMath {\n', '    function mul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract TokenController {\n', '    function proxyPayment(address _owner) payable returns (bool);\n', '\n', '    function onTransfer(address _from, address _to, uint _amount) returns (bool);\n', '\n', '    function onApprove(address _owner, address _spender, uint _amount)\n', '    returns (bool);\n', '}\n', '\n', '\n', 'contract Controlled {\n', '    modifier onlyController {if (msg.sender != controller) throw;\n', '        _;}\n', '\n', '    address public controller;\n', '\n', '    function Controlled() {controller = msg.sender;}\n', '\n', '    function changeController(address _newController) onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\n', '}\n', '\n', '\n', 'contract ShineCoinToken is Controlled {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    string public version = &#39;SHINE_0.1&#39;;\n', '\n', '    struct Checkpoint {\n', '        uint128 fromBlock;\n', '        uint128 value;\n', '    }\n', '\n', '    ShineCoinToken public parentToken;\n', '\n', '    address public frozenReserveTeamRecipient;\n', '\n', '    uint public parentSnapShotBlock;\n', '\n', '    uint public creationBlock;\n', '\n', '    // Periods\n', '    uint public firstRewardPeriodEndBlock;\n', '\n', '    uint public secondRewardPeriodEndBlock;\n', '\n', '    uint public thirdRewardPeriodEndBlock;\n', '\n', '    uint public finalRewardPeriodEndBlock;\n', '\n', '    // Loos\n', '    uint public firstLoos;\n', '\n', '    uint public secondLoos;\n', '\n', '    uint public thirdLoos;\n', '\n', '    uint public finalLoos;\n', '\n', '\n', '    // Percents\n', '    uint public firstRewardPeriodPercent;\n', '\n', '    uint public secondRewardPeriodPercent;\n', '\n', '    uint public thirdRewardPeriodPercent;\n', '\n', '    uint public finalRewardPeriodPercent;\n', '\n', '    // Unfreeze team wallet for transfers\n', '    uint public unfreezeTeamRecepientBlock;\n', '\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', '    bool public transfersEnabled;\n', '\n', '    ShineCoinTokenFactory public tokenFactory;\n', '\n', '    function ShineCoinToken(\n', '        address _tokenFactory,\n', '        address _parentToken,\n', '        uint _parentSnapShotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) {\n', '        tokenFactory = ShineCoinTokenFactory(_tokenFactory);\n', '        name = _tokenName;\n', '        decimals = _decimalUnits;\n', '        symbol = _tokenSymbol;\n', '        parentToken = ShineCoinToken(_parentToken);\n', '        parentSnapShotBlock = _parentSnapShotBlock;\n', '        transfersEnabled = _transfersEnabled;\n', '        creationBlock = block.number;\n', '        unfreezeTeamRecepientBlock = block.number + ((396 * 24 * 3600) / 18); // 396 days\n', '\n', '        firstRewardPeriodEndBlock = creationBlock + ((121 * 24 * 3600) / 18); // 121 days\n', '        secondRewardPeriodEndBlock = creationBlock + ((181 * 24 * 3600) / 18); // 181 days\n', '        thirdRewardPeriodEndBlock = creationBlock + ((211 * 24 * 3600) / 18); // 211 days\n', '        finalRewardPeriodEndBlock = creationBlock + ((760 * 24 * 3600) / 18); // 2 years\n', '\n', '        firstRewardPeriodPercent = 29;\n', '        secondRewardPeriodPercent = 23;\n', '        thirdRewardPeriodPercent = 18;\n', '        finalRewardPeriodPercent = 12;\n', '\n', '        firstLoos = ((15 * 24 * 3600) / 18); // 15 days;\n', '        secondLoos = ((10 * 24 * 3600) / 18); // 10 days;\n', '        thirdLoos = ((5 * 24 * 3600) / 18); // 5 days;\n', '        finalLoos = ((1 * 24 * 3600) / 18); // 1 days;\n', '    }\n', '\n', '    function changeReserveTeamRecepient(address _newReserveTeamRecipient) onlyController returns (bool) {\n', '        frozenReserveTeamRecipient = _newReserveTeamRecipient;\n', '        return true;\n', '    }\n', '\n', '    ///////////////////\n', '    // ERC20 Methods\n', '    ///////////////////\n', '\n', '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        if (!transfersEnabled) throw;\n', '        if ((address(msg.sender) == frozenReserveTeamRecipient) && (block.number < unfreezeTeamRecepientBlock)) throw;\n', '        if ((_to == frozenReserveTeamRecipient) && (block.number < unfreezeTeamRecepientBlock)) throw;\n', '        return doTransfer(msg.sender, _to, _amount);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '        if (msg.sender != controller) {\n', '            if (!transfersEnabled) throw;\n', '\n', '            if (allowed[_from][msg.sender] < _amount) return false;\n', '            allowed[_from][msg.sender] -= _amount;\n', '        }\n', '        return doTransfer(_from, _to, _amount);\n', '    }\n', '\n', '    function doTransfer(address _from, address _to, uint _amount) internal returns (bool) {\n', '\n', '        if (_amount == 0) {\n', '            return true;\n', '        }\n', '\n', '        if (parentSnapShotBlock >= block.number) throw;\n', '\n', '        if ((_to == 0) || (_to == address(this))) throw;\n', '\n', '        var previousBalanceFrom = balanceOfAt(_from, block.number);\n', '        if (previousBalanceFrom < _amount) {\n', '            return false;\n', '        }\n', '\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n', '            throw;\n', '        }\n', '\n', '        Checkpoint[] checkpoints = balances[_from];\n', '        uint lastBlock = checkpoints[checkpoints.length - 1].fromBlock;\n', '        uint blocksFromLastBlock = block.number - lastBlock;\n', '        uint rewardAmount = 0;\n', '\n', '        if (block.number <= firstRewardPeriodEndBlock) {\n', '            if (blocksFromLastBlock > firstLoos) {\n', '                rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * blocksFromLastBlock;\n', '            }\n', '        }\n', '        else if (block.number <= secondRewardPeriodEndBlock) {\n', '            if (blocksFromLastBlock > secondLoos) {\n', '                if (lastBlock < firstRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - block.number);\n', '                }\n', '                else {\n', '                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * blocksFromLastBlock;\n', '                }\n', '            }\n', '        }\n', '        else if (block.number <= thirdRewardPeriodEndBlock) {\n', '            if (blocksFromLastBlock > thirdLoos) {\n', '                if (lastBlock < firstRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\n', '                }\n', '                else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\n', '                }\n', '                else {\n', '                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * blocksFromLastBlock;\n', '                }\n', '            }\n', '        }\n', '        else if (block.number <= finalRewardPeriodEndBlock) {\n', '            if (blocksFromLastBlock > finalLoos) {\n', '                if (lastBlock < firstRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else {\n', '                    rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * blocksFromLastBlock;\n', '                }\n', '            }\n', '        }\n', '        else {\n', '            if (blocksFromLastBlock > finalLoos) {\n', '                if (lastBlock < firstRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                    rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                }\n', '                else {\n', '                    rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock);\n', '                }\n', '            }\n', '        }\n', '\n', '        rewardAmount = rewardAmount / 10000;\n', '        uint curTotalSupply = 0;\n', '\n', '        updateValueAtNow(balances[_from], previousBalanceFrom - _amount + rewardAmount);\n', '\n', '        // UPDATE TOTAL\n', '        if (rewardAmount > 0) {\n', '            curTotalSupply = getValueAt(totalSupplyHistory, block.number);\n', '            if (curTotalSupply + rewardAmount < curTotalSupply) throw; // Check for overflow\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply + rewardAmount);\n', '        }\n', '\n', '        rewardAmount = 0;\n', '\n', '        var previousBalanceTo = balanceOfAt(_to, block.number);\n', '        if (previousBalanceTo + _amount < previousBalanceTo) throw;\n', '\n', '        checkpoints = balances[_to];\n', '        if (checkpoints.length > 0) {\n', '            lastBlock = checkpoints[checkpoints.length - 1].fromBlock;\n', '            blocksFromLastBlock = block.number - lastBlock;\n', '\n', '            if (_amount >= (previousBalanceTo / 3)) {\n', '                if (blocksFromLastBlock > finalLoos) {\n', '\n', '                    if (block.number <= firstRewardPeriodEndBlock) {\n', '                        rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * blocksFromLastBlock;\n', '                    }\n', '                    else if (block.number <= secondRewardPeriodEndBlock) {\n', '\n', '                        if (lastBlock < firstRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else {\n', '                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * blocksFromLastBlock;\n', '                        }\n', '\n', '                    }\n', '                    else if (block.number <= thirdRewardPeriodEndBlock) {\n', '\n', '                        if (lastBlock < firstRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (thirdRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else {\n', '                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * blocksFromLastBlock;\n', '                        }\n', '\n', '                    }\n', '                    else if (block.number <= finalRewardPeriodEndBlock) {\n', '\n', '                        if (lastBlock < firstRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else {\n', '                            rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * blocksFromLastBlock;\n', '                        }\n', '\n', '                    }\n', '                    else {\n', '\n', '                        if (lastBlock < firstRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * firstRewardPeriodPercent * (firstRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * secondRewardPeriodPercent * (thirdRewardPeriodEndBlock - secondRewardPeriodEndBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * secondRewardPeriodPercent * (secondRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else if (lastBlock < secondRewardPeriodEndBlock) {\n', '                            rewardAmount = previousBalanceFrom * thirdRewardPeriodPercent * (finalRewardPeriodEndBlock - lastBlock) + previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - block.number);\n', '                        }\n', '                        else {\n', '                            rewardAmount = previousBalanceFrom * finalRewardPeriodPercent * (finalRewardPeriodEndBlock - thirdRewardPeriodEndBlock);\n', '                        }\n', '                    }\n', '\n', '                }\n', '            }\n', '\n', '        }\n', '\n', '        rewardAmount = rewardAmount / 10000;\n', '        updateValueAtNow(balances[_to], previousBalanceTo + _amount + rewardAmount);\n', '\n', '        // UPDATE TOTAL\n', '        if (rewardAmount > 0) {\n', '            curTotalSupply = getValueAt(totalSupplyHistory, block.number);\n', '            if (curTotalSupply + rewardAmount < curTotalSupply) throw;\n', '            // Check for overflow\n', '            updateValueAtNow(totalSupplyHistory, curTotalSupply + rewardAmount);\n', '        }\n', '\n', '        Transfer(_from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        if (!transfersEnabled) throw;\n', '\n', '        if ((_amount != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\n', '            throw;\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender\n', '    ) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) returns (bool success) {\n', '        if (!approve(_spender, _amount)) throw;\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '        msg.sender,\n', '        _amount,\n', '        this,\n', '        _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '\n', '    function getBalancesOfAddress(address _owner) onlyController returns (uint128, uint128) {\n', '        Checkpoint[] checkpoints = balances[_owner];\n', '        return (checkpoints[checkpoints.length - 1].value, checkpoints[checkpoints.length - 1].fromBlock);\n', '    }\n', '\n', '    function balanceOfAt(address _owner, uint _blockNumber) constant\n', '    returns (uint) {\n', '\n', '        if ((balances[_owner].length == 0)\n', '        || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '            }\n', '            else {\n', '                return 0;\n', '            }\n', '        }\n', '        else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '    function totalSupplyAt(uint _blockNumber) constant returns (uint) {\n', '        if ((totalSupplyHistory.length == 0)\n', '        || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '            }\n', '            else {\n', '                return 0;\n', '            }\n', '        }\n', '        else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '    ) returns (address) {\n', '        if (_snapshotBlock == 0) _snapshotBlock = block.number;\n', '        ShineCoinToken cloneToken = tokenFactory.createCloneToken(\n', '        this,\n', '        _snapshotBlock,\n', '        _cloneTokenName,\n', '        _cloneDecimalUnits,\n', '        _cloneTokenSymbol,\n', '        _transfersEnabled\n', '        );\n', '\n', '        cloneToken.changeController(msg.sender);\n', '\n', '        NewCloneToken(address(cloneToken), _snapshotBlock);\n', '        return address(cloneToken);\n', '    }\n', '\n', '    function generateTokens(address _owner, uint _amount\n', '    ) onlyController returns (bool) {\n', '        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\n', '        if (curTotalSupply + _amount < curTotalSupply) throw;\n', '\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '        var previousBalanceTo = balanceOf(_owner);\n', '        if (previousBalanceTo + _amount < previousBalanceTo) throw;\n', '\n', '        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '        Transfer(0, _owner, _amount);\n', '        return true;\n', '    }\n', '\n', '    function destroyTokens(address _owner, uint _amount\n', '    ) onlyController returns (bool) {\n', '        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\n', '        if (curTotalSupply < _amount) throw;\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n', '        var previousBalanceFrom = balanceOf(_owner);\n', '        if (previousBalanceFrom < _amount) throw;\n', '        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n', '        Transfer(_owner, 0, _amount);\n', '        return true;\n', '    }\n', '\n', '    function enableTransfers(bool _transfersEnabled) onlyController {\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n', '    ) constant internal returns (uint) {\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        if (_block >= checkpoints[checkpoints.length - 1].fromBlock)\n', '        return checkpoints[checkpoints.length - 1].value;\n', '        if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '        uint min = 0;\n', '        uint max = checkpoints.length - 1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock <= _block) {\n', '                min = mid;\n', '            }\n', '            else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n', '    ) internal {\n', '        if ((checkpoints.length == 0)\n', '        || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n', '            Checkpoint newCheckPoint = checkpoints[checkpoints.length++];\n', '            newCheckPoint.fromBlock = uint128(block.number);\n', '            newCheckPoint.value = uint128(_value);\n', '        }\n', '        else {\n', '            Checkpoint oldCheckPoint = checkpoints[checkpoints.length - 1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '\n', '    function isContract(address _addr) constant internal returns (bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '        size := extcodesize(_addr)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    function min(uint a, uint b) internal returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function() payable {\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\n', '            throw;\n', '        }\n', '        else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount\n', '    );\n', '\n', '}\n', '\n', 'contract ShineCoinTokenFactory {\n', '        function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) returns (ShineCoinToken) {\n', '        ShineCoinToken newToken = new ShineCoinToken(\n', '        this,\n', '        _parentToken,\n', '        _snapshotBlock,\n', '        _tokenName,\n', '        _decimalUnits,\n', '        _tokenSymbol,\n', '        _transfersEnabled\n', '        );\n', '        newToken.changeController(msg.sender);\n', '        return newToken;\n', '    }\n', '}\n', '\n', 'contract ShineCrowdFunder is Controlled, SafeMath {\n', '    address public creator;\n', '\n', '    address public fundRecipient;\n', '\n', '    address public reserveTeamRecipient;\n', '\n', '    address public reserveBountyRecipient;\n', '\n', '    address public developersRecipient;\n', '\n', '    address public marketingRecipient;\n', '\n', '    bool public isReserveGenerated;\n', '\n', '    State public state = State.Wait;\n', '\n', '    uint investorCount;\n', '\n', '    uint public minFundingGoal;\n', '\n', '    uint public currentBalance;\n', '\n', '    uint public tokensIssued;\n', '\n', '    uint public capTokenAmount;\n', '\n', '    uint public startBlockNumber;\n', '\n', '    uint public endBlockNumber;\n', '\n', '    uint public tokenExchangeRate;\n', '\n', '    ShineCoinToken public exchangeToken;\n', '\n', '    event GoalReached(address fundRecipient, uint amountRaised);\n', '\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n', '\n', '    mapping (address => uint256) private balanceOf;\n', '\n', '    mapping (address => uint) public fiatInvestorShare;\n', '\n', '    address[] fiatInvestors;\n', '\n', '    mapping (address => bool) private frozenAccount;\n', '\n', '    enum State {\n', '        Wait,\n', '        Fundraising,\n', '        ExpiredRefund,\n', '        Successful,\n', '        Closed\n', '    }\n', '\n', '    modifier inState(State _state) {\n', '        if (state != _state) throw;\n', '        _;\n', '    }\n', '\n', '    modifier atEndOfFundraising() {\n', '        if (!((state == State.ExpiredRefund || state == State.Successful) && block.number > endBlockNumber)\n', '        ) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier accountNotFrozen() {\n', '        if (frozenAccount[msg.sender] == true) throw;\n', '        _;\n', '    }\n', '\n', '    modifier minInvestment() {\n', '        // User has to send at least 0.01 Eth\n', '        require(msg.value >= 10 ** 16);\n', '        _;\n', '    }\n', '\n', '    function ShineCrowdFunder(\n', '    address _fundRecipient,\n', '    address _reserveTeamRecipient,\n', '    address _reserveBountyRecipient,\n', '    address _developersRecipient,\n', '    address _marketingRecipient,\n', '    ShineCoinToken _addressOfExchangeToken\n', '    ) {\n', '        creator = msg.sender;\n', '\n', '        fundRecipient = _fundRecipient;\n', '        reserveTeamRecipient = _reserveTeamRecipient;\n', '        reserveBountyRecipient = _reserveBountyRecipient;\n', '\n', '        developersRecipient = _developersRecipient;\n', '        marketingRecipient = _marketingRecipient;\n', '\n', '        isReserveGenerated = false;\n', '\n', '        minFundingGoal = 10 * 1 ether;\n', '        capTokenAmount = 10000000 * 10 ** 9;\n', '\n', '        state = State.Wait;\n', '\n', '        currentBalance = 0;\n', '        tokensIssued = 0;\n', '\n', '        tokenExchangeRate = 1000 * 10 ** 9;\n', '\n', '        exchangeToken = ShineCoinToken(_addressOfExchangeToken);\n', '    }\n', '\n', '    function startFundraising() inState(State.Wait) onlyController {\n', '        startBlockNumber = block.number;\n', '        endBlockNumber = startBlockNumber + ((31 * 24 * 3600) / 18); // 31 days\n', '        state = State.Fundraising;\n', '    }\n', '\n', '    function changeReserveTeamRecipient(address _reserveTeamRecipient) onlyController {\n', '        reserveTeamRecipient = _reserveTeamRecipient;\n', '    }\n', '\n', '    function changeReserveBountyRecipient(address _reserveBountyRecipient) onlyController {\n', '        reserveBountyRecipient = _reserveBountyRecipient;\n', '    }\n', '\n', '    function changeDevelopersRecipient(address _developersRecipient) onlyController {\n', '        developersRecipient = _developersRecipient;\n', '    }\n', '\n', '    function changeMarketingRecipient(address _marketingRecipient) onlyController {\n', '        marketingRecipient = _marketingRecipient;\n', '    }\n', '\n', '    function addInvestor(address target, uint share) onlyController {\n', '        if (fiatInvestorShare[target] == uint(0x0)) { // new address\n', '            fiatInvestorShare[target] = share;\n', '            fiatInvestors.push(target);\n', '        } else { // address already exists\n', '            if (share > 0) {\n', '                uint prevShare = fiatInvestorShare[target];\n', '                uint newShare = prevShare + share;\n', '\n', '                fiatInvestorShare[target] = newShare;\n', '            }\n', '        }\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze) onlyController {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function updateExchangeRate () {\n', '        if (tokensIssued >= (1000000 * 10 ** 9) && tokensIssued < (2000000 * 10 ** 9)) {\n', '            tokenExchangeRate = 600 * 10 ** 9;\n', '        }\n', '        if (tokensIssued >= (2000000 * 10 ** 9) && tokensIssued < (3500000 * 10 ** 9)) {\n', '            tokenExchangeRate = 500 * 10 ** 9;\n', '        }\n', '        if (tokensIssued >= (3500000 * 10 ** 9) && tokensIssued < (6000000 * 10 ** 9)) {\n', '            tokenExchangeRate = 400 * 10 ** 9;\n', '        }\n', '        if (tokensIssued >= (6000000 * 10 ** 9)) {\n', '            tokenExchangeRate = 300 * 10 ** 9;\n', '        }\n', '    }\n', '\n', '    function getExchangeRate(uint amount) public constant returns (uint) {\n', '        return tokenExchangeRate * amount / 1 ether;\n', '    }\n', '\n', '    function investment() public inState(State.Fundraising) accountNotFrozen minInvestment payable returns (uint)  {\n', '        uint amount = msg.value;\n', '        if (amount == 0) throw;\n', '\n', '        balanceOf[msg.sender] += amount;\n', '        currentBalance += amount;\n', '\n', '        updateExchangeRate();\n', '        uint tokenAmount = getExchangeRate(amount);\n', '        exchangeToken.generateTokens(msg.sender, tokenAmount);\n', '        tokensIssued += tokenAmount;\n', '        updateExchangeRate();\n', '\n', '        FundTransfer(msg.sender, amount, true);\n', '        LogFundingReceived(msg.sender, tokenAmount, tokensIssued);\n', '\n', '        checkIfFundingCompleteOrExpired();\n', '\n', '        return balanceOf[msg.sender];\n', '    }\n', '\n', '    function checkIfFundingCompleteOrExpired() {\n', '        if (block.number > endBlockNumber || tokensIssued >= capTokenAmount) {\n', '            if (currentBalance >= minFundingGoal) {\n', '                state = State.Successful;\n', '                payOut();\n', '\n', '                GoalReached(fundRecipient, currentBalance);\n', '            }\n', '            else {\n', '                state = State.ExpiredRefund;\n', '                // backers can now collect refunds by calling getRefund()\n', '            }\n', '        }\n', '    }\n', '\n', '    function payOut() public inState(State.Successful) onlyController() {\n', '        var amount = currentBalance;\n', '        var balance = currentBalance;\n', '\n', '        currentBalance = 0;\n', '        state = State.Closed;\n', '\n', '        for (uint i = 0; i < fiatInvestors.length; i++) {\n', '            address investorAddress = fiatInvestors[i];\n', '            uint investorShare = fiatInvestorShare[investorAddress];\n', '            uint investorAmount = div(mul(balance, investorShare), 1000000);\n', '            investorAddress.transfer(investorAmount);\n', '            amount -= investorAmount;\n', '        }\n', '\n', '        uint percentDevelopers = 5;\n', '        uint percentMarketing = 5;\n', '        uint amountDevelopers = div(mul(balance, percentDevelopers), 100);\n', '        uint amountMarketing = div(mul(balance, percentMarketing), 100);\n', '\n', '        developersRecipient.transfer(amountDevelopers);\n', '        marketingRecipient.transfer(amountMarketing);\n', '\n', '        amount -= (amountDevelopers + amountMarketing);\n', '\n', '        fundRecipient.transfer(amount);\n', '\n', '        generateReserve();\n', '\n', '        exchangeToken.enableTransfers(true);\n', '        exchangeToken.changeReserveTeamRecepient(reserveTeamRecipient);\n', '        exchangeToken.changeController(controller);\n', '    }\n', '\n', '    function getRefund() public inState(State.ExpiredRefund) {\n', '        uint amountToRefund = balanceOf[msg.sender];\n', '        balanceOf[msg.sender] = 0;\n', '\n', '        msg.sender.transfer(amountToRefund);\n', '        currentBalance -= amountToRefund;\n', '\n', '        FundTransfer(msg.sender, amountToRefund, false);\n', '    }\n', '\n', '    function generateReserve() {\n', '        if (isReserveGenerated) {\n', '            throw;\n', '        }\n', '        else {\n', '            uint issued = tokensIssued;\n', '            uint percentTeam = 15;\n', '            uint percentBounty = 1;\n', '            uint reserveAmountTeam = div(mul(issued, percentTeam), 85);\n', '            uint reserveAmountBounty = div(mul(issued, percentBounty), 99);\n', '            exchangeToken.generateTokens(reserveTeamRecipient, reserveAmountTeam);\n', '            exchangeToken.generateTokens(reserveBountyRecipient, reserveAmountBounty);\n', '            isReserveGenerated = true;\n', '        }\n', '    }\n', '\n', '    function removeContract() public atEndOfFundraising onlyController() {\n', '        if (state != State.Closed) {\n', '            exchangeToken.changeController(controller);\n', '        }\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    /* default */\n', '    function() inState(State.Fundraising) accountNotFrozen payable {\n', '        investment();\n', '    }\n', '\n', '}']