['contract Assertive {\n', '  function assert(bool assertion) {\n', '    if (!assertion) throw;\n', '  }\n', '}\n', '\n', 'contract TokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'contract Owned is Assertive {\n', '  address internal owner;\n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  function Owned () {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _\n', '  }\n', '  function setOwner(address newOwner) onlyOwner {\n', '    SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  function getOwner() returns (address out) {\n', '    return owner;\n', '  }\n', '}\n', '\n', 'contract StateTransferrable is Owned {\n', '  bool internal locked;\n', '  event Locked(address indexed from);\n', '  event PropertySet(address indexed from);\n', '  modifier onlyIfUnlocked {\n', '    assert(!locked);\n', '    _\n', '  }\n', '  modifier setter {\n', '    _\n', '    PropertySet(msg.sender);\n', '  }\n', '  modifier onlyOwnerUnlocked {\n', '    assert(!locked && msg.sender == owner);\n', '    _\n', '  }\n', '  function lock() onlyOwner onlyIfUnlocked {\n', '    locked = true;\n', '    Locked(msg.sender);\n', '  }\n', '  function isLocked() returns (bool status) {\n', '    return locked;\n', '  }\n', '}\n', '\n', 'contract TrustEvents {\n', '  event AuthInit(address indexed from);\n', '  event AuthComplete(address indexed from, address indexed with);\n', '  event AuthPending(address indexed from);\n', '  event Unauthorized(address indexed from);\n', '  event InitCancel(address indexed from);\n', '  event NothingToCancel(address indexed from);\n', '  event SetMasterKey(address indexed from);\n', '  event AuthCancel(address indexed from, address indexed with);\n', '  event NameRegistered(address indexed from, bytes32 indexed name);\n', '}\n', '\n', 'contract Trust is StateTransferrable, TrustEvents {\n', '  mapping (address => bool) public masterKeys;\n', '  mapping (address => bytes32) public nameRegistry;\n', '  address[] public masterKeyIndex;\n', '  mapping (address => bool) public masterKeyActive;\n', '  mapping (address => bool) public trustedClients;\n', '  mapping (bytes32 => address) public functionCalls;\n', '  mapping (address => bytes32) public functionCalling;\n', '  function activateMasterKey(address addr) internal {\n', '    if (!masterKeyActive[addr]) {\n', '      masterKeyActive[addr] = true;\n', '      masterKeyIndex.push(addr);\n', '    }\n', '  }\n', '  function setTrustedClient(address addr) onlyOwnerUnlocked setter {\n', '    trustedClients[addr] = true;\n', '  }\n', '  function untrustClient(address addr) multisig(sha3(msg.data)) {\n', '    trustedClients[addr] = false;\n', '  }\n', '  function trustClient(address addr) multisig(sha3(msg.data)) {\n', '    trustedClients[addr] = true;\n', '  }\n', '  function setMasterKey(address addr) onlyOwnerUnlocked {\n', '    assert(!masterKeys[addr]);\n', '    activateMasterKey(addr);\n', '    masterKeys[addr] = true;\n', '    SetMasterKey(msg.sender);\n', '  }\n', '  modifier onlyMasterKey {\n', '    assert(masterKeys[msg.sender]);\n', '    _\n', '  }\n', '  function extractMasterKeyIndexLength() returns (uint256 length) {\n', '    return masterKeyIndex.length;\n', '  }\n', '  function resetAction(bytes32 hash) internal {\n', '    address addr = functionCalls[hash];\n', '    functionCalls[hash] = 0x0;\n', '    functionCalling[addr] = bytes32(0);\n', '  }\n', '  function authCancel(address from) external returns (uint8 status) {\n', '    if (!masterKeys[from] || !trustedClients[msg.sender]) {\n', '      Unauthorized(from);\n', '      return 0;\n', '    }\n', '    bytes32 call = functionCalling[from];\n', '    if (call == bytes32(0)) {\n', '      NothingToCancel(from);\n', '      return 1;\n', '    } else {\n', '      AuthCancel(from, from);\n', '      functionCalling[from] = bytes32(0);\n', '      functionCalls[call] = 0x0;\n', '      return 2;\n', '    }\n', '  }\n', '  function cancel() returns (uint8 code) {\n', '    if (!masterKeys[msg.sender]) {\n', '      Unauthorized(msg.sender);\n', '      return 0;\n', '    }\n', '    bytes32 call = functionCalling[msg.sender];\n', '    if (call == bytes32(0)) {\n', '      NothingToCancel(msg.sender);\n', '      return 1;\n', '    } else {\n', '      AuthCancel(msg.sender, msg.sender);\n', '      bytes32 hash = functionCalling[msg.sender];\n', '      functionCalling[msg.sender] = 0x0;\n', '      functionCalls[hash] = 0;\n', '      return 2;\n', '    }\n', '  }\n', '  function authCall(address from, bytes32 hash) external returns (uint8 code) {\n', '    if (!masterKeys[from] && !trustedClients[msg.sender]) {\n', '      Unauthorized(from);\n', '      return 0;\n', '    }\n', '    if (functionCalling[from] == 0) {\n', '      if (functionCalls[hash] == 0x0) {\n', '        functionCalls[hash] = from;\n', '        functionCalling[from] = hash;\n', '        AuthInit(from);\n', '        return 1;\n', '      } else { \n', '        AuthComplete(functionCalls[hash], from);\n', '        resetAction(hash);\n', '        return 2;\n', '      }\n', '    } else {\n', '      AuthPending(from);\n', '      return 3;\n', '    }\n', '  }\n', '  modifier multisig (bytes32 hash) {\n', '    if (!masterKeys[msg.sender]) {\n', '      Unauthorized(msg.sender);\n', '    } else if (functionCalling[msg.sender] == 0) {\n', '      if (functionCalls[hash] == 0x0) {\n', '        functionCalls[hash] = msg.sender;\n', '        functionCalling[msg.sender] = hash;\n', '        AuthInit(msg.sender);\n', '      } else { \n', '        AuthComplete(functionCalls[hash], msg.sender);\n', '        resetAction(hash);\n', '        _\n', '      }\n', '    } else {\n', '      AuthPending(msg.sender);\n', '    }\n', '  }\n', '  function voteOutMasterKey(address addr) multisig(sha3(msg.data)) {\n', '    assert(masterKeys[addr]);\n', '    masterKeys[addr] = false;\n', '  }\n', '  function voteInMasterKey(address addr) multisig(sha3(msg.data)) {\n', '    assert(!masterKeys[addr]);\n', '    activateMasterKey(addr);\n', '    masterKeys[addr] = true;\n', '  }\n', '  function identify(bytes32 name) onlyMasterKey {\n', '    nameRegistry[msg.sender] = name;\n', '    NameRegistered(msg.sender, name);\n', '  }\n', '  function nameFor(address addr) returns (bytes32 name) {\n', '    return nameRegistry[addr];\n', '  }\n', '}\n', '\n', '\n', 'contract TrustClient is StateTransferrable, TrustEvents {\n', '  address public trustAddress;\n', '  function setTrust(address addr) setter onlyOwnerUnlocked {\n', '    trustAddress = addr;\n', '  }\n', '  function nameFor(address addr) constant returns (bytes32 name) {\n', '    return Trust(trustAddress).nameFor(addr);\n', '  }\n', '  function cancel() returns (uint8 status) {\n', '    assert(trustAddress != address(0x0));\n', '    uint8 code = Trust(trustAddress).authCancel(msg.sender);\n', '    if (code == 0) Unauthorized(msg.sender);\n', '    else if (code == 1) NothingToCancel(msg.sender);\n', '    else if (code == 2) AuthCancel(msg.sender, msg.sender);\n', '    return code;\n', '  }\n', '  modifier multisig (bytes32 hash) {\n', '    assert(trustAddress != address(0x0));\n', '    address current = Trust(trustAddress).functionCalls(hash);\n', '    uint8 code = Trust(trustAddress).authCall(msg.sender, hash);\n', '    if (code == 0) Unauthorized(msg.sender);\n', '    else if (code == 1) AuthInit(msg.sender);\n', '    else if (code == 2) {\n', '      AuthComplete(current, msg.sender);\n', '      _\n', '    }\n', '    else if (code == 3) {\n', '      AuthPending(msg.sender);\n', '    }\n', '  }\n', '}\n', 'contract Relay {\n', '  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\n', '}\n', 'contract TokenBase is Owned {\n', "    bytes32 public standard = 'Token 0.1';\n", '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    bool public allowTransactions;\n', '\n', '    event Approval(address indexed from, address indexed spender, uint256 amount);\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    function () {\n', '        throw;\n', '    }\n', '}\n', '\n', 'contract Precision {\n', '  uint8 public decimals;\n', '}\n', 'contract Token is TokenBase, Precision {}\n', 'contract Util {\n', '  function pow10(uint256 a, uint8 b) internal returns (uint256 result) {\n', '    for (uint8 i = 0; i < b; i++) {\n', '      a *= 10;\n', '    }\n', '    return a;\n', '  }\n', '  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\n', '    for (uint8 i = 0; i < b; i++) {\n', '      a /= 10;\n', '    }\n', '    return a;\n', '  }\n', '  function max(uint256 a, uint256 b) internal returns (uint256 res) {\n', '    if (a >= b) return a;\n', '    return b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title DVIP Contract. DCAsset Membership Token contract.\n', ' *\n', ' * @author Ray Pulver, ray@decentralizedcapital.com\n', ' */\n', 'contract DVIP is Token, StateTransferrable, TrustClient, Util {\n', '\n', '  uint256 public totalSupply;\n', '\n', '  mapping (address => bool) public frozenAccount;\n', '\n', '  mapping (address => address[]) public allowanceIndex;\n', '  mapping (address => mapping (address => bool)) public allowanceActive;\n', '  address[] public accountIndex;\n', '  mapping (address => bool) public accountActive;\n', '  address public oversightAddress;\n', '  uint256 public expiry;\n', '\n', '  uint256 public treasuryBalance;\n', '\n', '  bool public isActive;\n', '  mapping (address => uint256) public exportFee;\n', '  address[] public exportFeeIndex;\n', '  mapping (address => bool) exportFeeActive;\n', '\n', '  mapping (address => uint256) public importFee;\n', '  address[] public importFeeIndex;\n', '  mapping (address => bool) importFeeActive;\n', '\n', '  event FrozenFunds(address target, bool frozen);\n', '  event PrecisionSet(address indexed from, uint8 precision);\n', '  event TransactionsShutDown(address indexed from);\n', '  event FeeSetup(address indexed from, address indexed target, uint256 amount);\n', '\n', '\n', '  /**\n', '   * Constructor.\n', '   *\n', '   */\n', '  function DVIP() {\n', '    isActive = true;\n', '    treasuryBalance = 0;\n', '    totalSupply = 0;\n', '    name = "DVIP";\n', '    symbol = "DVIP";\n', '    decimals = 6;\n', '    allowTransactions = true;\n', '    expiry = 1514764800; //1 jan 2018\n', '  }\n', '\n', '\n', '  /* ---------------  modifiers  --------------*/\n', '\n', '  /**\n', '   * Makes sure a method is only called by an overseer.\n', '   */\n', '  modifier onlyOverseer {\n', '    assert(msg.sender == oversightAddress);\n', '    _\n', '  }\n', '\n', '  /* ---------------  setter methods, only for the unlocked state --------------*/\n', '\n', '\n', '  /**\n', '   * Sets the oversight address (not the contract).\n', '   *\n', '   * @param addr The oversight contract address.\n', '   */\n', '  function setOversight(address addr) onlyOwnerUnlocked setter {\n', '    oversightAddress = addr;\n', '  }\n', '\n', '\n', '  /**\n', '   * Sets the total supply\n', '   *\n', '   * @param total Total supply of the asset.\n', '   */\n', '  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\n', '    totalSupply = total;\n', '  }\n', '\n', '  /**\n', '   * Set the Token Standard the contract applies to.\n', '   *\n', '   * @param std the Standard.\n', '   */\n', '  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\n', '    standard = std;\n', '  }\n', '\n', '  /**\n', '   * Sets the name of the contraxt\n', '   *\n', '   * @param _name the name.\n', '   */\n', '  function setName(bytes32 _name) onlyOwnerUnlocked setter {\n', '    name = _name;\n', '  }\n', '\n', '  /**\n', '   * Sets the symbol\n', '   *\n', '   * @param sym The Symbol\n', '   */\n', '  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\n', '    symbol = sym;\n', '  }\n', '\n', '  /**\n', '   * Sets the precision\n', '   *\n', '   * @param precision Amount of decimals\n', '   */\n', '  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\n', '    decimals = precision;\n', '    PrecisionSet(msg.sender, precision);\n', '  }\n', '\n', '  /**\n', '   * Sets the balance of a certain account.\n', '   *\n', '   * @param addr Address of the account\n', '   * @param amount Amount of assets to set on the account\n', '   */\n', '  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\n', '    balanceOf[addr] = amount;\n', '    activateAccount(addr);\n', '  }\n', '\n', '  /**\n', '   * Sets an allowance from a specific account to a specific account.\n', '   *\n', '   * @param from From-part of the allowance\n', '   * @param to To-part of the allowance\n', '   * @param amount Amount of the allowance\n', '   */\n', '  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\n', '    allowance[from][to] = amount;\n', '    activateAllowanceRecord(from, to);\n', '  }\n', '\n', '  /**\n', '   * Sets the treasure balance to a certain account.\n', '   *\n', '   * @param amount Amount of assets to pre-set in the treasury\n', '   */\n', '  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\n', '    treasuryBalance = amount;\n', '  }\n', '\n', '  /**\n', '   * Sets a certain account on frozen/unfrozen\n', '   *\n', '   * @param addr Account that will be frozen/unfrozen\n', '   * @param frozen Boolean to freeze or unfreeze\n', '   */\n', '  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\n', '    activateAccount(addr);\n', '    frozenAccount[addr] = frozen;\n', '  }\n', '\n', '  /**\n', '   * Sets up a import fee for a certain address.\n', '   *\n', '   * @param addr Address that will require fee\n', '   * @param fee Amount of fee\n', '   */\n', '  function setupImportFee(address addr, uint256 fee) onlyOwnerUnlocked {\n', '    importFee[addr] = fee;\n', '    activateImportFeeChargeRecord(addr);\n', '    FeeSetup(msg.sender, addr, fee);\n', '  }\n', ' \n', '  /**\n', '   * Sets up a export fee for a certain address.\n', '   *\n', '   * @param addr Address that will require fee\n', '   * @param fee Amount of fee\n', '   */\n', '  function setupExportFee(address addr, uint256 fee) onlyOwnerUnlocked {\n', '    exportFee[addr] = fee;\n', '    activateExportFeeChargeRecord(addr);\n', '    FeeSetup(msg.sender, addr, fee);\n', '  }\n', '\n', '  /* ---------------  main token methods  --------------*/\n', '\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `msg.sender.address()` to `_to`.\n', '   *\n', '   * @param _to Address that will receive.\n', '   * @param _amount Amount to be transferred.\n', '   */\n', '  function transfer(address _to, uint256 _amount) returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[msg.sender]);\n', '    assert(balanceOf[msg.sender] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    activateAccount(msg.sender);\n', '    activateAccount(_to);\n', '    balanceOf[msg.sender] -= _amount;\n', '    if (_to == address(this)) treasuryBalance += _amount;\n', '    else balanceOf[_to] += _amount;\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `_from` to `_to`.\n', '   *\n', '   * @param _from Origin address\n', '   * @param _to Address that will receive\n', '   * @param _amount Amount to be transferred.\n', '   * @return result of the method call\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[msg.sender]);\n', '    assert(!frozenAccount[_from]);\n', '    assert(balanceOf[_from] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    assert(_amount <= allowance[_from][msg.sender]);\n', '    balanceOf[_from] -= _amount;\n', '    balanceOf[_to] += _amount;\n', '    allowance[_from][msg.sender] -= _amount;\n', '    activateAccount(_from);\n', '    activateAccount(_to);\n', '    activateAccount(msg.sender);\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @param _extraData Consequential contract to be executed by spender in same transcation.\n', '   * @return result of the method call\n', '   */\n', '  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[msg.sender]);\n', '    allowance[msg.sender][_spender] = _amount;\n', '    activateAccount(msg.sender);\n', '    activateAccount(_spender);\n', '    activateAllowanceRecord(msg.sender, _spender);\n', '    TokenRecipient spender = TokenRecipient(_spender);\n', '    spender.receiveApproval(msg.sender, _amount, this, _extraData);\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @return result of the method call\n', '   */\n', '  function approve(address _spender, uint256 _amount) returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[msg.sender]);\n', '    allowance[msg.sender][_spender] = _amount;\n', '    activateAccount(msg.sender);\n', '    activateAccount(_spender);\n', '    activateAllowanceRecord(msg.sender, _spender);\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* ---------------  multisig admin methods  --------------*/\n', '\n', '\n', '\n', '  /**\n', '   * @notice Sets the expiry time in milliseconds since 1970.\n', '   *\n', '   * @param ts milliseconds since 1970.\n', '   *\n', '   */\n', '  function setExpiry(uint256 ts) multisig(sha3(msg.data)) {\n', '    expiry = ts;\n', '  }\n', '\n', '  /**\n', '   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.\n', '   *\n', '   * @param mintedAmount Amount of new tokens to be minted.\n', '   */\n', '  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\n', '    treasuryBalance += mintedAmount;\n', '    totalSupply += mintedAmount;\n', '  }\n', '\n', '  /**\n', '   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`\n', '   *\n', '   * @param destroyAmount Amount of new tokens to be minted.\n', '   */\n', '  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\n', '    assert(treasuryBalance >= destroyAmount);\n', '    treasuryBalance -= destroyAmount;\n', '    totalSupply -= destroyAmount;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers `amount` from the treasury to `to`\n', '   *\n', '   * @param to Address to transfer to\n', '   * @param amount Amount to transfer from treasury\n', '   */\n', '  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\n', '    assert(treasuryBalance >= amount);\n', '    treasuryBalance -= amount;\n', '    balanceOf[to] += amount;\n', '    activateAccount(to);\n', '  }\n', '\n', '  /* ---------------  fee setting administration methods  --------------*/\n', '\n', '  /**\n', '   * @notice Sets an import fee of `fee` on address `addr`\n', '   *\n', '   * @param addr Address for which the fee is valid\n', '   * @param addr fee Fee\n', '   *\n', '   */\n', '  function setImportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\n', '    uint256 max = 1;\n', '    max = pow10(1, decimals);\n', '    assert(fee <= max);\n', '    importFee[addr] = fee;\n', '    activateImportFeeChargeRecord(addr);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets an export fee of `fee` on address `addr`\n', '   *\n', '   * @param addr Address for which the fee is valid\n', '   * @param addr fee Fee\n', '   *\n', '   */\n', '  function setExportFee(address addr, uint256 fee) multisig(sha3(msg.data)) {\n', '    uint256 max = 1;\n', '    max = pow10(1, decimals);\n', '    assert(fee <= max);\n', '    exportFee[addr] = fee;\n', '    activateExportFeeChargeRecord(addr);\n', '  }\n', '\n', '\n', '  /* ---------------  multisig emergency methods --------------*/\n', '\n', '  /**\n', '   * @notice Sets allow transactions to `allow`\n', '   *\n', '   * @param allow Allow or disallow transactions\n', '   */\n', '  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\n', '    assert(allow != allowTransactions);\n', '    allowTransactions = allow;\n', '  }\n', '\n', '  /**\n', '   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`\n', '   *\n', '   * @param beneficiary Beneficiary of remaining Ether on contract\n', '   */\n', '  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\n', '    selfdestruct(beneficiary);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets frozen to `freeze` for account `target`\n', '   *\n', '   * @param addr Address to be frozen/unfrozen\n', '   * @param freeze Freeze/unfreeze account\n', '   */\n', '  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\n', '    frozenAccount[addr] = freeze;\n', '    activateAccount(addr);\n', '  }\n', '\n', '  /**\n', '   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet\n', '   *\n', '   * @param addr Adress to seize tokens from\n', '   * @param amount Amount of tokens to seize\n', '   */\n', '  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\n', '    assert(balanceOf[addr] >= amount);\n', '    assert(frozenAccount[addr]);\n', '    activateAccount(addr);\n', '    balanceOf[addr] -= amount;\n', '    treasuryBalance += amount;\n', '  }\n', '\n', '  /* --------------- fee calculation method ---------------- */\n', '\n', '\n', '  /**\n', "   * @notice 'Returns the fee for a transfer from `from` to `to` on an amount `amount`.\n", '   *\n', "   * Fee's consist of a possible\n", '   *    - import fee on transfers to an address\n', '   *    - export fee on transfers from an address\n', '   * DVIP ownership on an address\n', '   *    - reduces fee on a transfer from this address to an import fee-ed address\n', '   *    - reduces the fee on a transfer to this address from an export fee-ed address\n', '   * DVIP discount does not work for addresses that have an import fee or export fee set up against them.\n', '   *\n', '   * DVIP discount goes up to 100%\n', '   *\n', '   * @param from From address\n', '   * @param to To address\n', '   * @param amount Amount for which fee needs to be calculated.\n', '   *\n', '   */\n', '  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\n', '    uint256 fee = exportFee[from] + importFee[to];\n', '    if (fee == 0) return 0;\n', '    uint256 amountHeld;\n', '    bool discounted = true;\n', '    uint256 oneDVIPUnit;\n', '    if (exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry) {\n', '      amountHeld = balanceOf[from];\n', '    } else if (importFee[to] == 0 && balanceOf[to] != 0 && now < expiry) {\n', '      amountHeld = balanceOf[to];\n', '    } else discounted = false;\n', '    if (discounted) {\n', '      oneDVIPUnit = pow10(1, decimals);\n', '      if (amountHeld > oneDVIPUnit) amountHeld = oneDVIPUnit;\n', '      uint256 remaining = oneDVIPUnit - amountHeld;\n', '      return div10(amount*fee*remaining, decimals*2);\n', '    }\n', '    return div10(amount*fee, decimals);\n', '  }\n', '\n', '\n', '  /* ---------------  overseer methods for emergency --------------*/\n', '\n', '  /**\n', '   * @notice Shuts down all transaction and approval options on the asset contract\n', '   */\n', '  function shutdownTransactions() onlyOverseer {\n', '    allowTransactions = false;\n', '    TransactionsShutDown(msg.sender);\n', '  }\n', '\n', '  /* ---------------  helper methods for siphoning --------------*/\n', '\n', '  function extractAccountAllowanceRecordLength(address addr) constant returns (uint256 len) {\n', '    return allowanceIndex[addr].length;\n', '  }\n', '\n', '  function extractAccountLength() constant returns (uint256 length) {\n', '    return accountIndex.length;\n', '  }\n', '\n', '  /* ---------------  private methods --------------*/\n', '\n', '  function activateAccount(address addr) internal {\n', '    if (!accountActive[addr]) {\n', '      accountActive[addr] = true;\n', '      accountIndex.push(addr);\n', '    }\n', '  }\n', '\n', '  function activateAllowanceRecord(address from, address to) internal {\n', '    if (!allowanceActive[from][to]) {\n', '      allowanceActive[from][to] = true;\n', '      allowanceIndex[from].push(to);\n', '    }\n', '  }\n', '\n', '  function activateExportFeeChargeRecord(address addr) internal {\n', '    if (!exportFeeActive[addr]) {\n', '      exportFeeActive[addr] = true;\n', '      exportFeeIndex.push(addr);\n', '    }\n', '  }\n', '\n', '  function activateImportFeeChargeRecord(address addr) internal {\n', '    if (!importFeeActive[addr]) {\n', '      importFeeActive[addr] = true;\n', '      importFeeIndex.push(addr);\n', '    }\n', '  }\n', '  function extractImportFeeChargeLength() returns (uint256 length) {\n', '    return importFeeIndex.length;\n', '  }\n', '\n', '  function extractExportFeeChargeLength() returns (uint256 length) {\n', '    return exportFeeIndex.length;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title DCAssetBackend Contract\n', ' *\n', ' * @author Ray Pulver, ray@decentralizedcapital.com\n', ' */\n', 'contract DCAssetBackend is Owned, Precision, StateTransferrable, TrustClient, Util {\n', '\n', "  bytes32 public standard = 'Token 0.1';\n", '  bytes32 public name;\n', '  bytes32 public symbol;\n', '\n', '  bool public allowTransactions;\n', '\n', '  event Approval(address indexed from, address indexed spender, uint256 amount);\n', '\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  uint256 public totalSupply;\n', '\n', '  address public hotWalletAddress;\n', '  address public assetAddress;\n', '  address public oversightAddress;\n', '  address public membershipAddress;\n', '\n', '  mapping (address => bool) public frozenAccount;\n', '\n', '  mapping (address => address[]) public allowanceIndex;\n', '  mapping (address => mapping (address => bool)) public allowanceActive;\n', '  address[] public accountIndex;\n', '  mapping (address => bool) public accountActive;\n', '\n', '  bool public isActive;\n', '  uint256 public treasuryBalance;\n', '\n', '  mapping (address => uint256) public feeCharge;\n', '  address[] public feeChargeIndex;\n', '  mapping (address => bool) feeActive;\n', '\n', '  event FrozenFunds(address target, bool frozen);\n', '  event PrecisionSet(address indexed from, uint8 precision);\n', '  event TransactionsShutDown(address indexed from);\n', '  event FeeSetup(address indexed from, address indexed target, uint256 amount);\n', '\n', '\n', '  /**\n', '   * Constructor.\n', '   *\n', '   * @param tokenName Name of the Token\n', '   * @param tokenSymbol The Token Symbol\n', '   */\n', '  function DCAssetBackend(bytes32 tokenSymbol, bytes32 tokenName) {\n', '    isActive = true;\n', '    name = tokenName;\n', '    symbol = tokenSymbol;\n', '    decimals = 6;\n', '    allowTransactions = true;\n', '  }\n', '\n', '  /* ---------------  modifiers  --------------*/\n', '\n', '  /**\n', '   * Makes sure a method is only called by an overseer.\n', '   */\n', '  modifier onlyOverseer {\n', '    assert(msg.sender == oversightAddress);\n', '    _\n', '  }\n', '\n', '  /**\n', '   * Make sure only the front end Asset can call the transfer methods\n', '   */\n', '   modifier onlyAsset {\n', '    assert(msg.sender == assetAddress);\n', '    _\n', '   }\n', '\n', '  /* ---------------  setter methods, only for the unlocked state --------------*/\n', '\n', '\n', '  /**\n', '   * Sets the hot wallet contract address\n', '   *\n', '   * @param addr Address of the Hotwallet\n', '   */\n', '  function setHotWallet(address addr) onlyOwnerUnlocked setter {\n', '    hotWalletAddress = addr;\n', '  }\n', '\n', '  /**\n', '    * Sets the token facade contract address\n', '    *\n', '    * @param addr Address of the front-end Asset\n', '    */\n', '  function setAsset(address addr) onlyOwnerUnlocked setter {\n', '    assetAddress = addr;\n', '  }\n', '\n', '  /**\n', '   * Sets the membership contract address\n', '   *\n', '   * @param addr Address of the membership contract\n', '   */\n', '  function setMembership(address addr) onlyOwnerUnlocked setter {\n', '    membershipAddress = addr;\n', '  }\n', '\n', '  /**\n', '   * Sets the oversight address (not the contract).\n', '   *\n', '   * @param addr The oversight contract address.\n', '   */\n', '  function setOversight(address addr) onlyOwnerUnlocked setter {\n', '    oversightAddress = addr;\n', '  }\n', '\n', '  /**\n', '   * Sets the total supply\n', '   *\n', '   * @param total Total supply of the asset.\n', '   */\n', '  function setTotalSupply(uint256 total) onlyOwnerUnlocked setter {\n', '    totalSupply = total;\n', '  }\n', '\n', '  /**\n', '   * Set the Token Standard the contract applies to.\n', '   *\n', '   * @param std the Standard.\n', '   */\n', '  function setStandard(bytes32 std) onlyOwnerUnlocked setter {\n', '    standard = std;\n', '  }\n', '\n', '  /**\n', '   * Sets the name of the contraxt\n', '   *\n', '   * @param _name the name.\n', '   */\n', '  function setName(bytes32 _name) onlyOwnerUnlocked setter {\n', '    name = _name;\n', '  }\n', '\n', '  /**\n', '   * Sets the symbol\n', '   *\n', '   * @param sym The Symbol\n', '   */\n', '  function setSymbol(bytes32 sym) onlyOwnerUnlocked setter {\n', '    symbol = sym;\n', '  }\n', '\n', '  /**\n', '   * Sets the precision\n', '   *\n', '   * @param precision Amount of decimals\n', '   */\n', '  function setPrecisionDirect(uint8 precision) onlyOwnerUnlocked {\n', '    decimals = precision;\n', '    PrecisionSet(msg.sender, precision);\n', '  }\n', '\n', '  /**\n', '   * Sets the balance of a certain account.\n', '   *\n', '   * @param addr Address of the account\n', '   * @param amount Amount of assets to set on the account\n', '   */\n', '  function setAccountBalance(address addr, uint256 amount) onlyOwnerUnlocked {\n', '    balanceOf[addr] = amount;\n', '    activateAccount(addr);\n', '  }\n', '\n', '  /**\n', '   * Sets an allowance from a specific account to a specific account.\n', '   *\n', '   * @param from From-part of the allowance\n', '   * @param to To-part of the allowance\n', '   * @param amount Amount of the allowance\n', '   */\n', '  function setAccountAllowance(address from, address to, uint256 amount) onlyOwnerUnlocked {\n', '    allowance[from][to] = amount;\n', '    activateAllowanceRecord(from, to);\n', '  }\n', '\n', '  /**\n', '   * Sets the treasure balance to a certain account.\n', '   *\n', '   * @param amount Amount of assets to pre-set in the treasury\n', '   */\n', '  function setTreasuryBalance(uint256 amount) onlyOwnerUnlocked {\n', '    treasuryBalance = amount;\n', '  }\n', '\n', '  /**\n', '   * Sets a certain account on frozen/unfrozen\n', '   *\n', '   * @param addr Account that will be frozen/unfrozen\n', '   * @param frozen Boolean to freeze or unfreeze\n', '   */\n', '  function setAccountFrozenStatus(address addr, bool frozen) onlyOwnerUnlocked {\n', '    activateAccount(addr);\n', '    frozenAccount[addr] = frozen;\n', '  }\n', '\n', '  /* ---------------  main token methods  --------------*/\n', '\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `_caller` to `_to`.\n', '   *\n', '   * @param _caller Origin address\n', '   * @param _to Address that will receive.\n', '   * @param _amount Amount to be transferred.\n', '   */\n', '  function transfer(address _caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[_caller]);\n', '    assert(balanceOf[_caller] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    activateAccount(_caller);\n', '    activateAccount(_to);\n', '    balanceOf[_caller] -= _amount;\n', '    if (_to == address(this)) treasuryBalance += _amount;\n', '    else {\n', '        uint256 fee = feeFor(_caller, _to, _amount);\n', '        balanceOf[_to] += _amount - fee;\n', '        treasuryBalance += fee;\n', '    }\n', '    Transfer(_caller, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `_from` to `_to`, invoked by `_caller`.\n', '   *\n', '   * @param _caller Invoker of the call (owner of the allowance)\n', '   * @param _from Origin address\n', '   * @param _to Address that will receive\n', '   * @param _amount Amount to be transferred.\n', '   * @return result of the method call\n', '   */\n', '  function transferFrom(address _caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[_caller]);\n', '    assert(!frozenAccount[_from]);\n', '    assert(balanceOf[_from] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    assert(_amount <= allowance[_from][_caller]);\n', '    balanceOf[_from] -= _amount;\n', '    uint256 fee = feeFor(_from, _to, _amount);\n', '    balanceOf[_to] += _amount - fee;\n', '    treasuryBalance += fee;\n', '    allowance[_from][_caller] -= _amount;\n', '    activateAccount(_from);\n', '    activateAccount(_to);\n', '    activateAccount(_caller);\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`\n', '   *\n', '   * @param _caller Address that grants the allowance\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @param _extraData Consequential contract to be executed by spender in same transcation.\n', '   * @return result of the method call\n', '   */\n', '  function approveAndCall(address _caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[_caller]);\n', '    allowance[_caller][_spender] = _amount;\n', '    activateAccount(_caller);\n', '    activateAccount(_spender);\n', '    activateAllowanceRecord(_caller, _spender);\n', '    TokenRecipient spender = TokenRecipient(_spender);\n', '    assert(Relay(assetAddress).relayReceiveApproval(_caller, _spender, _amount, _extraData));\n', '    Approval(_caller, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve Approves spender `_spender` to transfer `_amount` from `_caller`\n', '   *\n', '   * @param _caller Address that grants the allowance\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @return result of the method call\n', '   */\n', '  function approve(address _caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(!frozenAccount[_caller]);\n', '    allowance[_caller][_spender] = _amount;\n', '    activateAccount(_caller);\n', '    activateAccount(_spender);\n', '    activateAllowanceRecord(_caller, _spender);\n', '    Approval(_caller, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* ---------------  multisig admin methods  --------------*/\n', '\n', '\n', '  /**\n', '   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.\n', '   *\n', '   * @param mintedAmount Amount of new tokens to be minted.\n', '   */\n', '  function mint(uint256 mintedAmount) multisig(sha3(msg.data)) {\n', '    activateAccount(hotWalletAddress);\n', '    balanceOf[hotWalletAddress] += mintedAmount;\n', '    totalSupply += mintedAmount;\n', '  }\n', '\n', '  /**\n', '   * @notice Destroys `destroyAmount` new tokens from the hotwallet `hotWalletAddress`\n', '   *\n', '   * @param destroyAmount Amount of new tokens to be minted.\n', '   */\n', '  function destroyTokens(uint256 destroyAmount) multisig(sha3(msg.data)) {\n', '    assert(balanceOf[hotWalletAddress] >= destroyAmount);\n', '    activateAccount(hotWalletAddress);\n', '    balanceOf[hotWalletAddress] -= destroyAmount;\n', '    totalSupply -= destroyAmount;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers `amount` from the treasury to `to`\n', '   *\n', '   * @param to Address to transfer to\n', '   * @param amount Amount to transfer from treasury\n', '   */\n', '  function transferFromTreasury(address to, uint256 amount) multisig(sha3(msg.data)) {\n', '    assert(treasuryBalance >= amount);\n', '    treasuryBalance -= amount;\n', '    balanceOf[to] += amount;\n', '    activateAccount(to);\n', '  }\n', '\n', '  /* ---------------  multisig emergency methods --------------*/\n', '\n', '  /**\n', '   * @notice Sets allow transactions to `allow`\n', '   *\n', '   * @param allow Allow or disallow transactions\n', '   */\n', '  function voteAllowTransactions(bool allow) multisig(sha3(msg.data)) {\n', '    if (allow == allowTransactions) throw;\n', '    allowTransactions = allow;\n', '  }\n', '\n', '  /**\n', '   * @notice Destructs the contract and sends remaining `this.balance` Ether to `beneficiary`\n', '   *\n', '   * @param beneficiary Beneficiary of remaining Ether on contract\n', '   */\n', '  function voteSuicide(address beneficiary) multisig(sha3(msg.data)) {\n', '    selfdestruct(beneficiary);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets frozen to `freeze` for account `target`\n', '   *\n', '   * @param addr Address to be frozen/unfrozen\n', '   * @param freeze Freeze/unfreeze account\n', '   */\n', '  function freezeAccount(address addr, bool freeze) multisig(sha3(msg.data)) {\n', '    frozenAccount[addr] = freeze;\n', '    activateAccount(addr);\n', '  }\n', '\n', '  /**\n', '   * @notice Seizes `seizeAmount` of tokens from `address` and transfers it to hotwallet\n', '   *\n', '   * @param addr Adress to seize tokens from\n', '   * @param amount Amount of tokens to seize\n', '   */\n', '  function seizeTokens(address addr, uint256 amount) multisig(sha3(msg.data)) {\n', '    assert(balanceOf[addr] >= amount);\n', '    assert(frozenAccount[addr]);\n', '    activateAccount(addr);\n', '    balanceOf[addr] -= amount;\n', '    balanceOf[hotWalletAddress] += amount;\n', '  }\n', '\n', '  /* ---------------  overseer methods for emergency --------------*/\n', '\n', '  /**\n', '   * @notice Shuts down all transaction and approval options on the asset contract\n', '   */\n', '  function shutdownTransactions() onlyOverseer {\n', '    allowTransactions = false;\n', '    TransactionsShutDown(msg.sender);\n', '  }\n', '\n', '  /* ---------------  helper methods for siphoning --------------*/\n', '\n', '  function extractAccountAllowanceRecordLength(address addr) returns (uint256 len) {\n', '    return allowanceIndex[addr].length;\n', '  }\n', '\n', '  function extractAccountLength() returns (uint256 length) {\n', '    return accountIndex.length;\n', '  }\n', '\n', '\n', '  /* ---------------  private methods --------------*/\n', '\n', '  function activateAccount(address addr) internal {\n', '    if (!accountActive[addr]) {\n', '      accountActive[addr] = true;\n', '      accountIndex.push(addr);\n', '    }\n', '  }\n', '\n', '  function activateAllowanceRecord(address from, address to) internal {\n', '    if (!allowanceActive[from][to]) {\n', '      allowanceActive[from][to] = true;\n', '      allowanceIndex[from].push(to);\n', '    }\n', '  }\n', '  function feeFor(address a, address b, uint256 amount) returns (uint256 value) {\n', '    if (membershipAddress == address(0x0)) return 0;\n', '    return DVIP(membershipAddress).feeFor(a, b, amount);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DCAssetFacade, Facade for the underlying back-end dcasset token contract. Allow to be updated later.\n', ' *\n', ' * @author P.S.D. Reitsma, peter@decentralizedcapital.com\n', ' *\n', ' */\n', 'contract DCAsset is TokenBase, StateTransferrable, TrustClient, Relay {\n', '\n', '   address public backendContract;\n', '\n', '   /**\n', '    * Constructor\n', '    *\n', '    *\n', '    */\n', '   function DCAsset(address _backendContract) {\n', '     backendContract = _backendContract;\n', '   }\n', '\n', '   function standard() constant returns (bytes32 std) {\n', '     return DCAssetBackend(backendContract).standard();\n', '   }\n', '\n', '   function name() constant returns (bytes32 nm) {\n', '     return DCAssetBackend(backendContract).name();\n', '   }\n', '\n', '   function symbol() constant returns (bytes32 sym) {\n', '     return DCAssetBackend(backendContract).symbol();\n', '   }\n', '\n', '   function decimals() constant returns (uint8 precision) {\n', '     return DCAssetBackend(backendContract).decimals();\n', '   }\n', '  \n', '   function allowance(address from, address to) constant returns (uint256 res) {\n', '     return DCAssetBackend(backendContract).allowance(from, to);\n', '   }\n', '\n', '\n', '   /* ---------------  multisig admin methods  --------------*/\n', '\n', '\n', '   /**\n', '    * @notice Sets the backend contract to `_backendContract`. Can only be switched by multisig.\n', '    *\n', '    * @param _backendContract Address of the underlying token contract.\n', '    */\n', '   function setBackend(address _backendContract) multisig(sha3(msg.data)) {\n', '     backendContract = _backendContract;\n', '   }\n', '\n', '   /* ---------------  main token methods  --------------*/\n', '\n', '   /**\n', '    * @notice Returns the balance of `_address`.\n', '    *\n', '    * @param _address The address of the balance.\n', '    */\n', '   function balanceOf(address _address) constant returns (uint256 balance) {\n', '      return DCAssetBackend(backendContract).balanceOf(_address);\n', '   }\n', '\n', '   /**\n', '    * @notice Returns the total supply of the token\n', '    *\n', '    */\n', '   function totalSupply() constant returns (uint256 balance) {\n', '      return DCAssetBackend(backendContract).totalSupply();\n', '   }\n', '\n', '  /**\n', '   * @notice Transfer `_amount` to `_to`.\n', '   *\n', '   * @param _to Address that will receive.\n', '   * @param _amount Amount to be transferred.\n', '   */\n', '   function transfer(address _to, uint256 _amount) returns (bool success)  {\n', '      if (!DCAssetBackend(backendContract).transfer(msg.sender, _to, _amount)) throw;\n', '      Transfer(msg.sender, _to, _amount);\n', '      return true;\n', '   }\n', '\n', '  /**\n', '   * @notice Approve Approves spender `_spender` to transfer `_amount`.\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @param _extraData Consequential contract to be executed by spender in same transcation.\n', '   * @return result of the method call\n', '   */\n', '   function approveAndCall(address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\n', '      if (!DCAssetBackend(backendContract).approveAndCall(msg.sender, _spender, _amount, _extraData)) throw;\n', '      Approval(msg.sender, _spender, _amount);\n', '      return true;\n', '   }\n', '\n', '  /**\n', '   * @notice Approve Approves spender `_spender` to transfer `_amount`.\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @return result of the method call\n', '   */\n', '   function approve(address _spender, uint256 _amount) returns (bool success) {\n', '      if (!DCAssetBackend(backendContract).approve(msg.sender, _spender, _amount)) throw;\n', '      Approval(msg.sender, _spender, _amount);\n', '      return true;\n', '   }\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `_from` to `_to`.\n', '   *\n', '   * @param _from Origin address\n', '   * @param _to Address that will receive\n', '   * @param _amount Amount to be transferred.\n', '   * @return result of the method call\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '      if (!DCAssetBackend(backendContract).transferFrom(msg.sender, _from, _to, _amount)) throw;\n', '      Transfer(_from, _to, _amount);\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns fee for transferral of `_amount` from `_from` to `_to`.\n', '   *\n', '   * @param _from Origin address\n', '   * @param _to Address that will receive\n', '   * @param _amount Amount to be transferred.\n', '   * @return height of the fee\n', '   */\n', '  function feeFor(address _from, address _to, uint256 _amount) returns (uint256 amount) {\n', '      return DCAssetBackend(backendContract).feeFor(_from, _to, _amount);\n', '  }\n', '\n', '  /* ---------------  to be called by backend  --------------*/\n', '\n', '  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success) {\n', '     assert(msg.sender == backendContract);\n', '     TokenRecipient spender = TokenRecipient(_spender);\n', '     spender.receiveApproval(_caller, _amount, this, _extraData);\n', '     return true;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title Oversight Contract that is hooked into HotWallet to provide extra security.\n', ' *\n', ' * @author Ray Pulver, ray@decentralizedcapital.com\n', ' */\n', 'contract Oversight is StateTransferrable, TrustClient {\n', '\n', '  address public hotWalletAddress;\n', '\n', '  mapping (address => uint256) public approved;             //map of approved amounts per currency\n', '  address[] public approvedIndex;                           //array of approved currencies\n', '\n', '  mapping (address => uint256) public expiry;               //map of expiry times per currency\n', '\n', '  mapping (address => bool) public currencyActive;          //map of active/inactive currencies\n', '\n', '  mapping (address => bool) public oversightAddresses;      //map of active/inactive oversight addresses\n', '  address[] public oversightAddressesIndex;                 //array of oversight addresses\n', '\n', '  mapping (address => bool) public oversightAddressActive;  //map of active oversight addresses (for siphoning/uploading)\n', '\n', '  uint256 public timeWindow;                                //expiry time for an approval\n', '\n', '  event TransactionsShutDown(address indexed from);\n', '\n', '  /**\n', '   * Constructor. Sets expiry to 10 minutes.\n', '   */\n', '  function Oversight() {\n', '    timeWindow = 10 minutes;\n', '  }\n', '\n', '  /* ---------------  modifiers  --------------*/\n', '\n', '  /**\n', '   * Makes sure a method is only called by an overseer.\n', '   */\n', '  modifier onlyOverseer {\n', '    assert(oversightAddresses[msg.sender]);\n', '    _\n', '  }\n', '\n', '  /**\n', '   * Makes sure a method is only called from the HotWallet.\n', '   */\n', '  modifier onlyHotWallet {\n', '    assert(msg.sender == hotWalletAddress);\n', '    _\n', '  }\n', '\n', '  /* ---------------  setter methods, only for the unlocked state --------------*/\n', '\n', '  /**\n', '   * Sets the HotWallet address.\n', '   *\n', '   * @param addr Address of the hotwallet.\n', '   */\n', '  function setHotWallet(address addr) onlyOwnerUnlocked setter {\n', '      hotWalletAddress = addr;\n', '  }\n', '\n', '  /**\n', '   * Sets the approval expiry window, called before the contract is locked.\n', '   *\n', '   * @param secs Expiry time in seconds.\n', '   */\n', '  function setupTimeWindow(uint256 secs) onlyOwnerUnlocked setter {\n', '    timeWindow = secs;\n', '  }\n', '\n', '  /**\n', '   * Approves an amount for a certain currency, called before the contract is locked.\n', '   *\n', '   * @param addr Currency.\n', '   * @param amount The amount to approve.\n', '   */\n', '  function setApproved(address addr, uint256 amount) onlyOwnerUnlocked setter {\n', '    activateCurrency(addr);\n', '    approved[addr] = amount;\n', '  }\n', '\n', '  /**\n', '   * Sets the expiry window for a certain currency, called before the contracted is locked.\n', '   *\n', '   * @param addr Currency.\n', '   * @param ts Window in seconds\n', '   */\n', '  function setExpiry(address addr, uint256 ts) onlyOwnerUnlocked setter {\n', '    activateCurrency(addr);\n', '    expiry[addr] = ts;\n', '  }\n', '\n', '  /**\n', '   * Sets an oversight address, on active or inactive, called before the contract is locked.\n', '   *\n', '   * @param addr The oversight address.\n', '   * @param value Whether to activate or deactivate the address.\n', '   */\n', '  function setOversightAddress(address addr, bool value) onlyOwnerUnlocked setter {\n', '    activateOversightAddress(addr);\n', '    oversightAddresses[addr] = value;\n', '  }\n', '\n', '\n', '\n', '  /* ---------------  multisig admin methods  --------------*/\n', '\n', '  /**\n', '   * @notice Sets the approval expiry window to `secs`.\n', '   *\n', '   * @param secs Expiry time in seconds.\n', '   */\n', '  function setTimeWindow(uint256 secs) external multisig(sha3(msg.data)) {\n', '    timeWindow = secs;\n', '  }\n', '\n', '  /**\n', '   * @notice Adds and activates new oversight address `addr`.\n', '   *\n', '   * @param addr The oversight addresss.\n', '   */\n', '  function addOversight(address addr) external multisig(sha3(msg.data)) {\n', '    activateOversightAddress(addr);\n', '    oversightAddresses[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Removes/deactivates oversight address `addr`.\n', '   *\n', '   * @param addr The oversight address to be removed.\n', '   */\n', '  function removeOversight(address addr) external multisig(sha3(msg.data)) {\n', '    oversightAddresses[addr] = false;\n', '  }\n', '\n', '  /* ---------------  multisig main methods  --------------*/\n', '\n', '  /**\n', '   * @notice Approve `amount` of asset `currency` to be withdrawn.\n', '   *\n', '   * @param currency Address of the currency/asset to approve a certain amount for.\n', '   * @param amount The amount to approve.\n', '   */\n', '  function approve(address currency, uint256 amount) external multisig(sha3(msg.data)) {\n', '    activateCurrency(currency);\n', '    approved[currency] = amount;\n', '    expiry[currency] = now + timeWindow;\n', '  }\n', '\n', '  /* ---------------  method for hotwallet  --------------*/\n', '\n', '  /**\n', '   * @notice Validate that `amount` is allowed to be transacted for `currency`.\n', '   * Called by the HotWallet to validate a transaction.\n', '   *\n', '   * @param currency Address of the currency/asset for which is validated.\n', '   * @param amount The amount that is validated.\n', '   */\n', '  function validate(address currency, uint256 amount) external onlyHotWallet returns (bool) {\n', '    assert(approved[currency] >= amount);\n', '    approved[currency] -= amount;\n', '    return true;\n', '  }\n', '\n', '  /* ---------------  Overseer methods for emergency --------------*/\n', '\n', '  /**\n', '   * @notice Shutdown transactions on asset `currency`\n', '   *\n', '   * @param currency Address of the currency/asset contract to be shut down.\n', '   */\n', '  function shutdownTransactions(address currency) onlyOverseer {\n', '    address backend = DCAsset(currency).backendContract();\n', '    DCAssetBackend(backend).shutdownTransactions();\n', '    TransactionsShutDown(msg.sender);\n', '  }\n', '\n', '  /* ---------------  Helper methods for siphoning --------------*/\n', '\n', '  /**\n', '   * Returns the amount of approvals.\n', '   */\n', '  function extractApprovedIndexLength() returns (uint256) {\n', '    return approvedIndex.length;\n', '  }\n', '\n', '  /**\n', '   * Returns the amount of oversight addresses.\n', '   */\n', '  function extractOversightAddressesIndexLength() returns (uint256) {\n', '    return oversightAddressesIndex.length;\n', '  }\n', '\n', '  /* ---------------  private methods --------------*/\n', '\n', '  function activateOversightAddress(address addr) internal {\n', '    if (!oversightAddressActive[addr]) {\n', '      oversightAddressActive[addr] = true;\n', '      oversightAddressesIndex.push(addr);\n', '    }\n', '  }\n', '\n', '  function activateCurrency(address addr) internal {\n', '    if (!currencyActive[addr]) {\n', '      currencyActive[addr] = true;\n', '          approvedIndex.push(addr);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title HotWallet contract into which all freshly minted assets end-up. Controlled by Oversight Contract\n', ' *\n', ' * @author Ray Pulver, ray@decentralizedcapital.com\n', ' */\n', 'contract HotWallet is StateTransferrable, TrustClient {\n', '\n', '  address public oversightAddress;\n', '\n', '  mapping (address => uint256) public invoiced;\n', '  address[] public invoicedIndex;\n', '  mapping (address => bool) public invoicedActive;\n', '\n', '  event HotWalletDeposit(address indexed from, uint256 amount);\n', '  event PerformedTransfer(address indexed to, uint256 amount);\n', '  event PerformedTransferFrom(address indexed from, address indexed to, uint256 amount);\n', '  event PerformedApprove(address indexed spender, uint256 amount);\n', '  /* ---------------  modifiers  --------------*/\n', '\n', '  /**\n', '   * Makes sure the Oversight Contract is set\n', '   */\n', '  modifier onlyWithOversight {\n', '    assert(oversightAddress != 0x0);\n', '    _\n', '  }\n', '\n', '  /**\n', '   * Check if the amount of for a certain asset/currency has been approved in the Oversight address\n', '   */\n', '  modifier spendControl(address currency, uint256 amount) {\n', '    assert(Oversight(oversightAddress).validate(currency, amount));\n', '    _\n', '  }\n', '\n', '  /**\n', '   * Check if the amount of for a certain asset/currency has been approved in the Oversight address\n', '   * and that the transfer is not to the HotWallet itself\n', '   */\n', '  modifier spendControlTargeted (address currency, address to, uint256 amount) {\n', '    if (to != address(this)) {\n', '      assert(Oversight(oversightAddress).validate(currency, amount));\n', '    }\n', '    _\n', '  }\n', '\n', '  /* ---------------  setter methods, only for the unlocked state --------------*/\n', '\n', '  /**\n', '   * Sets the Oversight contract address.\n', '   *\n', '   * @param addr Address of the Oversight contract.\n', '   */\n', '  function setOversight(address addr) onlyOwnerUnlocked setter {\n', '    oversightAddress = addr;\n', '  }\n', '\n', '  /* --------------- main methods  --------------*/\n', '\n', '  /**\n', '   * @notice Transfer `amount` of asset `currency` from the hotwallet to `to`.\n', '   *\n', '   * @param currency Address of the currency/asset.\n', '   * @param to Destination address of the transfer.\n', '   * @param amount The amount to be transferred.\n', '   */\n', '  function transfer(address currency, address to, uint256 amount) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\n', '    Token(currency).transfer(to, amount);\n', '    PerformedTransfer(to, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `amount` of asset `currency` from `from` to `to`.\n', '   *\n', '   * @param currency Address of the currency/asset.\n', '   * @param from Origin address.\n', '   * @param to Destination address of the transfer.\n', '   * @param amount The amount to be transferred\n', '   */\n', '  function transferFrom(address currency, address from, address to, uint256 amount) multisig(sha3(msg.data)) spendControlTargeted(currency, to, amount) onlyWithOversight {\n', '    Token(currency).transferFrom(from, to, amount);\n', '    PerformedTransferFrom(from, to, amount);\n', '  }\n', '\n', '  /**\n', '    * @notice Approve `spender` to transfer `amount` of asset `currency` from the Hotwallet and make a consequential call.\n', '    *\n', '    * @param currency Address of the currency/asset.\n', '    * @param spender Address that receives the cheque/approval to spend\n', '    * @param amount The amount that is approved\n', '    */\n', '  function approve(address currency, address spender, uint256 amount) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\n', '    Token(currency).approve(spender, amount);\n', '    PerformedApprove(spender, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Approve `spender` to transfer `amount` of asset `currency` from the Hotwallet and make a consequential call.\n', '   *\n', '   * @param currency Address of the currency/asset.\n', '   * @param spender Address that receives the cheque/approval to spend\n', '   * @param amount The amount that is approved\n', '   * @param extraData consequential call that is made\n', '   */\n', '  function approveAndCall(address currency, address spender, uint256 amount, bytes extraData) multisig(sha3(msg.data)) spendControl(currency, amount) onlyWithOversight {\n', '    Token(currency).approveAndCall(spender, amount, extraData);\n', '    PerformedApprove(spender, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Receives approval to drain the invoice.\n', '   *\n', '   * @param from Address from which the transfer can be made.\n', '   * @param amount The amount that is approved.\n', '   * @param currency Address of the currency\n', '   * @param extraData consequential call that can be made\n', '   */\n', '  function receiveApproval(address from, uint256 amount, address currency, bytes extraData) external {\n', '    Token(currency).transferFrom(from, this, amount);\n', '    HotWalletDeposit(from, amount);\n', '  }\n', '\n', '  /* --------------- methods for siphoning, uploading  --------------*/\n', '\n', '  function activateInvoiced(address addr) internal {\n', '    if (!invoicedActive[addr]) {\n', '      invoicedActive[addr] = true;\n', '      invoicedIndex.push(addr);\n', '    }\n', '  }\n', '\n', '  function extractInvoicedLength() external returns (uint256 len) {\n', '    return invoicedIndex.length;\n', '  }\n', '}']