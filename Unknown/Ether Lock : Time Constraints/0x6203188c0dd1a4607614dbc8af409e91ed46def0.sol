['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract BMICOAffiliateProgramm {\n', '    struct itemReferrals {\n', '        uint256 amount_investments;\n', '        uint256 preico_holdersBonus;\n', '    }\n', '    mapping (address => itemReferrals) referralsInfo;\n', '    uint256 public preico_holdersAmountInvestWithBonus = 0;\n', '\n', '    mapping (string => address) partnersPromo;\n', '    struct itemPartners {\n', '        uint256 attracted_investments;\n', '        string promo;\n', '        uint16 personal_percent;\n', '        uint256 preico_partnerBonus;\n', '        bool create;\n', '    }\n', '    mapping (address => itemPartners) partnersInfo;\n', '\n', '    uint16 public ref_percent = 100; //1 = 0.01%, 10000 = 100%\n', '\n', '    struct itemHistory {\n', '        uint256 datetime;\n', '        address referral;\n', '        uint256 amount_invest;\n', '    }\n', '    mapping(address => itemHistory[]) history;\n', '\n', '    uint256 public amount_referral_invest;\n', '\n', '    address public owner;\n', '    address public contractPreICO;\n', '    address public contractICO;\n', '\n', '    function BMICOAffiliateProgramm(){\n', '        owner = msg.sender;\n', '        contractPreICO = address(0x0);\n', '        contractICO = address(0x0);\n', '    }\n', '\n', '    modifier isOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function str_length(string x) constant internal returns (uint256) {\n', '        bytes32 str;\n', '        assembly {\n', '        str := mload(add(x, 32))\n', '        }\n', '        bytes memory bytesString = new bytes(32);\n', '        uint256 charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(str) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        return charCount;\n', '    }\n', '\n', '    function changeOwner(address new_owner) isOwner {\n', '        assert(new_owner!=address(0x0));\n', '        assert(new_owner!=address(this));\n', '\n', '        owner = new_owner;\n', '    }\n', '\n', '    function setReferralPercent(uint16 new_percent) isOwner {\n', '        ref_percent = new_percent;\n', '    }\n', '\n', '    function setPartnerPercent(address partner, uint16 new_percent) isOwner {\n', '        assert(partner!=address(0x0));\n', '        assert(partner!=address(this));\n', '        assert(partnersInfo[partner].create==true);\n', '        partnersInfo[partner].personal_percent = new_percent;\n', '    }\n', '\n', '    function setContractPreICO(address new_address) isOwner {\n', '        assert(contractPreICO==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '\n', '        contractPreICO = new_address;\n', '    }\n', '\n', '    function setContractICO(address new_address) isOwner {\n', '        assert(contractICO==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '\n', '        contractICO = new_address;\n', '    }\n', '\n', '    function setPromoToPartner(string promo) {\n', '        assert(partnersPromo[promo]==address(0x0));\n', '        assert(partnersInfo[msg.sender].create==false);\n', '        assert(str_length(promo)>0 && str_length(promo)<=6);\n', '\n', '        partnersPromo[promo] = msg.sender;\n', '        partnersInfo[msg.sender].attracted_investments = 0;\n', '        partnersInfo[msg.sender].promo = promo;\n', '        partnersInfo[msg.sender].create = true;\n', '    }\n', '\n', '    function checkPromo(string promo) constant returns(bool){\n', '        return partnersPromo[promo]!=address(0x0);\n', '    }\n', '\n', '    function checkPartner(address partner_address) constant returns(bool isPartner, string promo){\n', '        isPartner = partnersInfo[partner_address].create;\n', '        promo = &#39;-1&#39;;\n', '        if(isPartner){\n', '            promo = partnersInfo[partner_address].promo;\n', '        }\n', '    }\n', '\n', '    function calc_partnerPercent(address partner) constant internal returns(uint16 percent){\n', '        percent = 0;\n', '        if(partnersInfo[partner].personal_percent > 0){\n', '            percent = partnersInfo[partner].personal_percent;\n', '        }\n', '        else{\n', '            uint256 attracted_investments = partnersInfo[partner].attracted_investments;\n', '            if(attracted_investments > 0){\n', '                if(attracted_investments < 3 ether){\n', '                    percent = 300; //1 = 0.01%, 10000 = 100%\n', '                }\n', '                else if(attracted_investments >= 3 ether && attracted_investments < 10 ether){\n', '                    percent = 500;\n', '                }\n', '                else if(attracted_investments >= 10 ether && attracted_investments < 100 ether){\n', '                    percent = 700;\n', '                }\n', '                else if(attracted_investments >= 100 ether){\n', '                    percent = 1000;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function partnerInfo(address partner_address) isOwner constant returns(string promo, uint256 attracted_investments, uint256[] h_datetime, uint256[] h_invest, address[] h_referrals){\n', '        if(partner_address != address(0x0) && partnersInfo[partner_address].create){\n', '            promo = partnersInfo[partner_address].promo;\n', '            attracted_investments = partnersInfo[partner_address].attracted_investments;\n', '\n', '            h_datetime = new uint256[](history[partner_address].length);\n', '            h_invest = new uint256[](history[partner_address].length);\n', '            h_referrals = new address[](history[partner_address].length);\n', '\n', '            for(uint256 i=0; i<history[partner_address].length; i++){\n', '                h_datetime[i] = history[partner_address][i].datetime;\n', '                h_invest[i] = history[partner_address][i].amount_invest;\n', '                h_referrals[i] = history[partner_address][i].referral;\n', '            }\n', '        }\n', '        else{\n', '            promo = &#39;-1&#39;;\n', '            attracted_investments = 0;\n', '            h_datetime = new uint256[](0);\n', '            h_invest = new uint256[](0);\n', '            h_referrals = new address[](0);\n', '        }\n', '    }\n', '\n', '    function refferalPreICOBonus(address referral) constant external returns (uint256 bonus){\n', '        bonus = referralsInfo[referral].preico_holdersBonus;\n', '    }\n', '\n', '    function partnerPreICOBonus(address partner) constant external returns (uint256 bonus){\n', '        bonus = partnersInfo[partner].preico_partnerBonus;\n', '    }\n', '\n', '    function referralAmountInvest(address referral) constant external returns (uint256 amount){\n', '        amount = referralsInfo[referral].amount_investments;\n', '    }\n', '\n', '    function add_referral(address referral, string promo, uint256 amount) external returns(address partner, uint256 p_partner, uint256 p_referral){\n', '        p_partner = 0;\n', '        p_referral = 0;\n', '        partner = address(0x0);\n', '        if(partnersPromo[promo] != address(0x0) && partnersPromo[promo] != referral){\n', '            partner = partnersPromo[promo];\n', '            if(msg.sender == contractPreICO){\n', '                referralsInfo[referral].amount_investments += amount;\n', '                amount_referral_invest += amount;\n', '                partnersInfo[partner].attracted_investments += amount;\n', '                history[partner].push(itemHistory(now, referral, amount));\n', '\n', '                uint256 partner_bonus = (amount*uint256(calc_partnerPercent(partner)))/10000;\n', '                if(partner_bonus > 0){\n', '                    partnersInfo[partner].preico_partnerBonus += partner_bonus;\n', '                }\n', '                uint256 referral_bonus = (amount*uint256(ref_percent))/10000;\n', '                if(referral_bonus > 0){\n', '                    referralsInfo[referral].preico_holdersBonus += referral_bonus;\n', '                    preico_holdersAmountInvestWithBonus += amount;\n', '                }\n', '            }\n', '            if (msg.sender == contractICO){\n', '                referralsInfo[referral].amount_investments += amount;\n', '                amount_referral_invest += amount;\n', '                partnersInfo[partner].attracted_investments += amount;\n', '                history[partner].push(itemHistory(now, referral, amount));\n', '                p_partner = (amount*uint256(calc_partnerPercent(partner)))/10000;\n', '                p_referral = (amount*uint256(ref_percent))/10000;\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract BMICOAffiliateProgramm {\n', '    struct itemReferrals {\n', '        uint256 amount_investments;\n', '        uint256 preico_holdersBonus;\n', '    }\n', '    mapping (address => itemReferrals) referralsInfo;\n', '    uint256 public preico_holdersAmountInvestWithBonus = 0;\n', '\n', '    mapping (string => address) partnersPromo;\n', '    struct itemPartners {\n', '        uint256 attracted_investments;\n', '        string promo;\n', '        uint16 personal_percent;\n', '        uint256 preico_partnerBonus;\n', '        bool create;\n', '    }\n', '    mapping (address => itemPartners) partnersInfo;\n', '\n', '    uint16 public ref_percent = 100; //1 = 0.01%, 10000 = 100%\n', '\n', '    struct itemHistory {\n', '        uint256 datetime;\n', '        address referral;\n', '        uint256 amount_invest;\n', '    }\n', '    mapping(address => itemHistory[]) history;\n', '\n', '    uint256 public amount_referral_invest;\n', '\n', '    address public owner;\n', '    address public contractPreICO;\n', '    address public contractICO;\n', '\n', '    function BMICOAffiliateProgramm(){\n', '        owner = msg.sender;\n', '        contractPreICO = address(0x0);\n', '        contractICO = address(0x0);\n', '    }\n', '\n', '    modifier isOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function str_length(string x) constant internal returns (uint256) {\n', '        bytes32 str;\n', '        assembly {\n', '        str := mload(add(x, 32))\n', '        }\n', '        bytes memory bytesString = new bytes(32);\n', '        uint256 charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(str) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        return charCount;\n', '    }\n', '\n', '    function changeOwner(address new_owner) isOwner {\n', '        assert(new_owner!=address(0x0));\n', '        assert(new_owner!=address(this));\n', '\n', '        owner = new_owner;\n', '    }\n', '\n', '    function setReferralPercent(uint16 new_percent) isOwner {\n', '        ref_percent = new_percent;\n', '    }\n', '\n', '    function setPartnerPercent(address partner, uint16 new_percent) isOwner {\n', '        assert(partner!=address(0x0));\n', '        assert(partner!=address(this));\n', '        assert(partnersInfo[partner].create==true);\n', '        partnersInfo[partner].personal_percent = new_percent;\n', '    }\n', '\n', '    function setContractPreICO(address new_address) isOwner {\n', '        assert(contractPreICO==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '\n', '        contractPreICO = new_address;\n', '    }\n', '\n', '    function setContractICO(address new_address) isOwner {\n', '        assert(contractICO==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '\n', '        contractICO = new_address;\n', '    }\n', '\n', '    function setPromoToPartner(string promo) {\n', '        assert(partnersPromo[promo]==address(0x0));\n', '        assert(partnersInfo[msg.sender].create==false);\n', '        assert(str_length(promo)>0 && str_length(promo)<=6);\n', '\n', '        partnersPromo[promo] = msg.sender;\n', '        partnersInfo[msg.sender].attracted_investments = 0;\n', '        partnersInfo[msg.sender].promo = promo;\n', '        partnersInfo[msg.sender].create = true;\n', '    }\n', '\n', '    function checkPromo(string promo) constant returns(bool){\n', '        return partnersPromo[promo]!=address(0x0);\n', '    }\n', '\n', '    function checkPartner(address partner_address) constant returns(bool isPartner, string promo){\n', '        isPartner = partnersInfo[partner_address].create;\n', "        promo = '-1';\n", '        if(isPartner){\n', '            promo = partnersInfo[partner_address].promo;\n', '        }\n', '    }\n', '\n', '    function calc_partnerPercent(address partner) constant internal returns(uint16 percent){\n', '        percent = 0;\n', '        if(partnersInfo[partner].personal_percent > 0){\n', '            percent = partnersInfo[partner].personal_percent;\n', '        }\n', '        else{\n', '            uint256 attracted_investments = partnersInfo[partner].attracted_investments;\n', '            if(attracted_investments > 0){\n', '                if(attracted_investments < 3 ether){\n', '                    percent = 300; //1 = 0.01%, 10000 = 100%\n', '                }\n', '                else if(attracted_investments >= 3 ether && attracted_investments < 10 ether){\n', '                    percent = 500;\n', '                }\n', '                else if(attracted_investments >= 10 ether && attracted_investments < 100 ether){\n', '                    percent = 700;\n', '                }\n', '                else if(attracted_investments >= 100 ether){\n', '                    percent = 1000;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function partnerInfo(address partner_address) isOwner constant returns(string promo, uint256 attracted_investments, uint256[] h_datetime, uint256[] h_invest, address[] h_referrals){\n', '        if(partner_address != address(0x0) && partnersInfo[partner_address].create){\n', '            promo = partnersInfo[partner_address].promo;\n', '            attracted_investments = partnersInfo[partner_address].attracted_investments;\n', '\n', '            h_datetime = new uint256[](history[partner_address].length);\n', '            h_invest = new uint256[](history[partner_address].length);\n', '            h_referrals = new address[](history[partner_address].length);\n', '\n', '            for(uint256 i=0; i<history[partner_address].length; i++){\n', '                h_datetime[i] = history[partner_address][i].datetime;\n', '                h_invest[i] = history[partner_address][i].amount_invest;\n', '                h_referrals[i] = history[partner_address][i].referral;\n', '            }\n', '        }\n', '        else{\n', "            promo = '-1';\n", '            attracted_investments = 0;\n', '            h_datetime = new uint256[](0);\n', '            h_invest = new uint256[](0);\n', '            h_referrals = new address[](0);\n', '        }\n', '    }\n', '\n', '    function refferalPreICOBonus(address referral) constant external returns (uint256 bonus){\n', '        bonus = referralsInfo[referral].preico_holdersBonus;\n', '    }\n', '\n', '    function partnerPreICOBonus(address partner) constant external returns (uint256 bonus){\n', '        bonus = partnersInfo[partner].preico_partnerBonus;\n', '    }\n', '\n', '    function referralAmountInvest(address referral) constant external returns (uint256 amount){\n', '        amount = referralsInfo[referral].amount_investments;\n', '    }\n', '\n', '    function add_referral(address referral, string promo, uint256 amount) external returns(address partner, uint256 p_partner, uint256 p_referral){\n', '        p_partner = 0;\n', '        p_referral = 0;\n', '        partner = address(0x0);\n', '        if(partnersPromo[promo] != address(0x0) && partnersPromo[promo] != referral){\n', '            partner = partnersPromo[promo];\n', '            if(msg.sender == contractPreICO){\n', '                referralsInfo[referral].amount_investments += amount;\n', '                amount_referral_invest += amount;\n', '                partnersInfo[partner].attracted_investments += amount;\n', '                history[partner].push(itemHistory(now, referral, amount));\n', '\n', '                uint256 partner_bonus = (amount*uint256(calc_partnerPercent(partner)))/10000;\n', '                if(partner_bonus > 0){\n', '                    partnersInfo[partner].preico_partnerBonus += partner_bonus;\n', '                }\n', '                uint256 referral_bonus = (amount*uint256(ref_percent))/10000;\n', '                if(referral_bonus > 0){\n', '                    referralsInfo[referral].preico_holdersBonus += referral_bonus;\n', '                    preico_holdersAmountInvestWithBonus += amount;\n', '                }\n', '            }\n', '            if (msg.sender == contractICO){\n', '                referralsInfo[referral].amount_investments += amount;\n', '                amount_referral_invest += amount;\n', '                partnersInfo[partner].attracted_investments += amount;\n', '                history[partner].push(itemHistory(now, referral, amount));\n', '                p_partner = (amount*uint256(calc_partnerPercent(partner)))/10000;\n', '                p_referral = (amount*uint256(ref_percent))/10000;\n', '            }\n', '        }\n', '    }\n', '}']
