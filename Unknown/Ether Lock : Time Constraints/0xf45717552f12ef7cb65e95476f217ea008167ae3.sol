['contract Government {\n', '\n', '    // Global Variables\n', '    uint32 public lastCreditorPayedOut;\n', '    uint public lastTimeOfNewCredit;\n', '    uint public profitFromCrash;\n', '    address[] public creditorAddresses;\n', '    uint[] public creditorAmounts;\n', '    address public corruptElite;\n', '    mapping (address => uint) buddies;\n', '    uint constant TWELVE_HOURS = 43200;\n', '    uint8 public round;\n', '\n', '    function Government() {\n', '        // The corrupt elite establishes a new government\n', '        // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n', '        profitFromCrash = msg.value;\n', '        corruptElite = msg.sender;\n', '        lastTimeOfNewCredit = block.timestamp;\n', '    }\n', '\n', '    function lendGovernmentMoney(address buddy) returns (bool) {\n', '        uint amount = msg.value;\n', '        // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n', '        // 12h are on average = 60*60*12/12.5 = 3456\n', '        if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n', '            // Return money to sender\n', '            msg.sender.send(amount);\n', '            // Sends all contract money to the last creditor\n', '            creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n', '            corruptElite.send(this.balance);\n', '            // Reset contract state\n', '            lastCreditorPayedOut = 0;\n', '            lastTimeOfNewCredit = block.timestamp;\n', '            profitFromCrash = 0;\n', '            creditorAddresses = new address[](0);\n', '            creditorAmounts = new uint[](0);\n', '            round += 1;\n', '            return false;\n', '        }\n', '        else {\n', '            // the system needs to collect at least 1% of the profit from a crash to stay alive\n', '            if (amount >= 10 ** 18) {\n', '                // the System has received fresh money, it will survive at leat 12h more\n', '                lastTimeOfNewCredit = block.timestamp;\n', '                // register the new creditor and his amount with 10% interest rate\n', '                creditorAddresses.push(msg.sender);\n', '                creditorAmounts.push(amount * 110 / 100);\n', '                // now the money is distributed\n', '                // first the corrupt elite grabs 5% - thieves!\n', '                corruptElite.send(amount * 5/100);\n', '                // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n', '                if (profitFromCrash < 10000 * 10**18) {\n', '                    profitFromCrash += amount * 5/100;\n', '                }\n', '                // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n', '                // Make a deal with him.\n', '                if(buddies[buddy] >= amount) {\n', '                    buddy.send(amount * 5/100);\n', '                }\n', '                buddies[msg.sender] += amount * 110 / 100;\n', '                // 90% of the money will be used to pay out old creditors\n', '                if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n', '                    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n', '                    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n', '                    lastCreditorPayedOut += 1;\n', '                }\n', '                return true;\n', '            }\n', '            else {\n', '                msg.sender.send(amount);\n', '                return false;\n', '            }\n', '        }\n', '    }\n', '\n', '    // fallback function\n', '    function() {\n', '        lendGovernmentMoney(0);\n', '    }\n', '\n', '    function totalDebt() returns (uint debt) {\n', '        for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n', '            debt += creditorAmounts[i];\n', '        }\n', '    }\n', '\n', '    function totalPayedOut() returns (uint payout) {\n', '        for(uint i=0; i<lastCreditorPayedOut; i++){\n', '            payout += creditorAmounts[i];\n', '        }\n', '    }\n', '\n', "    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n", '    function investInTheSystem() {\n', '        profitFromCrash += msg.value;\n', '    }\n', '\n', "    // From time to time the corrupt elite inherits it's power to the next generation\n", '    function inheritToNextGeneration(address nextGeneration) {\n', '        if (msg.sender == corruptElite) {\n', '            corruptElite = nextGeneration;\n', '        }\n', '    }\n', '\n', '    function getCreditorAddresses() returns (address[]) {\n', '        return creditorAddresses;\n', '    }\n', '\n', '    function getCreditorAmounts() returns (uint[]) {\n', '        return creditorAmounts;\n', '    }\n', '}']