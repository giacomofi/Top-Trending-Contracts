['pragma solidity ^0.4.17;\n', '\n', 'contract PyramidGame\n', '{\n', '    /////////////////////////////////////////////\n', '    // Game parameters\n', '    uint256 private constant BOTTOM_LAYER_BET_AMOUNT = 0.005 ether;\n', '    uint256 private adminFeeDivisor; // e.g. 100 means a 1% fee, 200 means a 0.5% fee\n', '    \n', '    /////////////////////////////////////////////\n', '    // Game owner\n', '    address private administrator;\n', '    \n', '    /////////////////////////////////////////////\n', '    // Pyramid grid data\n', '    //\n', '    // The uint32 is the coordinates.\n', "    // It consists of two uint16's:\n", '    // The x is the most significant 2 bytes (16 bits)\n', '    // The y is the least significant 2 bytes (16 bits)\n', '    // x = coordinates >> 16\n', '    // y = coordinates & 0xFFFF\n', '    // coordinates = (x << 16) | y\n', '    // x is a 16-bit unsigned integer\n', '    // y is a 16-bit unsigned integer\n', '    mapping(uint32 => address) public coordinatesToAddresses;\n', '    uint32[] public allBlockCoordinates;\n', '    \n', '    // In the user interface, the rows of blocks will be\n', '    // progressively shifted more to the right, as y increases\n', '    // \n', "    // For example, these blocks in the contract's coordinate system:\n", '    //         ______\n', '    //      2 |__A__|______\n', '    // /|\\  1 |__B__|__D__|______\n', '    //  |   0 |__C__|__E__|__F__|\n', '    //  y        0     1     2\n', '    // \n', '    //        x -->\n', '    // \n', '    // \n', '    // Become these blocks in the user interface:\n', '    //    __        ______\n', '    //    /|     __|__A__|___\n', '    //   /    __|__B__|__D__|___\n', '    //  y    |__C__|__E__|__F__|\n', '    // \n', '    //   x -->\n', '    // \n', '    // \n', '    \n', '    /////////////////////////////////////////////\n', '    // Address properties\n', '    mapping(address => uint256) public addressesToTotalWeiPlaced;\n', '    mapping(address => uint256) public addressBalances;\n', '    \n', '    ////////////////////////////////////////////\n', '    // Game Constructor\n', '    function PyramidGame() public\n', '    {\n', '        administrator = msg.sender;\n', '        adminFeeDivisor = 200; // Default fee is 0.5%\n', '        \n', '        // The administrator gets a few free chat messages :-)\n', '        addressesToChatMessagesLeft[administrator] += 5;\n', '        \n', '        // Set the first block in the middle of the bottom row\n', '        coordinatesToAddresses[uint32(1 << 15) << 16] = msg.sender;\n', '        allBlockCoordinates.push(uint32(1 << 15) << 16);\n', '    }\n', '    \n', '    ////////////////////////////////////////////\n', '    // Pyramid grid reading functions\n', '    function getBetAmountAtLayer(uint16 y) public pure returns (uint256)\n', '    {\n', '        // The minimum bet doubles every time you go up 1 layer\n', '        return BOTTOM_LAYER_BET_AMOUNT * (uint256(1) << y);\n', '    }\n', '    \n', '    function isThereABlockAtCoordinates(uint16 x, uint16 y) public view returns (bool)\n', '    {\n', '        return coordinatesToAddresses[(uint32(x) << 16) | uint16(y)] != 0;\n', '    }\n', '    \n', '    function getTotalAmountOfBlocks() public view returns (uint256)\n', '    {\n', '        return allBlockCoordinates.length;\n', '    }\n', '    \n', '    ////////////////////////////////////////////\n', '    // Pyramid grid writing functions\n', '    function placeBlock(uint16 x, uint16 y) external payable\n', '    {\n', '        // You may only place a block on an empty spot\n', '        require(!isThereABlockAtCoordinates(x, y));\n', '        \n', "        // Add the transaction amount to the person's balance\n", '        addressBalances[msg.sender] += msg.value;\n', '        \n', '        // Calculate the required bet amount at the specified layer\n', '        uint256 betAmount = getBetAmountAtLayer(y);\n', '\n', '        // If the block is at the lowest layer...\n', '        if (y == 0)\n', '        {\n', '            // There must be a block to the left or to the right of it\n', '            require(isThereABlockAtCoordinates(x-1, y) ||\n', '                    isThereABlockAtCoordinates(x+1, y));\n', '        }\n', '        \n', '        // If the block is NOT at the lowest layer...\n', '        else\n', '        {\n', '            // There must be two existing blocks below it:\n', '            require(isThereABlockAtCoordinates(x  , y-1) &&\n', '                    isThereABlockAtCoordinates(x+1, y-1));\n', '        }\n', '        \n', "        // Subtract the bet amount from the person's balance\n", '        addressBalances[msg.sender] -= betAmount;\n', '        \n', '        // Place the block\n', '        coordinatesToAddresses[(uint32(x) << 16) | y] = msg.sender;\n', '        allBlockCoordinates.push((uint32(x) << 16) | y);\n', '        \n', '        // If the block is at the lowest layer...\n', '        if (y == 0)\n', '        {\n', '            // The bet goes to the administrator\n', '            addressBalances[administrator] += betAmount;\n', '        }\n', '        \n', '        // If the block is NOT at the lowest layer...\n', '        else\n', '        {\n', '            // Calculate the administrator fee\n', '            uint256 adminFee = betAmount / adminFeeDivisor;\n', '            \n', '            // Calculate the bet amount minus the admin fee\n', '            uint256 betAmountMinusAdminFee = betAmount - adminFee;\n', '            \n', '            // Add the money to the balances of the people below\n', '            addressBalances[coordinatesToAddresses[(uint32(x  ) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n', '            addressBalances[coordinatesToAddresses[(uint32(x+1) << 16) | (y-1)]] += betAmountMinusAdminFee / 2;\n', '            \n', '            // Give the admin fee to the admin\n', '            addressBalances[administrator] += adminFee;\n', '        }\n', '        \n', "        // The new sender's balance must not have underflowed\n", '        // (this verifies that the sender has enough balance to place the block)\n', '        require(addressBalances[msg.sender] < (1 << 255));\n', '        \n', '        // Give the sender their chat message rights\n', '        addressesToChatMessagesLeft[msg.sender] += uint32(1) << y;\n', '        \n', "        // Register the sender's total bets placed\n", '        addressesToTotalWeiPlaced[msg.sender] += betAmount;\n', '    }\n', '    \n', '    ////////////////////////////////////////////\n', '    // Withdrawing balance\n', '    function withdrawBalance(uint256 amountToWithdraw) external\n', '    {\n', '        require(amountToWithdraw != 0);\n', '        \n', '        // The user must have enough balance to withdraw\n', '        require(addressBalances[msg.sender] >= amountToWithdraw);\n', '        \n', "        // Subtract the withdrawn amount from the user's balance\n", '        addressBalances[msg.sender] -= amountToWithdraw;\n', '        \n', "        // Transfer the amount to the user's address\n", '        // If the transfer() call fails an exception will be thrown,\n', "        // and therefore the user's balance will be automatically restored\n", '        msg.sender.transfer(amountToWithdraw);\n', '    }\n', '    \n', '    /////////////////////////////////////////////\n', '    // Chatbox data\n', '    struct ChatMessage\n', '    {\n', '        address person;\n', '        string message;\n', '    }\n', '    mapping(bytes32 => address) public usernamesToAddresses;\n', '    mapping(address => bytes32) public addressesToUsernames;\n', '    mapping(address => uint32) public addressesToChatMessagesLeft;\n', '    ChatMessage[] public chatMessages;\n', '    mapping(uint256 => bool) public censoredChatMessages;\n', '    \n', '    /////////////////////////////////////////////\n', '    // Chatbox functions\n', '    function registerUsername(bytes32 username) external\n', '    {\n', '        // The username must not already be token\n', '        require(usernamesToAddresses[username] == 0);\n', '        \n', '        // The address must not already have a username\n', '        require(addressesToUsernames[msg.sender] == 0);\n', '        \n', '        // Register the new username & address combination\n', '        usernamesToAddresses[username] = msg.sender;\n', '        addressesToUsernames[msg.sender] = username;\n', '    }\n', '    \n', '    function sendChatMessage(string message) external\n', '    {\n', '        // The sender must have at least 1 chat message allowance\n', '        require(addressesToChatMessagesLeft[msg.sender] >= 1);\n', '        \n', '        // Deduct 1 chat message allowence from the sender\n', '        addressesToChatMessagesLeft[msg.sender]--;\n', '        \n', '        // Add the chat message\n', '        chatMessages.push(ChatMessage(msg.sender, message));\n', '    }\n', '    \n', '    function getTotalAmountOfChatMessages() public view returns (uint256)\n', '    {\n', '        return chatMessages.length;\n', '    }\n', '    \n', '    function getChatMessageAtIndex(uint256 index) public view returns (address, bytes32, string)\n', '    {\n', '        address person = chatMessages[index].person;\n', '        bytes32 username = addressesToUsernames[person];\n', '        return (person, username, chatMessages[index].message);\n', '    }\n', '    \n', '    // In case of chat messages with extremely rude or inappropriate\n', '    // content, the administrator can censor a chat message.\n', '    function censorChatMessage(uint256 chatMessageIndex) public\n', '    {\n', '        require(msg.sender == administrator);\n', '        censoredChatMessages[chatMessageIndex] = true;\n', '    }\n', '    \n', '    /////////////////////////////////////////////\n', '    // Game ownership functions\n', '    function transferOwnership(address newAdministrator) external\n', '    {\n', '        require(msg.sender == administrator);\n', '        administrator = newAdministrator;\n', '    }\n', '    \n', '    function setFeeDivisor(uint256 newFeeDivisor) external\n', '    {\n', '        require(msg.sender == administrator);\n', '        require(newFeeDivisor >= 20); // The fee may never exceed 5%\n', '        adminFeeDivisor = newFeeDivisor;\n', '    }\n', '}']