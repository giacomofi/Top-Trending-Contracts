['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract ERC20 {\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '}\n', '\n', 'contract TimeBankToken {\n', '\n', '    struct tokenDeposit{\n', '    uint256 timeToWithdraw;\n', '    uint256 numTokens;\n', '    }\n', '\n', '    mapping (address => mapping(address => tokenDeposit)) tokenBalances;\n', '\n', '    function getInfo(address _tokenAddress, address _holder) constant returns(uint, uint, uint){\n', '        return(tokenBalances[_tokenAddress][_holder].timeToWithdraw,tokenBalances[_tokenAddress][_holder].numTokens, block.timestamp);\n', '    }\n', '\n', '    function depositTokens(ERC20 _token, uint256 _time, uint256 _amount) returns (bool){\n', '        require(_amount > 0 && _time > block.timestamp && _time < block.timestamp + 157680000);\n', '\n', '        if (!(tokenBalances[_token][msg.sender].timeToWithdraw > 0)) tokenBalances[_token][msg.sender].timeToWithdraw = _time;\n', '\n', '        tokenBalances[_token][msg.sender].numTokens += _amount;\n', '\n', '        require(_token.transferFrom(msg.sender, this, _amount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(ERC20 _token) returns (bool){\n', '\n', '        uint tokens = tokenBalances[_token][msg.sender].numTokens;\n', '        tokenBalances[_token][msg.sender].numTokens = 0;\n', '\n', '        require(tokenBalances[_token][msg.sender].timeToWithdraw < block.timestamp && tokens > 0);\n', '\n', '        tokenBalances[_token][msg.sender].timeToWithdraw = 0;\n', '\n', '        require(_token.transfer(msg.sender, tokens));\n', '\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract ERC20 {\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '}\n', '\n', 'contract TimeBankToken {\n', '\n', '    struct tokenDeposit{\n', '    uint256 timeToWithdraw;\n', '    uint256 numTokens;\n', '    }\n', '\n', '    mapping (address => mapping(address => tokenDeposit)) tokenBalances;\n', '\n', '    function getInfo(address _tokenAddress, address _holder) constant returns(uint, uint, uint){\n', '        return(tokenBalances[_tokenAddress][_holder].timeToWithdraw,tokenBalances[_tokenAddress][_holder].numTokens, block.timestamp);\n', '    }\n', '\n', '    function depositTokens(ERC20 _token, uint256 _time, uint256 _amount) returns (bool){\n', '        require(_amount > 0 && _time > block.timestamp && _time < block.timestamp + 157680000);\n', '\n', '        if (!(tokenBalances[_token][msg.sender].timeToWithdraw > 0)) tokenBalances[_token][msg.sender].timeToWithdraw = _time;\n', '\n', '        tokenBalances[_token][msg.sender].numTokens += _amount;\n', '\n', '        require(_token.transferFrom(msg.sender, this, _amount));\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(ERC20 _token) returns (bool){\n', '\n', '        uint tokens = tokenBalances[_token][msg.sender].numTokens;\n', '        tokenBalances[_token][msg.sender].numTokens = 0;\n', '\n', '        require(tokenBalances[_token][msg.sender].timeToWithdraw < block.timestamp && tokens > 0);\n', '\n', '        tokenBalances[_token][msg.sender].timeToWithdraw = 0;\n', '\n', '        require(_token.transfer(msg.sender, tokens));\n', '\n', '        return true;\n', '    }\n', '}']
