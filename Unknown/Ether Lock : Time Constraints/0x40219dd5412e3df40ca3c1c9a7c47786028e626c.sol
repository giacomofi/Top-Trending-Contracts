['contract ICreditBIT {\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '    function mintMigrationTokens(address _reciever, uint _amount) returns (uint error) {}\n', '    function getAccountData(address _owner) constant returns (uint avaliableBalance, uint lockedBalance, uint bondMultiplier, uint lockedUntilBlock, uint lastBlockClaimed) {}\n', '}\n', '\n', 'contract ICreditIDENTITY {\n', '    function getAddressDescription(address _queryAddress) constant returns (string){}\n', '}\n', '\n', 'contract ICreditDAOfund {\n', '    function withdrawReward(address _destination) {}\n', '    function setCreditBondContract(address _creditBondAddress) {}\n', '    function setCreditBitContract(address _creditBitAddress) {}\n', '    function setFundsCreditDaoAddress(address _creditDaoAddress) {}\n', '    function claimBondReward() {}\n', '    function setCreditDaoAddress(address _creditDaoAddress) {}\n', '    function lockTokens(uint _multiplier) {}\n', '\n', '}\n', '\n', 'contract CreditDAO {\n', '    struct Election {\n', '        uint startBlock;\n', '        uint endBlock;\n', '        uint totalCrbSupply;\n', '        bool electionsFinished;\n', '\n', '        uint nextCandidateIndex;\n', '        mapping(uint => address) candidateIndex;\n', '        mapping(address => uint) candidateAddyToIndexMap;\n', '        mapping(uint => uint) candidateVotes;\n', '        mapping(address => bool) candidates;\n', '\n', '        mapping(address => bool) userHasVoted;\n', '\n', '        address maxVotes;\n', '        uint numOfMaxVotes;\n', '        uint idProcessed;\n', '    }\n', '\n', '    uint public nextElectionIndex;\n', '    mapping(uint => Election) public elections;\n', '\n', '    address public creditCEO;\n', '    uint public mandateInBlocks = 927530;\n', '    uint public blocksPerMonth = 76235;\n', '\n', '    ICreditBIT creditBitContract = ICreditBIT(0xAef38fBFBF932D1AeF3B808Bc8fBd8Cd8E1f8BC5);\n', '    ICreditDAOfund creditDAOFund;\n', '\n', '    modifier onlyCEO {\n', '        require(msg.sender == creditCEO);\n', '        _;\n', '    }\n', '    \n', '    function CreditDAO() {\n', '        elections[nextElectionIndex].startBlock = block.number;\n', '        elections[nextElectionIndex].endBlock = block.number + blocksPerMonth;\n', '        elections[nextElectionIndex].totalCrbSupply = creditBitContract.totalSupply();\n', '        nextElectionIndex++;\n', '    }\n', '\n', '    // Election part\n', '    function createNewElections() {\n', '        require(elections[nextElectionIndex - 1].endBlock + mandateInBlocks < block.number);\n', '\n', '        elections[nextElectionIndex].startBlock = block.number;\n', '        elections[nextElectionIndex].endBlock = block.number + blocksPerMonth;\n', '        elections[nextElectionIndex].totalCrbSupply = creditBitContract.totalSupply();\n', '        nextElectionIndex++;\n', '\n', '        creditCEO = 0x0;\n', '    }\n', '\n', '    function sumbitForElection() {\n', '        require(elections[nextElectionIndex - 1].endBlock > block.number);\n', '        require(!elections[nextElectionIndex - 1].candidates[msg.sender]);\n', '\n', '        uint nextCandidateId = elections[nextElectionIndex].nextCandidateIndex;\n', '        elections[nextElectionIndex - 1].candidateIndex[nextCandidateId] = msg.sender;\n', '        elections[nextElectionIndex - 1].candidateAddyToIndexMap[msg.sender] = nextCandidateId;\n', '        elections[nextElectionIndex - 1].nextCandidateIndex++;\n', '        elections[nextElectionIndex - 1].candidates[msg.sender] = true;\n', '        \n', '    }\n', '\n', '    function vote(address _participant) {\n', '        require(elections[nextElectionIndex - 1].endBlock > block.number);\n', '        \n', '        uint avaliableBalance;\n', '        uint lockedBalance;\n', '        uint bondMultiplier; \n', '        uint lockedUntilBlock; \n', '        uint lastBlockClaimed; \n', '        (avaliableBalance, lockedBalance, bondMultiplier, lockedUntilBlock, lastBlockClaimed) = creditBitContract.getAccountData(msg.sender);\n', '        require(lockedUntilBlock >= elections[nextElectionIndex - 1].endBlock);\n', '        require(!elections[nextElectionIndex - 1].userHasVoted[msg.sender]);\n', '        uint candidateId = elections[nextElectionIndex - 1].candidateAddyToIndexMap[_participant];\n', '        elections[nextElectionIndex - 1].candidateVotes[candidateId] += lockedBalance;\n', '        elections[nextElectionIndex - 1].userHasVoted[msg.sender] = true;\n', '    }\n', '\n', '    function finishElections(uint _iterations) {\n', '        require(elections[nextElectionIndex - 1].endBlock < block.number);\n', '        require(!elections[nextElectionIndex - 1].electionsFinished);\n', '\n', '        uint curentVotes;\n', '        uint nextCandidateId = elections[nextElectionIndex - 1].idProcessed;\n', '        for (uint cnt = 0; cnt < _iterations; cnt++) {\n', '            curentVotes = elections[nextElectionIndex - 1].candidateVotes[nextCandidateId];\n', '            if (curentVotes > elections[nextElectionIndex - 1].numOfMaxVotes) {\n', '                elections[nextElectionIndex - 1].maxVotes = elections[nextElectionIndex - 1].candidateIndex[nextCandidateId];\n', '                elections[nextElectionIndex - 1].numOfMaxVotes = curentVotes;\n', '            }\n', '            nextCandidateId++;\n', '        }\n', '        elections[nextElectionIndex - 1].idProcessed = nextCandidateId;\n', '        if (elections[nextElectionIndex - 1].candidateIndex[nextCandidateId] == 0x0) {\n', '            creditCEO = elections[nextElectionIndex - 1].maxVotes;\n', '            elections[nextElectionIndex - 1].electionsFinished = true;\n', '\n', '            if (elections[nextElectionIndex - 1].numOfMaxVotes == 0) {\n', '                elections[nextElectionIndex].startBlock = block.number;\n', '                elections[nextElectionIndex].endBlock = block.number + blocksPerMonth;\n', '                elections[nextElectionIndex].totalCrbSupply = creditBitContract.totalSupply();\n', '                nextElectionIndex++;\n', '            }\n', '        }\n', '    }\n', '\n', '    // CEO part\n', '    function claimBondReward() onlyCEO {\n', '\t\tcreditDAOFund.claimBondReward();\n', '\t}\n', '\n', '    function withdrawBondReward(address _addy) onlyCEO {\n', '        creditDAOFund.withdrawReward(_addy);\n', '    }\n', '\n', '    function lockTokens(uint _multiplier) onlyCEO {\n', '        creditDAOFund.lockTokens(_multiplier);\n', '    }\n', '\n', '    function setCreditBitContract(address _newCreditBitAddress) onlyCEO {\n', '        creditBitContract = ICreditBIT(_newCreditBitAddress);\n', '    }\n', '\n', '    function setMandateInBlocks(uint _newMandateInBlocks) onlyCEO {\n', '        mandateInBlocks = _newMandateInBlocks;\n', '    }\n', '\n', '    function setblocksPerMonth(uint _newblocksPerMonth) onlyCEO {\n', '        blocksPerMonth = _newblocksPerMonth;\n', '    }\n', '\n', '    \n', '    function setCreditDaoFund(address _newCreditDaoFundAddress) onlyCEO {\n', '        creditDAOFund = ICreditDAOfund(_newCreditDaoFundAddress);\n', '    }\n', '\n', '    // Fund methods\n', '    function setFundsCreditDaoAddress(address _creditDaoAddress) onlyCEO {\n', '\t    creditDAOFund.setCreditDaoAddress(_creditDaoAddress);\n', '\t}\n', '\t\n', '\tfunction setFundsCreditBitContract(address _creditBitAddress) onlyCEO {\n', '        creditDAOFund.setCreditBitContract(_creditBitAddress);\n', '\t}\n', '\t\n', '\tfunction setFundsCreditBondContract(address _creditBondAddress) onlyCEO {\n', '        creditDAOFund.setCreditBondContract(_creditBondAddress);\n', '\t}\n', '\n', '    function getCreditFundAddress() constant returns (address) {\n', '        return address(creditDAOFund);\n', '    }\n', '\n', '    function getCreditBitAddress() constant returns (address) {\n', '        return address(creditBitContract);\n', '    }\n', '}']