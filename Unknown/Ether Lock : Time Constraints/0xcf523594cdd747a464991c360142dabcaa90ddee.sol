['pragma solidity ^0.4.15;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    We deleted unused part.\n', '    To see full source code, refer below : \n', '    https://github.com/pipermerriam/ethereum-datetime\n', '\n', '    The MIT License (MIT)\n', '\n', '    Copyright (c) 2015 Piper Merriam\n', '\n', '    Permission is hereby granted, free of charge, to any person obtaining a copy\n', '    of this software and associated documentation files (the "Software"), to deal\n', '    in the Software without restriction, including without limitation the rights\n', '    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n', '    copies of the Software, and to permit persons to whom the Software is\n', '    furnished to do so, subject to the following conditions:\n', '\n', '    The above copyright notice and this permission notice shall be included in all\n', '    copies or substantial portions of the Software.\n', '\n', '    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '    SOFTWARE.\n', '*/\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) constant returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) constant returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) constant returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) constant returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) constant returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) constant returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) constant returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '}\n', '\n', 'contract ITGTokenBase is ERC20, SafeMath {\n', '\n', '  /* Actual balances of token holders */\n', '  mapping(address => uint) balances;\n', '\n', '  /* approve() allowances */\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  \n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Authable {\n', '    address public owner;\n', '    address public executor;\n', '\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '   \n', '    modifier onlyAuth(){\n', '        require(msg.sender == owner || msg.sender == executor);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _owner){\n', '        require(owner == 0x0 || owner == msg.sender);\n', '        owner = _owner;\n', '    }\n', '\n', '    function setExecutor(address exec) {\n', '        require(executor == 0x0 || owner == msg.sender || executor == msg.sender);\n', '        executor = exec;\n', '    }\n', '}\n', '\n', 'contract CrowdSale is SafeMath, Authable {\n', '\n', '    struct SaleAttr{\n', '        uint amountRaisedTotal;  // Total funding\n', '\n', '        uint saleSupplyPre; // Supply for Pre crowdSale\n', '        uint saleSupply1; // Supply for 1st crowdSale\n', '        uint saleSupply2; // Supply for 2nd crowdSale\n', '        uint saleSupply3; // Supply for 3rd crowdSale\n', '        uint saleSupply4; // Supply for 4th crowdSale\n', '        \n', '        uint amountRaisedPre;   // Only count Pre crowdSale funding for distribute\n', '        uint amountRaised1;     // Only count 1st crowdSale funding for distribute\n', '        uint amountRaised2;     // Only count 2nd crowdSale funding for just record\n', '        uint amountRaised3;     // Only count 3rd crowdSale funding for distribute\n', '        uint amountRaised4;     // Only count 4th crowdSale funding for just record\n', '\n', '        uint soldSupply2;\n', '        uint soldSupply4;\n', '    }\n', '    SaleAttr public s;\n', '    mapping(address => uint) public participantsForPreSale;    // Pre crowdSale participants\n', '    mapping(address => uint) public participantsFor1stSale;    // 1st crowdSale participants\n', '    mapping(address => uint) public participantsFor3rdSale;    // 3rd crowdSale participants\n', '\n', '    event LogCustomSale(uint startTime, uint endTime, uint tokPerEth, uint supply);\n', '\n', '    struct SaleTimeAttr{\n', '        uint pstart;\n', '        uint pdeadline;\n', '\n', '        // 1st, 3rd sale is time based share\n', '        // 2nd, 4th sale is price sale\n', '        uint start;         // When 1st crowdSale starts\n', '        uint deadline1;     // When 1st crowdSale ends and 2nd crowdSale starts\n', '        uint deadline2;     // When 2nd crowdSale ends\n', '        uint deadline3;     // When 3rd crowdSale ends\n', '        uint deadline4;     // When 4th crowdSale ends\n', '    }\n', '    SaleTimeAttr public t;\n', '\n', '    struct CustomSaleAttr{\n', '        uint start;\n', '        uint end;\n', '        uint tokenPerEth;   // 0 means period sale\n', '        uint saleSupply;\n', '        uint soldSupply;\n', '        uint amountRaised;\n', '    }\n', '    CustomSaleAttr public cs;\n', '    mapping(uint => mapping(address => uint)) public participantsForCustomSale;\n', '\n', '    function setAttrs(uint supplyPre, uint supply1, uint supply2, uint supply3, uint supply4\n', '            , uint preStart, uint preEnd, uint start, uint end1, uint end2, uint end3, uint end4\n', '        ) onlyAuth {\n', '        s.saleSupplyPre = supplyPre; // totalSupply * 10 / 100\n', '        //start, deadline1~4 should be set before start\n', '        s.saleSupply1 = supply1;    //totalSupply * 10 / 100;     // 10% of totalSupply. Total 40% to CrowdSale, 5% to dev team, 55% will be used for game and vote\n', '        s.saleSupply2 = supply2;    //totalSupply *  5 / 100;\n', '        s.saleSupply3 = supply3;    //totalSupply * 10 / 100;\n', '        s.saleSupply4 = supply4;    //totalSupply *  5 / 100;\n', '\n', '        t.pstart = preStart;\n', '        t.pdeadline = preEnd;\n', '        t.start = start;\n', '        t.deadline1 = end1;\n', '        t.deadline2 = end2;\n', '        t.deadline3 = end3;\n', '        t.deadline4 = end4;\n', '    }\n', '\n', '    function setAttrCustom(uint startTime, uint endTime, uint tokPerEth, uint supply) onlyAuth {\n', '        cs.start = startTime;\n', '        cs.end = endTime;\n', '        cs.tokenPerEth = tokPerEth;\n', '        cs.saleSupply = supply;\n', '        cs.soldSupply = 0;\n', '        cs.amountRaised = 0;\n', '        LogCustomSale(startTime, endTime, tokPerEth, supply);\n', '    }\n', '\n', '    function process(address sender, uint sendValue) onlyOwner returns (uint tokenAmount) {\n', '        if(now > t.pstart && now <= t.pdeadline){\n', '            participantsForPreSale[sender] = add(participantsForPreSale[sender],sendValue);\n', '            s.amountRaisedPre = add(s.amountRaisedPre, sendValue);\n', '        }else if(now > t.start && now <= t.deadline1){\n', '            participantsFor1stSale[sender] = add(participantsFor1stSale[sender],sendValue);\n', '            s.amountRaised1 = add(s.amountRaised1, sendValue);\n', '        }else if(now > t.deadline1 && now <= t.deadline2 && s.soldSupply2 < s.saleSupply2){\n', '            tokenAmount = sendValue / (s.amountRaised1 / s.saleSupply1 * 120 / 100);    //Token Price = s.amountRaised1 / s.saleSupply1. Price is going up 20%\n', '            s.soldSupply2 = add(s.soldSupply2, tokenAmount);\n', '            s.amountRaised2 = add(s.amountRaised2, sendValue);\n', '\n', '            require(s.soldSupply2 < s.saleSupply2 * 105 / 100);   // A little bit more sale is granted for the price sale.\n', '        }else if(now > t.deadline2 && now <= t.deadline3){\n', '            participantsFor3rdSale[sender] = add(participantsFor3rdSale[sender],sendValue);\n', '            s.amountRaised3 = add(s.amountRaised3, sendValue);\n', '        }else if(now > t.deadline3 && now <= t.deadline4 && s.soldSupply4 < s.saleSupply4){\n', '            tokenAmount = sendValue / (s.amountRaised3 / s.saleSupply3 * 120 / 100);     //Token Price = s.amountRaised3 / s.saleSupply3. Price is going up 20%\n', '            s.soldSupply4 = add(s.soldSupply4, tokenAmount);\n', '            s.amountRaised4 = add(s.amountRaised4, sendValue);\n', '\n', '            require(s.soldSupply4 < s.saleSupply4 * 105 / 100);   // A little bit more sale is granted for the price sale.\n', '        }else if(now > cs.start && now <= cs.end && cs.soldSupply < cs.saleSupply){\n', '            if(cs.tokenPerEth > 0){\n', '                tokenAmount = sendValue * cs.tokenPerEth;\n', '                cs.soldSupply = add(cs.soldSupply, tokenAmount);\n', '\n', '                require(cs.soldSupply < cs.saleSupply * 105 / 100); // A little bit more sale is granted for the price sale.\n', '            }else{\n', '                participantsForCustomSale[cs.start][sender] = add(participantsForCustomSale[cs.start][sender],sendValue);\n', '                cs.amountRaised = add(cs.amountRaised, sendValue);\n', '            }\n', '        }else{\n', '            throw;\n', '        }\n', '        s.amountRaisedTotal = add(s.amountRaisedTotal, sendValue);\n', '    }\n', '\n', '    function getToken(address sender) onlyOwner returns (uint tokenAmount){\n', '        if(now > t.pdeadline && participantsForPreSale[sender] != 0){\n', '            tokenAmount = add(tokenAmount,participantsForPreSale[sender] * s.saleSupplyPre / s.amountRaisedPre);  //Token Amount Per Eth = s.saleSupplyPre / s.amountRaisedPre\n', '            participantsForPreSale[sender] = 0;\n', '        }\n', '        if(now > t.deadline1 && participantsFor1stSale[sender] != 0){\n', '            tokenAmount = add(tokenAmount,participantsFor1stSale[sender] * s.saleSupply1 / s.amountRaised1);  //Token Amount Per Eth = s.saleSupply1 / s.amountRaised1\n', '            participantsFor1stSale[sender] = 0;\n', '        }\n', '        if(now > t.deadline3 && participantsFor3rdSale[sender] != 0){\n', '            tokenAmount = add(tokenAmount,participantsFor3rdSale[sender] * s.saleSupply3 / s.amountRaised3);  //Token Amount Per Eth = s.saleSupply3 / s.amountRaised3\n', '            participantsFor3rdSale[sender] = 0;\n', '        }\n', '        if(now > cs.end && participantsForCustomSale[cs.start][sender] != 0){\n', '            tokenAmount = add(tokenAmount,participantsForCustomSale[cs.start][sender] * cs.saleSupply / cs.amountRaised);  //Token Amount Per Eth = cs.saleSupply / cs.amountRaised\n', '            participantsForCustomSale[cs.start][sender] = 0;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Voting is SafeMath, Authable {\n', '    mapping(uint => uint) public voteRewardPerUnit; // If the voters vote, they will rewarded x% of tokens by their balances. 100 means 1%, 1000 means 10%\n', '    mapping(uint => uint) public voteWeightUnit;    // If 100 * 1 ether, each 100 * 1 ether token of holder will get vote weight 1. \n', '    mapping(uint => uint) public voteStart;\n', '    mapping(uint => uint) public voteEnd;\n', '    mapping(uint => uint) public maxCandidateId;\n', '\n', '    mapping(uint => mapping(address => bool)) public voted;\n', '    mapping(uint => mapping(uint => uint)) public results;\n', '\n', '    event LogVoteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId);\n', '    event LogVote(address voter, uint weight, uint voteId, uint candidateId, uint candidateValue);\n', '\n', '    function voteInitiate(uint _voteId, uint _voteRewardPerUnit, uint _voteWeightUnit, uint _voteStart, uint _voteEnd, uint _maxCandidateId) onlyOwner {   \n', '        require(voteEnd[_voteId] == 0);  // Do not allow duplicate voteId\n', '        require(_voteEnd != 0);\n', '\n', '        voteRewardPerUnit[_voteId] = _voteRewardPerUnit;\n', '        voteWeightUnit[_voteId] = _voteWeightUnit;\n', '        voteStart[_voteId] = _voteStart;\n', '        voteEnd[_voteId] = _voteEnd;\n', '        maxCandidateId[_voteId] = _maxCandidateId;\n', '\n', '        LogVoteInitiate(_voteId, _voteRewardPerUnit, _voteWeightUnit, _voteStart, _voteEnd, _maxCandidateId);\n', '    }\n', '\n', '     function vote(address sender, uint holding, uint voteId, uint candidateId) onlyOwner returns (uint tokenAmount, uint lockUntil){\n', '        require(now > voteStart[voteId] && now <= voteEnd[voteId]);\n', '        require(maxCandidateId[voteId] >= candidateId);\n', '        require(holding >= voteRewardPerUnit[voteId]);\n', '        require(!voted[voteId][sender]);\n', '\n', '        uint weight = holding / voteWeightUnit[voteId];\n', '\n', '        results[voteId][candidateId] = add(results[voteId][candidateId], weight);\n', '        voted[voteId][sender] = true;\n', '        tokenAmount = weight * voteWeightUnit[voteId] * voteRewardPerUnit[voteId] / 100 / 100;\n', '        lockUntil = voteEnd[voteId];\n', '\n', '        LogVote(sender, weight, voteId, candidateId, results[voteId][candidateId]);\n', '    }\n', '}\n', '\n', 'contract Games is SafeMath, DateTime, Authable {\n', '    enum GameTime { Hour, Month, Year, OutOfTime }\n', '    enum GameType { Range, Point}\n', '\n', '    struct Participant {\n', '        address sender;\n', '        uint value;\n', '        uint currency; // 1 : Eth, 2 : Tok\n', '    }\n', '\n', '    struct DateAttr{\n', '        uint currentYear;\n', '        uint gameStart; //Only for Range Game\n', '        uint gameEnd;   //For both Range Game and point Game(=intime timestamp)\n', '        uint prevGameEnd; //Only for Point Game\n', '    }\n', '    DateAttr public d;\n', '\n', '    struct CommonAttr{\n', '        GameTime currentGameTimeType;      // Current Game time type\n', '        GameType gameType;\n', '\n', '        uint hourlyAmountEth;  // Funded Eth amount\n', '        uint monthlyAmountEth;\n', '        uint yearlyAmountEth;\n', '        uint charityAmountEth;\n', '\n', '    }\n', '    CommonAttr public c;\n', '\n', '    struct FundAmountStatusAttr{\n', '        uint hourlyStatusEth;  // Funded Eth amount in current game time\n', '        uint monthlyStatusEth;\n', '        uint yearlyStatusEth;\n', '\n', '        uint hourlyStatusTok;  // Funded Token amount in current game time\n', '        uint monthlyStatusTok;\n', '    }\n', '    FundAmountStatusAttr public f;\n', '\n', '    struct PriceAttr{\n', '        uint bonusPerEth;   // If you not won, xx token to 1 Eth will be rewarded\n', '\n', '        uint inGameTokPricePerEth;   // Regard xx token to 1 Eth for token participants\n', '        uint inGameTokWinRatioMax;   // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\n', '        uint inGameTokWinRatioMin;\n', '        uint currentInGameTokWinRatio;  // Current token winners prize ratio\n', '\n', '        uint hourlyMinParticipateRatio;     // If participants.length are less than 100, x100 would be min prize ratio\n', '        uint monthlyMinParticipateRatio;    // If participants.length are less than 300, x300 would be min prize ratio\n', '        uint yearlyMinParticipateRatio;     // If participants.length are less than 1000, x1000 would be min prize ratio\n', '\n', '        uint boostPrizeEth;    // Boosts prize amount. Default is 100 and it means 100%\n', '    }\n', '    PriceAttr public p;\n', '\n', '\n', '    struct RangeGameAttr{\n', '        uint inTimeRange_H; // 10 means +-10 mins in time\n', '        uint inTimeRange_M;\n', '        uint inTimeRange_Y;\n', '    }\n', '    RangeGameAttr public r;\n', '    Participant[] public participants;  // RangeGame participants\n', '\n', '    mapping(uint256 => mapping(address => uint256)) public winners; // Eth reward\n', '    mapping(uint256 => mapping(address => uint256)) public tokTakers; // Tok reward\n', '    mapping(uint256 => uint256) public winPrizes;\n', '    mapping(uint256 => uint256) public tokPrizes;\n', '\n', '    event LogSelectWinner(uint rand, uint luckyNumber, address sender, uint reward, uint currency, uint amount);\n', '\n', '    function setPriceAttr(\n', '            GameType _gameType, uint _bonusPerEth, uint _inGameTokPricePerEth\n', '            , uint _inGameTokWinRatioMax, uint _inGameTokWinRatioMin, uint _currentInGameTokWinRatio\n', '            , uint _hourlyMinParticipateRatio, uint _monthlyMinParticipateRatio, uint _yearlyMinParticipateRatio, uint _boostPrizeEth\n', '        ) onlyAuth {\n', '        c.gameType = _gameType;\n', '\n', '        p.bonusPerEth = _bonusPerEth;   //300   // Depends on crowdSale average price. Vote needed, but we assume AVG/4 is reasonable.\n', '        p.inGameTokPricePerEth = _inGameTokPricePerEth; //300   // Regard xx token to 1 Eth for token participants. Depends on crowdSale, too.\n', '        p.inGameTokWinRatioMax = _inGameTokWinRatioMax; //50    // 100 means 100%. Disadventage against Eth. Change prize ratio like 25~50%\n', '        p.inGameTokWinRatioMin = _inGameTokWinRatioMin; //25\n', '        p.currentInGameTokWinRatio = _currentInGameTokWinRatio;    //50\n', '        p.hourlyMinParticipateRatio = _hourlyMinParticipateRatio;   //100   // If participants.length are less than 100, x100 would be min prize ratio\n', '        p.monthlyMinParticipateRatio = _monthlyMinParticipateRatio; //300\n', '        p.yearlyMinParticipateRatio = _yearlyMinParticipateRatio;   //1000\n', '        p.boostPrizeEth = _boostPrizeEth;   //100\n', '    }\n', '\n', '    function setRangeGameAttr(uint _inTimeRange_H, uint _inTimeRange_M, uint _inTimeRange_Y) onlyAuth {\n', '        r.inTimeRange_H = _inTimeRange_H;   //10       // 10 mean +-10 mins in time\n', '        r.inTimeRange_M = _inTimeRange_M;   //190 = 3 * 60 + r.inTimeRange_H\n', '        r.inTimeRange_Y = _inTimeRange_Y;   //370 = 6 * 60 + r.inTimeRange_H\n', '    }\n', '     \n', '    // Calulate game time and gc amount record\n', '    modifier beforeRangeGame(){\n', '        require(now > d.gameStart && now <= d.gameEnd);\n', '        _;\n', '    }\n', '\n', '    modifier beforePointGame(){\n', '        refreshGameTime();\n', '        _;\n', '    }\n', '\n', '    function process(address sender, uint sendValue) onlyOwner {\n', '        if(c.gameType == GameType.Range){\n', '            RangeGameProcess(sender, sendValue);\n', '        }else if(c.gameType == GameType.Point){\n', '            PointGameProcess(sender, sendValue);\n', '        }\n', '    }\n', '\n', '    function processWithITG(address sender, uint tokenAmountToGame) onlyOwner {\n', '        if(c.gameType == GameType.Range){\n', '            RangeGameWithITG(sender, tokenAmountToGame);\n', '        }else if(c.gameType == GameType.Point){\n', '            PointGameWithITG(sender, tokenAmountToGame);\n', '        }\n', '    }\n', '\n', '    // Range Game\n', '    function RangeGameProcess(address sender, uint sendValue) private beforeRangeGame {\n', '        if(c.currentGameTimeType == GameTime.Year){\n', '            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\n', '            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\n', '        }else if(c.currentGameTimeType == GameTime.Month){\n', '            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\n', '            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\n', '        }else if(c.currentGameTimeType == GameTime.Hour){\n', '            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\n', '            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\n', '        }\n', '        participants.push(Participant(sender,sendValue,1));\n', '        if(p.bonusPerEth != 0){\n', '            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\n', '            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\n', '        }\n', '    }\n', '\n', '    function RangeGameWithITG(address sender, uint tokenAmountToGame) private beforeRangeGame {\n', '        require(c.currentGameTimeType != GameTime.Year);\n', '\n', '        if(c.currentGameTimeType == GameTime.Month){\n', '            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\n', '        }else if(c.currentGameTimeType == GameTime.Hour){\n', '            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\n', '        }\n', '        participants.push(Participant(sender,tokenAmountToGame,2));\n', '    }\n', '\n', '    function getTimeRangeInfo() private returns (GameTime, uint, uint, uint) {\n', '        uint nextTimeStamp;\n', '        uint nextYear;\n', '        uint nextMonth;\n', '        uint basis;\n', '        if(c.gameType == GameType.Range){\n', '            nextTimeStamp = now + r.inTimeRange_Y * 1 minutes + 1 hours;\n', '            nextYear = getYear(nextTimeStamp);\n', '            if(getYear(now - r.inTimeRange_Y * 1 minutes + 1 hours) != nextYear){\n', '                basis = nextTimeStamp - (nextTimeStamp % 1 days);    //Time range limit is less than 12 hours\n', '                return (GameTime.Year, nextYear, basis - r.inTimeRange_Y * 1 minutes, basis + r.inTimeRange_Y * 1 minutes);\n', '            }\n', '            nextTimeStamp = now + r.inTimeRange_M * 1 minutes + 1 hours;\n', '            nextMonth = getMonth(nextTimeStamp);\n', '            if(getMonth(now - r.inTimeRange_M * 1 minutes + 1 hours) != nextMonth){\n', '                basis = nextTimeStamp - (nextTimeStamp % 1 days); \n', '                return (GameTime.Month, nextYear, basis - r.inTimeRange_M * 1 minutes, basis + r.inTimeRange_M * 1 minutes);\n', '            }\n', '            nextTimeStamp = now + r.inTimeRange_H * 1 minutes + 1 hours;\n', '            basis = nextTimeStamp - (nextTimeStamp % 1 hours); \n', '            return (GameTime.Hour, nextYear, basis - r.inTimeRange_H * 1 minutes, basis + r.inTimeRange_H * 1 minutes);\n', '        }else if(c.gameType == GameType.Point){\n', '            nextTimeStamp = now - (now % 1 hours) + 1 hours;\n', '            nextYear = getYear(nextTimeStamp);\n', '            if(getYear(now) != nextYear){\n', '                return (GameTime.Year, nextYear, 0, nextTimeStamp);\n', '            }\n', '            nextMonth = getMonth(nextTimeStamp);\n', '            if(getMonth(now) != nextMonth){\n', '                return (GameTime.Month, nextYear, 0, nextTimeStamp);\n', '            }\n', '            return (GameTime.Hour, nextYear, 0, nextTimeStamp);\n', '        }\n', '    }\n', '\n', '    function refreshGameTime() private {\n', '        (c.currentGameTimeType, d.currentYear, d.gameStart, d.gameEnd) = getTimeRangeInfo();\n', '    }\n', '\n', '    // Garbage Collect previous funded amount record and log the status\n', '    function gcFundAmount() private {\n', '        f.hourlyStatusEth = 0;\n', '        f.monthlyStatusEth = 0;\n', '        f.yearlyStatusEth = 0;\n', '\n', '        f.hourlyStatusTok = 0;\n', '        f.monthlyStatusTok = 0;\n', '    }\n', '\n', '    function selectWinner(uint rand) onlyOwner {\n', '        uint luckyNumber = participants.length * rand / 100000000;\n', '        uint rewardDiv100 = 0;\n', '\n', '        uint participateRatio = participants.length;\n', '        if(participateRatio != 0){\n', '            if(c.currentGameTimeType == GameTime.Year){\n', '                participateRatio = participateRatio > p.yearlyMinParticipateRatio?participateRatio:p.yearlyMinParticipateRatio;\n', '            }else if(c.currentGameTimeType == GameTime.Month){\n', '                participateRatio = participateRatio > p.monthlyMinParticipateRatio?participateRatio:p.monthlyMinParticipateRatio;\n', '            }else if(c.currentGameTimeType == GameTime.Hour){\n', '                participateRatio = participateRatio > p.hourlyMinParticipateRatio?participateRatio:p.hourlyMinParticipateRatio;\n', '            }\n', '\n', '            if(participants[luckyNumber].currency == 1){\n', '                rewardDiv100 = participants[luckyNumber].value * participateRatio * p.boostPrizeEth / 100 / 100;\n', '                if(p.currentInGameTokWinRatio < p.inGameTokWinRatioMax){\n', '                    p.currentInGameTokWinRatio++;\n', '                }\n', '            }else if(participants[luckyNumber].currency == 2){\n', '                rewardDiv100 = (participants[luckyNumber].value / p.inGameTokPricePerEth * p.currentInGameTokWinRatio / 100) * participateRatio / 100;\n', '                if(p.currentInGameTokWinRatio > p.inGameTokWinRatioMin){\n', '                    p.currentInGameTokWinRatio--;\n', '                }\n', '            }\n', '\n', '            if(c.currentGameTimeType == GameTime.Year){\n', '                if(c.yearlyAmountEth >= rewardDiv100*104){  //1.04\n', '                    c.yearlyAmountEth = sub(c.yearlyAmountEth, rewardDiv100*104);\n', '                }else{\n', '                    rewardDiv100 = c.yearlyAmountEth / 104;\n', '                    c.yearlyAmountEth = 0;\n', '                }\n', '            }else if(c.currentGameTimeType == GameTime.Month){\n', '                if(c.monthlyAmountEth >= rewardDiv100*107){    //1.07\n', '                    c.monthlyAmountEth = sub(c.monthlyAmountEth, rewardDiv100*107);\n', '                }else{\n', '                    rewardDiv100 = c.monthlyAmountEth / 107;\n', '                    c.monthlyAmountEth = 0;\n', '                }\n', '                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3); //0.03, 1.1\n', '            }else if(c.currentGameTimeType == GameTime.Hour){\n', '                if(c.hourlyAmountEth >= rewardDiv100*110){\n', '                    c.hourlyAmountEth = sub(c.hourlyAmountEth, rewardDiv100*110);\n', '                }else{\n', '                    rewardDiv100 = c.hourlyAmountEth / 110;\n', '                    c.hourlyAmountEth = 0;\n', '                }\n', '                c.monthlyAmountEth = add(c.monthlyAmountEth,rewardDiv100 * 3);\n', '                c.yearlyAmountEth = add(c.yearlyAmountEth,rewardDiv100 * 3);\n', '            }\n', '            c.charityAmountEth = add(c.charityAmountEth,rewardDiv100 * 4);\n', '\n', '            winners[d.currentYear][participants[luckyNumber].sender] = add(winners[d.currentYear][participants[luckyNumber].sender],rewardDiv100*100);\n', '            winPrizes[d.currentYear] = add(winPrizes[d.currentYear],rewardDiv100*100);\n', '        \n', '            LogSelectWinner(rand, luckyNumber, participants[luckyNumber].sender, rewardDiv100*100, participants[luckyNumber].currency, participants[luckyNumber].value);\n', '\n', '            // Initialize participants\n', '            participants.length = 0;\n', '        }\n', '        if(c.gameType == GameType.Range){\n', '            refreshGameTime();\n', '        }\n', '        gcFundAmount();    \n', '    }\n', '\n', '    //claimAll\n', '    function getPrize(address sender) onlyOwner returns (uint ethPrize, uint tokPrize) {\n', '        ethPrize = add(winners[d.currentYear][sender],winners[d.currentYear-1][sender]);\n', '        tokPrize = add(tokTakers[d.currentYear][sender],tokTakers[d.currentYear-1][sender]);\n', '\n', '        winPrizes[d.currentYear] = sub(winPrizes[d.currentYear],winners[d.currentYear][sender]);\n', '        tokPrizes[d.currentYear] = sub(tokPrizes[d.currentYear],tokTakers[d.currentYear][sender]);\n', '        winners[d.currentYear][sender] = 0;\n', '        tokTakers[d.currentYear][sender] = 0;\n', '\n', '        winPrizes[d.currentYear-1] = sub(winPrizes[d.currentYear-1],winners[d.currentYear-1][sender]);\n', '        tokPrizes[d.currentYear-1] = sub(tokPrizes[d.currentYear-1],tokTakers[d.currentYear-1][sender]);\n', '        winners[d.currentYear-1][sender] = 0;\n', '        tokTakers[d.currentYear-1][sender] = 0;\n', '    }\n', '\n', '    // Point Game\n', '    function PointGameProcess(address sender, uint sendValue) private beforePointGame {\n', '        if(c.currentGameTimeType == GameTime.Year){\n', '            c.yearlyAmountEth = add(c.yearlyAmountEth, sendValue);\n', '            f.yearlyStatusEth = add(f.yearlyStatusEth, sendValue);\n', '        }else if(c.currentGameTimeType == GameTime.Month){\n', '            c.monthlyAmountEth = add(c.monthlyAmountEth, sendValue);\n', '            f.monthlyStatusEth = add(f.monthlyStatusEth, sendValue);\n', '        }else if(c.currentGameTimeType == GameTime.Hour){\n', '            c.hourlyAmountEth = add(c.hourlyAmountEth, sendValue);\n', '            f.hourlyStatusEth = add(f.hourlyStatusEth, sendValue);\n', '        }\n', '\n', '        PointGameParticipate(sender, sendValue, 1);\n', '        \n', '        if(p.bonusPerEth != 0){\n', '            tokTakers[d.currentYear][sender] = add(tokTakers[d.currentYear][sender], sendValue * p.bonusPerEth);\n', '            tokPrizes[d.currentYear] = add(tokPrizes[d.currentYear], sendValue * p.bonusPerEth);\n', '        }\n', '    }\n', '\n', '    function PointGameWithITG(address sender, uint tokenAmountToGame) private beforePointGame {\n', '        require(c.currentGameTimeType != GameTime.Year);\n', '\n', '        if(c.currentGameTimeType == GameTime.Month){\n', '            f.monthlyStatusTok = add(f.monthlyStatusTok, tokenAmountToGame);\n', '        }else if(c.currentGameTimeType == GameTime.Hour){\n', '            f.hourlyStatusTok = add(f.hourlyStatusTok, tokenAmountToGame);\n', '        }\n', '\n', '        PointGameParticipate(sender, tokenAmountToGame, 2);\n', '    }\n', '\n', '    function PointGameParticipate(address sender, uint sendValue, uint currency) private {\n', '        if(d.prevGameEnd != d.gameEnd){\n', '            selectWinner(1);\n', '        }\n', '        participants.length = 0;\n', '        participants.push(Participant(sender,sendValue,currency));\n', '\n', '        d.prevGameEnd = d.gameEnd;\n', '    }\n', '\n', '    function lossToCharity(uint year) onlyOwner returns (uint amt) {\n', '        require(year < d.currentYear-1);\n', '        \n', '        amt = winPrizes[year];\n', '        tokPrizes[year] = 0;\n', '        winPrizes[year] = 0;\n', '    }\n', '\n', '    function charityAmtToCharity() onlyOwner returns (uint amt) {\n', '        amt = c.charityAmountEth;\n', '        c.charityAmountEth = 0;\n', '    }\n', '\n', '    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyOwner{\n', '        c.hourlyAmountEth = add(c.hourlyAmountEth, hour);\n', '        c.monthlyAmountEth = add(c.monthlyAmountEth, month);\n', '        c.yearlyAmountEth = add(c.yearlyAmountEth, year);\n', '        c.charityAmountEth = add(c.charityAmountEth, charity);\n', '    }\n', '}\n', '\n', 'contract ITGToken is ITGTokenBase, Authable {\n', '    bytes32  public  symbol = "ITG";\n', '    uint256  public  decimals = 18;\n', '    bytes32   public  name = "ITG";\n', '\n', '    enum Status { CrowdSale, Game, Pause }\n', '    Status public status;\n', '\n', '    CrowdSale crowdSale;\n', '    Games games;\n', '    Voting voting;\n', '\n', '    mapping(address => uint) public withdrawRestriction;\n', '\n', '    uint public minEtherParticipate;\n', '    uint public minTokParticipate;\n', '\n', '    event LogFundTransfer(address sender, address to, uint amount, uint8 currency);\n', '\n', '    modifier beforeTransfer(){\n', '        require(withdrawRestriction[msg.sender] < now);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) beforeTransfer returns (bool success) {\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) beforeTransfer returns (bool success) {\n', '        uint _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_to] = add(balances[_to], _value);\n', '        balances[_from] = sub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = sub(_allowance, _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*  at initialization, setup the owner */\n', '    function ITGToken() {\n', '        owner = msg.sender;\n', '        totalSupply = 100000000 * 1 ether;\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        status = Status.Pause;\n', '    }\n', '    function () payable {\n', '       if(msg.value < minEtherParticipate){\n', '            throw;\n', '       }\n', '\n', '       if(status == Status.CrowdSale){\n', '            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\n', '            itgTokenTransfer(crowdSale.process(msg.sender,msg.value),true);\n', '       }else if(status == Status.Game){\n', '            LogFundTransfer(msg.sender, 0x0, msg.value, 1);\n', '            games.process(msg.sender, msg.value);\n', '       }else if(status == Status.Pause){\n', '            throw;\n', '       }\n', '    }\n', '\n', '    function setAttrs(address csAddr, address gmAddr, address vtAddr, Status _status, uint amtEth, uint amtTok) onlyAuth {\n', '        crowdSale = CrowdSale(csAddr);\n', '        games = Games(gmAddr);\n', '        voting = Voting(vtAddr);\n', '        status = _status;\n', '        minEtherParticipate = amtEth;\n', '        minTokParticipate = amtTok;\n', '    }\n', '\n', '    //getCrowdSaleToken\n', '    function USER_GET_CROWDSALE_TOKEN() {\n', '        itgTokenTransfer(crowdSale.getToken(msg.sender),true);\n', '    }\n', '\n', '    //vote\n', '    function USER_VOTE(uint voteId, uint candidateId){\n', '        uint addedToken;\n', '        uint lockUntil;\n', '        (addedToken, lockUntil) = voting.vote(msg.sender,balances[msg.sender],voteId,candidateId);\n', '        itgTokenTransfer(addedToken,true);\n', '\n', '        if(withdrawRestriction[msg.sender] < lockUntil){\n', '            withdrawRestriction[msg.sender] = lockUntil;\n', '        }\n', '    }\n', '\n', '    function voteInitiate(uint voteId, uint voteRewardPerUnit, uint voteWeightUnit, uint voteStart, uint voteEnd, uint maxCandidateId) onlyAuth {\n', '        voting.voteInitiate(voteId, voteRewardPerUnit, voteWeightUnit, voteStart, voteEnd, maxCandidateId);\n', '    }\n', '\n', '    function itgTokenTransfer(uint amt, bool fromOwner) private {\n', '        if(amt > 0){\n', '            if(fromOwner){\n', '                balances[owner] = sub(balances[owner], amt);\n', '                balances[msg.sender] = add(balances[msg.sender], amt);\n', '                Transfer(owner, msg.sender, amt);\n', '                LogFundTransfer(owner, msg.sender, amt, 2);\n', '            }else{\n', '                balances[owner] = add(balances[owner], amt);\n', '                balances[msg.sender] = sub(balances[msg.sender], amt);\n', '                Transfer(msg.sender, owner, amt);\n', '                LogFundTransfer(msg.sender, owner, amt, 2);\n', '            }\n', '        }\n', '    }\n', '\n', '    function ethTransfer(address target, uint amt) private {\n', '        if(amt > 0){\n', '            target.transfer(amt);\n', '            LogFundTransfer(0x0, target, amt, 1);\n', '        }\n', '    }\n', '\n', '    //gameWithToken\n', '    function USER_GAME_WITH_TOKEN(uint tokenAmountToGame) {\n', '        require(status == Status.Game);\n', '        require(balances[msg.sender] >= tokenAmountToGame * 1 ether);\n', '        require(tokenAmountToGame * 1 ether >= minTokParticipate);\n', '\n', '        itgTokenTransfer(tokenAmountToGame * 1 ether,false);\n', '\n', '        games.processWithITG(msg.sender, tokenAmountToGame * 1 ether);\n', '        \n', '    }\n', '\n', '    //getPrize\n', '    function USER_GET_PRIZE() {\n', '        uint ethPrize;\n', '        uint tokPrize;\n', '        (ethPrize, tokPrize) = games.getPrize(msg.sender);\n', '        itgTokenTransfer(tokPrize,true);\n', '        ethTransfer(msg.sender, ethPrize);\n', '    }\n', '\n', '    function selectWinner(uint rand) onlyAuth {\n', '        games.selectWinner(rand);\n', '    }\n', '\n', '    function burn(uint amt) onlyOwner {\n', '        balances[msg.sender] = sub(balances[msg.sender], amt);\n', '        totalSupply = sub(totalSupply,amt);\n', '    }\n', '\n', '    function mint(uint amt) onlyOwner {\n', '        balances[msg.sender] = add(balances[msg.sender], amt);\n', '        totalSupply = add(totalSupply,amt);\n', '    }\n', '\n', '    // We do not want big difference with our contract&#39;s balance and actual prize pool.\n', '    // So the ethereum that the winners didn&#39;t get over at least 1 year will be used for our charity business.\n', '    // We strongly hope winners get their prize after the game.\n', '    function lossToCharity(uint year,address charityAccount) onlyAuth {\n', '        ethTransfer(charityAccount, games.lossToCharity(year));\n', '    }\n', '\n', '    function charityAmtToCharity(address charityAccount) onlyOwner {\n', '        ethTransfer(charityAccount, games.charityAmtToCharity());\n', '    }\n', '\n', '    function distributeTokenSale(uint hour, uint month, uint year, uint charity) onlyAuth{\n', '        games.distributeTokenSale(hour, month, year, charity);\n', '    }\n', '\n', '}']