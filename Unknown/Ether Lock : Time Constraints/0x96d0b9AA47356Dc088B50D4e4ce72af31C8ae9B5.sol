['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract LoggedERC20 is Ownable {\n', '    /* Structures */\n', '    struct LogValueBlock {\n', '    uint256 value;\n', '    uint256 block;\n', '    }\n', '\n', '    /* Public variables of the token */\n', '    string public standard = &#39;LogValueBlockToken 0.1&#39;;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    LogValueBlock[] public loggedTotalSupply;\n', '\n', '    bool public locked;\n', '\n', '    uint256 public creationBlock;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => LogValueBlock[]) public loggedBalances;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function LoggedERC20(\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    uint8 decimalUnits,\n', '    string tokenSymbol,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) {\n', '        LogValueBlock memory valueBlock = LogValueBlock(initialSupply, block.number);\n', '\n', '        loggedTotalSupply.push(valueBlock);\n', '\n', '        if(transferAllSupplyToOwner) {\n', '            loggedBalances[msg.sender].push(valueBlock);\n', '        }\n', '        else {\n', '            loggedBalances[this].push(valueBlock);\n', '        }\n', '\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '        decimals = decimalUnits;                            // Amount of decimals for display purposes\n', '        locked = _locked;\n', '    }\n', '\n', '    function valueAt(LogValueBlock [] storage valueBlocks, uint256 block) internal returns (uint256) {\n', '        if(valueBlocks.length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        LogValueBlock memory prevLogValueBlock;\n', '\n', '        for(uint256 i = 0; i < valueBlocks.length; i++) {\n', '\n', '            LogValueBlock memory valueBlock = valueBlocks[i];\n', '\n', '            if(valueBlock.block > block) {\n', '                return prevLogValueBlock.value;\n', '            }\n', '\n', '            prevLogValueBlock = valueBlock;\n', '        }\n', '\n', '        return prevLogValueBlock.value;\n', '    }\n', '\n', '    function setBalance(address _address, uint256 value) internal {\n', '        loggedBalances[_address].push(LogValueBlock(value, block.number));\n', '    }\n', '\n', '    function totalSupply() returns (uint256) {\n', '        return valueAt(loggedTotalSupply, block.number);\n', '    }\n', '\n', '    function balanceOf(address _address) returns (uint256) {\n', '        return valueAt(loggedBalances[_address], block.number);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 value) internal returns (bool success) {\n', '        uint256 balanceFrom = valueAt(loggedBalances[msg.sender], block.number);\n', '        uint256 balanceTo = valueAt(loggedBalances[_to], block.number);\n', '\n', '        if(value == 0) {\n', '            return false;\n', '        }\n', '\n', '        if(frozenAccount[_from] == true) {\n', '            return false;\n', '        }\n', '\n', '        if(balanceFrom < value) {\n', '            return false;\n', '        }\n', '\n', '        if(balanceTo + value <= balanceTo) {\n', '            return false;\n', '        }\n', '\n', '        loggedBalances[_from].push(LogValueBlock(balanceFrom - value, block.number));\n', '        loggedBalances[_to].push(LogValueBlock(balanceTo + value, block.number));\n', '\n', '        Transfer(_from, _to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        require(locked == false);\n', '\n', '        bool status = transferInternal(msg.sender, _to, _value);\n', '\n', '        require(status == true);\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if(locked) {\n', '            return false;\n', '        }\n', '\n', '        bool _success = transferInternal(_from, _to, _value);\n', '\n', '        if(_success) {\n', '            allowance[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        return _success;\n', '    }\n', '}\n', '\n', 'contract LoggedDividend is Ownable, LoggedERC20 {\n', '    /* Structs */\n', '    struct Dividend {\n', '    uint256 id;\n', '\n', '    uint256 block;\n', '    uint256 time;\n', '    uint256 amount;\n', '\n', '    uint256 claimedAmount;\n', '    uint256 transferedBack;\n', '\n', '    uint256 totalSupply;\n', '    uint256 recycleTime;\n', '\n', '    bool recycled;\n', '\n', '    mapping (address => bool) claimed;\n', '    }\n', '\n', '    /* variables */\n', '    Dividend [] public dividends;\n', '\n', '    mapping (address => uint256) dividendsClaimed;\n', '\n', '    /* Events */\n', '    event DividendTransfered(uint256 id, address indexed _address, uint256 _block, uint256 _amount, uint256 _totalSupply);\n', '    event DividendClaimed(uint256 id, address indexed _address, uint256 _claim);\n', '    event UnclaimedDividendTransfer(uint256 id, uint256 _value);\n', '    event DividendRecycled(uint256 id, address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply);\n', '\n', '    function LoggedDividend(\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    uint8 decimalUnits,\n', '    string tokenSymbol,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) LoggedERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked) {\n', '\n', '    }\n', '\n', '    function addDividend(uint256 recycleTime) payable onlyOwner {\n', '        require(msg.value > 0);\n', '\n', '        uint256 id = dividends.length;\n', '        uint256 _totalSupply = valueAt(loggedTotalSupply, block.number);\n', '\n', '        dividends.push(\n', '        Dividend(\n', '        id,\n', '        block.number,\n', '        now,\n', '        msg.value,\n', '        0,\n', '        0,\n', '        _totalSupply,\n', '        recycleTime,\n', '        false\n', '        )\n', '        );\n', '\n', '        DividendTransfered(id, msg.sender, block.number, msg.value, _totalSupply);\n', '    }\n', '\n', '    function claimDividend(uint256 dividendId) public returns (bool) {\n', '        if(dividends.length - 1 < dividendId) {\n', '            return false;\n', '        }\n', '\n', '        Dividend storage dividend = dividends[dividendId];\n', '\n', '        if(dividend.claimed[msg.sender] == true) {\n', '            return false;\n', '        }\n', '\n', '        if(dividend.recycled == true) {\n', '            return false;\n', '        }\n', '\n', '        if(now >= dividend.time + dividend.recycleTime) {\n', '            return false;\n', '        }\n', '\n', '        uint256 balance = valueAt(loggedBalances[msg.sender], dividend.block);\n', '\n', '        if(balance == 0) {\n', '            return false;\n', '        }\n', '\n', '        uint256 claim = balance * dividend.amount / dividend.totalSupply;\n', '\n', '        dividend.claimed[msg.sender] = true;\n', '\n', '        dividend.claimedAmount = dividend.claimedAmount + claim;\n', '\n', '        if (claim > 0) {\n', '            msg.sender.transfer(claim);\n', '            DividendClaimed(dividendId, msg.sender, claim);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function claimDividends() public {\n', '        require(dividendsClaimed[msg.sender] < dividends.length);\n', '        for (uint i = dividendsClaimed[msg.sender]; i < dividends.length; i++) {\n', '            if ((dividends[i].claimed[msg.sender] == false) && (dividends[i].recycled == false)) {\n', '                dividendsClaimed[msg.sender] = i + 1;\n', '                claimDividend(i);\n', '            }\n', '        }\n', '    }\n', '\n', '    function recycleDividend(uint256 dividendId) public onlyOwner returns (bool success) {\n', '        if(dividends.length - 1 < dividendId) {\n', '            return false;\n', '        }\n', '\n', '        Dividend storage dividend = dividends[dividendId];\n', '\n', '        if(dividend.recycled) {\n', '            return false;\n', '        }\n', '\n', '        dividend.recycled = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function refundUnclaimedEthers(uint256 dividendId) public onlyOwner returns (bool success) {\n', '        if(dividends.length - 1 < dividendId) {\n', '            return false;\n', '        }\n', '\n', '        Dividend storage dividend = dividends[dividendId];\n', '\n', '        if(dividend.recycled == false) {\n', '            if(now < dividend.time + dividend.recycleTime) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        uint256 claimedBackAmount = dividend.amount - dividend.claimedAmount;\n', '\n', '        dividend.transferedBack = claimedBackAmount;\n', '\n', '        if(claimedBackAmount > 0) {\n', '            owner.transfer(claimedBackAmount);\n', '\n', '            UnclaimedDividendTransfer(dividendId, claimedBackAmount);\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '}\n', '\n', 'contract LoggedPhaseICO is LoggedDividend {\n', '    uint256 public icoSince;\n', '    uint256 public icoTill;\n', '\n', '    uint256 public collectedEthers;\n', '\n', '    Phase[] public phases;\n', '\n', '    struct Phase {\n', '    uint256 price;\n', '    uint256 maxAmount;\n', '    }\n', '\n', '    function LoggedPhaseICO(\n', '    uint256 _icoSince,\n', '    uint256 _icoTill,\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    string tokenSymbol,\n', '    uint8 precision,\n', '    bool transferAllSupplyToOwner,\n', '    bool _locked\n', '    ) LoggedDividend(initialSupply, tokenName, precision, tokenSymbol, transferAllSupplyToOwner, _locked) {\n', '        standard = &#39;LoggedPhaseICO 0.1&#39;;\n', '\n', '        icoSince = _icoSince;\n', '        icoTill = _icoTill;\n', '    }\n', '\n', '    function getIcoTokensAmount(uint256 collectedEthers, uint256 value) returns (uint256) {\n', '        uint256 amount;\n', '\n', '        uint256 newCollectedEthers = collectedEthers;\n', '        uint256 remainingValue = value;\n', '\n', '        for (uint i = 0; i < phases.length; i++) {\n', '            Phase storage phase = phases[i];\n', '\n', '            if(phase.maxAmount > newCollectedEthers) {\n', '                if (newCollectedEthers + remainingValue > phase.maxAmount) {\n', '                    uint256 diff = phase.maxAmount - newCollectedEthers;\n', '\n', '                    amount += diff * 1 ether / phase.price;\n', '\n', '                    remainingValue -= diff;\n', '                    newCollectedEthers += diff;\n', '                }\n', '                else {\n', '                    amount += remainingValue * 1 ether / phase.price;\n', '\n', '                    newCollectedEthers += remainingValue;\n', '\n', '                    remainingValue = 0;\n', '                }\n', '            }\n', '\n', '            if (remainingValue == 0) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (remainingValue > 0) {\n', '            return 0;\n', '        }\n', '\n', '        return amount;\n', '    }\n', '\n', '    function buy(address _address, uint256 time, uint256 value) internal returns (bool) {\n', '        if (locked == true) {\n', '            return false;\n', '        }\n', '\n', '        if (time < icoSince) {\n', '            return false;\n', '        }\n', '\n', '        if (time > icoTill) {\n', '            return false;\n', '        }\n', '\n', '        if (value == 0) {\n', '            return false;\n', '        }\n', '\n', '        uint256 amount = getIcoTokensAmount(collectedEthers, value);\n', '\n', '        if(amount == 0) {\n', '            return false;\n', '        }\n', '\n', '        uint256 selfBalance = valueAt(loggedBalances[this], block.number);\n', '        uint256 holderBalance = valueAt(loggedBalances[_address], block.number);\n', '\n', '        if (selfBalance < amount) {\n', '            return false;\n', '        }\n', '\n', '        if (holderBalance + amount < holderBalance) {\n', '            return false;\n', '        }\n', '\n', '        setBalance(_address, holderBalance + amount);\n', '        setBalance(this, selfBalance - amount);\n', '\n', '        collectedEthers += value;\n', '\n', '        Transfer(this, _address, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function () payable {\n', '        bool status = buy(msg.sender, now, msg.value);\n', '\n', '        require(status == true);\n', '    }\n', '}\n', '\n', 'contract Cajutel is LoggedPhaseICO {\n', '    function Cajutel(\n', '    uint256 initialSupply,\n', '    string tokenName,\n', '    string tokenSymbol,\n', '    address founder1,\n', '    address founder2,\n', '    address marketing,\n', '    uint256 icoSince,\n', '    uint256 icoTill\n', '    ) LoggedPhaseICO(icoSince, icoTill, initialSupply, tokenName, tokenSymbol, 18, false, false) {\n', '        standard = &#39;Cajutel 0.1&#39;;\n', '\n', '        phases.push(Phase(0.05 ether, 500 ether));\n', '        phases.push(Phase(0.075 ether, 750 ether + 500 ether));\n', '        phases.push(Phase(0.1 ether, 10000 ether + 750 ether + 500 ether));\n', '        phases.push(Phase(0.15 ether, 30000 ether + 10000 ether + 750 ether + 500 ether));\n', '        phases.push(Phase(0.2 ether, 80000 ether + 30000 ether + 10000 ether + 750 ether + 500 ether));\n', '\n', '        uint256 founder1Tokens = 900000000000000000000000;\n', '        uint256 founder2Tokens = 100000000000000000000000;\n', '        uint256 marketingTokens = 60000000000000000000000;\n', '\n', '        setBalance(founder1, founder1Tokens);\n', '\n', '        Transfer(this, founder1, founder1Tokens);\n', '\n', '        setBalance(founder2, founder2Tokens);\n', '\n', '        Transfer(this, founder2, founder2Tokens);\n', '\n', '        setBalance(marketing, marketingTokens);\n', '\n', '        Transfer(this, marketing, marketingTokens);\n', '\n', '        setBalance(this, initialSupply - founder1Tokens - founder2Tokens - marketingTokens);\n', '    }\n', '\n', '    function transferEthers() onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function setLocked(bool _locked) onlyOwner {\n', '        locked = _locked;\n', '    }\n', '\n', '    function setIcoDates(uint256 _icoSince, uint256 _icoTill) onlyOwner {\n', '        icoSince = _icoSince;\n', '        icoTill = _icoTill;\n', '    }\n', '}']