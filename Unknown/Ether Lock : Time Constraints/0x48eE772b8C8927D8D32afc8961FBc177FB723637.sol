['pragma solidity ^0.4.11;\n', 'contract SafeMath {\n', '    \n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner) ;\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Contribution is SafeMath, Owned {\n', '    uint256 public constant MIN_FUND = (0.01 ether);\n', '    uint256 public constant CRAWDSALE_START_DAY = 1;\n', '    uint256 public constant CRAWDSALE_END_DAY = 7;\n', '\n', '    uint256 public dayCycle = 24 hours;\n', '    uint256 public fundingStartTime = 0;\n', '    address public ethFundDeposit = 0;\n', '    address public investorDeposit = 0;\n', '    bool public isFinalize = false;\n', '    bool public isPause = false;\n', '    mapping (uint => uint) public dailyTotals; //total eth per day\n', '    mapping (uint => mapping (address => uint)) public userBuys; // otal eth per day per user\n', '    uint256 public totalContributedETH = 0; //total eth of 7 days\n', '\n', '    // events\n', '    event LogBuy (uint window, address user, uint amount);\n', '    event LogCreate (address ethFundDeposit, address investorDeposit, uint fundingStartTime, uint dayCycle);\n', '    event LogFinalize (uint finalizeTime);\n', '    event LogPause (uint finalizeTime, bool pause);\n', '\n', '    function Contribution (address _ethFundDeposit, address _investorDeposit, uint256 _fundingStartTime, uint256 _dayCycle)  {\n', '        require( now < _fundingStartTime );\n', '        require( _ethFundDeposit != address(0) );\n', '\n', '        fundingStartTime = _fundingStartTime;\n', '        dayCycle = _dayCycle;\n', '        ethFundDeposit = _ethFundDeposit;\n', '        investorDeposit = _investorDeposit;\n', '        LogCreate(_ethFundDeposit, _investorDeposit, _fundingStartTime,_dayCycle);\n', '    }\n', '\n', '    //crawdsale entry\n', '    function () payable {  \n', '        require(!isPause);\n', '        require(!isFinalize);\n', '        require( msg.value >= MIN_FUND ); //eth >= 0.01 at least\n', '\n', '        ethFundDeposit.transfer(msg.value);\n', '        buy(today(), msg.sender, msg.value);\n', '    }\n', '\n', '    function importExchangeSale(uint256 day, address _exchangeAddr, uint _amount) onlyOwner {\n', '        buy(day, _exchangeAddr, _amount);\n', '    }\n', '\n', '    function buy(uint256 day, address _addr, uint256 _amount) internal {\n', '        require( day >= CRAWDSALE_START_DAY && day <= CRAWDSALE_END_DAY ); \n', '\n', "        //record user's buy amount\n", '        userBuys[day][_addr] += _amount;\n', '        dailyTotals[day] += _amount;\n', '        totalContributedETH += _amount;\n', '\n', '        LogBuy(day, _addr, _amount);\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function pause(bool _isPause) onlyOwner {\n', '        isPause = _isPause;\n', '        LogPause(now,_isPause);\n', '    }\n', '\n', '    function finalize() onlyOwner {\n', '        isFinalize = true;\n', '        LogFinalize(now);\n', '    }\n', '\n', '    function today() constant returns (uint) {\n', '        return sub(now, fundingStartTime) / dayCycle + 1;\n', '    }\n', '}']