['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract. \n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value);\n', '  function approve(address spender, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if (_value != 0) require(allowed[msg.sender][_spender] == 0);\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Transmutable {\n', '  function transmute(address to, uint256 value) returns (bool, uint256);\n', '  event Transmuted(address indexed who, address baseContract, address transmutedContract, uint256 sourceQuantity, uint256 destQuantity);\n', '}\n', '\n', '// Contracts that can be transmuted to should implement this\n', 'contract TransmutableInterface {\n', '  function transmuted(uint256 _value) returns (bool, uint256);\n', '}\n', '\n', '\n', '\n', 'contract ERC20Mineable is StandardToken, ReentrancyGuard  {\n', '\n', '   uint256 public constant divisible_units = 10000000;\n', '   uint256 public constant decimals = 8;\n', '\n', '   uint256 public constant initial_reward = 100;\n', '\n', '   /** totalSupply in StandardToken refers to currently available supply\n', '   * maximumSupply refers to the cap on mining.\n', '   * When mining is finished totalSupply == maximumSupply\n', '   */\n', '   uint256 public maximumSupply;\n', '\n', '   // Current mining difficulty in Wei\n', '   uint256 public currentDifficultyWei;\n', '\n', '   // Minimum difficulty\n', '   uint256 public minimumDifficultyThresholdWei;\n', '\n', '   /** Block creation rate as number of Ethereum blocks per mining cycle\n', '   * 10 minutes at 12 seconds a block would be an internal block\n', '   * generated every 50 Ethereum blocks\n', '   */\n', '   uint256 public blockCreationRate;\n', '\n', '   /* difficultyAdjustmentPeriod should be every two weeks, or\n', '   * 2016 internal blocks.\n', '   */\n', '   uint256 public difficultyAdjustmentPeriod;\n', '\n', '   /* When was the last time we did a difficulty adjustment.\n', '   * In case mining ceases for indeterminate duration\n', '   */\n', '   uint256 public lastDifficultyAdjustmentEthereumBlock;\n', '\n', '   // Scale multiplier limit for difficulty adjustment\n', '   uint256 public constant difficultyScaleMultiplierLimit = 4;\n', '\n', '   // Total blocks mined helps us calculate the current reward\n', '   uint256 public totalBlocksMined;\n', '\n', '   // Reward adjustment period in Bitcoineum native blocks\n', '\n', '   uint256 public rewardAdjustmentPeriod; \n', '\n', '   // Total amount of Wei put into mining during current period\n', '   uint256 public totalWeiCommitted;\n', '   // Total amount of Wei expected for this mining period\n', '   uint256 public totalWeiExpected;\n', '\n', '   // Where to burn Ether\n', '   address public burnAddress;\n', '\n', '   /** Each block is created on a mining attempt if\n', '   * it does not already exist.\n', '   * this keeps track of the target difficulty at the time of creation\n', '   */\n', '\n', '   struct InternalBlock {\n', '      uint256 targetDifficultyWei;\n', '      uint256 blockNumber;\n', '      uint256 totalMiningWei;\n', '      uint256 totalMiningAttempts;\n', '      uint256 currentAttemptOffset;\n', '      bool payed;\n', '      address payee;\n', '      bool isCreated;\n', '   }\n', '\n', '   /** Mining attempts are given a projected offset to minimize\n', '   * keyspace overlap to increase fairness by reducing the redemption\n', '   * race condition\n', '   * This does not remove the possibility that two or more miners will\n', '   * be competing for the same award, especially if subsequent increases in\n', '   * wei from a single miner increase overlap\n', '   */\n', '   struct MiningAttempt {\n', '      uint256 projectedOffset;\n', '      uint256 value;\n', '      bool isCreated;\n', '   }\n', '\n', '   // Each guess gets assigned to a block\n', '   mapping (uint256 => InternalBlock) public blockData;\n', '   mapping (uint256 => mapping (address => MiningAttempt)) public miningAttempts;\n', '\n', '   // Utility related\n', '\n', '   function resolve_block_hash(uint256 _blockNum) public constant returns (bytes32) {\n', '       return block.blockhash(_blockNum);\n', '   }\n', '\n', '   function current_external_block() public constant returns (uint256) {\n', '       return block.number;\n', '   }\n', '\n', '   function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\n', '      // blockCreationRate is > 0\n', '      return _externalBlockNum / blockCreationRate;\n', '   }\n', '\n', '   // For the test harness verification\n', '   function get_internal_block_number() public constant returns (uint256) {\n', '     return external_to_internal_block_number(current_external_block());\n', '   }\n', '\n', '   // Initial state related\n', '   /** Dapps need to grab the initial state of the contract\n', '   * in order to properly initialize mining or tracking\n', '   * this is a single atomic function for getting state\n', '   * rather than scattering it across multiple public calls\n', '   * also returns the current blocks parameters\n', '   * or default params if it hasn&#39;t been created yet\n', '   * This is only called externally\n', '   */\n', '\n', '   function getContractState() external constant\n', '     returns (uint256,  // currentDifficultyWei\n', '              uint256,  // minimumDifficultyThresholdWei\n', '              uint256,  // blockNumber\n', '              uint256,  // blockCreationRate\n', '              uint256,  // difficultyAdjustmentPeriod\n', '              uint256,  // rewardAdjustmentPeriod\n', '              uint256,  // lastDifficultyAdustmentEthereumBlock\n', '              uint256,  // totalBlocksMined\n', '              uint256,  // totalWeiCommitted\n', '              uint256,  // totalWeiExpected\n', '              uint256,  // b.targetDifficultyWei\n', '              uint256,  // b.totalMiningWei\n', '              uint256  // b.currentAttemptOffset\n', '              ) {\n', '    InternalBlock memory b;\n', '    uint256 _blockNumber = external_to_internal_block_number(current_external_block());\n', '    if (!blockData[_blockNumber].isCreated) {\n', '        b = InternalBlock(\n', '                       {targetDifficultyWei: currentDifficultyWei,\n', '                       blockNumber: _blockNumber,\n', '                       totalMiningWei: 0,\n', '                       totalMiningAttempts: 0,\n', '                       currentAttemptOffset: 0,\n', '                       payed: false,\n', '                       payee: 0,\n', '                       isCreated: true\n', '                       });\n', '    } else {\n', '         b = blockData[_blockNumber];\n', '    }\n', '    return (currentDifficultyWei,\n', '            minimumDifficultyThresholdWei,\n', '            _blockNumber,\n', '            blockCreationRate,\n', '            difficultyAdjustmentPeriod,\n', '            rewardAdjustmentPeriod,\n', '            lastDifficultyAdjustmentEthereumBlock,\n', '            totalBlocksMined,\n', '            totalWeiCommitted,\n', '            totalWeiExpected,\n', '            b.targetDifficultyWei,\n', '            b.totalMiningWei,\n', '            b.currentAttemptOffset);\n', '   }\n', '\n', '   function getBlockData(uint256 _blockNum) public constant returns (uint256, uint256, uint256, uint256, uint256, bool, address, bool) {\n', '    InternalBlock memory iBlock = blockData[_blockNum];\n', '    return (iBlock.targetDifficultyWei,\n', '    iBlock.blockNumber,\n', '    iBlock.totalMiningWei,\n', '    iBlock.totalMiningAttempts,\n', '    iBlock.currentAttemptOffset,\n', '    iBlock.payed,\n', '    iBlock.payee,\n', '    iBlock.isCreated);\n', '   }\n', '\n', '   function getMiningAttempt(uint256 _blockNum, address _who) public constant returns (uint256, uint256, bool) {\n', '     if (miningAttempts[_blockNum][_who].isCreated) {\n', '        return (miningAttempts[_blockNum][_who].projectedOffset,\n', '        miningAttempts[_blockNum][_who].value,\n', '        miningAttempts[_blockNum][_who].isCreated);\n', '     } else {\n', '        return (0, 0, false);\n', '     }\n', '   }\n', '\n', '   // Mining Related\n', '\n', '   modifier blockCreated(uint256 _blockNum) {\n', '     require(blockData[_blockNum].isCreated);\n', '     _;\n', '   }\n', '\n', '   modifier blockRedeemed(uint256 _blockNum) {\n', '     require(_blockNum != current_external_block());\n', '     /* Should capture if the blockdata is payed\n', '     *  or if it does not exist in the blockData mapping\n', '     */\n', '     require(blockData[_blockNum].isCreated);\n', '     require(!blockData[_blockNum].payed);\n', '     _;\n', '   }\n', '\n', '   modifier initBlock(uint256 _blockNum) {\n', '     require(_blockNum != current_external_block());\n', '\n', '     if (!blockData[_blockNum].isCreated) {\n', '       // This is a new block, adjust difficulty\n', '       adjust_difficulty();\n', '\n', '       // Create new block for tracking\n', '       blockData[_blockNum] = InternalBlock(\n', '                                     {targetDifficultyWei: currentDifficultyWei,\n', '                                      blockNumber: _blockNum,\n', '                                      totalMiningWei: 0,\n', '                                      totalMiningAttempts: 0,\n', '                                      currentAttemptOffset: 0,\n', '                                      payed: false,\n', '                                      payee: 0,\n', '                                      isCreated: true\n', '                                      });\n', '     }\n', '     _;\n', '   }\n', '\n', '   modifier isValidAttempt() {\n', '     /* If the Ether for this mining attempt is less than minimum\n', '     * 0.0000001 % of total difficulty\n', '     */\n', '     uint256 minimum_wei = currentDifficultyWei / divisible_units; \n', '     require (msg.value >= minimum_wei);\n', '\n', '     /* Let&#39;s bound the value to guard against potential overflow\n', '     * i.e max int, or an underflow bug\n', '     * This is a single attempt\n', '     */\n', '     require(msg.value <= (1000000 ether));\n', '     _;\n', '   }\n', '\n', '   modifier alreadyMined(uint256 blockNumber, address sender) {\n', '     require(blockNumber != current_external_block()); \n', '    /* We are only going to allow one mining attempt per block per account\n', '    *  This prevents stuffing and make it easier for us to track boundaries\n', '    */\n', '    \n', '    // This user already made a mining attempt for this block\n', '    require(!checkMiningAttempt(blockNumber, sender));\n', '    _;\n', '   }\n', '\n', '   function checkMiningActive() public constant returns (bool) {\n', '      return (totalSupply < maximumSupply);\n', '   }\n', '\n', '   modifier isMiningActive() {\n', '      require(checkMiningActive());\n', '      _;\n', '   }\n', '\n', '   function burn(uint256 value) internal {\n', '      /* We don&#39;t really care if the burn fails for some\n', '      *  weird reason.\n', '      */\n', '      bool ret = burnAddress.send(value);\n', '      /* If we cannot burn this ether, than the contract might\n', '      *  be under some kind of stack attack.\n', '      *  Even though it shouldn&#39;t matter, let&#39;s err on the side of\n', '      *  caution and throw in case there is some invalid state.\n', '      */\n', '      require (ret);\n', '   }\n', '\n', '   event MiningAttemptEvent(\n', '       address indexed _from,\n', '       uint256 _value,\n', '       uint256 indexed _blockNumber,\n', '       uint256 _totalMinedWei,\n', '       uint256 _targetDifficultyWei\n', '   );\n', '\n', '   event LogEvent(\n', '       string _info\n', '   );\n', '\n', '   /**\n', '   * @dev Add a mining attempt for the current internal block\n', '   * Initialize an empty block if not created\n', '   * Invalidate this mining attempt if the block has been paid out\n', '   */\n', '\n', '   function mine() external payable \n', '                           nonReentrant\n', '                           isValidAttempt\n', '                           isMiningActive\n', '                           initBlock(external_to_internal_block_number(current_external_block()))\n', '                           blockRedeemed(external_to_internal_block_number(current_external_block()))\n', '                           alreadyMined(external_to_internal_block_number(current_external_block()), msg.sender) returns (bool) {\n', '      /* Let&#39;s immediately adjust the difficulty\n', '      *  In case an abnormal period of time has elapsed\n', '      *  nobody has been mining etc.\n', '      *  Will let us recover the network even if the\n', '      * difficulty spikes to some absurd amount\n', '      * this should only happen on the first attempt on a block\n', '      */\n', '      uint256 internalBlockNum = external_to_internal_block_number(current_external_block());\n', '      miningAttempts[internalBlockNum][msg.sender] =\n', '                     MiningAttempt({projectedOffset: blockData[internalBlockNum].currentAttemptOffset,\n', '                                    value: msg.value,\n', '                                    isCreated: true});\n', '\n', '      // Increment the mining attempts for this block\n', '      blockData[internalBlockNum].totalMiningAttempts += 1;\n', '      blockData[internalBlockNum].totalMiningWei += msg.value;\n', '      totalWeiCommitted += msg.value;\n', '\n', '      /* We are trying to stack mining attempts into their relative\n', '      *  positions in the key space.\n', '      */\n', '      blockData[internalBlockNum].currentAttemptOffset += msg.value;\n', '      MiningAttemptEvent(msg.sender,\n', '                         msg.value,\n', '                         internalBlockNum,\n', '                         blockData[internalBlockNum].totalMiningWei,\n', '                         blockData[internalBlockNum].targetDifficultyWei\n', '                         );\n', '      // All mining attempt Ether is burned\n', '      burn(msg.value);\n', '      return true;\n', '   }\n', '\n', '   // Redemption Related\n', '\n', '   modifier userMineAttempted(uint256 _blockNum, address _user) {\n', '      require(checkMiningAttempt(_blockNum, _user));\n', '      _;\n', '   }\n', '   \n', '   modifier isBlockMature(uint256 _blockNumber) {\n', '      require(_blockNumber != current_external_block());\n', '      require(checkBlockMature(_blockNumber, current_external_block()));\n', '      require(checkRedemptionWindow(_blockNumber, current_external_block()));\n', '      _;\n', '   }\n', '\n', '   // Just in case this block falls outside of the available\n', '   // block range, possibly because of a change in network params\n', '   modifier isBlockReadable(uint256 _blockNumber) {\n', '      InternalBlock memory iBlock = blockData[_blockNumber];\n', '      uint256 targetBlockNum = targetBlockNumber(_blockNumber);\n', '      require(resolve_block_hash(targetBlockNum) != 0);\n', '      _;\n', '   }\n', '\n', '   function calculate_difficulty_attempt(uint256 targetDifficultyWei,\n', '                                         uint256 totalMiningWei,\n', '                                         uint256 value) public constant returns (uint256) {\n', '      // The total amount of Wei sent for this mining attempt exceeds the difficulty level\n', '      // So the calculation of percentage keyspace should be done on the total wei.\n', '      uint256 selectedDifficultyWei = 0;\n', '      if (totalMiningWei > targetDifficultyWei) {\n', '         selectedDifficultyWei = totalMiningWei;\n', '      } else {\n', '         selectedDifficultyWei = targetDifficultyWei; \n', '      }\n', '\n', '      /* normalize the value against the entire key space\n', '       * Multiply it out because we do not have floating point\n', '       * 10000000 is .0000001 % increments\n', '      */\n', '\n', '      uint256 intermediate = ((value * divisible_units) / selectedDifficultyWei);\n', '      uint256 max_int = 0;\n', '      // Underflow to maxint\n', '      max_int = max_int - 1;\n', '\n', '      if (intermediate >= divisible_units) {\n', '         return max_int;\n', '      } else {\n', '         return intermediate * (max_int / divisible_units);\n', '      }\n', '   }\n', '\n', '   function calculate_range_attempt(uint256 difficulty, uint256 offset) public constant returns (uint256, uint256) {\n', '       /* Both the difficulty and offset should be normalized\n', '       * against the difficulty scale.\n', '       * If they are not we might have an integer overflow\n', '       */\n', '       require(offset + difficulty >= offset);\n', '       return (offset, offset+difficulty);\n', '   }\n', '\n', '   // Total allocated reward is proportional to burn contribution to limit incentive for\n', '   // hash grinding attacks\n', '   function calculate_proportional_reward(uint256 _baseReward, uint256 _userContributionWei, uint256 _totalCommittedWei) public constant returns (uint256) {\n', '   require(_userContributionWei <= _totalCommittedWei);\n', '   require(_userContributionWei > 0);\n', '   require(_totalCommittedWei > 0);\n', '      uint256 intermediate = ((_userContributionWei * divisible_units) / _totalCommittedWei);\n', '\n', '      if (intermediate >= divisible_units) {\n', '         return _baseReward;\n', '      } else {\n', '         return intermediate * (_baseReward / divisible_units);\n', '      }\n', '   }\n', '\n', '   function calculate_base_mining_reward(uint256 _totalBlocksMined) public constant returns (uint256) {\n', '      /* Block rewards starts at initial_reward\n', '      *  Every 10 minutes\n', '      *  Block reward decreases by 50% every 210000 blocks\n', '      */\n', '      uint256 mined_block_period = 0;\n', '      if (_totalBlocksMined < 210000) {\n', '           mined_block_period = 210000;\n', '      } else {\n', '           mined_block_period = _totalBlocksMined;\n', '      }\n', '\n', '      // Again we have to do this iteratively because of floating\n', '      // point limitations in solidity.\n', '      uint256 total_reward = initial_reward * (10 ** decimals); \n', '      uint256 i = 1;\n', '      uint256 rewardperiods = mined_block_period / 210000;\n', '      if (mined_block_period % 210000 > 0) {\n', '         rewardperiods += 1;\n', '      }\n', '      for (i=1; i < rewardperiods; i++) {\n', '          total_reward = total_reward / 2;\n', '      }\n', '      return total_reward;\n', '   }\n', '\n', '   // Break out the expected wei calculation\n', '   // for easy external testing\n', '   function calculate_next_expected_wei(uint256 _totalWeiCommitted,\n', '                                        uint256 _totalWeiExpected,\n', '                                        uint256 _minimumDifficultyThresholdWei,\n', '                                        uint256 _difficultyScaleMultiplierLimit) public constant\n', '                                        returns (uint256) {\n', '          \n', '          /* The adjustment window has been fulfilled\n', '          *  The new difficulty should be bounded by the total wei actually spent\n', '          * capped at difficultyScaleMultiplierLimit times\n', '          */\n', '          uint256 lowerBound = _totalWeiExpected / _difficultyScaleMultiplierLimit;\n', '          uint256 upperBound = _totalWeiExpected * _difficultyScaleMultiplierLimit;\n', '\n', '          if (_totalWeiCommitted < lowerBound) {\n', '              _totalWeiExpected = lowerBound;\n', '          } else if (_totalWeiCommitted > upperBound) {\n', '              _totalWeiExpected = upperBound;\n', '          } else {\n', '              _totalWeiExpected = _totalWeiCommitted;\n', '          }\n', '\n', '          /* If difficulty drops too low lets set it to our minimum.\n', '          *  This may halt coin creation, but obviously does not affect\n', '          *  token transactions.\n', '          */\n', '          if (_totalWeiExpected < _minimumDifficultyThresholdWei) {\n', '              _totalWeiExpected = _minimumDifficultyThresholdWei;\n', '          }\n', '\n', '          return _totalWeiExpected;\n', '    }\n', '\n', '   function adjust_difficulty() internal {\n', '      /* Total blocks mined might not be increasing if the \n', '      *  difficulty is too high. So we should instead base the adjustment\n', '      * on the progression of the Ethereum network.\n', '      * So that the difficulty can increase/deflate regardless of sparse\n', '      * mining attempts\n', '      */\n', '\n', '      if ((current_external_block() - lastDifficultyAdjustmentEthereumBlock) > (difficultyAdjustmentPeriod * blockCreationRate)) {\n', '\n', '          // Get the new total wei expected via static function\n', '          totalWeiExpected = calculate_next_expected_wei(totalWeiCommitted, totalWeiExpected, minimumDifficultyThresholdWei * difficultyAdjustmentPeriod, difficultyScaleMultiplierLimit);\n', '\n', '          currentDifficultyWei = totalWeiExpected / difficultyAdjustmentPeriod;\n', '\n', '          // Regardless of difficulty adjustment, let us zero totalWeiCommited\n', '          totalWeiCommitted = 0;\n', '\n', '          // Lets reset the difficulty adjustment block target\n', '          lastDifficultyAdjustmentEthereumBlock = current_external_block();\n', '\n', '      }\n', '   }\n', '\n', '   event BlockClaimedEvent(\n', '       address indexed _from,\n', '       address indexed _forCreditTo,\n', '       uint256 _reward,\n', '       uint256 indexed _blockNumber\n', '   );\n', '\n', '   modifier onlyWinner(uint256 _blockNumber) {\n', '      require(checkWinning(_blockNumber));\n', '      _;\n', '   }\n', '\n', '\n', '   // Helper function to avoid stack issues\n', '   function calculate_reward(uint256 _totalBlocksMined, address _sender, uint256 _blockNumber) public constant returns (uint256) {\n', '      return calculate_proportional_reward(calculate_base_mining_reward(_totalBlocksMined), miningAttempts[_blockNumber][_sender].value, blockData[_blockNumber].totalMiningWei); \n', '   }\n', '\n', '   /** \n', '   * @dev Claim the mining reward for a given block\n', '   * @param _blockNumber The internal block that the user is trying to claim\n', '   * @param forCreditTo When the miner account is different from the account\n', '   * where we want to deliver the redeemed Bitcoineum. I.e Hard wallet.\n', '   */\n', '   function claim(uint256 _blockNumber, address forCreditTo)\n', '                  nonReentrant\n', '                  blockRedeemed(_blockNumber)\n', '                  isBlockMature(_blockNumber)\n', '                  isBlockReadable(_blockNumber)\n', '                  userMineAttempted(_blockNumber, msg.sender)\n', '                  onlyWinner(_blockNumber)\n', '                  external returns (bool) {\n', '      /* If attempt is valid, invalidate redemption\n', '      *  Difficulty is adjusted here\n', '      *  and on bidding, in case bidding stalls out for some\n', '      *  unusual period of time.\n', '      *  Do everything, then adjust supply and balance\n', '      */\n', '      blockData[_blockNumber].payed = true;\n', '      blockData[_blockNumber].payee = msg.sender;\n', '      totalBlocksMined = totalBlocksMined + 1;\n', '\n', '      uint256 proportional_reward = calculate_reward(totalBlocksMined, msg.sender, _blockNumber);\n', '      balances[forCreditTo] = balances[forCreditTo].add(proportional_reward);\n', '      totalSupply += proportional_reward;\n', '      BlockClaimedEvent(msg.sender, forCreditTo,\n', '                        proportional_reward,\n', '                        _blockNumber);\n', '      // Mining rewards should show up as ERC20 transfer events\n', '      // So that ERC20 scanners will see token creation.\n', '      Transfer(this, forCreditTo, proportional_reward);\n', '      return true;\n', '   }\n', '\n', '   /** \n', '   * @dev Claim the mining reward for a given block\n', '   * @param _blockNum The internal block that the user is trying to claim\n', '   */\n', '   function isBlockRedeemed(uint256 _blockNum) constant public returns (bool) {\n', '     if (!blockData[_blockNum].isCreated) {\n', '         return false;\n', '     } else {\n', '         return blockData[_blockNum].payed;\n', '     }\n', '   }\n', '\n', '   /** \n', '   * @dev Get the target block in the winning equation \n', '   * @param _blockNum is the internal block number to get the target block for\n', '   */\n', '   function targetBlockNumber(uint256 _blockNum) constant public returns (uint256) {\n', '      return ((_blockNum + 1) * blockCreationRate);\n', '   }\n', '\n', '   /** \n', '   * @dev Check whether a given block is mature \n', '   * @param _blockNum is the internal block number to check \n', '   */\n', '   function checkBlockMature(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\n', '     return (_externalblock >= targetBlockNumber(_blockNum));\n', '   }\n', '\n', '   /**\n', '   * @dev Check the redemption window for a given block\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '\n', '   function checkRedemptionWindow(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\n', '       uint256 _targetblock = targetBlockNumber(_blockNum);\n', '       return _externalblock >= _targetblock && _externalblock < (_targetblock + 256);\n', '   }\n', '\n', '   /** \n', '   * @dev Check whether a mining attempt was made by sender for this block\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\n', '       return miningAttempts[_blockNum][_sender].isCreated;\n', '   }\n', '\n', '   /** \n', '   * @dev Did the user win a specific block and can claim it?\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '   function checkWinning(uint256 _blockNum) constant public returns (bool) {\n', '     if (checkMiningAttempt(_blockNum, msg.sender) && checkBlockMature(_blockNum, current_external_block())) {\n', '\n', '      InternalBlock memory iBlock = blockData[_blockNum];\n', '      uint256 targetBlockNum = targetBlockNumber(iBlock.blockNumber);\n', '      MiningAttempt memory attempt = miningAttempts[_blockNum][msg.sender];\n', '\n', '      uint256 difficultyAttempt = calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.value);\n', '      uint256 beginRange;\n', '      uint256 endRange;\n', '      uint256 targetBlockHashInt;\n', '\n', '      (beginRange, endRange) = calculate_range_attempt(difficultyAttempt,\n', '          calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.projectedOffset)); \n', '      targetBlockHashInt = uint256(keccak256(resolve_block_hash(targetBlockNum)));\n', '   \n', '      // This is the winning condition\n', '      if ((beginRange < targetBlockHashInt) && (endRange >= targetBlockHashInt))\n', '      {\n', '        return true;\n', '      }\n', '     \n', '     }\n', '\n', '     return false;\n', '     \n', '   }\n', '\n', '}\n', '\n', '\n', '\n', 'contract Bitcoineum is ERC20Mineable, Transmutable {\n', '\n', ' string public constant name = "Bitcoineum";\n', ' string public constant symbol = "BTE";\n', ' uint256 public constant decimals = 8;\n', ' uint256 public constant INITIAL_SUPPLY = 0;\n', '\n', ' // 21 Million coins at 8 decimal places\n', ' uint256 public constant MAX_SUPPLY = 21000000 * (10**8);\n', ' \n', ' function Bitcoineum() {\n', '\n', '    totalSupply = INITIAL_SUPPLY;\n', '    maximumSupply = MAX_SUPPLY;\n', '\n', '    // 0.0001 Ether per block\n', '    // Difficulty is so low because it doesn&#39;t include\n', '    // gas prices for execution\n', '    currentDifficultyWei = 100 szabo;\n', '    minimumDifficultyThresholdWei = 100 szabo;\n', '    \n', '    // Ethereum blocks to internal blocks\n', '    // Roughly 10 minute windows\n', '    blockCreationRate = 50;\n', '\n', '    // Adjust difficulty x claimed internal blocks\n', '    difficultyAdjustmentPeriod = 2016;\n', '\n', '    // Reward adjustment\n', '\n', '    rewardAdjustmentPeriod = 210000;\n', '\n', '    // This is the effective block counter, since block windows are discontinuous\n', '    totalBlocksMined = 0;\n', '\n', '    totalWeiExpected = difficultyAdjustmentPeriod * currentDifficultyWei;\n', '\n', '    // Balance of this address can be used to determine total burned value\n', '    // not including fees spent.\n', '    burnAddress = 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\n', '\n', '    lastDifficultyAdjustmentEthereumBlock = block.number; \n', ' }\n', '\n', '\n', '   /**\n', '   * @dev Bitcoineum can extend proof of burn into convertable units\n', '   * that have token specific properties\n', '   * @param to is the address of the contract that Bitcoineum is converting into\n', '   * @param value is the quantity of Bitcoineum to attempt to convert\n', '   */\n', '\n', '  function transmute(address to, uint256 value) nonReentrant returns (bool, uint256) {\n', '    require(value > 0);\n', '    require(balances[msg.sender] >= value);\n', '    require(totalSupply >= value);\n', '    balances[msg.sender] = balances[msg.sender].sub(value);\n', '    totalSupply = totalSupply.sub(value);\n', '    TransmutableInterface target = TransmutableInterface(to);\n', '    bool _result = false;\n', '    uint256 _total = 0;\n', '    (_result, _total) = target.transmuted(value);\n', '    require (_result);\n', '    Transmuted(msg.sender, this, to, value, _total);\n', '    return (_result, _total);\n', '  }\n', '\n', ' }']
['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract. \n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value);\n', '  function approve(address spender, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if (_value != 0) require(allowed[msg.sender][_spender] == 0);\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Transmutable {\n', '  function transmute(address to, uint256 value) returns (bool, uint256);\n', '  event Transmuted(address indexed who, address baseContract, address transmutedContract, uint256 sourceQuantity, uint256 destQuantity);\n', '}\n', '\n', '// Contracts that can be transmuted to should implement this\n', 'contract TransmutableInterface {\n', '  function transmuted(uint256 _value) returns (bool, uint256);\n', '}\n', '\n', '\n', '\n', 'contract ERC20Mineable is StandardToken, ReentrancyGuard  {\n', '\n', '   uint256 public constant divisible_units = 10000000;\n', '   uint256 public constant decimals = 8;\n', '\n', '   uint256 public constant initial_reward = 100;\n', '\n', '   /** totalSupply in StandardToken refers to currently available supply\n', '   * maximumSupply refers to the cap on mining.\n', '   * When mining is finished totalSupply == maximumSupply\n', '   */\n', '   uint256 public maximumSupply;\n', '\n', '   // Current mining difficulty in Wei\n', '   uint256 public currentDifficultyWei;\n', '\n', '   // Minimum difficulty\n', '   uint256 public minimumDifficultyThresholdWei;\n', '\n', '   /** Block creation rate as number of Ethereum blocks per mining cycle\n', '   * 10 minutes at 12 seconds a block would be an internal block\n', '   * generated every 50 Ethereum blocks\n', '   */\n', '   uint256 public blockCreationRate;\n', '\n', '   /* difficultyAdjustmentPeriod should be every two weeks, or\n', '   * 2016 internal blocks.\n', '   */\n', '   uint256 public difficultyAdjustmentPeriod;\n', '\n', '   /* When was the last time we did a difficulty adjustment.\n', '   * In case mining ceases for indeterminate duration\n', '   */\n', '   uint256 public lastDifficultyAdjustmentEthereumBlock;\n', '\n', '   // Scale multiplier limit for difficulty adjustment\n', '   uint256 public constant difficultyScaleMultiplierLimit = 4;\n', '\n', '   // Total blocks mined helps us calculate the current reward\n', '   uint256 public totalBlocksMined;\n', '\n', '   // Reward adjustment period in Bitcoineum native blocks\n', '\n', '   uint256 public rewardAdjustmentPeriod; \n', '\n', '   // Total amount of Wei put into mining during current period\n', '   uint256 public totalWeiCommitted;\n', '   // Total amount of Wei expected for this mining period\n', '   uint256 public totalWeiExpected;\n', '\n', '   // Where to burn Ether\n', '   address public burnAddress;\n', '\n', '   /** Each block is created on a mining attempt if\n', '   * it does not already exist.\n', '   * this keeps track of the target difficulty at the time of creation\n', '   */\n', '\n', '   struct InternalBlock {\n', '      uint256 targetDifficultyWei;\n', '      uint256 blockNumber;\n', '      uint256 totalMiningWei;\n', '      uint256 totalMiningAttempts;\n', '      uint256 currentAttemptOffset;\n', '      bool payed;\n', '      address payee;\n', '      bool isCreated;\n', '   }\n', '\n', '   /** Mining attempts are given a projected offset to minimize\n', '   * keyspace overlap to increase fairness by reducing the redemption\n', '   * race condition\n', '   * This does not remove the possibility that two or more miners will\n', '   * be competing for the same award, especially if subsequent increases in\n', '   * wei from a single miner increase overlap\n', '   */\n', '   struct MiningAttempt {\n', '      uint256 projectedOffset;\n', '      uint256 value;\n', '      bool isCreated;\n', '   }\n', '\n', '   // Each guess gets assigned to a block\n', '   mapping (uint256 => InternalBlock) public blockData;\n', '   mapping (uint256 => mapping (address => MiningAttempt)) public miningAttempts;\n', '\n', '   // Utility related\n', '\n', '   function resolve_block_hash(uint256 _blockNum) public constant returns (bytes32) {\n', '       return block.blockhash(_blockNum);\n', '   }\n', '\n', '   function current_external_block() public constant returns (uint256) {\n', '       return block.number;\n', '   }\n', '\n', '   function external_to_internal_block_number(uint256 _externalBlockNum) public constant returns (uint256) {\n', '      // blockCreationRate is > 0\n', '      return _externalBlockNum / blockCreationRate;\n', '   }\n', '\n', '   // For the test harness verification\n', '   function get_internal_block_number() public constant returns (uint256) {\n', '     return external_to_internal_block_number(current_external_block());\n', '   }\n', '\n', '   // Initial state related\n', '   /** Dapps need to grab the initial state of the contract\n', '   * in order to properly initialize mining or tracking\n', '   * this is a single atomic function for getting state\n', '   * rather than scattering it across multiple public calls\n', '   * also returns the current blocks parameters\n', "   * or default params if it hasn't been created yet\n", '   * This is only called externally\n', '   */\n', '\n', '   function getContractState() external constant\n', '     returns (uint256,  // currentDifficultyWei\n', '              uint256,  // minimumDifficultyThresholdWei\n', '              uint256,  // blockNumber\n', '              uint256,  // blockCreationRate\n', '              uint256,  // difficultyAdjustmentPeriod\n', '              uint256,  // rewardAdjustmentPeriod\n', '              uint256,  // lastDifficultyAdustmentEthereumBlock\n', '              uint256,  // totalBlocksMined\n', '              uint256,  // totalWeiCommitted\n', '              uint256,  // totalWeiExpected\n', '              uint256,  // b.targetDifficultyWei\n', '              uint256,  // b.totalMiningWei\n', '              uint256  // b.currentAttemptOffset\n', '              ) {\n', '    InternalBlock memory b;\n', '    uint256 _blockNumber = external_to_internal_block_number(current_external_block());\n', '    if (!blockData[_blockNumber].isCreated) {\n', '        b = InternalBlock(\n', '                       {targetDifficultyWei: currentDifficultyWei,\n', '                       blockNumber: _blockNumber,\n', '                       totalMiningWei: 0,\n', '                       totalMiningAttempts: 0,\n', '                       currentAttemptOffset: 0,\n', '                       payed: false,\n', '                       payee: 0,\n', '                       isCreated: true\n', '                       });\n', '    } else {\n', '         b = blockData[_blockNumber];\n', '    }\n', '    return (currentDifficultyWei,\n', '            minimumDifficultyThresholdWei,\n', '            _blockNumber,\n', '            blockCreationRate,\n', '            difficultyAdjustmentPeriod,\n', '            rewardAdjustmentPeriod,\n', '            lastDifficultyAdjustmentEthereumBlock,\n', '            totalBlocksMined,\n', '            totalWeiCommitted,\n', '            totalWeiExpected,\n', '            b.targetDifficultyWei,\n', '            b.totalMiningWei,\n', '            b.currentAttemptOffset);\n', '   }\n', '\n', '   function getBlockData(uint256 _blockNum) public constant returns (uint256, uint256, uint256, uint256, uint256, bool, address, bool) {\n', '    InternalBlock memory iBlock = blockData[_blockNum];\n', '    return (iBlock.targetDifficultyWei,\n', '    iBlock.blockNumber,\n', '    iBlock.totalMiningWei,\n', '    iBlock.totalMiningAttempts,\n', '    iBlock.currentAttemptOffset,\n', '    iBlock.payed,\n', '    iBlock.payee,\n', '    iBlock.isCreated);\n', '   }\n', '\n', '   function getMiningAttempt(uint256 _blockNum, address _who) public constant returns (uint256, uint256, bool) {\n', '     if (miningAttempts[_blockNum][_who].isCreated) {\n', '        return (miningAttempts[_blockNum][_who].projectedOffset,\n', '        miningAttempts[_blockNum][_who].value,\n', '        miningAttempts[_blockNum][_who].isCreated);\n', '     } else {\n', '        return (0, 0, false);\n', '     }\n', '   }\n', '\n', '   // Mining Related\n', '\n', '   modifier blockCreated(uint256 _blockNum) {\n', '     require(blockData[_blockNum].isCreated);\n', '     _;\n', '   }\n', '\n', '   modifier blockRedeemed(uint256 _blockNum) {\n', '     require(_blockNum != current_external_block());\n', '     /* Should capture if the blockdata is payed\n', '     *  or if it does not exist in the blockData mapping\n', '     */\n', '     require(blockData[_blockNum].isCreated);\n', '     require(!blockData[_blockNum].payed);\n', '     _;\n', '   }\n', '\n', '   modifier initBlock(uint256 _blockNum) {\n', '     require(_blockNum != current_external_block());\n', '\n', '     if (!blockData[_blockNum].isCreated) {\n', '       // This is a new block, adjust difficulty\n', '       adjust_difficulty();\n', '\n', '       // Create new block for tracking\n', '       blockData[_blockNum] = InternalBlock(\n', '                                     {targetDifficultyWei: currentDifficultyWei,\n', '                                      blockNumber: _blockNum,\n', '                                      totalMiningWei: 0,\n', '                                      totalMiningAttempts: 0,\n', '                                      currentAttemptOffset: 0,\n', '                                      payed: false,\n', '                                      payee: 0,\n', '                                      isCreated: true\n', '                                      });\n', '     }\n', '     _;\n', '   }\n', '\n', '   modifier isValidAttempt() {\n', '     /* If the Ether for this mining attempt is less than minimum\n', '     * 0.0000001 % of total difficulty\n', '     */\n', '     uint256 minimum_wei = currentDifficultyWei / divisible_units; \n', '     require (msg.value >= minimum_wei);\n', '\n', "     /* Let's bound the value to guard against potential overflow\n", '     * i.e max int, or an underflow bug\n', '     * This is a single attempt\n', '     */\n', '     require(msg.value <= (1000000 ether));\n', '     _;\n', '   }\n', '\n', '   modifier alreadyMined(uint256 blockNumber, address sender) {\n', '     require(blockNumber != current_external_block()); \n', '    /* We are only going to allow one mining attempt per block per account\n', '    *  This prevents stuffing and make it easier for us to track boundaries\n', '    */\n', '    \n', '    // This user already made a mining attempt for this block\n', '    require(!checkMiningAttempt(blockNumber, sender));\n', '    _;\n', '   }\n', '\n', '   function checkMiningActive() public constant returns (bool) {\n', '      return (totalSupply < maximumSupply);\n', '   }\n', '\n', '   modifier isMiningActive() {\n', '      require(checkMiningActive());\n', '      _;\n', '   }\n', '\n', '   function burn(uint256 value) internal {\n', "      /* We don't really care if the burn fails for some\n", '      *  weird reason.\n', '      */\n', '      bool ret = burnAddress.send(value);\n', '      /* If we cannot burn this ether, than the contract might\n', '      *  be under some kind of stack attack.\n', "      *  Even though it shouldn't matter, let's err on the side of\n", '      *  caution and throw in case there is some invalid state.\n', '      */\n', '      require (ret);\n', '   }\n', '\n', '   event MiningAttemptEvent(\n', '       address indexed _from,\n', '       uint256 _value,\n', '       uint256 indexed _blockNumber,\n', '       uint256 _totalMinedWei,\n', '       uint256 _targetDifficultyWei\n', '   );\n', '\n', '   event LogEvent(\n', '       string _info\n', '   );\n', '\n', '   /**\n', '   * @dev Add a mining attempt for the current internal block\n', '   * Initialize an empty block if not created\n', '   * Invalidate this mining attempt if the block has been paid out\n', '   */\n', '\n', '   function mine() external payable \n', '                           nonReentrant\n', '                           isValidAttempt\n', '                           isMiningActive\n', '                           initBlock(external_to_internal_block_number(current_external_block()))\n', '                           blockRedeemed(external_to_internal_block_number(current_external_block()))\n', '                           alreadyMined(external_to_internal_block_number(current_external_block()), msg.sender) returns (bool) {\n', "      /* Let's immediately adjust the difficulty\n", '      *  In case an abnormal period of time has elapsed\n', '      *  nobody has been mining etc.\n', '      *  Will let us recover the network even if the\n', '      * difficulty spikes to some absurd amount\n', '      * this should only happen on the first attempt on a block\n', '      */\n', '      uint256 internalBlockNum = external_to_internal_block_number(current_external_block());\n', '      miningAttempts[internalBlockNum][msg.sender] =\n', '                     MiningAttempt({projectedOffset: blockData[internalBlockNum].currentAttemptOffset,\n', '                                    value: msg.value,\n', '                                    isCreated: true});\n', '\n', '      // Increment the mining attempts for this block\n', '      blockData[internalBlockNum].totalMiningAttempts += 1;\n', '      blockData[internalBlockNum].totalMiningWei += msg.value;\n', '      totalWeiCommitted += msg.value;\n', '\n', '      /* We are trying to stack mining attempts into their relative\n', '      *  positions in the key space.\n', '      */\n', '      blockData[internalBlockNum].currentAttemptOffset += msg.value;\n', '      MiningAttemptEvent(msg.sender,\n', '                         msg.value,\n', '                         internalBlockNum,\n', '                         blockData[internalBlockNum].totalMiningWei,\n', '                         blockData[internalBlockNum].targetDifficultyWei\n', '                         );\n', '      // All mining attempt Ether is burned\n', '      burn(msg.value);\n', '      return true;\n', '   }\n', '\n', '   // Redemption Related\n', '\n', '   modifier userMineAttempted(uint256 _blockNum, address _user) {\n', '      require(checkMiningAttempt(_blockNum, _user));\n', '      _;\n', '   }\n', '   \n', '   modifier isBlockMature(uint256 _blockNumber) {\n', '      require(_blockNumber != current_external_block());\n', '      require(checkBlockMature(_blockNumber, current_external_block()));\n', '      require(checkRedemptionWindow(_blockNumber, current_external_block()));\n', '      _;\n', '   }\n', '\n', '   // Just in case this block falls outside of the available\n', '   // block range, possibly because of a change in network params\n', '   modifier isBlockReadable(uint256 _blockNumber) {\n', '      InternalBlock memory iBlock = blockData[_blockNumber];\n', '      uint256 targetBlockNum = targetBlockNumber(_blockNumber);\n', '      require(resolve_block_hash(targetBlockNum) != 0);\n', '      _;\n', '   }\n', '\n', '   function calculate_difficulty_attempt(uint256 targetDifficultyWei,\n', '                                         uint256 totalMiningWei,\n', '                                         uint256 value) public constant returns (uint256) {\n', '      // The total amount of Wei sent for this mining attempt exceeds the difficulty level\n', '      // So the calculation of percentage keyspace should be done on the total wei.\n', '      uint256 selectedDifficultyWei = 0;\n', '      if (totalMiningWei > targetDifficultyWei) {\n', '         selectedDifficultyWei = totalMiningWei;\n', '      } else {\n', '         selectedDifficultyWei = targetDifficultyWei; \n', '      }\n', '\n', '      /* normalize the value against the entire key space\n', '       * Multiply it out because we do not have floating point\n', '       * 10000000 is .0000001 % increments\n', '      */\n', '\n', '      uint256 intermediate = ((value * divisible_units) / selectedDifficultyWei);\n', '      uint256 max_int = 0;\n', '      // Underflow to maxint\n', '      max_int = max_int - 1;\n', '\n', '      if (intermediate >= divisible_units) {\n', '         return max_int;\n', '      } else {\n', '         return intermediate * (max_int / divisible_units);\n', '      }\n', '   }\n', '\n', '   function calculate_range_attempt(uint256 difficulty, uint256 offset) public constant returns (uint256, uint256) {\n', '       /* Both the difficulty and offset should be normalized\n', '       * against the difficulty scale.\n', '       * If they are not we might have an integer overflow\n', '       */\n', '       require(offset + difficulty >= offset);\n', '       return (offset, offset+difficulty);\n', '   }\n', '\n', '   // Total allocated reward is proportional to burn contribution to limit incentive for\n', '   // hash grinding attacks\n', '   function calculate_proportional_reward(uint256 _baseReward, uint256 _userContributionWei, uint256 _totalCommittedWei) public constant returns (uint256) {\n', '   require(_userContributionWei <= _totalCommittedWei);\n', '   require(_userContributionWei > 0);\n', '   require(_totalCommittedWei > 0);\n', '      uint256 intermediate = ((_userContributionWei * divisible_units) / _totalCommittedWei);\n', '\n', '      if (intermediate >= divisible_units) {\n', '         return _baseReward;\n', '      } else {\n', '         return intermediate * (_baseReward / divisible_units);\n', '      }\n', '   }\n', '\n', '   function calculate_base_mining_reward(uint256 _totalBlocksMined) public constant returns (uint256) {\n', '      /* Block rewards starts at initial_reward\n', '      *  Every 10 minutes\n', '      *  Block reward decreases by 50% every 210000 blocks\n', '      */\n', '      uint256 mined_block_period = 0;\n', '      if (_totalBlocksMined < 210000) {\n', '           mined_block_period = 210000;\n', '      } else {\n', '           mined_block_period = _totalBlocksMined;\n', '      }\n', '\n', '      // Again we have to do this iteratively because of floating\n', '      // point limitations in solidity.\n', '      uint256 total_reward = initial_reward * (10 ** decimals); \n', '      uint256 i = 1;\n', '      uint256 rewardperiods = mined_block_period / 210000;\n', '      if (mined_block_period % 210000 > 0) {\n', '         rewardperiods += 1;\n', '      }\n', '      for (i=1; i < rewardperiods; i++) {\n', '          total_reward = total_reward / 2;\n', '      }\n', '      return total_reward;\n', '   }\n', '\n', '   // Break out the expected wei calculation\n', '   // for easy external testing\n', '   function calculate_next_expected_wei(uint256 _totalWeiCommitted,\n', '                                        uint256 _totalWeiExpected,\n', '                                        uint256 _minimumDifficultyThresholdWei,\n', '                                        uint256 _difficultyScaleMultiplierLimit) public constant\n', '                                        returns (uint256) {\n', '          \n', '          /* The adjustment window has been fulfilled\n', '          *  The new difficulty should be bounded by the total wei actually spent\n', '          * capped at difficultyScaleMultiplierLimit times\n', '          */\n', '          uint256 lowerBound = _totalWeiExpected / _difficultyScaleMultiplierLimit;\n', '          uint256 upperBound = _totalWeiExpected * _difficultyScaleMultiplierLimit;\n', '\n', '          if (_totalWeiCommitted < lowerBound) {\n', '              _totalWeiExpected = lowerBound;\n', '          } else if (_totalWeiCommitted > upperBound) {\n', '              _totalWeiExpected = upperBound;\n', '          } else {\n', '              _totalWeiExpected = _totalWeiCommitted;\n', '          }\n', '\n', '          /* If difficulty drops too low lets set it to our minimum.\n', '          *  This may halt coin creation, but obviously does not affect\n', '          *  token transactions.\n', '          */\n', '          if (_totalWeiExpected < _minimumDifficultyThresholdWei) {\n', '              _totalWeiExpected = _minimumDifficultyThresholdWei;\n', '          }\n', '\n', '          return _totalWeiExpected;\n', '    }\n', '\n', '   function adjust_difficulty() internal {\n', '      /* Total blocks mined might not be increasing if the \n', '      *  difficulty is too high. So we should instead base the adjustment\n', '      * on the progression of the Ethereum network.\n', '      * So that the difficulty can increase/deflate regardless of sparse\n', '      * mining attempts\n', '      */\n', '\n', '      if ((current_external_block() - lastDifficultyAdjustmentEthereumBlock) > (difficultyAdjustmentPeriod * blockCreationRate)) {\n', '\n', '          // Get the new total wei expected via static function\n', '          totalWeiExpected = calculate_next_expected_wei(totalWeiCommitted, totalWeiExpected, minimumDifficultyThresholdWei * difficultyAdjustmentPeriod, difficultyScaleMultiplierLimit);\n', '\n', '          currentDifficultyWei = totalWeiExpected / difficultyAdjustmentPeriod;\n', '\n', '          // Regardless of difficulty adjustment, let us zero totalWeiCommited\n', '          totalWeiCommitted = 0;\n', '\n', '          // Lets reset the difficulty adjustment block target\n', '          lastDifficultyAdjustmentEthereumBlock = current_external_block();\n', '\n', '      }\n', '   }\n', '\n', '   event BlockClaimedEvent(\n', '       address indexed _from,\n', '       address indexed _forCreditTo,\n', '       uint256 _reward,\n', '       uint256 indexed _blockNumber\n', '   );\n', '\n', '   modifier onlyWinner(uint256 _blockNumber) {\n', '      require(checkWinning(_blockNumber));\n', '      _;\n', '   }\n', '\n', '\n', '   // Helper function to avoid stack issues\n', '   function calculate_reward(uint256 _totalBlocksMined, address _sender, uint256 _blockNumber) public constant returns (uint256) {\n', '      return calculate_proportional_reward(calculate_base_mining_reward(_totalBlocksMined), miningAttempts[_blockNumber][_sender].value, blockData[_blockNumber].totalMiningWei); \n', '   }\n', '\n', '   /** \n', '   * @dev Claim the mining reward for a given block\n', '   * @param _blockNumber The internal block that the user is trying to claim\n', '   * @param forCreditTo When the miner account is different from the account\n', '   * where we want to deliver the redeemed Bitcoineum. I.e Hard wallet.\n', '   */\n', '   function claim(uint256 _blockNumber, address forCreditTo)\n', '                  nonReentrant\n', '                  blockRedeemed(_blockNumber)\n', '                  isBlockMature(_blockNumber)\n', '                  isBlockReadable(_blockNumber)\n', '                  userMineAttempted(_blockNumber, msg.sender)\n', '                  onlyWinner(_blockNumber)\n', '                  external returns (bool) {\n', '      /* If attempt is valid, invalidate redemption\n', '      *  Difficulty is adjusted here\n', '      *  and on bidding, in case bidding stalls out for some\n', '      *  unusual period of time.\n', '      *  Do everything, then adjust supply and balance\n', '      */\n', '      blockData[_blockNumber].payed = true;\n', '      blockData[_blockNumber].payee = msg.sender;\n', '      totalBlocksMined = totalBlocksMined + 1;\n', '\n', '      uint256 proportional_reward = calculate_reward(totalBlocksMined, msg.sender, _blockNumber);\n', '      balances[forCreditTo] = balances[forCreditTo].add(proportional_reward);\n', '      totalSupply += proportional_reward;\n', '      BlockClaimedEvent(msg.sender, forCreditTo,\n', '                        proportional_reward,\n', '                        _blockNumber);\n', '      // Mining rewards should show up as ERC20 transfer events\n', '      // So that ERC20 scanners will see token creation.\n', '      Transfer(this, forCreditTo, proportional_reward);\n', '      return true;\n', '   }\n', '\n', '   /** \n', '   * @dev Claim the mining reward for a given block\n', '   * @param _blockNum The internal block that the user is trying to claim\n', '   */\n', '   function isBlockRedeemed(uint256 _blockNum) constant public returns (bool) {\n', '     if (!blockData[_blockNum].isCreated) {\n', '         return false;\n', '     } else {\n', '         return blockData[_blockNum].payed;\n', '     }\n', '   }\n', '\n', '   /** \n', '   * @dev Get the target block in the winning equation \n', '   * @param _blockNum is the internal block number to get the target block for\n', '   */\n', '   function targetBlockNumber(uint256 _blockNum) constant public returns (uint256) {\n', '      return ((_blockNum + 1) * blockCreationRate);\n', '   }\n', '\n', '   /** \n', '   * @dev Check whether a given block is mature \n', '   * @param _blockNum is the internal block number to check \n', '   */\n', '   function checkBlockMature(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\n', '     return (_externalblock >= targetBlockNumber(_blockNum));\n', '   }\n', '\n', '   /**\n', '   * @dev Check the redemption window for a given block\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '\n', '   function checkRedemptionWindow(uint256 _blockNum, uint256 _externalblock) constant public returns (bool) {\n', '       uint256 _targetblock = targetBlockNumber(_blockNum);\n', '       return _externalblock >= _targetblock && _externalblock < (_targetblock + 256);\n', '   }\n', '\n', '   /** \n', '   * @dev Check whether a mining attempt was made by sender for this block\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '   function checkMiningAttempt(uint256 _blockNum, address _sender) constant public returns (bool) {\n', '       return miningAttempts[_blockNum][_sender].isCreated;\n', '   }\n', '\n', '   /** \n', '   * @dev Did the user win a specific block and can claim it?\n', '   * @param _blockNum is the internal block number to check\n', '   */\n', '   function checkWinning(uint256 _blockNum) constant public returns (bool) {\n', '     if (checkMiningAttempt(_blockNum, msg.sender) && checkBlockMature(_blockNum, current_external_block())) {\n', '\n', '      InternalBlock memory iBlock = blockData[_blockNum];\n', '      uint256 targetBlockNum = targetBlockNumber(iBlock.blockNumber);\n', '      MiningAttempt memory attempt = miningAttempts[_blockNum][msg.sender];\n', '\n', '      uint256 difficultyAttempt = calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.value);\n', '      uint256 beginRange;\n', '      uint256 endRange;\n', '      uint256 targetBlockHashInt;\n', '\n', '      (beginRange, endRange) = calculate_range_attempt(difficultyAttempt,\n', '          calculate_difficulty_attempt(iBlock.targetDifficultyWei, iBlock.totalMiningWei, attempt.projectedOffset)); \n', '      targetBlockHashInt = uint256(keccak256(resolve_block_hash(targetBlockNum)));\n', '   \n', '      // This is the winning condition\n', '      if ((beginRange < targetBlockHashInt) && (endRange >= targetBlockHashInt))\n', '      {\n', '        return true;\n', '      }\n', '     \n', '     }\n', '\n', '     return false;\n', '     \n', '   }\n', '\n', '}\n', '\n', '\n', '\n', 'contract Bitcoineum is ERC20Mineable, Transmutable {\n', '\n', ' string public constant name = "Bitcoineum";\n', ' string public constant symbol = "BTE";\n', ' uint256 public constant decimals = 8;\n', ' uint256 public constant INITIAL_SUPPLY = 0;\n', '\n', ' // 21 Million coins at 8 decimal places\n', ' uint256 public constant MAX_SUPPLY = 21000000 * (10**8);\n', ' \n', ' function Bitcoineum() {\n', '\n', '    totalSupply = INITIAL_SUPPLY;\n', '    maximumSupply = MAX_SUPPLY;\n', '\n', '    // 0.0001 Ether per block\n', "    // Difficulty is so low because it doesn't include\n", '    // gas prices for execution\n', '    currentDifficultyWei = 100 szabo;\n', '    minimumDifficultyThresholdWei = 100 szabo;\n', '    \n', '    // Ethereum blocks to internal blocks\n', '    // Roughly 10 minute windows\n', '    blockCreationRate = 50;\n', '\n', '    // Adjust difficulty x claimed internal blocks\n', '    difficultyAdjustmentPeriod = 2016;\n', '\n', '    // Reward adjustment\n', '\n', '    rewardAdjustmentPeriod = 210000;\n', '\n', '    // This is the effective block counter, since block windows are discontinuous\n', '    totalBlocksMined = 0;\n', '\n', '    totalWeiExpected = difficultyAdjustmentPeriod * currentDifficultyWei;\n', '\n', '    // Balance of this address can be used to determine total burned value\n', '    // not including fees spent.\n', '    burnAddress = 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD;\n', '\n', '    lastDifficultyAdjustmentEthereumBlock = block.number; \n', ' }\n', '\n', '\n', '   /**\n', '   * @dev Bitcoineum can extend proof of burn into convertable units\n', '   * that have token specific properties\n', '   * @param to is the address of the contract that Bitcoineum is converting into\n', '   * @param value is the quantity of Bitcoineum to attempt to convert\n', '   */\n', '\n', '  function transmute(address to, uint256 value) nonReentrant returns (bool, uint256) {\n', '    require(value > 0);\n', '    require(balances[msg.sender] >= value);\n', '    require(totalSupply >= value);\n', '    balances[msg.sender] = balances[msg.sender].sub(value);\n', '    totalSupply = totalSupply.sub(value);\n', '    TransmutableInterface target = TransmutableInterface(to);\n', '    bool _result = false;\n', '    uint256 _total = 0;\n', '    (_result, _total) = target.transmuted(value);\n', '    require (_result);\n', '    Transmuted(msg.sender, this, to, value, _total);\n', '    return (_result, _total);\n', '  }\n', '\n', ' }']
