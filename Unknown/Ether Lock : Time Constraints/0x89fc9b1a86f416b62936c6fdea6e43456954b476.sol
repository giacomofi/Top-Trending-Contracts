['pragma solidity^0.4.11;\n', '\n', '// This is a hash bounty market which allows to set a bounty for a preimage of\n', '//  a given hash (e.g. a password)\n', '\n', '// Feel free to use the following code for any ethical purposes.\n', '\n', 'contract HashBounty {\n', '    event HashSolved (\n', '        address solver,\n', '        string solution,\n', '        bytes32 hash\n', '    );\n', '    \n', '    struct Bounty {\n', '        bytes32 hash;\n', '        uint reward;\n', '        bool isClaimed;\n', '    }\n', '    \n', '    mapping (uint => Bounty) bounties;\n', '    uint bountyIndex = 0;\n', '    \n', '    address owner;\n', '    uint fees = 0;\n', '    \n', '    function HashBounty() {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function setBounty(bytes32 hash) payable returns (uint) {\n', '        uint reward;\n', '        if (msg.value < 0.001 ether)\n', '            throw;\n', '        \n', '        reward = msg.value - 0.001 ether;\n', '        fees += 0.001 ether;\n', '        \n', '        bounties[bountyIndex++] = Bounty(hash, reward, false);\n', '        \n', '        return bountyIndex - 1;\n', '    }\n', '    \n', '    function claimBounty(uint claimIndex, string solution) {\n', '        bytes32 hash = sha256(solution);\n', '        \n', '        if (bounties[claimIndex].hash == hash) {\n', '            HashSolved(msg.sender, solution, bounties[claimIndex].hash);\n', '            bounties[claimIndex].isClaimed = true;\n', '            msg.sender.transfer(bounties[claimIndex].reward);\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '    \n', '    function addBountyReward(uint index) payable {\n', '        if (!bounties[index].isClaimed && bounties[index].hash != 0x0) {\n', '            bounties[index].reward += msg.value;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '    \n', '    function collectFees() {\n', '        owner.transfer(fees);\n', '        fees = 0;\n', '    }\n', '}']