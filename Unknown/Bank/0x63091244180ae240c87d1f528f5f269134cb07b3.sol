['pragma solidity ^0.4.6;\n', '\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '\n', 'contract DVIP {\n', '  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value);\n', '}\n', '\n', 'contract Assertive {\n', '  function assert(bool assertion) {\n', '    if (!assertion) throw;\n', '  }\n', '}\n', '\n', 'contract Owned is Assertive {\n', '  address internal owner;\n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  function Owned () {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '  function setOwner(address newOwner) onlyOwner {\n', '    SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  function getOwner() returns (address out) {\n', '    return owner;\n', '  }\n', '}\n', '\n', 'contract Math is Assertive {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ExchangeWhitelist is Math, Owned {\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances\n', '\n', '  struct Account {\n', '    bool authorized;\n', '    uint256 tier;\n', '    uint256 resetWithdrawal;\n', '    uint256 withdrawn;\n', '  }\n', '\n', '  mapping (address => Account) public accounts;\n', '  mapping (address => bool) public whitelistAdmins;\n', '  mapping (address => bool) public admins;\n', '  //ether balances are held in the token=0 account\n', '  mapping (bytes32 => uint256) public orderFills;\n', '  address public feeAccount;\n', '  address public dvipAddress;\n', '  address public feeMakeExporter;\n', '  address public feeTakeExporter;\n', '  event Order(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Cancel(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give, bytes32 hash);\n', '  event Deposit(address token, address user, uint256 amount, uint256 balance);\n', '  event Withdraw(address token, address user, uint256 amount, uint256 balance);\n', '\n', '  function ExchangeWhitelist(address feeAccount_, address dvipAddress_) {\n', '    feeAccount = feeAccount_;\n', '    dvipAddress = dvipAddress_;\n', '    feeMakeExporter = 0x00000000000000000000000000000000000000f7;\n', '    feeTakeExporter = 0x00000000000000000000000000000000000000f8;\n', '  }\n', '\n', '  function setFeeAccount(address feeAccount_) onlyOwner {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  function setDVIP(address dvipAddress_) onlyOwner {\n', '    dvipAddress = dvipAddress_;\n', '  }\n', '\n', '  function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '  function setWhitelister(address whitelister, bool isWhitelister) onlyOwner {\n', '    whitelistAdmins[whitelister] = isWhitelister;\n', '  }\n', '\n', '  modifier onlyWhitelister {\n', '    if (!whitelistAdmins[msg.sender]) throw;\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    if (msg.sender != owner && !admins[msg.sender]) throw;\n', '    _;\n', '  }\n', '  function setWhitelisted(address target, bool isWhitelisted) onlyWhitelister {\n', '    accounts[target].authorized = isWhitelisted;\n', '  }\n', '  modifier onlyWhitelisted {\n', '    if (!accounts[msg.sender].authorized) throw;\n', '    _;\n', '  }\n', '\n', '  function() {\n', '    throw;\n', '  }\n', '\n', '  function deposit(address token, uint256 amount) payable {\n', '    if (token == address(0)) {\n', '      tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n', '    } else {\n', '      if (msg.value != 0) throw;\n', '      tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '      if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n', '    }\n', '    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function withdraw(address token, uint256 amount) {\n', '    if (tokens[token][msg.sender] < amount) throw;\n', '    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '    if (token == address(0)) {\n', '      if (!msg.sender.send(amount)) throw;\n', '    } else {\n', '      if (!Token(token).transfer(msg.sender, amount)) throw;\n', '    }\n', '    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function balanceOf(address token, address user) constant returns (uint256) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  uint256 internal feeTake;\n', '  uint256 internal feeMake;\n', '  uint256 internal feeTerm;\n', '\n', '  function trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s, uint256 amount) onlyWhitelisted {\n', '    //amount is in amountBuy terms\n', '    bytes32 hash = sha3(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);\n', '    if (!(\n', '      ecrecover(hash,v,r,s) == user &&\n', '      block.number <= expires &&\n', '      safeAdd(orderFills[hash], amount) <= amountBuy &&\n', '      tokens[tokenBuy][msg.sender] >= amount &&\n', '      tokens[tokenSell][user] >= safeMul(amountSell, amount) / amountBuy\n', '    )) throw;\n', '    feeMake = DVIP(dvipAddress).feeFor(feeMakeExporter, msg.sender, 1 ether);\n', '    feeTake = DVIP(dvipAddress).feeFor(feeTakeExporter, user, 1 ether);\n', '    tokens[tokenBuy][msg.sender] = safeSub(tokens[tokenBuy][msg.sender], amount);\n', '    feeTerm = safeMul(amount, ((1 ether) - feeMake)) / (1 ether);\n', '    tokens[tokenBuy][user] = safeAdd(tokens[tokenBuy][user], feeTerm);\n', '    feeTerm = safeMul(amount, feeMake) / (1 ether);\n', '    tokens[tokenBuy][feeAccount] = safeAdd(tokens[tokenBuy][feeAccount], feeTerm);\n', '    feeTerm = safeMul(amountSell, amount) / amountBuy;\n', '    tokens[tokenSell][user] = safeSub(tokens[tokenSell][user], feeTerm);\n', '    feeTerm = safeMul(safeMul(((1 ether) - feeTake), amountSell), amount) / amountBuy / (1 ether);\n', '    tokens[tokenSell][msg.sender] = safeAdd(tokens[tokenSell][msg.sender], feeTerm);\n', '    feeTerm = safeMul(safeMul(feeTake, amountSell), amount) / amountBuy / (1 ether);\n', '    tokens[tokenSell][feeAccount] = safeAdd(tokens[tokenSell][feeAccount], feeTerm);\n', '    orderFills[hash] = safeAdd(orderFills[hash], amount);\n', '    Trade(tokenBuy, amount, tokenSell, amountSell * amount / amountBuy, user, msg.sender, hash);\n', '  }\n', '\n', '  bytes32 internal testHash;\n', '  uint256 internal amountSelln;\n', '\n', '  function testTrade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, address user, uint8 v, bytes32 r, bytes32 s, uint256 amount, address sender) constant returns (uint8 code) {\n', '    testHash = sha3(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);\n', '    if (tokens[tokenBuy][sender] < amount) return 1;\n', '    if (!accounts[sender].authorized) return 2; \n', '    if (!accounts[user].authorized) return 3;\n', '    if (ecrecover(testHash, v, r, s) != user) return 4;\n', '    amountSelln = safeMul(amountSell, amount) / amountBuy;\n', '    if (tokens[tokenSell][user] < amountSelln) return 5;\n', '    if (block.number > expires) return 6;\n', '    if (safeAdd(orderFills[testHash], amount) > amountBuy) return 7;\n', '    return 0;\n', '  }\n', '  function cancelOrder(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, uint256 expires, uint256 nonce, uint8 v, bytes32 r, bytes32 s, address user) {\n', '    bytes32 hash = sha3(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, user);\n', '    if (ecrecover(hash,v,r,s) != msg.sender) throw;\n', '    orderFills[hash] = amountBuy;\n', '    Cancel(tokenBuy, amountBuy, tokenSell, amountSell, expires, nonce, msg.sender, v, r, s);\n', '  }\n', '}']