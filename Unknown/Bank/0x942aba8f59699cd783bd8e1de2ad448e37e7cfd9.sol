['pragma solidity ^0.4.11;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) throw;\n', '  }\n', '}\n', 'contract Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract Ethex is SafeMath {\n', '  address public admin; //the admin address\n', '  address public feeAccount; //the account that will receive fees\n', '  uint public sellFee; //percentage times (1 ether)\n', '  uint public buyFee; //percentage times (1 ether)\n', '  mapping (bytes32 => uint) public sellOrders; //a hash of available orders holds a number of tokens\n', '  mapping (bytes32 => uint) public buyOrders; //a hash of available orders. holds a number of eth\n', '\n', '  event BuyOrder(bytes32 order, address token, uint amount, uint price, address buyer);\n', '  event SellOrder(bytes32 order,address token, uint amount, uint price, address seller);\n', '  event CancelBuyOrder(bytes32 order, address token, uint price, address buyer);\n', '  event CancelSellOrder(bytes32 order, address token, uint price, address seller);\n', '  event Buy(bytes32 order, address token, uint amount, uint price, address buyer, address seller);\n', '  event Sell(bytes32 order, address token, uint amount, uint price, address buyer, address seller);\n', '\n', '  function Ethex(address admin_, address feeAccount_, uint buyFee_, uint sellFee_) {\n', '    admin = admin_;\n', '    feeAccount = feeAccount_;\n', '    buyFee = buyFee_;\n', '    sellFee = sellFee_;\n', '  }\n', '\n', '  function() {\n', '    throw;\n', '  }\n', '\n', '  function changeAdmin(address admin_) {\n', '    if (msg.sender != admin) throw;\n', '    admin = admin_;\n', '  }\n', '\n', '  function changeFeeAccount(address feeAccount_) {\n', '    if (msg.sender != admin) throw;\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  function changeBuyFee(uint buyFee_) {\n', '    if (msg.sender != admin) throw;\n', '    if (buyFee_ > buyFee) throw;\n', '    buyFee = buyFee_;\n', '  }\n', '\n', '  function changeSellFee(uint sellFee_) {\n', '    if (msg.sender != admin) throw;\n', '    if (sellFee_ > sellFee)\n', '    sellFee = sellFee_;\n', '  }\n', '\n', '  function sellOrder(address token, uint tokenAmount, uint price) {\n', '    bytes32 h = sha256(token, price, msg.sender);\n', '    sellOrders[h] = safeAdd(sellOrders[h],tokenAmount);\n', '    SellOrder(h, token, tokenAmount, price, msg.sender);\n', '  }\n', '\n', '  function buyOrder(address token, uint tokenAmount, uint price) payable {\n', '    bytes32 h = sha256(token, price,  msg.sender);\n', '    uint totalCost = tokenAmount*price;\n', '    if (totalCost < msg.value) throw;\n', '    buyOrders[h] = safeAdd(buyOrders[h],msg.value);\n', '    BuyOrder(h, token, tokenAmount, price, msg.sender);\n', '  }\n', '\n', '  function cancelSellOrder(address token, uint price) {\n', '    bytes32 h = sha256(token, price, msg.sender);\n', '    delete sellOrders[h];\n', '    CancelSellOrder(h,token,price,msg.sender);\n', '  }\n', '\n', '  function cancelBuyOrder(address token, uint price) {\n', '    bytes32 h = sha256(token, price, msg.sender);\n', '    uint remain = buyOrders[h];\n', '    delete buyOrders[h];\n', '    if (!msg.sender.call.value(remain)()) throw;\n', '    CancelBuyOrder(h,token,price,msg.sender);\n', '  }\n', '\n', '  function totalBuyPrice(uint amount, uint price)  public constant returns (uint) {\n', '    uint totalPriceNoFee = safeMul(amount, price);\n', '    uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n', '    uint totalPrice = safeAdd(totalPriceNoFee,totalFee);\n', '    return totalPrice;\n', '  }\n', '\n', '  function takeBuy(address token, uint amount, uint price, address buyer) payable {\n', '    bytes32 h = sha256(token, price, buyer);\n', '    uint totalPriceNoFee = safeMul(amount, price);\n', '    uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n', '    uint totalPrice = safeAdd(totalPriceNoFee,totalFee);\n', '    if (buyOrders[h] < amount) throw;\n', '    if (totalPrice > msg.value) throw;\n', '    if (Token(token).allowance(msg.sender,this) < amount) throw;\n', '    if (Token(token).transferFrom(msg.sender,buyer,amount)) throw;\n', '    buyOrders[h] = safeSub(buyOrders[h], amount);\n', '    if (!feeAccount.send(totalFee)) throw;\n', '    uint leftOver = msg.value - totalPrice;\n', '    if (leftOver>0)\n', '      if (!msg.sender.send(leftOver)) throw;\n', '    Buy(h, token, amount, totalPrice, buyer, msg.sender);\n', '  }\n', '\n', '  function totalSellPrice(uint amount, uint price)  public constant returns (uint) {\n', '    uint totalPriceNoFee = safeMul(amount, price);\n', '    uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n', '    uint totalPrice = safeSub(totalPriceNoFee,totalFee);\n', '    return totalPrice;\n', '  }\n', '\n', '  function takeSell(address token, uint amount,uint price, address seller) payable {\n', '    bytes32 h = sha256(token, price, seller);\n', '    uint totalPriceNoFee = safeMul(amount, price);\n', '    uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n', '    uint totalPrice = safeSub(totalPriceNoFee,totalFee);\n', '    if (sellOrders[h] < amount) throw;\n', '    if (Token(token).allowance(seller,this) < amount) throw;\n', '    if (!Token(token).transferFrom(seller,msg.sender,amount)) throw;\n', '    sellOrders[h] = safeSub(sellOrders[h],amount);\n', '    if (!seller.send(totalPrice)) throw;\n', '    if (!feeAccount.send(totalFee)) throw;\n', '    Sell(h, token, amount, totalPrice, msg.sender, seller);\n', '  }\n', '}']