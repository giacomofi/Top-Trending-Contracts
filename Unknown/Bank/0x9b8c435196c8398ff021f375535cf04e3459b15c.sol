['pragma solidity ^0.4.11;\n', '\n', '// Minimum version requirement\n', '\n', '\n', '\n', 'contract MPY {\n', '\n', '  function getSupply() constant returns (uint256);\n', '\n', '  /// Return address balance of tokens\n', '  function balanceOf(address _owner) constant returns (uint256);\n', '\n', '}\n', '\n', '\n', '\n', 'contract MatchPay {\n', '    /* @title Master contract. MatchPay\n', '       @param msg.sender owner address\n', '    */\n', '\n', '    struct dividend_right {\n', '      uint _total_owed;\n', '      uint _period;\n', '    }\n', '\n', '    uint genesis_date;\n', '    uint current_period;\n', '\n', '    address master;\n', '    MPY token;\n', '\n', '    bool is_payday ;\n', '    uint dividends;\n', '    mapping (address => dividend_right) dividends_redeemed;\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '    // Only owner modifier\n', '    modifier only_owner_once(address _who) { require(_who == master && token == address(0)); _; }\n', '\n', '    // Is window open (first month after each genesis anniversary)\n', '    modifier is_window_open() { require( (now - genesis_date) % 31536000 <= 2592000); _; }\n', '\n', '    // Is window close\n', '    modifier is_window_close() { require( (now - genesis_date) % 31536000 > 2592000); _; }\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '    event Created(address indexed _who, address indexed _to_whom, address indexed _contract_address);\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '\n', '    function MatchPay() {\n', '      master = msg.sender;\n', '      genesis_date = now;\n', '      current_period = 0;\n', '      is_payday = false;\n', '    }\n', '\n', '\n', '    // Sets token address (MPY)\n', '    function setTokenAddress(address _MPYAddress) only_owner_once(msg.sender) returns (bool) {\n', '      token = MPY(_MPYAddress);\n', '\n', '      return true;\n', '    }\n', '\n', '\n', '    // Redeem dividends\n', '    function redeem(uint _amount) is_window_open() returns (bool) {\n', '      // If payday isn&#39;t flagged, flag it and freeze the dividends\n', '      if (!is_payday) {\n', '        is_payday = true;\n', '        dividends = this.balance;\n', '      }\n', '\n', '      // Check balance of sender and total balance\n', '      uint256 tokenBalance = token.balanceOf(msg.sender);\n', '      if (tokenBalance == 0) return false;\n', '      uint256 tokenSupply = token.getSupply();\n', '\n', '      // Reset amount owed if necessary\n', '      if (dividends_redeemed[msg.sender]._period != current_period) {\n', '        dividends_redeemed[msg.sender]._total_owed = 0;\n', '        dividends_redeemed[msg.sender]._period = current_period;\n', '      }\n', '\n', '      // Add _amount to total owed\n', '      dividends_redeemed[msg.sender]._total_owed += _amount;\n', '\n', '      // If proposed amount is viable, then give it to the owner\n', '      if (dividends_redeemed[msg.sender]._total_owed * tokenSupply <= dividends * tokenBalance) {\n', '        if (!msg.sender.send(_amount)) {\n', '          dividends_redeemed[msg.sender]._total_owed -= _amount;\n', '          return false;\n', '        }\n', '      }\n', '\n', '      return true;\n', '    }\n', '\n', '\n', '    // Redeem dividends\n', '    function switch_period() is_window_close() returns (bool) {\n', '      // If payday is flagged, unflag it and reset the dividends\n', '      if (is_payday) {\n', '        is_payday = false;\n', '        dividends = 0;\n', '        current_period += 1;\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '\n', '    // Collect fees\n', '    function() payable {}\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// Minimum version requirement\n', '\n', '\n', '\n', 'contract MPY {\n', '\n', '  function getSupply() constant returns (uint256);\n', '\n', '  /// Return address balance of tokens\n', '  function balanceOf(address _owner) constant returns (uint256);\n', '\n', '}\n', '\n', '\n', '\n', 'contract MatchPay {\n', '    /* @title Master contract. MatchPay\n', '       @param msg.sender owner address\n', '    */\n', '\n', '    struct dividend_right {\n', '      uint _total_owed;\n', '      uint _period;\n', '    }\n', '\n', '    uint genesis_date;\n', '    uint current_period;\n', '\n', '    address master;\n', '    MPY token;\n', '\n', '    bool is_payday ;\n', '    uint dividends;\n', '    mapping (address => dividend_right) dividends_redeemed;\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '    // Only owner modifier\n', '    modifier only_owner_once(address _who) { require(_who == master && token == address(0)); _; }\n', '\n', '    // Is window open (first month after each genesis anniversary)\n', '    modifier is_window_open() { require( (now - genesis_date) % 31536000 <= 2592000); _; }\n', '\n', '    // Is window close\n', '    modifier is_window_close() { require( (now - genesis_date) % 31536000 > 2592000); _; }\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '    event Created(address indexed _who, address indexed _to_whom, address indexed _contract_address);\n', '\n', '    // -------------------------------------------------------------------------------------------\n', '\n', '\n', '    function MatchPay() {\n', '      master = msg.sender;\n', '      genesis_date = now;\n', '      current_period = 0;\n', '      is_payday = false;\n', '    }\n', '\n', '\n', '    // Sets token address (MPY)\n', '    function setTokenAddress(address _MPYAddress) only_owner_once(msg.sender) returns (bool) {\n', '      token = MPY(_MPYAddress);\n', '\n', '      return true;\n', '    }\n', '\n', '\n', '    // Redeem dividends\n', '    function redeem(uint _amount) is_window_open() returns (bool) {\n', "      // If payday isn't flagged, flag it and freeze the dividends\n", '      if (!is_payday) {\n', '        is_payday = true;\n', '        dividends = this.balance;\n', '      }\n', '\n', '      // Check balance of sender and total balance\n', '      uint256 tokenBalance = token.balanceOf(msg.sender);\n', '      if (tokenBalance == 0) return false;\n', '      uint256 tokenSupply = token.getSupply();\n', '\n', '      // Reset amount owed if necessary\n', '      if (dividends_redeemed[msg.sender]._period != current_period) {\n', '        dividends_redeemed[msg.sender]._total_owed = 0;\n', '        dividends_redeemed[msg.sender]._period = current_period;\n', '      }\n', '\n', '      // Add _amount to total owed\n', '      dividends_redeemed[msg.sender]._total_owed += _amount;\n', '\n', '      // If proposed amount is viable, then give it to the owner\n', '      if (dividends_redeemed[msg.sender]._total_owed * tokenSupply <= dividends * tokenBalance) {\n', '        if (!msg.sender.send(_amount)) {\n', '          dividends_redeemed[msg.sender]._total_owed -= _amount;\n', '          return false;\n', '        }\n', '      }\n', '\n', '      return true;\n', '    }\n', '\n', '\n', '    // Redeem dividends\n', '    function switch_period() is_window_close() returns (bool) {\n', '      // If payday is flagged, unflag it and reset the dividends\n', '      if (is_payday) {\n', '        is_payday = false;\n', '        dividends = 0;\n', '        current_period += 1;\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '\n', '    // Collect fees\n', '    function() payable {}\n', '}']
