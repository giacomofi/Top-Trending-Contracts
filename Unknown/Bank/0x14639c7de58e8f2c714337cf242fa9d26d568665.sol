['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract ScamStampToken {\n', '    //The Scam Stamp Token is intended to mark an address as SCAM.\n', '    //this token is used by the contract ScamStamp defined bellow\n', '    //a false ERC20 token, where transfers can be done only by \n', '    //the creator of the token.\n', '\n', '    string public constant name = "SCAM Stamp Token";\n', '    string public constant symbol = "SCAM_STAMP";\n', '    uint8 public constant decimals = 0;\n', '    uint256 public totalSupply;\n', '\n', '    // Owner of this contract\n', '    address public owner;\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance){\n', '        return balances[_owner];\n', '    }\n', '    //Only the owner of the token can transfer.\n', '    //tokens are being generated on the fly,\n', '    //tokenSupply increases with double the amount that is required to be transfered \n', '    //if the amount isn&#39;t available to transfer\n', '    //newly generated tokens are never burned.\n', '    function transfer(address _to, uint256 _amount) onlyOwner returns (bool success){\n', '        if(_amount >= 0){\n', '            if(balances[msg.sender] >= _amount){\n', '                balances[msg.sender] -= _amount;\n', '                balances[_to] += _amount;\n', '                Transfer(msg.sender, _to, _amount);\n', '                return true;\n', '                }else{\n', '                    totalSupply += _amount + _amount;   \n', '                    balances[msg.sender] += _amount + _amount;\n', '                    balances[msg.sender] -= _amount;\n', '                    balances[_to] += _amount;\n', '                    Transfer(msg.sender, _to, _amount);\n', '                    return true;\n', '                }\n', '            }\n', '    }\n', '    function transferBack(address _from, uint256 _amount) onlyOwner returns (bool success){\n', '        if(_amount >= 0){\n', '            if(balances[_from] >= _amount){\n', '                balances[_from] -= _amount;\n', '                balances[owner] += _amount;\n', '                Transfer(_from, owner, _amount);\n', '                return true;\n', '            }else{\n', '                _amount = balances[_from];\n', '                balances[_from] -= _amount;\n', '                balances[owner] += _amount;\n', '                Transfer(_from, owner, _amount);\n', '                return true;\n', '            }\n', '            }else{\n', '                return false;\n', '            }\n', '    }\n', '\n', '\n', '    function ScamStampToken(){\n', '        owner = msg.sender;\n', '        totalSupply = 1;\n', '        balances[owner] = totalSupply;\n', '\n', '    }\n', '}\n', '\n', '\n', 'contract ScamStamp{\n', '//the contract is intended as a broker between a scammer address and the scamee\n', 'modifier onlyOwner(){\n', '    require(msg.sender == owner);\n', '    _;\n', '}\n', 'modifier hasMinimumAmountToFlag(){\n', '    require(msg.value >= pricePerUnit);\n', '    _;\n', '}\n', '\n', 'function mul(uint a, uint b) internal returns (uint) {\n', 'uint c = a * b;\n', 'require(a == 0 || c / a == b);\n', 'return c;\n', '}\n', '\n', 'function div(uint a, uint b) internal returns (uint) {\n', 'require(b > 0);\n', 'uint c = a / b;\n', 'require(a == b * c + a % b);\n', 'return c;\n', '}\n', '\n', 'function sub(uint a, uint b) internal returns (uint) {\n', 'require(b <= a);\n', 'return a - b;\n', '}\n', '\n', 'function add(uint a, uint b) internal returns (uint) {\n', 'uint c = a + b;\n', 'require(c >= a);\n', 'return c;\n', '}\n', '\n', '\n', 'address public owner;\n', '//the address of the ScamStampToken created by this contract\n', 'address public scamStampTokenAddress;\n', '//the actual ScamStampToken\n', 'ScamStampToken theScamStampToken; \n', '//the contract has a brokerage fee applied to all payable function calls\n', '//the fee is 2% of the amount sent.\n', '//the fee is directly sent to the owner of this contract\n', 'uint public contractFeePercentage = 2;\n', '\n', '//the price for 1 ScamStapToken is 1 finney\n', 'uint256 public pricePerUnit = 1 finney;\n', '//for a address to lose the ScamStampTokens it must pay a reliefRatio per token\n', '//for each 1 token that it holds it must pay 10 finney to make the token dissapear from they account\n', 'uint256 public reliefRatio = 10;\n', '//how many times an address has been marked as SCAM\n', 'mapping (address => uint256) public scamFlags;\n', '//contract statistics.\n', 'uint public totalNumberOfScammers = 0;\n', 'uint public totalScammedQuantity = 0;\n', 'uint public totalRepaidQuantity = 0;\n', '\n', 'mapping (address => mapping(address => uint256)) flaggedQuantity;\n', 'mapping (address => mapping(address => uint256)) flaggedRepaid;\n', '//the address that is flagging an address as scam has an issurance\n', '//when the scammer repays the scammed amount, the insurance will be sent\n', '//to the owner of the contract\n', 'mapping (address => mapping(address => uint256)) flaggerInsurance;\n', '\n', 'mapping (address => mapping(address => uint256)) contractsInsuranceFee;\n', 'mapping (address => address[]) flaggedIndex;\n', '//how much wei was the scammer been marked for.\n', 'mapping (address => uint256) public totalScammed;\n', '//how much wei did the scammer repaid\n', 'mapping (address => uint256) public totalScammedRepaid;\n', '\n', 'function ScamStamp() {\n', 'owner = msg.sender;\n', 'scamStampTokenAddress = new ScamStampToken();\n', 'theScamStampToken = ScamStampToken(scamStampTokenAddress);\n', '\n', '}\n', 'event MarkedAsScam(address scammer, address by, uint256 amount);\n', '//markAsSpam: payable function. \n', '//it flags the address as a scam address by sending ScamStampTokens to it.\n', '//the minimum value sent with this function call must be  pricePerUnit - set to 1 finney\n', '//the value sent to this function will be held as insurance by this contract.\n', '//it can be withdrawn by the calee anytime before the scammer pays the debt.\n', '\n', 'function markAsScam(address scammer) payable hasMinimumAmountToFlag{\n', '    uint256 numberOfTokens = div(msg.value, pricePerUnit);\n', '    updateFlagCount(msg.sender, scammer, numberOfTokens);\n', '\n', '    uint256 ownersFee = div( mul(msg.value, contractFeePercentage), 100 );//mul(msg.value, div(contractFeePercentage, 100));\n', '    uint256 insurance = msg.value - ownersFee;\n', '    owner.transfer(ownersFee);\n', '    flaggerInsurance[msg.sender][scammer] += insurance;\n', '    contractsInsuranceFee[msg.sender][scammer] += ownersFee;\n', '    theScamStampToken.transfer(scammer, numberOfTokens);\n', '    uint256 q = mul(reliefRatio, mul(msg.value, pricePerUnit));\n', '    MarkedAsScam(scammer, msg.sender, q);\n', '}\n', '//once an address is flagged as SCAM it can be forgiven by the flagger \n', '//unless the scammer already started to pay its debt\n', '\n', 'function forgiveIt(address scammer) {\n', '    if(flaggerInsurance[msg.sender][scammer] > 0){\n', '        uint256 insurance = flaggerInsurance[msg.sender][scammer];\n', '        uint256 hadFee = contractsInsuranceFee[msg.sender][scammer];\n', '        uint256 numberOfTokensToForgive = div( insurance + hadFee ,  pricePerUnit);\n', '        contractsInsuranceFee[msg.sender][scammer] = 0;\n', '        flaggerInsurance[msg.sender][scammer] = 0;\n', '        totalScammed[scammer] -= flaggedQuantity[scammer][msg.sender];\n', '        totalScammedQuantity -= flaggedQuantity[scammer][msg.sender];\n', '        flaggedQuantity[scammer][msg.sender] = 0;\n', '        theScamStampToken.transferBack(scammer, numberOfTokensToForgive);\n', '\n', '        msg.sender.transfer(insurance);\n', '        Forgived(scammer, msg.sender, insurance+hadFee);\n', '    }\n', '}\n', 'function updateFlagCount(address from, address scammer, uint256 quantity) private{\n', '    scamFlags[scammer] += 1;\n', '    if(scamFlags[scammer] == 1){\n', '        totalNumberOfScammers += 1;\n', '    }\n', '    uint256 q = mul(reliefRatio, mul(quantity, pricePerUnit));\n', '    flaggedQuantity[scammer][from] += q;\n', '    flaggedRepaid[scammer][from] = 0;\n', '    totalScammed[scammer] += q;\n', '    totalScammedQuantity += q;\n', '    addAddressToIndex(scammer, from);\n', '}\n', '\n', '\n', '\n', 'function addAddressToIndex(address scammer, address theAddressToIndex) private returns(bool success){\n', '    bool addressFound = false;\n', '    for(uint i = 0; i < flaggedIndex[scammer].length; i++){\n', '        if(flaggedIndex[scammer][i] == theAddressToIndex){\n', '            addressFound = true;\n', '            break;\n', '        }\n', '    }\n', '    if(!addressFound){\n', '        flaggedIndex[scammer].push(theAddressToIndex);\n', '    }\n', '    return true;\n', '}\n', 'modifier toBeAScammer(){\n', '    require(totalScammed[msg.sender] - totalScammedRepaid[msg.sender] > 0);\n', '    _;\n', '}\n', 'modifier addressToBeAScammer(address scammer){\n', '    require(totalScammed[scammer] - totalScammedRepaid[scammer] > 0);\n', '    _;\n', '}\n', 'event Forgived(address scammer, address by, uint256 amount);\n', 'event PartiallyForgived(address scammer, address by, uint256 amount);\n', '//forgiveMe - function called by scammer to pay any of its debt\n', '//If the amount sent to this function is greater than the amount \n', '//that is needed to cover or debt is sent back to the scammer.\n', 'function forgiveMe() payable toBeAScammer returns (bool success){\n', '    address scammer = msg.sender;\n', '\n', '    forgiveThis(scammer);\n', '    return true;\n', '}\n', '//forgiveMeOnBehalfOf - somebody else can pay a scammer address debt (same as above)\n', 'function forgiveMeOnBehalfOf(address scammer) payable addressToBeAScammer(scammer) returns (bool success){\n', '\n', '        forgiveThis(scammer);\n', '\n', '        return true;\n', '    }\n', '    function forgiveThis(address scammer) private returns (bool success){\n', '        uint256 forgivenessAmount = msg.value;\n', '        uint256 contractFeeAmount =  div(mul(forgivenessAmount, contractFeePercentage), 100); \n', '        uint256 numberOfTotalTokensToForgive = div(div(forgivenessAmount, reliefRatio), pricePerUnit);\n', '        forgivenessAmount = forgivenessAmount - contractFeeAmount;\n', '        for(uint128 i = 0; i < flaggedIndex[scammer].length; i++){\n', '            address forgivedBy = flaggedIndex[scammer][i];\n', '            uint256 toForgive = flaggedQuantity[scammer][forgivedBy] - flaggedRepaid[scammer][forgivedBy];\n', '            if(toForgive > 0){\n', '                if(toForgive >= forgivenessAmount){\n', '                    flaggedRepaid[scammer][forgivedBy] += forgivenessAmount;\n', '                    totalRepaidQuantity += forgivenessAmount;\n', '                    totalScammedRepaid[scammer] += forgivenessAmount;\n', '                    forgivedBy.transfer(forgivenessAmount);\n', '                    PartiallyForgived(scammer, forgivedBy, forgivenessAmount);\n', '                    forgivenessAmount = 0;\n', '                    break;\n', '                }else{\n', '                    forgivenessAmount -= toForgive;\n', '                    flaggedRepaid[scammer][forgivedBy] += toForgive;\n', '                    totalScammedRepaid[scammer] += toForgive;\n', '                    totalRepaidQuantity += toForgive;\n', '                    forgivedBy.transfer(toForgive);\n', '                    Forgived(scammer, forgivedBy, toForgive);\n', '                }\n', '                if(flaggerInsurance[forgivedBy][scammer] > 0){\n', '                    uint256 insurance = flaggerInsurance[forgivedBy][scammer];\n', '                    contractFeeAmount += insurance;\n', '                    flaggerInsurance[forgivedBy][scammer] = 0;\n', '                    contractsInsuranceFee[forgivedBy][scammer] = 0;\n', '                }\n', '            }\n', '        }\n', '        owner.transfer(contractFeeAmount);\n', '        theScamStampToken.transferBack(scammer, numberOfTotalTokensToForgive);\n', '\n', '        if(forgivenessAmount > 0){\n', '            msg.sender.transfer(forgivenessAmount);\n', '        }\n', '        return true;\n', '    }\n', '    event DonationReceived(address by, uint256 amount);\n', '    function donate() payable {\n', '        owner.transfer(msg.value);\n', '        DonationReceived(msg.sender, msg.value);\n', '\n', '    }\n', '    function () payable {\n', '        owner.transfer(msg.value);\n', '        DonationReceived(msg.sender, msg.value);        \n', '    }\n', '    \n', '\n', '}']