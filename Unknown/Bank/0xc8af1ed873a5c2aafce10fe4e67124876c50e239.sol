['pragma solidity ^0.4.11;\n', '/*\n', '\n', 'P2PFuturesTrading\n', '\n', 'Trustless trading of not already transferable tokens between two people\n', 'Author: thestral.eth\n', '\n', '*/\n', '\n', '// ERC20 Interface: ethereum/EIPs#20\n', 'contract ERC20 {\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', 'contract P2PFuturesTrading {\n', '\n', '\tstruct Trade{\n', '\t\taddress tokenAddress;\n', '\t\tuint tokenAmount;\n', '\t\tuint etherAmount;\n', '\t\tuint etherCollateralAmount;\n', '\t\tuint endTradeBlock;\n', '\t\tbool initialized;\n', '\t\tbool finalized;\n', '\t}\n', '\n', '\n', '\t// Store the open trades\n', '\tmapping (address => mapping(address => Trade)) public trades;\n', '\n', '\t// The developer address.\n', '\taddress developerAddress = 0x335854eF79Fff47F9050ca853c7f3bA53eeEEE93;\n', '\n', '\n', '\n', '\tfunction startTrade(address tokenSellerAddress, address tokenAddress, uint tokenAmount, uint etherCollateralAmount, uint endTradeBlock) payable{\n', '\t\t//Variable validation. The endTradeBlock can&#39;t be smaller than the current one plus 220 (around 1 hour)\n', '\t\tif(msg.value == 0 || tokenAmount == 0 || endTradeBlock <= block.number + 220){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tTrade t1 = trades[msg.sender][tokenSellerAddress];\n', '\t\tTrade t2 = trades[tokenSellerAddress][msg.sender];\n', '\t\t\n', '\t\t//You can&#39;t have more than one trade at a time between the same two people. To close a non finalized trade and have you ether back, you need to call the function cancelTrade\n', '\t\tif(t1.initialized || t2.initialized){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\ttrades[msg.sender][tokenSellerAddress] = Trade(tokenAddress, tokenAmount, msg.value, etherCollateralAmount, endTradeBlock, true, false);\n', '\t}\n', '\n', '\n', '\n', '\tfunction finalizeTrade(address tokenBuyerAddress, uint etherAmount, address tokenAddress, uint tokenAmount, uint endTradeBlock) payable{\n', '\t\tTrade t = trades[tokenBuyerAddress][msg.sender];\n', '\t\t\n', '\t\t//It needs to exist already a trade between the two people and it hasn&#39;t have to be already finalized\n', '\t\tif(!t.initialized || t.finalized){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\t//The trade condition specified by the two people must concide\n', '\t\tif(!(t.tokenAddress == tokenAddress && t.tokenAmount == tokenAmount && t.etherAmount == etherAmount && t.etherCollateralAmount == msg.value && t.endTradeBlock == endTradeBlock)){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tt.finalized = true;\n', '\t}\n', '\n', '\t \n', '\tfunction completeTrade(address otherPersonAddress){\n', '\t    Trade t;\n', '\t\taddress tokenBuyerAddress;\n', '\t\taddress tokenSellerAddress;\n', '\t\t\n', '\t\tTrade tokenBuyerTrade = trades[msg.sender][otherPersonAddress];\n', '\t\tTrade tokenSellerTrade = trades[otherPersonAddress][msg.sender];\n', '\t\t\n', '\t\t//It needs to exist already a trade between the two people and it has to be already finalized.\n', '\t\tif(tokenBuyerTrade.initialized && tokenBuyerTrade.finalized){\n', '\t\t\tt = tokenBuyerTrade;\n', '\t\t\ttokenBuyerAddress = msg.sender;\n', '\t\t\ttokenSellerAddress = otherPersonAddress;\n', '\t\t}\n', '\t\telse if(tokenSellerTrade.initialized && tokenSellerTrade.finalized){\n', '\t\t\tt = tokenSellerTrade;\n', '\t\t\ttokenBuyerAddress = otherPersonAddress;\n', '\t\t\ttokenSellerAddress = msg.sender;\n', '\t\t}\n', '\t\telse{\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\t\n', '\t\tERC20 token = ERC20(t.tokenAddress);\n', '\t\t\n', '\t\t//1% developer fee, 0.5% from the tokenSeller (in tokens) and 0.5% from the tokenBuyer (in ethers). In case the trade doesn&#39;t complete the fee is of 1% of the collateral.\n', '\t\tuint tokenSellerFee = t.tokenAmount * 5 / 1000;\n', '\t\tuint tokenBuyerFee = t.etherAmount * 5 / 1000;\n', '\t\tuint collateralFee = t.etherCollateralAmount / 100;\n', '\t\t\n', '\t\tt.initialized = false;\n', '\t\tt.finalized = false;\n', '\t\t\n', '\t\t//If the tokenSeller didn&#39;t allow this contract of the needed amount, one of the two following functions will return false\n', '\t\tif(!token.transferFrom(tokenSellerAddress, tokenBuyerAddress, t.tokenAmount - tokenSellerFee) || !token.transferFrom(tokenSellerAddress, developerAddress, tokenSellerFee)){\n', '\t\t\t//If the maximum time has passed, and the trade coudldn&#39;t be completed, the tokenBuyer will receive his ether plus the collateral. Otherwise no action is taken.\n', '\t\t\tif(t.endTradeBlock < block.number){\n', '\t\t\t\ttokenBuyerAddress.transfer(t.etherAmount + t.etherCollateralAmount - collateralFee);\n', '\t\t\t\tdeveloperAddress.transfer(collateralFee);\n', '\t\t\t\t\n', '\t\t\t\treturn;\n', '\t\t\t}\n', '\t\t\telse{\n', '\t\t\t\tthrow;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\t//Transfer to the tokenSeller the etherAmount plus his collateral\n', '\t\ttokenSellerAddress.transfer(t.etherAmount + t.etherCollateralAmount - tokenBuyerFee);\n', '\t\tdeveloperAddress.transfer(tokenBuyerFee);\n', '    }\n', '    \n', '    \n', '\tfunction cancelTrade(address tokenSellerAddress){\n', '\t\tTrade t = trades[msg.sender][tokenSellerAddress];\n', '\t\t\n', '\t\t//It needs to exist already a trade between the two people and it hasn&#39;t have to be already finalized\n', '\t\tif(!t.initialized || t.finalized){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\t//Cancel the trade and give the sender his ether back\t\n', '\t\tt.initialized = false;\n', '\t\t\n', '\t\tmsg.sender.transfer(t.etherAmount);\n', '\t}\n', '}']