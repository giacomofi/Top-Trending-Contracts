['contract Owned {\n', '\n', '    address public owner;\n', '    mapping (address => bool) public isAdmin;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '        isAdmin[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        assert(isAdmin[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address user) onlyAdmin {\n', '        isAdmin[user] = true;\n', '    }\n', '\n', '    function removeAdmin(address user) onlyAdmin {\n', '        if (user == owner) {\n', '            throw; //cant remove the owner\n', '        }\n', '        isAdmin[user] = false;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'contract SoupToken is Owned {\n', '\n', '\n', '    string public standard = &#39;SoupToken 30/06&#39;;\n', '\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint256 public totalSupply;\n', '\n', '    uint public minBalanceForAccounts = 5 finney;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    mapping (uint => address[]) public ordersFor;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    event BurnFrom(address _from, uint256 _value);\n', '\n', '    event LogDepositReceived(address sender);\n', '\n', '    function SoupToken(string tokenName, string tokenSymbol) payable {\n', '        name = tokenName;\n', '        // Set the name for display purposes\n', '        symbol = tokenSymbol;\n', '        // Set the symbol for display purposes\n', '    }\n', '\n', '    function() payable {\n', '        LogDepositReceived(msg.sender);\n', '    }\n', '\n', '    function mintToken(address target, uint256 mintedAmount) onlyAdmin {\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        Transfer(0, owner, mintedAmount);\n', '        Transfer(owner, target, mintedAmount);\n', '        if (target.balance < minBalanceForAccounts) target.transfer(minBalanceForAccounts - target.balance);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value){\n', '        if (_to == 0x0) throw;\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balanceOf[msg.sender] < _value) throw;\n', '        // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n', '        // Check for overflows\n', '        balanceOf[msg.sender] -= _value;\n', '        // Subtract from the sender\n', '        balanceOf[_to] += _value;\n', '        // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);\n', '        // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyAdmin returns (bool success){\n', '        if (_to == 0x0) throw;\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balanceOf[_from] < _value) throw;\n', '        // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n', '        // Check for overflows\n', '        balanceOf[_from] -= _value;\n', '        // Subtract from the sender\n', '        balanceOf[_to] += _value;\n', '        // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) onlyAdmin returns (bool success) {\n', '        if (balanceOf[_from] < _value) throw;\n', '        // Check if the sender has enough\n', '        balanceOf[_from] -= _value;\n', '        // Subtract from the sender\n', '        totalSupply -= _value;\n', '        // Updates totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function checkIfAlreadyOrderedForDay(uint day, address user) internal constant returns (bool){\n', '        var orders = ordersFor[day];\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            if (orders[i] == user) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function findOrderIndexForAddress(uint day, address user) internal constant returns (uint){\n', '        var orders = ordersFor[day];\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            if (orders[i] == user) {\n', '                return i;\n', '            }\n', '        }\n', '        //this throw will never be reached. This function is only called for users\n', '        //where we absolutely know they are in the list\n', '        throw;\n', '    }\n', '\n', '    function orderForDays(bool[] weekdays) returns (bool success) {\n', '\n', '        uint totalOrders = 0;\n', '        for (uint i = 0; i < weekdays.length; i++) {\n', '            var isOrdering = weekdays[i];\n', '            //check if the user already ordered for that day\n', '            if (checkIfAlreadyOrderedForDay(i, msg.sender)) {\n', '                //if so we remove the order if the user changed his mind\n', '                if (!isOrdering) {\n', '                    var useridx = findOrderIndexForAddress(i, msg.sender);\n', '                    delete ordersFor[i][useridx];\n', '                }\n', '                //if he still wants to buy for the change we dont do anything\n', '            }\n', '            else {\n', '                if (isOrdering) {\n', '                    //add the user to the list of purchases that day\n', '                    ordersFor[i].push(msg.sender);\n', '                    totalOrders++;\n', '                }\n', '                //do nothing otherwise\n', '            }\n', '            // rollback transaction if totalOrders exceeds balance\n', '            if (balanceOf[msg.sender] < totalOrders) {\n', '                throw;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function burnSoupTokensForDay(uint day) onlyAdmin returns (bool success) {\n', '\n', '        for (uint i = 0; i < ordersFor[day].length; i++) {\n', '            if (ordersFor[day][i] == 0x0) {\n', '                continue;\n', '            }\n', '            burnFrom(ordersFor[day][i], 1);\n', '            delete ordersFor[day][i];\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getOrderAddressesForDay(uint day) constant returns (address[]) {\n', '        return ordersFor[day];\n', '    }\n', '\n', '    function getAmountOrdersForDay(uint day) constant returns (uint){\n', '        return ordersFor[day].length;\n', '    }\n', '\n', '    function setMinBalance(uint minimumBalanceInFinney) onlyAdmin {\n', '        minBalanceForAccounts = minimumBalanceInFinney * 1 finney;\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        suicide(owner);\n', '    }\n', '\n', '\n', '}']
['contract Owned {\n', '\n', '    address public owner;\n', '    mapping (address => bool) public isAdmin;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '        isAdmin[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        assert(isAdmin[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function addAdmin(address user) onlyAdmin {\n', '        isAdmin[user] = true;\n', '    }\n', '\n', '    function removeAdmin(address user) onlyAdmin {\n', '        if (user == owner) {\n', '            throw; //cant remove the owner\n', '        }\n', '        isAdmin[user] = false;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'contract SoupToken is Owned {\n', '\n', '\n', "    string public standard = 'SoupToken 30/06';\n", '\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint256 public totalSupply;\n', '\n', '    uint public minBalanceForAccounts = 5 finney;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    mapping (uint => address[]) public ordersFor;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    event BurnFrom(address _from, uint256 _value);\n', '\n', '    event LogDepositReceived(address sender);\n', '\n', '    function SoupToken(string tokenName, string tokenSymbol) payable {\n', '        name = tokenName;\n', '        // Set the name for display purposes\n', '        symbol = tokenSymbol;\n', '        // Set the symbol for display purposes\n', '    }\n', '\n', '    function() payable {\n', '        LogDepositReceived(msg.sender);\n', '    }\n', '\n', '    function mintToken(address target, uint256 mintedAmount) onlyAdmin {\n', '        balanceOf[target] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        Transfer(0, owner, mintedAmount);\n', '        Transfer(owner, target, mintedAmount);\n', '        if (target.balance < minBalanceForAccounts) target.transfer(minBalanceForAccounts - target.balance);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value){\n', '        if (_to == 0x0) throw;\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balanceOf[msg.sender] < _value) throw;\n', '        // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n', '        // Check for overflows\n', '        balanceOf[msg.sender] -= _value;\n', '        // Subtract from the sender\n', '        balanceOf[_to] += _value;\n', '        // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);\n', '        // Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyAdmin returns (bool success){\n', '        if (_to == 0x0) throw;\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balanceOf[_from] < _value) throw;\n', '        // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n', '        // Check for overflows\n', '        balanceOf[_from] -= _value;\n', '        // Subtract from the sender\n', '        balanceOf[_to] += _value;\n', '        // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) onlyAdmin returns (bool success) {\n', '        if (balanceOf[_from] < _value) throw;\n', '        // Check if the sender has enough\n', '        balanceOf[_from] -= _value;\n', '        // Subtract from the sender\n', '        totalSupply -= _value;\n', '        // Updates totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function checkIfAlreadyOrderedForDay(uint day, address user) internal constant returns (bool){\n', '        var orders = ordersFor[day];\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            if (orders[i] == user) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function findOrderIndexForAddress(uint day, address user) internal constant returns (uint){\n', '        var orders = ordersFor[day];\n', '        for (uint i = 0; i < orders.length; i++) {\n', '            if (orders[i] == user) {\n', '                return i;\n', '            }\n', '        }\n', '        //this throw will never be reached. This function is only called for users\n', '        //where we absolutely know they are in the list\n', '        throw;\n', '    }\n', '\n', '    function orderForDays(bool[] weekdays) returns (bool success) {\n', '\n', '        uint totalOrders = 0;\n', '        for (uint i = 0; i < weekdays.length; i++) {\n', '            var isOrdering = weekdays[i];\n', '            //check if the user already ordered for that day\n', '            if (checkIfAlreadyOrderedForDay(i, msg.sender)) {\n', '                //if so we remove the order if the user changed his mind\n', '                if (!isOrdering) {\n', '                    var useridx = findOrderIndexForAddress(i, msg.sender);\n', '                    delete ordersFor[i][useridx];\n', '                }\n', '                //if he still wants to buy for the change we dont do anything\n', '            }\n', '            else {\n', '                if (isOrdering) {\n', '                    //add the user to the list of purchases that day\n', '                    ordersFor[i].push(msg.sender);\n', '                    totalOrders++;\n', '                }\n', '                //do nothing otherwise\n', '            }\n', '            // rollback transaction if totalOrders exceeds balance\n', '            if (balanceOf[msg.sender] < totalOrders) {\n', '                throw;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function burnSoupTokensForDay(uint day) onlyAdmin returns (bool success) {\n', '\n', '        for (uint i = 0; i < ordersFor[day].length; i++) {\n', '            if (ordersFor[day][i] == 0x0) {\n', '                continue;\n', '            }\n', '            burnFrom(ordersFor[day][i], 1);\n', '            delete ordersFor[day][i];\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getOrderAddressesForDay(uint day) constant returns (address[]) {\n', '        return ordersFor[day];\n', '    }\n', '\n', '    function getAmountOrdersForDay(uint day) constant returns (uint){\n', '        return ordersFor[day].length;\n', '    }\n', '\n', '    function setMinBalance(uint minimumBalanceInFinney) onlyAdmin {\n', '        minBalanceForAccounts = minimumBalanceInFinney * 1 finney;\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        suicide(owner);\n', '    }\n', '\n', '\n', '}']
