['pragma solidity ^0.4.16;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() constant returns (uint256 supply) {\n', '    return 0;\n', '  }\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    _owner = _owner;\n', '    return 0;\n', '  }\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '    _to = _to;\n', '    _value = _value;\n', '    return false;\n', '  }\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '    _from = _from;\n', '    _to = _to;\n', '    _value = _value;\n', '    return false;\n', '  }\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success) {\n', '    _spender = _spender;\n', '    _value = _value;\n', '    return false;\n', '  }\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    _owner = _owner;\n', '    _spender = _spender;\n', '    return 0;\n', '  }\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '    //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '    //Replace the if with this one instead.\n', '    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    //if (balances[msg.sender] >= _value && _value > 0) {\n', '      balances[msg.sender] -= _value;\n', '      balances[_to] += _value;\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    } else { return false; }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '    //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '      balances[_to] += _value;\n', '      balances[_from] -= _value;\n', '      allowed[_from][msg.sender] -= _value;\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    } else { return false; }\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  uint256 public totalSupply;\n', '}\n', '\n', 'contract EtherPush is SafeMath {\n', '  struct Order {\n', '    uint    id;\n', '    address sell;\n', '    uint    sellamount;\n', '    address buy;\n', '    uint    buyamount;\n', '    address seller;\n', '    address buyer;\n', '    uint    created;\n', '    uint    expired;\n', '    uint    timestamp;\n', '  }\n', '\n', '  mapping (address => mapping (address => uint))            public tokens;\n', '  mapping (uint => mapping (address => Order))              public orders;\n', '\n', '  string  public constant  name = "EtherPush";\n', '  string  public constant  version = "20170913";\n', '\n', '  bool    public           running = true;\n', '\n', '  uint    public           sellerfee = 0.005 ether;\n', '  uint    public constant    sellerfeeDivide = 1 ether;\n', '\n', '  uint    public           buyerfee = 0.005 ether;\n', '  uint    public constant    buyerfeeDivide = 1 ether;\n', '\n', '  uint    private          _id = 0;\n', '  uint    private          _nonce = 0;\n', '  address  private          owner;\n', '\n', '  event onSell(bytes32 nonce, uint id, address sell, uint sellamount, address buy, uint buyamount, address seller, address buyer, uint created, uint expired, uint timestamp);\n', '  event onBuy(bytes32 nonce, uint id, address sell, uint sellamount, uint balanceSellamount,\n', '              address buy, uint buyamount, uint balanceBuyamount, address seller, address buyer,\n', '              uint created, uint timestamp);\n', '  event onCancel(bytes32 nonce, uint id, address seller);\n', '  event onDeposit(address token, address user, uint amount, uint balance);\n', '  event onWithdraw(address token, address user, uint amount, uint balance);\n', '\n', '  modifier onlyRunning() {\n', '    require(running);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function EtherPush() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function ownerChangeRunning(bool _running)\n', '    public\n', '    onlyOwner\n', '  {\n', '    running = _running;\n', '  }\n', '\n', '  function ownerChangeSellerfee(uint _fee)\n', '    public\n', '    onlyOwner\n', '  {\n', '    /*\n', '     * between [0.1%, 2%]\n', '     */\n', '    require (_fee >= 0.001 ether && _fee <= 0.02 ether);\n', '\n', '    sellerfee = _fee;\n', '  }\n', '\n', '  function ownerChangeBuyerfee(uint _fee)\n', '    public\n', '    onlyOwner\n', '  {\n', '    /*\n', '     * between [0.1%, 2%]\n', '     */\n', '    require (_fee >= 0.001 ether && _fee <= 0.02 ether);\n', '    buyerfee = _fee;\n', '  }\n', '\n', '  function ownerChangeOwner(address _owner)\n', '    public\n', '    onlyOwner\n', '  {\n', '    require (_owner > 0);\n', '    owner = _owner;\n', '  }\n', '\n', '  function ownerWithdrawAccount(address account)\n', '    public\n', '    onlyOwner\n', '  {\n', '    account.transfer(this.balance);\n', '  }\n', '\n', '  function ownerWithdraw()\n', '    public\n', '    onlyOwner\n', '  {\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  function getRunning() public constant returns (bool) {\n', '    return running;\n', '  }\n', '\n', '  function getSellerfee() public constant returns (uint) {\n', '    return sellerfee;\n', '  }\n', '\n', '  function getBuyerfee() public constant returns (uint) {\n', '    return buyerfee;\n', '  }\n', '\n', '  function withdrawAmountETH(uint amount) {\n', '    if (tokens[0][msg.sender] < amount) {\n', '      revert();\n', '    }\n', '\n', '    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    onWithdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function withdrawETH() {\n', '    uint amount = tokens[0][msg.sender];\n', '    tokens[0][msg.sender] = 0;\n', '\n', '    msg.sender.transfer(amount);\n', '\n', '    onWithdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function withdrawToken(address token) {\n', '    if (token == address(0)) {\n', '      revert();\n', '    }\n', '\n', '    uint amount = tokens[token][msg.sender];\n', '    tokens[token][msg.sender] = 0;\n', '\n', '    if (!Token(token).transfer(msg.sender, amount)) {\n', '      revert();\n', '    }\n', '\n', '    onWithdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function withdrawAmountToken(address token, uint amount) {\n', '    if (token == address(0)) {\n', '      revert();\n', '    }\n', '\n', '    if (tokens[token][msg.sender] < amount) {\n', '      revert();\n', '    }\n', '\n', '    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '\n', '    if (!Token(token).transfer(msg.sender, amount)) {\n', '      revert();\n', '    }\n', '\n', '    onWithdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function depositETH()\n', '    public\n', '    payable\n', '  {\n', '    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '    onDeposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function depositToken(address token, uint amount)\n', '    public\n', '  {\n', '    if (token == address(0)) {\n', '      revert();\n', '    }\n', '\n', '    if (!Token(token).transferFrom(msg.sender, this, amount)) {\n', '      revert();\n', '    }\n', '\n', '    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '    onDeposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function balanceOf(address token, address user)\n', '    public\n', '    constant\n', '    returns\n', '    (uint)\n', '  {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  function tobuy(uint id, address seller, uint buyamount)\n', '    public\n', '    onlyRunning\n', '  {\n', '    if (orders[id][seller].expired < block.number) {\n', '      revert();\n', '    }\n', '\n', '    if (orders[id][seller].buyer > 0) {\n', '      if (orders[id][seller].buyer != msg.sender) {\n', '        revert();\n', '      }\n', '    }\n', '\n', '    if (orders[id][seller].buyamount < buyamount) {\n', '      revert();\n', '    }\n', '\n', '    address sell = orders[id][seller].sell;\n', '    address buy = orders[id][seller].buy;\n', '    uint    ordersellamount = orders[id][seller].sellamount;\n', '    uint    orderbuyamount = orders[id][seller].buyamount;\n', '    uint    sellamount = safeMul(ordersellamount, buyamount) / orderbuyamount;\n', '    buyamount = safeMul(sellamount, orderbuyamount) / ordersellamount;\n', '\n', '    if (ordersellamount < sellamount) {\n', '      revert();\n', '    }\n', '\n', '    if (tokens[sell][seller] < sellamount) {\n', '      revert();\n', '    }\n', '\n', '    if (tokens[buy][msg.sender] < buyamount) {\n', '      revert();\n', '    }\n', '\n', '    uint _sellerfee = safeMul(sellamount, sellerfee) / sellerfeeDivide;\n', '    uint _buyerfee = safeMul(buyamount, buyerfee) / buyerfeeDivide;\n', '\n', '    /*\n', '     * order\n', '     */\n', '\n', '    orders[id][seller].sellamount = safeSub(orders[id][seller].sellamount, sellamount);\n', '    orders[id][seller].buyamount = safeSub(orders[id][seller].buyamount, buyamount);\n', '\n', '    /*\n', '     * balance sell token\n', '     */\n', '\n', '    tokens[sell][seller] = safeSub(tokens[sell][seller], sellamount);\n', '    tokens[sell][owner] = safeAdd(tokens[sell][owner], _sellerfee);\n', '    tokens[sell][msg.sender] = safeAdd(tokens[sell][msg.sender], safeSub(sellamount, _sellerfee));\n', '\n', '    /*\n', '     * balance buy token\n', '     */\n', '\n', '    tokens[buy][msg.sender] = safeSub(tokens[buy][msg.sender], buyamount);\n', '    tokens[buy][owner] = safeAdd(tokens[buy][owner], _buyerfee);\n', '    tokens[buy][seller] = safeAdd(tokens[buy][seller], safeSub(buyamount, _buyerfee));\n', '\n', '    /*\n', '     * call to buy function to clear stack\n', '     */\n', '\n', '    _tobuy(id, seller, sellamount, buyamount);\n', '  }\n', '\n', '  function _tobuy(uint id, address seller, uint sellamount, uint buyamount)\n', '    private\n', '  {\n', '    bytes32 nonce = sha3(block.number, msg.data, _nonce++);\n', '    onBuy(\n', '         nonce,\n', '         id,\n', '         orders[id][seller].sell,\n', '         sellamount,\n', '         orders[id][seller].sellamount,\n', '         orders[id][seller].buy,\n', '         buyamount,\n', '         orders[id][seller].buyamount,\n', '         seller,\n', '         msg.sender,\n', '         block.number,\n', '         now\n', '         );\n', '  }\n', '\n', '  function tosell(address sell, uint sellamount, address buy, uint buyamount,\n', '               address buyer, uint expire, uint broadcast)\n', '    public\n', '    onlyRunning\n', '  {\n', '\n', '    if (tokens[sell][msg.sender] < sellamount) {\n', '      revert();\n', '    }\n', '\n', '    /*\n', '     * if buyer > 0, the order only can be purchased by the specified buyer.\n', '     * and here we do not check the token balance to imporve the poor performance\n', '     */\n', '\n', '    _id = _id + 1;\n', '    orders[_id][msg.sender].id = _id;\n', '    orders[_id][msg.sender].sell = sell;\n', '    orders[_id][msg.sender].sellamount = sellamount;\n', '    orders[_id][msg.sender].buy = buy;\n', '    orders[_id][msg.sender].buyamount = buyamount;\n', '    orders[_id][msg.sender].seller = msg.sender;\n', '    orders[_id][msg.sender].buyer = buyer;\n', '    orders[_id][msg.sender].created = block.number;\n', '    orders[_id][msg.sender].expired = safeAdd(block.number, expire);\n', '\n', '    bytes32 nonce = sha3(block.number, msg.data, _nonce++);\n', '\n', '    onSell(nonce, _id, sell, sellamount, buy, buyamount, msg.sender, buyer, block.number, orders[_id][msg.sender].expired, now);\n', '  }\n', '\n', '  function tocancel(uint id)\n', '    public\n', '  {\n', '    orders[id][msg.sender].sellamount = 0;\n', '\n', '    bytes32 nonce = sha3(block.number, msg.data, _nonce++);\n', '\n', '    onCancel(nonce, id, msg.sender);\n', '  }\n', '\n', '  function getOrder(uint id, address seller)\n', '    public\n', '    constant\n', '    returns\n', '    (address, uint, address, uint, address, uint)\n', '  {\n', '    return (orders[id][seller].sell,\n', '      orders[id][seller].sellamount,\n', '      orders[id][seller].buy,\n', '      orders[id][seller].buyamount,\n', '      orders[id][seller].buyer,\n', '      orders[id][seller].expired\n', '    );\n', '  }\n', '}']