['/**\n', ' * @title DVIP Contract. DCAsset Membership Token contract.\n', ' *\n', ' * @author Ray Pulver, ray@decentralizedcapital.com\n', ' */\n', 'contract Relay {\n', '  function relayReceiveApproval(address _caller, address _spender, uint256 _amount, bytes _extraData) returns (bool success);\n', '}\n', '\n', 'contract DVIPBackend {\n', '  uint8 public decimals;\n', '  function assert(bool assertion) {\n', '    if (!assertion) throw;\n', '  }\n', '  address public owner;\n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _\n', '  }\n', '  function setOwner(address newOwner) onlyOwner {\n', '    SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  bool internal locked;\n', '  event Locked(address indexed from);\n', '  event PropertySet(address indexed from);\n', '  modifier onlyIfUnlocked {\n', '    assert(!locked);\n', '    _\n', '  }\n', '  modifier setter {\n', '    _\n', '    PropertySet(msg.sender);\n', '  }\n', '  modifier onlyOwnerUnlocked {\n', '    assert(!locked && msg.sender == owner);\n', '    _\n', '  }\n', '  function lock() onlyOwner onlyIfUnlocked {\n', '    locked = true;\n', '    Locked(msg.sender);\n', '  }\n', '  function isLocked() returns (bool status) {\n', '    return locked;\n', '  }\n', "  bytes32 public standard = 'Token 0.1';\n", '  bytes32 public name;\n', '  bytes32 public symbol;\n', '  bool public allowTransactions;\n', '  uint256 public totalSupply;\n', '\n', '  event Approval(address indexed from, address indexed spender, uint256 amount);\n', '\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function () {\n', '    throw;\n', '  }\n', '\n', '  uint256 public expiry;\n', '  uint8 public feeDecimals;\n', '  mapping (address => uint256) public validAfter;\n', '  uint256 public mustHoldFor;\n', '  address public hotwalletAddress;\n', '  address public frontendAddress;\n', '  mapping (address => bool) public frozenAccount;\n', '  mapping (address => uint256) public exportFee;\n', '\n', '  event FeeSetup(address indexed from, address indexed target, uint256 amount);\n', '  event Processed(address indexed sender);\n', '\n', '  modifier onlyAsset {\n', '    if (msg.sender != frontendAddress) throw;\n', '    _\n', '  }\n', '\n', '  /**\n', '   * Constructor.\n', '   *\n', '   */\n', '  function DVIPBackend(address _hotwalletAddress, address _frontendAddress) {\n', '    owner = msg.sender;\n', '    hotwalletAddress = _hotwalletAddress;\n', '    frontendAddress = _frontendAddress;\n', '    allowTransactions = true;\n', '    totalSupply = 0;\n', '    name = "DVIP";\n', '    symbol = "DVIP";\n', '    feeDecimals = 6;\n', '    expiry = 1514764800; //1 jan 2018\n', '    mustHoldFor = 86400;\n', '  }\n', '\n', '  function setHotwallet(address _address) onlyOwnerUnlocked {\n', '    hotwalletAddress = _address;\n', '    PropertySet(msg.sender);\n', '  }\n', '\n', '  function setFrontend(address _address) onlyOwnerUnlocked {\n', '    frontendAddress = _address;\n', '    PropertySet(msg.sender);\n', '  } \n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `msg.sender.address()` to `_to`.\n', '   *\n', '   * @param _to Address that will receive.\n', '   * @param _amount Amount to be transferred.\n', '   */\n', '  function transfer(address caller, address _to, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(balanceOf[caller] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    assert(!frozenAccount[caller]);\n', '    assert(!frozenAccount[_to]);\n', '    balanceOf[caller] -= _amount;\n', '    uint256 preBalance = balanceOf[_to];\n', '    balanceOf[_to] += _amount;\n', '    if (preBalance <= 1 && balanceOf[_to] >= 1) {\n', '      validAfter[_to] = now + mustHoldFor;\n', '    }\n', '    Transfer(caller, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `_amount` from `_from` to `_to`.\n', '   *\n', '   * @param _from Origin address\n', '   * @param _to Address that will receive\n', '   * @param _amount Amount to be transferred.\n', '   * @return result of the method call\n', '   */\n', '  function transferFrom(address caller, address _from, address _to, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    assert(balanceOf[_from] >= _amount);\n', '    assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '    assert(_amount <= allowance[_from][caller]);\n', '    assert(!frozenAccount[caller]);\n', '    assert(!frozenAccount[_from]);\n', '    assert(!frozenAccount[_to]);\n', '    balanceOf[_from] -= _amount;\n', '    uint256 preBalance = balanceOf[_to];\n', '    balanceOf[_to] += _amount;\n', '    allowance[_from][caller] -= _amount;\n', '    if (balanceOf[_to] >= 1 && preBalance <= 1) {\n', '      validAfter[_to] = now + mustHoldFor;\n', '    }\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @param _extraData Consequential contract to be executed by spender in same transcation.\n', '   * @return result of the method call\n', '   */\n', '  function approveAndCall(address caller, address _spender, uint256 _amount, bytes _extraData) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    allowance[caller][_spender] = _amount;\n', '    Relay(frontendAddress).relayReceiveApproval(caller, _spender, _amount, _extraData);\n', '    Approval(caller, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve spender `_spender` to transfer `_amount` from `msg.sender.address()`\n', '   *\n', '   * @param _spender Address that receives the cheque\n', '   * @param _amount Amount on the cheque\n', '   * @return result of the method call\n', '   */\n', '  function approve(address caller, address _spender, uint256 _amount) onlyAsset returns (bool success) {\n', '    assert(allowTransactions);\n', '    allowance[caller][_spender] = _amount;\n', '    Approval(caller, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* ---------------  multisig admin methods  --------------*/\n', '\n', '\n', '\n', '  /**\n', '   * @notice Sets the expiry time in milliseconds since 1970.\n', '   *\n', '   * @param ts milliseconds since 1970.\n', '   *\n', '   */\n', '  function setExpiry(uint256 ts) onlyOwner {\n', '    expiry = ts;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Mints `mintedAmount` new tokens to the hotwallet `hotWalletAddress`.\n', '   *\n', '   * @param mintedAmount Amount of new tokens to be minted.\n', '   */\n', '  function mint(uint256 mintedAmount) onlyOwner {\n', '    balanceOf[hotwalletAddress] += mintedAmount;\n', '    totalSupply += mintedAmount;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  function freezeAccount(address target, bool frozen) onlyOwner {\n', '    frozenAccount[target] = frozen;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  function seizeTokens(address target, uint256 amount) onlyOwner {\n', '    assert(balanceOf[target] >= amount);\n', '    assert(frozenAccount[target]);\n', '    balanceOf[target] -= amount;\n', '    balanceOf[hotwalletAddress] += amount;\n', '    Transfer(target, hotwalletAddress, amount);\n', '  }\n', '\n', '  function destroyTokens(uint256 amt) onlyOwner {\n', '    assert(balanceOf[hotwalletAddress] >= amt);\n', '    balanceOf[hotwalletAddress] -= amt;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets an export fee of `fee` on address `addr`\n', '   *\n', '   * @param addr Address for which the fee is valid\n', '   * @param addr fee Fee\n', '   *\n', '   */\n', '  function setExportFee(address addr, uint256 fee) onlyOwner {\n', '    exportFee[addr] = fee;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  function setHoldingPeriod(uint256 ts) onlyOwner {\n', '    mustHoldFor = ts;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  function setAllowTransactions(bool allow) onlyOwner {\n', '    allowTransactions = allow;\n', '    Processed(msg.sender);\n', '  }\n', '\n', '  /* --------------- fee calculation method ---------------- */\n', '\n', '\n', '  /**\n', "   * @notice 'Returns the fee for a transfer from `from` to `to` on an amount `amount`.\n", '   *\n', "   * Fee's consist of a possible\n", '   *    - import fee on transfers to an address\n', '   *    - export fee on transfers from an address\n', '   * DVIP ownership on an address\n', '   *    - reduces fee on a transfer from this address to an import fee-ed address\n', '   *    - reduces the fee on a transfer to this address from an export fee-ed address\n', '   * DVIP discount does not work for addresses that have an import fee or export fee set up against them.\n', '   *\n', '   * DVIP discount goes up to 100%\n', '   *\n', '   * @param from From address\n', '   * @param to To address\n', '   * @param amount Amount for which fee needs to be calculated.\n', '   *\n', '   */\n', '  function feeFor(address from, address to, uint256 amount) constant external returns (uint256 value) {\n', '    uint256 fee = exportFee[from];\n', '    if (fee == 0) return 0;\n', '    if ((exportFee[from] == 0 && balanceOf[from] != 0 && now < expiry && validAfter[from] <= now) || (balanceOf[to] != 0 && now < expiry && validAfter[to] <= now)) return 0;\n', '    return div10(amount*fee, feeDecimals);\n', '  }\n', '  function div10(uint256 a, uint8 b) internal returns (uint256 result) {\n', '    for (uint8 i = 0; i < b; i++) {\n', '      a /= 10;\n', '    }\n', '    return a;\n', '  }\n', '}']