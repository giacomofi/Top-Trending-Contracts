['pragma solidity ^0.4.11;\n', '\n', 'contract Grid {\n', '  // The account address with admin privilege to this contract\n', '  // This is also the default owner of all unowned pixels\n', '  address admin;\n', '\n', '  // The default price of unowned pixels\n', '  uint public defaultPrice;\n', '\n', '  // The price-fee ratio used in the following formula:\n', '  //   salePrice / feeRatio = fee\n', '  //   payout = salePrice - fee\n', '  // Higher feeRatio equates to lower fee percentage\n', '  uint public feeRatio;\n', '\n', '  // The price increment rate used in the following formula:\n', '  //   price = prevPrice + (prevPrice * incrementRate / 100);\n', '  uint public incrementRate;\n', '\n', '  struct Pixel {\n', '    // User with permission to modify the pixel. A successful sale of the\n', '    // pixel will result in payouts being credited to the pendingWithdrawal of\n', '    // the User\n', '    address owner;\n', '\n', '    // Current listed price of the pixel\n', '    uint price;\n', '\n', '    // Current color of the pixel. A valid of 0 is considered transparent and\n', '    // not black. Use 1 for black.\n', '    uint24 color;\n', '  }\n', '\n', '  // The state of the pixel grid\n', '  /*mapping(uint32 => Pixel) pixels;*/\n', '  Pixel[1000][1000] pixels;\n', '\n', '  // The state of all users who have transacted with this contract\n', '  mapping(address => uint) pendingWithdrawals;\n', '\n', '  // An optional message that is shown in some parts of the UI and in the\n', '  // details pane of every owned pixel\n', '  mapping(address => string) messages;\n', '\n', '  //============================================================================\n', '  // Events\n', '  //============================================================================\n', '\n', '  event PixelTransfer(uint16 row, uint16 col, uint price, address prevOwner, address newOwner);\n', '  event PixelColor(uint16 row, uint16 col, address owner, uint24 color);\n', '  event PixelPrice(uint16 row, uint16 col, address owner, uint price);\n', '\n', '  //============================================================================\n', '  // Basic API and helper functions\n', '  //============================================================================\n', '\n', '  function Grid(\n', '    uint _defaultPrice,\n', '    uint _feeRatio,\n', '    uint _incrementRate) {\n', '    admin = msg.sender;\n', '    defaultPrice = _defaultPrice;\n', '    feeRatio = _feeRatio;\n', '    incrementRate = _incrementRate;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner(uint16 row, uint16 col) {\n', '    require(msg.sender == getPixelOwner(row, col));\n', '    _;\n', '  }\n', '\n', '  modifier validPixel(uint16 row, uint16 col) {\n', '    require(row < 1000 && col < 1000);\n', '    _;\n', '  }\n', '\n', '  function() payable {}\n', '\n', '  //============================================================================\n', '  // Admin API\n', '  //============================================================================\n', '\n', '  function setAdmin(address _admin) onlyAdmin {\n', '    admin = _admin;\n', '  }\n', '\n', '  function setFeeRatio(uint _feeRatio) onlyAdmin {\n', '    feeRatio = _feeRatio;\n', '  }\n', '\n', '  function setDefaultPrice(uint _defaultPrice) onlyAdmin {\n', '    defaultPrice = _defaultPrice;\n', '  }\n', '\n', '  //============================================================================\n', '  // Public Querying API\n', '  //============================================================================\n', '\n', '  function getPixelColor(uint16 row, uint16 col) constant\n', '    validPixel(row, col) returns (uint24) {\n', '    return pixels[row][col].color;\n', '  }\n', '\n', '  function getPixelOwner(uint16 row, uint16 col) constant\n', '    validPixel(row, col) returns (address) {\n', '    if (pixels[row][col].owner == 0) {\n', '      return admin;\n', '    }\n', '    return pixels[row][col].owner;\n', '  }\n', '\n', '  function getPixelPrice(uint16 row, uint16 col) constant\n', '    validPixel(row,col) returns (uint) {\n', '    if (pixels[row][col].owner == 0) {\n', '      return defaultPrice;\n', '    }\n', '    return pixels[row][col].price;\n', '  }\n', '\n', '  function getUserMessage(address user) constant returns (string) {\n', '    return messages[user];\n', '  }\n', '\n', '  //============================================================================\n', '  // Public Transaction API\n', '  //============================================================================\n', '\n', '  function checkPendingWithdrawal() constant returns (uint) {\n', '    return pendingWithdrawals[msg.sender];\n', '  }\n', '\n', '  function withdraw() {\n', '    if (pendingWithdrawals[msg.sender] > 0) {\n', '      uint amount = pendingWithdrawals[msg.sender];\n', '      pendingWithdrawals[msg.sender] = 0;\n', '      msg.sender.transfer(amount);\n', '    }\n', '  }\n', '\n', '  function buyPixel(uint16 row, uint16 col, uint24 newColor) payable {\n', '    uint balance = pendingWithdrawals[msg.sender];\n', '    // Return instead of letting getKey throw here to correctly refund the\n', '    // transaction by updating the user balance in user.pendingWithdrawal\n', '    if (row >= 1000 || col >= 1000) {\n', '      pendingWithdrawals[msg.sender] = SafeMath.add(balance, msg.value);\n', '      return;\n', '    }\n', '\n', '    uint price = getPixelPrice(row, col);\n', '    address owner = getPixelOwner(row, col);\n', '\n', '    // Return instead of throw here to correctly refund the transaction by\n', '    // updating the user balance in user.pendingWithdrawal\n', '    if (msg.value < price) {\n', '      pendingWithdrawals[msg.sender] = SafeMath.add(balance, msg.value);\n', '      return;\n', '    }\n', '\n', '    uint fee = SafeMath.div(msg.value, feeRatio);\n', '    uint payout = SafeMath.sub(msg.value, fee);\n', '\n', '    uint adminBalance = pendingWithdrawals[admin];\n', '    pendingWithdrawals[admin] = SafeMath.add(adminBalance, fee);\n', '\n', '    uint ownerBalance = pendingWithdrawals[owner];\n', '    pendingWithdrawals[owner] = SafeMath.add(ownerBalance, payout);\n', '\n', '    // Increase the price automatically based on the global incrementRate\n', '    uint increase = SafeMath.div(SafeMath.mul(price, incrementRate), 100);\n', '    pixels[row][col].price = SafeMath.add(price, increase);\n', '    pixels[row][col].owner = msg.sender;\n', '\n', '    PixelTransfer(row, col, price, owner, msg.sender);\n', '    setPixelColor(row, col, newColor);\n', '  }\n', '\n', '  //============================================================================\n', '  // Owner Management API\n', '  //============================================================================\n', '\n', '  function setPixelColor(uint16 row, uint16 col, uint24 color)\n', '    validPixel(row, col) onlyOwner(row, col) {\n', '    if (pixels[row][col].color != color) {\n', '      pixels[row][col].color = color;\n', '      PixelColor(row, col, pixels[row][col].owner, color);\n', '    }\n', '  }\n', '\n', '  function setPixelPrice(uint16 row, uint16 col, uint newPrice)\n', '    validPixel(row, col) onlyOwner(row, col) {\n', '    // The owner can only lower the price. Price increases are determined by\n', '    // the global incrementRate\n', '    require(pixels[row][col].price > newPrice);\n', '\n', '    pixels[row][col].price = newPrice;\n', '    PixelPrice(row, col, pixels[row][col].owner, newPrice);\n', '  }\n', '\n', '  //============================================================================\n', '  // User Management API\n', '  //============================================================================\n', '\n', '  function setUserMessage(string message) {\n', '    messages[msg.sender] = message;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Grid {\n', '  // The account address with admin privilege to this contract\n', '  // This is also the default owner of all unowned pixels\n', '  address admin;\n', '\n', '  // The default price of unowned pixels\n', '  uint public defaultPrice;\n', '\n', '  // The price-fee ratio used in the following formula:\n', '  //   salePrice / feeRatio = fee\n', '  //   payout = salePrice - fee\n', '  // Higher feeRatio equates to lower fee percentage\n', '  uint public feeRatio;\n', '\n', '  // The price increment rate used in the following formula:\n', '  //   price = prevPrice + (prevPrice * incrementRate / 100);\n', '  uint public incrementRate;\n', '\n', '  struct Pixel {\n', '    // User with permission to modify the pixel. A successful sale of the\n', '    // pixel will result in payouts being credited to the pendingWithdrawal of\n', '    // the User\n', '    address owner;\n', '\n', '    // Current listed price of the pixel\n', '    uint price;\n', '\n', '    // Current color of the pixel. A valid of 0 is considered transparent and\n', '    // not black. Use 1 for black.\n', '    uint24 color;\n', '  }\n', '\n', '  // The state of the pixel grid\n', '  /*mapping(uint32 => Pixel) pixels;*/\n', '  Pixel[1000][1000] pixels;\n', '\n', '  // The state of all users who have transacted with this contract\n', '  mapping(address => uint) pendingWithdrawals;\n', '\n', '  // An optional message that is shown in some parts of the UI and in the\n', '  // details pane of every owned pixel\n', '  mapping(address => string) messages;\n', '\n', '  //============================================================================\n', '  // Events\n', '  //============================================================================\n', '\n', '  event PixelTransfer(uint16 row, uint16 col, uint price, address prevOwner, address newOwner);\n', '  event PixelColor(uint16 row, uint16 col, address owner, uint24 color);\n', '  event PixelPrice(uint16 row, uint16 col, address owner, uint price);\n', '\n', '  //============================================================================\n', '  // Basic API and helper functions\n', '  //============================================================================\n', '\n', '  function Grid(\n', '    uint _defaultPrice,\n', '    uint _feeRatio,\n', '    uint _incrementRate) {\n', '    admin = msg.sender;\n', '    defaultPrice = _defaultPrice;\n', '    feeRatio = _feeRatio;\n', '    incrementRate = _incrementRate;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner(uint16 row, uint16 col) {\n', '    require(msg.sender == getPixelOwner(row, col));\n', '    _;\n', '  }\n', '\n', '  modifier validPixel(uint16 row, uint16 col) {\n', '    require(row < 1000 && col < 1000);\n', '    _;\n', '  }\n', '\n', '  function() payable {}\n', '\n', '  //============================================================================\n', '  // Admin API\n', '  //============================================================================\n', '\n', '  function setAdmin(address _admin) onlyAdmin {\n', '    admin = _admin;\n', '  }\n', '\n', '  function setFeeRatio(uint _feeRatio) onlyAdmin {\n', '    feeRatio = _feeRatio;\n', '  }\n', '\n', '  function setDefaultPrice(uint _defaultPrice) onlyAdmin {\n', '    defaultPrice = _defaultPrice;\n', '  }\n', '\n', '  //============================================================================\n', '  // Public Querying API\n', '  //============================================================================\n', '\n', '  function getPixelColor(uint16 row, uint16 col) constant\n', '    validPixel(row, col) returns (uint24) {\n', '    return pixels[row][col].color;\n', '  }\n', '\n', '  function getPixelOwner(uint16 row, uint16 col) constant\n', '    validPixel(row, col) returns (address) {\n', '    if (pixels[row][col].owner == 0) {\n', '      return admin;\n', '    }\n', '    return pixels[row][col].owner;\n', '  }\n', '\n', '  function getPixelPrice(uint16 row, uint16 col) constant\n', '    validPixel(row,col) returns (uint) {\n', '    if (pixels[row][col].owner == 0) {\n', '      return defaultPrice;\n', '    }\n', '    return pixels[row][col].price;\n', '  }\n', '\n', '  function getUserMessage(address user) constant returns (string) {\n', '    return messages[user];\n', '  }\n', '\n', '  //============================================================================\n', '  // Public Transaction API\n', '  //============================================================================\n', '\n', '  function checkPendingWithdrawal() constant returns (uint) {\n', '    return pendingWithdrawals[msg.sender];\n', '  }\n', '\n', '  function withdraw() {\n', '    if (pendingWithdrawals[msg.sender] > 0) {\n', '      uint amount = pendingWithdrawals[msg.sender];\n', '      pendingWithdrawals[msg.sender] = 0;\n', '      msg.sender.transfer(amount);\n', '    }\n', '  }\n', '\n', '  function buyPixel(uint16 row, uint16 col, uint24 newColor) payable {\n', '    uint balance = pendingWithdrawals[msg.sender];\n', '    // Return instead of letting getKey throw here to correctly refund the\n', '    // transaction by updating the user balance in user.pendingWithdrawal\n', '    if (row >= 1000 || col >= 1000) {\n', '      pendingWithdrawals[msg.sender] = SafeMath.add(balance, msg.value);\n', '      return;\n', '    }\n', '\n', '    uint price = getPixelPrice(row, col);\n', '    address owner = getPixelOwner(row, col);\n', '\n', '    // Return instead of throw here to correctly refund the transaction by\n', '    // updating the user balance in user.pendingWithdrawal\n', '    if (msg.value < price) {\n', '      pendingWithdrawals[msg.sender] = SafeMath.add(balance, msg.value);\n', '      return;\n', '    }\n', '\n', '    uint fee = SafeMath.div(msg.value, feeRatio);\n', '    uint payout = SafeMath.sub(msg.value, fee);\n', '\n', '    uint adminBalance = pendingWithdrawals[admin];\n', '    pendingWithdrawals[admin] = SafeMath.add(adminBalance, fee);\n', '\n', '    uint ownerBalance = pendingWithdrawals[owner];\n', '    pendingWithdrawals[owner] = SafeMath.add(ownerBalance, payout);\n', '\n', '    // Increase the price automatically based on the global incrementRate\n', '    uint increase = SafeMath.div(SafeMath.mul(price, incrementRate), 100);\n', '    pixels[row][col].price = SafeMath.add(price, increase);\n', '    pixels[row][col].owner = msg.sender;\n', '\n', '    PixelTransfer(row, col, price, owner, msg.sender);\n', '    setPixelColor(row, col, newColor);\n', '  }\n', '\n', '  //============================================================================\n', '  // Owner Management API\n', '  //============================================================================\n', '\n', '  function setPixelColor(uint16 row, uint16 col, uint24 color)\n', '    validPixel(row, col) onlyOwner(row, col) {\n', '    if (pixels[row][col].color != color) {\n', '      pixels[row][col].color = color;\n', '      PixelColor(row, col, pixels[row][col].owner, color);\n', '    }\n', '  }\n', '\n', '  function setPixelPrice(uint16 row, uint16 col, uint newPrice)\n', '    validPixel(row, col) onlyOwner(row, col) {\n', '    // The owner can only lower the price. Price increases are determined by\n', '    // the global incrementRate\n', '    require(pixels[row][col].price > newPrice);\n', '\n', '    pixels[row][col].price = newPrice;\n', '    PixelPrice(row, col, pixels[row][col].owner, newPrice);\n', '  }\n', '\n', '  //============================================================================\n', '  // User Management API\n', '  //============================================================================\n', '\n', '  function setUserMessage(string message) {\n', '    messages[msg.sender] = message;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
