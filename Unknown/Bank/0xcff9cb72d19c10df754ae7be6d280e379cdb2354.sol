['contract quick {\n', '\n', '  struct Person {\n', '      address etherAddress;\n', '      uint amount;\n', '  }\n', '\n', '  Person[] public persons;\n', '\n', '  uint public payoutIdx = 0;\n', '  uint public collectedFees;\n', '  uint public balance = 0;\n', '\n', '  address public owner;\n', '\n', '\n', '  modifier onlyowner { if (msg.sender == owner) _ }\n', '\n', '\n', '  function quick() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function() {\n', '    enter();\n', '  }\n', '  \n', '  function enter() {\n', '    if (msg.value < 1 ether) {\n', '        msg.sender.send(msg.value);\n', '        return;\n', '    }\n', '\t\n', '\t\tuint amount;\n', '\t\tif (msg.value > 20 ether) {\n', '\t\t\tmsg.sender.send(msg.value - 20 ether);\t\n', '\t\t\tamount = 20 ether;\n', '    }\n', '\t\telse {\n', '\t\t\tamount = msg.value;\n', '\t\t}\n', '\n', '\n', '    uint idx = persons.length;\n', '    persons.length += 1;\n', '    persons[idx].etherAddress = msg.sender;\n', '    persons[idx].amount = amount;\n', ' \n', '    \n', '    if (idx != 0) {\n', '      collectedFees += amount / 10;\n', '\t  owner.send(collectedFees);\n', '\t  collectedFees = 0;\n', '      balance += amount - amount / 10;\n', '    } \n', '    else {\n', '      balance += amount;\n', '    }\n', '\n', '\n', '    while (balance > persons[payoutIdx].amount / 100 * 150) {\n', '      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n', '      persons[payoutIdx].etherAddress.send(transactionAmount);\n', '\n', '      balance -= transactionAmount;\n', '      payoutIdx += 1;\n', '    }\n', '  }\n', '\n', '\n', '  function setOwner(address _owner) onlyowner {\n', '      owner = _owner;\n', '  }\n', '}']