['/* Deployment:\n', 'Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e\n', 'Last address: 0x401e28717a6a35a50938bc7f290f2678fc0a2816\n', 'ABI: [{"constant":true,"inputs":[],"name":"gotParticipants","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_signature","type":"uint256[]"},{"name":"_x0","type":"uint256"},{"name":"_Ix","type":"uint256"},{"name":"_Iy","type":"uint256"}],"name":"withdrawStart","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"pubkeys2","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"payment","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"pubkeys1","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"participants","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"withdrawStep","outputs":[],"payable":false,"type":"function"},{"constant":false,"inputs":[],"name":"withdrawFinal","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_pubkey1","type":"uint256"},{"name":"_pubkey2","type":"uint256"}],"name":"deposit","outputs":[],"payable":true,"type":"function"},{"inputs":[{"name":"_participants","type":"uint256"},{"name":"_payment","type":"uint256"}],"type":"constructor"},{"payable":false,"type":"fallback"},{"anonymous":false,"inputs":[{"indexed":false,"name":"message","type":"string"}],"name":"LogDebug","type":"event"}]\n', 'Optimized: yes\n', 'Solidity version: v0.4.4\n', '*/\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract ArithLib {\n', '\n', '    function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint);\n', '    function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint);\n', '    function jsub(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint);\n', '    function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint);\n', '    function jexp(uint _b, uint _e, uint _m) constant returns (uint);\n', '    function jrecover_y(uint _x, uint _y_bit) constant returns (uint);\n', '    function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint);\n', '    function isbit(uint _data, uint _bit) constant returns (uint);\n', '    function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint);\n', '}\n', '\n', 'contract Laundromat {\n', '\n', '    struct WithdrawInfo {\n', '\n', '        address sender;\n', '        uint Ix;\n', '        uint Iy;\n', '        uint[] signature;\n', '        uint[] ring1;\n', '        uint[] ring2;\n', '        \n', '        uint step;\n', '        uint prevStep;\n', '    }\n', '\n', '    uint constant internal safeGas = 25000;\n', '    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;\n', '    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;\n', '    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;\n', '\n', '    address private owner;\n', '    bool private atomicLock;\n', '    \n', '    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;\n', '    ArithLib private arithContract;\n', '    mapping (uint => WithdrawInfo) private withdraws;\n', '    mapping (uint => bool) private consumed;\n', '\n', '    uint public participants = 0;\n', '    uint public payment = 0;\n', '    uint public gotParticipants = 0;\n', '    uint[] public pubkeys1;\n', '    uint[] public pubkeys2;\n', '\n', '    event LogDebug(string message);\n', '\n', '    //create new mixing contract with _participants amount of mixing participants,\n', '    //_payment - expected payment from each participant.\n', '    function Laundromat(uint _participants, uint _payment) {\n', '        owner = msg.sender;\n', '        arithContract = ArithLib(arithAddress);\n', '\n', '        participants = _participants;\n', '        payment = _payment;\n', '    }\n', '    \n', '    function safeSend(address addr, uint value) internal {\n', '\n', '        if(atomicLock) throw;\n', '        atomicLock = true;\n', '        if (!(addr.call.gas(safeGas).value(value)())) {\n', '            atomicLock = false;\n', '            throw;\n', '        }\n', '        atomicLock = false;\n', '    }\n', '\n', '    //add new participant to the mixing\n', '    function deposit(uint _pubkey1, uint _pubkey2) payable {\n', '        //if(msg.value != payment) throw;\n', '        if(gotParticipants >= participants) throw;\n', '\n', '        pubkeys1.push(_pubkey1);\n', '        pubkeys2.push(_pubkey2);\n', '        gotParticipants++;\n', '    }\n', '\n', '    //get funds from the mixer. Requires valid signature.\n', '    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {\n', '        if(gotParticipants < participants) throw;\n', '        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n', '\n', '        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n', '\n', '        withdraw.sender = msg.sender;\n', '        withdraw.Ix = _Ix;\n', '        withdraw.Iy = _Iy;\n', '        withdraw.signature = _signature;\n', '\n', '        withdraw.ring1.length = 0;\n', '        withdraw.ring2.length = 0;\n', '        withdraw.ring1.push(_x0);\n', '        withdraw.ring2.push(uint(sha3(_x0)));\n', '        \n', '        withdraw.step = 1;\n', '        withdraw.prevStep = 0;\n', '    }\n', '\n', '    function withdrawStep() {\n', '        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n', '\n', '        //throw if existing witdhraw not started\n', '        if(withdraw.step < 1) throw;\n', '        if(withdraw.step > participants) throw;\n', '        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n', '\n', '        uint k1x;\n', '        uint k1y;\n', '        uint k1z;\n', '        uint k2x;\n', '        uint k2y;\n', '        uint k2z;\n', '        uint pub1x;\n', '        uint pub1y;\n', '        \n', '        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,\n', '            withdraw.signature[withdraw.prevStep % participants]);\n', '        (k2x, k2y, k2z) = arithContract.jmul(\n', '            pubkeys1[withdraw.step % participants],\n', '            pubkeys2[withdraw.step % participants], 1,\n', '            withdraw.ring2[withdraw.prevStep % participants]);\n', '        //ksub1\n', '        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n', '        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);\n', '        //k3\n', '        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(\n', '            pubkeys1[withdraw.step % participants],\n', '            pubkeys2[withdraw.step % participants]);\n', '        //k4 = ecmul(k3, s[prev_i])\n', '        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,\n', '            withdraw.signature[withdraw.prevStep % participants]);\n', '        //k5 = ecmul(I, e[prev_i].right)\n', '        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,\n', '            withdraw.ring2[withdraw.prevStep % participants]);\n', '        //ksub2\n', '        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n', '        //pub2x, pub2y\n', '        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);\n', '        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));\n', '        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));\n', '        withdraw.step++;\n', '        withdraw.prevStep++;\n', '    }\n', '    \n', '    function withdrawFinal() returns (bool) {\n', '        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n', '        \n', '        if(withdraw.step != (participants + 1)) throw;\n', '        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n', '        if(withdraw.ring1[participants] != withdraw.ring1[0]) {\n', '            \n', '            LogDebug("Wrong signature");\n', '            return false;\n', '        }\n', '        if(withdraw.ring2[participants] != withdraw.ring2[0]) {\n', '            \n', '            LogDebug("Wrong signature");\n', '            return false;\n', '        }\n', '        \n', '        withdraw.step++;\n', '        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;\n', '        safeSend(withdraw.sender, payment);\n', '        return true;\n', '    }\n', '\n', '    function () {\n', '        throw;\n', '    }\n', '}']