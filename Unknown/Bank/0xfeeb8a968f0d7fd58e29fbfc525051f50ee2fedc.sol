['contract Etheramid1{\n', '\tfunction getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout );\n', '\tfunction getParticipantCount () public constant returns ( uint count );\n', '}\n', 'contract Etheramid2 {\n', '\n', '    struct Participant {\n', '        address inviter;\n', '        address itself;\n', '        uint totalPayout;\n', '    }\n', '    \n', '    mapping (address => Participant) Tree;\n', '    mapping (uint => address) Index;\n', '\t\n', '\tuint Count = 0;\n', '    address public top;\n', '    uint constant contribution = 1 ether;\n', '\t\n', ' \tEtheramid1 eth1 = Etheramid1(0x9758DA9B4D001Ed2d0DF46d25069Edf53750767a);\n', '\tuint oldUserCount = eth1.getParticipantCount();\n', '\t\n', '    function Etheramid2() {\n', '\t\tmoveOldUser(0);\n', '\t\ttop = Index[0];\n', '    }\n', '    \n', '    function() {\n', '\t\tthrow;\n', '    }\n', '    \n', '\tfunction moveOldUser (uint id) public {\n', '\t\taddress inviter; \n', '\t\taddress itself; \n', '\t\tuint totalPayout;\n', '\t\t(inviter, itself, totalPayout) = eth1.getParticipantById(id);\n', '\t\tif ((Tree[itself].inviter != 0x0) || (id >= oldUserCount)) throw;\n', '\t\taddParticipant(inviter, itself, totalPayout);\n', '\t}\n', '\t\n', '    function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout ){\n', '\t\tif (id >= Count) throw;\n', '\t\taddress ida = Index[id];\n', '        inviter = Tree[ida].inviter;\n', '        itself = Tree[ida].itself;\n', '        totalPayout = Tree[ida].totalPayout;\n', '    }\n', '\t\n', '\tfunction getParticipantByAddress (address adr) constant public returns ( address inviter, address itself, uint totalPayout ){\n', '\t\tif (Tree[adr].itself == 0x0) throw;\n', '        inviter = Tree[adr].inviter;\n', '        itself = Tree[adr].itself;\n', '        totalPayout = Tree[adr].totalPayout;\n', '    }\n', '    \n', '    function addParticipant(address inviter, address itself, uint totalPayout) private{\n', '        Index[Count] = itself;\n', '\t\tTree[itself] = Participant( {itself: itself, inviter: inviter, totalPayout: totalPayout});\n', '        Count +=1;\n', '    }\n', '    \n', '    function getParticipantCount () public constant returns ( uint count ){\n', '       count = Count;\n', '    }\n', '    \n', '    function enter(address inviter) public {\n', '        uint amount = msg.value;\n', '        if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) || (Tree[inviter].inviter == 0x0)) {\n', '            msg.sender.send(msg.value);\n', '            throw;\n', '        }\n', '        \n', '        addParticipant(inviter, msg.sender, 0);\n', '        address next = inviter;\n', '        uint rest = amount;\n', '        uint level = 1;\n', '        while ( (next != top) && (level < 7) ){\n', '            uint toSend = rest/2;\n', '            next.send(toSend);\n', '            Tree[next].totalPayout += toSend;\n', '            rest -= toSend;\n', '            next = Tree[next].inviter;\n', '            level++;\n', '        }\n', '        next.send(rest);\n', '\t\tTree[next].totalPayout += rest;\n', '    }\n', '}']