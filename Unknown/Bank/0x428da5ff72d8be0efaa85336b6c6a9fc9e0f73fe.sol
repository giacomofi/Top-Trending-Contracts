['contract NiceGuyPonzi {\n', '\n', '  struct Person {\n', '      address etherAddress;\n', '      uint amount;\n', '  }\n', '\n', '  Person[] public persons;\n', '\n', '  uint public payoutIdx = 0;\n', '  uint public collectedFees;\n', '  uint public balance = 0;\n', '  uint public niceGuy;\n', '\n', '  address public owner;\n', '\n', '\n', '  modifier onlyowner { if (msg.sender == owner) _ }\n', '\n', '\n', '  function NiceGuyPonzi() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function() {\n', '    enter();\n', '  }\n', '  \n', '  function enter() {\n', '    if (msg.value < 1/100 ether) {\n', '        msg.sender.send(msg.value);\n', '        return;\n', '    }\n', '\t\n', '\t\tuint amount;\n', '\t\tif (msg.value > 10 ether) {\n', '\t\t\tmsg.sender.send(msg.value - 10 ether);\t\n', '\t\t\tamount = 10 ether;\n', '    }\n', '\t\telse {\n', '\t\t\tamount = msg.value;\n', '\t\t}\n', '\n', '    if (niceGuy < 10){\n', '        uint idx = persons.length;\n', '        persons.length += 1;\n', '        persons[idx].etherAddress = msg.sender;\n', '        persons[idx].amount = amount;\n', '        niceGuy += 1;\n', '    }\n', '    else {\n', '        owner = msg.sender;\n', '        niceGuy = 0;\n', '        return;\n', '    }\n', '    \n', '    if (idx != 0) {\n', '      collectedFees += amount / 10;\n', '\t  owner.send(collectedFees);\n', '\t  collectedFees = 0;\n', '      balance += amount - amount / 10;\n', '    } \n', '    else {\n', '      balance += amount;\n', '    }\n', '\n', '\n', '    while (balance > persons[payoutIdx].amount / 100 * 125) {\n', '      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n', '      persons[payoutIdx].etherAddress.send(transactionAmount);\n', '      balance -= transactionAmount;\n', '      payoutIdx += 1;\n', '    }\n', '  }\n', '\n', '\n', '  function setOwner(address _owner) onlyowner {\n', '      owner = _owner;\n', '  }\n', '}']