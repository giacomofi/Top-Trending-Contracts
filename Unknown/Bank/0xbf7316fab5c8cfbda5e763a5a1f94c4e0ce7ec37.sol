['// A name registry in Ethereum\n', '\n', '// "Real" attempts to a name registry with Ethereum:\n', '// <http://etherid.org/> <https://github.com/sinking-point/dns2/>\n', '\n', '// TODO: use the registry interface described in\n', '// <https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs>?\n', '\n', '// Standard strings are poor, we need an extension library,\n', '// github.com/Arachnid/solidity-stringutils/strings.sol TODO: use it as soon as https://github.com/Arachnid/solidity-stringutils/issues/1 is solved.\n', '// import "strings.sol";\n', '\n', 'contract Registry {\n', '\n', '  // using strings for *; // TODO see above\n', '\n', '  address public nic; // The Network Information Center\n', '  \n', '  struct Record {\n', '    string value; // IP addresses, emails, etc TODO accept an array\n', '\t\t     // as soon as we have a strings library to\n', '\t\t     // serialize/deserialize. TODO type the values with an Enum\n', '    address holder;\n', '    bool exists; // Or a more detailed state, with an enum?\n', '    uint idx;\n', '  }\n', '  mapping (string => Record) records;\n', '  mapping (uint => string) index;\n', '  \n', '  // TODO define accessors instead\n', '  uint public maxRecords;\n', '  uint public currentRecords;\n', '\n', '  event debug(string indexed label, string msg);\n', '  event created(string indexed label, string indexed name, address holder, uint block);\n', '  event deleted(string indexed label, string indexed name, address holder, uint block);\n', '  \n', '  // "value" should be a comma-separated list of values. Solidity\n', '  // public functions cannot use arrays of strings :-( TODO: solve it\n', "  // when we'll have strings.\n", '  function register(string name, string value) {\n', '    /* TODO: pay the price */\n', '    uint i;\n', '    if (records[name].exists) {\n', '      if (msg.sender != records[name].holder) { // TODO: use modifiers instead\n', '\tthrow;\n', '      }\n', '      else {\n', '\ti = records[name].idx;\n', '      }\n', '    }\n', '    else {\n', '      records[name].idx = maxRecords;\n', '      i = maxRecords;\n', '      maxRecords++;\n', '    }\n', '    records[name].value = value;\n', '    records[name].holder = msg.sender;\n', '    records[name].exists = true;\n', '    currentRecords++;\n', '    index[i] = name;\n', '    created("CREATION", name, msg.sender, block.number);\t  \n', '  }\n', '\n', '  function transfer(string name, address to) {\n', '    if (records[name].exists) {\n', '      if (msg.sender != records[name].holder) {\n', '\tthrow;\n', '      }\n', '      records[name].holder = to;\n', '    }\n', '    else {\n', '      throw;\n', '    }\n', '  }\n', '  \n', '  function get(string name) constant returns(bool exists, string value) {\n', '    if (records[name].exists) {\n', '      exists = true;\n', '      value = records[name].value;\n', '    } else {\n', '      exists = false;\n', '    }\n', '  }\n', '\n', '  // Constructor\n', '  function Registry() {\n', '    nic = msg.sender;\n', '    currentRecords = 0;\n', '    maxRecords = 0;\n', '    register("NIC", "Automatically created by for the registry"); // TODO may fail if not\n', '    // enough gas in the creating transaction?\n', '  }\n', '  \n', '\n', '  function whois(string name) constant returns(bool exists, string value, address holder) {\n', '    if (records[name].exists) {\n', '      exists = true;\n', '      value = records[name].value;\n', '      holder = records[name].holder;\n', '    } else {\n', '      exists = false;\n', '    }\n', '  }\n', '\n', '  function remove(string name) {\n', '    uint i;\n', '    if (records[name].exists) {\n', '      if (msg.sender != records[name].holder) {\n', '\tthrow;\n', '      }\n', '      else {\n', '\ti = records[name].idx;\n', '      }\n', '    }\n', '    else {\n', '      throw; // 404. Too bad we cannot add content to throw.\n', '    }\n', '    records[name].exists = false;\n', '    currentRecords--;\n', '    deleted("DELETION", name, msg.sender, block.number);\t  \n', '  }\n', '\n', '  function download() returns(string all) {\n', '    if (msg.sender != nic) {\n', '\tthrow;\n', '      }\n', '    all = "NOT YET IMPLEMENTED";\n', '    // Looping over all the records is easy:\n', '    //for uint (i = 0; i < maxRecords; i++) {\n', '    //\tif (records[index[i]].exists) {\n', '    \n', '    // Or we could use an iterable mapping may\n', '    // be this library\n', '    // <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>\n', '\n', '    // The difficult part is to construct an answer, since Solidity\n', '    // does not provide string concatenation, or the ability to return\n', '    // arrays.\n', '\n', '\t// TODO: provide a function to access one item, using its index,\n', '\t// and to let the caller loops from 0 to maxRecords\n', '\t// http://stackoverflow.com/questions/37606839/how-to-return-mapping-list-in-solidity-ethereum-contract/37643972#37643972\n', '  }\n', '  \n', '}']