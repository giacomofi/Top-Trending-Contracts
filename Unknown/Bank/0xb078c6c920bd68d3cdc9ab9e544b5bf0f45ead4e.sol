['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token {\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'contract TokenLab is SafeMath {\n', '    address public admin;\n', '    address public feeAccount;\n', '    uint public feeMake;\n', '    uint public feeTake;\n', '    mapping (address => mapping (address => uint)) public tokens;\n', '    mapping (address => mapping (bytes32 => bool)) public orders;\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    function TokenLab(address feeAccount_, uint feeMake_, uint feeTake_) {\n', '        admin = msg.sender;\n', '        feeAccount = feeAccount_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    modifier onlyAdmin () {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    function changeAdmin(address admin_) onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) onlyAdmin {\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) onlyAdmin {\n', '        require (feeMake_ <= feeMake);\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) onlyAdmin {\n', '        require (feeTake_ <= feeTake);\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function deposit() payable {\n', '        tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '        Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) {\n', '        require(tokens[0][msg.sender] >= amount);\n', '        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '        require(msg.sender.call.value(amount)());\n', '        Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function depositToken(address token, uint amount) {\n', '        require (token!=0);\n', '        require (Token(token).transferFrom(msg.sender, this, amount));\n', '        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '        Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) {\n', '        require (token!=0);\n', '        require (tokens[token][msg.sender] >= amount);\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        require (Token(token).transfer(msg.sender, amount));\n', '        Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) constant returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        orders[msg.sender][hash] = true;\n', '        Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require ((\n', '        (orders[user][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '        block.number <= expires &&\n', '        safeAdd(orderFills[user][hash], amount) <= amountGet\n', '        ));\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n', '        Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n', '        tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(amount, feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeAdd(feeMakeXfer, feeTakeXfer));\n', '        tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n', '        if (!(\n', '        tokens[tokenGet][sender] >= amount &&\n', '        availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '        )) return false;\n', '        return true;\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '        (orders[user][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '        block.number <= expires\n', '        )) return 0;\n', '        uint available1 = safeSub(amountGet, orderFills[user][hash]);\n', '        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1<available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require ((orders[msg.sender][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == msg.sender));\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token {\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'contract TokenLab is SafeMath {\n', '    address public admin;\n', '    address public feeAccount;\n', '    uint public feeMake;\n', '    uint public feeTake;\n', '    mapping (address => mapping (address => uint)) public tokens;\n', '    mapping (address => mapping (bytes32 => bool)) public orders;\n', '    mapping (address => mapping (bytes32 => uint)) public orderFills;\n', '\n', '    event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n', '    event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '    event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    function TokenLab(address feeAccount_, uint feeMake_, uint feeTake_) {\n', '        admin = msg.sender;\n', '        feeAccount = feeAccount_;\n', '        feeMake = feeMake_;\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    modifier onlyAdmin () {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    function changeAdmin(address admin_) onlyAdmin {\n', '        admin = admin_;\n', '    }\n', '\n', '    function changeFeeAccount(address feeAccount_) onlyAdmin {\n', '        feeAccount = feeAccount_;\n', '    }\n', '\n', '    function changeFeeMake(uint feeMake_) onlyAdmin {\n', '        require (feeMake_ <= feeMake);\n', '        feeMake = feeMake_;\n', '    }\n', '\n', '    function changeFeeTake(uint feeTake_) onlyAdmin {\n', '        require (feeTake_ <= feeTake);\n', '        feeTake = feeTake_;\n', '    }\n', '\n', '    function deposit() payable {\n', '        tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '        Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function withdraw(uint amount) {\n', '        require(tokens[0][msg.sender] >= amount);\n', '        tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n', '        require(msg.sender.call.value(amount)());\n', '        Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '    }\n', '\n', '    function depositToken(address token, uint amount) {\n', '        require (token!=0);\n', '        require (Token(token).transferFrom(msg.sender, this, amount));\n', '        tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n', '        Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) {\n', '        require (token!=0);\n', '        require (tokens[token][msg.sender] >= amount);\n', '        tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n', '        require (Token(token).transfer(msg.sender, amount));\n', '        Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '    }\n', '\n', '    function balanceOf(address token, address user) constant returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        orders[msg.sender][hash] = true;\n', '        Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n', '    }\n', '\n', '    function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require ((\n', '        (orders[user][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '        block.number <= expires &&\n', '        safeAdd(orderFills[user][hash], amount) <= amountGet\n', '        ));\n', '        tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n', '        orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n', '        Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n', '    }\n', '\n', '    function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n', '        uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n', '        uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n', '        tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n', '        tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(amount, feeMakeXfer));\n', '        tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeAdd(feeMakeXfer, feeTakeXfer));\n', '        tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n', '        tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n', '    }\n', '\n', '    function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n', '        if (!(\n', '        tokens[tokenGet][sender] >= amount &&\n', '        availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n', '        )) return false;\n', '        return true;\n', '    }\n', '\n', '    function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        if (!(\n', '        (orders[user][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == user) &&\n', '        block.number <= expires\n', '        )) return 0;\n', '        uint available1 = safeSub(amountGet, orderFills[user][hash]);\n', '        uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n', '        if (available1<available2) return available1;\n', '        return available2;\n', '    }\n', '\n', '    function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user) constant returns(uint) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        return orderFills[user][hash];\n', '    }\n', '\n', '    function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n', '        bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n', '        require ((orders[msg.sender][hash] || ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash),v,r,s) == msg.sender));\n', '        orderFills[msg.sender][hash] = amountGet;\n', '        Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n', '    }\n', '}']
