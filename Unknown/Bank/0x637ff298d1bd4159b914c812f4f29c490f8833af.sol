['pragma solidity ^0.4.13;\n', '\n', 'contract EInterface { \n', '   \t  \n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) { }\n', '    function transferFrom(address _from, address _to, uint256 _value)  {}\n', '}\n', '\n', '\n', 'contract BidAskX {  \n', '   \n', '    //--------------------------------------------------------------------------EInterface\n', '    function allow_spend(address _coin) private returns(uint){  \n', '        EInterface pixiu = EInterface(_coin);\n', '        uint allow = pixiu.allowance(msg.sender, this);\n', '        return allow;\n', '        \n', '    }\n', '             \n', '    function transferFromTx(address _coin, address _from, address _to, uint256 _value) private {\n', '        EInterface pixiu = EInterface(_coin); \n', '        pixiu.transferFrom(_from, _to, _value);\n', '    }     \n', '    \n', '    //--------------------------------------------------------------------------event\n', '    event Logs(string); \n', '    event Log(string data, uint value, uint value1); \n', '    event Println(address _address,uint32 number, uint price, uint qty, uint ex_qty, bool isClosed,uint32 n32);\n', '    event Paydata(address indexed payer, uint256 value, bytes data, uint256 balances);\n', '        \n', '    //--------------------------------------------------------------------------admin\n', '    mapping (address => AdminType) admins;  \n', '    address[] adminArray;   \n', '    enum AdminType { none, normal, agent, admin, widthdraw }\n', '\n', '    //--------------------------------------------------------------------------member\n', '    struct Member {\n', '        bool isExists;                                    \n', '        bool isWithdraw;                                  \n', '        uint deposit;\n', '        uint withdraw;\n', '        uint balances;\n', '        uint bid_amount;\n', '        uint tx_amount;\n', '        uint ask_qty;\n', '        uint tx_qty;\n', '        address agent;\n', '    }\n', '    mapping (address => Member) public members;  \n', '    address[] public memberArray;\n', '\n', '    //--------------------------------------------------------------------------order\n', '    uint32 public order_number=1;\n', '    struct OrderSheet {\n', '        bool isAsk;\n', '        uint32 number;\n', '        address owner;\n', '        uint price;\n', '        uint qty;\n', '        uint amount;\n', '        uint exFee;\n', '        uint ex_qty;\n', '        bool isClosed;\n', '    }\n', '    address[] public tokensArray; \n', '    mapping (address => bool) tokens; \n', '    mapping (address => uint32[]) public token_ask; \n', '    mapping (address => uint32[]) public token_bid; \n', '    mapping (address => mapping(address => uint32[])) public token_member_order;\n', '    mapping (address => mapping(uint32 => OrderSheet)) public token_orderSheet;  \n', '\n', '    //--------------------------------------------------------------------------public\n', '    bool public isPayable = true;\n', '    bool public isWithdrawable = true;\n', '    bool public isRequireData = false;\n', '\tuint public MinimalPayValue = 0;\n', '\tuint public exFeeRate = 1000;\n', '\tuint public exFeeTotal = 0;\n', '    \n', '\n', '    function BidAskX(){  \n', '        \n', '        adminArray.push(msg.sender); \n', '        admins[msg.sender]=AdminType.widthdraw;\n', '        //ask(this);\n', '        \n', '    }\n', '\n', '    function list_token_ask(address _token){\n', '        uint32[] storage numbers = token_ask[_token];\n', '        for(uint i=0;i<numbers.length;i++){\n', '            uint32 n32 = numbers[i];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '        }\n', '    }\n', '    \n', '    function list_token_bid(address _token){\n', '        uint32[] storage numbers = token_bid[_token];\n', '        for(uint i=0;i<numbers.length;i++){\n', '            uint32 n32 = numbers[i];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '        }\n', '    }\n', '     \n', '    function tokens_push(address _token) private {\n', '        if(tokens[_token]!=true){\n', '            tokensArray.push(_token);\n', '            tokens[_token]=true;\n', '        }\n', '    }\n', '    \n', '    function token_member_order_pop(address _token, address _sender, uint32 _number) private {\n', '        for(uint i=0;k<token_member_order[_token][_sender].length-1;i++){\n', '            if(token_member_order[_token][_sender][i]==_number){\n', '                for(uint k=i;k<token_member_order[_token][_sender].length-2;k++){\n', '                    token_bid[_token][k]=token_bid[_token][k+1];\n', '                }\n', '                token_member_order[_token][_sender].length-=1;\n', '                break;\n', '            }\n', '        }\n', '    }\n', ' \n', '    function members_push(address _address) private {\n', '        if (members[_address].isExists != true) {\n', '            members[_address].isExists = true;\n', '            members[_address].isWithdraw = true; \n', '            members[msg.sender].deposit=0;\n', '            members[msg.sender].withdraw=0;\n', '            members[msg.sender].balances =0;\n', '            members[msg.sender].tx_amount=0;\n', '            members[msg.sender].bid_amount=0;\n', '            members[msg.sender].ask_qty=0;\n', '            members[msg.sender].tx_qty=0;\n', '            members[msg.sender].agent=address(0);\n', '            memberArray.push(_address); \n', '        }\n', '    }\n', '        \n', '    function cancel( address _token,uint32 _number){ \n', '        OrderSheet storage od = token_orderSheet[_token][_number];\n', '        if(od.owner==msg.sender){\n', '            uint i;\n', '            uint k;\n', '            if(od.isAsk){\n', '                \n', '                for(i=0; i<token_ask[_token].length;i++){\n', '                    if(token_ask[_token][i]==_number){\n', '                        od.isClosed = true;\n', '                        members[msg.sender].ask_qty - od.qty + od.ex_qty;\n', '                        for(k=i;k<token_ask[_token].length-2;k++){\n', '                            token_ask[_token][k]=token_ask[_token][k+1];\n', '                        }\n', '                        token_ask[_token].length-=1;\n', '                        break;\n', '                    }\n', '                }\n', '                \n', '            } else {\n', '            \n', '                for(i=0; i<token_bid[_token].length;i++){\n', '                    if(token_bid[_token][i]==_number){\n', '                        od.isClosed = true;\n', '                        members[msg.sender].bid_amount - od.amount + od.price*od.ex_qty;\n', '                        for(k=i;k<token_bid[_token].length-2;k++){\n', '                            token_bid[_token][k]=token_bid[_token][k+1];\n', '                        }\n', '                        token_bid[_token].length-=1;\n', '                        break;\n', '                    }\n', '                }\n', '                \n', '            }\n', '            token_member_order_pop(_token, msg.sender, _number);\n', '        } else {\n', '            Logs("The order owner not match");\n', '        }\n', '    }\n', '    \n', '    function bid( address _token, uint _qty, uint _priceEth, uint _priceWei){ \n', '        tokens_push(_token); \n', '        uint256 _price = _priceEth *10**18 + _priceWei;\n', '        uint exFee = (_qty * _price) / exFeeRate;\n', '        uint amount = (_qty * _price)+exFee;\n', '        \n', '        uint unclose = members[msg.sender].bid_amount - members[msg.sender].tx_amount;\n', '        uint remaining = members[msg.sender].balances - unclose;\n', '        if(remaining >= amount){\n', '            OrderSheet memory od;\n', '            od.isAsk = false;\n', '            od.number = order_number;\n', '            od.owner = msg.sender;\n', '            od.price = _price;\n', '            od.qty = _qty;\n', '            od.ex_qty=0;\n', '            od.exFee = (_price * _qty)/exFeeRate;\n', '            od.amount = (_price * _qty) + od.exFee;\n', '            od.isClosed=false; \n', '            token_orderSheet[_token][order_number]=od; \n', '            members[msg.sender].bid_amount+=amount;\n', '            token_member_order[_token][msg.sender].push(order_number);\n', '            bid_match(_token,token_orderSheet[_token][order_number],token_ask[_token]); \n', '            if(token_orderSheet[_token][order_number].isClosed==false){\n', '                token_bid[_token].push(order_number);   \n', '                Println(od.owner, od.number, od.price, od.qty, od.ex_qty, od.isClosed,777);\n', '            }\n', '            order_number++;\n', '        } else {\n', '            Log("You need more money for bid", remaining, amount);\n', '        }\n', '    }\n', '    \n', '    function ask( address _token, uint _qty, uint _priceEth, uint _priceWei){ \n', '        tokens_push(_token); \n', '        uint256 _price = _priceEth *10**18 + _priceWei;\n', '        uint unclose = members[msg.sender].ask_qty - members[msg.sender].tx_qty;\n', '        uint remaining = allow_spend(_token) - unclose;\n', '        uint exFee = (_price * _qty)/exFeeRate;\n', '        if(members[msg.sender].balances < exFee){\n', '            Log("You need to deposit ether to acoount befor ask", exFee, members[msg.sender].balances);\n', '        } else if(remaining >= _qty){\n', '            members_push(msg.sender);\n', '            OrderSheet memory od;\n', '            od.isAsk = true;\n', '            od.number = order_number;\n', '            od.owner = msg.sender;\n', '            od.price = _price;\n', '            od.qty = _qty;\n', '            od.ex_qty=0;\n', '            od.exFee = exFee;\n', '            od.amount = (_price * _qty) - exFee;\n', '            od.isClosed=false; \n', '            token_orderSheet[_token][order_number]=od; \n', '            members[msg.sender].ask_qty+=_qty;\n', '            token_member_order[_token][msg.sender].push(order_number);\n', '            ask_match(_token,token_orderSheet[_token][order_number],token_bid[_token]);\n', '            if(od.isClosed==false){\n', '                token_ask[_token].push(order_number);  \n', '                Log("Push order number to token_ask",order_number,0);\n', '            }\n', '            order_number++;\n', '        } else {\n', '            Log("You need approve your token for transfer",0,0);\n', '        }\n', '    }\n', '     \n', '    function ask_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \n', '        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\n', '            uint32 n32 = token_match[i-1];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            uint qty = oa.qty-oa.ex_qty;\n', '            if(oa.isClosed==false && qty>0){\n', '                uint ex_qty = (qty>od.qty?od.qty:qty);\n', '                uint ex_price = oa.price;\n', '                uint exFee = (ex_qty * ex_price) / exFeeRate;\n', '                uint amount = (ex_qty * ex_price);\n', '                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '                \n', '                if(members[oa.owner].balances >= amount && od.price <= oa.price){\n', '                    od.ex_qty += ex_qty;\n', '                    if(oa.ex_qty+ex_qty>=oa.qty){\n', '                        token_orderSheet[_token][n32].isClosed = true; \n', '                        for(uint k=i-1;k<token_match.length-2;k++){\n', '                            token_match[k]=token_match[k+1];\n', '                        }\n', '                    }\n', '                    token_orderSheet[_token][n32].ex_qty += ex_qty; \n', '                    transferFromTx(_token,  msg.sender, oa.owner, ex_qty); \n', '                    \n', '                    members[oa.owner].balances -= (amount+exFee);\n', '                    members[oa.owner].tx_amount += (amount+exFee);\n', '                    members[oa.owner].tx_qty += ex_qty;\n', '\n', '                    members[msg.sender].balances += (amount-exFee);\n', '                    members[msg.sender].tx_amount += (amount-exFee);\n', '                    members[msg.sender].tx_qty += ex_qty;\n', '                    \n', '                    if(od.ex_qty+ex_qty>=od.qty){\n', '                        od.isClosed = true; \n', '                    } \n', '                    exFeeTotal += exFee;\n', '                }\n', '            }\n', '        } \n', '    }\n', '    \n', '    function bid_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \n', '        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\n', '            uint32 n32 = token_match[i-1];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            uint qty = oa.qty-oa.ex_qty;\n', '            if(oa.isClosed==false && qty>0){\n', '                uint ex_qty = (qty>od.qty?od.qty:qty);\n', '                uint ex_price = oa.price;\n', '                uint exFee = (ex_qty * ex_price) / exFeeRate;\n', '                uint amount = (ex_qty * ex_price);\n', '                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,222); \n', '                if(members[msg.sender].balances >= amount && oa.price <= od.price){\n', '                    od.ex_qty += ex_qty;\n', '                    if(oa.ex_qty+ex_qty>=oa.qty){\n', '                        token_orderSheet[_token][n32].isClosed = true; \n', '                        for(uint k=i-1;k<token_match.length-2;k++){\n', '                            token_match[k]=token_match[k+1];\n', '                        }\n', '                    }\n', '                    token_orderSheet[_token][n32].ex_qty += ex_qty; \n', '                    //transferFromTx(_token, oa.owner, msg.sender, ex_qty); \n', '                    members[od.owner].balances += (amount-exFee);\n', '                    members[od.owner].tx_amount += (amount-exFee); \n', '                    members[od.owner].tx_qty += ex_qty; \n', '\n', '                    members[msg.sender].balances -= (amount+exFee);\n', '                    members[msg.sender].tx_amount += (amount+exFee);\n', '                    members[msg.sender].tx_qty += ex_qty;\n', '                    \n', '                    if(od.ex_qty+ex_qty>=od.qty){\n', '                        od.isClosed = true; \n', '                    }\n', '                    exFeeTotal += exFee;\n', '                } \n', '            }\n', '        } \n', '    }\n', '    \n', '  \n', '    //--------------------------------------------------------------------------member function\n', '    function withdraw(uint _eth, uint _wei) {\n', '        \n', '        for(uint i=0;i<tokensArray.length-1;i++){\n', '            address token = tokensArray[i];\n', '            uint32[] storage order = token_member_order[token][msg.sender];\n', '            for(uint j=0;j<order.length-1;j++){\n', '                cancel( token,order[j]);\n', '            }\n', '        }\n', '        \n', '        uint balances = members[msg.sender].balances;\n', '        uint withdraws = _eth*10**18 + _wei;\n', '        require( balances >= withdraws);\n', '        require( this.balance >= withdraws);\n', '        require(isWithdrawable);\n', '        require(members[msg.sender].isWithdraw);\n', '        msg.sender.transfer(withdraws);\n', '        members[msg.sender].balances -= withdraws;\n', '        members[msg.sender].withdraw += withdraws;  \n', '\n', '    }\n', '            \n', '    function get_this_balance() constant returns(uint256 _eth,uint256 _wei){\n', '      \n', '        _eth = this.balance / 10**18 ;\n', '        _wei = this.balance - _eth * 10**18 ;\n', '      \n', '    }\n', '    \n', '    \n', '    function pay() public payable returns (bool) {\n', '        \n', '        require(msg.value > MinimalPayValue);\n', '        require(isPayable);\n', '        \n', '        \n', '        if(admins[msg.sender] == AdminType.widthdraw){\n', '\n', '        }else{\n', '            \n', '            if(isRequireData){\n', '                require(admins[address(msg.data[0])] > AdminType.none);   \n', '            }\n', '        \n', '            members_push(msg.sender);\n', '            members[msg.sender].balances += msg.value;\n', '            members[msg.sender].deposit += msg.value;\n', '            if(admins[address(msg.data[0])]>AdminType.none){\n', '                members[msg.sender].agent = address(msg.data[0]);\n', '            }\n', '\n', '    \t\tPaydata(msg.sender, msg.value, msg.data, members[msg.sender].balances);\n', '\t\t\n', '        }\n', '        \n', '        return true;\n', '    \n', '    }\n', '\n', '   \n', '  \n', '\n', '    //--------------------------------------------------------------------------admin function\n', '    \n', '    modifier onlyAdmin() {\n', '        require(admins[msg.sender] > AdminType.agent);\n', '        _;\n', '    }\n', '\n', '    function admin_list() onlyAdmin constant returns(address[] _adminArray){\n', '        \n', '        _adminArray = adminArray; \n', '        \n', '    }    \n', '    \n', '    function admin_typeOf(address admin) onlyAdmin constant returns(AdminType adminType){\n', '          \n', '        adminType= admins[admin];\n', '        \n', '    }\n', '    \n', '    function admin_add_modify(address admin, AdminType adminType) onlyAdmin {\n', '        \n', '        require(admins[admin] > AdminType.agent);\n', '        if(admins[admin] < AdminType.normal){\n', '            adminArray.push(admin);\n', '        }\n', '        admins[admin]=AdminType(adminType);\n', '        \n', '    }\n', '    \n', '    function admin_del(address admin) onlyAdmin {\n', '        \n', '        require(admin!=msg.sender);\n', '        require(admins[admin] > AdminType.agent);\n', '        if(admins[admin] > AdminType.none){\n', '            admins[admin] = AdminType.none;\n', '            for (uint i = 0; i < adminArray.length - 1; i++) {\n', '                if (adminArray[i] == admin) {\n', '                    adminArray[i] = adminArray[adminArray.length - 1];\n', '                    adminArray.length -= 1;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        \n', '    }\n', '\n', '    function admin_withdraw(uint _eth, uint _wei) onlyAdmin {\n', '\n', '        require(admins[msg.sender] > AdminType.admin);\n', '        uint256 amount = _eth * 10**18 + _wei;\n', '\t\trequire(this.balance >= amount);\n', '\t\tmsg.sender.transfer(amount); \n', '        \n', '    }\n', '        \n', '\n', '\tfunction admin_exFeeRate(uint _rate) onlyAdmin {\n', '\t    \n', '\t    exFeeRate = _rate;\n', '\t    \n', '\t}\n', '     \t\n', '    function admin_MinimalPayValue(uint _eth, uint _wei) onlyAdmin {\n', '\t    \n', '\t    MinimalPayValue = _eth*10*18 + _wei;\n', '\t    \n', '\t}\n', '     \n', '    function admin_isRequireData(bool _requireData) onlyAdmin{\n', '    \n', '        isRequireData = _requireData;\n', '        \n', '    }\n', '    \n', '    function admin_isPayable(bool _payable) onlyAdmin{\n', '    \n', '        isPayable = _payable;\n', '        \n', '    }\n', '    \n', '    function admin_isWithdrawable(bool _withdrawable) onlyAdmin{\n', '        \n', '        isWithdrawable = _withdrawable;\n', '        \n', '    }\n', '    \n', '    function admin_member_isWithdraw(address _member, bool _withdrawable) onlyAdmin {\n', '        if(members[_member].isExists == true) {\n', '            members[_member].isWithdraw = _withdrawable;\n', '        } else {\n', '            Logs("member not existes");\n', '        }\n', '    }\n', '    \n', '    \n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract EInterface { \n', '   \t  \n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) { }\n', '    function transferFrom(address _from, address _to, uint256 _value)  {}\n', '}\n', '\n', '\n', 'contract BidAskX {  \n', '   \n', '    //--------------------------------------------------------------------------EInterface\n', '    function allow_spend(address _coin) private returns(uint){  \n', '        EInterface pixiu = EInterface(_coin);\n', '        uint allow = pixiu.allowance(msg.sender, this);\n', '        return allow;\n', '        \n', '    }\n', '             \n', '    function transferFromTx(address _coin, address _from, address _to, uint256 _value) private {\n', '        EInterface pixiu = EInterface(_coin); \n', '        pixiu.transferFrom(_from, _to, _value);\n', '    }     \n', '    \n', '    //--------------------------------------------------------------------------event\n', '    event Logs(string); \n', '    event Log(string data, uint value, uint value1); \n', '    event Println(address _address,uint32 number, uint price, uint qty, uint ex_qty, bool isClosed,uint32 n32);\n', '    event Paydata(address indexed payer, uint256 value, bytes data, uint256 balances);\n', '        \n', '    //--------------------------------------------------------------------------admin\n', '    mapping (address => AdminType) admins;  \n', '    address[] adminArray;   \n', '    enum AdminType { none, normal, agent, admin, widthdraw }\n', '\n', '    //--------------------------------------------------------------------------member\n', '    struct Member {\n', '        bool isExists;                                    \n', '        bool isWithdraw;                                  \n', '        uint deposit;\n', '        uint withdraw;\n', '        uint balances;\n', '        uint bid_amount;\n', '        uint tx_amount;\n', '        uint ask_qty;\n', '        uint tx_qty;\n', '        address agent;\n', '    }\n', '    mapping (address => Member) public members;  \n', '    address[] public memberArray;\n', '\n', '    //--------------------------------------------------------------------------order\n', '    uint32 public order_number=1;\n', '    struct OrderSheet {\n', '        bool isAsk;\n', '        uint32 number;\n', '        address owner;\n', '        uint price;\n', '        uint qty;\n', '        uint amount;\n', '        uint exFee;\n', '        uint ex_qty;\n', '        bool isClosed;\n', '    }\n', '    address[] public tokensArray; \n', '    mapping (address => bool) tokens; \n', '    mapping (address => uint32[]) public token_ask; \n', '    mapping (address => uint32[]) public token_bid; \n', '    mapping (address => mapping(address => uint32[])) public token_member_order;\n', '    mapping (address => mapping(uint32 => OrderSheet)) public token_orderSheet;  \n', '\n', '    //--------------------------------------------------------------------------public\n', '    bool public isPayable = true;\n', '    bool public isWithdrawable = true;\n', '    bool public isRequireData = false;\n', '\tuint public MinimalPayValue = 0;\n', '\tuint public exFeeRate = 1000;\n', '\tuint public exFeeTotal = 0;\n', '    \n', '\n', '    function BidAskX(){  \n', '        \n', '        adminArray.push(msg.sender); \n', '        admins[msg.sender]=AdminType.widthdraw;\n', '        //ask(this);\n', '        \n', '    }\n', '\n', '    function list_token_ask(address _token){\n', '        uint32[] storage numbers = token_ask[_token];\n', '        for(uint i=0;i<numbers.length;i++){\n', '            uint32 n32 = numbers[i];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '        }\n', '    }\n', '    \n', '    function list_token_bid(address _token){\n', '        uint32[] storage numbers = token_bid[_token];\n', '        for(uint i=0;i<numbers.length;i++){\n', '            uint32 n32 = numbers[i];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '        }\n', '    }\n', '     \n', '    function tokens_push(address _token) private {\n', '        if(tokens[_token]!=true){\n', '            tokensArray.push(_token);\n', '            tokens[_token]=true;\n', '        }\n', '    }\n', '    \n', '    function token_member_order_pop(address _token, address _sender, uint32 _number) private {\n', '        for(uint i=0;k<token_member_order[_token][_sender].length-1;i++){\n', '            if(token_member_order[_token][_sender][i]==_number){\n', '                for(uint k=i;k<token_member_order[_token][_sender].length-2;k++){\n', '                    token_bid[_token][k]=token_bid[_token][k+1];\n', '                }\n', '                token_member_order[_token][_sender].length-=1;\n', '                break;\n', '            }\n', '        }\n', '    }\n', ' \n', '    function members_push(address _address) private {\n', '        if (members[_address].isExists != true) {\n', '            members[_address].isExists = true;\n', '            members[_address].isWithdraw = true; \n', '            members[msg.sender].deposit=0;\n', '            members[msg.sender].withdraw=0;\n', '            members[msg.sender].balances =0;\n', '            members[msg.sender].tx_amount=0;\n', '            members[msg.sender].bid_amount=0;\n', '            members[msg.sender].ask_qty=0;\n', '            members[msg.sender].tx_qty=0;\n', '            members[msg.sender].agent=address(0);\n', '            memberArray.push(_address); \n', '        }\n', '    }\n', '        \n', '    function cancel( address _token,uint32 _number){ \n', '        OrderSheet storage od = token_orderSheet[_token][_number];\n', '        if(od.owner==msg.sender){\n', '            uint i;\n', '            uint k;\n', '            if(od.isAsk){\n', '                \n', '                for(i=0; i<token_ask[_token].length;i++){\n', '                    if(token_ask[_token][i]==_number){\n', '                        od.isClosed = true;\n', '                        members[msg.sender].ask_qty - od.qty + od.ex_qty;\n', '                        for(k=i;k<token_ask[_token].length-2;k++){\n', '                            token_ask[_token][k]=token_ask[_token][k+1];\n', '                        }\n', '                        token_ask[_token].length-=1;\n', '                        break;\n', '                    }\n', '                }\n', '                \n', '            } else {\n', '            \n', '                for(i=0; i<token_bid[_token].length;i++){\n', '                    if(token_bid[_token][i]==_number){\n', '                        od.isClosed = true;\n', '                        members[msg.sender].bid_amount - od.amount + od.price*od.ex_qty;\n', '                        for(k=i;k<token_bid[_token].length-2;k++){\n', '                            token_bid[_token][k]=token_bid[_token][k+1];\n', '                        }\n', '                        token_bid[_token].length-=1;\n', '                        break;\n', '                    }\n', '                }\n', '                \n', '            }\n', '            token_member_order_pop(_token, msg.sender, _number);\n', '        } else {\n', '            Logs("The order owner not match");\n', '        }\n', '    }\n', '    \n', '    function bid( address _token, uint _qty, uint _priceEth, uint _priceWei){ \n', '        tokens_push(_token); \n', '        uint256 _price = _priceEth *10**18 + _priceWei;\n', '        uint exFee = (_qty * _price) / exFeeRate;\n', '        uint amount = (_qty * _price)+exFee;\n', '        \n', '        uint unclose = members[msg.sender].bid_amount - members[msg.sender].tx_amount;\n', '        uint remaining = members[msg.sender].balances - unclose;\n', '        if(remaining >= amount){\n', '            OrderSheet memory od;\n', '            od.isAsk = false;\n', '            od.number = order_number;\n', '            od.owner = msg.sender;\n', '            od.price = _price;\n', '            od.qty = _qty;\n', '            od.ex_qty=0;\n', '            od.exFee = (_price * _qty)/exFeeRate;\n', '            od.amount = (_price * _qty) + od.exFee;\n', '            od.isClosed=false; \n', '            token_orderSheet[_token][order_number]=od; \n', '            members[msg.sender].bid_amount+=amount;\n', '            token_member_order[_token][msg.sender].push(order_number);\n', '            bid_match(_token,token_orderSheet[_token][order_number],token_ask[_token]); \n', '            if(token_orderSheet[_token][order_number].isClosed==false){\n', '                token_bid[_token].push(order_number);   \n', '                Println(od.owner, od.number, od.price, od.qty, od.ex_qty, od.isClosed,777);\n', '            }\n', '            order_number++;\n', '        } else {\n', '            Log("You need more money for bid", remaining, amount);\n', '        }\n', '    }\n', '    \n', '    function ask( address _token, uint _qty, uint _priceEth, uint _priceWei){ \n', '        tokens_push(_token); \n', '        uint256 _price = _priceEth *10**18 + _priceWei;\n', '        uint unclose = members[msg.sender].ask_qty - members[msg.sender].tx_qty;\n', '        uint remaining = allow_spend(_token) - unclose;\n', '        uint exFee = (_price * _qty)/exFeeRate;\n', '        if(members[msg.sender].balances < exFee){\n', '            Log("You need to deposit ether to acoount befor ask", exFee, members[msg.sender].balances);\n', '        } else if(remaining >= _qty){\n', '            members_push(msg.sender);\n', '            OrderSheet memory od;\n', '            od.isAsk = true;\n', '            od.number = order_number;\n', '            od.owner = msg.sender;\n', '            od.price = _price;\n', '            od.qty = _qty;\n', '            od.ex_qty=0;\n', '            od.exFee = exFee;\n', '            od.amount = (_price * _qty) - exFee;\n', '            od.isClosed=false; \n', '            token_orderSheet[_token][order_number]=od; \n', '            members[msg.sender].ask_qty+=_qty;\n', '            token_member_order[_token][msg.sender].push(order_number);\n', '            ask_match(_token,token_orderSheet[_token][order_number],token_bid[_token]);\n', '            if(od.isClosed==false){\n', '                token_ask[_token].push(order_number);  \n', '                Log("Push order number to token_ask",order_number,0);\n', '            }\n', '            order_number++;\n', '        } else {\n', '            Log("You need approve your token for transfer",0,0);\n', '        }\n', '    }\n', '     \n', '    function ask_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \n', '        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\n', '            uint32 n32 = token_match[i-1];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            uint qty = oa.qty-oa.ex_qty;\n', '            if(oa.isClosed==false && qty>0){\n', '                uint ex_qty = (qty>od.qty?od.qty:qty);\n', '                uint ex_price = oa.price;\n', '                uint exFee = (ex_qty * ex_price) / exFeeRate;\n', '                uint amount = (ex_qty * ex_price);\n', '                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,n32);\n', '                \n', '                if(members[oa.owner].balances >= amount && od.price <= oa.price){\n', '                    od.ex_qty += ex_qty;\n', '                    if(oa.ex_qty+ex_qty>=oa.qty){\n', '                        token_orderSheet[_token][n32].isClosed = true; \n', '                        for(uint k=i-1;k<token_match.length-2;k++){\n', '                            token_match[k]=token_match[k+1];\n', '                        }\n', '                    }\n', '                    token_orderSheet[_token][n32].ex_qty += ex_qty; \n', '                    transferFromTx(_token,  msg.sender, oa.owner, ex_qty); \n', '                    \n', '                    members[oa.owner].balances -= (amount+exFee);\n', '                    members[oa.owner].tx_amount += (amount+exFee);\n', '                    members[oa.owner].tx_qty += ex_qty;\n', '\n', '                    members[msg.sender].balances += (amount-exFee);\n', '                    members[msg.sender].tx_amount += (amount-exFee);\n', '                    members[msg.sender].tx_qty += ex_qty;\n', '                    \n', '                    if(od.ex_qty+ex_qty>=od.qty){\n', '                        od.isClosed = true; \n', '                    } \n', '                    exFeeTotal += exFee;\n', '                }\n', '            }\n', '        } \n', '    }\n', '    \n', '    function bid_match(address _token, OrderSheet storage od, uint32[] storage token_match) private { \n', '        for(uint i=token_match.length;i>0 && od.qty>od.ex_qty;i--){\n', '            uint32 n32 = token_match[i-1];\n', '            OrderSheet storage oa = token_orderSheet[_token][n32];\n', '            uint qty = oa.qty-oa.ex_qty;\n', '            if(oa.isClosed==false && qty>0){\n', '                uint ex_qty = (qty>od.qty?od.qty:qty);\n', '                uint ex_price = oa.price;\n', '                uint exFee = (ex_qty * ex_price) / exFeeRate;\n', '                uint amount = (ex_qty * ex_price);\n', '                Println(oa.owner, oa.number, oa.price, oa.qty, oa.ex_qty, oa.isClosed,222); \n', '                if(members[msg.sender].balances >= amount && oa.price <= od.price){\n', '                    od.ex_qty += ex_qty;\n', '                    if(oa.ex_qty+ex_qty>=oa.qty){\n', '                        token_orderSheet[_token][n32].isClosed = true; \n', '                        for(uint k=i-1;k<token_match.length-2;k++){\n', '                            token_match[k]=token_match[k+1];\n', '                        }\n', '                    }\n', '                    token_orderSheet[_token][n32].ex_qty += ex_qty; \n', '                    //transferFromTx(_token, oa.owner, msg.sender, ex_qty); \n', '                    members[od.owner].balances += (amount-exFee);\n', '                    members[od.owner].tx_amount += (amount-exFee); \n', '                    members[od.owner].tx_qty += ex_qty; \n', '\n', '                    members[msg.sender].balances -= (amount+exFee);\n', '                    members[msg.sender].tx_amount += (amount+exFee);\n', '                    members[msg.sender].tx_qty += ex_qty;\n', '                    \n', '                    if(od.ex_qty+ex_qty>=od.qty){\n', '                        od.isClosed = true; \n', '                    }\n', '                    exFeeTotal += exFee;\n', '                } \n', '            }\n', '        } \n', '    }\n', '    \n', '  \n', '    //--------------------------------------------------------------------------member function\n', '    function withdraw(uint _eth, uint _wei) {\n', '        \n', '        for(uint i=0;i<tokensArray.length-1;i++){\n', '            address token = tokensArray[i];\n', '            uint32[] storage order = token_member_order[token][msg.sender];\n', '            for(uint j=0;j<order.length-1;j++){\n', '                cancel( token,order[j]);\n', '            }\n', '        }\n', '        \n', '        uint balances = members[msg.sender].balances;\n', '        uint withdraws = _eth*10**18 + _wei;\n', '        require( balances >= withdraws);\n', '        require( this.balance >= withdraws);\n', '        require(isWithdrawable);\n', '        require(members[msg.sender].isWithdraw);\n', '        msg.sender.transfer(withdraws);\n', '        members[msg.sender].balances -= withdraws;\n', '        members[msg.sender].withdraw += withdraws;  \n', '\n', '    }\n', '            \n', '    function get_this_balance() constant returns(uint256 _eth,uint256 _wei){\n', '      \n', '        _eth = this.balance / 10**18 ;\n', '        _wei = this.balance - _eth * 10**18 ;\n', '      \n', '    }\n', '    \n', '    \n', '    function pay() public payable returns (bool) {\n', '        \n', '        require(msg.value > MinimalPayValue);\n', '        require(isPayable);\n', '        \n', '        \n', '        if(admins[msg.sender] == AdminType.widthdraw){\n', '\n', '        }else{\n', '            \n', '            if(isRequireData){\n', '                require(admins[address(msg.data[0])] > AdminType.none);   \n', '            }\n', '        \n', '            members_push(msg.sender);\n', '            members[msg.sender].balances += msg.value;\n', '            members[msg.sender].deposit += msg.value;\n', '            if(admins[address(msg.data[0])]>AdminType.none){\n', '                members[msg.sender].agent = address(msg.data[0]);\n', '            }\n', '\n', '    \t\tPaydata(msg.sender, msg.value, msg.data, members[msg.sender].balances);\n', '\t\t\n', '        }\n', '        \n', '        return true;\n', '    \n', '    }\n', '\n', '   \n', '  \n', '\n', '    //--------------------------------------------------------------------------admin function\n', '    \n', '    modifier onlyAdmin() {\n', '        require(admins[msg.sender] > AdminType.agent);\n', '        _;\n', '    }\n', '\n', '    function admin_list() onlyAdmin constant returns(address[] _adminArray){\n', '        \n', '        _adminArray = adminArray; \n', '        \n', '    }    \n', '    \n', '    function admin_typeOf(address admin) onlyAdmin constant returns(AdminType adminType){\n', '          \n', '        adminType= admins[admin];\n', '        \n', '    }\n', '    \n', '    function admin_add_modify(address admin, AdminType adminType) onlyAdmin {\n', '        \n', '        require(admins[admin] > AdminType.agent);\n', '        if(admins[admin] < AdminType.normal){\n', '            adminArray.push(admin);\n', '        }\n', '        admins[admin]=AdminType(adminType);\n', '        \n', '    }\n', '    \n', '    function admin_del(address admin) onlyAdmin {\n', '        \n', '        require(admin!=msg.sender);\n', '        require(admins[admin] > AdminType.agent);\n', '        if(admins[admin] > AdminType.none){\n', '            admins[admin] = AdminType.none;\n', '            for (uint i = 0; i < adminArray.length - 1; i++) {\n', '                if (adminArray[i] == admin) {\n', '                    adminArray[i] = adminArray[adminArray.length - 1];\n', '                    adminArray.length -= 1;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        \n', '    }\n', '\n', '    function admin_withdraw(uint _eth, uint _wei) onlyAdmin {\n', '\n', '        require(admins[msg.sender] > AdminType.admin);\n', '        uint256 amount = _eth * 10**18 + _wei;\n', '\t\trequire(this.balance >= amount);\n', '\t\tmsg.sender.transfer(amount); \n', '        \n', '    }\n', '        \n', '\n', '\tfunction admin_exFeeRate(uint _rate) onlyAdmin {\n', '\t    \n', '\t    exFeeRate = _rate;\n', '\t    \n', '\t}\n', '     \t\n', '    function admin_MinimalPayValue(uint _eth, uint _wei) onlyAdmin {\n', '\t    \n', '\t    MinimalPayValue = _eth*10*18 + _wei;\n', '\t    \n', '\t}\n', '     \n', '    function admin_isRequireData(bool _requireData) onlyAdmin{\n', '    \n', '        isRequireData = _requireData;\n', '        \n', '    }\n', '    \n', '    function admin_isPayable(bool _payable) onlyAdmin{\n', '    \n', '        isPayable = _payable;\n', '        \n', '    }\n', '    \n', '    function admin_isWithdrawable(bool _withdrawable) onlyAdmin{\n', '        \n', '        isWithdrawable = _withdrawable;\n', '        \n', '    }\n', '    \n', '    function admin_member_isWithdraw(address _member, bool _withdrawable) onlyAdmin {\n', '        if(members[_member].isExists == true) {\n', '            members[_member].isWithdraw = _withdrawable;\n', '        } else {\n', '            Logs("member not existes");\n', '        }\n', '    }\n', '    \n', '    \n', '}']
