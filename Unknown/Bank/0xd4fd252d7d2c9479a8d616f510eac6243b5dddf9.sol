['pragma solidity 0.4.14;\n', '\n', '/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <<span class="__cf_email__" data-cfemail="b5d4d8dcc7f585cde5c7dadfd0d6c19bd6dad8">[email&#160;protected]</span>>, Will Warren - <<span class="__cf_email__" data-cfemail="b9ced0d5d5f989c1e9cbd6d3dcdacd97dad6d4">[email&#160;protected]</span>>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return Token(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '/// @title Exchange - Facilitates exchange of ERC20 tokens.\n', '/// @author Amir Bandeali - <<span class="__cf_email__" data-cfemail="a6c7cbcfd4e696def6d4c9ccc3c5d288c5c9cb">[email&#160;protected]</span>>, Will Warren - <<span class="__cf_email__" data-cfemail="74031d181834440c24061b1e1117005a171b19">[email&#160;protected]</span>>\n', 'contract Exchange is SafeMath {\n', '\n', '    // Error Codes\n', '    enum Errors {\n', '        ORDER_EXPIRED,                    // Order has already expired\n', '        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n', '        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n', '        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n', '    }\n', '\n', '    string constant public VERSION = "1.0.0";\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    address public ZRX_TOKEN_CONTRACT;\n', '    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n', '\n', '    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n', '    mapping (bytes32 => uint) public filled;\n', '    mapping (bytes32 => uint) public cancelled;\n', '\n', '    event LogFill(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint filledMakerTokenAmount,\n', '        uint filledTakerTokenAmount,\n', '        uint paidMakerFee,\n', '        uint paidTakerFee,\n', '        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogCancel(\n', '        address indexed maker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint cancelledMakerTokenAmount,\n', '        uint cancelledTakerTokenAmount,\n', '        bytes32 indexed tokens,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    function Exchange(address _zrxToken, address _tokenTransferProxy) {\n', '        ZRX_TOKEN_CONTRACT = _zrxToken;\n', '        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\n', '    }\n', '\n', '    /*\n', '    * Core exchange functions\n', '    */\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Total amount of takerToken filled in trade.\n', '    function fillOrder(\n', '          address[5] orderAddresses,\n', '          uint[6] orderValues,\n', '          uint fillTakerTokenAmount,\n', '          bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '          uint8 v,\n', '          bytes32 r,\n', '          bytes32 s)\n', '          public\n', '          returns (uint filledTakerTokenAmount)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(0) || order.taker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (filledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\n', '            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\n', '            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '        uint paidMakerFee;\n', '        uint paidTakerFee;\n', '        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\n', '        require(transferViaTokenTransferProxy(\n', '            order.makerToken,\n', '            order.maker,\n', '            msg.sender,\n', '            filledMakerTokenAmount\n', '        ));\n', '        require(transferViaTokenTransferProxy(\n', '            order.takerToken,\n', '            msg.sender,\n', '            order.maker,\n', '            filledTakerTokenAmount\n', '        ));\n', '        if (order.feeRecipient != address(0)) {\n', '            if (order.makerFee > 0) {\n', '                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    order.maker,\n', '                    order.feeRecipient,\n', '                    paidMakerFee\n', '                ));\n', '            }\n', '            if (order.takerFee > 0) {\n', '                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    msg.sender,\n', '                    order.feeRecipient,\n', '                    paidTakerFee\n', '                ));\n', '            }\n', '        }\n', '\n', '        LogFill(\n', '            order.maker,\n', '            msg.sender,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            filledMakerTokenAmount,\n', '            filledTakerTokenAmount,\n', '            paidMakerFee,\n', '            paidTakerFee,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Cancels the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n', '    /// @return Amount of takerToken cancelled.\n', '    function cancelOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint cancelTakerTokenAmount)\n', '        public\n', '        returns (uint)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.maker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (cancelledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\n', '\n', '        LogCancel(\n', '            order.maker,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\n', '            cancelledTakerTokenAmount,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return cancelledTakerTokenAmount;\n', '    }\n', '\n', '    /*\n', '    * Wrapper functions\n', '    */\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    function fillOrKillOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '    {\n', '        require(fillOrder(\n', '            orderAddresses,\n', '            orderValues,\n', '            fillTakerTokenAmount,\n', '            false,\n', '            v,\n', '            r,\n', '            s\n', '        ) == fillTakerTokenAmount);\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrKillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrKillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    /// @return Total amount of fillTakerTokenAmount filled in orders.\n', '    function fillOrdersUpTo(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '        returns (uint)\n', '    {\n', '        uint filledTakerTokenAmount = 0;\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\n', '            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            ));\n', '            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\n', '        }\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n', '    function batchCancelOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] cancelTakerTokenAmounts)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            cancelOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                cancelTakerTokenAmounts[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Constant public functions\n', '    */\n', '\n', '    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @return Keccak-256 hash of order.\n', '    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            orderAddresses[0], // maker\n', '            orderAddresses[1], // taker\n', '            orderAddresses[2], // makerToken\n', '            orderAddresses[3], // takerToken\n', '            orderAddresses[4], // feeRecipient\n', '            orderValues[0],    // makerTokenAmount\n', '            orderValues[1],    // takerTokenAmount\n', '            orderValues[2],    // makerFee\n', '            orderValues[3],    // takerFee\n', '            orderValues[4],    // expirationTimestampInSec\n', '            orderValues[5]     // salt\n', '        );\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param signer address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if rounding error > 0.1%.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingError(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) return false; // No rounding error.\n', '\n', '        uint errPercentageTimes1000000 = safeDiv(\n', '            safeMul(remainder, 1000000),\n', '            safeMul(numerator, target)\n', '        );\n', '        return errPercentageTimes1000000 > 1000;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeDiv(safeMul(numerator, target), denominator);\n', '    }\n', '\n', '    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n', '    /// @param orderHash The Keccak-256 hash of the given order.\n', '    /// @return Sum of values already filled and cancelled.\n', '    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeAdd(filled[orderHash], cancelled[orderHash]);\n', '    }\n', '\n', '\n', '    /*\n', '    * Internal functions\n', '    */\n', '\n', '    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\n', '    /// @param token Address of token to transferFrom.\n', '    /// @param from Address transfering token.\n', '    /// @param to Address receiving token.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of token transfer.\n', '    function transferViaTokenTransferProxy(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return TokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\n', '    }\n', '\n', '    /// @dev Checks if any order transfers will fail.\n', '    /// @param order Order struct of params that will be checked.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @return Predicted result of transfers.\n', '    function isTransferable(Order order, uint fillTakerTokenAmount)\n', '        internal\n', '        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\n', '        returns (bool)\n', '    {\n', '        address taker = msg.sender;\n', '        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '\n', '        if (order.feeRecipient != address(0)) {\n', '            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\n', '            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\n', '            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\n', '            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\n', '\n', '            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '            ) return false;\n', '\n', '            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don&#39;t double check makerToken if ZRX\n', '                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\n', '            ) return false;\n', '            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don&#39;t double check takerToken if ZRX\n', '                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\n', '            ) return false;\n', '        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\n', '                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\n', '        ) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Get token balance of an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Token balance of owner.\n', '    function getBalance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\n', '    }\n', '\n', '    /// @dev Get allowance of token given to TokenTransferProxy by an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Allowance of token given to TokenTransferProxy by owner.\n', '    function getAllowance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\n', '    }\n', '}\n', '\n', '\n', '/// @title Standard token contract with overflow protection - Used for tokens with dynamic supply.\n', 'contract StandardTokenWithOverflowProtection is Token,\n', '                                                SafeMath\n', '{\n', '\n', '    /*\n', '     *  Data structures\n', '     */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    /// @dev Transfers sender&#39;s tokens to a given address. Returns success.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read functions\n', '     */\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner)\n', '        constant\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '/// @title Token contract - Token exchanging Ether 1:1.\n', '/// @author Stefan George - <<span class="__cf_email__" data-cfemail="a7d4d3c2c1c6c989c0c2c8d5c0c2e7c4c8c9d4c2c9d4ded489c9c2d3">[email&#160;protected]</span>>\n', '/// @author Modified by Amir Bandeali - <<span class="__cf_email__" data-cfemail="6b0a0602192b5b131b1904010e081f45080406">[email&#160;protected]</span>>\n', 'contract EtherToken is StandardTokenWithOverflowProtection {\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    // Token meta data\n', '    string constant public name = "Ether Token";\n', '    string constant public symbol = "WETH";\n', '    uint8 constant public decimals = 18;\n', '\n', '    /*\n', '     *  Read and write functions\n', '     */\n', '\n', '    /// @dev Fallback to calling deposit when ether is sent directly to contract.\n', '    function()\n', '        public\n', '        payable\n', '    {\n', '        deposit();\n', '    }\n', '\n', '    /// @dev Buys tokens with Ether, exchanging them 1:1.\n', '    function deposit()\n', '        public\n', '        payable\n', '    {\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);\n', '        totalSupply = safeAdd(totalSupply, msg.value);\n', '    }\n', '\n', '    /// @dev Sells tokens in exchange for Ether, exchanging them 1:1.\n', '    /// @param amount Number of tokens to sell.\n', '    function withdraw(uint amount)\n', '        public\n', '    {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '        require(msg.sender.send(amount));\n', '    }\n', '}\n', '\n', 'contract TokenSale is Ownable, SafeMath {\n', '\n', '    event SaleInitialized(uint startTimeInSec);\n', '    event SaleFinished(uint endTimeInSec);\n', '\n', '    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n', '\n', '    Exchange exchange;\n', '    Token protocolToken;\n', '    EtherToken ethToken;\n', '\n', '    mapping (address => bool) public registered;\n', '    mapping (address => uint) public contributed;\n', '\n', '    bool public isSaleInitialized;\n', '    bool public isSaleFinished;\n', '    uint public baseEthCapPerAddress;\n', '    uint public startTimeInSec;\n', '    Order order;\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        uint salt;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    modifier saleNotInitialized() {\n', '        require(!isSaleInitialized);\n', '        _;\n', '    }\n', '\n', '    modifier saleStarted() {\n', '        require(isSaleInitialized && block.timestamp >= startTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier saleNotFinished() {\n', '        require(!isSaleFinished);\n', '        _;\n', '    }\n', '\n', '    modifier onlyRegistered() {\n', '        require(registered[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier validStartTime(uint _startTimeInSec) {\n', '        require(_startTimeInSec >= block.timestamp);\n', '        _;\n', '    }\n', '\n', '    modifier validBaseEthCapPerAddress(uint _ethCapPerAddress) {\n', '        require(_ethCapPerAddress != 0);\n', '        _;\n', '    }\n', '\n', '    function TokenSale(\n', '        address _exchange,\n', '        address _protocolToken,\n', '        address _ethToken)\n', '    {\n', '        exchange = Exchange(_exchange);\n', '        protocolToken = Token(_protocolToken);\n', '        ethToken = EtherToken(_ethToken);\n', '    }\n', '\n', '    /// @dev Allows users to fill stored order by sending ETH to contract.\n', '    function()\n', '        payable\n', '    {\n', '        fillOrderWithEth();\n', '    }\n', '\n', '    /// @dev Stores order and initializes sale parameters.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @param _startTimeInSec Time that token sale begins in seconds since epoch.\n', '    /// @param _baseEthCapPerAddress The ETH cap per address for the first time period.\n', '    function initializeSale(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint _startTimeInSec,\n', '        uint _baseEthCapPerAddress)\n', '        public\n', '        saleNotInitialized\n', '        onlyOwner\n', '        validStartTime(_startTimeInSec)\n', '        validBaseEthCapPerAddress(_baseEthCapPerAddress)\n', '    {\n', '        order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            salt: orderValues[5],\n', '            v: v,\n', '            r: r,\n', '            s: s,\n', '            orderHash: exchange.getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(this));\n', '        require(order.makerToken == address(protocolToken));\n', '        require(order.takerToken == address(ethToken));\n', '        require(order.feeRecipient == address(0));\n', '\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        require(ethToken.approve(exchange.TOKEN_TRANSFER_PROXY_CONTRACT(), order.takerTokenAmount));\n', '        isSaleInitialized = true;\n', '        startTimeInSec = _startTimeInSec;\n', '        baseEthCapPerAddress = _baseEthCapPerAddress;\n', '\n', '        SaleInitialized(_startTimeInSec);\n', '    }\n', '\n', '    /// @dev Fills order using msg.value. Should not be called by contracts unless able to access the protocol token after execution.\n', '    function fillOrderWithEth()\n', '        public\n', '        payable\n', '        saleStarted\n', '        saleNotFinished\n', '        onlyRegistered\n', '    {\n', '        uint remainingEth = safeSub(order.takerTokenAmount, exchange.getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint ethCapPerAddress = getEthCapPerAddress();\n', '        uint allowedEth = safeSub(ethCapPerAddress, contributed[msg.sender]);\n', '        uint ethToFill = min256(min256(msg.value, remainingEth), allowedEth);\n', '        ethToken.deposit.value(ethToFill)();\n', '\n', '        contributed[msg.sender] = safeAdd(contributed[msg.sender], ethToFill);\n', '\n', '        exchange.fillOrKillOrder(\n', '            [order.maker, order.taker, order.makerToken, order.takerToken, order.feeRecipient],\n', '            [order.makerTokenAmount, order.takerTokenAmount, order.makerFee, order.takerFee, order.expirationTimestampInSec, order.salt],\n', '            ethToFill,\n', '            order.v,\n', '            order.r,\n', '            order.s\n', '        );\n', '        uint filledProtocolToken = safeDiv(safeMul(order.makerTokenAmount, ethToFill), order.takerTokenAmount);\n', '        require(protocolToken.transfer(msg.sender, filledProtocolToken));\n', '\n', '        if (ethToFill < msg.value) {\n', '            require(msg.sender.send(safeSub(msg.value, ethToFill)));\n', '        }\n', '        if (remainingEth == ethToFill) {\n', '            isSaleFinished = true;\n', '            SaleFinished(block.timestamp);\n', '            return;\n', '        }\n', '    }\n', '\n', '    /// @dev Changes registration status of an address for participation.\n', '    /// @param target Address that will be registered/deregistered.\n', '    /// @param isRegistered New registration status of address.\n', '    function changeRegistrationStatus(address target, bool isRegistered)\n', '        public\n', '        onlyOwner\n', '        saleNotInitialized\n', '    {\n', '        registered[target] = isRegistered;\n', '    }\n', '\n', '    /// @dev Changes registration statuses of addresses for participation.\n', '    /// @param targets Addresses that will be registered/deregistered.\n', '    /// @param isRegistered New registration status of addresss.\n', '    function changeRegistrationStatuses(address[] targets, bool isRegistered)\n', '        public\n', '        onlyOwner\n', '        saleNotInitialized\n', '    {\n', '        for (uint i = 0; i < targets.length; i++) {\n', '            changeRegistrationStatus(targets[i], isRegistered);\n', '        }\n', '    }\n', '\n', '    /// @dev Calculates the ETH cap per address. The cap increases by double the previous increase at each next period. E.g 1, 3, 7, 15\n', '    /// @return The current ETH cap per address.\n', '    function getEthCapPerAddress()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        if (block.timestamp < startTimeInSec || startTimeInSec == 0) return 0;\n', '\n', '        uint timeSinceStartInSec = safeSub(block.timestamp, startTimeInSec);\n', '        uint currentPeriod = safeAdd(                           // currentPeriod begins at 1\n', '              safeDiv(timeSinceStartInSec, TIME_PERIOD_IN_SEC), // rounds down\n', '              1\n', '        );\n', '\n', '        uint ethCapPerAddress = safeMul(\n', '            baseEthCapPerAddress,\n', '            safeSub(\n', '                2 ** currentPeriod,\n', '                1\n', '            )\n', '        );\n', '        return ethCapPerAddress;\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param pubKey Public address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address pubKey,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return pubKey == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Getter function for initialized order&#39;s orderHash.\n', '    /// @return orderHash of initialized order or null.\n', '    function getOrderHash()\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return order.orderHash;\n', '    }\n', '\n', '    /// @dev Getter function for initialized order&#39;s makerTokenAmount.\n', '    /// @return makerTokenAmount of initialized order or 0.\n', '    function getOrderMakerTokenAmount()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return order.makerTokenAmount;\n', '    }\n', '\n', '    /// @dev Getter function for initialized order&#39;s takerTokenAmount.\n', '    /// @return takerTokenAmount of initialized order or 0.\n', '    function getOrderTakerTokenAmount()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return order.takerTokenAmount;\n', '    }\n', '}']
['pragma solidity 0.4.14;\n', '\n', '/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/// @title TokenTransferProxy - Transfers tokens on behalf of contracts that have been approved via decentralized governance.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract TokenTransferProxy is Ownable {\n', '\n', '    /// @dev Only authorized addresses can invoke functions with this modifier.\n', '    modifier onlyAuthorized {\n', '        require(authorized[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier targetAuthorized(address target) {\n', '        require(authorized[target]);\n', '        _;\n', '    }\n', '\n', '    modifier targetNotAuthorized(address target) {\n', '        require(!authorized[target]);\n', '        _;\n', '    }\n', '\n', '    mapping (address => bool) public authorized;\n', '    address[] public authorities;\n', '\n', '    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\n', '    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '\n', '    /// @dev Authorizes an address.\n', '    /// @param target Address to authorize.\n', '    function addAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetNotAuthorized(target)\n', '    {\n', '        authorized[target] = true;\n', '        authorities.push(target);\n', '        LogAuthorizedAddressAdded(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Removes authorizion of an address.\n', '    /// @param target Address to remove authorization from.\n', '    function removeAuthorizedAddress(address target)\n', '        public\n', '        onlyOwner\n', '        targetAuthorized(target)\n', '    {\n', '        delete authorized[target];\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            if (authorities[i] == target) {\n', '                authorities[i] = authorities[authorities.length - 1];\n', '                authorities.length -= 1;\n', '                break;\n', '            }\n', '        }\n', '        LogAuthorizedAddressRemoved(target, msg.sender);\n', '    }\n', '\n', '    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyAuthorized\n', '        returns (bool)\n', '    {\n', '        return Token(token).transferFrom(from, to, value);\n', '    }\n', '\n', '    /*\n', '     * Public constant functions\n', '     */\n', '\n', '    /// @dev Gets all authorized addresses.\n', '    /// @return Array of authorized addresses.\n', '    function getAuthorizedAddresses()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return authorities;\n', '    }\n', '}\n', '\n', '/// @title Exchange - Facilitates exchange of ERC20 tokens.\n', '/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\n', 'contract Exchange is SafeMath {\n', '\n', '    // Error Codes\n', '    enum Errors {\n', '        ORDER_EXPIRED,                    // Order has already expired\n', '        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n', '        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n', '        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n', '    }\n', '\n', '    string constant public VERSION = "1.0.0";\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    address public ZRX_TOKEN_CONTRACT;\n', '    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n', '\n', '    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n', '    mapping (bytes32 => uint) public filled;\n', '    mapping (bytes32 => uint) public cancelled;\n', '\n', '    event LogFill(\n', '        address indexed maker,\n', '        address taker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint filledMakerTokenAmount,\n', '        uint filledTakerTokenAmount,\n', '        uint paidMakerFee,\n', '        uint paidTakerFee,\n', '        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogCancel(\n', '        address indexed maker,\n', '        address indexed feeRecipient,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint cancelledMakerTokenAmount,\n', '        uint cancelledTakerTokenAmount,\n', '        bytes32 indexed tokens,\n', '        bytes32 orderHash\n', '    );\n', '\n', '    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    function Exchange(address _zrxToken, address _tokenTransferProxy) {\n', '        ZRX_TOKEN_CONTRACT = _zrxToken;\n', '        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\n', '    }\n', '\n', '    /*\n', '    * Core exchange functions\n', '    */\n', '\n', '    /// @dev Fills the input order.\n', "    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n", "    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n", '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Total amount of takerToken filled in trade.\n', '    function fillOrder(\n', '          address[5] orderAddresses,\n', '          uint[6] orderValues,\n', '          uint fillTakerTokenAmount,\n', '          bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '          uint8 v,\n', '          bytes32 r,\n', '          bytes32 s)\n', '          public\n', '          returns (uint filledTakerTokenAmount)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(0) || order.taker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (filledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\n', '            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\n', '            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '        uint paidMakerFee;\n', '        uint paidTakerFee;\n', '        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\n', '        require(transferViaTokenTransferProxy(\n', '            order.makerToken,\n', '            order.maker,\n', '            msg.sender,\n', '            filledMakerTokenAmount\n', '        ));\n', '        require(transferViaTokenTransferProxy(\n', '            order.takerToken,\n', '            msg.sender,\n', '            order.maker,\n', '            filledTakerTokenAmount\n', '        ));\n', '        if (order.feeRecipient != address(0)) {\n', '            if (order.makerFee > 0) {\n', '                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    order.maker,\n', '                    order.feeRecipient,\n', '                    paidMakerFee\n', '                ));\n', '            }\n', '            if (order.takerFee > 0) {\n', '                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '                require(transferViaTokenTransferProxy(\n', '                    ZRX_TOKEN_CONTRACT,\n', '                    msg.sender,\n', '                    order.feeRecipient,\n', '                    paidTakerFee\n', '                ));\n', '            }\n', '        }\n', '\n', '        LogFill(\n', '            order.maker,\n', '            msg.sender,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            filledMakerTokenAmount,\n', '            filledTakerTokenAmount,\n', '            paidMakerFee,\n', '            paidTakerFee,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Cancels the input order.\n', "    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n", "    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n", '    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n', '    /// @return Amount of takerToken cancelled.\n', '    function cancelOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint cancelTakerTokenAmount)\n', '        public\n', '        returns (uint)\n', '    {\n', '        Order memory order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            orderHash: getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.maker == msg.sender);\n', '        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\n', '\n', '        if (block.timestamp >= order.expirationTimestampInSec) {\n', '            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\n', '        if (cancelledTakerTokenAmount == 0) {\n', '            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\n', '            return 0;\n', '        }\n', '\n', '        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\n', '\n', '        LogCancel(\n', '            order.maker,\n', '            order.feeRecipient,\n', '            order.makerToken,\n', '            order.takerToken,\n', '            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\n', '            cancelledTakerTokenAmount,\n', '            keccak256(order.makerToken, order.takerToken),\n', '            order.orderHash\n', '        );\n', '        return cancelledTakerTokenAmount;\n', '    }\n', '\n', '    /*\n', '    * Wrapper functions\n', '    */\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n', "    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n", "    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n", '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    function fillOrKillOrder(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '    {\n', '        require(fillOrder(\n', '            orderAddresses,\n', '            orderValues,\n', '            fillTakerTokenAmount,\n', '            false,\n', '            v,\n', '            r,\n', '            s\n', '        ) == fillTakerTokenAmount);\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrKillOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] fillTakerTokenAmounts,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            fillOrKillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                fillTakerTokenAmounts[i],\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    /// @return Total amount of fillTakerTokenAmount filled in orders.\n', '    function fillOrdersUpTo(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '        returns (uint)\n', '    {\n', '        uint filledTakerTokenAmount = 0;\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\n', '            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\n', '                shouldThrowOnInsufficientBalanceOrAllowance,\n', '                v[i],\n', '                r[i],\n', '                s[i]\n', '            ));\n', '            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\n', '        }\n', '        return filledTakerTokenAmount;\n', '    }\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint arrays containing individual order values.\n', '    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n', '    function batchCancelOrders(\n', '        address[5][] orderAddresses,\n', '        uint[6][] orderValues,\n', '        uint[] cancelTakerTokenAmounts)\n', '        public\n', '    {\n', '        for (uint i = 0; i < orderAddresses.length; i++) {\n', '            cancelOrder(\n', '                orderAddresses[i],\n', '                orderValues[i],\n', '                cancelTakerTokenAmounts[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Constant public functions\n', '    */\n', '\n', '    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n', "    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n", "    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n", '    /// @return Keccak-256 hash of order.\n', '    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            address(this),\n', '            orderAddresses[0], // maker\n', '            orderAddresses[1], // taker\n', '            orderAddresses[2], // makerToken\n', '            orderAddresses[3], // takerToken\n', '            orderAddresses[4], // feeRecipient\n', '            orderValues[0],    // makerTokenAmount\n', '            orderValues[1],    // takerTokenAmount\n', '            orderValues[2],    // makerFee\n', '            orderValues[3],    // takerFee\n', '            orderValues[4],    // expirationTimestampInSec\n', '            orderValues[5]     // salt\n', '        );\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param signer address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', '    /// @dev Checks if rounding error > 0.1%.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingError(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint remainder = mulmod(target, numerator, denominator);\n', '        if (remainder == 0) return false; // No rounding error.\n', '\n', '        uint errPercentageTimes1000000 = safeDiv(\n', '            safeMul(remainder, 1000000),\n', '            safeMul(numerator, target)\n', '        );\n', '        return errPercentageTimes1000000 > 1000;\n', '    }\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint numerator, uint denominator, uint target)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeDiv(safeMul(numerator, target), denominator);\n', '    }\n', '\n', '    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n', '    /// @param orderHash The Keccak-256 hash of the given order.\n', '    /// @return Sum of values already filled and cancelled.\n', '    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return safeAdd(filled[orderHash], cancelled[orderHash]);\n', '    }\n', '\n', '\n', '    /*\n', '    * Internal functions\n', '    */\n', '\n', '    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\n', '    /// @param token Address of token to transferFrom.\n', '    /// @param from Address transfering token.\n', '    /// @param to Address receiving token.\n', '    /// @param value Amount of token to transfer.\n', '    /// @return Success of token transfer.\n', '    function transferViaTokenTransferProxy(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return TokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\n', '    }\n', '\n', '    /// @dev Checks if any order transfers will fail.\n', '    /// @param order Order struct of params that will be checked.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @return Predicted result of transfers.\n', '    function isTransferable(Order order, uint fillTakerTokenAmount)\n', '        internal\n', '        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\n', '        returns (bool)\n', '    {\n', '        address taker = msg.sender;\n', '        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\n', '\n', '        if (order.feeRecipient != address(0)) {\n', '            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\n', '            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\n', '            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\n', '            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\n', '            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\n', '            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\n', '\n', '            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\n', '                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\n', '            ) return false;\n', '\n', "            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don't double check makerToken if ZRX\n", '                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\n', '            ) return false;\n', "            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don't double check takerToken if ZRX\n", '                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\n', '            ) return false;\n', '        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\n', '                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\n', '                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\n', '        ) return false;\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Get token balance of an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Token balance of owner.\n', '    function getBalance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\n', '    }\n', '\n', '    /// @dev Get allowance of token given to TokenTransferProxy by an address.\n', '    /// @param token Address of token.\n', '    /// @param owner Address of owner.\n', '    /// @return Allowance of token given to TokenTransferProxy by owner.\n', '    function getAllowance(address token, address owner)\n', '        internal\n', '        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\n', '        returns (uint)\n', '    {\n', '        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\n', '    }\n', '}\n', '\n', '\n', '/// @title Standard token contract with overflow protection - Used for tokens with dynamic supply.\n', 'contract StandardTokenWithOverflowProtection is Token,\n', '                                                SafeMath\n', '{\n', '\n', '    /*\n', '     *  Data structures\n', '     */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read functions\n', '     */\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner)\n', '        constant\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '/// @title Token contract - Token exchanging Ether 1:1.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', '/// @author Modified by Amir Bandeali - <amir@0xproject.com>\n', 'contract EtherToken is StandardTokenWithOverflowProtection {\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    // Token meta data\n', '    string constant public name = "Ether Token";\n', '    string constant public symbol = "WETH";\n', '    uint8 constant public decimals = 18;\n', '\n', '    /*\n', '     *  Read and write functions\n', '     */\n', '\n', '    /// @dev Fallback to calling deposit when ether is sent directly to contract.\n', '    function()\n', '        public\n', '        payable\n', '    {\n', '        deposit();\n', '    }\n', '\n', '    /// @dev Buys tokens with Ether, exchanging them 1:1.\n', '    function deposit()\n', '        public\n', '        payable\n', '    {\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);\n', '        totalSupply = safeAdd(totalSupply, msg.value);\n', '    }\n', '\n', '    /// @dev Sells tokens in exchange for Ether, exchanging them 1:1.\n', '    /// @param amount Number of tokens to sell.\n', '    function withdraw(uint amount)\n', '        public\n', '    {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '        require(msg.sender.send(amount));\n', '    }\n', '}\n', '\n', 'contract TokenSale is Ownable, SafeMath {\n', '\n', '    event SaleInitialized(uint startTimeInSec);\n', '    event SaleFinished(uint endTimeInSec);\n', '\n', '    uint public constant TIME_PERIOD_IN_SEC = 1 days;\n', '\n', '    Exchange exchange;\n', '    Token protocolToken;\n', '    EtherToken ethToken;\n', '\n', '    mapping (address => bool) public registered;\n', '    mapping (address => uint) public contributed;\n', '\n', '    bool public isSaleInitialized;\n', '    bool public isSaleFinished;\n', '    uint public baseEthCapPerAddress;\n', '    uint public startTimeInSec;\n', '    Order order;\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address makerToken;\n', '        address takerToken;\n', '        address feeRecipient;\n', '        uint makerTokenAmount;\n', '        uint takerTokenAmount;\n', '        uint makerFee;\n', '        uint takerFee;\n', '        uint expirationTimestampInSec;\n', '        uint salt;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '        bytes32 orderHash;\n', '    }\n', '\n', '    modifier saleNotInitialized() {\n', '        require(!isSaleInitialized);\n', '        _;\n', '    }\n', '\n', '    modifier saleStarted() {\n', '        require(isSaleInitialized && block.timestamp >= startTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier saleNotFinished() {\n', '        require(!isSaleFinished);\n', '        _;\n', '    }\n', '\n', '    modifier onlyRegistered() {\n', '        require(registered[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier validStartTime(uint _startTimeInSec) {\n', '        require(_startTimeInSec >= block.timestamp);\n', '        _;\n', '    }\n', '\n', '    modifier validBaseEthCapPerAddress(uint _ethCapPerAddress) {\n', '        require(_ethCapPerAddress != 0);\n', '        _;\n', '    }\n', '\n', '    function TokenSale(\n', '        address _exchange,\n', '        address _protocolToken,\n', '        address _ethToken)\n', '    {\n', '        exchange = Exchange(_exchange);\n', '        protocolToken = Token(_protocolToken);\n', '        ethToken = EtherToken(_ethToken);\n', '    }\n', '\n', '    /// @dev Allows users to fill stored order by sending ETH to contract.\n', '    function()\n', '        payable\n', '    {\n', '        fillOrderWithEth();\n', '    }\n', '\n', '    /// @dev Stores order and initializes sale parameters.\n', "    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\n", "    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n", '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @param _startTimeInSec Time that token sale begins in seconds since epoch.\n', '    /// @param _baseEthCapPerAddress The ETH cap per address for the first time period.\n', '    function initializeSale(\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint _startTimeInSec,\n', '        uint _baseEthCapPerAddress)\n', '        public\n', '        saleNotInitialized\n', '        onlyOwner\n', '        validStartTime(_startTimeInSec)\n', '        validBaseEthCapPerAddress(_baseEthCapPerAddress)\n', '    {\n', '        order = Order({\n', '            maker: orderAddresses[0],\n', '            taker: orderAddresses[1],\n', '            makerToken: orderAddresses[2],\n', '            takerToken: orderAddresses[3],\n', '            feeRecipient: orderAddresses[4],\n', '            makerTokenAmount: orderValues[0],\n', '            takerTokenAmount: orderValues[1],\n', '            makerFee: orderValues[2],\n', '            takerFee: orderValues[3],\n', '            expirationTimestampInSec: orderValues[4],\n', '            salt: orderValues[5],\n', '            v: v,\n', '            r: r,\n', '            s: s,\n', '            orderHash: exchange.getOrderHash(orderAddresses, orderValues)\n', '        });\n', '\n', '        require(order.taker == address(this));\n', '        require(order.makerToken == address(protocolToken));\n', '        require(order.takerToken == address(ethToken));\n', '        require(order.feeRecipient == address(0));\n', '\n', '        require(isValidSignature(\n', '            order.maker,\n', '            order.orderHash,\n', '            v,\n', '            r,\n', '            s\n', '        ));\n', '\n', '        require(ethToken.approve(exchange.TOKEN_TRANSFER_PROXY_CONTRACT(), order.takerTokenAmount));\n', '        isSaleInitialized = true;\n', '        startTimeInSec = _startTimeInSec;\n', '        baseEthCapPerAddress = _baseEthCapPerAddress;\n', '\n', '        SaleInitialized(_startTimeInSec);\n', '    }\n', '\n', '    /// @dev Fills order using msg.value. Should not be called by contracts unless able to access the protocol token after execution.\n', '    function fillOrderWithEth()\n', '        public\n', '        payable\n', '        saleStarted\n', '        saleNotFinished\n', '        onlyRegistered\n', '    {\n', '        uint remainingEth = safeSub(order.takerTokenAmount, exchange.getUnavailableTakerTokenAmount(order.orderHash));\n', '        uint ethCapPerAddress = getEthCapPerAddress();\n', '        uint allowedEth = safeSub(ethCapPerAddress, contributed[msg.sender]);\n', '        uint ethToFill = min256(min256(msg.value, remainingEth), allowedEth);\n', '        ethToken.deposit.value(ethToFill)();\n', '\n', '        contributed[msg.sender] = safeAdd(contributed[msg.sender], ethToFill);\n', '\n', '        exchange.fillOrKillOrder(\n', '            [order.maker, order.taker, order.makerToken, order.takerToken, order.feeRecipient],\n', '            [order.makerTokenAmount, order.takerTokenAmount, order.makerFee, order.takerFee, order.expirationTimestampInSec, order.salt],\n', '            ethToFill,\n', '            order.v,\n', '            order.r,\n', '            order.s\n', '        );\n', '        uint filledProtocolToken = safeDiv(safeMul(order.makerTokenAmount, ethToFill), order.takerTokenAmount);\n', '        require(protocolToken.transfer(msg.sender, filledProtocolToken));\n', '\n', '        if (ethToFill < msg.value) {\n', '            require(msg.sender.send(safeSub(msg.value, ethToFill)));\n', '        }\n', '        if (remainingEth == ethToFill) {\n', '            isSaleFinished = true;\n', '            SaleFinished(block.timestamp);\n', '            return;\n', '        }\n', '    }\n', '\n', '    /// @dev Changes registration status of an address for participation.\n', '    /// @param target Address that will be registered/deregistered.\n', '    /// @param isRegistered New registration status of address.\n', '    function changeRegistrationStatus(address target, bool isRegistered)\n', '        public\n', '        onlyOwner\n', '        saleNotInitialized\n', '    {\n', '        registered[target] = isRegistered;\n', '    }\n', '\n', '    /// @dev Changes registration statuses of addresses for participation.\n', '    /// @param targets Addresses that will be registered/deregistered.\n', '    /// @param isRegistered New registration status of addresss.\n', '    function changeRegistrationStatuses(address[] targets, bool isRegistered)\n', '        public\n', '        onlyOwner\n', '        saleNotInitialized\n', '    {\n', '        for (uint i = 0; i < targets.length; i++) {\n', '            changeRegistrationStatus(targets[i], isRegistered);\n', '        }\n', '    }\n', '\n', '    /// @dev Calculates the ETH cap per address. The cap increases by double the previous increase at each next period. E.g 1, 3, 7, 15\n', '    /// @return The current ETH cap per address.\n', '    function getEthCapPerAddress()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        if (block.timestamp < startTimeInSec || startTimeInSec == 0) return 0;\n', '\n', '        uint timeSinceStartInSec = safeSub(block.timestamp, startTimeInSec);\n', '        uint currentPeriod = safeAdd(                           // currentPeriod begins at 1\n', '              safeDiv(timeSinceStartInSec, TIME_PERIOD_IN_SEC), // rounds down\n', '              1\n', '        );\n', '\n', '        uint ethCapPerAddress = safeMul(\n', '            baseEthCapPerAddress,\n', '            safeSub(\n', '                2 ** currentPeriod,\n', '                1\n', '            )\n', '        );\n', '        return ethCapPerAddress;\n', '    }\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param pubKey Public address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address pubKey,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        return pubKey == ecrecover(\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", hash),\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '\n', "    /// @dev Getter function for initialized order's orderHash.\n", '    /// @return orderHash of initialized order or null.\n', '    function getOrderHash()\n', '        public\n', '        constant\n', '        returns (bytes32)\n', '    {\n', '        return order.orderHash;\n', '    }\n', '\n', "    /// @dev Getter function for initialized order's makerTokenAmount.\n", '    /// @return makerTokenAmount of initialized order or 0.\n', '    function getOrderMakerTokenAmount()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return order.makerTokenAmount;\n', '    }\n', '\n', "    /// @dev Getter function for initialized order's takerTokenAmount.\n", '    /// @return takerTokenAmount of initialized order or 0.\n', '    function getOrderTakerTokenAmount()\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return order.takerTokenAmount;\n', '    }\n', '}']
