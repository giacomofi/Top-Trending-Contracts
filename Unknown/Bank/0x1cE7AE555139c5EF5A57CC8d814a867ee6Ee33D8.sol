['pragma solidity ^0.4.11;\n', '\n', '// ERC20 token protocol, see more details at\n', '// https://theethereum.wiki/w/index.php/ERC20_Token_Standard\n', '// And also https://github.com/ethereum/eips/issues/20\n', '\n', 'contract Token {\n', '  function totalSupply() constant returns (uint256 supply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// Safe mathematics to make the code more readable\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '// Ownable interface to simplify owner checks\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) onlyOwner {\n', '    require(_newOwner != address(0));\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// Interface for trading discounts and rebates for specific accounts\n', '\n', 'contract AccountModifiersInterface {\n', '  function accountModifiers(address _user) constant returns(uint takeFeeDiscount, uint rebatePercentage);\n', '  function tradeModifiers(address _maker, address _taker) constant returns(uint takeFeeDiscount, uint rebatePercentage);\n', '}\n', '\n', '// Interface for trade tacker\n', '\n', 'contract TradeTrackerInterface {\n', '  function tradeComplete(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, address _get, address _give, uint _takerFee, uint _makerRebate);\n', '}\n', '\n', '// Exchange contract\n', '\n', 'contract TokenStore is SafeMath, Ownable {\n', '\n', '  // The account that will receive fees\n', '  address feeAccount;\n', '\n', '  // The account that stores fee discounts/rebates\n', '  address accountModifiers;\n', '  \n', '  // Trade tracker account\n', '  address tradeTracker;\n', '\n', '  // We charge only the takers and this is the fee, percentage times 1 ether\n', '  uint public fee;\n', '\n', '  // Mapping of token addresses to mapping of account balances (token 0 means Ether)\n', '  mapping (address => mapping (address => uint)) public tokens;\n', '\n', '  // Mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills;\n', '  \n', '  // Address of a next and previous versions of the contract, also status of the contract\n', '  // can be used for user-triggered fund migrations\n', '  address public successor;\n', '  address public predecessor;\n', '  bool public deprecated;\n', '  uint16 public version;\n', '\n', '  // Logging events\n', '  // Note: Order creation is handled off-chain, see explanation further below\n', '  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint nonce);\n', '  event Deposit(address token, address user, uint amount, uint balance);\n', '  event Withdraw(address token, address user, uint amount, uint balance);\n', '  event FundsMigrated(address user);\n', '\n', '  function TokenStore(uint _fee, address _predecessor) {\n', '    feeAccount = owner;\n', '    fee = _fee;\n', '    predecessor = _predecessor;\n', '    deprecated = false;\n', '    if (predecessor != address(0)) {\n', '      version = TokenStore(predecessor).version() + 1;\n', '    } else {\n', '      version = 1;\n', '    }\n', '  }\n', '\n', '  // Throw on default handler to prevent direct transactions of Ether\n', '  function() {\n', '    revert();\n', '  }\n', '  \n', '  modifier deprecable() {\n', '    require(!deprecated);\n', '    _;\n', '  }\n', '\n', '  function deprecate(bool _deprecated, address _successor) onlyOwner {\n', '    deprecated = _deprecated;\n', '    successor = _successor;\n', '  }\n', '\n', '  function changeFeeAccount(address _feeAccount) onlyOwner {\n', '    require(_feeAccount != address(0));\n', '    feeAccount = _feeAccount;\n', '  }\n', '\n', '  function changeAccountModifiers(address _accountModifiers) onlyOwner {\n', '    accountModifiers = _accountModifiers;\n', '  }\n', '  \n', '  function changeTradeTracker(address _tradeTracker) onlyOwner {\n', '    tradeTracker = _tradeTracker;\n', '  }\n', '\n', '  // Fee can only be decreased!\n', '  function changeFee(uint _fee) onlyOwner {\n', '    require(_fee <= fee);\n', '    fee = _fee;\n', '  }\n', '  \n', '  // Allows a user to get her current discount/rebate\n', '  function getAccountModifiers() constant returns(uint takeFeeDiscount, uint rebatePercentage) {\n', '    if (accountModifiers != address(0)) {\n', '      return AccountModifiersInterface(accountModifiers).accountModifiers(msg.sender);\n', '    } else {\n', '      return (0, 0);\n', '    }\n', '  }\n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Deposits, withdrawals, balances\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  function deposit() payable deprecable {\n', '    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n', '    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function withdraw(uint _amount) {\n', '    require(tokens[0][msg.sender] >= _amount);\n', '    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);\n', '    if (!msg.sender.call.value(_amount)()) {\n', '      revert();\n', '    }\n', '    Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);\n', '  }\n', '\n', '  function depositToken(address _token, uint _amount) deprecable {\n', '    // Note that Token(_token).approve(this, _amount) needs to be called\n', '    // first or this contract will not be able to do the transfer.\n', '    require(_token != 0);\n', '    if (!Token(_token).transferFrom(msg.sender, this, _amount)) {\n', '      revert();\n', '    }\n', '    tokens[_token][msg.sender] = safeAdd(tokens[_token][msg.sender], _amount);\n', '    Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\n', '  }\n', '\n', '  function withdrawToken(address _token, uint _amount) {\n', '    require(_token != 0);\n', '    require(tokens[_token][msg.sender] >= _amount);\n', '    tokens[_token][msg.sender] = safeSub(tokens[_token][msg.sender], _amount);\n', '    if (!Token(_token).transfer(msg.sender, _amount)) {\n', '      revert();\n', '    }\n', '    Withdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]);\n', '  }\n', '\n', '  function balanceOf(address _token, address _user) constant returns (uint) {\n', '    return tokens[_token][_user];\n', '  }\n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Trading\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  // Note: Order creation happens off-chain but the orders are signed by creators,\n', '  // we validate the contents and the creator address in the logic below\n', '\n', '  function trade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\n', '      uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount) {\n', '    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    // Check order signatures and expiration, also check if not fulfilled yet\n', '\t\tif (ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash), _v, _r, _s) != _user ||\n', '      block.number > _expires ||\n', '      safeAdd(orderFills[_user][hash], _amount) > _amountGet) {\n', '      revert();\n', '    }\n', '    tradeBalances(_tokenGet, _amountGet, _tokenGive, _amountGive, _user, msg.sender, _amount);\n', '    orderFills[_user][hash] = safeAdd(orderFills[_user][hash], _amount);\n', '    Trade(_tokenGet, _amount, _tokenGive, _amountGive * _amount / _amountGet, _user, msg.sender, _nonce);\n', '  }\n', '  \n', '  function tradeBalances(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\n', '      address _user, address _caller, uint _amount) private {\n', '\n', '    uint feeTakeValue = safeMul(_amount, fee) / (1 ether);\n', '    uint rebateValue = 0;\n', '    uint tokenGiveValue = safeMul(_amountGive, _amount) / _amountGet; // Proportionate to request ratio\n', '\n', '    // Apply modifiers\n', '    if (accountModifiers != address(0)) {\n', '      var (feeTakeDiscount, rebatePercentage) = AccountModifiersInterface(accountModifiers).tradeModifiers(_user, _caller);\n', '      // Check that the discounts/rebates are never higher then 100%\n', '      if (feeTakeDiscount > 100) {\n', '        feeTakeDiscount = 0;\n', '      }\n', '      if (rebatePercentage > 100) {\n', '        rebatePercentage = 0;\n', '      }\n', '      feeTakeValue = safeMul(feeTakeValue, 100 - feeTakeDiscount) / 100;  // discounted fee\n', '      rebateValue = safeMul(rebatePercentage, feeTakeValue) / 100;        // % of actual taker fee\n', '    }\n', '    \n', '    tokens[_tokenGet][_user] = safeAdd(tokens[_tokenGet][_user], safeAdd(_amount, rebateValue));\n', '    tokens[_tokenGet][_caller] = safeSub(tokens[_tokenGet][_caller], safeAdd(_amount, feeTakeValue));\n', '    tokens[_tokenGive][_user] = safeSub(tokens[_tokenGive][_user], tokenGiveValue);\n', '    tokens[_tokenGive][_caller] = safeAdd(tokens[_tokenGive][_caller], tokenGiveValue);\n', '    tokens[_tokenGet][feeAccount] = safeAdd(tokens[_tokenGet][feeAccount], safeSub(feeTakeValue, rebateValue));\n', '    \n', '    if (tradeTracker != address(0)) {\n', '      TradeTrackerInterface(tradeTracker).tradeComplete(_tokenGet, _amount, _tokenGive, tokenGiveValue, _user, _caller, feeTakeValue, rebateValue);\n', '    }\n', '  }\n', '\n', '  function testTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\n', '      uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _sender) constant returns(bool) {\n', '    if (tokens[_tokenGet][_sender] < _amount ||\n', '      availableVolume(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s) < _amount) {\n', '      return false;\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function availableVolume(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\n', '      uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) constant returns(uint) {\n', '    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    if (ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash), _v, _r, _s) != _user ||\n', '      block.number > _expires) {\n', '      return 0;\n', '    }\n', '    uint available1 = safeSub(_amountGet, orderFills[_user][hash]);\n', '    uint available2 = safeMul(tokens[_tokenGive][_user], _amountGet) / _amountGive;\n', '    if (available1 < available2) return available1;\n', '    return available2;\n', '  }\n', '\n', '  function amountFilled(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\n', '      uint _nonce, address _user) constant returns(uint) {\n', '    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    return orderFills[_user][hash];\n', '  }\n', '\n', '  function cancelOrder(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\n', '      uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) {\n', '    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\n', '    if (!(ecrecover(sha3("\\x19Ethereum Signed Message:\\n32", hash), _v, _r, _s) == msg.sender)) {\n', '      revert();\n', '    }\n', '    orderFills[msg.sender][hash] = _amountGet;\n', '    Cancel(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender, _v, _r, _s);\n', '  }\n', '  \n', '  ////////////////////////////////////////////////////////////////////////////////\n', '  // Migrations\n', '  ////////////////////////////////////////////////////////////////////////////////\n', '\n', '  // User-triggered (!) fund migrations in case contract got updated\n', '  // Similar to withdraw but we use a successor account instead\n', '  // As we don&#39;t store user tokens list on chain, it has to be passed from the outside\n', '  function migrateFunds(address[] _tokens) {\n', '  \n', '    // Get the latest successor in the chain\n', '    require(successor != address(0));\n', '    TokenStore newExchange = TokenStore(successor);\n', '    for (uint16 n = 0; n < 20; n++) {  // We will look past 20 contracts in the future\n', '      address nextSuccessor = newExchange.successor();\n', '      if (nextSuccessor == address(this)) {  // Circular succession\n', '        revert();\n', '      }\n', '      if (nextSuccessor == address(0)) { // We reached the newest, stop\n', '        break;\n', '      }\n', '      newExchange = TokenStore(nextSuccessor);\n', '    }\n', '\n', '    // Ether\n', '    uint etherAmount = tokens[0][msg.sender];\n', '    if (etherAmount > 0) {\n', '      tokens[0][msg.sender] = 0;\n', '      newExchange.depositForUser.value(etherAmount)(msg.sender);\n', '    }\n', '\n', '    // Tokens\n', '    for (n = 0; n < _tokens.length; n++) {\n', '      address token = _tokens[n];\n', '      require(token != address(0)); // 0 = Ether, we handle it above\n', '      uint tokenAmount = tokens[token][msg.sender];\n', '      if (tokenAmount == 0) {\n', '        continue;\n', '      }\n', '      if (!Token(token).approve(newExchange, tokenAmount)) {\n', '        revert();\n', '      }\n', '      tokens[token][msg.sender] = 0;\n', '      newExchange.depositTokenForUser(token, tokenAmount, msg.sender);\n', '    }\n', '\n', '    FundsMigrated(msg.sender);\n', '  }\n', '\n', '  // This is used for migrations only. To be called by previous exchange only,\n', '  // user-triggered, on behalf of the user called the migrateFunds method.\n', '  // Note that it does exactly the same as depositToken, but as this is called\n', '  // by a previous generation of exchange itself, we credit internally not the\n', '  // previous exchange, but the user it was called for.\n', '  function depositForUser(address _user) payable deprecable {\n', '    require(_user != address(0));\n', '    require(msg.value > 0);\n', '    TokenStore caller = TokenStore(msg.sender);\n', '    require(caller.version() > 0); // Make sure it&#39;s an exchange account\n', '    tokens[0][_user] = safeAdd(tokens[0][_user], msg.value);\n', '  }\n', '\n', '  function depositTokenForUser(address _token, uint _amount, address _user) deprecable {\n', '    require(_token != address(0));\n', '    require(_user != address(0));\n', '    require(_amount > 0);\n', '    TokenStore caller = TokenStore(msg.sender);\n', '    require(caller.version() > 0); // Make sure it&#39;s an exchange account\n', '    if (!Token(_token).transferFrom(msg.sender, this, _amount)) {\n', '      revert();\n', '    }\n', '    tokens[_token][_user] = safeAdd(tokens[_token][_user], _amount);\n', '  }\n', '}']