['pragma solidity ^0.4.2;\n', '\n', '//import "./SafeMathLib.sol";\n', '/**\n', ' * Safe unsigned safe math.\n', ' *\n', ' * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n', ' *\n', ' * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n', ' *\n', ' * Maintained here until merged to mainline zeppelin-solidity.\n', ' *\n', ' */\n', 'library SafeMathLib {\n', '\n', '  function times(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a);\n', '    return c;\n', '  }\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    require(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '\n', '  function transfer(address to, uint value) public  returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '   event Transfer(address indexed from, address indexed to, uint value);\n', '   event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  //function assert(bool assertion) internal pure{\n', '  //  require (assertion);\n', '  //}\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  /* Token supply got increased and a new owner received these tokens */\n', '   event Minted(address receiver, uint amount);\n', '\n', '  /* Actual balances of token holders */\n', '  mapping(address => uint) balances;\n', '\n', '  /* approve() allowances */\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /* Interface declaration */\n', '  function isToken() public pure returns (bool weAre) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     //require(msg.data.length < size + 4);\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '    require(_value >= 0);\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    //requre the alloced greater than _value\n', '    require(_allowance >= _value);\n', '    require(_value >= 0);\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value)public returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    //if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* Util */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) } // solium-disable-line\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  mapping (address => bool) private admins;\n', '  mapping (address => bool) private developers;\n', '  mapping (address => bool) private founds;\n', '\n', '  function Ownable()  internal{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyAdmins(){\n', '    require(admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner()  {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '\n', ' function getOwner() view public returns (address){\n', '     return owner;\n', '  }\n', '\n', ' function isDeveloper () view internal returns (bool) {\n', '     return developers[msg.sender];\n', '  }\n', '\n', ' function isFounder () view internal returns (bool){\n', '     return founds[msg.sender];\n', '  }\n', '\n', '  function addDeveloper (address _dev) onlyOwner() public {\n', '    developers[_dev] = true;\n', '  }\n', '\n', '  function removeDeveloper (address _dev) onlyOwner() public {\n', '    delete developers[_dev];\n', '  }\n', '\n', '    function addFound (address _found) onlyOwner() public {\n', '    founds[_found] = true;\n', '  }\n', '\n', '  function removeFound (address _found) onlyOwner() public {\n', '    delete founds[_found];\n', '  }\n', '\n', '  function addAdmin (address _admin) onlyOwner() public {\n', '    admins[_admin] = true;\n', '  }\n', '\n', '  function removeAdmin (address _admin) onlyOwner() public {\n', '    delete admins[_admin];\n', '  }\n', '  \n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * Define interface for distrible the token \n', ' */\n', 'contract DistributeToken is StandardToken, Ownable{\n', '\n', '  event AirDrop(address from, address to, uint amount);\n', '  event CrowdDistribute(address from, address to, uint amount);\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  /* The finalizer contract that allows Distribute token */\n', '  address public distAgent;\n', '\n', '  uint public maxAirDrop = 1000*10**18;//need below 1000 TTG\n', '\n', '  uint public havedAirDrop = 0;\n', '  uint public totalAirDrop = 0; //totalSupply * 5%\n', '\n', '  bool public finishCrowdCoin = false;\n', '  uint public havedCrowdCoin = 0;\n', '  uint public totalCrowdCoin = 0; //totalSupply * 50%\n', '\n', '  uint public havedDistDevCoin = 0;\n', '  uint public totalDevCoin = 0;  //totalSupply * 20%\n', '\n', '  uint public havedDistFoundCoin = 0;\n', '  uint public totalFoundCoin = 0;  //totalSupply * 20%\n', '\n', '  /**\n', '   * 0：1：100000；1：1：50000 2：1：25000  3：1：12500  4：1：12500\n', '   */\n', '  uint private crowState = 0;//\n', '  /**\n', '   * .\n', '   */\n', '  function setDistributeAgent(address addr) onlyOwner  public {\n', '     \n', '     require(addr != address(0));\n', '\n', '    // We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\n', '    distAgent = addr;\n', '  }\n', '\n', '\n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyDistributeAgent() {\n', '    require(msg.sender == distAgent) ;\n', '    _;\n', '  }\n', '\n', '  /* Withdraw */\n', '  /*\n', '    NOTICE: These functions withdraw the ETH which remained in the contract account when user call CrowdDistribute\n', '  */\n', '  function withdrawAll () onlyOwner() public {\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  function withdrawAmount (uint256 _amount) onlyOwner() public {\n', '    owner.transfer(_amount);\n', '  }\n', '\n', ' /**发token给基金会*/\n', ' function distributeToFound(address receiver, uint amount) onlyOwner() public  returns (uint actual){ \n', '  \n', '    require((amount+havedDistFoundCoin) < totalFoundCoin);\n', '  \n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedDistFoundCoin = havedDistFoundCoin.plus(amount);\n', '\n', '    addFound(receiver);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '   \n', '    return amount;\n', ' }\n', '\n', ' /**发token给开发者*/\n', ' function  distributeToDev(address receiver, uint amount) onlyOwner()  public  returns (uint actual){\n', '\n', '    require((amount+havedDistDevCoin) < totalDevCoin);\n', '\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedDistDevCoin = havedDistDevCoin.plus(amount);\n', '\n', '    addDeveloper(receiver);\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '\n', '    return amount;\n', ' }\n', '\n', ' /**空投总量及单次量由发行者来控制， agent不能修改，空投接口只能由授权的agent进行*/\n', ' function airDrop(address transmitter, address receiver, uint amount) public  returns (uint actual){\n', '\n', '    require(receiver != address(0));\n', '    require(amount <= maxAirDrop);\n', '    require((amount+havedAirDrop) < totalAirDrop);\n', '    require(transmitter == distAgent);\n', '\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedAirDrop = havedAirDrop.plus(amount);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit AirDrop(0, receiver, amount);\n', '\n', '    return amount;\n', '  }\n', '\n', ' /**用户ICO众筹，由用户发固定的ETH，回馈用户固定的TTG，并添加ICO账户，控制交易规则*/\n', ' function crowdDistribution() payable public  returns (uint actual) {\n', '      \n', '    require(msg.sender != address(0));\n', '    require(!isContract(msg.sender));\n', '    require(msg.value != 0);\n', '    require(totalCrowdCoin > havedCrowdCoin);\n', '    require(finishCrowdCoin == false);\n', '    \n', '    uint actualAmount = calculateCrowdAmount(msg.value);\n', '\n', '    require(actualAmount != 0);\n', '\n', '    havedCrowdCoin = havedCrowdCoin.plus(actualAmount);\n', '    balances[owner] = balances[owner].sub(actualAmount);\n', '    balances[msg.sender] = balances[msg.sender].plus(actualAmount);\n', '    \n', '    switchCrowdState();\n', '    \n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit CrowdDistribute(0, msg.sender, actualAmount);\n', '\n', '    return actualAmount;\n', '  }\n', '\n', ' function  switchCrowdState () internal{\n', '\n', '    if (havedCrowdCoin < totalCrowdCoin.mul(10).div(100) ){\n', '       crowState = 0;\n', '\n', '    }else  if (havedCrowdCoin < totalCrowdCoin.mul(20).div(100) ){\n', '       crowState = 1;\n', '    \n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(30).div(100) ){\n', '       crowState = 2;\n', '\n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(40).div(100) ){\n', '       crowState = 3;\n', '\n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(50).div(100) ){\n', '       crowState = 4;\n', '    }\n', '      \n', '    if (havedCrowdCoin >= totalCrowdCoin) {\n', '       finishCrowdCoin = true;\n', '  }\n', ' }\n', '\n', 'function calculateCrowdAmount (uint _price) internal view returns (uint _crow) {\n', '        \n', '    if (crowState == 0) {\n', '      return _price.mul(50000);\n', '    }\n', '    \n', '     else if (crowState == 1) {\n', '      return _price.mul(30000);\n', '    \n', '    } else if (crowState == 2) {\n', '      return  _price.mul(20000);\n', '\n', '    } else if (crowState == 3) {\n', '     return  _price.mul(15000);\n', '\n', '    } else if (crowState == 4) {\n', '     return  _price.mul(10000);\n', '    }\n', '\n', '    return 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Define interface for releasing the token transfer after a successful crowdsale.\n', ' */\n', 'contract ReleasableToken is ERC20, Ownable {\n', '\n', '  /* The finalizer contract that allows unlift the transfer limits on this token */\n', '  address public releaseAgent;\n', '\n', '  /** A TTG contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n', '  bool public released = false;\n', '\n', '  uint private maxTransferForDev  = 40000000*10**18;\n', '  uint private maxTransferFoFounds= 20000000*10**18;\n', '  uint private maxTransfer = 0;//other user is not limited.\n', '\n', '  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n', '  mapping (address => bool) public transferAgents;\n', '\n', '  /**\n', '   * Limit token transfer until the crowdsale is over.\n', '   *\n', '   */\n', '  modifier canTransfer(address _sender, uint _value) {\n', '\n', '    //if owner can Transfer all the time\n', '    if(_sender != owner){\n', '      \n', '      if(isDeveloper()){\n', '        require(_value < maxTransferForDev);\n', '\n', '      }else if(isFounder()){\n', '        require(_value < maxTransferFoFounds);\n', '\n', '      }else if(maxTransfer != 0){\n', '        require(_value < maxTransfer);\n', '      }\n', '\n', '      if(!released) {\n', '          require(transferAgents[_sender]);\n', '      }\n', '     }\n', '    _;\n', '  }\n', '\n', '\n', ' function setMaxTranferLimit(uint dev, uint found, uint other) onlyOwner  public {\n', '\n', '      require(dev < totalSupply);\n', '      require(found < totalSupply);\n', '      require(other < totalSupply);\n', '\n', '      maxTransferForDev = dev;\n', '      maxTransferFoFounds = found;\n', '      maxTransfer = other;\n', '  }\n', '\n', '\n', '  /**\n', '   * Set the contract that can call release and make the token transferable.\n', '   *\n', '   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n', '   */\n', '  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n', '\n', '    // We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\n', '    releaseAgent = addr;\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n', '   */\n', '  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n', '    transferAgents[addr] = state;\n', '  }\n', '\n', '  /**\n', '   * One way function to release the tokens to the wild.\n', '   *\n', '   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    released = true;\n', '  }\n', '\n', '  /** The function can be called only before or after the tokens have been releasesd */\n', '  modifier inReleaseState(bool releaseState) {\n', '    require(releaseState == released);\n', '    _;\n', '  }\n', '\n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyReleaseAgent() {\n', '    require(msg.sender == releaseAgent);\n', '    _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public canTransfer(msg.sender,_value) returns (bool success)  {\n', '    // Call StandardToken.transfer()\n', '   return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public canTransfer(_from,_value) returns (bool success)  {\n', '    // Call StandardToken.transferForm()\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', 'contract RecycleToken is StandardToken, Ownable {\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  /**\n', '   * recycle user token to owner account\n', '   * \n', '   */\n', '  function recycle(address from, uint amount) onlyAdmins public {\n', '  \n', '    require(from != address(0));\n', '    require(balances[from] >=  amount);\n', '\n', '    balances[owner] = balances[owner].add(amount);\n', '    balances[from]  = balances[from].sub(amount);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(from, owner, amount);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * A token that can increase its supply by another contract.\n', ' *\n', ' * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n', ' * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n', ' *\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  bool public mintingFinished = false;\n', '\n', '  /** List of agents that are allowed to create new tokens */\n', '  mapping (address => bool) public mintAgents;\n', '\n', '  event MintingAgentChanged(address addr, bool state  );\n', '\n', '  /**\n', '   * Create new tokens and allocate them to an address..\n', '   *\n', '   * Only callably by a crowdsale contract (mint agent). \n', '   */\n', '  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n', '\n', '    //totalsupply is not changed, send amount TTG to receiver from owner account.\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    \n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a crowdsale contract to mint new tokens.\n', '   */\n', '  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n', '    mintAgents[addr] = state;\n', '    emit MintingAgentChanged(addr, state);\n', '  }\n', '\n', '  modifier onlyMintAgent() {\n', '    // Only crowdsale contracts are allowed to mint new tokens\n', '    require(mintAgents[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function enableMint() onlyOwner public {\n', '    mintingFinished = false;\n', '  }\n', '\n', '  /** Make sure we are not done yet. */\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * A crowdsaled token.\n', ' *\n', ' * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n', ' *\n', ' * - The token transfer() is disabled until the crowdsale is over\n', ' * - The token contract gives an opt-in upgrade path to a new contract\n', ' * - The same token can be part of several crowdsales through approve() mechanism\n', ' * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n', ' *\n', ' */\n', 'contract TTGCoin is ReleasableToken, MintableToken , DistributeToken, RecycleToken{\n', '\n', '  /** Name and symbol were updated. */\n', '  event UpdatedTokenInformation(string newName, string newSymbol);\n', '\n', '  string public name;\n', '\n', '  string public symbol;\n', '\n', '  uint public decimals;\n', '\n', '  /**\n', '   * Construct the token.\n', '   *\n', '   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n', '   *\n', '   */\n', '  function TTGCoin() public {\n', '    // Create any address, can be transferred\n', '    // to team multisig via changeOwner(),\n', '    owner = msg.sender;\n', '\n', '    addAdmin(owner);\n', '\n', '    name  = "TotalGame Coin";\n', '    symbol = "TGC";\n', '    totalSupply = 2000000000*10**18;\n', '    decimals = 18;\n', '\n', '    // Create initially all balance on the team multisig\n', '    balances[msg.sender] = totalSupply;\n', '\n', '    //Mint feature is not allow  now\n', '    mintingFinished = true;\n', '\n', '    //Set the distribute totaltoken strategy\n', '    totalAirDrop = totalSupply.mul(10).div(100);\n', '    totalCrowdCoin = totalSupply.mul(50).div(100);\n', '    totalDevCoin = totalSupply.mul(20).div(100);\n', '    totalFoundCoin = totalSupply.mul(20).div(100);\n', '\n', '    emit Minted(owner, totalSupply);\n', '  }\n', '\n', '\n', '  /**\n', '   * When token is released to be transferable, enforce no new tokens can be created.\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    super.releaseTokenTransfer();\n', '  }\n', '\n', '  /**\n', '   * Owner can update token information here.\n', '   *\n', '   * It is often useful to conceal the actual token association, until\n', '   * the token operations, like central issuance or reissuance have been completed.\n', '   *\n', '   * This function allows the token owner to rename the token after the operations\n', '   * have been completed and then point the audience to use the token contract.\n', '   */\n', '  function setTokenInformation(string _name, string _symbol) public onlyOwner {\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    emit UpdatedTokenInformation(name, symbol);\n', '  }\n', '\n', '  function getTotalSupply() public view returns (uint) {\n', '    return totalSupply;\n', '  }\n', '\n', '  function tokenName() public view returns (string _name) {\n', '    return name;\n', '  }\n', '}']
['pragma solidity ^0.4.2;\n', '\n', '//import "./SafeMathLib.sol";\n', '/**\n', ' * Safe unsigned safe math.\n', ' *\n', ' * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n', ' *\n', ' * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n', ' *\n', ' * Maintained here until merged to mainline zeppelin-solidity.\n', ' *\n', ' */\n', 'library SafeMathLib {\n', '\n', '  function times(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a);\n', '    return c;\n', '  }\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    require(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '\n', '  function transfer(address to, uint value) public  returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '   event Transfer(address indexed from, address indexed to, uint value);\n', '   event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  //function assert(bool assertion) internal pure{\n', '  //  require (assertion);\n', '  //}\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  /* Token supply got increased and a new owner received these tokens */\n', '   event Minted(address receiver, uint amount);\n', '\n', '  /* Actual balances of token holders */\n', '  mapping(address => uint) balances;\n', '\n', '  /* approve() allowances */\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /* Interface declaration */\n', '  function isToken() public pure returns (bool weAre) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     //require(msg.data.length < size + 4);\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '    require(_value >= 0);\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    //requre the alloced greater than _value\n', '    require(_allowance >= _value);\n', '    require(_value >= 0);\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value)public returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    //if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* Util */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) } // solium-disable-line\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  mapping (address => bool) private admins;\n', '  mapping (address => bool) private developers;\n', '  mapping (address => bool) private founds;\n', '\n', '  function Ownable()  internal{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyAdmins(){\n', '    require(admins[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner()  {\n', '    require (msg.sender == owner);\n', '    _;\n', '  }\n', '\n', ' function getOwner() view public returns (address){\n', '     return owner;\n', '  }\n', '\n', ' function isDeveloper () view internal returns (bool) {\n', '     return developers[msg.sender];\n', '  }\n', '\n', ' function isFounder () view internal returns (bool){\n', '     return founds[msg.sender];\n', '  }\n', '\n', '  function addDeveloper (address _dev) onlyOwner() public {\n', '    developers[_dev] = true;\n', '  }\n', '\n', '  function removeDeveloper (address _dev) onlyOwner() public {\n', '    delete developers[_dev];\n', '  }\n', '\n', '    function addFound (address _found) onlyOwner() public {\n', '    founds[_found] = true;\n', '  }\n', '\n', '  function removeFound (address _found) onlyOwner() public {\n', '    delete founds[_found];\n', '  }\n', '\n', '  function addAdmin (address _admin) onlyOwner() public {\n', '    admins[_admin] = true;\n', '  }\n', '\n', '  function removeAdmin (address _admin) onlyOwner() public {\n', '    delete admins[_admin];\n', '  }\n', '  \n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * Define interface for distrible the token \n', ' */\n', 'contract DistributeToken is StandardToken, Ownable{\n', '\n', '  event AirDrop(address from, address to, uint amount);\n', '  event CrowdDistribute(address from, address to, uint amount);\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  /* The finalizer contract that allows Distribute token */\n', '  address public distAgent;\n', '\n', '  uint public maxAirDrop = 1000*10**18;//need below 1000 TTG\n', '\n', '  uint public havedAirDrop = 0;\n', '  uint public totalAirDrop = 0; //totalSupply * 5%\n', '\n', '  bool public finishCrowdCoin = false;\n', '  uint public havedCrowdCoin = 0;\n', '  uint public totalCrowdCoin = 0; //totalSupply * 50%\n', '\n', '  uint public havedDistDevCoin = 0;\n', '  uint public totalDevCoin = 0;  //totalSupply * 20%\n', '\n', '  uint public havedDistFoundCoin = 0;\n', '  uint public totalFoundCoin = 0;  //totalSupply * 20%\n', '\n', '  /**\n', '   * 0：1：100000；1：1：50000 2：1：25000  3：1：12500  4：1：12500\n', '   */\n', '  uint private crowState = 0;//\n', '  /**\n', '   * .\n', '   */\n', '  function setDistributeAgent(address addr) onlyOwner  public {\n', '     \n', '     require(addr != address(0));\n', '\n', "    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n", '    distAgent = addr;\n', '  }\n', '\n', '\n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyDistributeAgent() {\n', '    require(msg.sender == distAgent) ;\n', '    _;\n', '  }\n', '\n', '  /* Withdraw */\n', '  /*\n', '    NOTICE: These functions withdraw the ETH which remained in the contract account when user call CrowdDistribute\n', '  */\n', '  function withdrawAll () onlyOwner() public {\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  function withdrawAmount (uint256 _amount) onlyOwner() public {\n', '    owner.transfer(_amount);\n', '  }\n', '\n', ' /**发token给基金会*/\n', ' function distributeToFound(address receiver, uint amount) onlyOwner() public  returns (uint actual){ \n', '  \n', '    require((amount+havedDistFoundCoin) < totalFoundCoin);\n', '  \n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedDistFoundCoin = havedDistFoundCoin.plus(amount);\n', '\n', '    addFound(receiver);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '   \n', '    return amount;\n', ' }\n', '\n', ' /**发token给开发者*/\n', ' function  distributeToDev(address receiver, uint amount) onlyOwner()  public  returns (uint actual){\n', '\n', '    require((amount+havedDistDevCoin) < totalDevCoin);\n', '\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedDistDevCoin = havedDistDevCoin.plus(amount);\n', '\n', '    addDeveloper(receiver);\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '\n', '    return amount;\n', ' }\n', '\n', ' /**空投总量及单次量由发行者来控制， agent不能修改，空投接口只能由授权的agent进行*/\n', ' function airDrop(address transmitter, address receiver, uint amount) public  returns (uint actual){\n', '\n', '    require(receiver != address(0));\n', '    require(amount <= maxAirDrop);\n', '    require((amount+havedAirDrop) < totalAirDrop);\n', '    require(transmitter == distAgent);\n', '\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    havedAirDrop = havedAirDrop.plus(amount);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit AirDrop(0, receiver, amount);\n', '\n', '    return amount;\n', '  }\n', '\n', ' /**用户ICO众筹，由用户发固定的ETH，回馈用户固定的TTG，并添加ICO账户，控制交易规则*/\n', ' function crowdDistribution() payable public  returns (uint actual) {\n', '      \n', '    require(msg.sender != address(0));\n', '    require(!isContract(msg.sender));\n', '    require(msg.value != 0);\n', '    require(totalCrowdCoin > havedCrowdCoin);\n', '    require(finishCrowdCoin == false);\n', '    \n', '    uint actualAmount = calculateCrowdAmount(msg.value);\n', '\n', '    require(actualAmount != 0);\n', '\n', '    havedCrowdCoin = havedCrowdCoin.plus(actualAmount);\n', '    balances[owner] = balances[owner].sub(actualAmount);\n', '    balances[msg.sender] = balances[msg.sender].plus(actualAmount);\n', '    \n', '    switchCrowdState();\n', '    \n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit CrowdDistribute(0, msg.sender, actualAmount);\n', '\n', '    return actualAmount;\n', '  }\n', '\n', ' function  switchCrowdState () internal{\n', '\n', '    if (havedCrowdCoin < totalCrowdCoin.mul(10).div(100) ){\n', '       crowState = 0;\n', '\n', '    }else  if (havedCrowdCoin < totalCrowdCoin.mul(20).div(100) ){\n', '       crowState = 1;\n', '    \n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(30).div(100) ){\n', '       crowState = 2;\n', '\n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(40).div(100) ){\n', '       crowState = 3;\n', '\n', '    } else if (havedCrowdCoin < totalCrowdCoin.mul(50).div(100) ){\n', '       crowState = 4;\n', '    }\n', '      \n', '    if (havedCrowdCoin >= totalCrowdCoin) {\n', '       finishCrowdCoin = true;\n', '  }\n', ' }\n', '\n', 'function calculateCrowdAmount (uint _price) internal view returns (uint _crow) {\n', '        \n', '    if (crowState == 0) {\n', '      return _price.mul(50000);\n', '    }\n', '    \n', '     else if (crowState == 1) {\n', '      return _price.mul(30000);\n', '    \n', '    } else if (crowState == 2) {\n', '      return  _price.mul(20000);\n', '\n', '    } else if (crowState == 3) {\n', '     return  _price.mul(15000);\n', '\n', '    } else if (crowState == 4) {\n', '     return  _price.mul(10000);\n', '    }\n', '\n', '    return 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Define interface for releasing the token transfer after a successful crowdsale.\n', ' */\n', 'contract ReleasableToken is ERC20, Ownable {\n', '\n', '  /* The finalizer contract that allows unlift the transfer limits on this token */\n', '  address public releaseAgent;\n', '\n', '  /** A TTG contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n', '  bool public released = false;\n', '\n', '  uint private maxTransferForDev  = 40000000*10**18;\n', '  uint private maxTransferFoFounds= 20000000*10**18;\n', '  uint private maxTransfer = 0;//other user is not limited.\n', '\n', '  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n', '  mapping (address => bool) public transferAgents;\n', '\n', '  /**\n', '   * Limit token transfer until the crowdsale is over.\n', '   *\n', '   */\n', '  modifier canTransfer(address _sender, uint _value) {\n', '\n', '    //if owner can Transfer all the time\n', '    if(_sender != owner){\n', '      \n', '      if(isDeveloper()){\n', '        require(_value < maxTransferForDev);\n', '\n', '      }else if(isFounder()){\n', '        require(_value < maxTransferFoFounds);\n', '\n', '      }else if(maxTransfer != 0){\n', '        require(_value < maxTransfer);\n', '      }\n', '\n', '      if(!released) {\n', '          require(transferAgents[_sender]);\n', '      }\n', '     }\n', '    _;\n', '  }\n', '\n', '\n', ' function setMaxTranferLimit(uint dev, uint found, uint other) onlyOwner  public {\n', '\n', '      require(dev < totalSupply);\n', '      require(found < totalSupply);\n', '      require(other < totalSupply);\n', '\n', '      maxTransferForDev = dev;\n', '      maxTransferFoFounds = found;\n', '      maxTransfer = other;\n', '  }\n', '\n', '\n', '  /**\n', '   * Set the contract that can call release and make the token transferable.\n', '   *\n', '   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n', '   */\n', '  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n', '\n', "    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n", '    releaseAgent = addr;\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n', '   */\n', '  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n', '    transferAgents[addr] = state;\n', '  }\n', '\n', '  /**\n', '   * One way function to release the tokens to the wild.\n', '   *\n', '   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    released = true;\n', '  }\n', '\n', '  /** The function can be called only before or after the tokens have been releasesd */\n', '  modifier inReleaseState(bool releaseState) {\n', '    require(releaseState == released);\n', '    _;\n', '  }\n', '\n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyReleaseAgent() {\n', '    require(msg.sender == releaseAgent);\n', '    _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public canTransfer(msg.sender,_value) returns (bool success)  {\n', '    // Call StandardToken.transfer()\n', '   return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public canTransfer(_from,_value) returns (bool success)  {\n', '    // Call StandardToken.transferForm()\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', 'contract RecycleToken is StandardToken, Ownable {\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  /**\n', '   * recycle user token to owner account\n', '   * \n', '   */\n', '  function recycle(address from, uint amount) onlyAdmins public {\n', '  \n', '    require(from != address(0));\n', '    require(balances[from] >=  amount);\n', '\n', '    balances[owner] = balances[owner].add(amount);\n', '    balances[from]  = balances[from].sub(amount);\n', '\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(from, owner, amount);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * A token that can increase its supply by another contract.\n', ' *\n', ' * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n', ' * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n', ' *\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '\n', '  using SafeMathLib for uint;\n', '\n', '  bool public mintingFinished = false;\n', '\n', '  /** List of agents that are allowed to create new tokens */\n', '  mapping (address => bool) public mintAgents;\n', '\n', '  event MintingAgentChanged(address addr, bool state  );\n', '\n', '  /**\n', '   * Create new tokens and allocate them to an address..\n', '   *\n', '   * Only callably by a crowdsale contract (mint agent). \n', '   */\n', '  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n', '\n', '    //totalsupply is not changed, send amount TTG to receiver from owner account.\n', '    balances[owner] = balances[owner].sub(amount);\n', '    balances[receiver] = balances[receiver].plus(amount);\n', '    \n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    emit Transfer(0, receiver, amount);\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a crowdsale contract to mint new tokens.\n', '   */\n', '  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n', '    mintAgents[addr] = state;\n', '    emit MintingAgentChanged(addr, state);\n', '  }\n', '\n', '  modifier onlyMintAgent() {\n', '    // Only crowdsale contracts are allowed to mint new tokens\n', '    require(mintAgents[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function enableMint() onlyOwner public {\n', '    mintingFinished = false;\n', '  }\n', '\n', '  /** Make sure we are not done yet. */\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * A crowdsaled token.\n', ' *\n', ' * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n', ' *\n', ' * - The token transfer() is disabled until the crowdsale is over\n', ' * - The token contract gives an opt-in upgrade path to a new contract\n', ' * - The same token can be part of several crowdsales through approve() mechanism\n', ' * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n', ' *\n', ' */\n', 'contract TTGCoin is ReleasableToken, MintableToken , DistributeToken, RecycleToken{\n', '\n', '  /** Name and symbol were updated. */\n', '  event UpdatedTokenInformation(string newName, string newSymbol);\n', '\n', '  string public name;\n', '\n', '  string public symbol;\n', '\n', '  uint public decimals;\n', '\n', '  /**\n', '   * Construct the token.\n', '   *\n', '   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n', '   *\n', '   */\n', '  function TTGCoin() public {\n', '    // Create any address, can be transferred\n', '    // to team multisig via changeOwner(),\n', '    owner = msg.sender;\n', '\n', '    addAdmin(owner);\n', '\n', '    name  = "TotalGame Coin";\n', '    symbol = "TGC";\n', '    totalSupply = 2000000000*10**18;\n', '    decimals = 18;\n', '\n', '    // Create initially all balance on the team multisig\n', '    balances[msg.sender] = totalSupply;\n', '\n', '    //Mint feature is not allow  now\n', '    mintingFinished = true;\n', '\n', '    //Set the distribute totaltoken strategy\n', '    totalAirDrop = totalSupply.mul(10).div(100);\n', '    totalCrowdCoin = totalSupply.mul(50).div(100);\n', '    totalDevCoin = totalSupply.mul(20).div(100);\n', '    totalFoundCoin = totalSupply.mul(20).div(100);\n', '\n', '    emit Minted(owner, totalSupply);\n', '  }\n', '\n', '\n', '  /**\n', '   * When token is released to be transferable, enforce no new tokens can be created.\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    super.releaseTokenTransfer();\n', '  }\n', '\n', '  /**\n', '   * Owner can update token information here.\n', '   *\n', '   * It is often useful to conceal the actual token association, until\n', '   * the token operations, like central issuance or reissuance have been completed.\n', '   *\n', '   * This function allows the token owner to rename the token after the operations\n', '   * have been completed and then point the audience to use the token contract.\n', '   */\n', '  function setTokenInformation(string _name, string _symbol) public onlyOwner {\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    emit UpdatedTokenInformation(name, symbol);\n', '  }\n', '\n', '  function getTotalSupply() public view returns (uint) {\n', '    return totalSupply;\n', '  }\n', '\n', '  function tokenName() public view returns (string _name) {\n', '    return name;\n', '  }\n', '}']
