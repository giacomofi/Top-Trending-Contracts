['pragma solidity ^0.4.18;\n', '\n', '/// @title Kinguin Krowns [KRS]\n', '\n', ' /* ERC223 additions to ERC20 */\n', '\n', ' /*\n', '  ERC223 additions to ERC20\n', '\n', '  Interface wise is ERC20 + data parameter to transfer and transferFrom.\n', ' */\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract ERC223 is ERC20 {\n', '  function transfer(address to, uint value, bytes data) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\n', '}\n', '\n', 'contract ERC223Receiver {\n', '  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  /*function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }*/\n', '}\n', '\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'contract KinguinKrowns is ERC223, StandardToken {\n', '  address public owner;  // token owner adddres\n', '  string public constant name = "Kinguin Krowns";\n', '  string public constant symbol = "KRS";\n', '  uint8 public constant decimals = 18;\n', '  // uint256 public totalSupply; // defined in ERC20 contract\n', '\t\t\n', '  function KinguinKrowns() {\n', '\towner = msg.sender;\n', '    totalSupply = 100000000 * (10**18); // 100 mln\n', '    balances[msg.sender] = totalSupply;\n', '  } \n', '  \n', '  /*\n', '  //only do if call is from owner modifier\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _;\n', '  }*/\n', '  \n', '  //function that is called when a user or another contract wants to transfer funds\n', '  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '    //filtering if the target is a contract with bytecode inside it\n', '    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\n', '    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    return transfer(_to, _value, new bytes(0));\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    return transferFrom(_from, _to, _value, new bytes(0));\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\n', '    ERC223Receiver receiver = ERC223Receiver(_to);\n', '    return receiver.tokenFallback(msg.sender, _origin, _value, _data);\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) private returns (bool is_contract) {\n', '    // retrieve the size of the code on target address, this needs assembly\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    return length > 0;\n', '  }\n', '  \n', '  // returns krown balance of given address \t\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\t\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/// @title Kinguin Krowns [KRS]\n', '\n', ' /* ERC223 additions to ERC20 */\n', '\n', ' /*\n', '  ERC223 additions to ERC20\n', '\n', '  Interface wise is ERC20 + data parameter to transfer and transferFrom.\n', ' */\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract ERC223 is ERC20 {\n', '  function transfer(address to, uint value, bytes data) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\n', '}\n', '\n', 'contract ERC223Receiver {\n', '  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  /*function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }*/\n', '}\n', '\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'contract KinguinKrowns is ERC223, StandardToken {\n', '  address public owner;  // token owner adddres\n', '  string public constant name = "Kinguin Krowns";\n', '  string public constant symbol = "KRS";\n', '  uint8 public constant decimals = 18;\n', '  // uint256 public totalSupply; // defined in ERC20 contract\n', '\t\t\n', '  function KinguinKrowns() {\n', '\towner = msg.sender;\n', '    totalSupply = 100000000 * (10**18); // 100 mln\n', '    balances[msg.sender] = totalSupply;\n', '  } \n', '  \n', '  /*\n', '  //only do if call is from owner modifier\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _;\n', '  }*/\n', '  \n', '  //function that is called when a user or another contract wants to transfer funds\n', '  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '    //filtering if the target is a contract with bytecode inside it\n', '    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\n', '    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    return transfer(_to, _value, new bytes(0));\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    return transferFrom(_from, _to, _value, new bytes(0));\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\n', '    ERC223Receiver receiver = ERC223Receiver(_to);\n', '    return receiver.tokenFallback(msg.sender, _origin, _value, _data);\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) private returns (bool is_contract) {\n', '    // retrieve the size of the code on target address, this needs assembly\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    return length > 0;\n', '  }\n', '  \n', '  // returns krown balance of given address \t\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\t\n', '}']
