['pragma solidity ^0.4.17;\n', '\n', '\n', '\n', '/// @title CurrencyToken contract\n', 'contract GBPp {\n', '\n', '    address public server; // Address, which the platform website uses.\n', '    address public populous; // Address of the Populous bank contract.\n', '\n', '    uint256 public totalSupply;\n', '    bytes32 public name;// token name, e.g, pounds for fiat UK pounds.\n', "    uint8 public decimals;// How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n", '    bytes32 public symbol;// An identifier: eg SBX.\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    //EVENTS\n', '    // An event triggered when a transfer of tokens is made from a _from address to a _to address.\n', '    event Transfer(\n', '        address indexed _from, \n', '        address indexed _to, \n', '        uint256 _value\n', '    );\n', '    // An event triggered when an owner of tokens successfully approves another address to spend a specified amount of tokens.\n', '    event Approval(\n', '        address indexed _owner, \n', '        address indexed _spender, \n', '        uint256 _value\n', '    );\n', '    // event EventMintTokens(bytes32 currency, uint amount);\n', '\n', '    // MODIFIERS\n', '\n', '    modifier onlyServer {\n', '        require(isServer(msg.sender) == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyServerOrOnlyPopulous {\n', '        require(isServer(msg.sender) == true || isPopulous(msg.sender) == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPopulous {\n', '        require(isPopulous(msg.sender) == true);\n', '        _;\n', '    }\n', '    // NON-CONSTANT METHODS\n', '    \n', '    /** @dev Creates a new currency/token.\n', '      * param _decimalUnits The decimal units/places the token can have.\n', "      * param _tokenSymbol The token's symbol, e.g., GBP.\n", '      * param _decimalUnits The tokens decimal unites/precision\n', '      * param _amount The amount of tokens to create upon deployment\n', '      * param _owner The owner of the tokens created upon deployment\n', '      * param _server The server/admin address\n', '      */\n', '    function GBPp ()\n', '        public\n', '    {\n', '        populous = server = 0x63d509F7152769Ddf162eD048B83719fE1e31080;\n', '        symbol = name = 0x47425070; // Set the name for display purposes\n', '        decimals = 6; // Amount of decimals for display purposes\n', '        balances[server] = safeAdd(balances[server], 10000000000000000);\n', '        totalSupply = safeAdd(totalSupply, 10000000000000000);\n', '    }\n', '\n', '    // ERC20\n', '\n', '    //Note.. Need to emit event, Pokens destroyed... from system\n', '    /** @dev Destroys a specified amount of tokens \n', '      * @dev The method uses a modifier from withAccessManager contract to only permit populous to use it.\n', '      * @dev The method uses SafeMath to carry out safe token deductions/subtraction.\n', '      * @param amount The amount of tokens to create.\n', '      */\n', '\n', '    function destroyTokens(uint amount) public onlyPopulous returns (bool success) {\n', '        if (balances[populous] < amount) {\n', '            return false;\n', '        } else {\n', '            balances[populous] = safeSub(balances[populous], amount);\n', '            totalSupply = safeSub(totalSupply, amount);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    \n', '    /** @dev Destroys a specified amount of tokens, from a user.\n', '      * @dev The method uses a modifier from withAccessManager contract to only permit populous to use it.\n', '      * @dev The method uses SafeMath to carry out safe token deductions/subtraction.\n', '      * @param amount The amount of tokens to create.\n', '      */\n', '    function destroyTokensFrom(uint amount, address from) public onlyPopulous returns (bool success) {\n', '        if (balances[from] < amount) {\n', '            return false;\n', '        } else {\n', '            balances[from] = safeSub(balances[from], amount);\n', '            totalSupply = safeSub(totalSupply, amount);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    // ACCESS MANAGER\n', '\n', '    /** @dev Checks a given address to determine whether it is populous address.\n', '      * @param sender The address to be checked.\n', '      * @return bool returns true or false is the address corresponds to populous or not.\n', '      */\n', '    function isPopulous(address sender) public view returns (bool) {\n', '        return sender == populous;\n', '    }\n', '\n', '        /** @dev Changes the populous contract address.\n', '      * @dev The method requires the message sender to be the set server.\n', '      * @param _populous The address to be set as populous.\n', '      */\n', '    function changePopulous(address _populous) public {\n', '        require(isServer(msg.sender) == true);\n', '        populous = _populous;\n', '    }\n', '\n', '    // CONSTANT METHODS\n', '    \n', '    /** @dev Checks a given address to determine whether it is the server.\n', '      * @param sender The address to be checked.\n', '      * @return bool returns true or false is the address corresponds to the server or not.\n', '      */\n', '    function isServer(address sender) public view returns (bool) {\n', '        return sender == server;\n', '    }\n', '\n', '    /** @dev Changes the server address that is set by the constructor.\n', '      * @dev The method requires the message sender to be the set server.\n', '      * @param _server The new address to be set as the server.\n', '      */\n', '    function changeServer(address _server) public {\n', '        require(isServer(msg.sender) == true);\n', '        server = _server;\n', '    }\n', '\n', '\n', '    // SAFE MATH\n', '\n', '\n', '      /** @dev Safely multiplies two unsigned/non-negative integers.\n', '    * @dev Ensures that one of both numbers can be derived from dividing the product by the other.\n', '    * @param a The first number.\n', '    * @param b The second number.\n', '    * @return uint The expected result.\n', '    */\n', '    function safeMul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '  /** @dev Safely subtracts one number from another\n', '    * @dev Ensures that the number to subtract is lower.\n', '    * @param a The first number.\n', '    * @param b The second number.\n', '    * @return uint The expected result.\n', '    */\n', '    function safeSub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '  /** @dev Safely adds two unsigned/non-negative integers.\n', '    * @dev Ensures that the sum of both numbers is greater or equal to one of both.\n', '    * @param a The first number.\n', '    * @param b The second number.\n', '    * @return uint The expected result.\n', '    */\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '}']