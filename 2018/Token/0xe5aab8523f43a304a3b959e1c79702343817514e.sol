['pragma solidity ^0.4.20;\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply) {}\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '}\n', '\n', 'contract Obredis is StandardToken { \n', '    string public name;                   // Token Name\n', '    uint8 public decimals;                // How many decimals the token has\n', '    string public symbol;                 // Token identifier\n', '    address public fundsWallet;           // Wallet which manages the contract\n', '    uint256 public totalRewards;\n', '    uint256 public newReward;\n', '    address[] public addresses;\n', '    mapping (address => bool) public isAddress;\n', '    bool public allRewPaid;\n', '    mapping (address => bool) public awaitingRew;\n', '    \n', '    \n', '    event Minted(uint256 qty,uint256 totalSupply);\n', '    event Burned(uint256 qty,uint256 totalSupply);\n', '    event Reward(uint256 qty);\n', '    \n', '    function Obredis() public {\n', '        balances[msg.sender] = 0;\n', '        totalSupply = 0;\n', '        name = "Obelisk Reward Token";\n', '        decimals = 18;\n', '        symbol = "ORT";\n', '        allRewPaid = true;\n', '        awaitingRew[msg.sender] = false;\n', '        fundsWallet = msg.sender;\n', '        addresses.push(msg.sender);\n', '        isAddress[msg.sender] = true;\n', '    }\n', '\n', '    function() public {\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public canSend returns (bool success) {\n', '        // Transfer Tokens\n', '        require(super.transfer(_to,_value));\n', '        if (!isAddress[_to]){\n', '            addresses.push(_to);\n', '            isAddress[_to] = true;\n', '        }\n', '        // Return success flag\n', '        return true;\n', '    }\n', '\n', '    modifier isOwner {\n', '        require(msg.sender == fundsWallet);\n', '        _;\n', '    }\n', '    \n', '    modifier canSend {\n', '        require(allRewPaid);\n', '        _;\n', '    }\n', '    \n', '    function forceTransfer(address _who, uint256 _qty) public isOwner returns (bool success) {\n', '        // owner can transfer qty from a wallet (in case your hopeless mates lose their private keys).\n', '        if (balances[_who] >= _qty && _qty > 0) {\n', '            balances[_who] -= _qty;\n', '            balances[fundsWallet] += _qty;\n', '            Transfer(_who, fundsWallet, _qty);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '    function payReward() public payable isOwner canSend {\n', '        require(msg.value > 0);\n', '        newReward = this.balance; // the only balance will be the scraps after payout\n', '        totalRewards += msg.value;     // only want to update with new amount\n', '        Reward(msg.value);\n', '        allRewPaid = false;\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++){\n', '            awaitingRew[addresses[i]] = true;\n', '        }\n', '    }\n', '    \n', '    function payAllRewards() public isOwner {\n', '        require(allRewPaid == false);\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++){\n', '            if (balances[addresses[i]] == 0){\n', '                awaitingRew[addresses[i]] = false;\n', '            } else if (awaitingRew[addresses[i]]) {\n', '                addresses[i].transfer((newReward*balances[addresses[i]])/totalSupply);\n', '                awaitingRew[addresses[i]] = false;\n', '            }\n', '        }\n', '        allRewPaid = true;\n', '    }\n', '\n', '    function paySomeRewards(uint32 _first, uint32 _last) public isOwner {\n', '        require(_first <= _last);\n', '        require(_last <= addresses.length);\n', '        for (uint32 i = _first; i<= _last; i++) {\n', '            if (balances[addresses[i]] == 0){\n', '                awaitingRew[addresses[i]] = false;\n', '            } else if (awaitingRew[addresses[i]]) {\n', '                addresses[i].transfer((newReward*balances[addresses[i]])/totalSupply);\n', '                awaitingRew[addresses[i]] = false;\n', '            }\n', '        }\n', '        allRewPaid = checkAllRewPaid(); \n', '    }\n', '    \n', '    function checkAllRewPaid() public view returns(bool success) {\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++ ){\n', '            if (awaitingRew[addresses[i]]){\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function updateAllRewPaid() public isOwner {\n', '        allRewPaid = checkAllRewPaid();\n', '    }\n', '\n', '    function mint(uint256 _qty) public canSend isOwner {\n', '        require(totalSupply + _qty > totalSupply); // Prevents overflow\n', '        totalSupply += _qty;\n', '        balances[fundsWallet] += _qty;\n', '        Minted(_qty,totalSupply);\n', '        Transfer(0x0, fundsWallet, _qty);\n', '    }\n', '    \n', '    function burn(uint256 _qty) public canSend isOwner {\n', '        require(totalSupply - _qty < totalSupply); // Prevents underflow\n', '        require(balances[fundsWallet] >= _qty);\n', '        totalSupply -= _qty;\n', '        balances[fundsWallet] -= _qty;\n', '        Burned(_qty,totalSupply);\n', '        Transfer(fundsWallet, 0x0, _qty);\n', '    }\n', '    \n', '    function collectOwnRew() public {\n', '        if(awaitingRew[msg.sender]){\n', '            msg.sender.transfer((newReward*balances[msg.sender])/totalSupply);\n', '            awaitingRew[msg.sender] = false;\n', '        }\n', '        allRewPaid = checkAllRewPaid();\n', '    }\n', '    \n', '    function addressesLength() public view returns(uint32 len){\n', '        return uint32(addresses.length);\n', '    }\n', '    \n', '    function kill() public isOwner {\n', '        // Too much money involved to not have a fire exit\n', '        selfdestruct(fundsWallet);\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract Token {\n', '    function totalSupply() public constant returns (uint256 supply) {}\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '}\n', '\n', 'contract Obredis is StandardToken { \n', '    string public name;                   // Token Name\n', '    uint8 public decimals;                // How many decimals the token has\n', '    string public symbol;                 // Token identifier\n', '    address public fundsWallet;           // Wallet which manages the contract\n', '    uint256 public totalRewards;\n', '    uint256 public newReward;\n', '    address[] public addresses;\n', '    mapping (address => bool) public isAddress;\n', '    bool public allRewPaid;\n', '    mapping (address => bool) public awaitingRew;\n', '    \n', '    \n', '    event Minted(uint256 qty,uint256 totalSupply);\n', '    event Burned(uint256 qty,uint256 totalSupply);\n', '    event Reward(uint256 qty);\n', '    \n', '    function Obredis() public {\n', '        balances[msg.sender] = 0;\n', '        totalSupply = 0;\n', '        name = "Obelisk Reward Token";\n', '        decimals = 18;\n', '        symbol = "ORT";\n', '        allRewPaid = true;\n', '        awaitingRew[msg.sender] = false;\n', '        fundsWallet = msg.sender;\n', '        addresses.push(msg.sender);\n', '        isAddress[msg.sender] = true;\n', '    }\n', '\n', '    function() public {\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public canSend returns (bool success) {\n', '        // Transfer Tokens\n', '        require(super.transfer(_to,_value));\n', '        if (!isAddress[_to]){\n', '            addresses.push(_to);\n', '            isAddress[_to] = true;\n', '        }\n', '        // Return success flag\n', '        return true;\n', '    }\n', '\n', '    modifier isOwner {\n', '        require(msg.sender == fundsWallet);\n', '        _;\n', '    }\n', '    \n', '    modifier canSend {\n', '        require(allRewPaid);\n', '        _;\n', '    }\n', '    \n', '    function forceTransfer(address _who, uint256 _qty) public isOwner returns (bool success) {\n', '        // owner can transfer qty from a wallet (in case your hopeless mates lose their private keys).\n', '        if (balances[_who] >= _qty && _qty > 0) {\n', '            balances[_who] -= _qty;\n', '            balances[fundsWallet] += _qty;\n', '            Transfer(_who, fundsWallet, _qty);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '    function payReward() public payable isOwner canSend {\n', '        require(msg.value > 0);\n', '        newReward = this.balance; // the only balance will be the scraps after payout\n', '        totalRewards += msg.value;     // only want to update with new amount\n', '        Reward(msg.value);\n', '        allRewPaid = false;\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++){\n', '            awaitingRew[addresses[i]] = true;\n', '        }\n', '    }\n', '    \n', '    function payAllRewards() public isOwner {\n', '        require(allRewPaid == false);\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++){\n', '            if (balances[addresses[i]] == 0){\n', '                awaitingRew[addresses[i]] = false;\n', '            } else if (awaitingRew[addresses[i]]) {\n', '                addresses[i].transfer((newReward*balances[addresses[i]])/totalSupply);\n', '                awaitingRew[addresses[i]] = false;\n', '            }\n', '        }\n', '        allRewPaid = true;\n', '    }\n', '\n', '    function paySomeRewards(uint32 _first, uint32 _last) public isOwner {\n', '        require(_first <= _last);\n', '        require(_last <= addresses.length);\n', '        for (uint32 i = _first; i<= _last; i++) {\n', '            if (balances[addresses[i]] == 0){\n', '                awaitingRew[addresses[i]] = false;\n', '            } else if (awaitingRew[addresses[i]]) {\n', '                addresses[i].transfer((newReward*balances[addresses[i]])/totalSupply);\n', '                awaitingRew[addresses[i]] = false;\n', '            }\n', '        }\n', '        allRewPaid = checkAllRewPaid(); \n', '    }\n', '    \n', '    function checkAllRewPaid() public view returns(bool success) {\n', '        uint32 len = uint32(addresses.length);\n', '        for (uint32 i = 0; i < len ; i++ ){\n', '            if (awaitingRew[addresses[i]]){\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function updateAllRewPaid() public isOwner {\n', '        allRewPaid = checkAllRewPaid();\n', '    }\n', '\n', '    function mint(uint256 _qty) public canSend isOwner {\n', '        require(totalSupply + _qty > totalSupply); // Prevents overflow\n', '        totalSupply += _qty;\n', '        balances[fundsWallet] += _qty;\n', '        Minted(_qty,totalSupply);\n', '        Transfer(0x0, fundsWallet, _qty);\n', '    }\n', '    \n', '    function burn(uint256 _qty) public canSend isOwner {\n', '        require(totalSupply - _qty < totalSupply); // Prevents underflow\n', '        require(balances[fundsWallet] >= _qty);\n', '        totalSupply -= _qty;\n', '        balances[fundsWallet] -= _qty;\n', '        Burned(_qty,totalSupply);\n', '        Transfer(fundsWallet, 0x0, _qty);\n', '    }\n', '    \n', '    function collectOwnRew() public {\n', '        if(awaitingRew[msg.sender]){\n', '            msg.sender.transfer((newReward*balances[msg.sender])/totalSupply);\n', '            awaitingRew[msg.sender] = false;\n', '        }\n', '        allRewPaid = checkAllRewPaid();\n', '    }\n', '    \n', '    function addressesLength() public view returns(uint32 len){\n', '        return uint32(addresses.length);\n', '    }\n', '    \n', '    function kill() public isOwner {\n', '        // Too much money involved to not have a fire exit\n', '        selfdestruct(fundsWallet);\n', '    }\n', '}']
