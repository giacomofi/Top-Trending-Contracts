['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract CreditAsiaCoin is StandardToken, Ownable {\n', '\n', '    string public name = "CreditAsia Coin";\n', '    string public symbol = "CAC";\n', '    uint public decimals = 18;\n', '\n', '    // The token allocation\n', '    uint public constant TOTAL_SUPPLY       = 10000000000e18;\n', '    uint public constant ALLOC_FOUNDER    =  10000000000e18; // 100%\n', '    \n', '\n', '    // wallets\n', '    address public constant WALLET_FOUNDER    = 0xbb90E8310a78f99aB776985A9B7ecDf39ace98e9; \n', '    \n', '    \n', '    // 2 groups of lockup\n', '    mapping(address => uint256) public contributors_locked; \n', '    mapping(address => uint256) public investors_locked;\n', '\n', '    // 2 types of releasing\n', '    mapping(address => uint256) public contributors_countdownDate;\n', '    mapping(address => uint256) public investors_deliveryDate;\n', '\n', '    // MODIFIER\n', '\n', '    // checks if the address can transfer certain amount of tokens\n', '    modifier canTransfer(address _sender, uint256 _value) {\n', '        require(_sender != address(0));\n', '\n', '        uint256 remaining = balances[_sender].sub(_value);\n', '        uint256 totalLockAmt = 0;\n', '\n', '        if (contributors_locked[_sender] > 0) {\n', '            totalLockAmt = totalLockAmt.add(getLockedAmount_contributors(_sender));\n', '        }\n', '\n', '        if (investors_locked[_sender] > 0) {\n', '            totalLockAmt = totalLockAmt.add(getLockedAmount_investors(_sender));\n', '        }\n', '\n', '        require(remaining >= totalLockAmt);\n', '\n', '        _;\n', '    }\n', '\n', '    // EVENTS\n', '    event UpdatedLockingState(string whom, address indexed to, uint256 value, uint256 date);\n', '\n', '    // FUNCTIONS\n', '\n', '    function CreditAsiaCoin() public {\n', '        balances[msg.sender] = TOTAL_SUPPLY;\n', '        totalSupply = TOTAL_SUPPLY;\n', '\n', '        // do the distribution of the token, in token transfer\n', '        transfer(WALLET_FOUNDER, ALLOC_FOUNDER);\n', '        \n', '    }\n', '\t\n', '    // get contributors&#39; locked amount of token\n', '    // this lockup will be released in 8 batches which take place every 180 days\n', '    function getLockedAmount_contributors(address _contributor) \n', '        public\n', '\t\tconstant\n', '\t\treturns (uint256)\n', '\t{\n', '        uint256 countdownDate = contributors_countdownDate[_contributor];\n', '        uint256 lockedAmt = contributors_locked[_contributor];\n', '\n', '        if (now <= countdownDate +  (90 * 1 days )) {return lockedAmt;}\n', '       \n', '\t\n', '        return 0;\n', '    }\n', '\n', '    // get investors&#39; locked amount of token\n', '    // this lockup will be released in 3 batches: \n', '    // 1. on delievery date\n', '    // 2. three months after the delivery date\n', '    // 3. six months after the delivery date\n', '    function getLockedAmount_investors(address _investor)\n', '        public\n', '\t\tconstant\n', '\t\treturns (uint256)\n', '\t{\n', '        uint256 delieveryDate = investors_deliveryDate[_investor];\n', '        uint256 lockedAmt = investors_locked[_investor];\n', '\n', '        if (now <= delieveryDate) {return lockedAmt;}\n', '        if (now <= delieveryDate + 90 days) {return lockedAmt;}\n', '        \n', '\t\n', '        return 0;\n', '    }\n', '\n', '    // set lockup for contributors \n', '    function setLockup_contributors(address _contributor, uint256 _value, uint256 _countdownDate)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_contributor != address(0));\n', '\n', '        contributors_locked[_contributor] = _value;\n', '        contributors_countdownDate[_contributor] = _countdownDate;\n', '        UpdatedLockingState("contributor", _contributor, _value, _countdownDate);\n', '    }\n', '\n', '    // set lockup for strategic investor\n', '    function setLockup_investors(address _investor, uint256 _value, uint256 _delieveryDate)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_investor != address(0));\n', '\n', '        investors_locked[_investor] = _value;\n', '        investors_deliveryDate[_investor] = _delieveryDate;\n', '        UpdatedLockingState("investor", _investor, _value, _delieveryDate);\n', '    }\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        canTransfer(msg.sender, _value)\n', '\t\treturns (bool success)\n', '\t{\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        canTransfer(_from, _value)\n', '\t\treturns (bool success)\n', '\t{\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract CreditAsiaCoin is StandardToken, Ownable {\n', '\n', '    string public name = "CreditAsia Coin";\n', '    string public symbol = "CAC";\n', '    uint public decimals = 18;\n', '\n', '    // The token allocation\n', '    uint public constant TOTAL_SUPPLY       = 10000000000e18;\n', '    uint public constant ALLOC_FOUNDER    =  10000000000e18; // 100%\n', '    \n', '\n', '    // wallets\n', '    address public constant WALLET_FOUNDER    = 0xbb90E8310a78f99aB776985A9B7ecDf39ace98e9; \n', '    \n', '    \n', '    // 2 groups of lockup\n', '    mapping(address => uint256) public contributors_locked; \n', '    mapping(address => uint256) public investors_locked;\n', '\n', '    // 2 types of releasing\n', '    mapping(address => uint256) public contributors_countdownDate;\n', '    mapping(address => uint256) public investors_deliveryDate;\n', '\n', '    // MODIFIER\n', '\n', '    // checks if the address can transfer certain amount of tokens\n', '    modifier canTransfer(address _sender, uint256 _value) {\n', '        require(_sender != address(0));\n', '\n', '        uint256 remaining = balances[_sender].sub(_value);\n', '        uint256 totalLockAmt = 0;\n', '\n', '        if (contributors_locked[_sender] > 0) {\n', '            totalLockAmt = totalLockAmt.add(getLockedAmount_contributors(_sender));\n', '        }\n', '\n', '        if (investors_locked[_sender] > 0) {\n', '            totalLockAmt = totalLockAmt.add(getLockedAmount_investors(_sender));\n', '        }\n', '\n', '        require(remaining >= totalLockAmt);\n', '\n', '        _;\n', '    }\n', '\n', '    // EVENTS\n', '    event UpdatedLockingState(string whom, address indexed to, uint256 value, uint256 date);\n', '\n', '    // FUNCTIONS\n', '\n', '    function CreditAsiaCoin() public {\n', '        balances[msg.sender] = TOTAL_SUPPLY;\n', '        totalSupply = TOTAL_SUPPLY;\n', '\n', '        // do the distribution of the token, in token transfer\n', '        transfer(WALLET_FOUNDER, ALLOC_FOUNDER);\n', '        \n', '    }\n', '\t\n', "    // get contributors' locked amount of token\n", '    // this lockup will be released in 8 batches which take place every 180 days\n', '    function getLockedAmount_contributors(address _contributor) \n', '        public\n', '\t\tconstant\n', '\t\treturns (uint256)\n', '\t{\n', '        uint256 countdownDate = contributors_countdownDate[_contributor];\n', '        uint256 lockedAmt = contributors_locked[_contributor];\n', '\n', '        if (now <= countdownDate +  (90 * 1 days )) {return lockedAmt;}\n', '       \n', '\t\n', '        return 0;\n', '    }\n', '\n', "    // get investors' locked amount of token\n", '    // this lockup will be released in 3 batches: \n', '    // 1. on delievery date\n', '    // 2. three months after the delivery date\n', '    // 3. six months after the delivery date\n', '    function getLockedAmount_investors(address _investor)\n', '        public\n', '\t\tconstant\n', '\t\treturns (uint256)\n', '\t{\n', '        uint256 delieveryDate = investors_deliveryDate[_investor];\n', '        uint256 lockedAmt = investors_locked[_investor];\n', '\n', '        if (now <= delieveryDate) {return lockedAmt;}\n', '        if (now <= delieveryDate + 90 days) {return lockedAmt;}\n', '        \n', '\t\n', '        return 0;\n', '    }\n', '\n', '    // set lockup for contributors \n', '    function setLockup_contributors(address _contributor, uint256 _value, uint256 _countdownDate)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_contributor != address(0));\n', '\n', '        contributors_locked[_contributor] = _value;\n', '        contributors_countdownDate[_contributor] = _countdownDate;\n', '        UpdatedLockingState("contributor", _contributor, _value, _countdownDate);\n', '    }\n', '\n', '    // set lockup for strategic investor\n', '    function setLockup_investors(address _investor, uint256 _value, uint256 _delieveryDate)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(_investor != address(0));\n', '\n', '        investors_locked[_investor] = _value;\n', '        investors_deliveryDate[_investor] = _delieveryDate;\n', '        UpdatedLockingState("investor", _investor, _value, _delieveryDate);\n', '    }\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        canTransfer(msg.sender, _value)\n', '\t\treturns (bool success)\n', '\t{\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        canTransfer(_from, _value)\n', '\t\treturns (bool success)\n', '\t{\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}']
