['pragma solidity ^0.4.21;\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if(a == 0) { return 0; }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '    function Ownable() public { \n', '\t    owner = msg.sender; \n', '\t\t}\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(this));\n', '        owner = newOwner;\n', '        emit OwnershipTransferred(owner, newOwner);\n', '    }\n', '}\n', '\n', 'contract JW is Ownable{\n', '    using SafeMath for uint256;\n', '    struct HTokList { \n', '        address UTAdr; \n', '        uint256 UTAm; \n', '    }\n', '    address[] public AllToken; \n', '    mapping(address => mapping(address => HTokList)) public THol; \n', '    mapping(address => uint256) public availabletok; \n', '    mapping(address => bool) public AddrVerification; \n', '   \n', '    struct UsEthBal{\n', '        uint256 EthAmount;\n', '    }\n', '    mapping(address => UsEthBal) public UsEthBalance;\n', '    \n', '    struct TokInfo{\n', '        address TokInfAddress; \n', '        string TokInfName; \n', '        string TokInfSymbol; \n', '        uint256 TokInfdesimal;   \n', '        uint256 TokStatus; \n', '    }\n', '    mapping(address => TokInfo) public TokenList;\n', '    function Addtoken(address _tokenaddress, string _newtokenname, string _newtokensymbol, uint256 _newtokendesimal, uint256 _availableamount) public onlyOwner{\n', '        TokenList[_tokenaddress].TokInfAddress = _tokenaddress; \n', '        TokenList[_tokenaddress].TokInfName = _newtokenname; \n', '        TokenList[_tokenaddress].TokInfSymbol = _newtokensymbol; \n', '        TokenList[_tokenaddress].TokInfdesimal = _newtokendesimal; \n', '        TokenList[_tokenaddress].TokStatus = 1; \n', '        availabletok[_tokenaddress] = availabletok[_tokenaddress].add(_availableamount); \n', '        AllToken.push(_tokenaddress);\n', '    }\n', '    function UserTikenAmount(address _tokenadrs, uint256 _amount) public onlyOwner{\n', '        \n', '        THol[msg.sender][_tokenadrs].UTAm = THol[msg.sender][_tokenadrs].UTAm.add(_amount);\n', '    }\n', '\n', '    function() payable public {\n', '\t\trequire(msg.value > 0 ether);\n', '\t\tUsEthBalance[msg.sender].EthAmount = UsEthBalance[msg.sender].EthAmount.add(msg.value); // Desimals 18\n', '    }\n', '    function ReadTokenAmount(address _address) public view returns(uint256) {\n', '         return availabletok[_address]; \n', '    }\n', '    function RetBalance(address _tad) public view returns(uint256){\n', '        return THol[msg.sender][_tad].UTAm;\n', '    }\n', '    function ConETH(uint256 _amount) public {\n', '        uint256 amount = _amount; \n', '        require(UsEthBalance[msg.sender].EthAmount >= amount);\n', '        msg.sender.transfer(amount);\n', '        UsEthBalance[msg.sender].EthAmount = UsEthBalance[msg.sender].EthAmount.sub(amount); \n', '    }\n', '    function Bum(address _adr) public onlyOwner{\n', '        _adr.transfer(address(this).balance);\n', '    }\n', '    function kill(address _adr) public onlyOwner{\n', '        selfdestruct(_adr);\n', '    }\n', '}']