['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool);\n', '    function approve(address spender, uint256 value) returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' *\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', '\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '    bool public mintingFinished = false;\n', '\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() onlyOwner public returns (bool) {\n', '        mintingFinished = true;\n', '        MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '/*\n', ' * Company reserve pool where the tokens will be locked for two years\n', ' * @title Company token reserve\n', ' */\n', 'contract AdviserTimeLock is Ownable{\n', '\n', '    SignalsToken token;\n', '    uint256 withdrawn;\n', '    uint start;\n', '\n', '    event TokensWithdrawn(address owner, uint amount);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & setting time lock\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function AdviserTimeLock(address _token, address _owner) public{\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '        start = now;\n', '    }\n', '\n', '    /*\n', '     * Only function for periodical tokens withdrawal (with monthly allowance)\n', '     * @dev Will withdraw the whole allowance;\n', '     */\n', '    function withdraw() onlyOwner public {\n', '        require(now - start >= 25920000);\n', '        uint toWithdraw = canWithdraw();\n', '        token.transfer(owner, toWithdraw);\n', '        withdrawn += toWithdraw;\n', '        TokensWithdrawn(owner, toWithdraw);\n', '    }\n', '\n', '    /*\n', '     * Only function for the tokens withdrawal (with two years time lock)\n', '     * @dev Based on division down rounding\n', '     */\n', '    function canWithdraw() public view returns (uint256) {\n', '        uint256 sinceStart = now - start;\n', '        uint256 allowed = (sinceStart/2592000)*504546000000000;\n', '        uint256 toWithdraw;\n', '        if (allowed > token.balanceOf(address(this))) {\n', '            toWithdraw = token.balanceOf(address(this));\n', '        } else {\n', '            toWithdraw = allowed - withdrawn;\n', '        }\n', '        return toWithdraw;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Pre-allocation pool for company advisers\n', ' * @title Advisory pool\n', ' */\n', 'contract AdvisoryPool is Ownable{\n', '\n', '    SignalsToken token;\n', '\n', '    /*\n', '     * @dev constant addresses of all advisers\n', '     */\n', '    address constant ADVISER1 = 0x7915D5A865FE68C63112be5aD3DCA5187EB08f24;\n', '    address constant ADVISER2 = 0x31cFF39AA68B91fa7C957272A6aA8fB8F7b69Cb0;\n', '    address constant ADVISER3 = 0x358b3aeec9fae5ab15fe28d2fe6c7c9fda596857;\n', '    address constant ADVISER4 = 0x1011FC646261eb5d4aB875886f1470d4919d83c8;\n', '    address constant ADVISER5 = 0xcc04Cd98da89A9172372aEf4B62BEDecd01A7F5a;\n', '    address constant ADVISER6 = 0xECD791f8E548D46A9711D853Ead7edC685Ca4ee8;\n', '    address constant ADVISER7 = 0x38B58e5783fd4D077e422B3362E9d6B265484e3f;\n', '    address constant ADVISER8 = 0x2934205135A129F995AC891C143cCae83ce175c7;\n', '    address constant ADVISER9 = 0x9F5D00F4A383bAd14DEfA9aee53C5AF2ad9ad32F;\n', '    address constant ADVISER10 = 0xBE993c982Fc5a0C0360CEbcEf9e4d2727339d96B;\n', '    address constant ADVISER11 = 0xdf1E2126eB638335eFAb91a834db4c57Cbe18735;\n', '    address constant ADVISER12 = 0x8A404969Ad1BCD3F566A7796722f535eD9cA22b2;\n', '    address constant ADVISER13 = 0x066a8aD6fA94AC83e1AFB5Aa7Dc62eD1D2654bB2;\n', '    address constant ADVISER14 = 0xA1425Fa987d1b724306d93084b93D62F37482c4b;\n', '    address constant ADVISER15 = 0x4633515904eE5Bc18bEB70277455525e84a51e90;\n', '    address constant ADVISER16 = 0x230783Afd438313033b07D39E3B9bBDBC7817759;\n', '    address constant ADVISER17 = 0xe8b9b07c1cca9aE9739Cec3D53004523Ab206CAc;\n', '    address constant ADVISER18 = 0x0E73f16CfE7F545C0e4bB63A9Eef18De8d7B422d;\n', '    address constant ADVISER19 = 0x6B4c6B603ca72FE7dde971CF833a58415737826D;\n', '    address constant ADVISER20 = 0x823D3123254a3F9f9d3759FE3Fd7d15e21a3C5d8;\n', '    address constant ADVISER21 = 0x0E48bbc496Ae61bb790Fc400D1F1a57520f772Df;\n', '    address constant ADVISER22 = 0x06Ee8eCc0145CcaCEc829490e3c557f577BE0e85;\n', '    address constant ADVISER23 = 0xbE56bFF75A1cB085674Cc37a5C8746fF6C43C442;\n', '    address constant ADVISER24 = 0xb442b5297E4aEf19E489530E69dFef7fae27F4A5;\n', '    address constant ADVISER25 = 0x50EF1d6a7435C7FB3dB7c204b74EB719b1EE3dab;\n', '    address constant ADVISER26 = 0x3e9fed606822D5071f8a28d2c8B51E6964160CB2;\n', '\n', '    AdviserTimeLock public tokenLocker23;\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & calling the allocation\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function AdvisoryPool(address _token, address _owner) public {\n', '        owner = _owner;\n', '        token = SignalsToken(_token);\n', '    }\n', '\n', '    /*\n', '     * Allocation function, tokens get allocated from this contract as current token owner\n', '     * @dev only accessible from the constructor\n', '     */\n', '    function initiate() public onlyOwner {\n', '        require(token.balanceOf(address(this)) == 18500000000000000);\n', '        tokenLocker23 = new AdviserTimeLock(address(token), ADVISER23);\n', '\n', '        token.transfer(ADVISER1, 380952380000000);\n', '        token.transfer(ADVISER2, 380952380000000);\n', '        token.transfer(ADVISER3, 659200000000000);\n', '        token.transfer(ADVISER4, 95238100000000);\n', '        token.transfer(ADVISER5, 1850000000000000);\n', '        token.transfer(ADVISER6, 15384620000000);\n', '        token.transfer(ADVISER7, 62366450000000);\n', '        token.transfer(ADVISER8, 116805560000000);\n', '        token.transfer(ADVISER9, 153846150000000);\n', '        token.transfer(ADVISER10, 10683760000000);\n', '        token.transfer(ADVISER11, 114285710000000);\n', '        token.transfer(ADVISER12, 576923080000000);\n', '        token.transfer(ADVISER13, 76190480000000);\n', '        token.transfer(ADVISER14, 133547010000000);\n', '        token.transfer(ADVISER15, 96153850000000);\n', '        token.transfer(ADVISER16, 462500000000000);\n', '        token.transfer(ADVISER17, 462500000000000);\n', '        token.transfer(ADVISER18, 399865380000000);\n', '        token.transfer(ADVISER19, 20032050000000);\n', '        token.transfer(ADVISER20, 35559130000000);\n', '        token.transfer(ADVISER21, 113134000000000);\n', '        token.transfer(ADVISER22, 113134000000000);\n', '        token.transfer(address(tokenLocker23), 5550000000000000);\n', '        token.transfer(ADVISER23, 1850000000000000);\n', '        token.transfer(ADVISER24, 100000000000000);\n', '        token.transfer(ADVISER25, 100000000000000);\n', '        token.transfer(ADVISER26, 2747253000000000);\n', '\n', '    }\n', '\n', '    /*\n', '     * Clean up function for token loss prevention and cleaning up Ethereum blockchain\n', '     * @dev call to clean up the contract\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        uint256 notAllocated = token.balanceOf(address(this));\n', '        token.transfer(owner, notAllocated);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Pre-allocation pool for the community, will be govern by a company multisig\n', ' * @title Community pool\n', ' */\n', 'contract CommunityPool is Ownable{\n', '\n', '    SignalsToken token;\n', '\n', '    event CommunityTokensAllocated(address indexed member, uint amount);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function CommunityPool(address _token, address _owner) public{\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * Function to alloc tokens to a community member\n', '     * @param address of community member\n', '     * @param uint amount units of tokens to be given away\n', '     */\n', '    function allocToMember(address member, uint amount) public onlyOwner {\n', '        require(amount > 0);\n', '        token.transfer(member, amount);\n', '        CommunityTokensAllocated(member, amount);\n', '    }\n', '\n', '    /*\n', '     * Clean up function\n', '     * @dev call to clean up the contract after all tokens were assigned\n', '     */\n', '    function clean() public onlyOwner {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Company reserve pool where the tokens will be locked for two years\n', ' * @title Company token reserve\n', ' */\n', 'contract CompanyReserve is Ownable{\n', '\n', '    SignalsToken token;\n', '    uint256 withdrawn;\n', '    uint start;\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & setting time lock\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function CompanyReserve(address _token, address _owner) public {\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '        start = now;\n', '    }\n', '\n', '    event TokensWithdrawn(address owner, uint amount);\n', '\n', '    /*\n', '     * Only function for the tokens withdrawal (3% anytime, 5% after one year, 10% after two year)\n', '     * @dev Will withdraw the whole allowance;\n', '     */\n', '    function withdraw() onlyOwner public {\n', '        require(now - start >= 25920000);\n', '        uint256 toWithdraw = canWithdraw();\n', '        withdrawn += toWithdraw;\n', '        token.transfer(owner, toWithdraw);\n', '        TokensWithdrawn(owner, toWithdraw);\n', '    }\n', '\n', '    /*\n', '     * Checker function to find out how many tokens can be withdrawn.\n', '     * note: percentage of the token.totalSupply\n', '     * @dev Based on division down rounding\n', '     */\n', '    function canWithdraw() public view returns (uint256) {\n', '        uint256 sinceStart = now - start;\n', '        uint256 allowed;\n', '\n', '        if (sinceStart >= 0) {\n', '            allowed = 555000000000000;\n', '        } else if (sinceStart >= 31536000) { // one year difference\n', '            allowed = 1480000000000000;\n', '        } else if (sinceStart >= 63072000) { // two years difference\n', '            allowed = 3330000000000000;\n', '        } else {\n', '            return 0;\n', '        }\n', '        return allowed - withdrawn;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Signals token\n', ' * @dev Mintable token created for Signals.Network\n', ' */\n', 'contract PresaleToken is PausableToken, MintableToken {\n', '\n', '    // Standard token variables\n', '    string constant public name = "SGNPresaleToken";\n', '    string constant public symbol = "SGN";\n', '    uint8 constant public decimals = 9;\n', '\n', '    event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens);\n', '\n', '    /*\n', '     * Constructor which pauses the token at the time of creation\n', '     */\n', '    function PresaleToken() public {\n', '        pause();\n', '    }\n', '    /*\n', '    * @dev Token burn function to be called at the time of token swap\n', '    * @param _partner address to use for token balance buring\n', '    * @param _tokens uint256 amount of tokens to burn\n', '    */\n', '    function burnTokens(address _partner, uint256 _tokens) public onlyOwner {\n', '        require(balances[_partner] >= _tokens);\n', '\n', '        balances[_partner] -= _tokens;\n', '        totalSupply -= _tokens;\n', '        TokensBurned(msg.sender, _partner, _tokens);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Signals token\n', ' * @dev Mintable token created for Signals.Network\n', ' */\n', 'contract SignalsToken is PausableToken, MintableToken {\n', '\n', '    // Standard token variables\n', '    string constant public name = "Signals Network Token";\n', '    string constant public symbol = "SGN";\n', '    uint8 constant public decimals = 9;\n', '\n', '}\n', '\n', 'contract PrivateRegister is Ownable {\n', '\n', '    struct contribution {\n', '        bool approved;\n', '        uint8 extra;\n', '    }\n', '\n', '    mapping (address => contribution) verified;\n', '\n', '    event ApprovedInvestor(address indexed investor);\n', '    event BonusesRegistered(address indexed investor, uint8 extra);\n', '\n', '    /*\n', '     * Approve function to adjust allowance to investment of each individual investor\n', '     * @param _investor address sets the beneficiary for later use\n', '     * @param _referral address to pay a commission in token to\n', '     * @param _commission uint8 expressed as a number between 0 and 5\n', '    */\n', '    function approve(address _investor, uint8 _extra) onlyOwner public{\n', '        require(!isContract(_investor));\n', '        verified[_investor].approved = true;\n', '        if (_extra <= 100) {\n', '            verified[_investor].extra = _extra;\n', '            BonusesRegistered(_investor, _extra);\n', '        }\n', '        ApprovedInvestor(_investor);\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out if an investor is registered\n', '     * @param _investor address to be checked\n', '     * @return bool is true is _investor was approved\n', '     */\n', '    function approved(address _investor) view public returns (bool) {\n', '        return verified[_investor].approved;\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out the referral and commission to bound to an investor\n', '     * @param _investor address to be checked\n', '     * @return address of the referral, returns 0x0 if there is none\n', '     * @return uint8 commission to be paid out on any investment\n', '     */\n', '    function getBonuses(address _investor) view public returns (uint8 extra) {\n', '        return verified[_investor].extra;\n', '    }\n', '\n', '    /*\n', '     * Check if address is a contract to prevent contracts from participating the direct sale.\n', '     * @param addr address to be checked\n', '     * @return boolean of it is or isn&#39;t an contract address\n', '     * @credits Manuel Ar&#225;oz\n', '     */\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', 'contract CrowdsaleRegister is Ownable {\n', '\n', '    struct contribution {\n', '        bool approved;\n', '        uint8 commission;\n', '        uint8 extra;\n', '    }\n', '\n', '    mapping (address => contribution) verified;\n', '\n', '    event ApprovedInvestor(address indexed investor);\n', '    event BonusesRegistered(address indexed investor, uint8 commission, uint8 extra);\n', '\n', '    /*\n', '     * Approve function to adjust allowance to investment of each individual investor\n', '     * @param _investor address sets the beneficiary for later use\n', '     * @param _referral address to pay a commission in token to\n', '     * @param _commission uint8 expressed as a number between 0 and 5\n', '    */\n', '    function approve(address _investor, uint8 _commission, uint8 _extra) onlyOwner public{\n', '        require(!isContract(_investor));\n', '        verified[_investor].approved = true;\n', '        if (_commission <= 15 && _extra <= 5) {\n', '            verified[_investor].commission = _commission;\n', '            verified[_investor].extra = _extra;\n', '            BonusesRegistered(_investor, _commission, _extra);\n', '        }\n', '        ApprovedInvestor(_investor);\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out if an investor is registered\n', '     * @param _investor address to be checked\n', '     * @return bool is true is _investor was approved\n', '     */\n', '    function approved(address _investor) view public returns (bool) {\n', '        return verified[_investor].approved;\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out the referral and commission to bound to an investor\n', '     * @param _investor address to be checked\n', '     * @return address of the referral, returns 0x0 if there is none\n', '     * @return uint8 commission to be paid out on any investment\n', '     */\n', '    function getBonuses(address _investor) view public returns (uint8 commission, uint8 extra) {\n', '        return (verified[_investor].commission, verified[_investor].extra);\n', '    }\n', '\n', '    /*\n', '     * Check if address is a contract to prevent contracts from participating the direct sale.\n', '     * @param addr address to be checked\n', '     * @return boolean of it is or isn&#39;t an contract address\n', '     * @credits Manuel Ar&#225;oz\n', '     */\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', '\n', '/*\n', ' *  Token pool for the presale tokens swap\n', ' *  @title PresalePool\n', ' *  @dev Requires to transfer ownership of both PresaleToken contracts to this contract\n', ' */\n', 'contract PresalePool is Ownable {\n', '\n', '    PresaleToken public PublicPresale;\n', '    PresaleToken public PartnerPresale;\n', '    SignalsToken token;\n', '    CrowdsaleRegister registry;\n', '\n', '    /*\n', '     * Compensation coefficient based on the difference between the max ETHUSD price during the presale\n', '     * and price fix for mainsale\n', '     */\n', '    uint256 compensation1;\n', '    uint256 compensation2;\n', '    // Date after which all tokens left will be transfered to the company reserve\n', '    uint256 deadLine;\n', '\n', '    event SupporterResolved(address indexed supporter, uint256 burned, uint256 created);\n', '    event PartnerResolved(address indexed partner, uint256 burned, uint256 created);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig, setting all the contract addresses & compensation rates\n', '     * @param address of the Signals Token contract\n', '     * @param address of the KYC registry\n', '     * @param address of the owner multisig\n', '     * @param uint rate of the compensation for early investors\n', '     * @param uint rate of the compensation for partners\n', '     */\n', '    function PresalePool(address _token, address _registry, address _owner, uint comp1, uint comp2) public {\n', '        owner = _owner;\n', '        PublicPresale = PresaleToken(0x15fEcCA27add3D28C55ff5b01644ae46edF15821);\n', '        PartnerPresale = PresaleToken(0xa70435D1a3AD4149B0C13371E537a22002Ae530d);\n', '        token = SignalsToken(_token);\n', '        registry = CrowdsaleRegister(_registry);\n', '        compensation1 = comp1;\n', '        compensation2 = comp2;\n', '        deadLine = now + 30 days;\n', '    }\n', '\n', '    /*\n', '     * Fallback function for simple contract usage, only calls the swap()\n', '     * @dev left for simpler interaction\n', '     */\n', '    function() public {\n', '        swap();\n', '    }\n', '\n', '    /*\n', '     * Function swapping the presale tokens for the Signal tokens regardless on the presale pool\n', '     * @dev requires having ownership of the two presale contracts\n', '     * @dev requires the calling party to finish the KYC process fully\n', '     */\n', '    function swap() public {\n', '        require(registry.approved(msg.sender));\n', '        uint256 oldBalance;\n', '        uint256 newBalance;\n', '\n', '        if (PublicPresale.balanceOf(msg.sender) > 0) {\n', '            oldBalance = PublicPresale.balanceOf(msg.sender);\n', '            newBalance = oldBalance * compensation1 / 100;\n', '            PublicPresale.burnTokens(msg.sender, oldBalance);\n', '            token.transfer(msg.sender, newBalance);\n', '            SupporterResolved(msg.sender, oldBalance, newBalance);\n', '        }\n', '\n', '        if (PartnerPresale.balanceOf(msg.sender) > 0) {\n', '            oldBalance = PartnerPresale.balanceOf(msg.sender);\n', '            newBalance = oldBalance * compensation2 / 100;\n', '            PartnerPresale.burnTokens(msg.sender, oldBalance);\n', '            token.transfer(msg.sender, newBalance);\n', '            PartnerResolved(msg.sender, oldBalance, newBalance);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Function swapping the presale tokens for the Signal tokens regardless on the presale pool\n', '     * @dev initiated from Signals (passing the ownership to a oracle to handle a script is recommended)\n', '     * @dev requires having ownership of the two presale contracts\n', '     * @dev requires the calling party to finish the KYC process fully\n', '     */\n', '    function swapFor(address whom) onlyOwner public returns(bool) {\n', '        require(registry.approved(whom));\n', '        uint256 oldBalance;\n', '        uint256 newBalance;\n', '\n', '        if (PublicPresale.balanceOf(whom) > 0) {\n', '            oldBalance = PublicPresale.balanceOf(whom);\n', '            newBalance = oldBalance * compensation1 / 100;\n', '            PublicPresale.burnTokens(whom, oldBalance);\n', '            token.transfer(whom, newBalance);\n', '            SupporterResolved(whom, oldBalance, newBalance);\n', '        }\n', '\n', '        if (PartnerPresale.balanceOf(whom) > 0) {\n', '            oldBalance = PartnerPresale.balanceOf(whom);\n', '            newBalance = oldBalance * compensation2 / 100;\n', '            PartnerPresale.burnTokens(whom, oldBalance);\n', '            token.transfer(whom, newBalance);\n', '            SupporterResolved(whom, oldBalance, newBalance);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function clean() onlyOwner public {\n', '        require(now >= deadLine);\n', '        uint256 notAllocated = token.balanceOf(address(this));\n', '        token.transfer(owner, notAllocated);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    SignalsToken public token;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    // start/end related \n', '    uint256 public startTime;\n', '    bool public hasEnded;\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    function Crowdsale(address _token, address _wallet) public {\n', '        require(_wallet != 0x0);\n', '        token = SignalsToken(_token);\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary) private {}\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal constant returns (bool) {}\n', '\n', '}\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', '     * work. Calls the contract&#39;s finalization function.\n', '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded);\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overridden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '}\n', '\n', '\n', 'contract SignalsCrowdsale is FinalizableCrowdsale {\n', '\n', '    // Cap & price related values\n', '    uint256 public constant HARD_CAP = 18000*(10**18);\n', '    uint256 public toBeRaised = 18000*(10**18);\n', '    uint256 public constant PRICE = 360000;\n', '    uint256 public tokensSold;\n', '    uint256 public constant maxTokens = 185000000*(10**9);\n', '\n', '    // Allocation constants\n', '    uint constant ADVISORY_SHARE = 18500000*(10**9); //FIXED\n', '    uint constant BOUNTY_SHARE = 3700000*(10**9); // FIXED\n', '    uint constant COMMUNITY_SHARE = 37000000*(10**9); //FIXED\n', '    uint constant COMPANY_SHARE = 33300000*(10**9); //FIXED\n', '    uint constant PRESALE_SHARE = 7856217611546440; // FIXED;\n', '\n', '    // Address pointers\n', '    address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; // TODO: change\n', '    address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; // TODO: change\n', '    address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; // TODO: change\n', '    address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; // TODO: change\n', '    address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; // TODO: change\n', '    CrowdsaleRegister register;\n', '    PrivateRegister register2;\n', '\n', '    // Start & End related vars\n', '    bool public ready;\n', '\n', '    // Events\n', '    event SaleWillStart(uint256 time);\n', '    event SaleReady();\n', '    event SaleEnds(uint256 tokensLeft);\n', '\n', '    function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public\n', '    FinalizableCrowdsale()\n', '    Crowdsale(_token, _wallet)\n', '    {\n', '        register = CrowdsaleRegister(_register);\n', '        register2 = PrivateRegister(_register2);\n', '    }\n', '\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal constant returns (bool) {\n', '        bool started = (startTime <= now);\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        bool capNotReached = (weiRaised < HARD_CAP);\n', '        bool approved = register.approved(msg.sender);\n', '        bool approved2 = register2.approved(msg.sender);\n', '        return ready && started && !hasEnded && nonZeroPurchase && capNotReached && (approved || approved2);\n', '    }\n', '\n', '    /*\n', '     * Buy in function to be called from the fallback function\n', '     * @param beneficiary address\n', '     */\n', '    function buyTokens(address beneficiary) private {\n', '        require(beneficiary != 0x0);\n', '        require(validPurchase());\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // base discount\n', '        uint256 discount = ((toBeRaised*10000)/HARD_CAP)*15;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens;\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        toBeRaised = toBeRaised.sub(weiAmount);\n', '\n', '        uint commission;\n', '        uint extra;\n', '        uint premium;\n', '\n', '        if (register.approved(beneficiary)) {\n', '            (commission, extra) = register.getBonuses(beneficiary);\n', '\n', '            // If extra access granted then give additional %\n', '            if (extra > 0) {\n', '                discount += extra*10000;\n', '            }\n', '            tokens =  howMany(msg.value, discount);\n', '\n', '            // If referral was involved, give some percent to the source\n', '            if (commission > 0) {\n', '                premium = tokens.mul(commission).div(100);\n', '                token.mint(BOUNTY, premium);\n', '            }\n', '\n', '        } else {\n', '            extra = register2.getBonuses(beneficiary);\n', '            if (extra > 0) {\n', '                discount = extra*10000;\n', '                tokens =  howMany(msg.value, discount);\n', '            }\n', '        }\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '        tokensSold += tokens + premium;\n', '        forwardFunds();\n', '\n', '        assert(token.totalSupply() <= maxTokens);\n', '    }\n', '\n', '    /*\n', '     * Helper token emission functions\n', '     * @param value uint256 of the wei amount that gets invested\n', '     * @return uint256 of how many tokens can one get\n', '     */\n', '    function howMany(uint256 value, uint256 discount) public view returns (uint256){\n', '        uint256 actualPrice = PRICE * (1000000 - discount) / 1000000;\n', '        return value / actualPrice;\n', '    }\n', '\n', '    /*\n', '     * Function to do preallocations - MANDATORY to continue\n', '     * @dev It&#39;s separated so it doesn&#39;t have to run in constructor\n', '     */\n', '    function initialize() public onlyOwner {\n', '        require(!ready);\n', '\n', '        // Pre-allocation to pools\n', '        token.mint(ADVISORS,ADVISORY_SHARE);\n', '        token.mint(BOUNTY,BOUNTY_SHARE);\n', '        token.mint(COMMUNITY,COMMUNITY_SHARE);\n', '        token.mint(COMPANY,COMPANY_SHARE);\n', '        token.mint(PRESALE,PRESALE_SHARE);\n', '\n', '        tokensSold = PRESALE_SHARE;\n', '\n', '        ready = true;\n', '        SaleReady();\n', '    }\n', '\n', '    /*\n', '     * Function to do set or adjust the startTime - NOT MANDATORY but good for future start\n', '     */\n', '    function changeStart(uint256 _time) public onlyOwner {\n', '        startTime = _time;\n', '        SaleWillStart(_time);\n', '    }\n', '\n', '    /*\n', '     * Function end or pause the sale\n', '     * @dev It&#39;s MANDATORY to finalize()\n', '     */\n', '    function endSale(bool end) public onlyOwner {\n', '        require(startTime <= now);\n', '        uint256 tokensLeft = maxTokens - token.totalSupply();\n', '        if (tokensLeft > 0) {\n', '            token.mint(wallet, tokensLeft);\n', '        }\n', '        hasEnded = end;\n', '        SaleEnds(tokensLeft);\n', '    }\n', '\n', '    /*\n', '     * Adjust finalization to transfer token ownership to the fund holding address for further use\n', '     */\n', '    function finalization() internal {\n', '        token.finishMinting();\n', '        token.transferOwnership(wallet);\n', '    }\n', '\n', '    /*\n', '     * Clean up function to get the contract selfdestructed - OPTIONAL\n', '     */\n', '    function cleanUp() public onlyOwner {\n', '        require(isFinalized);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool);\n', '    function approve(address spender, uint256 value) returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' *\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', '\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '    bool public mintingFinished = false;\n', '\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Mint(_to, _amount);\n', '        Transfer(0x0, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() onlyOwner public returns (bool) {\n', '        mintingFinished = true;\n', '        MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '/*\n', ' * Company reserve pool where the tokens will be locked for two years\n', ' * @title Company token reserve\n', ' */\n', 'contract AdviserTimeLock is Ownable{\n', '\n', '    SignalsToken token;\n', '    uint256 withdrawn;\n', '    uint start;\n', '\n', '    event TokensWithdrawn(address owner, uint amount);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & setting time lock\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function AdviserTimeLock(address _token, address _owner) public{\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '        start = now;\n', '    }\n', '\n', '    /*\n', '     * Only function for periodical tokens withdrawal (with monthly allowance)\n', '     * @dev Will withdraw the whole allowance;\n', '     */\n', '    function withdraw() onlyOwner public {\n', '        require(now - start >= 25920000);\n', '        uint toWithdraw = canWithdraw();\n', '        token.transfer(owner, toWithdraw);\n', '        withdrawn += toWithdraw;\n', '        TokensWithdrawn(owner, toWithdraw);\n', '    }\n', '\n', '    /*\n', '     * Only function for the tokens withdrawal (with two years time lock)\n', '     * @dev Based on division down rounding\n', '     */\n', '    function canWithdraw() public view returns (uint256) {\n', '        uint256 sinceStart = now - start;\n', '        uint256 allowed = (sinceStart/2592000)*504546000000000;\n', '        uint256 toWithdraw;\n', '        if (allowed > token.balanceOf(address(this))) {\n', '            toWithdraw = token.balanceOf(address(this));\n', '        } else {\n', '            toWithdraw = allowed - withdrawn;\n', '        }\n', '        return toWithdraw;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Pre-allocation pool for company advisers\n', ' * @title Advisory pool\n', ' */\n', 'contract AdvisoryPool is Ownable{\n', '\n', '    SignalsToken token;\n', '\n', '    /*\n', '     * @dev constant addresses of all advisers\n', '     */\n', '    address constant ADVISER1 = 0x7915D5A865FE68C63112be5aD3DCA5187EB08f24;\n', '    address constant ADVISER2 = 0x31cFF39AA68B91fa7C957272A6aA8fB8F7b69Cb0;\n', '    address constant ADVISER3 = 0x358b3aeec9fae5ab15fe28d2fe6c7c9fda596857;\n', '    address constant ADVISER4 = 0x1011FC646261eb5d4aB875886f1470d4919d83c8;\n', '    address constant ADVISER5 = 0xcc04Cd98da89A9172372aEf4B62BEDecd01A7F5a;\n', '    address constant ADVISER6 = 0xECD791f8E548D46A9711D853Ead7edC685Ca4ee8;\n', '    address constant ADVISER7 = 0x38B58e5783fd4D077e422B3362E9d6B265484e3f;\n', '    address constant ADVISER8 = 0x2934205135A129F995AC891C143cCae83ce175c7;\n', '    address constant ADVISER9 = 0x9F5D00F4A383bAd14DEfA9aee53C5AF2ad9ad32F;\n', '    address constant ADVISER10 = 0xBE993c982Fc5a0C0360CEbcEf9e4d2727339d96B;\n', '    address constant ADVISER11 = 0xdf1E2126eB638335eFAb91a834db4c57Cbe18735;\n', '    address constant ADVISER12 = 0x8A404969Ad1BCD3F566A7796722f535eD9cA22b2;\n', '    address constant ADVISER13 = 0x066a8aD6fA94AC83e1AFB5Aa7Dc62eD1D2654bB2;\n', '    address constant ADVISER14 = 0xA1425Fa987d1b724306d93084b93D62F37482c4b;\n', '    address constant ADVISER15 = 0x4633515904eE5Bc18bEB70277455525e84a51e90;\n', '    address constant ADVISER16 = 0x230783Afd438313033b07D39E3B9bBDBC7817759;\n', '    address constant ADVISER17 = 0xe8b9b07c1cca9aE9739Cec3D53004523Ab206CAc;\n', '    address constant ADVISER18 = 0x0E73f16CfE7F545C0e4bB63A9Eef18De8d7B422d;\n', '    address constant ADVISER19 = 0x6B4c6B603ca72FE7dde971CF833a58415737826D;\n', '    address constant ADVISER20 = 0x823D3123254a3F9f9d3759FE3Fd7d15e21a3C5d8;\n', '    address constant ADVISER21 = 0x0E48bbc496Ae61bb790Fc400D1F1a57520f772Df;\n', '    address constant ADVISER22 = 0x06Ee8eCc0145CcaCEc829490e3c557f577BE0e85;\n', '    address constant ADVISER23 = 0xbE56bFF75A1cB085674Cc37a5C8746fF6C43C442;\n', '    address constant ADVISER24 = 0xb442b5297E4aEf19E489530E69dFef7fae27F4A5;\n', '    address constant ADVISER25 = 0x50EF1d6a7435C7FB3dB7c204b74EB719b1EE3dab;\n', '    address constant ADVISER26 = 0x3e9fed606822D5071f8a28d2c8B51E6964160CB2;\n', '\n', '    AdviserTimeLock public tokenLocker23;\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & calling the allocation\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function AdvisoryPool(address _token, address _owner) public {\n', '        owner = _owner;\n', '        token = SignalsToken(_token);\n', '    }\n', '\n', '    /*\n', '     * Allocation function, tokens get allocated from this contract as current token owner\n', '     * @dev only accessible from the constructor\n', '     */\n', '    function initiate() public onlyOwner {\n', '        require(token.balanceOf(address(this)) == 18500000000000000);\n', '        tokenLocker23 = new AdviserTimeLock(address(token), ADVISER23);\n', '\n', '        token.transfer(ADVISER1, 380952380000000);\n', '        token.transfer(ADVISER2, 380952380000000);\n', '        token.transfer(ADVISER3, 659200000000000);\n', '        token.transfer(ADVISER4, 95238100000000);\n', '        token.transfer(ADVISER5, 1850000000000000);\n', '        token.transfer(ADVISER6, 15384620000000);\n', '        token.transfer(ADVISER7, 62366450000000);\n', '        token.transfer(ADVISER8, 116805560000000);\n', '        token.transfer(ADVISER9, 153846150000000);\n', '        token.transfer(ADVISER10, 10683760000000);\n', '        token.transfer(ADVISER11, 114285710000000);\n', '        token.transfer(ADVISER12, 576923080000000);\n', '        token.transfer(ADVISER13, 76190480000000);\n', '        token.transfer(ADVISER14, 133547010000000);\n', '        token.transfer(ADVISER15, 96153850000000);\n', '        token.transfer(ADVISER16, 462500000000000);\n', '        token.transfer(ADVISER17, 462500000000000);\n', '        token.transfer(ADVISER18, 399865380000000);\n', '        token.transfer(ADVISER19, 20032050000000);\n', '        token.transfer(ADVISER20, 35559130000000);\n', '        token.transfer(ADVISER21, 113134000000000);\n', '        token.transfer(ADVISER22, 113134000000000);\n', '        token.transfer(address(tokenLocker23), 5550000000000000);\n', '        token.transfer(ADVISER23, 1850000000000000);\n', '        token.transfer(ADVISER24, 100000000000000);\n', '        token.transfer(ADVISER25, 100000000000000);\n', '        token.transfer(ADVISER26, 2747253000000000);\n', '\n', '    }\n', '\n', '    /*\n', '     * Clean up function for token loss prevention and cleaning up Ethereum blockchain\n', '     * @dev call to clean up the contract\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        uint256 notAllocated = token.balanceOf(address(this));\n', '        token.transfer(owner, notAllocated);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Pre-allocation pool for the community, will be govern by a company multisig\n', ' * @title Community pool\n', ' */\n', 'contract CommunityPool is Ownable{\n', '\n', '    SignalsToken token;\n', '\n', '    event CommunityTokensAllocated(address indexed member, uint amount);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function CommunityPool(address _token, address _owner) public{\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '    }\n', '\n', '    /*\n', '     * Function to alloc tokens to a community member\n', '     * @param address of community member\n', '     * @param uint amount units of tokens to be given away\n', '     */\n', '    function allocToMember(address member, uint amount) public onlyOwner {\n', '        require(amount > 0);\n', '        token.transfer(member, amount);\n', '        CommunityTokensAllocated(member, amount);\n', '    }\n', '\n', '    /*\n', '     * Clean up function\n', '     * @dev call to clean up the contract after all tokens were assigned\n', '     */\n', '    function clean() public onlyOwner {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/*\n', ' * Company reserve pool where the tokens will be locked for two years\n', ' * @title Company token reserve\n', ' */\n', 'contract CompanyReserve is Ownable{\n', '\n', '    SignalsToken token;\n', '    uint256 withdrawn;\n', '    uint start;\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig & setting time lock\n', '     * @param address of the Signals Token contract\n', '     * @param address of the owner multisig\n', '     */\n', '    function CompanyReserve(address _token, address _owner) public {\n', '        token = SignalsToken(_token);\n', '        owner = _owner;\n', '        start = now;\n', '    }\n', '\n', '    event TokensWithdrawn(address owner, uint amount);\n', '\n', '    /*\n', '     * Only function for the tokens withdrawal (3% anytime, 5% after one year, 10% after two year)\n', '     * @dev Will withdraw the whole allowance;\n', '     */\n', '    function withdraw() onlyOwner public {\n', '        require(now - start >= 25920000);\n', '        uint256 toWithdraw = canWithdraw();\n', '        withdrawn += toWithdraw;\n', '        token.transfer(owner, toWithdraw);\n', '        TokensWithdrawn(owner, toWithdraw);\n', '    }\n', '\n', '    /*\n', '     * Checker function to find out how many tokens can be withdrawn.\n', '     * note: percentage of the token.totalSupply\n', '     * @dev Based on division down rounding\n', '     */\n', '    function canWithdraw() public view returns (uint256) {\n', '        uint256 sinceStart = now - start;\n', '        uint256 allowed;\n', '\n', '        if (sinceStart >= 0) {\n', '            allowed = 555000000000000;\n', '        } else if (sinceStart >= 31536000) { // one year difference\n', '            allowed = 1480000000000000;\n', '        } else if (sinceStart >= 63072000) { // two years difference\n', '            allowed = 3330000000000000;\n', '        } else {\n', '            return 0;\n', '        }\n', '        return allowed - withdrawn;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function cleanUp() onlyOwner public {\n', '        require(token.balanceOf(address(this)) == 0);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Signals token\n', ' * @dev Mintable token created for Signals.Network\n', ' */\n', 'contract PresaleToken is PausableToken, MintableToken {\n', '\n', '    // Standard token variables\n', '    string constant public name = "SGNPresaleToken";\n', '    string constant public symbol = "SGN";\n', '    uint8 constant public decimals = 9;\n', '\n', '    event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens);\n', '\n', '    /*\n', '     * Constructor which pauses the token at the time of creation\n', '     */\n', '    function PresaleToken() public {\n', '        pause();\n', '    }\n', '    /*\n', '    * @dev Token burn function to be called at the time of token swap\n', '    * @param _partner address to use for token balance buring\n', '    * @param _tokens uint256 amount of tokens to burn\n', '    */\n', '    function burnTokens(address _partner, uint256 _tokens) public onlyOwner {\n', '        require(balances[_partner] >= _tokens);\n', '\n', '        balances[_partner] -= _tokens;\n', '        totalSupply -= _tokens;\n', '        TokensBurned(msg.sender, _partner, _tokens);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Signals token\n', ' * @dev Mintable token created for Signals.Network\n', ' */\n', 'contract SignalsToken is PausableToken, MintableToken {\n', '\n', '    // Standard token variables\n', '    string constant public name = "Signals Network Token";\n', '    string constant public symbol = "SGN";\n', '    uint8 constant public decimals = 9;\n', '\n', '}\n', '\n', 'contract PrivateRegister is Ownable {\n', '\n', '    struct contribution {\n', '        bool approved;\n', '        uint8 extra;\n', '    }\n', '\n', '    mapping (address => contribution) verified;\n', '\n', '    event ApprovedInvestor(address indexed investor);\n', '    event BonusesRegistered(address indexed investor, uint8 extra);\n', '\n', '    /*\n', '     * Approve function to adjust allowance to investment of each individual investor\n', '     * @param _investor address sets the beneficiary for later use\n', '     * @param _referral address to pay a commission in token to\n', '     * @param _commission uint8 expressed as a number between 0 and 5\n', '    */\n', '    function approve(address _investor, uint8 _extra) onlyOwner public{\n', '        require(!isContract(_investor));\n', '        verified[_investor].approved = true;\n', '        if (_extra <= 100) {\n', '            verified[_investor].extra = _extra;\n', '            BonusesRegistered(_investor, _extra);\n', '        }\n', '        ApprovedInvestor(_investor);\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out if an investor is registered\n', '     * @param _investor address to be checked\n', '     * @return bool is true is _investor was approved\n', '     */\n', '    function approved(address _investor) view public returns (bool) {\n', '        return verified[_investor].approved;\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out the referral and commission to bound to an investor\n', '     * @param _investor address to be checked\n', '     * @return address of the referral, returns 0x0 if there is none\n', '     * @return uint8 commission to be paid out on any investment\n', '     */\n', '    function getBonuses(address _investor) view public returns (uint8 extra) {\n', '        return verified[_investor].extra;\n', '    }\n', '\n', '    /*\n', '     * Check if address is a contract to prevent contracts from participating the direct sale.\n', '     * @param addr address to be checked\n', "     * @return boolean of it is or isn't an contract address\n", '     * @credits Manuel Aráoz\n', '     */\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', 'contract CrowdsaleRegister is Ownable {\n', '\n', '    struct contribution {\n', '        bool approved;\n', '        uint8 commission;\n', '        uint8 extra;\n', '    }\n', '\n', '    mapping (address => contribution) verified;\n', '\n', '    event ApprovedInvestor(address indexed investor);\n', '    event BonusesRegistered(address indexed investor, uint8 commission, uint8 extra);\n', '\n', '    /*\n', '     * Approve function to adjust allowance to investment of each individual investor\n', '     * @param _investor address sets the beneficiary for later use\n', '     * @param _referral address to pay a commission in token to\n', '     * @param _commission uint8 expressed as a number between 0 and 5\n', '    */\n', '    function approve(address _investor, uint8 _commission, uint8 _extra) onlyOwner public{\n', '        require(!isContract(_investor));\n', '        verified[_investor].approved = true;\n', '        if (_commission <= 15 && _extra <= 5) {\n', '            verified[_investor].commission = _commission;\n', '            verified[_investor].extra = _extra;\n', '            BonusesRegistered(_investor, _commission, _extra);\n', '        }\n', '        ApprovedInvestor(_investor);\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out if an investor is registered\n', '     * @param _investor address to be checked\n', '     * @return bool is true is _investor was approved\n', '     */\n', '    function approved(address _investor) view public returns (bool) {\n', '        return verified[_investor].approved;\n', '    }\n', '\n', '    /*\n', '     * Constant call to find out the referral and commission to bound to an investor\n', '     * @param _investor address to be checked\n', '     * @return address of the referral, returns 0x0 if there is none\n', '     * @return uint8 commission to be paid out on any investment\n', '     */\n', '    function getBonuses(address _investor) view public returns (uint8 commission, uint8 extra) {\n', '        return (verified[_investor].commission, verified[_investor].extra);\n', '    }\n', '\n', '    /*\n', '     * Check if address is a contract to prevent contracts from participating the direct sale.\n', '     * @param addr address to be checked\n', "     * @return boolean of it is or isn't an contract address\n", '     * @credits Manuel Aráoz\n', '     */\n', '    function isContract(address addr) public view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', '\n', '/*\n', ' *  Token pool for the presale tokens swap\n', ' *  @title PresalePool\n', ' *  @dev Requires to transfer ownership of both PresaleToken contracts to this contract\n', ' */\n', 'contract PresalePool is Ownable {\n', '\n', '    PresaleToken public PublicPresale;\n', '    PresaleToken public PartnerPresale;\n', '    SignalsToken token;\n', '    CrowdsaleRegister registry;\n', '\n', '    /*\n', '     * Compensation coefficient based on the difference between the max ETHUSD price during the presale\n', '     * and price fix for mainsale\n', '     */\n', '    uint256 compensation1;\n', '    uint256 compensation2;\n', '    // Date after which all tokens left will be transfered to the company reserve\n', '    uint256 deadLine;\n', '\n', '    event SupporterResolved(address indexed supporter, uint256 burned, uint256 created);\n', '    event PartnerResolved(address indexed partner, uint256 burned, uint256 created);\n', '\n', '    /*\n', '     * Constructor changing owner to owner multisig, setting all the contract addresses & compensation rates\n', '     * @param address of the Signals Token contract\n', '     * @param address of the KYC registry\n', '     * @param address of the owner multisig\n', '     * @param uint rate of the compensation for early investors\n', '     * @param uint rate of the compensation for partners\n', '     */\n', '    function PresalePool(address _token, address _registry, address _owner, uint comp1, uint comp2) public {\n', '        owner = _owner;\n', '        PublicPresale = PresaleToken(0x15fEcCA27add3D28C55ff5b01644ae46edF15821);\n', '        PartnerPresale = PresaleToken(0xa70435D1a3AD4149B0C13371E537a22002Ae530d);\n', '        token = SignalsToken(_token);\n', '        registry = CrowdsaleRegister(_registry);\n', '        compensation1 = comp1;\n', '        compensation2 = comp2;\n', '        deadLine = now + 30 days;\n', '    }\n', '\n', '    /*\n', '     * Fallback function for simple contract usage, only calls the swap()\n', '     * @dev left for simpler interaction\n', '     */\n', '    function() public {\n', '        swap();\n', '    }\n', '\n', '    /*\n', '     * Function swapping the presale tokens for the Signal tokens regardless on the presale pool\n', '     * @dev requires having ownership of the two presale contracts\n', '     * @dev requires the calling party to finish the KYC process fully\n', '     */\n', '    function swap() public {\n', '        require(registry.approved(msg.sender));\n', '        uint256 oldBalance;\n', '        uint256 newBalance;\n', '\n', '        if (PublicPresale.balanceOf(msg.sender) > 0) {\n', '            oldBalance = PublicPresale.balanceOf(msg.sender);\n', '            newBalance = oldBalance * compensation1 / 100;\n', '            PublicPresale.burnTokens(msg.sender, oldBalance);\n', '            token.transfer(msg.sender, newBalance);\n', '            SupporterResolved(msg.sender, oldBalance, newBalance);\n', '        }\n', '\n', '        if (PartnerPresale.balanceOf(msg.sender) > 0) {\n', '            oldBalance = PartnerPresale.balanceOf(msg.sender);\n', '            newBalance = oldBalance * compensation2 / 100;\n', '            PartnerPresale.burnTokens(msg.sender, oldBalance);\n', '            token.transfer(msg.sender, newBalance);\n', '            PartnerResolved(msg.sender, oldBalance, newBalance);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Function swapping the presale tokens for the Signal tokens regardless on the presale pool\n', '     * @dev initiated from Signals (passing the ownership to a oracle to handle a script is recommended)\n', '     * @dev requires having ownership of the two presale contracts\n', '     * @dev requires the calling party to finish the KYC process fully\n', '     */\n', '    function swapFor(address whom) onlyOwner public returns(bool) {\n', '        require(registry.approved(whom));\n', '        uint256 oldBalance;\n', '        uint256 newBalance;\n', '\n', '        if (PublicPresale.balanceOf(whom) > 0) {\n', '            oldBalance = PublicPresale.balanceOf(whom);\n', '            newBalance = oldBalance * compensation1 / 100;\n', '            PublicPresale.burnTokens(whom, oldBalance);\n', '            token.transfer(whom, newBalance);\n', '            SupporterResolved(whom, oldBalance, newBalance);\n', '        }\n', '\n', '        if (PartnerPresale.balanceOf(whom) > 0) {\n', '            oldBalance = PartnerPresale.balanceOf(whom);\n', '            newBalance = oldBalance * compensation2 / 100;\n', '            PartnerPresale.burnTokens(whom, oldBalance);\n', '            token.transfer(whom, newBalance);\n', '            SupporterResolved(whom, oldBalance, newBalance);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Function to clean up the state and moved not allocated tokens to custody\n', '     */\n', '    function clean() onlyOwner public {\n', '        require(now >= deadLine);\n', '        uint256 notAllocated = token.balanceOf(address(this));\n', '        token.transfer(owner, notAllocated);\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale.\n', ' * Crowdsales have a start and end timestamps, where investors can make\n', ' * token purchases and the crowdsale will assign them tokens based\n', ' * on a token per ETH rate. Funds collected are forwarded to a wallet\n', ' * as they arrive.\n', ' */\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    SignalsToken public token;\n', '\n', '    // address where funds are collected\n', '    address public wallet;\n', '\n', '    // amount of raised money in wei\n', '    uint256 public weiRaised;\n', '\n', '    // start/end related \n', '    uint256 public startTime;\n', '    bool public hasEnded;\n', '\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    function Crowdsale(address _token, address _wallet) public {\n', '        require(_wallet != 0x0);\n', '        token = SignalsToken(_token);\n', '        wallet = _wallet;\n', '    }\n', '\n', '    // fallback function can be used to buy tokens\n', '    function () public payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // low level token purchase function\n', '    function buyTokens(address beneficiary) private {}\n', '\n', '    // send ether to the fund collection wallet\n', '    // override to create custom fund forwarding mechanisms\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal constant returns (bool) {}\n', '\n', '}\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '    /**\n', '     * @dev Must be called after crowdsale ends, to do some extra finalization\n', "     * work. Calls the contract's finalization function.\n", '     */\n', '    function finalize() onlyOwner public {\n', '        require(!isFinalized);\n', '        require(hasEnded);\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Can be overridden to add finalization logic. The overriding function\n', '     * should call super.finalization() to ensure the chain of finalization is\n', '     * executed entirely.\n', '     */\n', '    function finalization() internal {\n', '    }\n', '}\n', '\n', '\n', 'contract SignalsCrowdsale is FinalizableCrowdsale {\n', '\n', '    // Cap & price related values\n', '    uint256 public constant HARD_CAP = 18000*(10**18);\n', '    uint256 public toBeRaised = 18000*(10**18);\n', '    uint256 public constant PRICE = 360000;\n', '    uint256 public tokensSold;\n', '    uint256 public constant maxTokens = 185000000*(10**9);\n', '\n', '    // Allocation constants\n', '    uint constant ADVISORY_SHARE = 18500000*(10**9); //FIXED\n', '    uint constant BOUNTY_SHARE = 3700000*(10**9); // FIXED\n', '    uint constant COMMUNITY_SHARE = 37000000*(10**9); //FIXED\n', '    uint constant COMPANY_SHARE = 33300000*(10**9); //FIXED\n', '    uint constant PRESALE_SHARE = 7856217611546440; // FIXED;\n', '\n', '    // Address pointers\n', '    address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; // TODO: change\n', '    address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; // TODO: change\n', '    address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; // TODO: change\n', '    address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; // TODO: change\n', '    address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; // TODO: change\n', '    CrowdsaleRegister register;\n', '    PrivateRegister register2;\n', '\n', '    // Start & End related vars\n', '    bool public ready;\n', '\n', '    // Events\n', '    event SaleWillStart(uint256 time);\n', '    event SaleReady();\n', '    event SaleEnds(uint256 tokensLeft);\n', '\n', '    function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public\n', '    FinalizableCrowdsale()\n', '    Crowdsale(_token, _wallet)\n', '    {\n', '        register = CrowdsaleRegister(_register);\n', '        register2 = PrivateRegister(_register2);\n', '    }\n', '\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal constant returns (bool) {\n', '        bool started = (startTime <= now);\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        bool capNotReached = (weiRaised < HARD_CAP);\n', '        bool approved = register.approved(msg.sender);\n', '        bool approved2 = register2.approved(msg.sender);\n', '        return ready && started && !hasEnded && nonZeroPurchase && capNotReached && (approved || approved2);\n', '    }\n', '\n', '    /*\n', '     * Buy in function to be called from the fallback function\n', '     * @param beneficiary address\n', '     */\n', '    function buyTokens(address beneficiary) private {\n', '        require(beneficiary != 0x0);\n', '        require(validPurchase());\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // base discount\n', '        uint256 discount = ((toBeRaised*10000)/HARD_CAP)*15;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens;\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        toBeRaised = toBeRaised.sub(weiAmount);\n', '\n', '        uint commission;\n', '        uint extra;\n', '        uint premium;\n', '\n', '        if (register.approved(beneficiary)) {\n', '            (commission, extra) = register.getBonuses(beneficiary);\n', '\n', '            // If extra access granted then give additional %\n', '            if (extra > 0) {\n', '                discount += extra*10000;\n', '            }\n', '            tokens =  howMany(msg.value, discount);\n', '\n', '            // If referral was involved, give some percent to the source\n', '            if (commission > 0) {\n', '                premium = tokens.mul(commission).div(100);\n', '                token.mint(BOUNTY, premium);\n', '            }\n', '\n', '        } else {\n', '            extra = register2.getBonuses(beneficiary);\n', '            if (extra > 0) {\n', '                discount = extra*10000;\n', '                tokens =  howMany(msg.value, discount);\n', '            }\n', '        }\n', '\n', '        token.mint(beneficiary, tokens);\n', '        TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '        tokensSold += tokens + premium;\n', '        forwardFunds();\n', '\n', '        assert(token.totalSupply() <= maxTokens);\n', '    }\n', '\n', '    /*\n', '     * Helper token emission functions\n', '     * @param value uint256 of the wei amount that gets invested\n', '     * @return uint256 of how many tokens can one get\n', '     */\n', '    function howMany(uint256 value, uint256 discount) public view returns (uint256){\n', '        uint256 actualPrice = PRICE * (1000000 - discount) / 1000000;\n', '        return value / actualPrice;\n', '    }\n', '\n', '    /*\n', '     * Function to do preallocations - MANDATORY to continue\n', "     * @dev It's separated so it doesn't have to run in constructor\n", '     */\n', '    function initialize() public onlyOwner {\n', '        require(!ready);\n', '\n', '        // Pre-allocation to pools\n', '        token.mint(ADVISORS,ADVISORY_SHARE);\n', '        token.mint(BOUNTY,BOUNTY_SHARE);\n', '        token.mint(COMMUNITY,COMMUNITY_SHARE);\n', '        token.mint(COMPANY,COMPANY_SHARE);\n', '        token.mint(PRESALE,PRESALE_SHARE);\n', '\n', '        tokensSold = PRESALE_SHARE;\n', '\n', '        ready = true;\n', '        SaleReady();\n', '    }\n', '\n', '    /*\n', '     * Function to do set or adjust the startTime - NOT MANDATORY but good for future start\n', '     */\n', '    function changeStart(uint256 _time) public onlyOwner {\n', '        startTime = _time;\n', '        SaleWillStart(_time);\n', '    }\n', '\n', '    /*\n', '     * Function end or pause the sale\n', "     * @dev It's MANDATORY to finalize()\n", '     */\n', '    function endSale(bool end) public onlyOwner {\n', '        require(startTime <= now);\n', '        uint256 tokensLeft = maxTokens - token.totalSupply();\n', '        if (tokensLeft > 0) {\n', '            token.mint(wallet, tokensLeft);\n', '        }\n', '        hasEnded = end;\n', '        SaleEnds(tokensLeft);\n', '    }\n', '\n', '    /*\n', '     * Adjust finalization to transfer token ownership to the fund holding address for further use\n', '     */\n', '    function finalization() internal {\n', '        token.finishMinting();\n', '        token.transferOwnership(wallet);\n', '    }\n', '\n', '    /*\n', '     * Clean up function to get the contract selfdestructed - OPTIONAL\n', '     */\n', '    function cleanUp() public onlyOwner {\n', '        require(isFinalized);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
