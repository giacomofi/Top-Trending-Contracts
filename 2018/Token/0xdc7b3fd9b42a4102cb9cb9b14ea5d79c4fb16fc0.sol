['pragma solidity 0.4.15;\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transfer(address _recipient, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '\tuint256 public totalSupply;\n', '\tmapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    modifier when_can_transfer(address _from, uint256 _value) {\n', '        if (balances[_from] >= _value) _;\n', '    }\n', '\n', '    modifier when_can_receive(address _recipient, uint256 _value) {\n', '        if (balances[_recipient] + _value > balances[_recipient]) _;\n', '    }\n', '\n', '    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\n', '        if (allowed[_from][_delegate] >= _value) _;\n', '    }\n', '\n', '    function transfer(address _recipient, uint256 _value)\n', '        when_can_transfer(msg.sender, _value)\n', '        when_can_receive(_recipient, _value)\n', '        returns (bool o_success)\n', '    {\n', '        balances[msg.sender] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(msg.sender, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _recipient, uint256 _value)\n', '        when_can_transfer(_from, _value)\n', '        when_can_receive(_recipient, _value)\n', '        when_is_allowed(_from, msg.sender, _value)\n', '        returns (bool o_success)\n', '    {\n', '        allowed[_from][msg.sender] -= _value;\n', '        balances[_from] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(_from, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool o_success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract LBToken is StandardToken {\n', '\n', '\tstring public name = "LB Coin";\n', '    string public symbol = "LB";\n', '    uint public decimals = 18;\n', '\n', '\tfunction LBToken (address _bank, uint _totalSupply) {\n', '\t\tbalances[_bank] += _totalSupply;\n', '\t\ttotalSupply += _totalSupply;\n', '\t}\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '\tfunction transfer(address _recipient, uint _amount)\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transfer(_recipient, _amount);\n', '\t}\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '\tfunction transferFrom(address _from, address _recipient, uint _amount)\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transferFrom(_from, _recipient, _amount);\n', '\t}\n', '}']
['pragma solidity 0.4.15;\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transfer(address _recipient, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '\tuint256 public totalSupply;\n', '\tmapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    modifier when_can_transfer(address _from, uint256 _value) {\n', '        if (balances[_from] >= _value) _;\n', '    }\n', '\n', '    modifier when_can_receive(address _recipient, uint256 _value) {\n', '        if (balances[_recipient] + _value > balances[_recipient]) _;\n', '    }\n', '\n', '    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\n', '        if (allowed[_from][_delegate] >= _value) _;\n', '    }\n', '\n', '    function transfer(address _recipient, uint256 _value)\n', '        when_can_transfer(msg.sender, _value)\n', '        when_can_receive(_recipient, _value)\n', '        returns (bool o_success)\n', '    {\n', '        balances[msg.sender] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(msg.sender, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _recipient, uint256 _value)\n', '        when_can_transfer(_from, _value)\n', '        when_can_receive(_recipient, _value)\n', '        when_is_allowed(_from, msg.sender, _value)\n', '        returns (bool o_success)\n', '    {\n', '        allowed[_from][msg.sender] -= _value;\n', '        balances[_from] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(_from, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool o_success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract LBToken is StandardToken {\n', '\n', '\tstring public name = "LB Coin";\n', '    string public symbol = "LB";\n', '    uint public decimals = 18;\n', '\n', '\tfunction LBToken (address _bank, uint _totalSupply) {\n', '\t\tbalances[_bank] += _totalSupply;\n', '\t\ttotalSupply += _totalSupply;\n', '\t}\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '\tfunction transfer(address _recipient, uint _amount)\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transfer(_recipient, _amount);\n', '\t}\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '\tfunction transferFrom(address _from, address _recipient, uint _amount)\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transferFrom(_from, _recipient, _amount);\n', '\t}\n', '}']
