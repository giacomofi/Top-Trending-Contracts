['pragma solidity ^0.4.25;\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'contract ZygStop is Owned {\n', '\n', '    bool public stopped = false;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public onlyOwner {\n', '        stopped = true;\n', '    }\n', '    function start() public onlyOwner {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', '\n', 'contract Utils {\n', '    function Utils() internal {\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract BuyZygoma is Owned, ZygStop, Utils {\n', '    using SafeMath for uint;\n', '    ERC20Interface public zygomaAddress;\n', '\n', '    function BuyZygoma(ERC20Interface _zygomaAddress) public{\n', '        zygomaAddress = _zygomaAddress;\n', '    }\n', '        \n', '    function withdrawTo(address to, uint amount)\n', '        public onlyOwner\n', '        notThis(to)\n', '    {   \n', '        require(amount <= this.balance);\n', '        to.transfer(amount);\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(ERC20Interface token, address to, uint amount)\n', '        public onlyOwner\n', '        validAddress(token)\n', '        validAddress(to)\n', '        notThis(to)\n', '    {\n', '        assert(token.transfer(to, amount));\n', '\n', '    }\n', '    \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && msg.value >= 0.001 ether);\n', '        uint amount = msg.value * 350000;\n', '        assert(zygomaAddress.transfer(msg.sender, amount));\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'contract ZygStop is Owned {\n', '\n', '    bool public stopped = false;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public onlyOwner {\n', '        stopped = true;\n', '    }\n', '    function start() public onlyOwner {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', '\n', 'contract Utils {\n', '    function Utils() internal {\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract BuyZygoma is Owned, ZygStop, Utils {\n', '    using SafeMath for uint;\n', '    ERC20Interface public zygomaAddress;\n', '\n', '    function BuyZygoma(ERC20Interface _zygomaAddress) public{\n', '        zygomaAddress = _zygomaAddress;\n', '    }\n', '        \n', '    function withdrawTo(address to, uint amount)\n', '        public onlyOwner\n', '        notThis(to)\n', '    {   \n', '        require(amount <= this.balance);\n', '        to.transfer(amount);\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(ERC20Interface token, address to, uint amount)\n', '        public onlyOwner\n', '        validAddress(token)\n', '        validAddress(to)\n', '        notThis(to)\n', '    {\n', '        assert(token.transfer(to, amount));\n', '\n', '    }\n', '    \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && msg.value >= 0.001 ether);\n', '        uint amount = msg.value * 350000;\n', '        assert(zygomaAddress.transfer(msg.sender, amount));\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
