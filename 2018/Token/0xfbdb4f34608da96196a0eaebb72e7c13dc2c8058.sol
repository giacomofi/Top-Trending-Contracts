['pragma solidity ^0.4.16;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', ' \n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', ' \n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', ' \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract owned {\n', '    address public owner;\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract ERNToken is owned {\n', '    using SafeMath for uint256;\n', '    string public constant name = "ERNToken";\n', '    string public constant symbol = "ERN";\n', '    uint public constant decimals = 8;\n', '    uint constant ONETOKEN = 10 ** uint256(decimals);\n', '    uint constant MILLION = 1000000; \n', '    uint public constant Total_TokenSupply = 1000 * MILLION * ONETOKEN; //1B Final Token Supply\n', '    uint public totalSupply;\n', '    uint public Dev_Supply;\n', '    uint public GrowthPool_Supply;\n', '    uint public Rewards_Supply;                                //to be added 45% Rewards \n', '    bool public DevSupply_Released = false;                     //Locked 3% Dev Supply\n', '    bool public GrowthPool_Released = false;                    //Locked 2% Growth Pool Supply\n', '    bool public ICO_Finished = false;                           //ICO Status\n', '    uint public ICO_Tier = 0;                                   //ICO Tier (1,2,3,4)\n', '    uint public ICO_Supply = 0;                                 //ICO Supply will change per Tier\n', '    uint public ICO_TokenValue = 0;                             //Token Value will change per ICO Tier\n', '    bool public ICO_AllowPayment;                               //Control Ether Payment when ICO is On\n', '    bool public Token_AllowTransfer = false;                    //Locked Token Holder for transferring ERN\n', '    uint public Collected_Ether;\n', '    uint public Total_SoldToken;\n', '    uint public Total_ICOSupply;\n', '    address public etherWallet = 0x90C5Daf1Ca815aF29b3a79f72565D02bdB706126;\n', '    \n', '    constructor() public {\n', '        totalSupply = 1000 * MILLION * ONETOKEN;                        //1 Billion Total Supply\n', '        Dev_Supply = totalSupply.mul(3).div(100);                       //3% of Supply -> locked until 01/01/2020\n', '        GrowthPool_Supply = totalSupply.mul(2).div(100);                //2% of Supply -> locked until 01/01/2019\n', '        Rewards_Supply = totalSupply.mul(45).div(100);                  //45% of Supply -> use for rewards, bounty, mining, etc\n', '        totalSupply -= Dev_Supply + GrowthPool_Supply + Rewards_Supply; //50% less for initial token supply \n', '        Total_ICOSupply = totalSupply;                                  //500M ICO supply\n', '        balanceOf[msg.sender] = totalSupply;                            \n', '    }\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => bool) public whitelist;\n', '    mapping (address => uint256) public PrivateSale_Cap;\n', '    mapping (address => uint256) public PreIco_Cap;\n', '    mapping (address => uint256) public MainIco_Cap;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Whitelisted(address indexed target, bool whitelist);\n', '    event IcoFinished(bool finish);\n', '    \n', '    modifier notLocked{\n', '        require(Token_AllowTransfer == true || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier buyingToken{\n', '        require(ICO_AllowPayment == true);\n', '        require(msg.sender != owner);\n', '        \n', '        if(ICO_Tier == 1)\n', '        {\n', '            require(whitelist[msg.sender]);\n', '        }\n', '        if(ICO_Tier == 2)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(PrivateSale_Cap[msg.sender] + msg.value <= 5 ether); //private sale -> 5 Eth Limit\n', '        }\n', '        if(ICO_Tier == 3)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(PreIco_Cap[msg.sender] + msg.value <= 15 ether);    //pre-ico -> 15 Eth Limit\n', '        }\n', '        if(ICO_Tier == 4)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(MainIco_Cap[msg.sender] + msg.value <= 15 ether);   //main-ico -> 15 Eth Limit\n', '        }\n', '        _;\n', '    }\n', '    function unlockDevTokenSupply() onlyOwner public {\n', '        require(now > 1577836800);                              //can be unlocked only on 1/1/2020\n', '        require(DevSupply_Released == false);       \n', '        balanceOf[owner] += Dev_Supply;\n', '        totalSupply += Dev_Supply;          \n', '        emit Transfer(0, this, Dev_Supply);\n', '        emit Transfer(this, owner, Dev_Supply);\n', '        Dev_Supply = 0;                                         //clear dev supply -> 0\n', '        DevSupply_Released = true;                              //to avoid next execution\n', '    }\n', '    function unlockGrowthPoolTokenSupply() onlyOwner public {\n', '        require(now > 1546300800);                              //can be unlocked only on 1/1/2019\n', '        require(GrowthPool_Released == false);      \n', '        balanceOf[owner] += GrowthPool_Supply;\n', '        totalSupply += GrowthPool_Supply;\n', '        emit Transfer(0, this, GrowthPool_Supply);\n', '        emit Transfer(this, owner, GrowthPool_Supply);\n', '        GrowthPool_Supply = 0;                                  //clear growthpool supply -> 0\n', '        GrowthPool_Released = true;                             //to avoid next execution\n', '    }\n', '    function sendUnsoldTokenToRewardSupply() onlyOwner public {\n', '        require(ICO_Finished == true);    \n', '        uint totalUnsold = Total_ICOSupply - Total_SoldToken;   //get total unsold token on ICO\n', '        Rewards_Supply += totalUnsold;                          //add to rewards / mineable supply\n', '        Total_SoldToken += totalUnsold;\n', '    }\n', '    function giveReward(address target, uint256 reward) onlyOwner public {\n', '        require(Rewards_Supply >= reward);\n', '        balanceOf[target] += reward;\n', '        totalSupply += reward;\n', '        emit Transfer(0, this, reward);\n', '        emit Transfer(this, target, reward);\n', '        Rewards_Supply -= reward;\n', '    }\n', '    function _transferToken(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transfer(address _to, uint256 _value) notLocked public {\n', '        _transferToken(msg.sender, _to, _value);\n', '    }\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] -= _value;            \n', '        totalSupply -= _value;                 \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               \n', '        require (balanceOf[_from] >= _value); \n', '        require (balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '    function() payable buyingToken public {\n', '        uint totalToken = (msg.value.mul(ICO_TokenValue)).div(10 ** 18);\n', '        totalToken = totalToken.mul(ONETOKEN);\n', '        require(ICO_Supply >= totalToken);\n', '        if(ICO_Tier == 2)\n', '        {\n', '            PrivateSale_Cap[msg.sender] += msg.value;\n', '        }\n', '        if(ICO_Tier == 3)\n', '        {\n', '            PreIco_Cap[msg.sender] += msg.value;\n', '        }\n', '        if(ICO_Tier == 4)\n', '        {\n', '            MainIco_Cap[msg.sender] += msg.value;\n', '        }\n', '        ICO_Supply -= totalToken;\n', '        _transfer(owner, msg.sender, totalToken);\n', '        uint256 sendBonus = icoReturnBonus(msg.value);\n', '        if(sendBonus != 0)\n', '        {\n', '            msg.sender.transfer(sendBonus);\n', '        }\n', '        etherWallet.transfer(this.balance);\n', '        Collected_Ether += msg.value - sendBonus;               //divide 18 decimals\n', '        Total_SoldToken += totalToken;                          //divide 8 decimals\n', '    }\n', '    function icoReturnBonus(uint256 amount) internal constant returns (uint256) {\n', '        uint256 bonus = 0;\n', '        if(ICO_Tier == 1)\n', '        {\n', '            bonus = amount.mul(15).div(100);\n', '        }\n', '        if(ICO_Tier == 2)\n', '        {\n', '            bonus = amount.mul(12).div(100);\n', '        }\n', '        if(ICO_Tier == 3)\n', '        {\n', '            bonus = amount.mul(10).div(100);\n', '        }\n', '        if(ICO_Tier == 4)\n', '        {\n', '            bonus = amount.mul(8).div(100);\n', '        }\n', '        return bonus;\n', '    }\n', '    function withdrawEther() onlyOwner public{\n', '        owner.transfer(this.balance);\n', '    }\n', '    function setIcoTier(uint256 newTokenValue) onlyOwner public {\n', '        require(ICO_Finished == false && ICO_Tier < 4);\n', '        ICO_Tier += 1;\n', '        ICO_AllowPayment = true;\n', '        ICO_TokenValue = newTokenValue;\n', '        if(ICO_Tier == 1){\n', '            ICO_Supply = 62500000 * ONETOKEN;               //62.5M supply -> x private sale \n', '        }\n', '        if(ICO_Tier == 2){\n', '            ICO_Supply = 100 * MILLION * ONETOKEN;          //100M supply -> private sale\n', '        }\n', '        if(ICO_Tier == 3){\n', '            ICO_Supply = 150 * MILLION * ONETOKEN;          //150M supply -> pre-ico\n', '        }\n', '        if(ICO_Tier == 4){\n', '            ICO_Supply = 187500000 * ONETOKEN;              //187.5M supply -> main-ico\n', '        }\n', '    }\n', '    function FinishIco() onlyOwner public {\n', '        require(ICO_Tier >= 4);\n', '        ICO_Supply = 0;\n', '        ICO_Tier = 0;\n', '        ICO_TokenValue = 0;\n', '        ICO_Finished = true;\n', '        ICO_AllowPayment = false;\n', '        emit IcoFinished(true);\n', '    }\n', '    function setWhitelistAddress(address addr, bool status) onlyOwner public {\n', '        whitelist[addr] = status;\n', '        emit Whitelisted(addr, status);\n', '    }\n', '    function setIcoPaymentStatus(bool status) onlyOwner public {\n', '        require(ICO_Finished == false);\n', '        ICO_AllowPayment = status;\n', '    }\n', '    function setTokenTransferStatus(bool status) onlyOwner public {\n', '        require(ICO_Finished == true);\n', '        Token_AllowTransfer = status;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', ' \n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', ' \n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', ' \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract owned {\n', '    address public owner;\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract ERNToken is owned {\n', '    using SafeMath for uint256;\n', '    string public constant name = "ERNToken";\n', '    string public constant symbol = "ERN";\n', '    uint public constant decimals = 8;\n', '    uint constant ONETOKEN = 10 ** uint256(decimals);\n', '    uint constant MILLION = 1000000; \n', '    uint public constant Total_TokenSupply = 1000 * MILLION * ONETOKEN; //1B Final Token Supply\n', '    uint public totalSupply;\n', '    uint public Dev_Supply;\n', '    uint public GrowthPool_Supply;\n', '    uint public Rewards_Supply;                                //to be added 45% Rewards \n', '    bool public DevSupply_Released = false;                     //Locked 3% Dev Supply\n', '    bool public GrowthPool_Released = false;                    //Locked 2% Growth Pool Supply\n', '    bool public ICO_Finished = false;                           //ICO Status\n', '    uint public ICO_Tier = 0;                                   //ICO Tier (1,2,3,4)\n', '    uint public ICO_Supply = 0;                                 //ICO Supply will change per Tier\n', '    uint public ICO_TokenValue = 0;                             //Token Value will change per ICO Tier\n', '    bool public ICO_AllowPayment;                               //Control Ether Payment when ICO is On\n', '    bool public Token_AllowTransfer = false;                    //Locked Token Holder for transferring ERN\n', '    uint public Collected_Ether;\n', '    uint public Total_SoldToken;\n', '    uint public Total_ICOSupply;\n', '    address public etherWallet = 0x90C5Daf1Ca815aF29b3a79f72565D02bdB706126;\n', '    \n', '    constructor() public {\n', '        totalSupply = 1000 * MILLION * ONETOKEN;                        //1 Billion Total Supply\n', '        Dev_Supply = totalSupply.mul(3).div(100);                       //3% of Supply -> locked until 01/01/2020\n', '        GrowthPool_Supply = totalSupply.mul(2).div(100);                //2% of Supply -> locked until 01/01/2019\n', '        Rewards_Supply = totalSupply.mul(45).div(100);                  //45% of Supply -> use for rewards, bounty, mining, etc\n', '        totalSupply -= Dev_Supply + GrowthPool_Supply + Rewards_Supply; //50% less for initial token supply \n', '        Total_ICOSupply = totalSupply;                                  //500M ICO supply\n', '        balanceOf[msg.sender] = totalSupply;                            \n', '    }\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => bool) public whitelist;\n', '    mapping (address => uint256) public PrivateSale_Cap;\n', '    mapping (address => uint256) public PreIco_Cap;\n', '    mapping (address => uint256) public MainIco_Cap;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Whitelisted(address indexed target, bool whitelist);\n', '    event IcoFinished(bool finish);\n', '    \n', '    modifier notLocked{\n', '        require(Token_AllowTransfer == true || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier buyingToken{\n', '        require(ICO_AllowPayment == true);\n', '        require(msg.sender != owner);\n', '        \n', '        if(ICO_Tier == 1)\n', '        {\n', '            require(whitelist[msg.sender]);\n', '        }\n', '        if(ICO_Tier == 2)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(PrivateSale_Cap[msg.sender] + msg.value <= 5 ether); //private sale -> 5 Eth Limit\n', '        }\n', '        if(ICO_Tier == 3)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(PreIco_Cap[msg.sender] + msg.value <= 15 ether);    //pre-ico -> 15 Eth Limit\n', '        }\n', '        if(ICO_Tier == 4)                                       \n', '        {\n', '            require(whitelist[msg.sender]);\n', '            require(MainIco_Cap[msg.sender] + msg.value <= 15 ether);   //main-ico -> 15 Eth Limit\n', '        }\n', '        _;\n', '    }\n', '    function unlockDevTokenSupply() onlyOwner public {\n', '        require(now > 1577836800);                              //can be unlocked only on 1/1/2020\n', '        require(DevSupply_Released == false);       \n', '        balanceOf[owner] += Dev_Supply;\n', '        totalSupply += Dev_Supply;          \n', '        emit Transfer(0, this, Dev_Supply);\n', '        emit Transfer(this, owner, Dev_Supply);\n', '        Dev_Supply = 0;                                         //clear dev supply -> 0\n', '        DevSupply_Released = true;                              //to avoid next execution\n', '    }\n', '    function unlockGrowthPoolTokenSupply() onlyOwner public {\n', '        require(now > 1546300800);                              //can be unlocked only on 1/1/2019\n', '        require(GrowthPool_Released == false);      \n', '        balanceOf[owner] += GrowthPool_Supply;\n', '        totalSupply += GrowthPool_Supply;\n', '        emit Transfer(0, this, GrowthPool_Supply);\n', '        emit Transfer(this, owner, GrowthPool_Supply);\n', '        GrowthPool_Supply = 0;                                  //clear growthpool supply -> 0\n', '        GrowthPool_Released = true;                             //to avoid next execution\n', '    }\n', '    function sendUnsoldTokenToRewardSupply() onlyOwner public {\n', '        require(ICO_Finished == true);    \n', '        uint totalUnsold = Total_ICOSupply - Total_SoldToken;   //get total unsold token on ICO\n', '        Rewards_Supply += totalUnsold;                          //add to rewards / mineable supply\n', '        Total_SoldToken += totalUnsold;\n', '    }\n', '    function giveReward(address target, uint256 reward) onlyOwner public {\n', '        require(Rewards_Supply >= reward);\n', '        balanceOf[target] += reward;\n', '        totalSupply += reward;\n', '        emit Transfer(0, this, reward);\n', '        emit Transfer(this, target, reward);\n', '        Rewards_Supply -= reward;\n', '    }\n', '    function _transferToken(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transfer(address _to, uint256 _value) notLocked public {\n', '        _transferToken(msg.sender, _to, _value);\n', '    }\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] -= _value;            \n', '        totalSupply -= _value;                 \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               \n', '        require (balanceOf[_from] >= _value); \n', '        require (balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '    function() payable buyingToken public {\n', '        uint totalToken = (msg.value.mul(ICO_TokenValue)).div(10 ** 18);\n', '        totalToken = totalToken.mul(ONETOKEN);\n', '        require(ICO_Supply >= totalToken);\n', '        if(ICO_Tier == 2)\n', '        {\n', '            PrivateSale_Cap[msg.sender] += msg.value;\n', '        }\n', '        if(ICO_Tier == 3)\n', '        {\n', '            PreIco_Cap[msg.sender] += msg.value;\n', '        }\n', '        if(ICO_Tier == 4)\n', '        {\n', '            MainIco_Cap[msg.sender] += msg.value;\n', '        }\n', '        ICO_Supply -= totalToken;\n', '        _transfer(owner, msg.sender, totalToken);\n', '        uint256 sendBonus = icoReturnBonus(msg.value);\n', '        if(sendBonus != 0)\n', '        {\n', '            msg.sender.transfer(sendBonus);\n', '        }\n', '        etherWallet.transfer(this.balance);\n', '        Collected_Ether += msg.value - sendBonus;               //divide 18 decimals\n', '        Total_SoldToken += totalToken;                          //divide 8 decimals\n', '    }\n', '    function icoReturnBonus(uint256 amount) internal constant returns (uint256) {\n', '        uint256 bonus = 0;\n', '        if(ICO_Tier == 1)\n', '        {\n', '            bonus = amount.mul(15).div(100);\n', '        }\n', '        if(ICO_Tier == 2)\n', '        {\n', '            bonus = amount.mul(12).div(100);\n', '        }\n', '        if(ICO_Tier == 3)\n', '        {\n', '            bonus = amount.mul(10).div(100);\n', '        }\n', '        if(ICO_Tier == 4)\n', '        {\n', '            bonus = amount.mul(8).div(100);\n', '        }\n', '        return bonus;\n', '    }\n', '    function withdrawEther() onlyOwner public{\n', '        owner.transfer(this.balance);\n', '    }\n', '    function setIcoTier(uint256 newTokenValue) onlyOwner public {\n', '        require(ICO_Finished == false && ICO_Tier < 4);\n', '        ICO_Tier += 1;\n', '        ICO_AllowPayment = true;\n', '        ICO_TokenValue = newTokenValue;\n', '        if(ICO_Tier == 1){\n', '            ICO_Supply = 62500000 * ONETOKEN;               //62.5M supply -> x private sale \n', '        }\n', '        if(ICO_Tier == 2){\n', '            ICO_Supply = 100 * MILLION * ONETOKEN;          //100M supply -> private sale\n', '        }\n', '        if(ICO_Tier == 3){\n', '            ICO_Supply = 150 * MILLION * ONETOKEN;          //150M supply -> pre-ico\n', '        }\n', '        if(ICO_Tier == 4){\n', '            ICO_Supply = 187500000 * ONETOKEN;              //187.5M supply -> main-ico\n', '        }\n', '    }\n', '    function FinishIco() onlyOwner public {\n', '        require(ICO_Tier >= 4);\n', '        ICO_Supply = 0;\n', '        ICO_Tier = 0;\n', '        ICO_TokenValue = 0;\n', '        ICO_Finished = true;\n', '        ICO_AllowPayment = false;\n', '        emit IcoFinished(true);\n', '    }\n', '    function setWhitelistAddress(address addr, bool status) onlyOwner public {\n', '        whitelist[addr] = status;\n', '        emit Whitelisted(addr, status);\n', '    }\n', '    function setIcoPaymentStatus(bool status) onlyOwner public {\n', '        require(ICO_Finished == false);\n', '        ICO_AllowPayment = status;\n', '    }\n', '    function setTokenTransferStatus(bool status) onlyOwner public {\n', '        require(ICO_Finished == true);\n', '        Token_AllowTransfer = status;\n', '    }\n', '    \n', '}']
