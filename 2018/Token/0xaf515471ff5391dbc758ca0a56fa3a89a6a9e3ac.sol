['pragma solidity ^0.4.18;\n', '\n', 'contract BinksBucks  {\n', '    // Token Vars\n', '    string public constant name = "Binks Bucks";\n', '    string public constant symbol = "BNKS";\n', '    uint8 internal _decimals = 18;\n', '    uint internal _totalSupply = 0;\n', '    mapping(address => uint256) internal _balances;\n', '    mapping(address => mapping (address => uint256)) _allowed;\n', '\n', '    // Code Entry Vars\n', '    address internal imperator;\n', '    uint internal _code = 0;\n', '    uint internal _distribution_size = 1000000000000000000000;\n', '    uint internal _max_distributions = 100;\n', '    uint internal _distributions_left = 100;\n', '    uint internal _distribution_number = 0;\n', '    mapping(address => uint256) internal _last_distribution;\n', '    \n', '    function BinksBucks(address bossman) public {\n', '        imperator = msg.sender;\n', '        _balances[this] += 250000000000000000000000000;\n', '        _totalSupply += 250000000000000000000000000;\n', '        _balances[bossman] += 750000000000000000000000000;\n', '        _totalSupply += 750000000000000000000000000;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint) {return _totalSupply;}\n', '    function decimals() public constant returns (uint8) {return _decimals;}\n', '    function balanceOf(address owner) public constant returns (uint) {return _balances[owner];}\n', '\n', '    // Helper Functions\n', '    function hasAtLeast(address adr, uint amount) constant internal returns (bool) {\n', '        if (amount <= 0) {return false;}\n', '        return _balances[adr] >= amount;\n', '\n', '    }\n', '\n', '    function canRecieve(address adr, uint amount) constant internal returns (bool) {\n', '        if (amount <= 0) {return false;}\n', '        uint balance = _balances[adr];\n', '        return (balance + amount > balance);\n', '    }\n', '\n', '    function hasAllowance(address proxy, address spender, uint amount) constant internal returns (bool) {\n', '        if (amount <= 0) {return false;}\n', '        return _allowed[spender][proxy] >= amount;\n', '    }\n', '\n', '    function canAdd(uint x, uint y) pure internal returns (bool) {\n', '        uint total = x + y;\n', '        if (total > x && total > y) {return true;}\n', '        return false;\n', '    }\n', '    \n', '    // End Helper Functions\n', '\n', '    function transfer(address to, uint amount) public returns (bool) {\n', '        require(canRecieve(to, amount));\n', '        require(hasAtLeast(msg.sender, amount));\n', '        _balances[msg.sender] -= amount;\n', '        _balances[to] += amount;\n', '        Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address proxy, address spender) public constant returns (uint) {\n', '        return _allowed[proxy][spender];\n', '    }\n', '\n', '    function approve(address spender, uint amount) public returns (bool) {\n', '        _allowed[msg.sender][spender] = amount;\n', '        Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint amount) public returns (bool) {\n', '        require(hasAllowance(msg.sender, from, amount));\n', '        require(canRecieve(to, amount));\n', '        require(hasAtLeast(from, amount));\n', '        _allowed[from][msg.sender] -= amount;\n', '        _balances[from] -= amount;\n', '        _balances[to] += amount;\n', '        Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferEmpire(address newImperator) public {\n', '            require(msg.sender == imperator);\n', '            imperator = newImperator;\n', '        }\n', '\n', '    function setCode(uint code) public {\n', '        require(msg.sender == imperator);\n', '        _code = code;\n', '        _distributions_left = _max_distributions;\n', '        _distribution_number += 1;\n', '    }\n', '\n', '    function setMaxDistributions(uint num) public {\n', '        require(msg.sender == imperator);\n', '        _max_distributions = num;\n', '    }\n', '\n', '    function setDistributionSize(uint num) public {\n', '        require(msg.sender == imperator);\n', '        _distribution_size = num;\n', '    }\n', '\n', '    function CodeEligible() public view returns (bool) {\n', '        return (_code != 0 && _distributions_left > 0 && _distribution_number > _last_distribution[msg.sender]);\n', '    }\n', '\n', '    function EnterCode(uint code) public {\n', '        require(CodeEligible());\n', '        if (code == _code) {\n', '            _last_distribution[msg.sender] = _distribution_number;\n', '            _distributions_left -= 1;\n', '            require(canRecieve(msg.sender, _distribution_size));\n', '            require(hasAtLeast(this, _distribution_size));\n', '            _balances[this] -= _distribution_size;\n', '            _balances[msg.sender] += _distribution_size;\n', '            Transfer(this, msg.sender, _distribution_size);\n', '        }\n', '    }\n', '\n', '    event Transfer(address indexed, address indexed, uint);\n', '    event Approval(address indexed proxy, address indexed spender, uint amount);\n', '}']