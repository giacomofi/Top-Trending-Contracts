['pragma solidity ^0.4.19;\n', '\n', 'contract owned{\n', '\taddress public owner;\n', '\n', 'function owned() public {\n', '\towner = msg.sender;\n', '}\n', '\n', 'modifier onlyOwner{\n', '\trequire(msg.sender == owner);\n', '_;\n', '}\n', '\n', 'function transferOwnership(address newOwner) onlyOwner public {\n', '\towner = newOwner;\n', '}\n', '}\n', '\n', '//declare basic Events for Token Base\n', 'contract Token{\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', 'event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', 'event Burn(address indexed _from, uint256 _amount);\n', '}\n', '\n', 'contract StandardToken is Token{\n', '\n', '\tfunction transfer(address _to, uint256 _value) public returns(bool success) {\n', '\tif (balances[msg.sender] >= _value && _value > 0) {\n', '\t\tbalances[msg.sender] -= _value;\n', '\t\tbalances[_to] += _value;\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\telse {\n', '\t\treturn false;\n', '\t}\n', '}\n', '\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '\t\tbalances[_to] += _value;\n', '\t\tbalances[_from] -= _value;\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\telse {\n', '\t\treturn false;\n', '\t}\n', '}\n', '\n', 'function balanceOf(address _owner) constant public returns(uint256 amount) {\n', '\treturn balances[_owner];\n', '}\n', '\n', 'function approve(address _spender, uint256 _value) public returns(bool success) {\n', '\tallowed[msg.sender][_spender] = _value;\n', '\tApproval(msg.sender, _spender, _value);\n', '\treturn true;\n', '}\n', '\n', 'function burn(uint256 _amount) public returns(bool success) {\n', '\trequire(balances[msg.sender] >= _amount);\n', '\tbalances[msg.sender] -= _amount;\n', '\ttotalSupply -= _amount;\n', '\tBurn(msg.sender, _amount);\n', '\treturn true;\n', '}\n', '\n', 'function burnFrom(address from, uint256 _amount) public returns(bool success)\n', '{\n', '\trequire(balances[from] >= _amount);\n', '\trequire(_amount <= allowed[from][msg.sender]);\n', '\tbalances[from] -= _amount;\n', '\tallowed[from][msg.sender] -= _amount;\n', '\ttotalSupply -= _amount;\n', '\tBurn(from, _amount);\n', '\treturn true;\n', '}\n', '\n', 'function allowance(address _owner, address _spender) constant public returns(uint256 remaining) {\n', '\treturn allowed[_owner][_spender];\n', '}\n', '\n', 'mapping(address => uint256) balances;\n', 'mapping(address => mapping(address => uint256)) allowed;\n', 'uint256 public totalSupply;\n', 'uint256 public availableSupply;\n', 'uint256 public releasedSupply;\n', '}\n', '\n', '\n', '/////////////////////////////////////////////\n', '//Advanced Token functions - advanced layer//\n', '/////////////////////////////////////////////\n', 'contract AuraToken is StandardToken, owned{\n', '\tfunction() public payable{\n', '\tif (msg.sender != owner)\n', '\tgiveTokens(msg.sender,msg.value);\n', '}\n', '\n', '\n', 'string public name;\n', 'uint8 public decimals;\n', 'string public symbol;\n', 'uint256 public buyPrice;  //in wei\n', '\n', '\n', '\t\t\t\t\t\t  //make sure this constructor name matches contract name above\n', 'function AuraToken() public{\n', '\tdecimals = 18;                            // Amount of decimals for display purposes\n', '\ttotalSupply = 50000000 * 10 ** uint256(decimals);  // Update total supply \n', '\treleasedSupply = 0;\n', '\tavailableSupply = 0;\n', '\tname = "AuraToken";                                   // Set the name for display purposes\n', '\tsymbol = "AURA";                               // Set the symbol for display purposes\n', '\tbuyPrice = 1 * 10 ** 18;\t\t\t//set unreal price for the beginning to prevent attacks (in wei)\n', '}\n', '\n', 'function giveTokens(address _payer, uint256 _payment) internal returns(bool success) {\n', '\trequire(_payment > 0);\n', '\tuint256 tokens = (_payment / buyPrice) * (10 ** uint256(decimals));\n', '\tif (availableSupply < tokens)tokens = availableSupply;\n', '\trequire(availableSupply >= tokens);\n', '\trequire((balances[_payer] + tokens) > balances[_payer]); //overflow test\n', '\tbalances[_payer] += tokens;\n', '\tavailableSupply -= tokens;\n', '\treturn true;\n', '}\n', '\n', 'function giveReward(address _to, uint256 _amount) public onlyOwner returns(bool success) {\n', '\trequire(_amount > 0);\n', '\trequire(_to != 0x0); // burn instead\n', '\trequire(availableSupply >= _amount);\n', '\trequire((balances[_to] + _amount) > balances[_to]);\n', '\tbalances[_to] += _amount;\n', '\tavailableSupply -= _amount;\n', '\treturn true;\n', '}\n', '\n', 'function setPrice(uint256 _newPrice) public onlyOwner returns(bool success) {\n', '\tbuyPrice = _newPrice;\n', '\treturn true;\n', '}\n', '\n', 'function release(uint256 _amount) public onlyOwner returns(bool success) {\n', '\trequire((releasedSupply + _amount) <= totalSupply);\n', '\treleasedSupply += _amount;\n', '\tavailableSupply += _amount;\n', '\treturn true;\n', '}\n', '\n', 'function withdraw(uint256 _amount) public onlyOwner returns(bool success) {\n', '\tmsg.sender.transfer(_amount);\n', '\treturn true;\n', '}\n', '}\n', '\n', '//EOF']