['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;AWMV&#39; AnyWhereMobile Voucher Token\n', '//\n', '// Symbol      : AWMV\n', '// Name        : Example Fixed Supply Token\n', '// Total supply: 100,000,000,000.000000\n', '// Decimals    : 6\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe math\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // This notifies clients about the amount minted\n', '    event Mint(address indexed from, uint256 value);\n', '    \n', '    // This generates a public event on the blockchain that will notify clients \n', '    event FrozenFunds(address target, bool frozen);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// StopTrade contract - allows owner to stop trading\n', '// ----------------------------------------------------------------------------\n', 'contract StopTrade is Owned {\n', '\n', '    bool public stopped = false;\n', '\n', '    event TradeStopped(bool stopped);\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '\n', '    function stop() onlyOwner public {\n', '        stopped = true;\n', '        TradeStopped(true);\n', '    }\n', '\n', '    function start() onlyOwner public {\n', '        stopped = false;\n', '        TradeStopped(false);\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external ; }\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and an\n', '// initial fixed supply\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract AWMVoucher is ERC20Interface, SafeMath, StopTrade {\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function AWMVoucher() public {\n', '\n', '        symbol = "ATEST";\n', '        name = "AWM Test Token";\n', '        decimals = 6;\n', '\n', '        _totalSupply = 100000000000 * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[_from] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(!frozenAccount[_from]);          // Check if sender is frozen\n', '        require(!frozenAccount[_to]);            // Check if recipient is frozen\n', '\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = add(balances[_from], balances[_to]);\n', '\n', '        // Subtract from the sender\n', '        balances[_from] -= _value;\n', '\n', '        // Add the same to the recipient\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '     /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) stoppable public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool success) {\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Redeem tokens\n', '     *\n', '     * Send `_value` tokens from &#39;_from&#39; to `_to`\n', '     * Used to redeem AWMVouchers for AWMDollars\n', '     *\n', '     * @param _from The address of the source\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function redeem(address _from, address _to, uint256 _value) stoppable public onlyOwner {\n', '        _transfer(_from, _to, _value);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t    Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) stoppable onlyOwner public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] = sub(balances[msg.sender], _value); \n', '        _totalSupply = sub(_totalSupply,_value);\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) stoppable onlyOwner public returns (bool success) {\n', '        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '\n', '        // Subtract from the targeted balance\n', '        balances[_from] = sub(balances[_from], _value);\n', '\n', '        // Subtract from the sender&#39;s allowance\n', '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);\n', '\n', '        //totalSupply -= _value;                              // Update totalSupply\n', '        _totalSupply = sub(_totalSupply, _value);\n', '\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param _target Address to receive the tokens\n', '    /// @param _mintedAmount the amount of tokens it will receive\n', '    function mintToken(address _target, uint256 _mintedAmount) onlyOwner stoppable public {\n', '        require(!frozenAccount[_target]);            // Check if recipient is frozen\n', '\n', '\tbalances[_target] = add(balances[_target], _mintedAmount);\n', '\n', '        _totalSupply = add(_totalSupply, _mintedAmount);\n', '\n', '        Mint(_target, _mintedAmount);\n', '        Transfer(0, this, _mintedAmount);\n', '        Transfer(this, _target, _mintedAmount);\n', '    }\n', '\n', '    \n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param _target Address to be frozen\n', '    /// @param _freeze either to freeze it or not\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        frozenAccount[_target] = _freeze;\n', '        FrozenFunds(_target, _freeze);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Don&#39;t accept ETH\n', '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '\n', '    function transferToken(address _tokenContract, address _transferTo, uint256 _value) onlyOwner external {\n', '\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).transfer(_transferTo, _value);\n', '    }\n', '\n', '    function transferTokenFrom(address _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {\n', '\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).transferFrom(_transferTo, _transferFrom, _value);\n', '    }\n', '\n', '    function approveToken(address _tokenContract, address _spender, uint256 _value) onlyOwner external {\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).approve(_spender, _value);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'AWMV' AnyWhereMobile Voucher Token\n", '//\n', '// Symbol      : AWMV\n', '// Name        : Example Fixed Supply Token\n', '// Total supply: 100,000,000,000.000000\n', '// Decimals    : 6\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe math\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // This notifies clients about the amount minted\n', '    event Mint(address indexed from, uint256 value);\n', '    \n', '    // This generates a public event on the blockchain that will notify clients \n', '    event FrozenFunds(address target, bool frozen);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// StopTrade contract - allows owner to stop trading\n', '// ----------------------------------------------------------------------------\n', 'contract StopTrade is Owned {\n', '\n', '    bool public stopped = false;\n', '\n', '    event TradeStopped(bool stopped);\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '\n', '    function stop() onlyOwner public {\n', '        stopped = true;\n', '        TradeStopped(true);\n', '    }\n', '\n', '    function start() onlyOwner public {\n', '        stopped = false;\n', '        TradeStopped(false);\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external ; }\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and an\n', '// initial fixed supply\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract AWMVoucher is ERC20Interface, SafeMath, StopTrade {\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function AWMVoucher() public {\n', '\n', '        symbol = "ATEST";\n', '        name = "AWM Test Token";\n', '        decimals = 6;\n', '\n', '        _totalSupply = 100000000000 * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[_from] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        require(!frozenAccount[_from]);          // Check if sender is frozen\n', '        require(!frozenAccount[_to]);            // Check if recipient is frozen\n', '\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = add(balances[_from], balances[_to]);\n', '\n', '        // Subtract from the sender\n', '        balances[_from] -= _value;\n', '\n', '        // Add the same to the recipient\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '    }\n', '\n', '     /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) stoppable public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool success) {\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Redeem tokens\n', '     *\n', "     * Send `_value` tokens from '_from' to `_to`\n", '     * Used to redeem AWMVouchers for AWMDollars\n', '     *\n', '     * @param _from The address of the source\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function redeem(address _from, address _to, uint256 _value) stoppable public onlyOwner {\n', '        _transfer(_from, _to, _value);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t    Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) stoppable onlyOwner public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] = sub(balances[msg.sender], _value); \n', '        _totalSupply = sub(_totalSupply,_value);\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) stoppable onlyOwner public returns (bool success) {\n', '        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '\n', '        // Subtract from the targeted balance\n', '        balances[_from] = sub(balances[_from], _value);\n', '\n', "        // Subtract from the sender's allowance\n", '        allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value);\n', '\n', '        //totalSupply -= _value;                              // Update totalSupply\n', '        _totalSupply = sub(_totalSupply, _value);\n', '\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param _target Address to receive the tokens\n', '    /// @param _mintedAmount the amount of tokens it will receive\n', '    function mintToken(address _target, uint256 _mintedAmount) onlyOwner stoppable public {\n', '        require(!frozenAccount[_target]);            // Check if recipient is frozen\n', '\n', '\tbalances[_target] = add(balances[_target], _mintedAmount);\n', '\n', '        _totalSupply = add(_totalSupply, _mintedAmount);\n', '\n', '        Mint(_target, _mintedAmount);\n', '        Transfer(0, this, _mintedAmount);\n', '        Transfer(this, _target, _mintedAmount);\n', '    }\n', '\n', '    \n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param _target Address to be frozen\n', '    /// @param _freeze either to freeze it or not\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        frozenAccount[_target] = _freeze;\n', '        FrozenFunds(_target, _freeze);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '\n', '    function transferToken(address _tokenContract, address _transferTo, uint256 _value) onlyOwner external {\n', '\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).transfer(_transferTo, _value);\n', '    }\n', '\n', '    function transferTokenFrom(address _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {\n', '\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).transferFrom(_transferTo, _transferFrom, _value);\n', '    }\n', '\n', '    function approveToken(address _tokenContract, address _spender, uint256 _value) onlyOwner external {\n', '         // If ERC20 tokens are sent to this contract, they will be trapped forever.\n', '         // This function is way for us to withdraw them so we can get them back to their rightful owner\n', '\n', '         ERC20Interface(_tokenContract).approve(_spender, _value);\n', '    }\n', '\n', '}']
