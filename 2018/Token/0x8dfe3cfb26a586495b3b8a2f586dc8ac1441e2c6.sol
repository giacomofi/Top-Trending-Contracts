['pragma solidity ^0.4.19;\n', '// ï¿½ Ubecoin. All Rights Reserved\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', 'contract StandardToken {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping(address => uint256) balances;\n', '    uint256 public totalSupply;  \n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '      require(_to != address(0));\n', '\n', '      // SafeMath.sub will throw if there is not enough balance.\n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of. \n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '      return balances[_owner];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '      require(_to != address(0));\n', '\n', '      var _allowance = allowed[_from][msg.sender];\n', '\n', '      // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '      // require (_value <= _allowance);\n', '\n', '      balances[_from] = balances[_from].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      allowed[_from][msg.sender] = _allowance.sub(_value);\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '      // To change the approve amount you first have to reduce the addresses`\n', '      //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '      //  already 0 to mitigate the race condition described here:\n', '      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '      require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until \n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval (address _spender, uint _addedValue) public\n', '      returns (bool success) {\n', '      allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public\n', '      returns (bool success) {\n', '      uint oldValue = allowed[msg.sender][_spender];\n', '      if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '      }\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '    }\n', '}\n', '\n', '\n', 'contract UbecoinICO is owned {\n', '    using SafeMath for uint256;\n', '    string public version = "1.0";\n', '    address private WITHDRAW_WALLET;\n', '    uint256 public totalSold = 0;\n', '    uint256 public soldOnStage = 0;\n', '    uint8 public currentStage = 0;\n', '    Ubecoin public rewardToken;\n', '\n', '\n', '    uint256[] tokensRate = [7000,4200];\n', '    uint256[] tokensCap = [50000000,80000000];\n', '    mapping(address=>uint256) investments;\n', '    uint256 limit_on_beneficiary = 1000 * 1000 ether;\n', '\n', '    function investmentsOf(address beneficiary) public constant returns(uint256) {\n', '      return investments[beneficiary];\n', '    }\n', '  \n', '    function availableOnStage() public constant returns(uint256) {\n', '        return tokensCap[currentStage].mul(1 ether).sub(soldOnStage);\n', '    }\n', '\n', '    function createTokenContract() internal returns (Ubecoin) {\n', '      return new Ubecoin();\n', '    }\n', '\n', '    function currentStageTokensCap() public constant returns(uint256) {\n', '      return tokensCap[currentStage];\n', '    }\n', '    function currentStageTokensRate() public constant returns(uint256) {\n', '      return tokensRate[currentStage];\n', '    }\n', '\n', '    function UbecoinICO() payable owned() {\n', '        owner = msg.sender;\n', '        WITHDRAW_WALLET = msg.sender; \n', '        rewardToken = createTokenContract();\n', '    }\n', '\n', '    function () payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address beneficiary) payable {\n', '      bool canBuy = investmentsOf(beneficiary) < limit_on_beneficiary;\n', '      bool validPurchase = beneficiary != 0x0 && msg.value != 0;\n', '      uint256 currentTokensAmount = availableTokens();\n', '      require(canBuy && validPurchase && currentTokensAmount > 0);\n', '      uint256 boughtTokens;\n', '      uint256 refundAmount = 0;\n', '      \n', '      uint256[2] memory tokensAndRefund = calcMultiStage();\n', '      boughtTokens = tokensAndRefund[0];\n', '      refundAmount = tokensAndRefund[1];\n', '\n', '      require(boughtTokens < currentTokensAmount);\n', '\n', '      totalSold = totalSold.add(boughtTokens);\n', '      investments[beneficiary] = investments[beneficiary].add(boughtTokens);\n', '      if( soldOnStage >= tokensCap[currentStage].mul(1 ether)) {\n', '        toNextStage();\n', '      } \n', '      \n', '      rewardToken.transfer(beneficiary,boughtTokens);\n', '      if (refundAmount > 0) \n', '          refundMoney(refundAmount);\n', '\n', '      withdrawFunds(this.balance);\n', '    }\n', '\n', '    function forceWithdraw() onlyOwner {\n', '      withdrawFunds(this.balance);\n', '    }\n', '\n', '    function calcMultiStage() internal returns(uint256[2]) {\n', '      uint256 stageBoughtTokens;\n', '      uint256 undistributedAmount = msg.value; \n', '      uint256 _boughtTokens = 0; \n', '      uint256 undistributedTokens = availableTokens(); \n', '\n', '      while(undistributedAmount > 0 && undistributedTokens > 0) {\n', '        bool needNextStage = false; \n', '        \n', '        stageBoughtTokens = getTokensAmount(undistributedAmount);\n', '        \n', '\n', '        if(totalInvestments(_boughtTokens.add(stageBoughtTokens)) > limit_on_beneficiary){\n', '          stageBoughtTokens = limit_on_beneficiary.sub(_boughtTokens);\n', '          undistributedTokens = stageBoughtTokens; \n', '        }\n', '\n', '        \n', '        if (stageBoughtTokens > availableOnStage()) {\n', '          stageBoughtTokens = availableOnStage();\n', '          needNextStage = true; \n', '        }\n', '        \n', '        _boughtTokens = _boughtTokens.add(stageBoughtTokens);\n', '        undistributedTokens = undistributedTokens.sub(stageBoughtTokens); \n', '        undistributedAmount = undistributedAmount.sub(getTokensCost(stageBoughtTokens)); \n', '        soldOnStage = soldOnStage.add(stageBoughtTokens);\n', '        if (needNextStage) \n', '          toNextStage();\n', '      }\n', '      return [_boughtTokens,undistributedAmount];\n', '    }\n', '\n', '\n', '    function setWithdrawWallet(address addressToWithdraw) public onlyOwner {\n', '        require(addressToWithdraw != 0x0);\n', '        WITHDRAW_WALLET = addressToWithdraw;\n', '    }\n', '    function totalInvestments(uint additionalAmount) internal returns (uint256) {\n', '      return investmentsOf(msg.sender).add(additionalAmount);\n', '    }\n', '\n', '    function refundMoney(uint256 refundAmount) internal {\n', '      msg.sender.transfer(refundAmount);\n', '    }\n', '\n', '    function burnTokens(uint256 amount) public onlyOwner {\n', '      rewardToken.burn(amount);\n', '    }\n', '\n', '    function getTokensCost(uint256 _tokensAmount) internal constant returns(uint256) {\n', '      return _tokensAmount.div(tokensRate[currentStage]);\n', '    } \n', '\n', '    function getTokensAmount(uint256 _amountInWei) internal constant returns(uint256) {\n', '      return _amountInWei.mul(tokensRate[currentStage]);\n', '    }\n', '\n', '    function toNextStage() internal {\n', '        \n', '        if(currentStage < tokensRate.length && currentStage < tokensCap.length){\n', '          currentStage++;\n', '          soldOnStage = 0;\n', '        }\n', '    }\n', '\n', '    function availableTokens() public constant returns(uint256) {\n', '        return rewardToken.balanceOf(address(this));\n', '    }\n', '\n', '    function withdrawFunds(uint256 amount) internal {\n', '        WITHDRAW_WALLET.transfer(amount);\n', '    }\n', '}\n', '\n', '\n', 'contract Ubecoin is StandardToken {\n', '      event Burn(address indexed burner, uint256 value);\n', '\n', '      string public constant name = "Ubecoin";\n', '      string public constant symbol = "UBE";\n', '      uint8 public constant decimals = 18;\n', '      string public version = "1.0";\n', '      uint256 public totalSupply  = 3000000000 * 1 ether;\n', '      mapping(address=>uint256) premineOf;\n', '      address[] private premineWallets = [\n', '          0xc1b1dCA667619888EF005fA515472FC8058856D9, \n', '          0x2aB549AF98722F013432698D1D74027c5897843B\n', '      ];\n', '\n', '      function Ubecoin() public {\n', '        balances[msg.sender] = totalSupply;\n', '        premineOf[premineWallets[0]] = 300000000 * 1 ether; \n', '        premineOf[premineWallets[1]] = 2570000000 * 1 ether;\n', '                \n', '        for(uint i = 0; i<premineWallets.length;i++) {\n', '          transfer(premineWallets[i],premineOf[premineWallets[i]]);\n', '        }\n', '      }\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param _value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '  }']