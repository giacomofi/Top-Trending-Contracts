['pragma solidity ^0.4.16; \n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } \n', '\n', 'contract Rapide { \n', '    // 변수 선언 \n', '    string public name; \n', '    string public symbol; \n', '    uint8 public decimals = 18; \n', '    // 18소수 점 이하는 강력하게 제안된 기본 값이므로 변경하지 마십시오. \n', '    uint256 public totalSupply; \n', '\n', '    // 모든 균형을 갖춘 배열을 생성합니다. \n', '    mapping (address => uint256) public balanceOf; \n', '    mapping (address => mapping (address => uint256)) public allowance; \n', '\n', '    // 이것은 블록체인에서 클라이언트에게 알려주는 공개 이벤트를 생성합니다 \n', '    event Transfer(address indexed from, address indexed to, uint256 value); \n', '\n', '    // 소각된 양을 알립니다. \n', '    event Burn(address indexed from, uint256 value); \n', '\n', '    /** \n', '     * 생성자 함수 \n', '     * \n', '     * 계약서 작성자에게 초기 공급 토큰과의 계약을 초기화합니다. \n', '     */ \n', '    function Rapide( \n', '        uint256 initialSupply, \n', '        string tokenName, \n', '        string tokenSymbol \n', '    ) public { \n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  // 총 공급액을 소수로 업데이트합니다. \n', '        balanceOf[msg.sender] = totalSupply;                    // 총 발행량 \n', '        name = tokenName;                                       // 토큰 이름 \n', '        symbol = tokenSymbol;                                   // 토큰 심볼 (EX: BTC, ETH, LTC) \n', '    } \n', '\n', '    /** \n', '     * 내부 전송, 이 계약으로만 호출할 수 있습니다. \n', '     */ \n', '    function _transfer(address _from, address _to, uint _value) internal { \n', '        // Prevent transfer to 0x0 address. Use burn() instead \n', '        require(_to != 0x0); \n', '        // 발신자 점검 \n', '        require(balanceOf[_from] >= _value); \n', '        // 오버플로 확인 \n', '        require(balanceOf[_to] + _value > balanceOf[_to]); \n', '        // 미래의 주장을 위해 이것을 저장하십시오 \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to]; \n', '        // 발신자에서 차감 \n', '        balanceOf[_from] -= _value; \n', '        // 받는 사람에게 같은 것을 추가하십시오. \n', '        balanceOf[_to] += _value; \n', '        Transfer(_from, _to, _value); \n', '        // 정적 분석을 사용하여 코드에서 버그를 찾을 때 사용합니다. 이 시스템은 실패하지 않습니다. \n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances); \n', '    } \n', '\n', '    /** \n', '     * 토큰 전송 \n', '     * @ _to 받는 사람의 주소에 대한 매개 변수 \n', '     * @ _value 전송할 금액을 정하다. \n', '     */ \n', '    function transfer(address _to, uint256 _value) public { \n', '        _transfer(msg.sender, _to, _value); \n', '    } \n', '\n', '    /** \n', '     * _from  보낸 사람의 주소 \n', '     * _to    받는 사람의 주소 \n', '     * _value 전송할 금액 \n', '     */ \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n', '        require(_value <= allowance[_from][msg.sender]);     // 허용량 체크 \n', '        allowance[_from][msg.sender] -= _value; \n', '        _transfer(_from, _to, _value); \n', '        return true; \n', '    } \n', '\n', '    /** \n', '     * 다른 주소에 대한 허용량 설정 \n', '     * _spender 지출 할 수있는 주소 \n', '     * _value   그들이 쓸 수 있는 지출 할 수있는 최대 금액 \n', '     */ \n', '    function approve(address _spender, uint256 _value) public \n', '        returns (bool success) { \n', '        allowance[msg.sender][_spender] = _value; \n', '        return true; \n', '    } \n', '\n', '    /** \n', '     * 다른 주소에 대한 허용치 설정 및 알림 \n', '     * @param _spender   지출 할 수있는 주소 \n', '     * @param _value     그들이 쓸 수 있는 지출 할 수있는 최대 금액 \n', '     * @param _extraData 승인 된 계약서에 보낼 추가 정보 \n', '     */ \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) \n', '        public \n', '        returns (bool success) { \n', '        tokenRecipient spender = tokenRecipient(_spender); \n', '        if (approve(_spender, _value)) { \n', '            spender.receiveApproval(msg.sender, _value, this, _extraData); \n', '            return true; \n', '        } \n', '    } \n', '\n', '    /** \n', '     * 토큰 파괴 \n', '     * @param _value 소각되는 금액 \n', '     */ \n', '    function burn(uint256 _value) public returns (bool success) { \n', '        require(balanceOf[msg.sender] >= _value);   // 보낸 사람이 충분히 있는지 확인하십시오. \n', '        balanceOf[msg.sender] -= _value;            // 발신자에게서 뺍니다. \n', '        totalSupply -= _value;                      // 총 발행량 업데이트 \n', '        Burn(msg.sender, _value); \n', '        return true; \n', '    } \n', '\n', '  /** \n', '     * 다른 계정에서 토큰 삭제 \n', '     * @param _from 발신자 주소 \n', '     * @param _value 소각되는 금액 \n', '     */ \n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) { \n', '        require(balanceOf[_from] >= _value);                // 목표 잔액이 충분한 지 확인하십시오. \n', '        require(_value <= allowance[_from][msg.sender]);    // 수당 확인 \n', '        balanceOf[_from] -= _value;                         // 목표 잔액에서 차감 \n', '        allowance[_from][msg.sender] -= _value;             // 발송인의 허용량에서 차감 \n', '        totalSupply -= _value;                              // 총 발행량 업데이트 \n', '        Burn(_from, _value); \n', '        return true; \n', '    } \n', '}']