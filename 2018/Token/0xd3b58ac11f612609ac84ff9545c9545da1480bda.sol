['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract DateTime {\n', '        function getYear(uint timestamp) public constant returns (uint16);\n', '        function getMonth(uint timestamp) public constant returns (uint8);\n', '        function getDay(uint timestamp) public constant returns (uint8);\n', '}\n', '\n', 'contract TokenDistributor {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    ERC20 public token;\n', '    uint public neededAmountTotal;\n', '    uint public releasedTokenTotal;\n', '\n', '    address public approver;\n', '    uint public distributedBountyTotal;\n', '\n', '    struct DistributeList {\n', '        uint totalAmount;\n', '        uint releasedToken;\n', '        LockUpData[] lockUpData;\n', '    }    \n', '\n', '    struct LockUpData {\n', '        uint amount;\n', '        uint releaseDate;\n', '    }\n', '\n', '    /*\n', '    //\n', '    // address for DateTime should be changed before contract deploying.\n', '    //\n', '    */\n', '    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n', '    //DateTime public dateTime = DateTime(dateTimeAddr);    \n', '    DateTime public dateTime;\n', '    \n', '    mapping (address => DistributeList) public distributeList;    \n', '\n', '    /*\n', '    //  events\n', '    */\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n', '    event ReceiverRemoved(address indexed tokenReceiver);\n', '    \n', '    event ReleaseToken(address indexed tokenReceiver, uint amount);\n', '\n', '    event BountyDistributed(uint listCount, uint amount);\n', '   \n', '   /*\n', '   //   modifiers\n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    /* constructor */\n', '    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n', '        owner = msg.sender;\n', '        token = _tokenAddr;\n', '        dateTime = DateTime(_dateTimeAddr); \n', '    }\n', '\n', '    /* fallback */\n', '    function () external  {\n', '        releaseToken();\n', '    }\n', '\n', '    function requestTransferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferRequsted(owner, newOwner);\n', '        newOwnerCandidate = newOwner;\n', '    }\n', '\n', '    function receiveTransferOwnership() public {\n', '        require(newOwnerCandidate == msg.sender);\n', '        emit OwnershipTransferred(owner, newOwnerCandidate);\n', '        owner = newOwnerCandidate;\n', '    }\n', '\n', '    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n', '        require(_amount.length == _releaseDate.length && _receiver != address(0));\n', '\n', '        uint tokenReserve;\n', '        DistributeList storage dl = distributeList[_receiver];\n', '\n', '        // check amount of lock token\n', '        for (uint i = 0; i < _amount.length; i++) {\n', '            tokenReserve += _amount[i];\n', '        }\n', '        \n', '        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n', '\n', '        for (i = 0; i < _amount.length; i++) {\n', '            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n', '        }\n', '        \n', '        dl.totalAmount += tokenReserve;\n', '        neededAmountTotal += tokenReserve;\n', '        \n', '    }\n', '    \n', '    function changeReceiver(address _from, address _to) public onlyOwner {\n', '        //change only when _to address has 0 amount (means new address)\n', '        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n', '        \n', '        distributeList[_to] = distributeList[_from];\n', '        delete distributeList[_from];\n', '        emit ReceiverChanged(_from, _to);\n', '    }\n', '    \n', '    function removeReceiver(address _receiver) public onlyOwner {\n', '        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n', '        \n', '        //adjust neededAmountTotal when lockupdata removing.\n', '        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n', '\n', '        delete distributeList[_receiver];\n', '\n', '        emit ReceiverRemoved(_receiver);\n', '    }\n', '    \n', '    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n', '        _releaseToken(_tokenReceiver);\n', '    }\n', '    \n', '    function releaseToken() public {\n', '        _releaseToken(msg.sender);\n', '    }\n', '    \n', '    function _releaseToken(address _tokenReceiver) internal {\n', '\n', '        DistributeList storage dl = distributeList[_tokenReceiver];\n', '        uint releasableToken;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++){\n', '\n', '            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n', '                releasableToken += dl.lockUpData[i].amount;\n', '                dl.lockUpData[i].amount = 0;\n', '            }\n', '        }\n', '        \n', '        dl.releasedToken    += releasableToken;\n', '        releasedTokenTotal  += releasableToken;\n', '        neededAmountTotal   -= releasableToken;\n', '        \n', '        token.transfer(_tokenReceiver, releasableToken);\n', '        emit ReleaseToken(_tokenReceiver, releasableToken);\n', '    }\n', '    \n', '    function transfer(address _to, uint _amount) public onlyOwner {\n', '        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n', '        token.transfer(_to, _amount);\n', '    }\n', '    \n', '    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n', '    function setApprover(address _approver) public onlyOwner {\n', '        approver = _approver;\n', '    }\n', '    \n', '    //should be checked approved amount and the sum of _amount\n', '    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n', '        require(_receiver.length == _amount.length);\n', '        uint bountyAmount;\n', '        \n', '        for (uint i = 0; i < _amount.length; i++) {\n', '            distributedBountyTotal += _amount[i];\n', '            bountyAmount += _amount[i];\n', '            token.transferFrom(approver, _receiver[i], _amount[i]);\n', '        }\n', '        emit BountyDistributed(_receiver.length, bountyAmount);\n', '    }\n', '\n', '    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n', '    \n', '        DistributeList storage dl = distributeList[_tokenReceiver];\n', '        uint releasableToken;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++) {\n', '            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n', '                releasableToken += dl.lockUpData[i].amount;\n', '            }\n', '        }\n', '        \n', '        return (dl.totalAmount, dl.releasedToken, releasableToken);\n', '        \n', '    }\n', '\n', '    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n', '    \n', '        DistributeList storage dl = distributeList[_tokenRecv];\n', '        uint _releasableToken;\n', '        uint _releaseDate;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++){\n', '            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n', '                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n', '                    _releasableToken = dl.lockUpData[i].amount;\n', '                    _releaseDate = dl.lockUpData[i].releaseDate;\n', '                }\n', '            }\n', '        }\n', '        \n', '        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n', '\n', '    }\n', '\n', '    function viewContractHoldingToken() public view returns (uint _amount) {\n', '        return (token.balanceOf(this));\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract DateTime {\n', '        function getYear(uint timestamp) public constant returns (uint16);\n', '        function getMonth(uint timestamp) public constant returns (uint8);\n', '        function getDay(uint timestamp) public constant returns (uint8);\n', '}\n', '\n', 'contract TokenDistributor {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    ERC20 public token;\n', '    uint public neededAmountTotal;\n', '    uint public releasedTokenTotal;\n', '\n', '    address public approver;\n', '    uint public distributedBountyTotal;\n', '\n', '    struct DistributeList {\n', '        uint totalAmount;\n', '        uint releasedToken;\n', '        LockUpData[] lockUpData;\n', '    }    \n', '\n', '    struct LockUpData {\n', '        uint amount;\n', '        uint releaseDate;\n', '    }\n', '\n', '    /*\n', '    //\n', '    // address for DateTime should be changed before contract deploying.\n', '    //\n', '    */\n', '    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n', '    //DateTime public dateTime = DateTime(dateTimeAddr);    \n', '    DateTime public dateTime;\n', '    \n', '    mapping (address => DistributeList) public distributeList;    \n', '\n', '    /*\n', '    //  events\n', '    */\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n', '    event ReceiverRemoved(address indexed tokenReceiver);\n', '    \n', '    event ReleaseToken(address indexed tokenReceiver, uint amount);\n', '\n', '    event BountyDistributed(uint listCount, uint amount);\n', '   \n', '   /*\n', '   //   modifiers\n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    /* constructor */\n', '    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n', '        owner = msg.sender;\n', '        token = _tokenAddr;\n', '        dateTime = DateTime(_dateTimeAddr); \n', '    }\n', '\n', '    /* fallback */\n', '    function () external  {\n', '        releaseToken();\n', '    }\n', '\n', '    function requestTransferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferRequsted(owner, newOwner);\n', '        newOwnerCandidate = newOwner;\n', '    }\n', '\n', '    function receiveTransferOwnership() public {\n', '        require(newOwnerCandidate == msg.sender);\n', '        emit OwnershipTransferred(owner, newOwnerCandidate);\n', '        owner = newOwnerCandidate;\n', '    }\n', '\n', '    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n', '        require(_amount.length == _releaseDate.length && _receiver != address(0));\n', '\n', '        uint tokenReserve;\n', '        DistributeList storage dl = distributeList[_receiver];\n', '\n', '        // check amount of lock token\n', '        for (uint i = 0; i < _amount.length; i++) {\n', '            tokenReserve += _amount[i];\n', '        }\n', '        \n', '        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n', '\n', '        for (i = 0; i < _amount.length; i++) {\n', '            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n', '        }\n', '        \n', '        dl.totalAmount += tokenReserve;\n', '        neededAmountTotal += tokenReserve;\n', '        \n', '    }\n', '    \n', '    function changeReceiver(address _from, address _to) public onlyOwner {\n', '        //change only when _to address has 0 amount (means new address)\n', '        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n', '        \n', '        distributeList[_to] = distributeList[_from];\n', '        delete distributeList[_from];\n', '        emit ReceiverChanged(_from, _to);\n', '    }\n', '    \n', '    function removeReceiver(address _receiver) public onlyOwner {\n', '        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n', '        \n', '        //adjust neededAmountTotal when lockupdata removing.\n', '        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n', '\n', '        delete distributeList[_receiver];\n', '\n', '        emit ReceiverRemoved(_receiver);\n', '    }\n', '    \n', '    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n', '        _releaseToken(_tokenReceiver);\n', '    }\n', '    \n', '    function releaseToken() public {\n', '        _releaseToken(msg.sender);\n', '    }\n', '    \n', '    function _releaseToken(address _tokenReceiver) internal {\n', '\n', '        DistributeList storage dl = distributeList[_tokenReceiver];\n', '        uint releasableToken;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++){\n', '\n', '            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n', '                releasableToken += dl.lockUpData[i].amount;\n', '                dl.lockUpData[i].amount = 0;\n', '            }\n', '        }\n', '        \n', '        dl.releasedToken    += releasableToken;\n', '        releasedTokenTotal  += releasableToken;\n', '        neededAmountTotal   -= releasableToken;\n', '        \n', '        token.transfer(_tokenReceiver, releasableToken);\n', '        emit ReleaseToken(_tokenReceiver, releasableToken);\n', '    }\n', '    \n', '    function transfer(address _to, uint _amount) public onlyOwner {\n', '        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n', '        token.transfer(_to, _amount);\n', '    }\n', '    \n', '    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n', '    function setApprover(address _approver) public onlyOwner {\n', '        approver = _approver;\n', '    }\n', '    \n', '    //should be checked approved amount and the sum of _amount\n', '    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n', '        require(_receiver.length == _amount.length);\n', '        uint bountyAmount;\n', '        \n', '        for (uint i = 0; i < _amount.length; i++) {\n', '            distributedBountyTotal += _amount[i];\n', '            bountyAmount += _amount[i];\n', '            token.transferFrom(approver, _receiver[i], _amount[i]);\n', '        }\n', '        emit BountyDistributed(_receiver.length, bountyAmount);\n', '    }\n', '\n', '    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n', '    \n', '        DistributeList storage dl = distributeList[_tokenReceiver];\n', '        uint releasableToken;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++) {\n', '            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n', '                releasableToken += dl.lockUpData[i].amount;\n', '            }\n', '        }\n', '        \n', '        return (dl.totalAmount, dl.releasedToken, releasableToken);\n', '        \n', '    }\n', '\n', '    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n', '    \n', '        DistributeList storage dl = distributeList[_tokenRecv];\n', '        uint _releasableToken;\n', '        uint _releaseDate;\n', '\n', '        for (uint i=0; i < dl.lockUpData.length ; i++){\n', '            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n', '                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n', '                    _releasableToken = dl.lockUpData[i].amount;\n', '                    _releaseDate = dl.lockUpData[i].releaseDate;\n', '                }\n', '            }\n', '        }\n', '        \n', '        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n', '\n', '    }\n', '\n', '    function viewContractHoldingToken() public view returns (uint _amount) {\n', '        return (token.balanceOf(this));\n', '    }\n', '\n', '}']
