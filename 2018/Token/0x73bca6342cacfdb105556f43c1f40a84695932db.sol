['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '  \n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require(b <= a);\n', '    c = a - b;\n', '  }\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require(a == 0 || c / a == b);\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint c) {\n', '    require(b > 0);\n', '    c = a / b;\n', '  }\n', '}\n', '\n', 'contract Nonpayable {\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Don&#39;t accept ETH\n', '  // ------------------------------------------------------------------------\n', '  function () public payable {\n', '    revert();\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function destroy() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'contract Regulated is Ownable {\n', '  event Whitelisted(address indexed customer);\n', '  event Blacklisted(address indexed customer);\n', '  \n', '  mapping(address => bool) regulationStatus;\n', '\n', '  function whitelist(address customer) public onlyOwner {\n', '    regulationStatus[customer] = true;\n', '    Whitelisted(customer);\n', '  }\n', '\n', '  function blacklist(address customer) public onlyOwner {\n', '    regulationStatus[customer] = false;\n', '    Blacklisted(customer);\n', '  }\n', '  \n', '  function ensureRegulated(address customer) public constant {\n', '    require(regulationStatus[customer] == true);\n', '  }\n', '\n', '  function isRegulated(address customer) public constant returns (bool approved) { \n', '    return regulationStatus[customer];\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '  function transfer(address to, uint tokens) public returns (bool success);\n', '  function approve(address spender, uint tokens) public returns (bool success);\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract VaultbankVotingToken is ERC20, Regulated, Nonpayable {\n', '  using SafeMath for uint;\n', '\n', '  string public symbol;\n', '  string public  name;\n', '  uint8 public decimals;\n', '  uint public _totalSupply;\n', '\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowed;\n', '\n', '  function VaultbankVotingToken() public {\n', '    symbol = "VBV";\n', '    name = "Vaultbank Voting Token";\n', '    decimals = 0;\n', '    _totalSupply = 1000;\n', '\n', '    regulationStatus[address(0)] = true;\n', '    Whitelisted(address(0));\n', '    regulationStatus[owner] = true;\n', '    Whitelisted(owner);\n', '\n', '    balances[owner] = _totalSupply;\n', '    Transfer(address(0), owner, _totalSupply);\n', '  }\n', '\n', '  function issue(address recipient, uint tokens) public onlyOwner returns (bool success) {\n', '    require(recipient != address(0));\n', '    require(recipient != owner);\n', '    \n', '    whitelist(recipient);\n', '    transfer(recipient, tokens);\n', '    return true;\n', '  }\n', '\n', '  function issueAndLock(address recipient, uint tokens) public onlyOwner returns (bool success) {\n', '    issue(recipient, tokens);\n', '    blacklist(recipient);\n', '    return true;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    require(newOwner != owner);\n', '   \n', '    whitelist(newOwner);\n', '    transfer(newOwner, balances[owner]);\n', '    owner = newOwner;\n', '  }\n', '\n', '  function totalSupply() public constant returns (uint supply) {\n', '    return _totalSupply - balances[address(0)];\n', '  }\n', '\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function transfer(address to, uint tokens) public returns (bool success) {\n', '    ensureRegulated(msg.sender);\n', '    ensureRegulated(to);\n', '    \n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens) public returns (bool success) {\n', '    // Put a check for race condition issue with approval workflow of ERC20\n', '    require((tokens == 0) || (allowed[msg.sender][spender] == 0));\n', '    \n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '    ensureRegulated(from);\n', '    ensureRegulated(to);\n', '\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '  \n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require(b <= a);\n', '    c = a - b;\n', '  }\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require(a == 0 || c / a == b);\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint c) {\n', '    require(b > 0);\n', '    c = a / b;\n', '  }\n', '}\n', '\n', 'contract Nonpayable {\n', '\n', '  // ------------------------------------------------------------------------\n', "  // Don't accept ETH\n", '  // ------------------------------------------------------------------------\n', '  function () public payable {\n', '    revert();\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function destroy() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', 'contract Regulated is Ownable {\n', '  event Whitelisted(address indexed customer);\n', '  event Blacklisted(address indexed customer);\n', '  \n', '  mapping(address => bool) regulationStatus;\n', '\n', '  function whitelist(address customer) public onlyOwner {\n', '    regulationStatus[customer] = true;\n', '    Whitelisted(customer);\n', '  }\n', '\n', '  function blacklist(address customer) public onlyOwner {\n', '    regulationStatus[customer] = false;\n', '    Blacklisted(customer);\n', '  }\n', '  \n', '  function ensureRegulated(address customer) public constant {\n', '    require(regulationStatus[customer] == true);\n', '  }\n', '\n', '  function isRegulated(address customer) public constant returns (bool approved) { \n', '    return regulationStatus[customer];\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '  function transfer(address to, uint tokens) public returns (bool success);\n', '  function approve(address spender, uint tokens) public returns (bool success);\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract VaultbankVotingToken is ERC20, Regulated, Nonpayable {\n', '  using SafeMath for uint;\n', '\n', '  string public symbol;\n', '  string public  name;\n', '  uint8 public decimals;\n', '  uint public _totalSupply;\n', '\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowed;\n', '\n', '  function VaultbankVotingToken() public {\n', '    symbol = "VBV";\n', '    name = "Vaultbank Voting Token";\n', '    decimals = 0;\n', '    _totalSupply = 1000;\n', '\n', '    regulationStatus[address(0)] = true;\n', '    Whitelisted(address(0));\n', '    regulationStatus[owner] = true;\n', '    Whitelisted(owner);\n', '\n', '    balances[owner] = _totalSupply;\n', '    Transfer(address(0), owner, _totalSupply);\n', '  }\n', '\n', '  function issue(address recipient, uint tokens) public onlyOwner returns (bool success) {\n', '    require(recipient != address(0));\n', '    require(recipient != owner);\n', '    \n', '    whitelist(recipient);\n', '    transfer(recipient, tokens);\n', '    return true;\n', '  }\n', '\n', '  function issueAndLock(address recipient, uint tokens) public onlyOwner returns (bool success) {\n', '    issue(recipient, tokens);\n', '    blacklist(recipient);\n', '    return true;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    require(newOwner != owner);\n', '   \n', '    whitelist(newOwner);\n', '    transfer(newOwner, balances[owner]);\n', '    owner = newOwner;\n', '  }\n', '\n', '  function totalSupply() public constant returns (uint supply) {\n', '    return _totalSupply - balances[address(0)];\n', '  }\n', '\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function transfer(address to, uint tokens) public returns (bool success) {\n', '    ensureRegulated(msg.sender);\n', '    ensureRegulated(to);\n', '    \n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint tokens) public returns (bool success) {\n', '    // Put a check for race condition issue with approval workflow of ERC20\n', '    require((tokens == 0) || (allowed[msg.sender][spender] == 0));\n', '    \n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '    ensureRegulated(from);\n', '    ensureRegulated(to);\n', '\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '}']
