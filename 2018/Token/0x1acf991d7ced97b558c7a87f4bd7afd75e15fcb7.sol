['pragma solidity ^0.4.18;\n', '\n', '/*\n', 'TTTTTTTTTTTTTTTTTTTTTTT  iiii                                                                                              \n', 'T:::::::::::::::::::::T i::::i                                                                                             \n', 'T:::::::::::::::::::::T  iiii                                                                                              \n', 'T:::::TT:::::::TT:::::T                                                                                                    \n', 'TTTTTT  T:::::T  TTTTTTiiiiiii xxxxxxx      xxxxxxxggggggggg   ggggguuuuuu    uuuuuu rrrrr   rrrrrrrrr   uuuuuu    uuuuuu  \n', '        T:::::T        i:::::i  x:::::x    x:::::xg:::::::::ggg::::gu::::u    u::::u r::::rrr:::::::::r  u::::u    u::::u  \n', '        T:::::T         i::::i   x:::::x  x:::::xg:::::::::::::::::gu::::u    u::::u r:::::::::::::::::r u::::u    u::::u  \n', '        T:::::T         i::::i    x:::::xx:::::xg::::::ggggg::::::ggu::::u    u::::u rr::::::rrrrr::::::ru::::u    u::::u  \n', '        T:::::T         i::::i     x::::::::::x g:::::g     g:::::g u::::u    u::::u  r:::::r     r:::::ru::::u    u::::u  \n', '        T:::::T         i::::i      x::::::::x  g:::::g     g:::::g u::::u    u::::u  r:::::r     rrrrrrru::::u    u::::u  \n', '        T:::::T         i::::i      x::::::::x  g:::::g     g:::::g u::::u    u::::u  r:::::r            u::::u    u::::u  \n', '        T:::::T         i::::i     x::::::::::x g::::::g    g:::::g u:::::uuuu:::::u  r:::::r            u:::::uuuu:::::u  \n', '      TT:::::::TT      i::::::i   x:::::xx:::::xg:::::::ggggg:::::g u:::::::::::::::uur:::::r            u:::::::::::::::uu\n', '      T:::::::::T      i::::::i  x:::::x  x:::::xg::::::::::::::::g  u:::::::::::::::ur:::::r             u:::::::::::::::u\n', '      T:::::::::T      i::::::i x:::::x    x:::::xgg::::::::::::::g   uu::::::::uu:::ur:::::r              uu::::::::uu:::u\n', '      TTTTTTTTTTT      iiiiiiiixxxxxxx      xxxxxxx gggggggg::::::g     uuuuuuuu  uuuurrrrrrr                uuuuuuuu  uuuu\n', '                                                            g:::::g                                                        \n', '                                                gggggg      g:::::g                                                        \n', '                                                g:::::gg   gg:::::g                                                        \n', '                                                 g::::::ggg:::::::g                                                        \n', '                                                  gg:::::::::::::g                                                         \n', '                                                    ggg::::::ggg                                                           \n', '                                                       gggggg                                                              \n', '*/\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  function getOwner() public view returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract TIX is StandardToken, Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "Tixguru Token";\n', '  string public constant symbol = "TIX";\n', '  uint256 public constant decimals = 3;\n', '  uint256 internal constant wei_to_token = 10 ** 15;\n', '\n', '  uint256 public rate = 10000;\n', '  uint256 public minimum = 1 * 10 ** 11;\n', '  uint256 public wei_raised = 0;\n', '  uint256 public token_issued = 0;\n', '  uint256 public start_time = 0;\n', '  uint256 public end_time = 0;\n', '  uint256 public period = 0;\n', '  uint256[] public discount_period;\n', '  uint256[] public discount;\n', '  bool public tradeable = false;\n', '  bool public issuable = false;\n', '\n', '  address internal vault;\n', '\n', '\n', '  event LogTokenBought(address indexed sender, address indexed buyer, uint256 value, uint256 tokens, uint256 timestamp);\n', '  event LogVaultChanged(address indexed new_vault, uint256 timestamp);\n', '  event LogStarted(uint256 timestamp);\n', '  event LogTradingEnabled(uint256 timestamp);\n', '  event LogTradingDisabled(uint256 timestamp);\n', '  event LogTokenBurned(address indexed burner, uint256 indexed tokens, uint256 timestamp);\n', '  event LogPreSaled(address indexed buyer, uint256 tokens, uint256 timestamp);\n', '  event LogDiscountSet(uint256[] indexed period, uint256[] indexed discount, uint256 timestamp);\n', '\n', '\n', '  modifier validAddress(address addr) {\n', '    require(addr != address(0));\n', '    _;\n', '  }\n', '\n', '  function disableTrading() external onlyOwner returns (bool) {\n', '    tradeable = false;\n', '    LogTradingDisabled(now);\n', '    return true;\n', '  }\n', '\n', '\n', '  function TIX(uint256 cap, address _vault, uint256[] _period, uint256[] _discount)\n', '  public\n', '  validAddress(_vault)\n', '  validArray(_period)\n', '  validArray(_discount) {\n', '\n', '    uint256 decimal_unit = 10 ** 3;\n', '    totalSupply_ = cap.mul(decimal_unit);\n', '    vault = _vault;\n', '    discount_period = _period;\n', '    discount = _discount;\n', '\n', '    balances[0x8b26E715fF12B0Bf37D504f7Bf0ee918Cd83C67B] = totalSupply_.mul(3).div(10);\n', '    balances[owner] = totalSupply_.mul(7).div(10);\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      period = period.add(discount_period[i]);\n', '    }\n', '  }\n', '\n', '  function deposit() internal {\n', '    vault.transfer(msg.value);\n', '  }\n', '\n', '  modifier validArray(uint[] array) {\n', '    require(array.length > 0);\n', '    _;\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address buyer) public validAddress(buyer) payable {\n', '    require(issuable);\n', '\n', '    uint256 tokens = getTokenAmount(msg.value);\n', '\n', '    require(canIssue(tokens));\n', '\n', '    wei_raised = wei_raised.add(msg.value);\n', '    token_issued = token_issued.add(tokens);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[buyer] = balances[buyer].add(tokens);\n', '\n', '    LogTokenBought(msg.sender, buyer, msg.value, tokens, now);\n', '\n', '    deposit();\n', '  }\n', '\n', '  function setDiscount(uint256[] _period, uint256[] _discount)\n', '  external\n', '  onlyVault\n', '  validArray(_period)\n', '  validArray(_discount)\n', '  returns (bool) {\n', '\n', '    discount_period = _period;\n', '    discount = _discount;\n', '\n', '    period = 0;\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      period = period.add(discount_period[i]);\n', '    }\n', '\n', '    if (start_time != 0) {\n', '      uint256 time_point = now;\n', '      start_time = time_point;\n', '      end_time = time_point + period;\n', '\n', '      uint256 tmp_time = time_point;\n', '      for (i = 0; i < discount_period.length; i++) {\n', '        tmp_time = tmp_time.add(discount_period[i]);\n', '        discount_period[i] = tmp_time;\n', '      }\n', '    }\n', '\n', '    LogDiscountSet( _period, _discount, time_point);\n', '    return true;\n', '  }\n', '\n', '  function getTokenAmount(uint256 _value) public view returns (uint256) {\n', '    require(_value >= minimum);\n', '\n', '    uint256 buy_time = now;\n', '    uint256 numerator = 0;\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      if (buy_time <= discount_period[i]) {\n', '        numerator = discount[i];\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (numerator == 0) {\n', '      numerator = 100;\n', '    }\n', '\n', '    return _value.mul(rate).mul(numerator).div(100).div(wei_to_token);\n', '  }\n', '\n', '  function enableTrading() external onlyOwner returns (bool) {\n', '    tradeable = true;\n', '    LogTradingEnabled(now);\n', '    return true;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '\n', '    balances[newOwner] = balances[owner];\n', '    delete balances[owner];\n', '    super.transferOwnership(newOwner);\n', '  }\n', '\n', '  function start() external onlyOwner returns (bool) {\n', '    require(start_time == 0);\n', '\n', '    uint256 time_point = now;\n', '\n', '    start_time = time_point;\n', '    end_time = time_point + period;\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      time_point = time_point.add(discount_period[i]);\n', '      discount_period[i] = time_point;\n', '    }\n', '\n', '    issuable = true;\n', '\n', '    LogStarted(start_time);\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function changeVault(address _vault) external onlyVault returns (bool) {\n', '    vault = _vault;\n', '    LogVaultChanged(_vault, now);\n', '    return true;\n', '  }\n', '\n', '  function burnTokens(uint256 tokens) external onlyVault returns (bool) {\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    totalSupply_ = totalSupply_.sub(tokens);\n', '    LogTokenBurned(owner, tokens, now);\n', '    return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 tokens) public returns (bool) {\n', '    require(tradeable == true);\n', '    return super.transferFrom(_from, _to, tokens);\n', '  }\n', '\n', '\n', '  function transfer(address _to, uint256 tokens) public returns (bool) {\n', '    require(tradeable == true);\n', '    return super.transfer(_to, tokens);\n', '  }\n', '\n', '\n', '  function canIssue(uint256 tokens) internal returns (bool){\n', '    if (start_time == 0 || end_time <= now) {\n', '      issuable = false;\n', '      return false;\n', '    }\n', '    if (token_issued.add(tokens) > balances[owner]) {\n', '      issuable = false;\n', '      return false;\n', '    }\n', '\n', '    return true;\n', '  }\n', '  modifier onlyVault() {\n', '    require(msg.sender == vault);\n', '    _;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', 'TTTTTTTTTTTTTTTTTTTTTTT  iiii                                                                                              \n', 'T:::::::::::::::::::::T i::::i                                                                                             \n', 'T:::::::::::::::::::::T  iiii                                                                                              \n', 'T:::::TT:::::::TT:::::T                                                                                                    \n', 'TTTTTT  T:::::T  TTTTTTiiiiiii xxxxxxx      xxxxxxxggggggggg   ggggguuuuuu    uuuuuu rrrrr   rrrrrrrrr   uuuuuu    uuuuuu  \n', '        T:::::T        i:::::i  x:::::x    x:::::xg:::::::::ggg::::gu::::u    u::::u r::::rrr:::::::::r  u::::u    u::::u  \n', '        T:::::T         i::::i   x:::::x  x:::::xg:::::::::::::::::gu::::u    u::::u r:::::::::::::::::r u::::u    u::::u  \n', '        T:::::T         i::::i    x:::::xx:::::xg::::::ggggg::::::ggu::::u    u::::u rr::::::rrrrr::::::ru::::u    u::::u  \n', '        T:::::T         i::::i     x::::::::::x g:::::g     g:::::g u::::u    u::::u  r:::::r     r:::::ru::::u    u::::u  \n', '        T:::::T         i::::i      x::::::::x  g:::::g     g:::::g u::::u    u::::u  r:::::r     rrrrrrru::::u    u::::u  \n', '        T:::::T         i::::i      x::::::::x  g:::::g     g:::::g u::::u    u::::u  r:::::r            u::::u    u::::u  \n', '        T:::::T         i::::i     x::::::::::x g::::::g    g:::::g u:::::uuuu:::::u  r:::::r            u:::::uuuu:::::u  \n', '      TT:::::::TT      i::::::i   x:::::xx:::::xg:::::::ggggg:::::g u:::::::::::::::uur:::::r            u:::::::::::::::uu\n', '      T:::::::::T      i::::::i  x:::::x  x:::::xg::::::::::::::::g  u:::::::::::::::ur:::::r             u:::::::::::::::u\n', '      T:::::::::T      i::::::i x:::::x    x:::::xgg::::::::::::::g   uu::::::::uu:::ur:::::r              uu::::::::uu:::u\n', '      TTTTTTTTTTT      iiiiiiiixxxxxxx      xxxxxxx gggggggg::::::g     uuuuuuuu  uuuurrrrrrr                uuuuuuuu  uuuu\n', '                                                            g:::::g                                                        \n', '                                                gggggg      g:::::g                                                        \n', '                                                g:::::gg   gg:::::g                                                        \n', '                                                 g::::::ggg:::::::g                                                        \n', '                                                  gg:::::::::::::g                                                         \n', '                                                    ggg::::::ggg                                                           \n', '                                                       gggggg                                                              \n', '*/\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  function getOwner() public view returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract TIX is StandardToken, Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "Tixguru Token";\n', '  string public constant symbol = "TIX";\n', '  uint256 public constant decimals = 3;\n', '  uint256 internal constant wei_to_token = 10 ** 15;\n', '\n', '  uint256 public rate = 10000;\n', '  uint256 public minimum = 1 * 10 ** 11;\n', '  uint256 public wei_raised = 0;\n', '  uint256 public token_issued = 0;\n', '  uint256 public start_time = 0;\n', '  uint256 public end_time = 0;\n', '  uint256 public period = 0;\n', '  uint256[] public discount_period;\n', '  uint256[] public discount;\n', '  bool public tradeable = false;\n', '  bool public issuable = false;\n', '\n', '  address internal vault;\n', '\n', '\n', '  event LogTokenBought(address indexed sender, address indexed buyer, uint256 value, uint256 tokens, uint256 timestamp);\n', '  event LogVaultChanged(address indexed new_vault, uint256 timestamp);\n', '  event LogStarted(uint256 timestamp);\n', '  event LogTradingEnabled(uint256 timestamp);\n', '  event LogTradingDisabled(uint256 timestamp);\n', '  event LogTokenBurned(address indexed burner, uint256 indexed tokens, uint256 timestamp);\n', '  event LogPreSaled(address indexed buyer, uint256 tokens, uint256 timestamp);\n', '  event LogDiscountSet(uint256[] indexed period, uint256[] indexed discount, uint256 timestamp);\n', '\n', '\n', '  modifier validAddress(address addr) {\n', '    require(addr != address(0));\n', '    _;\n', '  }\n', '\n', '  function disableTrading() external onlyOwner returns (bool) {\n', '    tradeable = false;\n', '    LogTradingDisabled(now);\n', '    return true;\n', '  }\n', '\n', '\n', '  function TIX(uint256 cap, address _vault, uint256[] _period, uint256[] _discount)\n', '  public\n', '  validAddress(_vault)\n', '  validArray(_period)\n', '  validArray(_discount) {\n', '\n', '    uint256 decimal_unit = 10 ** 3;\n', '    totalSupply_ = cap.mul(decimal_unit);\n', '    vault = _vault;\n', '    discount_period = _period;\n', '    discount = _discount;\n', '\n', '    balances[0x8b26E715fF12B0Bf37D504f7Bf0ee918Cd83C67B] = totalSupply_.mul(3).div(10);\n', '    balances[owner] = totalSupply_.mul(7).div(10);\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      period = period.add(discount_period[i]);\n', '    }\n', '  }\n', '\n', '  function deposit() internal {\n', '    vault.transfer(msg.value);\n', '  }\n', '\n', '  modifier validArray(uint[] array) {\n', '    require(array.length > 0);\n', '    _;\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address buyer) public validAddress(buyer) payable {\n', '    require(issuable);\n', '\n', '    uint256 tokens = getTokenAmount(msg.value);\n', '\n', '    require(canIssue(tokens));\n', '\n', '    wei_raised = wei_raised.add(msg.value);\n', '    token_issued = token_issued.add(tokens);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[buyer] = balances[buyer].add(tokens);\n', '\n', '    LogTokenBought(msg.sender, buyer, msg.value, tokens, now);\n', '\n', '    deposit();\n', '  }\n', '\n', '  function setDiscount(uint256[] _period, uint256[] _discount)\n', '  external\n', '  onlyVault\n', '  validArray(_period)\n', '  validArray(_discount)\n', '  returns (bool) {\n', '\n', '    discount_period = _period;\n', '    discount = _discount;\n', '\n', '    period = 0;\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      period = period.add(discount_period[i]);\n', '    }\n', '\n', '    if (start_time != 0) {\n', '      uint256 time_point = now;\n', '      start_time = time_point;\n', '      end_time = time_point + period;\n', '\n', '      uint256 tmp_time = time_point;\n', '      for (i = 0; i < discount_period.length; i++) {\n', '        tmp_time = tmp_time.add(discount_period[i]);\n', '        discount_period[i] = tmp_time;\n', '      }\n', '    }\n', '\n', '    LogDiscountSet( _period, _discount, time_point);\n', '    return true;\n', '  }\n', '\n', '  function getTokenAmount(uint256 _value) public view returns (uint256) {\n', '    require(_value >= minimum);\n', '\n', '    uint256 buy_time = now;\n', '    uint256 numerator = 0;\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      if (buy_time <= discount_period[i]) {\n', '        numerator = discount[i];\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (numerator == 0) {\n', '      numerator = 100;\n', '    }\n', '\n', '    return _value.mul(rate).mul(numerator).div(100).div(wei_to_token);\n', '  }\n', '\n', '  function enableTrading() external onlyOwner returns (bool) {\n', '    tradeable = true;\n', '    LogTradingEnabled(now);\n', '    return true;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '\n', '    balances[newOwner] = balances[owner];\n', '    delete balances[owner];\n', '    super.transferOwnership(newOwner);\n', '  }\n', '\n', '  function start() external onlyOwner returns (bool) {\n', '    require(start_time == 0);\n', '\n', '    uint256 time_point = now;\n', '\n', '    start_time = time_point;\n', '    end_time = time_point + period;\n', '\n', '    for (uint256 i = 0; i < discount_period.length; i++) {\n', '      time_point = time_point.add(discount_period[i]);\n', '      discount_period[i] = time_point;\n', '    }\n', '\n', '    issuable = true;\n', '\n', '    LogStarted(start_time);\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function changeVault(address _vault) external onlyVault returns (bool) {\n', '    vault = _vault;\n', '    LogVaultChanged(_vault, now);\n', '    return true;\n', '  }\n', '\n', '  function burnTokens(uint256 tokens) external onlyVault returns (bool) {\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    totalSupply_ = totalSupply_.sub(tokens);\n', '    LogTokenBurned(owner, tokens, now);\n', '    return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint256 tokens) public returns (bool) {\n', '    require(tradeable == true);\n', '    return super.transferFrom(_from, _to, tokens);\n', '  }\n', '\n', '\n', '  function transfer(address _to, uint256 tokens) public returns (bool) {\n', '    require(tradeable == true);\n', '    return super.transfer(_to, tokens);\n', '  }\n', '\n', '\n', '  function canIssue(uint256 tokens) internal returns (bool){\n', '    if (start_time == 0 || end_time <= now) {\n', '      issuable = false;\n', '      return false;\n', '    }\n', '    if (token_issued.add(tokens) > balances[owner]) {\n', '      issuable = false;\n', '      return false;\n', '    }\n', '\n', '    return true;\n', '  }\n', '  modifier onlyVault() {\n', '    require(msg.sender == vault);\n', '    _;\n', '  }\n', '}']
