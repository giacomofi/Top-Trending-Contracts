['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\t// event\n', '\tevent OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(_newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, _newOwner);\n', '\t\towner = _newOwner;\n', '\t}\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = true;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused returns (bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused returns (bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ControllablePause is Pausable {\n', '    mapping(address => bool) public transferWhiteList;\n', '    \n', '    modifier whenControllablePaused() {\n', '        if (!paused) {\n', '            require(transferWhiteList[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier whenControllableNotPaused() {\n', '        if (paused) {\n', '            require(transferWhiteList[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function addTransferWhiteList(address _new) public onlyOwner {\n', '        transferWhiteList[_new] = true;\n', '    }\n', '    \n', '    function delTransferWhiteList(address _del) public onlyOwner {\n', '        delete transferWhiteList[_del];\n', '    }\n', '}\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '\tfunction totalSupply() public view returns (uint256);\n', '\tfunction balanceOf(address _owner) public view returns (uint256);\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool);\n', '\t\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool);\n', '\t\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '    // use SafeMath to avoid uint256 overflow\n', '\tusing SafeMath for uint256;\n', '\n', '    // balances of every address\n', '\tmapping(address => uint256) balances;\n', '\n', '\t// total number of token\n', '\tuint256 totalSupply_;\n', '\n', '    // return total number of token\n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn totalSupply_;\n', '\t}\n', '\n', '\t// transfer _value tokens to _to from msg.sender\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t    // if you want to destroy tokens, use burn replace transfer to address 0\n', '\t\trequire(_to != address(0));\n', '\t\t// can not transfer to self\n', '\t\trequire(_to != msg.sender);\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\n', '\t\t// SafeMath.sub will throw if there is not enough balance.\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// return _owner how many tokens\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '}\n', '\n', '\n', '// anyone can destroy his tokens\n', 'contract BurnableToken is BasicToken {\n', '\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\n', '    // destroy his tokens\n', '\tfunction burn(uint256 _value) public {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\t\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply_ = totalSupply_.sub(_value);\n', '\t\temit Burn(burner, _value);\n', '\t\t// add a Transfer event only to ensure Transfer event record integrity\n', '\t\temit Transfer(burner, address(0), _value);\n', '\t}\n', '}\n', '\n', '\n', '// refer: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '\tmapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_from != _to);\n', '\t\trequire(_value <= balances[_from]);\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '    // return how many tokens _owner approve to _spender\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '    // increase approval to _spender\n', '\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '    // decrease approval to _spender\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '\t\t}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'contract PausableToken is BurnableToken, StandardToken, ControllablePause{\n', '    \n', '    function burn(uint256 _value) public whenControllableNotPaused {\n', '        super.burn(_value);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '\n', 'contract EONToken is PausableToken {\n', '\tusing SafeMath for uint256;\n', '    \n', '\tstring public constant name\t= &#39;Entertainment Open Network&#39;;\n', '\tstring public constant symbol = &#39;EON&#39;;\n', '\tuint public constant decimals = 18;\n', '\tuint public constant INITIAL_SUPPLY = 21*10**26;\n', '\n', '\tconstructor() public {\n', '\t\ttotalSupply_ = INITIAL_SUPPLY;\n', '\t\tbalances[owner] = totalSupply_;\n', '\t\temit Transfer(address(0x0), owner, totalSupply_);\n', '\t}\n', '\n', '\tfunction batchTransfer(address[] _recipients, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '\t\tuint256 count = _recipients.length;\n', '\t\trequire(count > 0 && count <= 20);\n', '\t\tuint256 needAmount = count.mul(_value);\n', '\t\trequire(_value > 0 && balances[msg.sender] >= needAmount);\n', '\n', '\t\tfor (uint256 i = 0; i < count; i++) {\n', '\t\t\ttransfer(_recipients[i], _value);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '    // Record private sale wallet to allow transfering.\n', '    address public privateSaleWallet;\n', '\n', '    // Crowdsale contract address.\n', '    address public crowdsaleAddress;\n', '    \n', '    // Lock tokens contract address.\n', '    address public lockTokensAddress;\n', '    \n', '    function setLockTokensAddress(address _lockTokensAddress) external onlyOwner {\n', '        lockTokensAddress = _lockTokensAddress;\n', '    }\n', '\t\n', '    function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner {\n', '        // Can only set one time.\n', '        require(crowdsaleAddress == address(0));\n', '        require(_crowdsaleAddress != address(0));\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '    }\n', '\n', '    function setPrivateSaleAddress(address _privateSaleWallet) external onlyOwner {\n', '        // Can only set one time.\n', '        require(privateSaleWallet == address(0));\n', '        privateSaleWallet = _privateSaleWallet;\n', '    }\n', '    \n', '    // revert error pay \n', '    function () public {\n', '        revert();\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\t// event\n', '\tevent OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(_newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, _newOwner);\n', '\t\towner = _newOwner;\n', '\t}\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = true;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyOwner whenNotPaused returns (bool) {\n', '        paused = true;\n', '        emit Pause();\n', '        return true;\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused returns (bool) {\n', '        paused = false;\n', '        emit Unpause();\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ControllablePause is Pausable {\n', '    mapping(address => bool) public transferWhiteList;\n', '    \n', '    modifier whenControllablePaused() {\n', '        if (!paused) {\n', '            require(transferWhiteList[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier whenControllableNotPaused() {\n', '        if (paused) {\n', '            require(transferWhiteList[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function addTransferWhiteList(address _new) public onlyOwner {\n', '        transferWhiteList[_new] = true;\n', '    }\n', '    \n', '    function delTransferWhiteList(address _del) public onlyOwner {\n', '        delete transferWhiteList[_del];\n', '    }\n', '}\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '\tfunction totalSupply() public view returns (uint256);\n', '\tfunction balanceOf(address _owner) public view returns (uint256);\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool);\n', '\t\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool);\n', '\t\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '    // use SafeMath to avoid uint256 overflow\n', '\tusing SafeMath for uint256;\n', '\n', '    // balances of every address\n', '\tmapping(address => uint256) balances;\n', '\n', '\t// total number of token\n', '\tuint256 totalSupply_;\n', '\n', '    // return total number of token\n', '\tfunction totalSupply() public view returns (uint256) {\n', '\t\treturn totalSupply_;\n', '\t}\n', '\n', '\t// transfer _value tokens to _to from msg.sender\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t    // if you want to destroy tokens, use burn replace transfer to address 0\n', '\t\trequire(_to != address(0));\n', '\t\t// can not transfer to self\n', '\t\trequire(_to != msg.sender);\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\n', '\t\t// SafeMath.sub will throw if there is not enough balance.\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// return _owner how many tokens\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '}\n', '\n', '\n', '// anyone can destroy his tokens\n', 'contract BurnableToken is BasicToken {\n', '\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\n', '    // destroy his tokens\n', '\tfunction burn(uint256 _value) public {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\t\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply_ = totalSupply_.sub(_value);\n', '\t\temit Burn(burner, _value);\n', '\t\t// add a Transfer event only to ensure Transfer event record integrity\n', '\t\temit Transfer(burner, address(0), _value);\n', '\t}\n', '}\n', '\n', '\n', '// refer: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '\tmapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_from != _to);\n', '\t\trequire(_value <= balances[_from]);\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '    // return how many tokens _owner approve to _spender\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '    // increase approval to _spender\n', '\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '    // decrease approval to _spender\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '\t\t}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '\n', 'contract PausableToken is BurnableToken, StandardToken, ControllablePause{\n', '    \n', '    function burn(uint256 _value) public whenControllableNotPaused {\n', '        super.burn(_value);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '\n', 'contract EONToken is PausableToken {\n', '\tusing SafeMath for uint256;\n', '    \n', "\tstring public constant name\t= 'Entertainment Open Network';\n", "\tstring public constant symbol = 'EON';\n", '\tuint public constant decimals = 18;\n', '\tuint public constant INITIAL_SUPPLY = 21*10**26;\n', '\n', '\tconstructor() public {\n', '\t\ttotalSupply_ = INITIAL_SUPPLY;\n', '\t\tbalances[owner] = totalSupply_;\n', '\t\temit Transfer(address(0x0), owner, totalSupply_);\n', '\t}\n', '\n', '\tfunction batchTransfer(address[] _recipients, uint256 _value) public whenControllableNotPaused returns (bool) {\n', '\t\tuint256 count = _recipients.length;\n', '\t\trequire(count > 0 && count <= 20);\n', '\t\tuint256 needAmount = count.mul(_value);\n', '\t\trequire(_value > 0 && balances[msg.sender] >= needAmount);\n', '\n', '\t\tfor (uint256 i = 0; i < count; i++) {\n', '\t\t\ttransfer(_recipients[i], _value);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '    // Record private sale wallet to allow transfering.\n', '    address public privateSaleWallet;\n', '\n', '    // Crowdsale contract address.\n', '    address public crowdsaleAddress;\n', '    \n', '    // Lock tokens contract address.\n', '    address public lockTokensAddress;\n', '    \n', '    function setLockTokensAddress(address _lockTokensAddress) external onlyOwner {\n', '        lockTokensAddress = _lockTokensAddress;\n', '    }\n', '\t\n', '    function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner {\n', '        // Can only set one time.\n', '        require(crowdsaleAddress == address(0));\n', '        require(_crowdsaleAddress != address(0));\n', '        crowdsaleAddress = _crowdsaleAddress;\n', '    }\n', '\n', '    function setPrivateSaleAddress(address _privateSaleWallet) external onlyOwner {\n', '        // Can only set one time.\n', '        require(privateSaleWallet == address(0));\n', '        privateSaleWallet = _privateSaleWallet;\n', '    }\n', '    \n', '    // revert error pay \n', '    function () public {\n', '        revert();\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}']
