['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c; \n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BasicTokenERC20 {  \n', '    using SafeMath for uint256;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    \n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    mapping (uint8 => mapping (address => uint256)) internal whitelist;\n', '\n', '    uint256 totalSupply_;\n', '    address public owner_;\n', '    \n', '    constructor() public {\n', '        owner_ = msg.sender;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return balances[owner];\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(to != address(0));\n', '        require(value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    } \n', '               \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool){\n', '        require(to != address(0));\n', '        require(value <= balances[from]);\n', '        require(value <= allowed[from][msg.sender]);\n', '\n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256){\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner_);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Seba is BasicTokenERC20 {    \n', '\n', '    string public constant name = "SebaToken"; \n', '    string public constant symbol = "SEBA";\n', '    uint public decimals = 18; \n', '    uint256 public milion = 1000000;\n', '    bool public takeToken = false;\n', '\n', '    uint256 public INITIAL_SUPPLY = 24 * milion * (uint256(10) ** decimals);\n', '    mapping (address => bool) internal friendList;\n', '\n', '    constructor() public {        \n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = totalSupply_;\n', '    }     \n', '\n', '    function setFriend(address friendWallet) public onlyOwner{\n', '        friendList[friendWallet] = true;        \n', '    }\n', '\n', '    function isFriend(address friendWallet) public view returns (bool) {\n', '        return friendList[friendWallet];\n', '    }\n', '\n', '    function withdraw(uint256 value) public onlyOwner {\n', '        require(value > 0);\n', '        require(owner_ != 0x0);        \n', '        owner_.transfer(value);\n', '    } \n', '\n', '    function () public payable {\n', '        require(takeToken == true);        \n', '        require(msg.sender != 0x0);\n', '\n', '        uint256 tokens = 100 * (uint256(10) ** decimals);\n', '        require(balances[msg.sender] >= tokens);\n', '\n', '        require(balances[owner_] >= tokens);\n', '        \n', '        balances[owner_] = balances[owner_].sub(tokens);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens); \n', '        \n', '        emit Transfer(owner_, msg.sender, tokens);\n', '    }\n', '\n', '    function startTakeToken() public onlyOwner {\n', '        takeToken = true;\n', '    }\n', '\n', '    function stopTakeToken() public onlyOwner {\n', '        takeToken = false;\n', '    } \n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c; \n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BasicTokenERC20 {  \n', '    using SafeMath for uint256;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    \n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    mapping (uint8 => mapping (address => uint256)) internal whitelist;\n', '\n', '    uint256 totalSupply_;\n', '    address public owner_;\n', '    \n', '    constructor() public {\n', '        owner_ = msg.sender;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return balances[owner];\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(to != address(0));\n', '        require(value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    } \n', '               \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool){\n', '        require(to != address(0));\n', '        require(value <= balances[from]);\n', '        require(value <= allowed[from][msg.sender]);\n', '\n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256){\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner_);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Seba is BasicTokenERC20 {    \n', '\n', '    string public constant name = "SebaToken"; \n', '    string public constant symbol = "SEBA";\n', '    uint public decimals = 18; \n', '    uint256 public milion = 1000000;\n', '    bool public takeToken = false;\n', '\n', '    uint256 public INITIAL_SUPPLY = 24 * milion * (uint256(10) ** decimals);\n', '    mapping (address => bool) internal friendList;\n', '\n', '    constructor() public {        \n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = totalSupply_;\n', '    }     \n', '\n', '    function setFriend(address friendWallet) public onlyOwner{\n', '        friendList[friendWallet] = true;        \n', '    }\n', '\n', '    function isFriend(address friendWallet) public view returns (bool) {\n', '        return friendList[friendWallet];\n', '    }\n', '\n', '    function withdraw(uint256 value) public onlyOwner {\n', '        require(value > 0);\n', '        require(owner_ != 0x0);        \n', '        owner_.transfer(value);\n', '    } \n', '\n', '    function () public payable {\n', '        require(takeToken == true);        \n', '        require(msg.sender != 0x0);\n', '\n', '        uint256 tokens = 100 * (uint256(10) ** decimals);\n', '        require(balances[msg.sender] >= tokens);\n', '\n', '        require(balances[owner_] >= tokens);\n', '        \n', '        balances[owner_] = balances[owner_].sub(tokens);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens); \n', '        \n', '        emit Transfer(owner_, msg.sender, tokens);\n', '    }\n', '\n', '    function startTakeToken() public onlyOwner {\n', '        takeToken = true;\n', '    }\n', '\n', '    function stopTakeToken() public onlyOwner {\n', '        takeToken = false;\n', '    } \n', '}']
