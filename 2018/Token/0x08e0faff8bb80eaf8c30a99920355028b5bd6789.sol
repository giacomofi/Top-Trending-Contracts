['pragma solidity ^0.4.25;\n', '\n', 'interface tokenRecipient \n', '{ \n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '//contrato para definir quien es el administrador central del token\n', 'contract owned \n', '{    \n', '  \taddress public owner;\n', '\n', '    constructor() public    \n', '    {        \n', '    \towner = msg.sender;\n', '\n', '    }    \n', '    modifier onlyOwner     \n', '    {        \n', '    \trequire(msg.sender == owner);\n', '        _;\n', '\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public     \n', '    {        \n', '    \towner = newOwner;\n', '\n', '    }\n', '}\n', '\n', 'contract TokenPrueba1 is owned\n', '{    \n', '    //Variables publicas del token    \n', '   \tstring public name;\n', '\n', '    string public symbol;\n', '\n', '    //18 decimales es el parametro por defecto, evitar cambiarlo    \n', '    uint8 public decimals = 8;\n', '\n', '    //cantidad total de la moneda\n', '    uint256 public totalSupply;\n', '\n', '    //Crea un arreglo para llevar los balances de las cuentas    \n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    //Arreglo que guarda la "toleracia" de las cuentas con otras, cuanto pueden "tomar" estas    \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    //cuentas congeladas    \n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    // Crea un evento en la blockchain que notifica a los clientes de la transferencia    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // Crea un evento en la blockchain que notifica a los clientes de la aprobación    \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // Notifica a los clientes de la cantidad quemada    \n', '    event Burn(uint256 value);\n', '\n', '    // Crea un evento que notifica sobre las cuentas congeladas    \n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    /**\n', '    * Funcion constructora     \n', '    * Le da todos los tokens al creador del contrato      \n', '    *     \n', '    *@param initialSupply La cantidad inicial del token     \n', '    *@param tokenName El nombre del token     \n', '    *@param tokenSymbol El símbolo a usar por parte del token     \n', '    *@param centralMinter La direccion del creador     \n', '    **/    \n', '    constructor(uint256 initialSupply,string tokenName,string tokenSymbol, address centralMinter) public     \n', '    {        \n', '    \t//Le damos valor al totalSupply y le damos decimales        \n', '    \ttotalSupply = initialSupply * 10 ** uint256(decimals);\n', '\n', '        //al sender del contrato, le damos todos los tokens al principio        \n', '        balanceOf[msg.sender] = totalSupply;\n', '\n', '        //nombre del token        \n', '        name = tokenName;\n', '\n', '        //simbolo del token        \n', '        symbol = tokenSymbol;\n', '\n', '        //administrador de la moneda que puede cambiar la cantidad disponible (minter)       \n', '        if(centralMinter != 0 ) owner = centralMinter;\n', '\n', '    }        \n', '    /**     \n', '    *Funcion para cambiar el numero de tokens disponibles, solo el owner puede cambiarlos     \n', '    *     \n', '    *@param target direccion a la que se le cambiará el número de tokens     \n', '    *@param mintedAmount cantidad que se desea añadir     \n', '    **/    \n', '    function mintToken(address target, uint256 mintedAmount) onlyOwner public    \n', '    {        \n', '    \tbalanceOf[target] += mintedAmount;\n', '\n', '        totalSupply += mintedAmount;\n', '\n', '        emit Transfer(0, owner, mintedAmount);\n', '\n', '        emit Transfer(owner, target, mintedAmount);\n', '\n', '    }     \n', '    /**     \n', '    * Destruye tokens (quema dinero), solo el propietario puede     \n', '    *     \n', "    * Remueve la cantidad de tokens en '_value' del sistema de forma irreversible     \n", '    *     \n', '    * @param _value La cantidad de dinero a quemar     \n', '    */    \n', '    function burn(uint256 _value) onlyOwner public returns (bool success)    \n', '    {        \n', '    // Actualiza el totalSupply        \n', '    \ttotalSupply -= _value;\n', '\n', '        emit Burn(_value);\n', '\n', '        return true;\n', '\n', '    }    \n', '    /**    \n', '    *Congela una cuenta    \n', '    *    \n', '    *@param target direccion de la cuenta que se desea congelar    \n', '    *@param freeze booleano que decide si se desea congelar la cuenta (true) o descongelar (false)    \n', '    **/    \n', '    function freezeAccount(address target, bool freeze) onlyOwner public    \n', '    {        \n', '    \tfrozenAccount[target] = freeze;\n', '\n', '        emit FrozenFunds(target, freeze);\n', '\n', '    }    \n', '    /**     \n', '    * Transferencia interna, solo puede ser llamada por este contrato     \n', '    *      \n', '    *@param _from direccion de la cuenta desde donde se envian los tokens     \n', '    *@param _to direccion de la cuenta a la que van los tokens     \n', '    *@param _value Número de tokens a enviar     \n', '    */    \n', '    function _transfer(address _from, address _to, uint _value) internal {        \n', '    // Previene la transferencia a una cuenta 0x0. Para destruir tokens es mejor usar burn()        \n', '    \trequire(_to != 0x0);\n', '\n', '        // Verificamos si el que envia tiene suficiente diner        \n', '        require(balanceOf[_from] >= _value);\n', '\n', '        // Verificamos si existe o no un overflow        \n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '\n', '        // Guardamos esta asercion en el futuro        \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\n', '        // Le quitamos tokens al que envia        \n', '        balanceOf[_from] -= _value;\n', '\n', '        // Le añadimos esa cantidad al que envia        \n', '        balanceOf[_to] += _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        // asercion para encontrar bugs        \n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\n', '    }    \n', '    /**     \n', '    * Transferir tokens     \n', '    *     \n', "    * Envia '_value' de tokens a '_to' desde tu cuenta     \n", '    *     \n', '    * @param _to La dirección del receptor     \n', '    * @param _value La cantidad a enviar     \n', '    */    \n', '    function transfer(address _to, uint256 _value) public returns (bool success)    \n', '    {        \n', '    \trequire(!frozenAccount[msg.sender]);\n', '\n', '        _transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '\n', '    }    \n', '    /**     \n', '    * Transferir tokens desde otra dirección     \n', '    *     \n', "    * Enviar la cantidad de tokens '_value' hacia la cuenta '_to' desde la cuenta '_from'     \n", '    * Esta es una función que podria usarse para operaciones de caja     \n', '    *     \n', '    * @param _from la dirección de quien envia     \n', '    * @param _to La dirección del receptor     \n', '    * @param _value La cantidad de tokens a enviar     \n', '    */    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)    {        \n', '    \trequire(_value <= allowance[_from][msg.sender]);\n', '\n', '     // Check allowance        \n', '    \tallowance[_from][msg.sender] -= _value;\n', '\n', '        _transfer(_from, _to, _value);\n', '\n', '        return true;\n', '\n', '    }    \n', '    /**     \n', '    * Coloca la toleracia para otras direcciones     \n', '    *     \n', "    * Permite que el '_spender' no gaste mas que la cantidad de '_value' de tokens por parte tuya     \n", '    *     \n', '    * @param _spender La dirección a la que se autoriza gastar     \n', '    * @param _value La cantidad máxima que pueden gastar     \n', '    */    \n', '    function approve(address _spender, uint256 _value) public returns (bool success)    {        \n', '    \tallowance[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '\n', '    }    \n', '    /**     \n', '    * Para funcionar con otros contratos     \n', '    * En prueba     \n', '    *     \n', '    * Coloca la toleracia para otras direcciones y notificar     \n', '    *     \n', "    * Permite al '_spender' a gastar no mas de la cantidad de tokens de '_value' de tu cuenta y luego notificar al contrato     \n", '    *     * @param _spender La dirección autorizada a gastar     * @param _value La cantidad máxima que pueden gastar     \n', '    * @param _extraData Informacion extra a enviar al contrato     \n', '    */    \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)    {        \n', '    \ttokenRecipient spender = tokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value))        \n', '        {            \n', '        \tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\n', '            return true;\n', '\n', '        }    \n', '    }\n', '}']