['/**\n', ' * @title ERC20 interface\n', ' * @dev Implements ERC20 Token Standard: https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(y != 0);\n', '        uint256 z = x / y;\n', '        assert(x == y * z + x % y);\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '/// @title Contract that will work with ERC223 tokens.\n', 'contract ERC223ReceivingContract { \n', '    /*\n', '    * @dev Standard ERC223 function that will handle incoming token transfers.\n', '    * @param _from Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint _value, bytes _data) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable contract\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control functions.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    // Events\n', '    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '    constructor(address _owner) public validAddress(_owner) {\n', '        owner = _owner;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param _newOwner The address to transfer ownership to.\n', '    function transferOwnership(address _newOwner) public onlyOwner validAddress(_newOwner) {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC223 is ERC20 {\n', '    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n', '}\n', '\n', '\n', '\n', '\n', 'contract StandardToken is ERC223 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Modifiers\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * @dev ERC20 method to transfer token to a specified address.\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bytes memory empty;\n', '        transfer(_to, _value, empty);\n', '    }\n', '\n', '    /*\n', '    * @dev ERC223 method to transfer token to a specified address with data.\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    * @param _data Transaction metadata.\n', '    */\n', '    function transfer(address _to, uint256 _value, bytes _data) public validAddress(_to) returns (bool success) {\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // Call token fallback function if _to is a contract. Rejects if not implemented.\n', '        if (codeLength > 0) {\n', '            ERC223ReceivingContract(_to).tokenFallback(msg.sender, _value, _data);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // require (_value <= _allowance);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /*\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    // Events\n', '    event Mint(uint256 supply, address indexed to, uint256 amount);\n', '\n', '    function tokenTotalSupply() public pure returns (uint256);\n', '\n', '    /// @dev Allows the owner to mint new tokens\n', '    /// @param _to Address to mint the tokens to\n', '    /// @param _amount Amount of tokens that will be minted\n', '    /// @return Boolean to signify successful minting\n', '    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n', '        require(totalSupply.add(_amount) <= tokenTotalSupply());\n', '\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        emit Mint(totalSupply, _to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract BodhiEthereum is MintableToken {\n', '    // Token configurations\n', '    string public constant name = "Bodhi Ethereum";\n', '    string public constant symbol = "BOE";\n', '    uint256 public constant decimals = 8;\n', '\n', '    constructor() Ownable(msg.sender) public {\n', '    }\n', '\n', '    // 100 million BOE ever created\n', '    function tokenTotalSupply() public pure returns (uint256) {\n', '        return 100 * (10**6) * (10**decimals);\n', '    }\n', '}']
['/**\n', ' * @title ERC20 interface\n', ' * @dev Implements ERC20 Token Standard: https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(y != 0);\n', '        uint256 z = x / y;\n', '        assert(x == y * z + x % y);\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '/// @title Contract that will work with ERC223 tokens.\n', 'contract ERC223ReceivingContract { \n', '    /*\n', '    * @dev Standard ERC223 function that will handle incoming token transfers.\n', '    * @param _from Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint _value, bytes _data) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable contract\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control functions.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    // Events\n', '    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '    constructor(address _owner) public validAddress(_owner) {\n', '        owner = _owner;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param _newOwner The address to transfer ownership to.\n', '    function transferOwnership(address _newOwner) public onlyOwner validAddress(_newOwner) {\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC223 is ERC20 {\n', '    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n', '}\n', '\n', '\n', '\n', '\n', 'contract StandardToken is ERC223 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Modifiers\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * @dev ERC20 method to transfer token to a specified address.\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bytes memory empty;\n', '        transfer(_to, _value, empty);\n', '    }\n', '\n', '    /*\n', '    * @dev ERC223 method to transfer token to a specified address with data.\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    * @param _data Transaction metadata.\n', '    */\n', '    function transfer(address _to, uint256 _value, bytes _data) public validAddress(_to) returns (bool success) {\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            // Retrieve the size of the code on target address, this needs assembly\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // Call token fallback function if _to is a contract. Rejects if not implemented.\n', '        if (codeLength > 0) {\n', '            ERC223ReceivingContract(_to).tokenFallback(msg.sender, _value, _data);\n', '        }\n', '\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // require (_value <= _allowance);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /*\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '    // Events\n', '    event Mint(uint256 supply, address indexed to, uint256 amount);\n', '\n', '    function tokenTotalSupply() public pure returns (uint256);\n', '\n', '    /// @dev Allows the owner to mint new tokens\n', '    /// @param _to Address to mint the tokens to\n', '    /// @param _amount Amount of tokens that will be minted\n', '    /// @return Boolean to signify successful minting\n', '    function mint(address _to, uint256 _amount) external onlyOwner returns (bool) {\n', '        require(totalSupply.add(_amount) <= tokenTotalSupply());\n', '\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        emit Mint(totalSupply, _to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract BodhiEthereum is MintableToken {\n', '    // Token configurations\n', '    string public constant name = "Bodhi Ethereum";\n', '    string public constant symbol = "BOE";\n', '    uint256 public constant decimals = 8;\n', '\n', '    constructor() Ownable(msg.sender) public {\n', '    }\n', '\n', '    // 100 million BOE ever created\n', '    function tokenTotalSupply() public pure returns (uint256) {\n', '        return 100 * (10**6) * (10**decimals);\n', '    }\n', '}']
