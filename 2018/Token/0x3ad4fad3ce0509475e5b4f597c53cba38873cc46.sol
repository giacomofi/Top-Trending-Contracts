['pragma solidity ^0.4.16;\n', '\n', 'contract ERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public pure returns (string) {}\n', '    function symbol() public pure returns (string) {}\n', '    function decimals() public pure returns (uint8) {}\n', '    function totalSupply() public pure returns (uint256) {}\n', '    function balanceOf(address _owner) public pure returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public pure returns (uint256) { _owner; _spender; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract CommonWallet {\n', '    mapping(address => mapping (address => uint256)) public tokenBalance;\n', '    mapping(address => uint) etherBalance;\n', '    address owner = msg.sender;\n', '    \n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '    \n', '    function depoEther() public payable{\n', '        etherBalance[msg.sender]+=msg.value;\n', '    }\n', '    \n', '    function depoToken(address tokenAddr, uint256 amount) public {\n', '        if (ERC20Token(tokenAddr).transferFrom(msg.sender, this, amount))\n', '        {\n', '            tokenBalance[tokenAddr][msg.sender] = safeAdd(tokenBalance[tokenAddr][msg.sender], amount);\n', '        }\n', '    }\n', '  \n', '    function wdEther(uint amount) public{\n', '        require(etherBalance[msg.sender]>=amount);\n', '        address sender=msg.sender;\n', '        sender.transfer(amount);\n', '        etherBalance[sender] = safeSub(etherBalance[sender],amount);\n', '    }\n', '    \n', '    function wdToken(address tokenAddr, uint256 amount) public {\n', '        require(tokenBalance[tokenAddr][msg.sender] < amount);\n', '        if(ERC20Token(tokenAddr).transfer(msg.sender, amount))\n', '        {\n', '            tokenBalance[tokenAddr][msg.sender] = safeSub(tokenBalance[tokenAddr][msg.sender], amount);\n', '        }\n', '    }\n', '  \n', '    function getEtherBalance(address user) public view returns(uint256) {\n', '        return etherBalance[user];\n', '    }\n', '    \n', '    function getTokenBalance(address tokenAddr, address user) public view returns (uint256) {\n', '        return tokenBalance[tokenAddr][user];\n', '    }\n', '    \n', '    function sendEtherTo(address to_, uint amount) public {\n', '        require(etherBalance[msg.sender]>=amount);\n', '        require(to_!=msg.sender);\n', '        to_.transfer(amount);\n', '        etherBalance[msg.sender] = safeSub(etherBalance[msg.sender],amount);\n', '    }\n', '    \n', '    function sendTokenTo(address tokenAddr, address to_, uint256 amount) public {\n', '        require(tokenBalance[tokenAddr][msg.sender] < amount);\n', '        require(!ERC20Token(tokenAddr).transfer(to_, amount));\n', '        tokenBalance[tokenAddr][msg.sender] = safeSub(tokenBalance[tokenAddr][msg.sender], amount);\n', '    }\n', '}']