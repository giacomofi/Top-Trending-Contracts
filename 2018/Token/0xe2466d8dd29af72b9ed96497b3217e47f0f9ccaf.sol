['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure  returns(uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure  returns(uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure  returns(uint) {\n', '    uint c = a + b;\n', '    assert(c >= a && c >= b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    if (msg.sender != owner) revert();\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', 'contract Lpktransfer is Ownable {\n', '  using SafeMath for uint;\n', '  mapping(address => uint) balances;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '  function Lpktransfer() public {\n', '    /* balances[0x59c8185565d98c16175fb445e517af7f817fdf2c]=2600000000; */\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _tokens) external onlyOwner() returns (bool success) {\n', '    require(balances[_from] >= _tokens); // Check if the sender has enough\n', '    balances[_from] = balances[_from].sub(_tokens);\n', '    balances[_to] = balances[_to].add(_tokens);\n', '    Transfer(_from, _to, _tokens);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns(uint balance) {\n', '    return balances[_owner];\n', '  }\n', '}']