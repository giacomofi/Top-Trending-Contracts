['pragma solidity ^0.4.20;\n', '\n', 'contract GenesisProtected {\n', '    modifier addrNotNull(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The original code is taken from:\n', '// https://github.com/OpenZeppelin/zeppelin-solidity:\n', '//     master branch from zeppelin-solidity/contracts/ownership/Ownable.sol\n', '// Changed function name: transferOwnership -> setOwner.\n', '// Added inheritance from GenesisProtected (address != 0x0).\n', '// setOwner refactored for emitting after owner replacing.\n', '// ----------------------------------------------------------------------------\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is GenesisProtected {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a _new.\n', '     * @param a The address to transfer ownership to.\n', '     */\n', '    function setOwner(address a) external onlyOwner addrNotNull(a) {\n', '        owner = a;\n', '        emit OwnershipReplaced(msg.sender, a);\n', '    }\n', '\n', '    event OwnershipReplaced(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// The original code is taken from:\n', '// https://theethereum.wiki/w/index.php/ERC20_Token_Standard\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner)\n', '        public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender)\n', '        public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens)\n', '        public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens)\n', '        public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(\n', '        address indexed tokenOwner,\n', '        address indexed spender,\n', '        uint tokens\n', '    );\n', '}\n', '\n', 'contract Enums {\n', '    // Type for mapping uint (index) => name for baskets types described in WP\n', '    enum BasketType {\n', '        unknown, // 0 unknown\n', '        team, // 1 Team\n', '        foundation, // 2 Foundation\n', '        arr, // 3 Advertisement, Referral program, Reward\n', '        advisors, // 4 Advisors\n', '        bounty, // 5 Bounty\n', '        referral, // 6 Referral\n', '        referrer // 7 Referrer\n', '    }\n', '}\n', '\n', '\n', 'contract WPTokensBaskets is Ownable, Enums {\n', '    // This mapping holds all accounts ever used as baskets forever\n', '    mapping (address => BasketType) internal types;\n', '\n', '    // Baskets for tokens\n', '    address public team;\n', '    address public foundation;\n', '    address public arr;\n', '    address public advisors;\n', '    address public bounty;\n', '\n', '    // Public constructor\n', '    function WPTokensBaskets(\n', '        address _team,\n', '        address _foundation,\n', '        address _arr,\n', '        address _advisors,\n', '        address _bounty\n', '    )\n', '        public\n', '    {\n', '        setTeam(_team);\n', '        setFoundation(_foundation);\n', '        setARR(_arr);\n', '        setAdvisors(_advisors);\n', '        setBounty(_bounty);\n', '    }\n', '\n', '    // Fallback function - do not apply any ether to this contract.\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    // Last resort to return ether.\n', '    // See the last warning at\n', '    // http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    // for such cases.\n', '    function transferEtherTo(address a) external onlyOwner addrNotNull(a) {\n', '        a.transfer(address(this).balance);\n', '    }\n', '\n', '    function typeOf(address a) public view returns (BasketType) {\n', '        return types[a];\n', '    }\n', '\n', '    // Return truth if given address is not registered as token basket.\n', '    function isUnknown(address a) public view returns (bool) {\n', '        return types[a] == BasketType.unknown;\n', '    }\n', '\n', '    function isTeam(address a) public view returns (bool) {\n', '        return types[a] == BasketType.team;\n', '    }\n', '\n', '    function isFoundation(address a) public view returns (bool) {\n', '        return types[a] == BasketType.foundation;\n', '    }\n', '\n', '    function setTeam(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[team = a] = BasketType.team;\n', '    }\n', '\n', '    function setFoundation(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[foundation = a] = BasketType.foundation;\n', '    }\n', '\n', '    function setARR(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[arr = a] = BasketType.arr;\n', '    }\n', '\n', '    function setAdvisors(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[advisors = a] = BasketType.advisors;\n', '    }\n', '\n', '    function setBounty(address a) public onlyOwner addrNotNull(a) {\n', '        require(types[a] == BasketType.unknown);\n', '        types[bounty = a] = BasketType.bounty;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// The original code is taken from:\n', '// https://github.com/OpenZeppelin/zeppelin-solidity:\n', '//     master branch from zeppelin-solidity/contracts/math/SafeMath.sol\n', '// ----------------------------------------------------------------------------\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0)\n', '            return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is\n', '     * greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token is Ownable, ERC20Interface, Enums {\n', '    using SafeMath for uint;\n', '\n', '    // Token full name\n', '    string private constant NAME = "EnvisionX EXCHAIN Token";\n', '    // Token symbol name\n', '    string private constant SYMBOL = "EXT";\n', '    // Token max fraction, in decimal signs after the point\n', '    uint8 private constant DECIMALS = 18;\n', '\n', '    // Tokens max supply, in EXTwei\n', '    uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS));\n', '\n', '    // Tokens balances map\n', '    mapping(address => uint) internal balances;\n', '\n', '    // Maps with allowed amounts fot TransferFrom\n', '    mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '    // Total amount of issued tokens, in EXTwei\n', '    uint internal _totalSupply;\n', '\n', '    // Map with Ether founds amount by address (using when refunds)\n', '    mapping(address => uint) internal etherFunds;\n', '    uint internal _earnedFunds;\n', '    // Map with refunded addreses (Black List)\n', '    mapping(address => bool) internal refunded;\n', '\n', '    // Address of sale agent (a contract) which can mint new tokens\n', '    address public mintAgent;\n', '\n', '    // Token transfer allowed only when token minting is finished\n', '    bool public isMintingFinished = false;\n', '    // When minting was finished\n', '    uint public mintingStopDate;\n', '\n', '    // Total amount of tokens minted to team basket, in EXTwei.\n', '    // This will not include tokens, transferred to team basket\n', '    // after minting is finished.\n', '    uint public teamTotal;\n', '    // Amount of tokens spent by team in first 96 weeks since\n', '    // minting finish date. Used to calculate team spend\n', '    // restrictions according to ICO White Paper.\n', '    uint public spentByTeam;\n', '\n', '    // Address of WPTokensBaskets contract\n', '    WPTokensBaskets public wpTokensBaskets;\n', '\n', '    // Constructor\n', '    function Token(WPTokensBaskets baskets) public {\n', '        wpTokensBaskets = baskets;\n', '        mintAgent = owner;\n', '    }\n', '\n', '    // Fallback function - do not apply any ether to this contract.\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    // Last resort to return ether.\n', '    // See the last warning at\n', '    // http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    // for such cases.\n', '    function transferEtherTo(address a) external onlyOwner addrNotNull(a) {\n', '        a.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    ERC20 Interface implementation\n', '    */\n', '\n', '    // Return token full name\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '\n', '    // Return token symbol name\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    // Return amount of decimals after point\n', '    function decimals() public pure returns (uint8) {\n', '        return DECIMALS;\n', '    }\n', '\n', '    // Return total amount of issued tokens, in EXTwei\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Return account balance in tokens (in EXTwei)\n', '    function balanceOf(address _address) public constant returns (uint) {\n', '        return balances[_address];\n', '    }\n', '\n', '    // Transfer tokens to another account\n', '    function transfer(address to, uint value)\n', '        public\n', '        addrNotNull(to)\n', '        returns (bool)\n', '    {\n', '        if (balances[msg.sender] < value)\n', '            return false;\n', '        if (isFrozen(wpTokensBaskets.typeOf(msg.sender), value))\n', '            return false;\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        saveTeamSpent(msg.sender, value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    // Transfer tokens from one account to another,\n', '    // using permissions defined with approve() method.\n', '    function transferFrom(address from, address to, uint value)\n', '        public\n', '        addrNotNull(to)\n', '        returns (bool)\n', '    {\n', '        if (balances[from] < value)\n', '            return false;\n', '        if (allowance(from, msg.sender) < value)\n', '            return false;\n', '        if (isFrozen(wpTokensBaskets.typeOf(from), value))\n', '            return false;\n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        saveTeamSpent(from, value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    // Allow to transfer given amount of tokens (in EXTwei)\n', '    // to account which is not owner.\n', '    function approve(address spender, uint value) public returns (bool) {\n', '        if (msg.sender == spender)\n', '            return false;\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Return amount of tokens (in EXTwei) which allowed to\n', '    // be transferred by non-owner spender\n', '    function allowance(address _owner, address spender)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][spender];\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Other methods\n', '    */\n', '\n', '    // Return account funds in ether (in wei)\n', '    function etherFundsOf(address _address) public constant returns (uint) {\n', '        return etherFunds[_address];\n', '    }\n', '\n', '    // Return total amount of funded ether, in wei\n', '    function earnedFunds() public constant returns (uint) {\n', '        return _earnedFunds;\n', '    }\n', '\n', '    // Return true if given address have been refunded\n', '    function isRefunded(address _address) public view returns (bool) {\n', '        return refunded[_address];\n', '    }\n', '\n', '    // Set new address of sale agent contract.\n', '    // Will be called for each sale stage: PrivateSale, PreSale, MainSale.\n', '    function setMintAgent(address a) public onlyOwner addrNotNull(a) {\n', '        emit MintAgentReplaced(mintAgent, a);\n', '        mintAgent = a;\n', '    }\n', '\n', '    // Interface for sale agent contract - mint new tokens\n', '    function mint(address to, uint256 extAmount, uint256 etherAmount) public {\n', '        require(!isMintingFinished);\n', '        require(msg.sender == mintAgent);\n', '        require(!refunded[to]);\n', '        _totalSupply = _totalSupply.add(extAmount);\n', '        require(_totalSupply <= MAX_SUPPLY);\n', '        balances[to] = balances[to].add(extAmount);\n', '        if (wpTokensBaskets.isUnknown(to)) {\n', '            _earnedFunds = _earnedFunds.add(etherAmount);\n', '            etherFunds[to] = etherFunds[to].add(etherAmount);\n', '        } else if (wpTokensBaskets.isTeam(to)) {\n', '            teamTotal = teamTotal.add(extAmount);\n', '        }\n', '        emit Mint(to, extAmount);\n', '        emit Transfer(msg.sender, to, extAmount);\n', '    }\n', '\n', '    // Destroy minted tokens and refund ether spent by investor.\n', '    // Used in AML (Anti Money Laundering) workflow.\n', '    // Will be called only by humans because there is no way\n', '    // to withdraw crowdfunded ether from Beneficiary account\n', '    // from context of this account.\n', '    // Important note: all tokens minted to team, foundation etc.\n', '    // will NOT be burned, because they in general are spent\n', '    // during the sale and its too expensive to track all these\n', '    // transactions.\n', '    function burnTokensAndRefund(address _address)\n', '        external\n', '        payable\n', '        addrNotNull(_address)\n', '        onlyOwner()\n', '    {\n', '        require(msg.value > 0 && msg.value == etherFunds[_address]);\n', '        _totalSupply = _totalSupply.sub(balances[_address]);\n', '        balances[_address] = 0;\n', '        _earnedFunds = _earnedFunds.sub(msg.value);\n', '        etherFunds[_address] = 0;\n', '        refunded[_address] = true;\n', '        _address.transfer(msg.value);\n', '    }\n', '\n', '    // Stop tokens minting forever.\n', '    function finishMinting() external onlyOwner {\n', '        require(!isMintingFinished);\n', '        isMintingFinished = true;\n', '        mintingStopDate = now;\n', '        emit MintingFinished();\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Tokens freeze logic, according to ICO White Paper\n', '    */\n', '\n', '    // Return truth if given _value amount of tokens (in EXTwei)\n', '    // cannot be transferred from account due to spend restrictions\n', '    // defined in ICO White Paper.\n', '    // !!!Caveat of current implementaion!!!\n', '    // Say,\n', '    //  1. There was 100 tokens minted to the team basket;\n', '    //  2. Minting was finished and 24 weeks elapsed, and now\n', '    //    team can spend up to 25 tokens till next 24 weeks;\n', '    //  3. Someone transfers another 100 tokens to the team basket;\n', '    //  4. ...\n', '    // Problem is, actually, you can&#39;t spend any of these extra 100\n', '    // tokens until 96 weeks will elapse since minting finish date.\n', '    // That&#39;s because after next 24 weeks will be unlocked only\n', '    // 25 tokens more (25% of *minted* tokens) and so on.\n', '    // So, DO NOT send tokens to the team basket until 96 weeks elapse!\n', '    function isFrozen(\n', '        BasketType _basketType,\n', '        uint _value\n', '    )\n', '        public view returns (bool)\n', '    {\n', '        if (!isMintingFinished) {\n', '            // Allow spend only after minting is finished\n', '            return true;\n', '        }\n', '        if (_basketType == BasketType.foundation) {\n', '            // Allow to spend foundation tokens only after\n', '            // 48 weeks after minting is finished\n', '            return now < mintingStopDate + 48 weeks;\n', '        }\n', '        if (_basketType == BasketType.team) {\n', '            // Team allowed to spend tokens:\n', '            //  25%  - after minting finished date + 24 weeks;\n', '            //  50%  - after minting finished date + 48 weeks;\n', '            //  75%  - after minting finished date + 72 weeks;\n', '            //  100% - after minting finished date + 96 weeks.\n', '            if (mintingStopDate + 96 weeks <= now) {\n', '                return false;\n', '            }\n', '            if (now < mintingStopDate + 24 weeks)\n', '                return true;\n', '            // Calculate fraction as percents multipled to 10^10.\n', '            // Without this owner will be able to spend fractions\n', '            // less than 1% per transaction.\n', '            uint fractionSpent =\n', '                spentByTeam.add(_value).mul(1000000000000).div(teamTotal);\n', '            if (now < mintingStopDate + 48 weeks) {\n', '                return 250000000000 < fractionSpent;\n', '            }\n', '            if (now < mintingStopDate + 72 weeks) {\n', '                return 500000000000 < fractionSpent;\n', '            }\n', '            // from 72 to 96 weeks elapsed\n', '            return 750000000000 < fractionSpent;\n', '        }\n', '        // No restrictions for other token holders\n', '        return false;\n', '    }\n', '\n', '    // Save amount of spent tokens by team till 96 weeks after minting\n', '    // finish date. This is vital because without the check we&#39;ll eventually\n', '    // overflow the uint256.\n', '    function saveTeamSpent(address _owner, uint _value) internal {\n', '        if (wpTokensBaskets.isTeam(_owner)) {\n', '            if (now < mintingStopDate + 96 weeks)\n', '                spentByTeam = spentByTeam.add(_value);\n', '        }\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Events\n', '    */\n', '\n', '    // Emitted when mint agent (address of a sale contract)\n', '    // replaced with new one\n', '    event MintAgentReplaced(\n', '        address indexed previousMintAgent,\n', '        address indexed newMintAgent\n', '    );\n', '\n', '    // Emitted when new tokens were created and funded to account\n', '    event Mint(address indexed to, uint256 amount);\n', '\n', '    // Emitted when tokens minting is finished.\n', '    event MintingFinished();\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract GenesisProtected {\n', '    modifier addrNotNull(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The original code is taken from:\n', '// https://github.com/OpenZeppelin/zeppelin-solidity:\n', '//     master branch from zeppelin-solidity/contracts/ownership/Ownable.sol\n', '// Changed function name: transferOwnership -> setOwner.\n', '// Added inheritance from GenesisProtected (address != 0x0).\n', '// setOwner refactored for emitting after owner replacing.\n', '// ----------------------------------------------------------------------------\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is GenesisProtected {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a _new.\n', '     * @param a The address to transfer ownership to.\n', '     */\n', '    function setOwner(address a) external onlyOwner addrNotNull(a) {\n', '        owner = a;\n', '        emit OwnershipReplaced(msg.sender, a);\n', '    }\n', '\n', '    event OwnershipReplaced(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// The original code is taken from:\n', '// https://theethereum.wiki/w/index.php/ERC20_Token_Standard\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner)\n', '        public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender)\n', '        public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens)\n', '        public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens)\n', '        public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(\n', '        address indexed tokenOwner,\n', '        address indexed spender,\n', '        uint tokens\n', '    );\n', '}\n', '\n', 'contract Enums {\n', '    // Type for mapping uint (index) => name for baskets types described in WP\n', '    enum BasketType {\n', '        unknown, // 0 unknown\n', '        team, // 1 Team\n', '        foundation, // 2 Foundation\n', '        arr, // 3 Advertisement, Referral program, Reward\n', '        advisors, // 4 Advisors\n', '        bounty, // 5 Bounty\n', '        referral, // 6 Referral\n', '        referrer // 7 Referrer\n', '    }\n', '}\n', '\n', '\n', 'contract WPTokensBaskets is Ownable, Enums {\n', '    // This mapping holds all accounts ever used as baskets forever\n', '    mapping (address => BasketType) internal types;\n', '\n', '    // Baskets for tokens\n', '    address public team;\n', '    address public foundation;\n', '    address public arr;\n', '    address public advisors;\n', '    address public bounty;\n', '\n', '    // Public constructor\n', '    function WPTokensBaskets(\n', '        address _team,\n', '        address _foundation,\n', '        address _arr,\n', '        address _advisors,\n', '        address _bounty\n', '    )\n', '        public\n', '    {\n', '        setTeam(_team);\n', '        setFoundation(_foundation);\n', '        setARR(_arr);\n', '        setAdvisors(_advisors);\n', '        setBounty(_bounty);\n', '    }\n', '\n', '    // Fallback function - do not apply any ether to this contract.\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    // Last resort to return ether.\n', '    // See the last warning at\n', '    // http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    // for such cases.\n', '    function transferEtherTo(address a) external onlyOwner addrNotNull(a) {\n', '        a.transfer(address(this).balance);\n', '    }\n', '\n', '    function typeOf(address a) public view returns (BasketType) {\n', '        return types[a];\n', '    }\n', '\n', '    // Return truth if given address is not registered as token basket.\n', '    function isUnknown(address a) public view returns (bool) {\n', '        return types[a] == BasketType.unknown;\n', '    }\n', '\n', '    function isTeam(address a) public view returns (bool) {\n', '        return types[a] == BasketType.team;\n', '    }\n', '\n', '    function isFoundation(address a) public view returns (bool) {\n', '        return types[a] == BasketType.foundation;\n', '    }\n', '\n', '    function setTeam(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[team = a] = BasketType.team;\n', '    }\n', '\n', '    function setFoundation(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[foundation = a] = BasketType.foundation;\n', '    }\n', '\n', '    function setARR(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[arr = a] = BasketType.arr;\n', '    }\n', '\n', '    function setAdvisors(address a) public onlyOwner addrNotNull(a) {\n', '        require(isUnknown(a));\n', '        types[advisors = a] = BasketType.advisors;\n', '    }\n', '\n', '    function setBounty(address a) public onlyOwner addrNotNull(a) {\n', '        require(types[a] == BasketType.unknown);\n', '        types[bounty = a] = BasketType.bounty;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// The original code is taken from:\n', '// https://github.com/OpenZeppelin/zeppelin-solidity:\n', '//     master branch from zeppelin-solidity/contracts/math/SafeMath.sol\n', '// ----------------------------------------------------------------------------\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0)\n', '            return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is\n', '     * greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Token is Ownable, ERC20Interface, Enums {\n', '    using SafeMath for uint;\n', '\n', '    // Token full name\n', '    string private constant NAME = "EnvisionX EXCHAIN Token";\n', '    // Token symbol name\n', '    string private constant SYMBOL = "EXT";\n', '    // Token max fraction, in decimal signs after the point\n', '    uint8 private constant DECIMALS = 18;\n', '\n', '    // Tokens max supply, in EXTwei\n', '    uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS));\n', '\n', '    // Tokens balances map\n', '    mapping(address => uint) internal balances;\n', '\n', '    // Maps with allowed amounts fot TransferFrom\n', '    mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '    // Total amount of issued tokens, in EXTwei\n', '    uint internal _totalSupply;\n', '\n', '    // Map with Ether founds amount by address (using when refunds)\n', '    mapping(address => uint) internal etherFunds;\n', '    uint internal _earnedFunds;\n', '    // Map with refunded addreses (Black List)\n', '    mapping(address => bool) internal refunded;\n', '\n', '    // Address of sale agent (a contract) which can mint new tokens\n', '    address public mintAgent;\n', '\n', '    // Token transfer allowed only when token minting is finished\n', '    bool public isMintingFinished = false;\n', '    // When minting was finished\n', '    uint public mintingStopDate;\n', '\n', '    // Total amount of tokens minted to team basket, in EXTwei.\n', '    // This will not include tokens, transferred to team basket\n', '    // after minting is finished.\n', '    uint public teamTotal;\n', '    // Amount of tokens spent by team in first 96 weeks since\n', '    // minting finish date. Used to calculate team spend\n', '    // restrictions according to ICO White Paper.\n', '    uint public spentByTeam;\n', '\n', '    // Address of WPTokensBaskets contract\n', '    WPTokensBaskets public wpTokensBaskets;\n', '\n', '    // Constructor\n', '    function Token(WPTokensBaskets baskets) public {\n', '        wpTokensBaskets = baskets;\n', '        mintAgent = owner;\n', '    }\n', '\n', '    // Fallback function - do not apply any ether to this contract.\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    // Last resort to return ether.\n', '    // See the last warning at\n', '    // http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    // for such cases.\n', '    function transferEtherTo(address a) external onlyOwner addrNotNull(a) {\n', '        a.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    ERC20 Interface implementation\n', '    */\n', '\n', '    // Return token full name\n', '    function name() public pure returns (string) {\n', '        return NAME;\n', '    }\n', '\n', '    // Return token symbol name\n', '    function symbol() public pure returns (string) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    // Return amount of decimals after point\n', '    function decimals() public pure returns (uint8) {\n', '        return DECIMALS;\n', '    }\n', '\n', '    // Return total amount of issued tokens, in EXTwei\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Return account balance in tokens (in EXTwei)\n', '    function balanceOf(address _address) public constant returns (uint) {\n', '        return balances[_address];\n', '    }\n', '\n', '    // Transfer tokens to another account\n', '    function transfer(address to, uint value)\n', '        public\n', '        addrNotNull(to)\n', '        returns (bool)\n', '    {\n', '        if (balances[msg.sender] < value)\n', '            return false;\n', '        if (isFrozen(wpTokensBaskets.typeOf(msg.sender), value))\n', '            return false;\n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        saveTeamSpent(msg.sender, value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    // Transfer tokens from one account to another,\n', '    // using permissions defined with approve() method.\n', '    function transferFrom(address from, address to, uint value)\n', '        public\n', '        addrNotNull(to)\n', '        returns (bool)\n', '    {\n', '        if (balances[from] < value)\n', '            return false;\n', '        if (allowance(from, msg.sender) < value)\n', '            return false;\n', '        if (isFrozen(wpTokensBaskets.typeOf(from), value))\n', '            return false;\n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        saveTeamSpent(from, value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    // Allow to transfer given amount of tokens (in EXTwei)\n', '    // to account which is not owner.\n', '    function approve(address spender, uint value) public returns (bool) {\n', '        if (msg.sender == spender)\n', '            return false;\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Return amount of tokens (in EXTwei) which allowed to\n', '    // be transferred by non-owner spender\n', '    function allowance(address _owner, address spender)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][spender];\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Other methods\n', '    */\n', '\n', '    // Return account funds in ether (in wei)\n', '    function etherFundsOf(address _address) public constant returns (uint) {\n', '        return etherFunds[_address];\n', '    }\n', '\n', '    // Return total amount of funded ether, in wei\n', '    function earnedFunds() public constant returns (uint) {\n', '        return _earnedFunds;\n', '    }\n', '\n', '    // Return true if given address have been refunded\n', '    function isRefunded(address _address) public view returns (bool) {\n', '        return refunded[_address];\n', '    }\n', '\n', '    // Set new address of sale agent contract.\n', '    // Will be called for each sale stage: PrivateSale, PreSale, MainSale.\n', '    function setMintAgent(address a) public onlyOwner addrNotNull(a) {\n', '        emit MintAgentReplaced(mintAgent, a);\n', '        mintAgent = a;\n', '    }\n', '\n', '    // Interface for sale agent contract - mint new tokens\n', '    function mint(address to, uint256 extAmount, uint256 etherAmount) public {\n', '        require(!isMintingFinished);\n', '        require(msg.sender == mintAgent);\n', '        require(!refunded[to]);\n', '        _totalSupply = _totalSupply.add(extAmount);\n', '        require(_totalSupply <= MAX_SUPPLY);\n', '        balances[to] = balances[to].add(extAmount);\n', '        if (wpTokensBaskets.isUnknown(to)) {\n', '            _earnedFunds = _earnedFunds.add(etherAmount);\n', '            etherFunds[to] = etherFunds[to].add(etherAmount);\n', '        } else if (wpTokensBaskets.isTeam(to)) {\n', '            teamTotal = teamTotal.add(extAmount);\n', '        }\n', '        emit Mint(to, extAmount);\n', '        emit Transfer(msg.sender, to, extAmount);\n', '    }\n', '\n', '    // Destroy minted tokens and refund ether spent by investor.\n', '    // Used in AML (Anti Money Laundering) workflow.\n', '    // Will be called only by humans because there is no way\n', '    // to withdraw crowdfunded ether from Beneficiary account\n', '    // from context of this account.\n', '    // Important note: all tokens minted to team, foundation etc.\n', '    // will NOT be burned, because they in general are spent\n', '    // during the sale and its too expensive to track all these\n', '    // transactions.\n', '    function burnTokensAndRefund(address _address)\n', '        external\n', '        payable\n', '        addrNotNull(_address)\n', '        onlyOwner()\n', '    {\n', '        require(msg.value > 0 && msg.value == etherFunds[_address]);\n', '        _totalSupply = _totalSupply.sub(balances[_address]);\n', '        balances[_address] = 0;\n', '        _earnedFunds = _earnedFunds.sub(msg.value);\n', '        etherFunds[_address] = 0;\n', '        refunded[_address] = true;\n', '        _address.transfer(msg.value);\n', '    }\n', '\n', '    // Stop tokens minting forever.\n', '    function finishMinting() external onlyOwner {\n', '        require(!isMintingFinished);\n', '        isMintingFinished = true;\n', '        mintingStopDate = now;\n', '        emit MintingFinished();\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Tokens freeze logic, according to ICO White Paper\n', '    */\n', '\n', '    // Return truth if given _value amount of tokens (in EXTwei)\n', '    // cannot be transferred from account due to spend restrictions\n', '    // defined in ICO White Paper.\n', '    // !!!Caveat of current implementaion!!!\n', '    // Say,\n', '    //  1. There was 100 tokens minted to the team basket;\n', '    //  2. Minting was finished and 24 weeks elapsed, and now\n', '    //    team can spend up to 25 tokens till next 24 weeks;\n', '    //  3. Someone transfers another 100 tokens to the team basket;\n', '    //  4. ...\n', "    // Problem is, actually, you can't spend any of these extra 100\n", '    // tokens until 96 weeks will elapse since minting finish date.\n', "    // That's because after next 24 weeks will be unlocked only\n", '    // 25 tokens more (25% of *minted* tokens) and so on.\n', '    // So, DO NOT send tokens to the team basket until 96 weeks elapse!\n', '    function isFrozen(\n', '        BasketType _basketType,\n', '        uint _value\n', '    )\n', '        public view returns (bool)\n', '    {\n', '        if (!isMintingFinished) {\n', '            // Allow spend only after minting is finished\n', '            return true;\n', '        }\n', '        if (_basketType == BasketType.foundation) {\n', '            // Allow to spend foundation tokens only after\n', '            // 48 weeks after minting is finished\n', '            return now < mintingStopDate + 48 weeks;\n', '        }\n', '        if (_basketType == BasketType.team) {\n', '            // Team allowed to spend tokens:\n', '            //  25%  - after minting finished date + 24 weeks;\n', '            //  50%  - after minting finished date + 48 weeks;\n', '            //  75%  - after minting finished date + 72 weeks;\n', '            //  100% - after minting finished date + 96 weeks.\n', '            if (mintingStopDate + 96 weeks <= now) {\n', '                return false;\n', '            }\n', '            if (now < mintingStopDate + 24 weeks)\n', '                return true;\n', '            // Calculate fraction as percents multipled to 10^10.\n', '            // Without this owner will be able to spend fractions\n', '            // less than 1% per transaction.\n', '            uint fractionSpent =\n', '                spentByTeam.add(_value).mul(1000000000000).div(teamTotal);\n', '            if (now < mintingStopDate + 48 weeks) {\n', '                return 250000000000 < fractionSpent;\n', '            }\n', '            if (now < mintingStopDate + 72 weeks) {\n', '                return 500000000000 < fractionSpent;\n', '            }\n', '            // from 72 to 96 weeks elapsed\n', '            return 750000000000 < fractionSpent;\n', '        }\n', '        // No restrictions for other token holders\n', '        return false;\n', '    }\n', '\n', '    // Save amount of spent tokens by team till 96 weeks after minting\n', "    // finish date. This is vital because without the check we'll eventually\n", '    // overflow the uint256.\n', '    function saveTeamSpent(address _owner, uint _value) internal {\n', '        if (wpTokensBaskets.isTeam(_owner)) {\n', '            if (now < mintingStopDate + 96 weeks)\n', '                spentByTeam = spentByTeam.add(_value);\n', '        }\n', '    }\n', '\n', '    /**\n', '    ----------------------------------------------------------------------\n', '    Events\n', '    */\n', '\n', '    // Emitted when mint agent (address of a sale contract)\n', '    // replaced with new one\n', '    event MintAgentReplaced(\n', '        address indexed previousMintAgent,\n', '        address indexed newMintAgent\n', '    );\n', '\n', '    // Emitted when new tokens were created and funded to account\n', '    event Mint(address indexed to, uint256 amount);\n', '\n', '    // Emitted when tokens minting is finished.\n', '    event MintingFinished();\n', '}']
