['pragma solidity ^0.4.21;\n', '\n', '// zeppelin-solidity: 1.9.0\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Membership is Ownable {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => bool) public isAdmin;\n', '  mapping(address => uint) public userToMemberIndex;\n', '  mapping(uint => uint[]) public tierToMemberIndexes;\n', '\n', '  struct Member {\n', '    address addr;\n', '    uint tier;\n', '    uint tierIndex;\n', '    uint memberIndex;\n', '  }\n', '\n', '  Member[] private members;\n', '\n', '  event NewMember(address user, uint tier);\n', '  event UpdatedMemberTier(address user, uint oldTier, uint newTier);\n', '  event RemovedMember(address user, uint tier);\n', '\n', '  modifier onlyAdmin() {\n', '    require(isAdmin[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier isValidTier(uint _tier) {\n', '    require(_tier >= 1 && _tier <= 4);\n', '    _;\n', '  }\n', '\n', '  modifier notTryingToChangeFromTier1(address _user, uint _tier) {\n', '    require(members[userToMemberIndex[_user]].tier != _tier);\n', '    _;\n', '  }\n', '\n', '\n', '  modifier isMember(address _user) {\n', '    require(userToMemberIndex[_user] != 0);\n', '    _;\n', '  }\n', '\n', '  modifier isValidAddr(address _trgt) {\n', '    require(_trgt != address(0));\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    Member memory member = Member(address(0), 0, 0, 0);\n', '    members.push(member);\n', '  }\n', '\n', '  function addAdmin(address _user)\n', '    external\n', '    onlyOwner\n', '  {\n', '    isAdmin[_user] = true;\n', '  }\n', '\n', '  function removeMember(address _user)\n', '    external\n', '    onlyAdmin\n', '    isValidAddr(_user)\n', '    isMember(_user)\n', '  {\n', '    uint index = userToMemberIndex[_user];\n', '    require(index != 0);\n', '\n', '    Member memory removingMember = members[index];\n', '\n', '    uint tier = removingMember.tier;\n', '\n', '    uint lastTierIndex = tierToMemberIndexes[removingMember.tier].length - 1;\n', '    uint lastTierMemberIndex = tierToMemberIndexes[removingMember.tier][lastTierIndex];\n', '    Member storage lastTierMember = members[lastTierMemberIndex];\n', '    lastTierMember.tierIndex = removingMember.tierIndex;\n', '    tierToMemberIndexes[removingMember.tier][removingMember.tierIndex] = lastTierMember.memberIndex;\n', '    tierToMemberIndexes[removingMember.tier].length--;\n', '\n', '    Member storage lastMember = members[members.length - 1];\n', '    if (lastMember.addr != removingMember.addr) {\n', '      userToMemberIndex[lastMember.addr] = removingMember.memberIndex;\n', '      tierToMemberIndexes[lastMember.tier][lastMember.tierIndex] = removingMember.memberIndex;\n', '      lastMember.memberIndex = removingMember.memberIndex;\n', '      members[removingMember.memberIndex] = lastMember;\n', '    }\n', '    userToMemberIndex[removingMember.addr] = 0;\n', '    members.length--;\n', '\n', '    emit RemovedMember(_user, tier);\n', '  }\n', '\n', '  function addNewMember(address _user, uint _tier)\n', '    internal\n', '  {\n', '    // it&#39;s a new member\n', '    uint memberIndex = members.length; // + 1; // add 1 to keep index 0 unoccupied\n', '    uint tierIndex = tierToMemberIndexes[_tier].length;\n', '\n', '    Member memory newMember = Member(_user, _tier, tierIndex, memberIndex);\n', '\n', '    members.push(newMember);\n', '    userToMemberIndex[_user] = memberIndex;\n', '    tierToMemberIndexes[_tier].push(memberIndex);\n', '\n', '    emit NewMember(_user, _tier);\n', '  }\n', '\n', '  function updateExistingMember(address _user, uint _newTier)\n', '    internal\n', '  {\n', '    // this user is a member in another tier, remove him from that tier,\n', '    // and add him to the new tier\n', '    Member storage existingMember = members[userToMemberIndex[_user]];\n', '\n', '    uint oldTier = existingMember.tier;\n', '    uint tierIndex = existingMember.tierIndex;\n', '    uint lastTierIndex = tierToMemberIndexes[oldTier].length - 1;\n', '\n', '    if (tierToMemberIndexes[oldTier].length > 1 && tierIndex != lastTierIndex) {\n', '      Member storage lastMember = members[tierToMemberIndexes[oldTier][lastTierIndex]];\n', '      tierToMemberIndexes[oldTier][tierIndex] = lastMember.memberIndex;\n', '      lastMember.tierIndex = tierIndex;\n', '    }\n', '\n', '    tierToMemberIndexes[oldTier].length--;\n', '    tierToMemberIndexes[_newTier].push(existingMember.memberIndex);\n', '\n', '    existingMember.tier = _newTier;\n', '    existingMember.tierIndex = tierToMemberIndexes[_newTier].length - 1;\n', '\n', '    emit UpdatedMemberTier(_user, oldTier, _newTier);\n', '  }\n', '\n', '  function setMemberTier(address _user, uint _tier)\n', '    external\n', '    onlyAdmin\n', '    isValidAddr(_user)\n', '    isValidTier(_tier)\n', '  {\n', '    if (userToMemberIndex[_user] == 0) {\n', '      addNewMember(_user, _tier);\n', '    } else {\n', '      uint currentTier = members[userToMemberIndex[_user]].tier;\n', '      if (currentTier != _tier) {\n', '        // user&#39;s in tier 1 are lifetime tier 1 users\n', '        require(currentTier != 1);\n', '\n', '        updateExistingMember(_user, _tier);\n', '      }\n', '    }\n', '  }\n', '\n', '  function getTierOfMember(address _user)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return members[userToMemberIndex[_user]].tier;\n', '  }\n', '\n', '  function getMembersOfTier(uint _tier)\n', '    external\n', '    view\n', '    returns (address[])\n', '  {\n', '    address[] memory addressesOfTier = new address[](tierToMemberIndexes[_tier].length);\n', '\n', '    for (uint i = 0; i < tierToMemberIndexes[_tier].length; i++) {\n', '      addressesOfTier[i] = members[tierToMemberIndexes[_tier][i]].addr;\n', '    }\n', '\n', '    return addressesOfTier;\n', '  }\n', '\n', '  function getMembersOfTierCount(uint _tier)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return tierToMemberIndexes[_tier].length;\n', '  }\n', '\n', '  function getMembersCount()\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    if (members.length == 0) {\n', '      return 0;\n', '    } else {\n', '      // remove sentinel at index zero from count\n', '      return members.length - 1;\n', '    }\n', '  }\n', '\n', '  function getMemberByIdx(uint _idx)\n', '    external\n', '    view\n', '    returns (address, uint)\n', '  {\n', '    Member memory member = members[_idx];\n', '\n', '    return (member.addr, member.tier);\n', '  }\n', '\n', '  function isUserMember(address _user)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return userToMemberIndex[_user] != 0;\n', '  }\n', '\n', '  function getMemberIdxOfUser(address _user)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return userToMemberIndex[_user];\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// zeppelin-solidity: 1.9.0\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Membership is Ownable {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => bool) public isAdmin;\n', '  mapping(address => uint) public userToMemberIndex;\n', '  mapping(uint => uint[]) public tierToMemberIndexes;\n', '\n', '  struct Member {\n', '    address addr;\n', '    uint tier;\n', '    uint tierIndex;\n', '    uint memberIndex;\n', '  }\n', '\n', '  Member[] private members;\n', '\n', '  event NewMember(address user, uint tier);\n', '  event UpdatedMemberTier(address user, uint oldTier, uint newTier);\n', '  event RemovedMember(address user, uint tier);\n', '\n', '  modifier onlyAdmin() {\n', '    require(isAdmin[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  modifier isValidTier(uint _tier) {\n', '    require(_tier >= 1 && _tier <= 4);\n', '    _;\n', '  }\n', '\n', '  modifier notTryingToChangeFromTier1(address _user, uint _tier) {\n', '    require(members[userToMemberIndex[_user]].tier != _tier);\n', '    _;\n', '  }\n', '\n', '\n', '  modifier isMember(address _user) {\n', '    require(userToMemberIndex[_user] != 0);\n', '    _;\n', '  }\n', '\n', '  modifier isValidAddr(address _trgt) {\n', '    require(_trgt != address(0));\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    Member memory member = Member(address(0), 0, 0, 0);\n', '    members.push(member);\n', '  }\n', '\n', '  function addAdmin(address _user)\n', '    external\n', '    onlyOwner\n', '  {\n', '    isAdmin[_user] = true;\n', '  }\n', '\n', '  function removeMember(address _user)\n', '    external\n', '    onlyAdmin\n', '    isValidAddr(_user)\n', '    isMember(_user)\n', '  {\n', '    uint index = userToMemberIndex[_user];\n', '    require(index != 0);\n', '\n', '    Member memory removingMember = members[index];\n', '\n', '    uint tier = removingMember.tier;\n', '\n', '    uint lastTierIndex = tierToMemberIndexes[removingMember.tier].length - 1;\n', '    uint lastTierMemberIndex = tierToMemberIndexes[removingMember.tier][lastTierIndex];\n', '    Member storage lastTierMember = members[lastTierMemberIndex];\n', '    lastTierMember.tierIndex = removingMember.tierIndex;\n', '    tierToMemberIndexes[removingMember.tier][removingMember.tierIndex] = lastTierMember.memberIndex;\n', '    tierToMemberIndexes[removingMember.tier].length--;\n', '\n', '    Member storage lastMember = members[members.length - 1];\n', '    if (lastMember.addr != removingMember.addr) {\n', '      userToMemberIndex[lastMember.addr] = removingMember.memberIndex;\n', '      tierToMemberIndexes[lastMember.tier][lastMember.tierIndex] = removingMember.memberIndex;\n', '      lastMember.memberIndex = removingMember.memberIndex;\n', '      members[removingMember.memberIndex] = lastMember;\n', '    }\n', '    userToMemberIndex[removingMember.addr] = 0;\n', '    members.length--;\n', '\n', '    emit RemovedMember(_user, tier);\n', '  }\n', '\n', '  function addNewMember(address _user, uint _tier)\n', '    internal\n', '  {\n', "    // it's a new member\n", '    uint memberIndex = members.length; // + 1; // add 1 to keep index 0 unoccupied\n', '    uint tierIndex = tierToMemberIndexes[_tier].length;\n', '\n', '    Member memory newMember = Member(_user, _tier, tierIndex, memberIndex);\n', '\n', '    members.push(newMember);\n', '    userToMemberIndex[_user] = memberIndex;\n', '    tierToMemberIndexes[_tier].push(memberIndex);\n', '\n', '    emit NewMember(_user, _tier);\n', '  }\n', '\n', '  function updateExistingMember(address _user, uint _newTier)\n', '    internal\n', '  {\n', '    // this user is a member in another tier, remove him from that tier,\n', '    // and add him to the new tier\n', '    Member storage existingMember = members[userToMemberIndex[_user]];\n', '\n', '    uint oldTier = existingMember.tier;\n', '    uint tierIndex = existingMember.tierIndex;\n', '    uint lastTierIndex = tierToMemberIndexes[oldTier].length - 1;\n', '\n', '    if (tierToMemberIndexes[oldTier].length > 1 && tierIndex != lastTierIndex) {\n', '      Member storage lastMember = members[tierToMemberIndexes[oldTier][lastTierIndex]];\n', '      tierToMemberIndexes[oldTier][tierIndex] = lastMember.memberIndex;\n', '      lastMember.tierIndex = tierIndex;\n', '    }\n', '\n', '    tierToMemberIndexes[oldTier].length--;\n', '    tierToMemberIndexes[_newTier].push(existingMember.memberIndex);\n', '\n', '    existingMember.tier = _newTier;\n', '    existingMember.tierIndex = tierToMemberIndexes[_newTier].length - 1;\n', '\n', '    emit UpdatedMemberTier(_user, oldTier, _newTier);\n', '  }\n', '\n', '  function setMemberTier(address _user, uint _tier)\n', '    external\n', '    onlyAdmin\n', '    isValidAddr(_user)\n', '    isValidTier(_tier)\n', '  {\n', '    if (userToMemberIndex[_user] == 0) {\n', '      addNewMember(_user, _tier);\n', '    } else {\n', '      uint currentTier = members[userToMemberIndex[_user]].tier;\n', '      if (currentTier != _tier) {\n', "        // user's in tier 1 are lifetime tier 1 users\n", '        require(currentTier != 1);\n', '\n', '        updateExistingMember(_user, _tier);\n', '      }\n', '    }\n', '  }\n', '\n', '  function getTierOfMember(address _user)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return members[userToMemberIndex[_user]].tier;\n', '  }\n', '\n', '  function getMembersOfTier(uint _tier)\n', '    external\n', '    view\n', '    returns (address[])\n', '  {\n', '    address[] memory addressesOfTier = new address[](tierToMemberIndexes[_tier].length);\n', '\n', '    for (uint i = 0; i < tierToMemberIndexes[_tier].length; i++) {\n', '      addressesOfTier[i] = members[tierToMemberIndexes[_tier][i]].addr;\n', '    }\n', '\n', '    return addressesOfTier;\n', '  }\n', '\n', '  function getMembersOfTierCount(uint _tier)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return tierToMemberIndexes[_tier].length;\n', '  }\n', '\n', '  function getMembersCount()\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    if (members.length == 0) {\n', '      return 0;\n', '    } else {\n', '      // remove sentinel at index zero from count\n', '      return members.length - 1;\n', '    }\n', '  }\n', '\n', '  function getMemberByIdx(uint _idx)\n', '    external\n', '    view\n', '    returns (address, uint)\n', '  {\n', '    Member memory member = members[_idx];\n', '\n', '    return (member.addr, member.tier);\n', '  }\n', '\n', '  function isUserMember(address _user)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return userToMemberIndex[_user] != 0;\n', '  }\n', '\n', '  function getMemberIdxOfUser(address _user)\n', '    external\n', '    view\n', '    returns (uint)\n', '  {\n', '    return userToMemberIndex[_user];\n', '  }\n', '}']
