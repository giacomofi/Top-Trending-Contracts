['pragma solidity 0.4.25;\n', '\n', '/// @title provides subject to role checking logic\n', 'contract IAccessPolicy {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', "    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\n", '    /// @dev checks if subject belongs to requested role for particular object\n', '    /// @param subject address to be checked against role, typically msg.sender\n', '    /// @param role identifier of required role\n', '    /// @param object contract instance context for role checking, typically contract requesting the check\n', '    /// @param verb additional data, in current AccessControll implementation msg.sig\n', '    /// @return if subject belongs to a role\n', '    function allowed(\n', '        address subject,\n', '        bytes32 role,\n', '        address object,\n', '        bytes4 verb\n', '    )\n', '        public\n', '        returns (bool);\n', '}\n', '\n', '/// @title enables access control in implementing contract\n', '/// @dev see AccessControlled for implementation\n', 'contract IAccessControlled {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    /// @dev must log on access policy change\n', '    event LogAccessPolicyChanged(\n', '        address controller,\n', '        IAccessPolicy oldPolicy,\n', '        IAccessPolicy newPolicy\n', '    );\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @dev allows to change access control mechanism for this contract\n', '    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\n', '    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\n', '    ///     then interfaces could be used for example to control access semantics\n', '    /// @param newPolicy new access policy to controll this contract\n', '    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\n', '    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\n', '        public;\n', '\n', '    function accessPolicy()\n', '        public\n', '        constant\n', '        returns (IAccessPolicy);\n', '\n', '}\n', '\n', 'contract StandardRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', "    // @notice Soldity somehow doesn't evaluate this compile time\n", '    // @dev role which has rights to change permissions and set new policy in contract, keccak256("AccessController")\n', '    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\n', '}\n', '\n', '/// @title Granular code execution permissions\n', '/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\n', "///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\n", '///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\n', '/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\n', '///     by msg.sender with ROLE_ACCESS_CONTROLLER role\n', 'contract AccessControlled is IAccessControlled, StandardRoles {\n', '\n', '    ////////////////////////\n', '    // Mutable state\n', '    ////////////////////////\n', '\n', '    IAccessPolicy private _accessPolicy;\n', '\n', '    ////////////////////////\n', '    // Modifiers\n', '    ////////////////////////\n', '\n', "    /// @dev limits function execution only to senders assigned to required 'role'\n", '    modifier only(bytes32 role) {\n', '        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\n', '        _;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    constructor(IAccessPolicy policy) internal {\n', '        require(address(policy) != 0x0);\n', '        _accessPolicy = policy;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements IAccessControlled\n', '    //\n', '\n', '    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\n', '        public\n', '        only(ROLE_ACCESS_CONTROLLER)\n', '    {\n', '        // ROLE_ACCESS_CONTROLLER must be present\n', '        // under the new policy. This provides some\n', '        // protection against locking yourself out.\n', '        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\n', '\n', '        // We can now safely set the new policy without foot shooting.\n', '        IAccessPolicy oldPolicy = _accessPolicy;\n', '        _accessPolicy = newPolicy;\n', '\n', '        // Log event\n', '        emit LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\n', '    }\n', '\n', '    function accessPolicy()\n', '        public\n', '        constant\n', '        returns (IAccessPolicy)\n', '    {\n', '        return _accessPolicy;\n', '    }\n', '}\n', '\n', 'contract IsContract {\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    function isContract(address addr)\n', '        internal\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint256 size;\n', '        // takes 700 gas\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/// @title standard access roles of the Platform\n', '/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap\n', 'contract AccessRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', '    // NOTE: All roles are set to the keccak256 hash of the\n', '    // CamelCased role name, i.e.\n', '    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256("LockedAccountAdmin")\n', '\n', '    // May issue (generate) Neumarks\n', '    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\n', '\n', '    // May burn Neumarks it owns\n', '    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\n', '\n', '    // May create new snapshots on Neumark\n', '    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\n', '\n', '    // May enable/disable transfers on Neumark\n', '    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\n', '\n', '    // may reclaim tokens/ether from contracts supporting IReclaimable interface\n', '    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\n', '\n', '    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256("PlatformOperatorRepresentative")\n', '    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\n', '\n', '    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256("EurtDepositManager")\n', '    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\n', '\n', '    // allows to register identities and change associated claims keccak256("IdentityManager")\n', '    bytes32 internal constant ROLE_IDENTITY_MANAGER = 0x32964e6bc50f2aaab2094a1d311be8bda920fc4fb32b2fb054917bdb153a9e9e;\n', '\n', '    // allows to replace controller on euro token and to destroy tokens without withdraw kecckak256("EurtLegalManager")\n', '    bytes32 internal constant ROLE_EURT_LEGAL_MANAGER = 0x4eb6b5806954a48eb5659c9e3982d5e75bfb2913f55199877d877f157bcc5a9b;\n', '\n', '    // allows to change known interfaces in universe kecckak256("UniverseManager")\n', '    bytes32 internal constant ROLE_UNIVERSE_MANAGER = 0xe8d8f8f9ea4b19a5a4368dbdace17ad71a69aadeb6250e54c7b4c7b446301738;\n', '\n', '    // allows to exchange gas for EUR-T keccak("GasExchange")\n', '    bytes32 internal constant ROLE_GAS_EXCHANGE = 0x9fe43636e0675246c99e96d7abf9f858f518b9442c35166d87f0934abef8a969;\n', '\n', '    // allows to set token exchange rates keccak("TokenRateOracle")\n', '    bytes32 internal constant ROLE_TOKEN_RATE_ORACLE = 0xa80c3a0c8a5324136e4c806a778583a2a980f378bdd382921b8d28dcfe965585;\n', '}\n', '\n', 'contract IBasicToken {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount\n', '    );\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @dev This function makes it easy to get the total number of tokens\n', '    /// @return The total number of tokens\n', '    function totalSupply()\n', '        public\n', '        constant\n', '        returns (uint256);\n', '\n', "    /// @param owner The address that's balance is being requested\n", '    /// @return The balance of `owner` at the current block\n', '    function balanceOf(address owner)\n', '        public\n', '        constant\n', '        returns (uint256 balance);\n', '\n', '    /// @notice Send `amount` tokens to `to` from `msg.sender`\n', '    /// @param to The address of the recipient\n', '    /// @param amount The amount of tokens to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 amount)\n', '        public\n', '        returns (bool success);\n', '\n', '}\n', '\n', '/// @title allows deriving contract to recover any token or ether that it has balance of\n', '/// @notice note that this opens your contracts to claims from various people saying they lost tokens and they want them back\n', '///     be ready to handle such claims\n', '/// @dev use with care!\n', "///     1. ROLE_RECLAIMER is allowed to claim tokens, it's not returning tokens to original owner\n", '///     2. in derived contract that holds any token by design you must override `reclaim` and block such possibility.\n', '///         see ICBMLockedAccount as an example\n', 'contract Reclaimable is AccessControlled, AccessRoles {\n', '\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', '    IBasicToken constant internal RECLAIM_ETHER = IBasicToken(0x0);\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function reclaim(IBasicToken token)\n', '        public\n', '        only(ROLE_RECLAIMER)\n', '    {\n', '        address reclaimer = msg.sender;\n', '        if(token == RECLAIM_ETHER) {\n', '            reclaimer.transfer(address(this).balance);\n', '        } else {\n', '            uint256 balance = token.balanceOf(this);\n', '            require(token.transfer(reclaimer, balance));\n', '        }\n', '    }\n', '}\n', '\n', 'contract ITokenMetadata {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function symbol()\n', '        public\n', '        constant\n', '        returns (string);\n', '\n', '    function name()\n', '        public\n', '        constant\n', '        returns (string);\n', '\n', '    function decimals()\n', '        public\n', '        constant\n', '        returns (uint8);\n', '}\n', '\n', '/// @title adds token metadata to token contract\n', '/// @dev see Neumark for example implementation\n', 'contract TokenMetadata is ITokenMetadata {\n', '\n', '    ////////////////////////\n', '    // Immutable state\n', '    ////////////////////////\n', '\n', "    // The Token's name: e.g. DigixDAO Tokens\n", '    string private NAME;\n', '\n', '    // An identifier: e.g. REP\n', '    string private SYMBOL;\n', '\n', '    // Number of decimals of the smallest unit\n', '    uint8 private DECIMALS;\n', '\n', '    // An arbitrary versioning scheme\n', '    string private VERSION;\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    /// @notice Constructor to set metadata\n', '    /// @param tokenName Name of the new token\n', '    /// @param decimalUnits Number of decimals of the new token\n', '    /// @param tokenSymbol Token Symbol for the new token\n', '    /// @param version Token version ie. when cloning is used\n', '    constructor(\n', '        string tokenName,\n', '        uint8 decimalUnits,\n', '        string tokenSymbol,\n', '        string version\n', '    )\n', '        public\n', '    {\n', '        NAME = tokenName;                                 // Set the name\n', '        SYMBOL = tokenSymbol;                             // Set the symbol\n', '        DECIMALS = decimalUnits;                          // Set the decimals\n', '        VERSION = version;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function name()\n', '        public\n', '        constant\n', '        returns (string)\n', '    {\n', '        return NAME;\n', '    }\n', '\n', '    function symbol()\n', '        public\n', '        constant\n', '        returns (string)\n', '    {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function decimals()\n', '        public\n', '        constant\n', '        returns (uint8)\n', '    {\n', '        return DECIMALS;\n', '    }\n', '\n', '    function version()\n', '        public\n', '        constant\n', '        returns (string)\n', '    {\n', '        return VERSION;\n', '    }\n', '}\n', '\n', '/// @title controls spending approvals\n', '/// @dev TokenAllowance observes this interface, Neumark contract implements it\n', 'contract MTokenAllowanceController {\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param owner The address that calls `approve()`\n', '    /// @param spender The spender in the `approve()` call\n', '    /// @param amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '    function mOnApprove(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        returns (bool allow);\n', '\n', '    /// @notice Allows to override allowance approved by the owner\n', '    ///         Primary role is to enable forced transfers, do not override if you do not like it\n', '    ///         Following behavior is expected in the observer\n', '    ///         approve() - should revert if mAllowanceOverride() > 0\n', '    ///         allowance() - should return mAllowanceOverride() if set\n', '    ///         transferFrom() - should override allowance if mAllowanceOverride() > 0\n', '    /// @param owner An address giving allowance to spender\n', '    /// @param spender An address getting  a right to transfer allowance amount from the owner\n', '    /// @return current allowance amount\n', '    function mAllowanceOverride(\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        constant\n', '        returns (uint256 allowance);\n', '}\n', '\n', '/// @title controls token transfers\n', '/// @dev BasicSnapshotToken observes this interface, Neumark contract implements it\n', 'contract MTokenTransferController {\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param from The origin of the transfer\n', '    /// @param to The destination of the transfer\n', '    /// @param amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '    function mOnTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        returns (bool allow);\n', '\n', '}\n', '\n', '/// @title controls approvals and transfers\n', '/// @dev The token controller contract must implement these functions, see Neumark as example\n', '/// @dev please note that controller may be a separate contract that is called from mOnTransfer and mOnApprove functions\n', 'contract MTokenController is MTokenTransferController, MTokenAllowanceController {\n', '}\n', '\n', 'contract TrustlessTokenController is\n', '    MTokenController\n', '{\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements MTokenController\n', '    //\n', '\n', '    function mOnTransfer(\n', '        address /*from*/,\n', '        address /*to*/,\n', '        uint256 /*amount*/\n', '    )\n', '        internal\n', '        returns (bool allow)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function mOnApprove(\n', '        address /*owner*/,\n', '        address /*spender*/,\n', '        uint256 /*amount*/\n', '    )\n', '        internal\n', '        returns (bool allow)\n', '    {\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IERC20Allowance {\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 amount\n', '    );\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @dev This function makes it easy to read the `allowed[]` map\n', '    /// @param owner The address of the account that owns the token\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens of owner that spender is allowed\n', '    ///  to spend\n', '    function allowance(address owner, address spender)\n', '        public\n', '        constant\n', '        returns (uint256 remaining);\n', '\n', '    /// @notice `msg.sender` approves `spender` to spend `amount` tokens on\n', '    ///  its behalf. This is a modified version of the ERC20 approve function\n', '    ///  to be a little bit safer\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @param amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(address spender, uint256 amount)\n', '        public\n', '        returns (bool success);\n', '\n', '    /// @notice Send `amount` tokens to `to` from `from` on the condition it\n', '    ///  is approved by `from`\n', '    /// @param from The address holding the tokens being transferred\n', '    /// @param to The address of the recipient\n', '    /// @param amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(address from, address to, uint256 amount)\n', '        public\n', '        returns (bool success);\n', '\n', '}\n', '\n', 'contract IERC20Token is IBasicToken, IERC20Allowance {\n', '\n', '}\n', '\n', 'contract IERC677Callback {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    // NOTE: This call can be initiated by anyone. You need to make sure that\n', '    // it is send by the token (`require(msg.sender == token)`) or make sure\n', '    // amount is valid (`require(token.allowance(this) >= amount)`).\n', '    function receiveApproval(\n', '        address from,\n', '        uint256 amount,\n', '        address token, // IERC667Token\n', '        bytes data\n', '    )\n', '        public\n', '        returns (bool success);\n', '\n', '}\n', '\n', 'contract IERC677Allowance is IERC20Allowance {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @notice `msg.sender` approves `spender` to send `amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param spender The address of the contract able to transfer the tokens\n', '    /// @param amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(address spender, uint256 amount, bytes extraData)\n', '        public\n', '        returns (bool success);\n', '\n', '}\n', '\n', 'contract IERC677Token is IERC20Token, IERC677Allowance {\n', '}\n', '\n', 'contract Math {\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    // absolute difference: |v1 - v2|\n', '    function absDiff(uint256 v1, uint256 v2)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return v1 > v2 ? v1 - v2 : v2 - v1;\n', '    }\n', '\n', '    // divide v by d, round up if remainder is 0.5 or more\n', '    function divRound(uint256 v, uint256 d)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return add(v, d/2) / d;\n', '    }\n', '\n', "    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\n", '    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\n', '    // mind loss of precision as decimal fractions do not have finite binary expansion\n', '    // do not use instead of division\n', '    function decimalFraction(uint256 amount, uint256 frac)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', "        // it's like 1 ether is 100% proportion\n", '        return proportion(amount, frac, 10**18);\n', '    }\n', '\n', '    // computes part/total of amount with maximum precision (multiplication first)\n', '    // part and total must have the same units\n', '    function proportion(uint256 amount, uint256 part, uint256 total)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return divRound(mul(amount, part), total);\n', '    }\n', '\n', '    //\n', '    // Open Zeppelin Math library below\n', '    //\n', '\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', '/// @title internal token transfer function\n', '/// @dev see BasicSnapshotToken for implementation\n', 'contract MTokenTransfer {\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    /// @dev This is the actual transfer function in the token contract, it can\n', '    ///  only be called by other functions in this contract.\n', '    /// @param from The address holding the tokens being transferred\n', '    /// @param to The address of the recipient\n', '    /// @param amount The amount of tokens to be transferred\n', '    /// @dev  reverts if transfer was not successful\n', '    function mTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal;\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is\n', '    MTokenTransfer,\n', '    MTokenTransferController,\n', '    IBasicToken,\n', '    Math\n', '{\n', '\n', '    ////////////////////////\n', '    // Mutable state\n', '    ////////////////////////\n', '\n', '    mapping(address => uint256) internal _balances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param to The address to transfer to.\n', '    * @param amount The amount to be transferred.\n', '    */\n', '    function transfer(address to, uint256 amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        mTransfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev This function makes it easy to get the total number of tokens\n', '    /// @return The total number of tokens\n', '    function totalSupply()\n', '        public\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address owner)\n', '        public\n', '        constant\n', '        returns (uint256 balance)\n', '    {\n', '        return _balances[owner];\n', '    }\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements MTokenTransfer\n', '    //\n', '\n', '    function mTransfer(address from, address to, uint256 amount)\n', '        internal\n', '    {\n', '        require(to != address(0));\n', '        require(mOnTransfer(from, to, amount));\n', '\n', '        _balances[from] = sub(_balances[from], amount);\n', '        _balances[to] = add(_balances[to], amount);\n', '        emit Transfer(from, to, amount);\n', '    }\n', '}\n', '\n', '/// @title token spending approval and transfer\n', '/// @dev implements token approval and transfers and exposes relevant part of ERC20 and ERC677 approveAndCall\n', '///     may be mixed in with any basic token (implementing mTransfer) like BasicSnapshotToken or MintableSnapshotToken to add approval mechanism\n', '///     observes MTokenAllowanceController interface\n', '///     observes MTokenTransfer\n', 'contract TokenAllowance is\n', '    MTokenTransfer,\n', '    MTokenAllowanceController,\n', '    IERC20Allowance,\n', '    IERC677Token\n', '{\n', '\n', '    ////////////////////////\n', '    // Mutable state\n', '    ////////////////////////\n', '\n', '    // `allowed` tracks rights to spends others tokens as per ERC20\n', '    // owner => spender => amount\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    constructor()\n', '        internal\n', '    {\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements IERC20Token\n', '    //\n', '\n', '    /// @dev This function makes it easy to read the `allowed[]` map\n', '    /// @param owner The address of the account that owns the token\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens of _owner that _spender is allowed\n', '    ///  to spend\n', '    function allowance(address owner, address spender)\n', '        public\n', '        constant\n', '        returns (uint256 remaining)\n', '    {\n', '        uint256 override = mAllowanceOverride(owner, spender);\n', '        if (override > 0) {\n', '            return override;\n', '        }\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n', '    ///  its behalf. This is a modified version of the ERC20 approve function\n', '    ///  where allowance per spender must be 0 to allow change of such allowance\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @param amount The amount of tokens to be approved for transfer\n', '    /// @return True or reverts, False is never returned\n', '    function approve(address spender, uint256 amount)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        // Alerts the token controller of the approve function call\n', '        require(mOnApprove(msg.sender, spender, amount));\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender,0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((amount == 0 || _allowed[msg.sender][spender] == 0) && mAllowanceOverride(msg.sender, spender) == 0);\n', '\n', '        _allowed[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n', '    ///  is approved by `_from`\n', '    /// @param from The address holding the tokens being transferred\n', '    /// @param to The address of the recipient\n', '    /// @param amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful, reverts in any other case\n', '    function transferFrom(address from, address to, uint256 amount)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        uint256 allowed = mAllowanceOverride(from, msg.sender);\n', '        if (allowed == 0) {\n', '            // The standard ERC 20 transferFrom functionality\n', '            allowed = _allowed[from][msg.sender];\n', "            // yes this will underflow but then we'll revert. will cost gas however so don't underflow\n", '            _allowed[from][msg.sender] -= amount;\n', '        }\n', '        require(allowed >= amount);\n', '        mTransfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // Implements IERC677Token\n', '    //\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param spender The address of the contract able to transfer the tokens\n', '    /// @param amount The amount of tokens to be approved for transfer\n', '    /// @return True or reverts, False is never returned\n', '    function approveAndCall(\n', '        address spender,\n', '        uint256 amount,\n', '        bytes extraData\n', '    )\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(approve(spender, amount));\n', '\n', '        success = IERC677Callback(spender).receiveApproval(\n', '            msg.sender,\n', '            amount,\n', '            this,\n', '            extraData\n', '        );\n', '        require(success);\n', '\n', '        return true;\n', '    }\n', '\n', '    ////////////////////////\n', '    // Internal functions\n', '    ////////////////////////\n', '\n', '    //\n', '    // Implements default MTokenAllowanceController\n', '    //\n', '\n', '    // no override in default implementation\n', '    function mAllowanceOverride(\n', '        address /*owner*/,\n', '        address /*spender*/\n', '    )\n', '        internal\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract StandardToken is\n', '    IERC20Token,\n', '    BasicToken,\n', '    TokenAllowance\n', '{\n', '\n', '}\n', '\n', '/// @title uniquely identifies deployable (non-abstract) platform contract\n', '/// @notice cheap way of assigning implementations to knownInterfaces which represent system services\n', '///         unfortunatelly ERC165 does not include full public interface (ABI) and does not provide way to list implemented interfaces\n', '///         EIP820 still in the making\n', '/// @dev ids are generated as follows keccak256("neufund-platform:<contract name>")\n', '///      ids roughly correspond to ABIs\n', 'contract IContractId {\n', '    /// @param id defined as above\n', '    /// @param version implementation version\n', '    function contractId() public pure returns (bytes32 id, uint256 version);\n', '}\n', '\n', '/// @title current ERC223 fallback function\n', '/// @dev to be used in all future token contract\n', '/// @dev NEU and ICBMEtherToken (obsolete) are the only contracts that still uses IERC223LegacyCallback\n', 'contract IERC223Callback {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function tokenFallback(address from, uint256 amount, bytes data)\n', '        public;\n', '\n', '}\n', '\n', 'contract IERC223Token is IERC20Token, ITokenMetadata {\n', '\n', '    /// @dev Departure: We do not log data, it has no advantage over a standard\n', '    ///     log event. By sticking to the standard log event we\n', '    ///     stay compatible with constracts that expect and ERC20 token.\n', '\n', '    // event Transfer(\n', '    //    address indexed from,\n', '    //    address indexed to,\n', '    //    uint256 amount,\n', '    //    bytes data);\n', '\n', '\n', '    /// @dev Departure: We do not use the callback on regular transfer calls to\n', '    ///     stay compatible with constracts that expect and ERC20 token.\n', '\n', '    // function transfer(address to, uint256 amount)\n', '    //     public\n', '    //     returns (bool);\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    function transfer(address to, uint256 amount, bytes data)\n', '        public\n', '        returns (bool);\n', '}\n', '\n', 'contract IWithdrawableToken {\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// @notice withdraws from a token holding assets\n', '    /// @dev amount of asset should be returned to msg.sender and corresponding balance burned\n', '    function withdraw(uint256 amount)\n', '        public;\n', '}\n', '\n', 'contract EtherToken is\n', '    IsContract,\n', '    IContractId,\n', '    AccessControlled,\n', '    StandardToken,\n', '    TrustlessTokenController,\n', '    IWithdrawableToken,\n', '    TokenMetadata,\n', '    IERC223Token,\n', '    Reclaimable\n', '{\n', '    ////////////////////////\n', '    // Constants\n', '    ////////////////////////\n', '\n', '    string private constant NAME = "Ether Token";\n', '\n', '    string private constant SYMBOL = "ETH-T";\n', '\n', '    uint8 private constant DECIMALS = 18;\n', '\n', '    ////////////////////////\n', '    // Events\n', '    ////////////////////////\n', '\n', '    event LogDeposit(\n', '        address indexed to,\n', '        uint256 amount\n', '    );\n', '\n', '    event LogWithdrawal(\n', '        address indexed from,\n', '        uint256 amount\n', '    );\n', '\n', '    event LogWithdrawAndSend(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount\n', '    );\n', '\n', '    ////////////////////////\n', '    // Constructor\n', '    ////////////////////////\n', '\n', '    constructor(IAccessPolicy accessPolicy)\n', '        AccessControlled(accessPolicy)\n', '        StandardToken()\n', '        TokenMetadata(NAME, DECIMALS, SYMBOL, "")\n', '        Reclaimable()\n', '        public\n', '    {\n', '    }\n', '\n', '    ////////////////////////\n', '    // Public functions\n', '    ////////////////////////\n', '\n', '    /// deposit msg.value of Ether to msg.sender balance\n', '    function deposit()\n', '        public\n', '        payable\n', '    {\n', '        depositPrivate();\n', '        emit Transfer(address(0), msg.sender, msg.value);\n', '    }\n', '\n', '    /// @notice convenience function to deposit and immediately transfer amount\n', '    /// @param transferTo where to transfer after deposit\n', '    /// @param amount total amount to transfer, must be <= balance after deposit\n', '    /// @param data erc223 data\n', '    /// @dev intended to deposit from simple account and invest in ETO\n', '    function depositAndTransfer(address transferTo, uint256 amount, bytes data)\n', '        public\n', '        payable\n', '    {\n', '        depositPrivate();\n', '        transfer(transferTo, amount, data);\n', '    }\n', '\n', "    /// withdraws and sends 'amount' of ether to msg.sender\n", '    function withdraw(uint256 amount)\n', '        public\n', '    {\n', '        withdrawPrivate(amount);\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    /// @notice convenience function to withdraw and transfer to external account\n', '    /// @param sendTo address to which send total amount\n', '    /// @param amount total amount to withdraw and send\n', '    /// @dev function is payable and is meant to withdraw funds on accounts balance and token in single transaction\n', '    /// @dev BEWARE that msg.sender of the funds is Ether Token contract and not simple account calling it.\n', '    /// @dev  when sent to smart conctract funds may be lost, so this is prevented below\n', '    function withdrawAndSend(address sendTo, uint256 amount)\n', '        public\n', '        payable\n', '    {\n', '        // must send at least what is in msg.value to being another deposit function\n', '        require(amount >= msg.value, "NF_ET_NO_DEPOSIT");\n', '        if (amount > msg.value) {\n', '            uint256 withdrawRemainder = amount - msg.value;\n', '            withdrawPrivate(withdrawRemainder);\n', '        }\n', '        emit LogWithdrawAndSend(msg.sender, sendTo, amount);\n', '        sendTo.transfer(amount);\n', '    }\n', '\n', '    //\n', '    // Implements IERC223Token\n', '    //\n', '\n', '    function transfer(address to, uint256 amount, bytes data)\n', '        public\n', '        returns (bool)\n', '    {\n', '        BasicToken.mTransfer(msg.sender, to, amount);\n', '\n', '        // Notify the receiving contract.\n', '        if (isContract(to)) {\n', '            // in case of re-entry (1) transfer is done (2) msg.sender is different\n', '            IERC223Callback(to).tokenFallback(msg.sender, amount, data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // Overrides Reclaimable\n', '    //\n', '\n', '    /// @notice allows EtherToken to reclaim tokens wrongly sent to its address\n', '    /// @dev as EtherToken by design has balance of Ether (native Ethereum token)\n', '    ///     such reclamation is not allowed\n', '    function reclaim(IBasicToken token)\n', '        public\n', '    {\n', '        // forbid reclaiming ETH hold in this contract.\n', '        require(token != RECLAIM_ETHER);\n', '        Reclaimable.reclaim(token);\n', '    }\n', '\n', '    //\n', '    // Implements IContractId\n', '    //\n', '\n', '    function contractId() public pure returns (bytes32 id, uint256 version) {\n', '        return (0x75b86bc24f77738576716a36431588ae768d80d077231d1661c2bea674c6373a, 0);\n', '    }\n', '\n', '\n', '    ////////////////////////\n', '    // Private functions\n', '    ////////////////////////\n', '\n', '    function depositPrivate()\n', '        private\n', '    {\n', '        _balances[msg.sender] = add(_balances[msg.sender], msg.value);\n', '        _totalSupply = add(_totalSupply, msg.value);\n', '        emit LogDeposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function withdrawPrivate(uint256 amount)\n', '        private\n', '    {\n', '        require(_balances[msg.sender] >= amount);\n', '        _balances[msg.sender] = sub(_balances[msg.sender], amount);\n', '        _totalSupply = sub(_totalSupply, amount);\n', '        emit LogWithdrawal(msg.sender, amount);\n', '        emit Transfer(msg.sender, address(0), amount);\n', '    }\n', '}']