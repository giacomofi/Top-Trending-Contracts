['// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '\t    uint\t wad,\n', '        bytes    fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSStop is DSAuth, DSNote {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '}\n', '\n', '\n', 'contract EIP20Interface {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract DSTokenBase is EIP20Interface, DSMath {\n', '    mapping (address => uint256)                       _balances;\n', '    mapping (address => mapping (address => uint256))  _approvals;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return _balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        _balances[msg.sender] = sub(_balances[msg.sender], _value);\n', '        _balances[_to] = add(_balances[_to], _value);\n', '        \n', '        Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\n', '        if (_from != msg.sender) {\n', '            _approvals[_from][msg.sender] = sub(_approvals[_from][msg.sender], _value);\n', '        }\n', '        _balances[_from] = sub(_balances[_from], _value);\n', '        _balances[_to] = add(_balances[_to], _value);\n', '        \n', '        Transfer(_from, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success){\n', '        _approvals[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining){\n', '        return _approvals[_owner][_spender];\n', '    }\n', '}\n', '\n', ' contract FUXEToken is DSTokenBase, DSStop {\n', '       string   public  name = "FUXECoin";\n', '       string   public  symbol = "FUX";\n', '       uint256  public  decimals = 18; // standard token precision. override to customize\n', '\n', '     function FUXEToken() public {\n', '         totalSupply = 100000000 * 10 ** uint256(decimals);\n', '         _balances[msg.sender] = totalSupply;\n', '     }\n', '\n', '     function transfer(address dst, uint wad) public stoppable note returns (bool) {\n', '         return super.transfer(dst, wad);\n', '     }\n', '     \n', '     function transferFrom(\n', '         address src, address dst, uint wad\n', '     ) public stoppable note returns (bool) {\n', '         return super.transferFrom(src, dst, wad);\n', '     }\n', '     \n', '     function approve(address guy, uint wad) public stoppable note returns (bool) {\n', '         return super.approve(guy, wad);\n', '     }\n', ' }']
['// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity ^0.4.20;\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '\t    uint\t wad,\n', '        bytes    fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() public {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSStop is DSAuth, DSNote {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '}\n', '\n', '\n', 'contract EIP20Interface {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract DSTokenBase is EIP20Interface, DSMath {\n', '    mapping (address => uint256)                       _balances;\n', '    mapping (address => mapping (address => uint256))  _approvals;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return _balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        _balances[msg.sender] = sub(_balances[msg.sender], _value);\n', '        _balances[_to] = add(_balances[_to], _value);\n', '        \n', '        Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\n', '        if (_from != msg.sender) {\n', '            _approvals[_from][msg.sender] = sub(_approvals[_from][msg.sender], _value);\n', '        }\n', '        _balances[_from] = sub(_balances[_from], _value);\n', '        _balances[_to] = add(_balances[_to], _value);\n', '        \n', '        Transfer(_from, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success){\n', '        _approvals[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining){\n', '        return _approvals[_owner][_spender];\n', '    }\n', '}\n', '\n', ' contract FUXEToken is DSTokenBase, DSStop {\n', '       string   public  name = "FUXECoin";\n', '       string   public  symbol = "FUX";\n', '       uint256  public  decimals = 18; // standard token precision. override to customize\n', '\n', '     function FUXEToken() public {\n', '         totalSupply = 100000000 * 10 ** uint256(decimals);\n', '         _balances[msg.sender] = totalSupply;\n', '     }\n', '\n', '     function transfer(address dst, uint wad) public stoppable note returns (bool) {\n', '         return super.transfer(dst, wad);\n', '     }\n', '     \n', '     function transferFrom(\n', '         address src, address dst, uint wad\n', '     ) public stoppable note returns (bool) {\n', '         return super.transferFrom(src, dst, wad);\n', '     }\n', '     \n', '     function approve(address guy, uint wad) public stoppable note returns (bool) {\n', '         return super.approve(guy, wad);\n', '     }\n', ' }']
