['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TTTToken is ERC20, Ownable {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring public constant name = "The Tip Token";\n', '\tstring public constant symbol = "TTT";\n', '\n', '\tuint8 public decimals = 18;\n', '\n', '\tmapping(address=>uint256) balances;\n', '\tmapping(address=>mapping(address=>uint256)) allowed;\n', '\n', '\t// Supply variables\n', '\tuint256 public totalSupply_;\n', '\tuint256 public presaleSupply;\n', '\tuint256 public crowdsaleSupply;\n', '\tuint256 public privatesaleSupply;\n', '\tuint256 public airdropSupply;\n', '\tuint256 public teamSupply;\n', '\tuint256 public ecoSupply;\n', '\n', '\t// Vest variables\n', '\tuint256 public firstVestStartsAt;\n', '\tuint256 public secondVestStartsAt;\n', '\tuint256 public firstVestAmount;\n', '\tuint256 public secondVestAmount;\n', '\tuint256 public currentVestedAmount;\n', '\n', '\tuint256 public crowdsaleBurnAmount;\n', '\n', '\t// Token sale addresses\n', '\taddress public privatesaleAddress;\n', '\taddress public presaleAddress;\n', '\taddress public crowdsaleAddress;\n', '\taddress public teamSupplyAddress;\n', '\taddress public ecoSupplyAddress;\n', '\taddress public crowdsaleAirdropAddress;\n', '\taddress public crowdsaleBurnAddress;\n', '\taddress public tokenSaleAddress;\n', '\n', '\t// Token sale state variables\n', '\tbool public privatesaleFinalized;\n', '\tbool public presaleFinalized;\n', '\tbool public crowdsaleFinalized;\n', '\n', '\tevent PrivatesaleFinalized(uint tokensRemaining);\n', '\tevent PresaleFinalized(uint tokensRemaining);\n', '\tevent CrowdsaleFinalized(uint tokensRemaining);\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\tevent TokensaleAddressSet(address tSeller, address from);\n', '\n', '\tmodifier onlyTokenSale() {\n', '\t\trequire(msg.sender == tokenSaleAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canItoSend() {\n', '\t\trequire(crowdsaleFinalized == true || (crowdsaleFinalized == false && msg.sender == ecoSupplyAddress));\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction TTTToken() {\n', '\t\t// 600 million total supply divided into\n', '\t\t//\t\t90 million to privatesale address\n', '\t\t//\t\t120 million to presale address\n', '\t\t//\t\t180 million to crowdsale address\n', '\t\t//\t\t90 million to eco supply address\n', '\t\t//\t\t120 million to team supply address\n', '\t\ttotalSupply_ = 600000000 * 10**uint(decimals);\n', '\t\tprivatesaleSupply = 90000000 * 10**uint(decimals);\n', '\t\tpresaleSupply = 120000000 * 10**uint(decimals);\n', '\t\tcrowdsaleSupply = 180000000 * 10**uint(decimals);\n', '\t\tecoSupply = 90000000 * 10**uint(decimals);\n', '\t\tteamSupply = 120000000 * 10**uint(decimals);\n', '\n', '\t\tfirstVestAmount = teamSupply.div(2);\n', '\t\tsecondVestAmount = firstVestAmount;\n', '\t\tcurrentVestedAmount = 0;\n', '\n', '\t\tprivatesaleAddress = 0xE67EE1935bf160B48BA331074bb743630ee8aAea;\n', '\t\tpresaleAddress = 0x4A41D67748D16aEB12708E88270d342751223870;\n', '\t\tcrowdsaleAddress = 0x2eDf855e5A90DF003a5c1039bEcf4a721C9c3f9b;\n', '\t\tteamSupplyAddress = 0xc4146EcE2645038fbccf79784a6DcbE3C6586c03;\n', '\t\tecoSupplyAddress = 0xdBA99B92a18930dA39d1e4B52177f84a0C27C8eE;\n', '\t\tcrowdsaleAirdropAddress = 0x6BCb947a8e8E895d1258C1b2fc84A5d22632E6Fa;\n', '\t\tcrowdsaleBurnAddress = 0xDF1CAf03FA89AfccdAbDd55bAF5C9C4b9b1ceBaB;\n', '\n', '\t\taddToBalance(privatesaleAddress, privatesaleSupply);\n', '\t\taddToBalance(presaleAddress, presaleSupply);\n', '\t\taddToBalance(crowdsaleAddress, crowdsaleSupply);\n', '\t\taddToBalance(teamSupplyAddress, teamSupply);\n', '\t\taddToBalance(ecoSupplyAddress, ecoSupply);\n', '\n', '\t\t// 12/01/2018 @ 12:00am (UTC)\n', '\t\tfirstVestStartsAt = 1543622400;\n', '\t\t// 06/01/2019 @ 12:00am (UTC)\n', '\t\tsecondVestStartsAt = 1559347200;\n', '\t}\n', '\n', '\t// Transfer\n', '\tfunction transfer(address _to, uint256 _amount) public canItoSend returns (bool success) {\n', '\t\trequire(balanceOf(msg.sender) >= _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tdecrementBalance(msg.sender, _amount);\n', '\t\tTransfer(msg.sender, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Transfer from one address to another\n', '\tfunction transferFrom(address _from, address _to, uint256 _amount) public canItoSend returns (bool success) {\n', '\t\trequire(allowance(_from, msg.sender) >= _amount);\n', '\t\tdecrementBalance(_from, _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Function for token sell contract to call on transfers\n', '\tfunction transferFromTokenSell(address _to, address _from, uint256 _amount) external onlyTokenSale returns (bool success) {\n', '\t\trequire(_amount > 0);\n', '\t\trequire(_to != 0x0);\n', '\t\trequire(balanceOf(_from) >= _amount);\n', '\t\tdecrementBalance(_from, _amount);\n', '\t\taddToBalance(_to, _amount);\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Approve another address a certain amount of TTT\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t\trequire((_value == 0) || (allowance(msg.sender, _spender) == 0));\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', "\t// Get an address's TTT allowance\n", '\tfunction allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\t// Get TTT balance of an address\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\t// Return total supply\n', '\tfunction totalSupply() public view returns (uint256 totalSupply) {\n', '\t\treturn totalSupply_;\n', '\t}\n', '\n', '\t// Set the tokenSell contract address, can only be set once\n', '\tfunction setTokenSaleAddress(address _tokenSaleAddress) external onlyOwner {\n', '\t\trequire(tokenSaleAddress == 0x0);\n', '\t\ttokenSaleAddress = _tokenSaleAddress;\n', '\t\tTokensaleAddressSet(tokenSaleAddress, msg.sender);\n', '\t}\n', '\n', '\t// Finalize private. If there are leftover TTT, overflow to presale\n', '\tfunction finalizePrivatesale() external onlyTokenSale returns (bool success) {\n', '\t\trequire(privatesaleFinalized == false);\n', '\t\tuint256 amount = balanceOf(privatesaleAddress);\n', '\t\tif (amount != 0) {\n', '\t\t\taddToBalance(presaleAddress, amount);\n', '\t\t\tdecrementBalance(privatesaleAddress, amount);\n', '\t\t}\n', '\t\tprivatesaleFinalized = true;\n', '\t\tPrivatesaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Finalize presale. If there are leftover TTT, overflow to crowdsale\n', '\tfunction finalizePresale() external onlyTokenSale returns (bool success) {\n', '\t\trequire(presaleFinalized == false && privatesaleFinalized == true);\n', '\t\tuint256 amount = balanceOf(presaleAddress);\n', '\t\tif (amount != 0) {\n', '\t\t\taddToBalance(crowdsaleAddress, amount);\n', '\t\t\tdecrementBalance(presaleAddress, amount);\n', '\t\t}\n', '\t\tpresaleFinalized = true;\n', '\t\tPresaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Finalize crowdsale. If there are leftover TTT, add 10% to airdrop, 20% to ecosupply, burn 70% at a later date\n', '\tfunction finalizeCrowdsale(uint256 _burnAmount, uint256 _ecoAmount, uint256 _airdropAmount) external onlyTokenSale returns(bool success) {\n', '\t\trequire(presaleFinalized == true && crowdsaleFinalized == false);\n', '\t\tuint256 amount = balanceOf(crowdsaleAddress);\n', '\t\tassert((_burnAmount.add(_ecoAmount).add(_airdropAmount)) == amount);\n', '\t\tif (amount > 0) {\n', '\t\t\tcrowdsaleBurnAmount = _burnAmount;\n', '\t\t\taddToBalance(ecoSupplyAddress, _ecoAmount);\n', '\t\t\taddToBalance(crowdsaleBurnAddress, crowdsaleBurnAmount);\n', '\t\t\taddToBalance(crowdsaleAirdropAddress, _airdropAmount);\n', '\t\t\tdecrementBalance(crowdsaleAddress, amount);\n', '\t\t\tassert(balanceOf(crowdsaleAddress) == 0);\n', '\t\t}\n', '\t\tcrowdsaleFinalized = true;\n', '\t\tCrowdsaleFinalized(amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Burns a specific amount of tokens. * added onlyOwner, as this will only happen from owner, if there are crowdsale leftovers\n', '\t* @param _value The amount of token to be burned.\n', '\t* @dev imported from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/BurnableToken.sol\n', '\t*/\n', '\tfunction burn(uint256 _value) public onlyOwner {\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\trequire(crowdsaleFinalized == true);\n', '\t\t// no need to require value <= totalSupply, since that would imply the\n', "\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply_ = totalSupply_.sub(_value);\n', '\t\tBurn(burner, _value);\n', '\t\tTransfer(burner, address(0), _value);\n', '\t}\n', '\n', '\t// Transfer tokens from the vested address. 50% available 12/01/2018, the rest available 06/01/2019\n', '\tfunction transferFromVest(uint256 _amount) public onlyOwner {\n', '\t\trequire(block.timestamp > firstVestStartsAt);\n', '\t\trequire(crowdsaleFinalized == true);\n', '\t\trequire(_amount > 0);\n', '\t\tif(block.timestamp > secondVestStartsAt) {\n', '\t\t\t// all tokens available for vest withdrawl\n', '\t\t\trequire(_amount <= teamSupply);\n', '\t\t\trequire(_amount <= balanceOf(teamSupplyAddress));\n', '\t\t} else {\n', '\t\t\t// only first vest available\n', '\t\t\trequire(_amount <= (firstVestAmount - currentVestedAmount));\n', '\t\t\trequire(_amount <= balanceOf(teamSupplyAddress));\n', '\t\t}\n', '\t\tcurrentVestedAmount = currentVestedAmount.add(_amount);\n', '\t\taddToBalance(msg.sender, _amount);\n', '\t\tdecrementBalance(teamSupplyAddress, _amount);\n', '\t\tTransfer(teamSupplyAddress, msg.sender, _amount);\n', '\t}\n', '\n', '\t// Add to balance\n', '\tfunction addToBalance(address _address, uint _amount) internal {\n', '\t\tbalances[_address] = balances[_address].add(_amount);\n', '\t}\n', '\n', '\t// Remove from balance\n', '\tfunction decrementBalance(address _address, uint _amount) internal {\n', '\t\tbalances[_address] = balances[_address].sub(_amount);\n', '\t}\n', '\n', '}']