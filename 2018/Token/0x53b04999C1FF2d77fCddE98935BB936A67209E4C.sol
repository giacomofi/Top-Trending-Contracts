['pragma solidity 0.4.24;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract UnlimitedAllowanceToken is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  /* ============ State variables ============ */\n', '\n', '  uint256 public totalSupply;\n', '  mapping (address => uint256) public  balances;\n', '  mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '  /* ============ Events ============ */\n', '\n', '  event Approval(address indexed src, address indexed spender, uint256 amount);\n', '  event Transfer(address indexed src, address indexed dest, uint256 amount);\n', '\n', '  /* ============ Constructor ============ */\n', '\n', '  constructor () public { }\n', '\n', '  /* ============ Public functions ============ */\n', '\n', '  function approve(address _spender, uint256 _amount) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    emit Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _dest, uint256 _amount) public returns (bool) {\n', '    return transferFrom(msg.sender, _dest, _amount);\n', '  }\n', '\n', '  function transferFrom(address _src, address _dest, uint256 _amount) public returns (bool) {\n', '    require(balances[_src] >= _amount, "Insufficient user balance");\n', '\n', '    if (_src != msg.sender && allowance(_src, msg.sender) != uint256(-1)) {\n', '      require(allowance(_src, msg.sender) >= _amount, "Insufficient user allowance");\n', '      allowed[_src][msg.sender] = allowed[_src][msg.sender].sub(_amount);\n', '    }\n', '\n', '    balances[_src] = balances[_src].sub(_amount);\n', '    balances[_dest] = balances[_dest].add(_amount);\n', '\n', '    emit Transfer(_src, _dest, _amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title VeilEther\n', ' * @author Veil\n', ' *\n', ' * WETH-like token with the ability to deposit ETH and approve in a single transaction\n', ' */\n', 'contract VeilEther is UnlimitedAllowanceToken {\n', '  using SafeMath for uint256;\n', '\n', '  /* ============ Constants ============ */\n', '\n', '  string constant public name = "Veil Ether"; // solium-disable-line uppercase\n', '  string constant public symbol = "Veil ETH"; // solium-disable-line uppercase\n', '  uint256 constant public decimals = 18; // solium-disable-line uppercase\n', '\n', '  /* ============ Events ============ */\n', '\n', '  event Deposit(address indexed dest, uint256 amount);\n', '  event Withdrawal(address indexed src, uint256 amount);\n', '\n', '  /* ============ Constructor ============ */\n', '\n', '  constructor () public { }\n', '\n', '  /* ============ Public functions ============ */\n', '\n', '  /**\n', '   * @dev Fallback function can be used to buy tokens by proxying the call to deposit()\n', '   */\n', '  function() public payable {\n', '    deposit();\n', '  }\n', '\n', '  /* ============ New functionality ============ */\n', '\n', '  /**\n', '   * Buys tokens with Ether, exchanging them 1:1 and sets the spender allowance\n', '   *\n', '   * @param _spender          Spender address for the allowance\n', '   * @param _allowance        Allowance amount\n', '   */\n', '  function depositAndApprove(address _spender, uint256 _allowance) public payable returns (bool) {\n', '    deposit();\n', '    approve(_spender, _allowance);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Withdraws from msg.sender&#39;s balance and transfers to a target address instead of msg.sender\n', '   *\n', '   * @param _amount           Amount to withdraw\n', '   * @param _target           Address to send the withdrawn ETH\n', '   */\n', '  function withdrawAndTransfer(uint256 _amount, address _target) public returns (bool) {\n', '    require(balances[msg.sender] >= _amount, "Insufficient user balance");\n', '    require(_target != address(0), "Invalid target address");\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    totalSupply = totalSupply.sub(_amount);\n', '    _target.transfer(_amount);\n', '\n', '    emit Withdrawal(msg.sender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* ============ Standard WETH functionality ============ */\n', '\n', '  function deposit() public payable returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '    totalSupply = totalSupply.add(msg.value);\n', '    emit Deposit(msg.sender, msg.value);\n', '    return true;\n', '  }\n', '\n', '  function withdraw(uint256 _amount) public returns (bool) {\n', '    require(balances[msg.sender] >= _amount, "Insufficient user balance");\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    totalSupply = totalSupply.sub(_amount);\n', '    msg.sender.transfer(_amount);\n', '\n', '    emit Withdrawal(msg.sender, _amount);\n', '    return true;\n', '  }\n', '}']