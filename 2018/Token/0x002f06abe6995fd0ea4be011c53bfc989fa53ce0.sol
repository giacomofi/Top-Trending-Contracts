['pragma solidity 0.4.17;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract TripCash is Ownable {\n', '\n', '    uint256 public totalSupply = 5000000000 * 1 ether;\n', '\n', '\n', '    string public constant name = "TripCash";\n', '    string public constant symbol = "TASH";\n', '    uint8 public constant decimals = 18;\n', '\n', '    mapping (address => uint256) public balances; //Addresses map\n', '    mapping (address => mapping(address => uint256)) public allowed;\n', '    mapping (address => bool) public notransfer;\n', '\n', '\n', '    uint256 public startPreICO = 1523840400; // preICO  start date\n', '    uint256 public endPreICO = 1528675199; // preICO  finish date\n', '    uint256 public startTime = 1529884800; // ICO  start date\n', '    uint256 public endTime = 1532303999; // ICO  finish date\n', '\n', '\n', '    address public constant ownerWallet = 0x9dA14C46f0182D850B12866AB0f3e397Fbd4FaC4; // Owner wallet address\n', '    address public constant teamWallet1 = 0xe82F49A648FADaafd468E65a13C050434a4C4a6f ; // Team wallet address\n', '    address public constant teamWallet2 = 0x16Eb7B7E232590787F1Fe3742acB1a1d0e43AF2A; // Team wallet address\n', '    address public constant fundWallet = 0x949844acF5C722707d02A037D074cabe7474e0CB; // Fund wallet address\n', '    address public constant frozenWallet2y = 0xAc77c90b37AFd80D2227f74971e7c3ad3e29D1fb; // For rest token frozen 2 year\n', '    address public constant frozenWallet4y = 0x265B8e89DAbA5Bdc330E55cA826a9f2e0EFf0870; // For rest token frozen 4 year\n', '\n', '    uint256 public constant ownerPercent = 10; // Owner percent token rate\n', '    uint256 public constant teamPercent = 10; // Team percent token rate\n', '    uint256 public constant bountyPercent = 10; // Bounty percent token rate\n', '\n', '    bool public transferAllowed = false;\n', '    bool public refundToken = false;\n', '\n', '    /**\n', '     * Token constructor\n', '     *\n', '     **/\n', '    function TripCash() public {\n', '        balances[owner] = totalSupply;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking token transfer\n', '     */\n', '    modifier canTransferToken(address _from) {\n', '        if (_from != owner) {\n', '            require(transferAllowed);\n', '        }\n', '        \n', '        if (_from == teamWallet1) {\n', '            require(now >= endTime + 15552000);\n', '        }\n', '\n', '        if (_from == teamWallet2) {\n', '            require(now >= endTime + 31536000);\n', '        }\n', '        \n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking transfer allownes\n', '     */\n', '    modifier notAllowed(){\n', '        require(!transferAllowed);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking ICO period\n', '     */\n', '    modifier saleIsOn() {\n', '        require((now > startTime && now < endTime)||(now > startPreICO && now < endPreICO));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking refund allownes\n', '     */\n', '\n', '    modifier canRefundToken() {\n', '        require(refundToken);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        uint256 tokenValue = balances[owner];\n', '\n', '        transfer(_newOwner, tokenValue);\n', '        owner = _newOwner;\n', '\n', '        OwnershipTransferred(owner, _newOwner);\n', '\n', '    }\n', '\n', '    /**\n', '     *\n', '     *   Adding bonus tokens for bounty, team and owner needs. Should be used by DAPPs\n', '     */\n', '    function dappsBonusCalc(address _to, uint256 _value) onlyOwner saleIsOn() notAllowed public returns (bool) {\n', '\n', '        require(_value != 0);\n', '        transfer(_to, _value);\n', '        notransfer[_to] = true;\n', '\n', '        uint256 bountyTokenAmount = 0;\n', '        uint256 ownerTokenAmount = 0;\n', '        uint256 teamTokenAmount = 0;\n', '\n', '        //calc bounty bonuses\n', '        bountyTokenAmount = _value * bountyPercent / 60;\n', '\n', '        //calc owner bonuses\n', '        ownerTokenAmount = _value * ownerPercent / 60;\n', '\n', '        //calc teamTokenAmount bonuses\n', '        teamTokenAmount = _value * teamPercent / 60;\n', '        \n', '        transfer(ownerWallet, ownerTokenAmount);\n', '        transfer(fundWallet, bountyTokenAmount);\n', '        transfer(teamWallet1, teamTokenAmount);\n', '        transfer(teamWallet2, teamTokenAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *\n', '     *   Return number of tokens for address\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transfer(address _to, uint256 _value) canTransferToken(msg.sender) public returns (bool){\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '        if (notransfer[msg.sender] == true) {\n', '            notransfer[msg.sender] = false;\n', '        }\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) canTransferToken(_from) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev function for rewarding token holders, who didn&#39;t transfer in 1 or 2 years\n', '     * @param _holder token holders address\n', '     */\n', '\n', '    function rewarding(address _holder) public onlyOwner returns(uint){\n', '        if(notransfer[_holder]==true){\n', '            if(now >= endTime + 63072000){\n', '                uint noTransfer2BonusYear = balances[_holder]*25 / 100;\n', '                if (balances[fundWallet] >= noTransfer2BonusYear) {\n', '                    balances[fundWallet] = balances[fundWallet] - noTransfer2BonusYear;\n', '                    balances[_holder] = balances[_holder] + noTransfer2BonusYear;\n', '                    assert(balances[_holder] >= noTransfer2BonusYear);\n', '                    Transfer(fundWallet, _holder, noTransfer2BonusYear);\n', '                    notransfer[_holder]=false;\n', '                    return noTransfer2BonusYear;\n', '                }\n', '            } else if (now >= endTime + 31536000) {\n', '                uint noTransferBonusYear = balances[_holder]*15 / 100;\n', '                if (balances[fundWallet] >= noTransferBonusYear) {\n', '                    balances[fundWallet] = balances[fundWallet] - noTransferBonusYear;\n', '                    balances[_holder] = balances[_holder] + noTransferBonusYear;\n', '                    assert(balances[_holder] >= noTransferBonusYear);\n', '                    Transfer(fundWallet, _holder, noTransferBonusYear);\n', '                    notransfer[_holder]=false;\n', '                    return noTransferBonusYear;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Unsold and undistributed tokens will be vested (50% for 2 years, 50% for 4 years) \n', '     * to be allocated for the future development needs of the project; \n', '     * in case of high unexpected volatility of the token, \n', '     * part or all of the vested tokens can be burned to support the token&#39;s value.\n', '     * /\n', '    /**\n', '     * function for after ICO burning tokens which was not bought\n', '     * @param _value uint256 Amount of burning tokens\n', '     */\n', '    function burn(uint256 _value) onlyOwner public returns (bool){\n', '        require(_value > 0);\n', '        require(_value <= balances[msg.sender]);\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner] - _value;\n', '        totalSupply = totalSupply - _value;\n', '        Burn(burner, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     *  Allownes refund\n', '     */\n', '    function changeRefundToken() public onlyOwner {\n', '        require(now >= endTime);\n', '        refundToken = true;\n', '    }\n', '    \n', '     /**\n', '     *  function for finishing ICO and allowed token transfer\n', '     */\n', '    function finishICO() public onlyOwner returns (bool) {\n', '        uint frozenBalance = balances[msg.sender]/2;\n', '        transfer(frozenWallet2y, frozenBalance);\n', '        transfer(frozenWallet4y, balances[msg.sender]);\n', '        transferAllowed = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * return investor tokens and burning\n', '     * \n', '     */\n', '    function refund()  canRefundToken public returns (bool){\n', '        uint256 _value = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        totalSupply = totalSupply - _value;\n', '        Refund(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Refund(address indexed refuner, uint256 value);\n', '\n', '}']
['pragma solidity 0.4.17;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract TripCash is Ownable {\n', '\n', '    uint256 public totalSupply = 5000000000 * 1 ether;\n', '\n', '\n', '    string public constant name = "TripCash";\n', '    string public constant symbol = "TASH";\n', '    uint8 public constant decimals = 18;\n', '\n', '    mapping (address => uint256) public balances; //Addresses map\n', '    mapping (address => mapping(address => uint256)) public allowed;\n', '    mapping (address => bool) public notransfer;\n', '\n', '\n', '    uint256 public startPreICO = 1523840400; // preICO  start date\n', '    uint256 public endPreICO = 1528675199; // preICO  finish date\n', '    uint256 public startTime = 1529884800; // ICO  start date\n', '    uint256 public endTime = 1532303999; // ICO  finish date\n', '\n', '\n', '    address public constant ownerWallet = 0x9dA14C46f0182D850B12866AB0f3e397Fbd4FaC4; // Owner wallet address\n', '    address public constant teamWallet1 = 0xe82F49A648FADaafd468E65a13C050434a4C4a6f ; // Team wallet address\n', '    address public constant teamWallet2 = 0x16Eb7B7E232590787F1Fe3742acB1a1d0e43AF2A; // Team wallet address\n', '    address public constant fundWallet = 0x949844acF5C722707d02A037D074cabe7474e0CB; // Fund wallet address\n', '    address public constant frozenWallet2y = 0xAc77c90b37AFd80D2227f74971e7c3ad3e29D1fb; // For rest token frozen 2 year\n', '    address public constant frozenWallet4y = 0x265B8e89DAbA5Bdc330E55cA826a9f2e0EFf0870; // For rest token frozen 4 year\n', '\n', '    uint256 public constant ownerPercent = 10; // Owner percent token rate\n', '    uint256 public constant teamPercent = 10; // Team percent token rate\n', '    uint256 public constant bountyPercent = 10; // Bounty percent token rate\n', '\n', '    bool public transferAllowed = false;\n', '    bool public refundToken = false;\n', '\n', '    /**\n', '     * Token constructor\n', '     *\n', '     **/\n', '    function TripCash() public {\n', '        balances[owner] = totalSupply;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking token transfer\n', '     */\n', '    modifier canTransferToken(address _from) {\n', '        if (_from != owner) {\n', '            require(transferAllowed);\n', '        }\n', '        \n', '        if (_from == teamWallet1) {\n', '            require(now >= endTime + 15552000);\n', '        }\n', '\n', '        if (_from == teamWallet2) {\n', '            require(now >= endTime + 31536000);\n', '        }\n', '        \n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking transfer allownes\n', '     */\n', '    modifier notAllowed(){\n', '        require(!transferAllowed);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking ICO period\n', '     */\n', '    modifier saleIsOn() {\n', '        require((now > startTime && now < endTime)||(now > startPreICO && now < endPreICO));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Modifier for checking refund allownes\n', '     */\n', '\n', '    modifier canRefundToken() {\n', '        require(refundToken);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        uint256 tokenValue = balances[owner];\n', '\n', '        transfer(_newOwner, tokenValue);\n', '        owner = _newOwner;\n', '\n', '        OwnershipTransferred(owner, _newOwner);\n', '\n', '    }\n', '\n', '    /**\n', '     *\n', '     *   Adding bonus tokens for bounty, team and owner needs. Should be used by DAPPs\n', '     */\n', '    function dappsBonusCalc(address _to, uint256 _value) onlyOwner saleIsOn() notAllowed public returns (bool) {\n', '\n', '        require(_value != 0);\n', '        transfer(_to, _value);\n', '        notransfer[_to] = true;\n', '\n', '        uint256 bountyTokenAmount = 0;\n', '        uint256 ownerTokenAmount = 0;\n', '        uint256 teamTokenAmount = 0;\n', '\n', '        //calc bounty bonuses\n', '        bountyTokenAmount = _value * bountyPercent / 60;\n', '\n', '        //calc owner bonuses\n', '        ownerTokenAmount = _value * ownerPercent / 60;\n', '\n', '        //calc teamTokenAmount bonuses\n', '        teamTokenAmount = _value * teamPercent / 60;\n', '        \n', '        transfer(ownerWallet, ownerTokenAmount);\n', '        transfer(fundWallet, bountyTokenAmount);\n', '        transfer(teamWallet1, teamTokenAmount);\n', '        transfer(teamWallet2, teamTokenAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *\n', '     *   Return number of tokens for address\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transfer(address _to, uint256 _value) canTransferToken(msg.sender) public returns (bool){\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] = balances[msg.sender] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '        if (notransfer[msg.sender] == true) {\n', '            notransfer[msg.sender] = false;\n', '        }\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) canTransferToken(_from) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from] - _value;\n', '        balances[_to] = balances[_to] + _value;\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue - _subtractedValue;\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', "     * @dev function for rewarding token holders, who didn't transfer in 1 or 2 years\n", '     * @param _holder token holders address\n', '     */\n', '\n', '    function rewarding(address _holder) public onlyOwner returns(uint){\n', '        if(notransfer[_holder]==true){\n', '            if(now >= endTime + 63072000){\n', '                uint noTransfer2BonusYear = balances[_holder]*25 / 100;\n', '                if (balances[fundWallet] >= noTransfer2BonusYear) {\n', '                    balances[fundWallet] = balances[fundWallet] - noTransfer2BonusYear;\n', '                    balances[_holder] = balances[_holder] + noTransfer2BonusYear;\n', '                    assert(balances[_holder] >= noTransfer2BonusYear);\n', '                    Transfer(fundWallet, _holder, noTransfer2BonusYear);\n', '                    notransfer[_holder]=false;\n', '                    return noTransfer2BonusYear;\n', '                }\n', '            } else if (now >= endTime + 31536000) {\n', '                uint noTransferBonusYear = balances[_holder]*15 / 100;\n', '                if (balances[fundWallet] >= noTransferBonusYear) {\n', '                    balances[fundWallet] = balances[fundWallet] - noTransferBonusYear;\n', '                    balances[_holder] = balances[_holder] + noTransferBonusYear;\n', '                    assert(balances[_holder] >= noTransferBonusYear);\n', '                    Transfer(fundWallet, _holder, noTransferBonusYear);\n', '                    notransfer[_holder]=false;\n', '                    return noTransferBonusYear;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Unsold and undistributed tokens will be vested (50% for 2 years, 50% for 4 years) \n', '     * to be allocated for the future development needs of the project; \n', '     * in case of high unexpected volatility of the token, \n', "     * part or all of the vested tokens can be burned to support the token's value.\n", '     * /\n', '    /**\n', '     * function for after ICO burning tokens which was not bought\n', '     * @param _value uint256 Amount of burning tokens\n', '     */\n', '    function burn(uint256 _value) onlyOwner public returns (bool){\n', '        require(_value > 0);\n', '        require(_value <= balances[msg.sender]);\n', '        // no need to require value <= totalSupply, since that would imply the\n', "        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner] - _value;\n', '        totalSupply = totalSupply - _value;\n', '        Burn(burner, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     *  Allownes refund\n', '     */\n', '    function changeRefundToken() public onlyOwner {\n', '        require(now >= endTime);\n', '        refundToken = true;\n', '    }\n', '    \n', '     /**\n', '     *  function for finishing ICO and allowed token transfer\n', '     */\n', '    function finishICO() public onlyOwner returns (bool) {\n', '        uint frozenBalance = balances[msg.sender]/2;\n', '        transfer(frozenWallet2y, frozenBalance);\n', '        transfer(frozenWallet4y, balances[msg.sender]);\n', '        transferAllowed = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * return investor tokens and burning\n', '     * \n', '     */\n', '    function refund()  canRefundToken public returns (bool){\n', '        uint256 _value = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        totalSupply = totalSupply - _value;\n', '        Refund(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Refund(address indexed refuner, uint256 value);\n', '\n', '}']
