['pragma solidity ^0.4.18;\n', '\n', '/** SafeMath libs are inspired by:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '  * There is debate as to whether this lib should use assert or require:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/issues/565\n', '\n', '  * `require` is used in these libraries for the following reasons:\n', '  *   - overflows should not be checked in contract function bodies; DRY\n', '  *   - "valid" user input can cause overflows, which should not assert()\n', '  */\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath64 {\n', '  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    uint64 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/DetailedERC20.sol\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/** SolClub has the following properties:\n', '  *\n', '  * Member Creation:\n', '  * - Self-registration\n', '  *   - Owner signs hash(address, username, endowment), and sends to member\n', '  *   - Member registers with username, endowment, and signature to create new account.\n', '  * - Mod creates new member.\n', '  * - Members are first eligible to withdraw dividends for the period after account creation.\n', '  *\n', '  * Karma/Token Rules:\n', '  * - Karma is created by initial member creation endowment.\n', '  * - Karma can also be minted by mod into an existing account.\n', '  * - Karma can only be transferred to existing account holder.\n', '  * - Karma implements the ERC20 token interface.\n', '  *\n', '  * Dividends:\n', '  * - each member can withdraw a dividend once per month.\n', '  * - dividend is total contract value minus owner cut at end of the month, divided by total number of members at end of month.\n', '  * - owner cut is determined at beginning of new period.\n', '  * - member has 1 month to withdraw their dividend from the previous month.\n', '  * - if member does not withdraw their dividend, their share will be given to owner.\n', '  * - mod can place a member on a 1 month "timeout", whereby they won&#39;t be eligible for a dividend.\n', '\n', '  * Eg: 10 eth is sent to the contract in January, owner cut is 30%. \n', '  * There are 70 token holders on Jan 31. At any time in February, each token holder can withdraw .1 eth for their January \n', '  * dividend (unless they were given a "timeout" in January).\n', '  */\n', 'contract SolClub is Ownable, DetailedERC20("SolClub", "SOL", 0) {\n', '  // SafeMath libs are responsible for checking overflow.\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '\n', '  struct Member {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage members.\n', '  mapping(address => Member) public members;\n', '  mapping(bytes20 => address) public usernames;\n', '\n', '  // Manage dividend payments.\n', '  uint256 public epoch; // Timestamp at start of new period.\n', '  uint256 dividendPool; // Total amount of dividends to pay out for last period.\n', '  uint256 public dividend; // Per-member share of last period&#39;s dividend.\n', '  uint256 public ownerCut; // Percentage, in basis points, of owner cut of this period&#39;s payments.\n', '  uint64 public numMembers; // Number of members created before this period.\n', '  uint64 public newMembers; // Number of members created during this period.\n', '  uint16 public currentPeriod = 1;\n', '\n', '  address public moderator;\n', '\n', '  mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event PeriodEnd(uint16 period, uint256 amount, uint64 members);\n', '  event Payment(address indexed from, uint256 amount);\n', '  event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);\n', '  event NewMember(address indexed addr, bytes20 username, uint64 endowment);\n', '  event RemovedMember(address indexed addr, bytes20 username, uint64 karma, bytes32 reason);\n', '\n', '  modifier onlyMod() {\n', '    require(msg.sender == moderator);\n', '    _;\n', '  }\n', '\n', '  function SolClub() public {\n', '    epoch = now;\n', '    moderator = msg.sender;\n', '  }\n', '\n', '  function() payable public {\n', '    Payment(msg.sender, msg.value);\n', '  }\n', '\n', '  /** \n', '   * Owner Functions \n', '   */\n', '\n', '  function setMod(address _newMod) public onlyOwner {\n', '    moderator = _newMod;\n', '  }\n', '\n', '  // Owner should call this on twice a month.\n', '  // _ownerCut is new owner cut for new period.\n', '  function newPeriod(uint256 _ownerCut) public onlyOwner {\n', '    require(now >= epoch + 15 days);\n', '    require(_ownerCut <= 10000);\n', '\n', '    uint256 unclaimedDividend = dividendPool;\n', '    uint256 ownerRake = (address(this).balance-unclaimedDividend) * ownerCut / 10000;\n', '\n', '    dividendPool = address(this).balance - unclaimedDividend - ownerRake;\n', '\n', '    // Calculate dividend.\n', '    uint64 existingMembers = numMembers;\n', '    if (existingMembers == 0) {\n', '      dividend = 0;\n', '    } else {\n', '      dividend = dividendPool / existingMembers;\n', '    }\n', '\n', '    numMembers = numMembers.add(newMembers);\n', '    newMembers = 0;\n', '    currentPeriod++;\n', '    epoch = now;\n', '    ownerCut = _ownerCut;\n', '\n', '    msg.sender.transfer(ownerRake + unclaimedDividend);\n', '    PeriodEnd(currentPeriod-1, this.balance, existingMembers);\n', '  }\n', '\n', '  // Places member is a "banished" state whereby they are no longer a member,\n', '  // but their username remains active (preventing re-registration)\n', '  function removeMember(address _addr, bytes32 _reason) public onlyOwner {\n', '    require(members[_addr].birthPeriod != 0);\n', '    Member memory m = members[_addr];\n', '\n', '    totalSupply = totalSupply.sub(m.karma);\n', '    if (m.birthPeriod == currentPeriod) {\n', '      newMembers--;\n', '    } else {\n', '      numMembers--;\n', '    }\n', '\n', '    // "Burns" username, so user can&#39;t recreate.\n', '    usernames[m.username] = address(0x1);\n', '\n', '    delete members[_addr];\n', '    RemovedMember(_addr, m.username, m.karma, _reason);\n', '  }\n', '\n', '  // Place a username back into circulation for re-registration.\n', '  function deleteUsername(bytes20 _username) public onlyOwner {\n', '    require(usernames[_username] == address(0x1));\n', '    delete usernames[_username];\n', '  }\n', '\n', '  /**\n', '    * Mod Functions\n', '    */\n', '\n', '  function createMember(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\n', '    newMember(_addr, _username, _amount);\n', '  }\n', '\n', '  // Send karma to existing account.\n', '  function mint(address _addr, uint64 _amount) public onlyMod {\n', '    require(members[_addr].canWithdrawPeriod != 0);\n', '\n', '    members[_addr].karma = members[_addr].karma.add(_amount);\n', '    totalSupply = totalSupply.add(_amount);\n', '    Mint(_addr, _amount);\n', '  }\n', '\n', '  // If a member has been bad, they won&#39;t be able to receive a dividend :(\n', '  function timeout(address _addr) public onlyMod {\n', '    require(members[_addr].canWithdrawPeriod != 0);\n', '\n', '    members[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '  }\n', '\n', '  /**\n', '    * Member Functions\n', '    */\n', '\n', '  // Owner will sign hash(address, username, amount), and address owner uses this \n', '  // signature to register their account.\n', '  function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\n', '    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\n', '    newMember(msg.sender, _username, _endowment);\n', '  }\n', '\n', '  // Member can withdraw their share of donations from the previous month.\n', '  function withdraw() public {\n', '    require(members[msg.sender].canWithdrawPeriod != 0);\n', '    require(members[msg.sender].canWithdrawPeriod < currentPeriod);\n', '\n', '    members[msg.sender].canWithdrawPeriod = currentPeriod;\n', '    dividendPool -= dividend;\n', '    msg.sender.transfer(dividend);\n', '    Withdrawal(msg.sender, currentPeriod-1, dividend);\n', '  }\n', '\n', '  /**\n', '    * ERC20 Functions\n', '    */\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return members[_owner].karma;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing member.\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(members[_to].canWithdrawPeriod != 0);\n', '    require(_value <= members[msg.sender].karma);\n', '\n', '    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\n', '    members[msg.sender].karma = members[msg.sender].karma.sub(uint64(_value));\n', '    members[_to].karma = members[_to].karma.add(uint64(_value));\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing member.\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(members[_to].canWithdrawPeriod != 0);\n', '    require(_value <= members[_from].karma);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    members[_from].karma = members[_from].karma.sub(uint64(_value));\n', '    members[_to].karma = members[_to].karma.add(uint64(_value));\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * Private Functions\n', '    */\n', '\n', '  // Ensures that username isn&#39;t taken, and account doesn&#39;t already exist for\n', '  // member&#39;s address.\n', '  function newMember(address _addr, bytes20 _username, uint64 _endowment) private {\n', '    require(usernames[_username] == address(0));\n', '    require(members[_addr].canWithdrawPeriod == 0);\n', '\n', '    members[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '    members[_addr].birthPeriod = currentPeriod;\n', '    members[_addr].karma = _endowment;\n', '    members[_addr].username = _username;\n', '    usernames[_username] = _addr;\n', '\n', '    newMembers = newMembers.add(1);\n', '    totalSupply = totalSupply.add(_endowment);\n', '    NewMember(_addr, _username, _endowment);\n', '  }\n', '\n', '  // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/** SafeMath libs are inspired by:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '  * There is debate as to whether this lib should use assert or require:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/issues/565\n', '\n', '  * `require` is used in these libraries for the following reasons:\n', '  *   - overflows should not be checked in contract function bodies; DRY\n', '  *   - "valid" user input can cause overflows, which should not assert()\n', '  */\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath64 {\n', '  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    uint64 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/DetailedERC20.sol\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/** SolClub has the following properties:\n', '  *\n', '  * Member Creation:\n', '  * - Self-registration\n', '  *   - Owner signs hash(address, username, endowment), and sends to member\n', '  *   - Member registers with username, endowment, and signature to create new account.\n', '  * - Mod creates new member.\n', '  * - Members are first eligible to withdraw dividends for the period after account creation.\n', '  *\n', '  * Karma/Token Rules:\n', '  * - Karma is created by initial member creation endowment.\n', '  * - Karma can also be minted by mod into an existing account.\n', '  * - Karma can only be transferred to existing account holder.\n', '  * - Karma implements the ERC20 token interface.\n', '  *\n', '  * Dividends:\n', '  * - each member can withdraw a dividend once per month.\n', '  * - dividend is total contract value minus owner cut at end of the month, divided by total number of members at end of month.\n', '  * - owner cut is determined at beginning of new period.\n', '  * - member has 1 month to withdraw their dividend from the previous month.\n', '  * - if member does not withdraw their dividend, their share will be given to owner.\n', '  * - mod can place a member on a 1 month "timeout", whereby they won\'t be eligible for a dividend.\n', '\n', '  * Eg: 10 eth is sent to the contract in January, owner cut is 30%. \n', '  * There are 70 token holders on Jan 31. At any time in February, each token holder can withdraw .1 eth for their January \n', '  * dividend (unless they were given a "timeout" in January).\n', '  */\n', 'contract SolClub is Ownable, DetailedERC20("SolClub", "SOL", 0) {\n', '  // SafeMath libs are responsible for checking overflow.\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '\n', '  struct Member {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage members.\n', '  mapping(address => Member) public members;\n', '  mapping(bytes20 => address) public usernames;\n', '\n', '  // Manage dividend payments.\n', '  uint256 public epoch; // Timestamp at start of new period.\n', '  uint256 dividendPool; // Total amount of dividends to pay out for last period.\n', "  uint256 public dividend; // Per-member share of last period's dividend.\n", "  uint256 public ownerCut; // Percentage, in basis points, of owner cut of this period's payments.\n", '  uint64 public numMembers; // Number of members created before this period.\n', '  uint64 public newMembers; // Number of members created during this period.\n', '  uint16 public currentPeriod = 1;\n', '\n', '  address public moderator;\n', '\n', '  mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event PeriodEnd(uint16 period, uint256 amount, uint64 members);\n', '  event Payment(address indexed from, uint256 amount);\n', '  event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);\n', '  event NewMember(address indexed addr, bytes20 username, uint64 endowment);\n', '  event RemovedMember(address indexed addr, bytes20 username, uint64 karma, bytes32 reason);\n', '\n', '  modifier onlyMod() {\n', '    require(msg.sender == moderator);\n', '    _;\n', '  }\n', '\n', '  function SolClub() public {\n', '    epoch = now;\n', '    moderator = msg.sender;\n', '  }\n', '\n', '  function() payable public {\n', '    Payment(msg.sender, msg.value);\n', '  }\n', '\n', '  /** \n', '   * Owner Functions \n', '   */\n', '\n', '  function setMod(address _newMod) public onlyOwner {\n', '    moderator = _newMod;\n', '  }\n', '\n', '  // Owner should call this on twice a month.\n', '  // _ownerCut is new owner cut for new period.\n', '  function newPeriod(uint256 _ownerCut) public onlyOwner {\n', '    require(now >= epoch + 15 days);\n', '    require(_ownerCut <= 10000);\n', '\n', '    uint256 unclaimedDividend = dividendPool;\n', '    uint256 ownerRake = (address(this).balance-unclaimedDividend) * ownerCut / 10000;\n', '\n', '    dividendPool = address(this).balance - unclaimedDividend - ownerRake;\n', '\n', '    // Calculate dividend.\n', '    uint64 existingMembers = numMembers;\n', '    if (existingMembers == 0) {\n', '      dividend = 0;\n', '    } else {\n', '      dividend = dividendPool / existingMembers;\n', '    }\n', '\n', '    numMembers = numMembers.add(newMembers);\n', '    newMembers = 0;\n', '    currentPeriod++;\n', '    epoch = now;\n', '    ownerCut = _ownerCut;\n', '\n', '    msg.sender.transfer(ownerRake + unclaimedDividend);\n', '    PeriodEnd(currentPeriod-1, this.balance, existingMembers);\n', '  }\n', '\n', '  // Places member is a "banished" state whereby they are no longer a member,\n', '  // but their username remains active (preventing re-registration)\n', '  function removeMember(address _addr, bytes32 _reason) public onlyOwner {\n', '    require(members[_addr].birthPeriod != 0);\n', '    Member memory m = members[_addr];\n', '\n', '    totalSupply = totalSupply.sub(m.karma);\n', '    if (m.birthPeriod == currentPeriod) {\n', '      newMembers--;\n', '    } else {\n', '      numMembers--;\n', '    }\n', '\n', '    // "Burns" username, so user can\'t recreate.\n', '    usernames[m.username] = address(0x1);\n', '\n', '    delete members[_addr];\n', '    RemovedMember(_addr, m.username, m.karma, _reason);\n', '  }\n', '\n', '  // Place a username back into circulation for re-registration.\n', '  function deleteUsername(bytes20 _username) public onlyOwner {\n', '    require(usernames[_username] == address(0x1));\n', '    delete usernames[_username];\n', '  }\n', '\n', '  /**\n', '    * Mod Functions\n', '    */\n', '\n', '  function createMember(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\n', '    newMember(_addr, _username, _amount);\n', '  }\n', '\n', '  // Send karma to existing account.\n', '  function mint(address _addr, uint64 _amount) public onlyMod {\n', '    require(members[_addr].canWithdrawPeriod != 0);\n', '\n', '    members[_addr].karma = members[_addr].karma.add(_amount);\n', '    totalSupply = totalSupply.add(_amount);\n', '    Mint(_addr, _amount);\n', '  }\n', '\n', "  // If a member has been bad, they won't be able to receive a dividend :(\n", '  function timeout(address _addr) public onlyMod {\n', '    require(members[_addr].canWithdrawPeriod != 0);\n', '\n', '    members[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '  }\n', '\n', '  /**\n', '    * Member Functions\n', '    */\n', '\n', '  // Owner will sign hash(address, username, amount), and address owner uses this \n', '  // signature to register their account.\n', '  function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\n', '    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\n', '    newMember(msg.sender, _username, _endowment);\n', '  }\n', '\n', '  // Member can withdraw their share of donations from the previous month.\n', '  function withdraw() public {\n', '    require(members[msg.sender].canWithdrawPeriod != 0);\n', '    require(members[msg.sender].canWithdrawPeriod < currentPeriod);\n', '\n', '    members[msg.sender].canWithdrawPeriod = currentPeriod;\n', '    dividendPool -= dividend;\n', '    msg.sender.transfer(dividend);\n', '    Withdrawal(msg.sender, currentPeriod-1, dividend);\n', '  }\n', '\n', '  /**\n', '    * ERC20 Functions\n', '    */\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return members[_owner].karma;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing member.\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(members[_to].canWithdrawPeriod != 0);\n', '    require(_value <= members[msg.sender].karma);\n', '\n', '    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\n', '    members[msg.sender].karma = members[msg.sender].karma.sub(uint64(_value));\n', '    members[_to].karma = members[_to].karma.add(uint64(_value));\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing member.\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(members[_to].canWithdrawPeriod != 0);\n', '    require(_value <= members[_from].karma);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    members[_from].karma = members[_from].karma.sub(uint64(_value));\n', '    members[_to].karma = members[_to].karma.add(uint64(_value));\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * Private Functions\n', '    */\n', '\n', "  // Ensures that username isn't taken, and account doesn't already exist for\n", "  // member's address.\n", '  function newMember(address _addr, bytes20 _username, uint64 _endowment) private {\n', '    require(usernames[_username] == address(0));\n', '    require(members[_addr].canWithdrawPeriod == 0);\n', '\n', '    members[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '    members[_addr].birthPeriod = currentPeriod;\n', '    members[_addr].karma = _endowment;\n', '    members[_addr].username = _username;\n', '    usernames[_username] = _addr;\n', '\n', '    newMembers = newMembers.add(1);\n', '    totalSupply = totalSupply.add(_endowment);\n', '    NewMember(_addr, _username, _endowment);\n', '  }\n', '\n', '  // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}']
