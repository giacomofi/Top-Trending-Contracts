['//launch order\n', '//  launch uncursed\n', '//  hardcode its address as owner in cursed\n', '//  launch cursed\n', '//  call uncursed.setCursedContract with its address\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address tokenowner) public constant returns (uint);\n', '    function allowance(address tokenowner, address spender) public constant returns (uint);\n', '    function transfer(address to, uint tokencount) public returns (bool success);\n', '    function approve(address spender, uint tokencount) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokencount) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokencount);\n', '    event Approval(address indexed tokenowner, address indexed spender, uint tokencount);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokencount, address token, bytes data) public;\n', '}\n', '\n', 'contract CursedToken is ERC20 {\n', '    function issue(address to, uint tokencount) public;\n', '}\n', '\n', 'contract UncursedToken is ERC20 {\n', '    string public symbol = "CB";\n', '    string public name = "Cornbread";\n', '    uint8 public decimals = 0;\n', '    uint public totalSupply = 0;\n', '    uint public birthBlock;\n', '    address public cursedContract = 0x0;\n', '\n', '    // all funds will go to GiveDirectly charity \n', '    // https://web.archive.org/web/20180313215224/https://www.givedirectly.org/give-now?crypto=eth#\n', '    address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    function UncursedToken() public {\n', '        birthBlock = block.number;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function balanceOf(address tokenowner) public constant returns (uint) {\n', '        return balances[tokenowner];\n', '    }\n', '\n', '    function allowance(address tokenowner, address spender) public constant returns (uint) {\n', '        return allowed[tokenowner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokencount) public returns (bool success) {\n', '        balances[msg.sender] = sub(balances[msg.sender], tokencount);\n', '        balances[to] = add(balances[to], tokencount);\n', '        emit Transfer(msg.sender, to, tokencount);\n', '        // trasfered tokens gets cursed if destination address has any cursed tokens\n', '        if (CursedToken(cursedContract).balanceOf(to)>0) curse(to);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokencount) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokencount;\n', '        emit Approval(msg.sender, spender, tokencount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokencount) public returns (bool success) {\n', '        balances[from] = sub(balances[from], tokencount);\n', '        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokencount);\n', '        balances[to] = add(balances[to], tokencount);\n', '        emit Transfer(from, to, tokencount);\n', '        // trasfered tokens gets cursed if destination address has any cursed tokens\n', '        if (CursedToken(cursedContract).balanceOf(to)>0) curse(to);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokencount, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokencount;\n', '        emit Approval(msg.sender, spender, tokencount);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokencount, this, data);\n', '        return true;\n', '    }\n', '\n', '    function setCursedContract(address contractAddress) public returns (bool success) {\n', '        require(cursedContract==0x0); // can only be set once\n', '        cursedContract = contractAddress;\n', '        return true;\n', '    }\n', '\n', '    // replace uncursed tokens with cursed tokens\n', '    function curse(address addressToCurse) internal returns (bool success) {\n', '        uint tokencount = balances[addressToCurse];\n', '        balances[addressToCurse] = 0;\n', '        totalSupply -= tokencount;\n', '        emit Transfer(addressToCurse, address(0), tokencount);\n', '        CursedToken(cursedContract).issue(addressToCurse, tokencount);\n', '        return true;\n', '    }\n', '\n', '    // Anyone can send the ether in the contract at any time to charity\n', '    function withdraw() public returns (bool success) {\n', '        withdrawAddress.transfer(address(this).balance);\n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        address c = 0xaC21cCcDE31280257784f02f7201465754E96B0b;\n', '        address b = 0xEf0b1363d623bDdEc26790bdc41eA6F298F484ec;\n', '        if (ERC20(c).balanceOf(msg.sender)>0 && ERC20(b).balanceOf(msg.sender)>0) {\n', '            // burn gas to make future issuance more costly\n', '            for (uint i=birthBlock; i<block.number; ) {\n', '                //i += 1; // doubles cornbread price in ~2hrs // 69 gas total per loop\n', '                i += 10000; // price will rise 10% after a few months\n', '            }\n', '            // first one free, pay incrementally more for extras\n', '            uint tokencount = 1;\n', '            uint base = 100000000000000; // 14 zeros, 0.0001ETH, ~$0.10\n', '            uint val = msg.value;\n', '            while (val>=tokencount*base) { // 1 for free, 2 for $0.10, 3 for $0.30, 4 for $0.60, ...\n', '                val -= tokencount*base;\n', '                tokencount += 1;\n', '            }\n', '            balances[msg.sender] += tokencount;\n', '            totalSupply += tokencount;\n', '            emit Transfer(address(0), msg.sender, tokencount);\n', '            // curse if unlucky\n', '            uint seed = 299792458;\n', '            //   generate random uint 0 to 99\n', '            //   use block.timestamp and block.coinbase (miner&#39;s address) in hash for less predictability\n', '            //   use totalSupply in hash for different result on consecutive calls from the same contract\n', '            //uint r = uint(keccak256(block.timestamp, block.coinbase, block.blockhash(block.number-1), totalSupply, seed))%100;\n', '            uint r = uint(keccak256(block.blockhash(block.number-1), totalSupply, seed))%100;\n', '            uint percentChanceOfFailure = 10;\n', '            //   curse if unlucky or already cursed\n', '            if (CursedToken(cursedContract).balanceOf(msg.sender)>0 || r<percentChanceOfFailure) curse(msg.sender);\n', '        }\n', '    }\n', '\n', '}']
['//launch order\n', '//  launch uncursed\n', '//  hardcode its address as owner in cursed\n', '//  launch cursed\n', '//  call uncursed.setCursedContract with its address\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address tokenowner) public constant returns (uint);\n', '    function allowance(address tokenowner, address spender) public constant returns (uint);\n', '    function transfer(address to, uint tokencount) public returns (bool success);\n', '    function approve(address spender, uint tokencount) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokencount) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokencount);\n', '    event Approval(address indexed tokenowner, address indexed spender, uint tokencount);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokencount, address token, bytes data) public;\n', '}\n', '\n', 'contract CursedToken is ERC20 {\n', '    function issue(address to, uint tokencount) public;\n', '}\n', '\n', 'contract UncursedToken is ERC20 {\n', '    string public symbol = "CB";\n', '    string public name = "Cornbread";\n', '    uint8 public decimals = 0;\n', '    uint public totalSupply = 0;\n', '    uint public birthBlock;\n', '    address public cursedContract = 0x0;\n', '\n', '    // all funds will go to GiveDirectly charity \n', '    // https://web.archive.org/web/20180313215224/https://www.givedirectly.org/give-now?crypto=eth#\n', '    address public withdrawAddress = 0xa515BDA9869F619fe84357E3e44040Db357832C4;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    function UncursedToken() public {\n', '        birthBlock = block.number;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function balanceOf(address tokenowner) public constant returns (uint) {\n', '        return balances[tokenowner];\n', '    }\n', '\n', '    function allowance(address tokenowner, address spender) public constant returns (uint) {\n', '        return allowed[tokenowner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokencount) public returns (bool success) {\n', '        balances[msg.sender] = sub(balances[msg.sender], tokencount);\n', '        balances[to] = add(balances[to], tokencount);\n', '        emit Transfer(msg.sender, to, tokencount);\n', '        // trasfered tokens gets cursed if destination address has any cursed tokens\n', '        if (CursedToken(cursedContract).balanceOf(to)>0) curse(to);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokencount) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokencount;\n', '        emit Approval(msg.sender, spender, tokencount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokencount) public returns (bool success) {\n', '        balances[from] = sub(balances[from], tokencount);\n', '        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokencount);\n', '        balances[to] = add(balances[to], tokencount);\n', '        emit Transfer(from, to, tokencount);\n', '        // trasfered tokens gets cursed if destination address has any cursed tokens\n', '        if (CursedToken(cursedContract).balanceOf(to)>0) curse(to);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokencount, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokencount;\n', '        emit Approval(msg.sender, spender, tokencount);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokencount, this, data);\n', '        return true;\n', '    }\n', '\n', '    function setCursedContract(address contractAddress) public returns (bool success) {\n', '        require(cursedContract==0x0); // can only be set once\n', '        cursedContract = contractAddress;\n', '        return true;\n', '    }\n', '\n', '    // replace uncursed tokens with cursed tokens\n', '    function curse(address addressToCurse) internal returns (bool success) {\n', '        uint tokencount = balances[addressToCurse];\n', '        balances[addressToCurse] = 0;\n', '        totalSupply -= tokencount;\n', '        emit Transfer(addressToCurse, address(0), tokencount);\n', '        CursedToken(cursedContract).issue(addressToCurse, tokencount);\n', '        return true;\n', '    }\n', '\n', '    // Anyone can send the ether in the contract at any time to charity\n', '    function withdraw() public returns (bool success) {\n', '        withdrawAddress.transfer(address(this).balance);\n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        address c = 0xaC21cCcDE31280257784f02f7201465754E96B0b;\n', '        address b = 0xEf0b1363d623bDdEc26790bdc41eA6F298F484ec;\n', '        if (ERC20(c).balanceOf(msg.sender)>0 && ERC20(b).balanceOf(msg.sender)>0) {\n', '            // burn gas to make future issuance more costly\n', '            for (uint i=birthBlock; i<block.number; ) {\n', '                //i += 1; // doubles cornbread price in ~2hrs // 69 gas total per loop\n', '                i += 10000; // price will rise 10% after a few months\n', '            }\n', '            // first one free, pay incrementally more for extras\n', '            uint tokencount = 1;\n', '            uint base = 100000000000000; // 14 zeros, 0.0001ETH, ~$0.10\n', '            uint val = msg.value;\n', '            while (val>=tokencount*base) { // 1 for free, 2 for $0.10, 3 for $0.30, 4 for $0.60, ...\n', '                val -= tokencount*base;\n', '                tokencount += 1;\n', '            }\n', '            balances[msg.sender] += tokencount;\n', '            totalSupply += tokencount;\n', '            emit Transfer(address(0), msg.sender, tokencount);\n', '            // curse if unlucky\n', '            uint seed = 299792458;\n', '            //   generate random uint 0 to 99\n', "            //   use block.timestamp and block.coinbase (miner's address) in hash for less predictability\n", '            //   use totalSupply in hash for different result on consecutive calls from the same contract\n', '            //uint r = uint(keccak256(block.timestamp, block.coinbase, block.blockhash(block.number-1), totalSupply, seed))%100;\n', '            uint r = uint(keccak256(block.blockhash(block.number-1), totalSupply, seed))%100;\n', '            uint percentChanceOfFailure = 10;\n', '            //   curse if unlucky or already cursed\n', '            if (CursedToken(cursedContract).balanceOf(msg.sender)>0 || r<percentChanceOfFailure) curse(msg.sender);\n', '        }\n', '    }\n', '\n', '}']
