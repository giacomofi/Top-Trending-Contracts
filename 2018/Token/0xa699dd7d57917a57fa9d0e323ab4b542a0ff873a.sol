['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title TokenLib\n', ' * @author Modular Inc, https://modular.network\n', ' *\n', ' * version 1.3.0\n', ' * Copyright (c) 2017 Modular, Inc\n', ' * The MIT License (MIT)\n', ' * https://github.com/Modular-Network/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The Token Library provides functionality to create a variety of ERC20 tokens.\n', ' * See https://github.com/Modular-Network/ethereum-contracts for an example of how to\n', ' * create a basic ERC20 token.\n', ' *\n', ' * Modular works on open source projects in the Ethereum community with the\n', ' * purpose of testing, documenting, and deploying reusable code onto the\n', ' * blockchain to improve security and usability of smart contracts. Modular\n', ' * also strives to educate non-profits, schools, and other community members\n', ' * about the application of blockchain technology.\n', ' * For further information: modular.network\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library TokenLib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct TokenStorage {\n', '    bool initialized;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    string name;\n', '    string symbol;\n', '    uint256 totalSupply;\n', '    uint256 initialSupply;\n', '    address owner;\n', '    uint8 decimals;\n', '    bool stillMinting;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event OwnerChange(address from, address to);\n', '  event Burn(address indexed burner, uint256 value);\n', '  event MintingClosed(bool mintingClosed);\n', '\n', '  /// @dev Called by the Standard Token upon creation.\n', '  /// @param self Stored token from token contract\n', '  /// @param _name Name of the new token\n', '  /// @param _symbol Symbol of the new token\n', '  /// @param _decimals Decimal places for the token represented\n', '  /// @param _initial_supply The initial token supply\n', '  /// @param _allowMinting True if additional tokens can be created, false otherwise\n', '  function init(TokenStorage storage self,\n', '                address _owner,\n', '                string _name,\n', '                string _symbol,\n', '                uint8 _decimals,\n', '                uint256 _initial_supply,\n', '                bool _allowMinting)\n', '                public\n', '  {\n', '    require(!self.initialized);\n', '    self.initialized = true;\n', '    self.name = _name;\n', '    self.symbol = _symbol;\n', '    self.totalSupply = _initial_supply;\n', '    self.initialSupply = _initial_supply;\n', '    self.decimals = _decimals;\n', '    self.owner = _owner;\n', '    self.stillMinting = _allowMinting;\n', '    self.balances[_owner] = _initial_supply;\n', '  }\n', '\n', '  /// @dev Transfer tokens from caller&#39;s account to another account.\n', '  /// @param self Stored token from token contract\n', '  /// @param _to Address to send tokens\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    bool err;\n', '    uint256 balance;\n', '\n', '    (err,balance) = self.balances[msg.sender].minus(_value);\n', '    require(!err);\n', '    self.balances[msg.sender] = balance;\n', '    //It&#39;s not possible to overflow token supply\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Authorized caller transfers tokens from one account to another\n', '  /// @param self Stored token from token contract\n', '  /// @param _from Address to send tokens from\n', '  /// @param _to Address to send tokens to\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transferFrom(TokenStorage storage self,\n', '                        address _from,\n', '                        address _to,\n', '                        uint256 _value)\n', '                        public\n', '                        returns (bool)\n', '  {\n', '    uint256 _allowance = self.allowed[_from][msg.sender];\n', '    bool err;\n', '    uint256 balanceOwner;\n', '    uint256 balanceSpender;\n', '\n', '    (err,balanceOwner) = self.balances[_from].minus(_value);\n', '    require(!err);\n', '\n', '    (err,balanceSpender) = _allowance.minus(_value);\n', '    require(!err);\n', '\n', '    self.balances[_from] = balanceOwner;\n', '    self.allowed[_from][msg.sender] = balanceSpender;\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Retrieve token balance for an account\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address to retrieve balance of\n', '  /// @return balance The number of tokens in the subject account\n', '  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n', '    return self.balances[_owner];\n', '  }\n', '\n', '  /// @dev Authorize an account to send tokens on caller&#39;s behalf\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _value Number of tokens authorized account may send\n', '  /// @return True if completed\n', '  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n', '    // must set to zero before changing approval amount in accordance with spec\n', '    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n', '\n', '    self.allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Remaining tokens third party spender has to send\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address of token holder\n', '  /// @param _spender Address of authorized spender\n', '  /// @return remaining Number of tokens spender has left in owner&#39;s account\n', '  function allowance(TokenStorage storage self, address _owner, address _spender)\n', '                     public\n', '                     view\n', '                     returns (uint256 remaining) {\n', '    return self.allowed[_owner][_spender];\n', '  }\n', '\n', '  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\n', '  /// @param _increase True if increasing allowance, false if decreasing allowance\n', '  /// @return True if completed\n', '  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n', '                          public returns (bool)\n', '  {\n', '    uint256 _newAllowed;\n', '    bool err;\n', '\n', '    if(_increase) {\n', '      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n', '      require(!err);\n', '\n', '      self.allowed[msg.sender][_spender] = _newAllowed;\n', '    } else {\n', '      if (_valueChange > self.allowed[msg.sender][_spender]) {\n', '        self.allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n', '        self.allowed[msg.sender][_spender] = _newAllowed;\n', '      }\n', '    }\n', '\n', '    emit Approval(msg.sender, _spender, _newAllowed);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Change owning address of the token contract, specifically for minting\n', '  /// @param self Stored token from token contract\n', '  /// @param _newOwner Address for the new owner\n', '  /// @return True if completed\n', '  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n', '    require((self.owner == msg.sender) && (_newOwner > 0));\n', '\n', '    self.owner = _newOwner;\n', '    emit OwnerChange(msg.sender, _newOwner);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Mints additional tokens, new tokens go to owner\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Number of tokens to mint\n', '  /// @return True if completed\n', '  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n', '    require((self.owner == msg.sender) && self.stillMinting);\n', '    uint256 _newAmount;\n', '    bool err;\n', '\n', '    (err, _newAmount) = self.totalSupply.plus(_amount);\n', '    require(!err);\n', '\n', '    self.totalSupply =  _newAmount;\n', '    self.balances[self.owner] = self.balances[self.owner] + _amount;\n', '    emit Transfer(0x0, self.owner, _amount);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanent stops minting\n', '  /// @param self Stored token from token contract\n', '  /// @return True if completed\n', '  function closeMint(TokenStorage storage self) public returns (bool) {\n', '    require(self.owner == msg.sender);\n', '\n', '    self.stillMinting = false;\n', '    emit MintingClosed(true);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanently burn tokens\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Amount of tokens to burn\n', '  /// @return True if completed\n', '  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n', '      uint256 _newBalance;\n', '      bool err;\n', '\n', '      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n', '      require(!err);\n', '\n', '      self.balances[msg.sender] = _newBalance;\n', '      self.totalSupply = self.totalSupply - _amount;\n', '      emit Burn(msg.sender, _amount);\n', '      emit Transfer(msg.sender, 0x0, _amount);\n', '      return true;\n', '  }\n', '}\n', '\n', 'library BasicMathLib {\n', '  /// @dev Multiplies two numbers and checks for overflow before returning.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The product of a and b, or 0 if there is overflow\n', '  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := mul(a,b)\n', '      switch or(iszero(b), eq(div(res,b), a))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Divides two numbers but checks for 0 in the divisor first.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if `b` is 0\n', '  /// @return res The quotient of a and b, or 0 if `b` is 0\n', '  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n', '    uint256 res;\n', '    assembly{\n', '      switch iszero(b)\n', '      case 0 {\n', '        res := div(a,b)\n', '        let loc := mload(0x40)\n', '        mstore(add(loc,0x20),res)\n', '        i := mload(add(loc,0x20))\n', '      }\n', '      default {\n', '        err := 1\n', '        i := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Adds two numbers and checks for overflow before returning.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The sum of a and b, or 0 if there is overflow\n', '  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n', '    assembly{\n', '      res := add(a,b)\n', '      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Subtracts two numbers and checks for underflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is underflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is underflow\n', '  /// @return res The difference between a and b, or 0 if there is underflow\n', '  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := sub(a,b)\n', '      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '}']