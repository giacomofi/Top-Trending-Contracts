['pragma solidity ^0.4.21;\n', '\n', 'contract ERC20Interface {\n', '    // function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    //function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    //function symbol() public constant returns (string);\n', '    //function decimals() public constant returns (uint256);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', 'contract Control {\n', '    bool public pause;\n', '    address public owner;\n', '\n', '    event Pause(bool pause);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier notPause {\n', '        require(!pause);\n', '        _;\n', '    }\n', '\n', '    function setPause(bool _pause) public onlyOwner {\n', '        pause = _pause;\n', '\n', '        emit Pause(_pause);\n', '    }\n', '}\n', '\n', 'contract Share is Control {\n', '    uint256 public totalSupply;\n', '    uint256 public watermark;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public fullfilled;\n', '    mapping (address => uint256) public sellPrice;\n', '    mapping (address => uint256) public toSell;\n', '\n', '    event Transfer(address from, address to, uint256 amount);\n', '    event Income(uint256);\n', '    event Sell(address holder, uint256 price, uint256 amount);\n', '    event Buy(address seller, address buyer, uint256 amount, uint256 value);\n', '    event Withdraw(address owner, uint256 amount);\n', '\n', '    constructor(uint256 _totalSupply) public {\n', '        totalSupply = _totalSupply;\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        emit Transfer(0, msg.sender, totalSupply);\n', '    }\n', '\n', '    function onIncome() public payable notPause {\n', '        if (msg.value > 0) {\n', '            uint256 split = (msg.value / totalSupply);\n', '            watermark += split;\n', '            assert(watermark * totalSupply > watermark);\n', '            emit Income(msg.value);\n', '        }\n', '    }\n', '\n', '    function() public payable {\n', '        onIncome();\n', '    }\n', '\n', '    function revenue() public view returns (uint256) {\n', '        return (watermark - fullfilled[msg.sender]) * balances[msg.sender];\n', '    }\n', '\n', '    function withdraw() public notPause {\n', '        if(balances[msg.sender] == 0) {\n', '            return;\n', '        }\n', '        uint256 value = revenue();\n', '        fullfilled[msg.sender] = watermark;\n', '        msg.sender.transfer(value);\n', '\n', '        emit Withdraw(msg.sender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 amount) internal {\n', '        // prevent overflow\n', '        require(amount > 0);\n', '        require(balances[from] >= amount);\n', '        require(balances[to] + amount > balances[to]);\n', '        \n', '\n', '        uint256 fromBonus = (watermark - fullfilled[from]) * amount;\n', '        uint256 toBonus = (watermark - fullfilled[to]) * balances[to];\n', '\n', '        balances[from] -= amount;\n', '        balances[to] += amount;\n', '\n', '        //for to, the revenue stays the same, but balance increases, so update the fullfilled\n', '        fullfilled[to] = (watermark * balances[to] - toBonus)/balances[to];\n', '\n', '        //for from, withdraw the revenue on the amount of token transferd\n', '        from.transfer(fromBonus);\n', '\n', '        emit Transfer(from, to, amount);\n', '        emit Withdraw(from, fromBonus);\n', '    }\n', '\n', '    function sell(uint256 price, uint256 amount) public {\n', '        sellPrice[msg.sender] = price;\n', '        toSell[msg.sender] = amount;\n', '\n', '        emit Sell(msg.sender, price, amount);\n', '    }\n', '\n', '    function buy(address from) public payable notPause {\n', '        require(sellPrice[from] > 0);\n', '        uint256 amount = msg.value / sellPrice[from];\n', '\n', '        if (amount >= balances[from]) {\n', '            amount = balances[from];\n', '        }\n', '\n', '        if (amount >= toSell[from]) {\n', '            amount = toSell[from];\n', '        }\n', '\n', '        require(amount > 0);\n', '\n', '        toSell[from] -= amount;\n', '        _transfer(from, msg.sender, amount);\n', '\n', '        from.transfer(msg.value);\n', '        \n', '        emit Buy(from, msg.sender, amount, msg.value);\n', '    }\n', '}\n', '/**\n', ' * this contract stands for the holds of WestIndia group\n', ' * all income will be split to holders according to their holds\n', ' * user can buy holds from shareholders at his will\n', ' */\n', 'contract ShareErc20 is Share, ERC20Interface {\n', '    string public symbol;\n', '    string public name;\n', '    uint256 public decimals;\n', '\n', '    mapping (address => mapping(address => uint256)) public allowance;\n', '\n', '    /**\n', '     * at start the owner has 100% share, which is 10,000 holds\n', '     */\n', '    constructor(string _symbol, string _name, uint _totalSupply)\n', '      Share(_totalSupply)\n', '      public {        \n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = 0;\n', '    }\n', '\n', '    function balanceOf(address addr) public constant returns(uint256) {\n', '        return balances[addr];\n', '    }\n', '\n', '    function transfer(address to, uint amount) public returns(bool) {\n', '        _transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address to, uint256 amount) public returns(bool){\n', '        allowance[msg.sender][to] = amount;\n', '\n', '        emit Approval(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) public returns(bool) {\n', '        require(allowance[from][msg.sender] >= amount);\n', '\n', '        allowance[from][msg.sender] -= amount;\n', '        _transfer(from, to, amount);\n', '\n', '        return true;\n', '    }\n', '}']