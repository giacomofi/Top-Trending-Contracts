['pragma solidity ^ 0.4.2;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\n', '\tfunction owned() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newAdmin) onlyOwner public {\n', '\t\towner = newAdmin;\n', '\t}\n', '}\n', '\n', 'contract tokenRecipient {\n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', '\n', 'contract token {\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\tmapping(address => uint256) public balanceOf;\n', '\tmapping(address => mapping(address => uint256)) public allowance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\tfunction token(uint256 initialSupply, string tokenName,\tuint8 decimalCount, string tokenSymbol) public {\n', '\t    decimals = decimalCount;\n', '\t\ttotalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n', '\t\tbalanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n', '\t\tname = tokenName; // Set the name for display purposes\n', '\t\tsymbol = tokenSymbol; // Set the symbol for display purposes\n', '\t}\n', '\n', '\t//Transfer tokens\n', '\tfunction transfer(address _to, uint256 _value) {\n', '\t\tif (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\n', '\t\tif (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '\t\tbalanceOf[msg.sender] -= _value; // Subtract from the sender\n', '\t\tbalanceOf[_to] += _value; // Add the same to the recipient\n', '\t\tTransfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '\t}\n', '\n', '\t//A contract attempts to get tokens\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '\t\tif (balanceOf[_from] < _value) throw; // Check if the sender has enough\n', '\t\tif (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '\t\tif (_value > allowance[_from][msg.sender]) throw; // Check allowance\n', '\t\tbalanceOf[_from] -= _value; // Subtract from the sender\n', '\t\tbalanceOf[_to] += _value; // Add the same to the recipient\n', '\t\tallowance[_from][msg.sender] -= _value;\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Set allowance for another address\n', '\tfunction approve(address _spender, uint256 _value) public\n', '\treturns(bool success) {\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Set allowance for another address and call a function\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t//Destroy tokens\n', '\tfunction burn(uint256 _value) public returns(bool success) {\n', '\t\trequire(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n', '\t\tbalanceOf[msg.sender] -= _value; // Subtract from the sender\n', '\t\ttotalSupply -= _value; // Updates totalSupply\n', '\t\tBurn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Destroy tokens from another account\n', '\tfunction burnFrom(address _from, uint256 _value) public returns(bool success) {\n', '\t\trequire(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n', '\t\trequire(_value <= allowance[_from][msg.sender]); // Check allowance\n', '\t\tbalanceOf[_from] -= _value; // Subtract from the targeted balance\n', '\t\tallowance[_from][msg.sender] -= _value; // Subtract from the sender&#39;s allowance\n', '\t\ttotalSupply -= _value; // Update totalSupply\n', '\t\tBurn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', 'contract OldToken {\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'contract Ohni is owned, token {\n', '\tOldToken ohniOld = OldToken(0x7f2176ceb16dcb648dc924eff617c3dc2befd30d); // The old Ohni token\n', '    using SafeMath for uint256; // We use safemath to do basic math operation (+,-,*,/)\n', '\tuint256 public sellPrice;\n', '\tuint256 public buyPrice;\n', '\tbool public deprecated;\n', '\taddress public currentVersion;\n', '\tmapping(address => bool) public frozenAccount;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent FrozenFunds(address target, bool frozen);\n', '\tevent ChangedTokens(address changedTarget, uint256 amountToChanged);\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction Ohni(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}\n', '\n', '\tfunction update(address newAddress, bool depr) onlyOwner {\n', '\t\tif (msg.sender != owner) throw;\n', '\t\tcurrentVersion = newAddress;\n', '\t\tdeprecated = depr;\n', '\t}\n', '\n', '\tfunction checkForUpdates() internal {\n', '\t\tif (deprecated) {\n', '\t\t\tif (!currentVersion.delegatecall(msg.data)) throw;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction withdrawETH(uint256 amount) onlyOwner {\n', '\t\tmsg.sender.send(amount);\n', '\t}\n', '\n', '\tfunction airdrop(address[] recipients, uint256 value) onlyOwner {\n', '\t\tfor (uint256 i = 0; i < recipients.length; i++) {\n', '\t\t\ttransfer(recipients[i], value);\n', '\t\t}\n', '\t}\n', '\n', '  \tfunction merge() public {\n', '\t\tcheckForUpdates();\n', '\t\tuint256 amountChanged = ohniOld.allowance(msg.sender, this);\n', '\t\trequire(amountChanged > 0);\n', '\t\trequire(amountChanged < 100000000);\n', '\t\trequire(ohniOld.balanceOf(msg.sender) < 100000000);\n', '   \t\trequire(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n', '\t\tif (!ohniOld.transferFrom(msg.sender, owner, amountChanged)) throw;\n', '\t\tamountChanged = (amountChanged * 10 ** uint256(decimals)) / 10;\n', '\t\tbalanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n', '    \tbalanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n', '\t\tTransfer(address(owner), msg.sender, amountChanged);\n', '\t\tChangedTokens(msg.sender,amountChanged);\n', '  \t}\n', '    \n', '\tfunction multiMerge(address[] recipients) onlyOwner {\n', '\t\tcheckForUpdates();\n', '    \tfor (uint256 i = 0; i < recipients.length; i++) {\t\n', '    \t\tuint256 amountChanged = ohniOld.allowance(msg.sender, owner);\n', '    \t\trequire(amountChanged > 0);\n', '    \t\trequire(amountChanged < 100000000);\n', '    \t\trequire(ohniOld.balanceOf(msg.sender) < 100000000);\n', '       \t\trequire(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n', '\t\t\tbalanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n', '\t\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n', '\t\t\tTransfer(address(owner), msg.sender, amountChanged);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '\t\tcheckForUpdates();\n', '\t\tbalanceOf[target] += mintedAmount;\n', '\t\ttotalSupply += mintedAmount;\n', '\t\tTransfer(0, this, mintedAmount);\n', '\t\tTransfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner {\n', '\t\tcheckForUpdates();\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\tFrozenFunds(target, freeze);\n', '\t}\n', '}']
['pragma solidity ^ 0.4.2;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\n', '\tfunction owned() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newAdmin) onlyOwner public {\n', '\t\towner = newAdmin;\n', '\t}\n', '}\n', '\n', 'contract tokenRecipient {\n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', '\n', 'contract token {\n', '\t// Public variables of the token\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\n', '\t// This creates an array with all balances\n', '\tmapping(address => uint256) public balanceOf;\n', '\tmapping(address => mapping(address => uint256)) public allowance;\n', '\n', '\t// This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '\n', '\tfunction token(uint256 initialSupply, string tokenName,\tuint8 decimalCount, string tokenSymbol) public {\n', '\t    decimals = decimalCount;\n', '\t\ttotalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n', '\t\tbalanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n', '\t\tname = tokenName; // Set the name for display purposes\n', '\t\tsymbol = tokenSymbol; // Set the symbol for display purposes\n', '\t}\n', '\n', '\t//Transfer tokens\n', '\tfunction transfer(address _to, uint256 _value) {\n', '\t\tif (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\n', '\t\tif (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '\t\tbalanceOf[msg.sender] -= _value; // Subtract from the sender\n', '\t\tbalanceOf[_to] += _value; // Add the same to the recipient\n', '\t\tTransfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '\t}\n', '\n', '\t//A contract attempts to get tokens\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '\t\tif (balanceOf[_from] < _value) throw; // Check if the sender has enough\n', '\t\tif (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '\t\tif (_value > allowance[_from][msg.sender]) throw; // Check allowance\n', '\t\tbalanceOf[_from] -= _value; // Subtract from the sender\n', '\t\tbalanceOf[_to] += _value; // Add the same to the recipient\n', '\t\tallowance[_from][msg.sender] -= _value;\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Set allowance for another address\n', '\tfunction approve(address _spender, uint256 _value) public\n', '\treturns(bool success) {\n', '\t\tallowance[msg.sender][_spender] = _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Set allowance for another address and call a function\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool success) {\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '\t\tif (approve(_spender, _value)) {\n', '\t\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\n', '\t//Destroy tokens\n', '\tfunction burn(uint256 _value) public returns(bool success) {\n', '\t\trequire(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n', '\t\tbalanceOf[msg.sender] -= _value; // Subtract from the sender\n', '\t\ttotalSupply -= _value; // Updates totalSupply\n', '\t\tBurn(msg.sender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//Destroy tokens from another account\n', '\tfunction burnFrom(address _from, uint256 _value) public returns(bool success) {\n', '\t\trequire(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n', '\t\trequire(_value <= allowance[_from][msg.sender]); // Check allowance\n', '\t\tbalanceOf[_from] -= _value; // Subtract from the targeted balance\n', "\t\tallowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\n", '\t\ttotalSupply -= _value; // Update totalSupply\n', '\t\tBurn(_from, _value);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', 'contract OldToken {\n', '  function totalSupply() constant returns (uint256 supply) {}\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint public decimals;\n', '  string public name;\n', '}\n', '\n', 'contract Ohni is owned, token {\n', '\tOldToken ohniOld = OldToken(0x7f2176ceb16dcb648dc924eff617c3dc2befd30d); // The old Ohni token\n', '    using SafeMath for uint256; // We use safemath to do basic math operation (+,-,*,/)\n', '\tuint256 public sellPrice;\n', '\tuint256 public buyPrice;\n', '\tbool public deprecated;\n', '\taddress public currentVersion;\n', '\tmapping(address => bool) public frozenAccount;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent FrozenFunds(address target, bool frozen);\n', '\tevent ChangedTokens(address changedTarget, uint256 amountToChanged);\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction Ohni(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}\n', '\n', '\tfunction update(address newAddress, bool depr) onlyOwner {\n', '\t\tif (msg.sender != owner) throw;\n', '\t\tcurrentVersion = newAddress;\n', '\t\tdeprecated = depr;\n', '\t}\n', '\n', '\tfunction checkForUpdates() internal {\n', '\t\tif (deprecated) {\n', '\t\t\tif (!currentVersion.delegatecall(msg.data)) throw;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction withdrawETH(uint256 amount) onlyOwner {\n', '\t\tmsg.sender.send(amount);\n', '\t}\n', '\n', '\tfunction airdrop(address[] recipients, uint256 value) onlyOwner {\n', '\t\tfor (uint256 i = 0; i < recipients.length; i++) {\n', '\t\t\ttransfer(recipients[i], value);\n', '\t\t}\n', '\t}\n', '\n', '  \tfunction merge() public {\n', '\t\tcheckForUpdates();\n', '\t\tuint256 amountChanged = ohniOld.allowance(msg.sender, this);\n', '\t\trequire(amountChanged > 0);\n', '\t\trequire(amountChanged < 100000000);\n', '\t\trequire(ohniOld.balanceOf(msg.sender) < 100000000);\n', '   \t\trequire(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n', '\t\tif (!ohniOld.transferFrom(msg.sender, owner, amountChanged)) throw;\n', '\t\tamountChanged = (amountChanged * 10 ** uint256(decimals)) / 10;\n', '\t\tbalanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n', '    \tbalanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n', '\t\tTransfer(address(owner), msg.sender, amountChanged);\n', '\t\tChangedTokens(msg.sender,amountChanged);\n', '  \t}\n', '    \n', '\tfunction multiMerge(address[] recipients) onlyOwner {\n', '\t\tcheckForUpdates();\n', '    \tfor (uint256 i = 0; i < recipients.length; i++) {\t\n', '    \t\tuint256 amountChanged = ohniOld.allowance(msg.sender, owner);\n', '    \t\trequire(amountChanged > 0);\n', '    \t\trequire(amountChanged < 100000000);\n', '    \t\trequire(ohniOld.balanceOf(msg.sender) < 100000000);\n', '       \t\trequire(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n', '\t\t\tbalanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n', '\t\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n', '\t\t\tTransfer(address(owner), msg.sender, amountChanged);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '\t\tcheckForUpdates();\n', '\t\tbalanceOf[target] += mintedAmount;\n', '\t\ttotalSupply += mintedAmount;\n', '\t\tTransfer(0, this, mintedAmount);\n', '\t\tTransfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner {\n', '\t\tcheckForUpdates();\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\tFrozenFunds(target, freeze);\n', '\t}\n', '}']
