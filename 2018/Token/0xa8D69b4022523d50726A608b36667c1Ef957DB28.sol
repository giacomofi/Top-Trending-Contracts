['pragma solidity ^0.4.8;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256 supply);\n', '    function balance() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Santal is ERC20Interface {\n', '    string public constant symbol = "TXQ";\n', '    string public constant name = "santal";\n', '    uint8  public constant decimals = 18;\n', '\n', '    uint256 public _airdropTotal = 0;\n', '    uint256 public _airdropLimit = 10 * 10000 * 1000000000000000000;\n', '    uint256 public _airdropAmount = 10 * 1000000000000000000; \n', '    uint256 public totalSupply = 50000 * 10000 * 1000000000000000000;\n', '    uint safeGas = 2300;\n', '    \n', '    uint256 public unitsOneEthCanBuy = 8000 * 1000000000000000000;\n', '    uint256 public canBuyLimit = 1000 * 10000 * 1000000000000000000;\n', '    uint256 public hasBuyTotal = 0;\n', '    uint256 public totalEthInWei;\n', '    uint256 constant public unitEthWei = 1000000000000000000;\n', '    address public owner;\n', '    bool public isBuyStopped;\n', '    bool public isAirdropStopped;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => bool) initialized;\n', '    mapping(address => bool) hasBuyed;\n', '\n', '\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    \n', '    event LOG_SuccessfulSend(address addr, uint amount);\n', '    event LOG_FailedSend(address receiver, uint amount);\n', '    event LOG_ZeroSend();\n', '    \n', '    event LOG_BuyStopped();\n', '    event LOG_BuyResumed();\n', '    \n', '    event LOG_AirdropStopped();\n', '    event LOG_AirdropResumed();\n', '    \n', '    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n', '    \n', '    modifier onlyOwner {\n', '        if (owner != msg.sender) throw;\n', '        _;\n', '    }\n', '\n', '    function Santal() {\n', '        owner = msg.sender;\n', '        initialized[msg.sender] = true;\n', '        balances[msg.sender] = totalSupply - _airdropLimit - canBuyLimit;\n', '    }\n', '    \n', '    function() payable{\n', '        \n', '        if (isBuyStopped) throw;\n', '        \n', '        if (!hasBuyed[msg.sender]) {\n', '            hasBuyed[msg.sender] = true;\n', '        }\n', '\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * (unitsOneEthCanBuy / unitEthWei);\n', '        \n', '        hasBuyTotal += amount;\n', '         \n', '        if(amount > canBuyLimit || hasBuyTotal > canBuyLimit) throw;\n', '        \n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(owner, msg.sender, amount);\n', '\n', '        safeSend(owner, msg.value);\n', '    }\n', '    \n', '    function safeSend(address addr, uint value)\n', '        private {\n', '\n', '        if (value == 0) {\n', '            LOG_ZeroSend();\n', '            return;\n', '        }\n', '\n', '        if (!(addr.call.gas(safeGas).value(value)())) {\n', '            LOG_FailedSend(addr, value);\n', '        }\n', '\n', '        LOG_SuccessfulSend(addr,value);\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 supply) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balance() constant returns (uint256) {\n', '        return getBalance(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256) {\n', '        return getBalance(_address);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        initialize(msg.sender);\n', '\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0) {\n', '            initialize(_to);\n', '            if (balances[_to] + _amount > balances[_to]) {\n', '\n', '                balances[msg.sender] -= _amount;\n', '                balances[_to] += _amount;\n', '\n', '                Transfer(msg.sender, _to, _amount);\n', '\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '        initialize(_from);\n', '\n', '        if (balances[_from] >= _amount\n', '            && allowed[_from][msg.sender] >= _amount\n', '            && _amount > 0) {\n', '            initialize(_to);\n', '            if (balances[_to] + _amount > balances[_to]) {\n', '\n', '                balances[_from] -= _amount;\n', '                allowed[_from][msg.sender] -= _amount;\n', '                balances[_to] += _amount;\n', '\n', '                Transfer(_from, _to, _amount);\n', '\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function initialize(address _address) internal returns (bool success) {\n', '        if (!isAirdropStopped && _airdropTotal < _airdropLimit && !initialized[_address]) {\n', '            initialized[_address] = true;\n', '            balances[_address] = _airdropAmount;\n', '            _airdropTotal += _airdropAmount;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function getBalance(address _address) internal returns (uint256) {\n', '        if (_airdropTotal < _airdropLimit && !initialized[_address] && !hasBuyed[_address]) {\n', '            return balances[_address] + _airdropAmount;\n', '        }\n', '        else {\n', '            return balances[_address];\n', '        }\n', '    }\n', '    \n', '    function stopBuy()\n', '        onlyOwner {\n', '\n', '        isBuyStopped = true;\n', '        LOG_BuyStopped();\n', '    }\n', '\n', '    function resumeBuy()\n', '        onlyOwner {\n', '\n', '        isBuyStopped = false;\n', '        LOG_BuyResumed();\n', '    }\n', '    \n', '    function stopAirdrop()\n', '        onlyOwner {\n', '\n', '        isAirdropStopped = true;\n', '        LOG_AirdropStopped();\n', '    }\n', '\n', '    function resumeAirdrop()\n', '        onlyOwner {\n', '\n', '        isAirdropStopped = false;\n', '        LOG_AirdropResumed();\n', '    }\n', '    \n', '        function changeOwnerAddress(address newOwner)\n', '        onlyOwner {\n', '\n', '        if (newOwner == address(0x0)) throw;\n', '        owner = newOwner;\n', '        LOG_OwnerAddressChanged(owner, newOwner);\n', '    }\n', '}']