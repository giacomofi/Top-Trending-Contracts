['pragma solidity ^0.4.8;\n', '\n', 'library BobbySafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a==0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BobbyERC20Base {\n', '\n', '  //可以执行暂停操作的权限\n', '  address public ceoAddress;\n', '\n', '  //是否暂停智能合约的运行\n', '  bool public paused = false;\n', '\n', '  constructor()  {\n', '    ceoAddress = msg.sender;\n', '  }\n', '\n', '  modifier onlyCEO() {\n', '     require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', ' function setCEO(address _newCEO) public onlyCEO {\n', '      require(_newCEO != address(0));\n', '      ceoAddress = _newCEO;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() external onlyCEO whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '  }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '  //ERC20指定接口\n', '  event Approval(address indexed src, address indexed guy, uint wad);\n', '  event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '  function name() public view returns (string name);\n', '  function symbol() public view returns (string symbol);\n', '  function decimals() public view returns (uint8 decimals);\n', '  function totalSupply() public view returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  //扩展接口\n', '  function getBalanceAddr(uint256 _index) public view returns(address addr);\n', '  function getBalance(uint256 _index) public view returns(uint256 tokens);\n', '  function getBalanceSize() public view returns(uint256 size);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '\n', '  using BobbySafeMath for uint256;\n', '\n', '  //常量定义\n', '  uint private  _Wei = 1;\n', '  uint private  _Kwei = 1000 * _Wei;\n', '  uint private  _Mwei = 1000 * _Kwei;\n', '  uint private  _Gwei = 1000 * _Mwei;\n', '  uint private  _Bobby = 1000 * 1000 * 1000 * _Gwei;\n', '  uint private  _CurrentBob = 165442393 * _Mwei;\n', '\n', '  uint private _Hundred = 100;\n', '  uint private _Thousand = 1000;\n', '  uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '  //代币基本信息\n', '  string private _name = "OtvCloud Token Bobby";     //代币名称\n', '  string private _symbol = "BOBBY";   //代币标识\n', '  uint8 private _decimals = 9;        //小数点后位数\n', '  uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '  //解封用户代币结构\n', '  struct userToken {\n', '    uint _index;             //放在数组中的下标\n', '    address _addr;          //用户账号\n', '    uint256 _tokens;        //通证数量\n', '  }\n', '  mapping(address=>userToken) private _balancesMap;           //用户可用代币映射\n', '  address[] _balancesArray;                                   //用户禁封代币数组,from 1\n', '\n', '  struct logEntry {\n', '    uint time;\n', '    address from;\n', '    address to;\n', '    uint256 value;\n', '  }\n', '  logEntry[] _logs;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);       //代币转移事件\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value); //配额许可事件\n', '\n', '  //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '  constructor() {\n', '    _balancesArray.push(address(0));\n', '\n', '    //此处需要注意，请使用CEO的地址,因为初始化后，将会使用这个地址作为CEO地址\n', '    //注意，一定要使用memory类型，否则，后面的赋值会影响其它成员变量\n', '    userToken memory userCEO;\n', '    userCEO._index = _balancesArray.length;\n', '    userCEO._addr = msg.sender;\n', '    userCEO._tokens = _totalSupply;\n', '    _balancesArray.push(msg.sender);\n', '    _balancesMap[msg.sender] = userCEO;\n', '  }\n', '\n', '  //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '  function name() public view returns (string name){\n', '    name = _name;\n', '  }\n', '\n', '  //返回合约标识符\n', '  function symbol() public view returns (string symbol){\n', '    symbol = _symbol;\n', '  }\n', '\n', '  //返回合约小数位\n', '  function decimals() public view returns (uint8 decimals){\n', '    decimals = _decimals;\n', '  }\n', '\n', '  //返回合约总供给额\n', '  function totalSupply() public view returns (uint256 totalSupply){\n', '    totalSupply = _totalSupply;\n', '  }\n', '\n', '  function getBalanceAddr(uint256 _index) public view returns(address addr){\n', '    require(_index < _balancesArray.length);\n', '    require(_index >= 0);\n', '    addr = _balancesArray[_index];\n', '  }\n', '\n', '  function getBalance(uint256 _index) public view returns(uint256 tokens){\n', '    require(_index < _balancesArray.length);\n', '    require(_index >= 0);\n', '    tokens = _balancesMap[_balancesArray[_index]]._tokens;\n', '  }\n', '\n', '  function getBalanceSize() public view returns(uint256 size){\n', '    size = _balancesArray.length;\n', '  }\n', '\n', '  function log(address from, address to, uint256 value) public {\n', '    logEntry memory entry;\n', '    entry.time = now;\n', '    entry.from = from;\n', '    entry.to = to;\n', '    entry.value = value;\n', '    _logs.push(entry);\n', '  }\n', '\n', '  function getLogSize() public view returns(uint256 size){\n', '    size = _logs.length;\n', '  }\n', '\n', '  function getLog(uint256 _index) public view returns(uint time, address from, address to, uint256 value){\n', '    require(_index < _logs.length);\n', '    require(_index >= 0);\n', '    logEntry entry = _logs[_index];\n', '    time = entry.time;\n', '    from = entry.from;\n', '    to = entry.to;\n', '    value = entry.value;\n', '  }\n', '\n', '  //查询账户_owner的账户余额\n', '  function balanceOf(address _owner) public view returns (uint256 balance){\n', '    balance = _balancesMap[_owner]._tokens;\n', '  }\n', '\n', '  function addBalance(address _addr, uint256 _value) private{\n', '    _balancesMap[_addr]._tokens = _balancesMap[_addr]._tokens.add(_value);\n', '  }\n', '\n', '  function subBalance(address _addr, uint256 _value) private{\n', '    _balancesMap[_addr]._tokens = _balancesMap[_addr]._tokens.sub(_value);\n', '  }\n', '\n', '  //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '    require(_balancesMap[msg.sender]._tokens >= _value);\n', '    subBalance(msg.sender, _value);\n', '\n', '    uint index = _balancesMap[_to]._index;\n', '    if(index == 0){\n', '      userToken memory user;\n', '      user._index = _balancesArray.length;\n', '      user._addr = _to;\n', '      user._tokens = _value;\n', '      _balancesMap[_to] = user;\n', '      _balancesArray.push(_to);\n', '    }\n', '    else{\n', '      addBalance(_to, _value);\n', '    }\n', '\n', '    Transfer(msg.sender, _to, _value);\n', '    log(msg.sender, _to, _value);\n', '    success = true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '    success = true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success){\n', '    success = true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view whenNotPaused returns (uint256 remaining){\n', '    remaining = 0;\n', '  }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', 'library BobbySafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a==0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BobbyERC20Base {\n', '\n', '  //可以执行暂停操作的权限\n', '  address public ceoAddress;\n', '\n', '  //是否暂停智能合约的运行\n', '  bool public paused = false;\n', '\n', '  constructor()  {\n', '    ceoAddress = msg.sender;\n', '  }\n', '\n', '  modifier onlyCEO() {\n', '     require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', ' function setCEO(address _newCEO) public onlyCEO {\n', '      require(_newCEO != address(0));\n', '      ceoAddress = _newCEO;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() external onlyCEO whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '  }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '  //ERC20指定接口\n', '  event Approval(address indexed src, address indexed guy, uint wad);\n', '  event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '  function name() public view returns (string name);\n', '  function symbol() public view returns (string symbol);\n', '  function decimals() public view returns (uint8 decimals);\n', '  function totalSupply() public view returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  //扩展接口\n', '  function getBalanceAddr(uint256 _index) public view returns(address addr);\n', '  function getBalance(uint256 _index) public view returns(uint256 tokens);\n', '  function getBalanceSize() public view returns(uint256 size);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '\n', '  using BobbySafeMath for uint256;\n', '\n', '  //常量定义\n', '  uint private  _Wei = 1;\n', '  uint private  _Kwei = 1000 * _Wei;\n', '  uint private  _Mwei = 1000 * _Kwei;\n', '  uint private  _Gwei = 1000 * _Mwei;\n', '  uint private  _Bobby = 1000 * 1000 * 1000 * _Gwei;\n', '  uint private  _CurrentBob = 165442393 * _Mwei;\n', '\n', '  uint private _Hundred = 100;\n', '  uint private _Thousand = 1000;\n', '  uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '  //代币基本信息\n', '  string private _name = "OtvCloud Token Bobby";     //代币名称\n', '  string private _symbol = "BOBBY";   //代币标识\n', '  uint8 private _decimals = 9;        //小数点后位数\n', '  uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '  //解封用户代币结构\n', '  struct userToken {\n', '    uint _index;             //放在数组中的下标\n', '    address _addr;          //用户账号\n', '    uint256 _tokens;        //通证数量\n', '  }\n', '  mapping(address=>userToken) private _balancesMap;           //用户可用代币映射\n', '  address[] _balancesArray;                                   //用户禁封代币数组,from 1\n', '\n', '  struct logEntry {\n', '    uint time;\n', '    address from;\n', '    address to;\n', '    uint256 value;\n', '  }\n', '  logEntry[] _logs;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);       //代币转移事件\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value); //配额许可事件\n', '\n', '  //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '  constructor() {\n', '    _balancesArray.push(address(0));\n', '\n', '    //此处需要注意，请使用CEO的地址,因为初始化后，将会使用这个地址作为CEO地址\n', '    //注意，一定要使用memory类型，否则，后面的赋值会影响其它成员变量\n', '    userToken memory userCEO;\n', '    userCEO._index = _balancesArray.length;\n', '    userCEO._addr = msg.sender;\n', '    userCEO._tokens = _totalSupply;\n', '    _balancesArray.push(msg.sender);\n', '    _balancesMap[msg.sender] = userCEO;\n', '  }\n', '\n', '  //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '  function name() public view returns (string name){\n', '    name = _name;\n', '  }\n', '\n', '  //返回合约标识符\n', '  function symbol() public view returns (string symbol){\n', '    symbol = _symbol;\n', '  }\n', '\n', '  //返回合约小数位\n', '  function decimals() public view returns (uint8 decimals){\n', '    decimals = _decimals;\n', '  }\n', '\n', '  //返回合约总供给额\n', '  function totalSupply() public view returns (uint256 totalSupply){\n', '    totalSupply = _totalSupply;\n', '  }\n', '\n', '  function getBalanceAddr(uint256 _index) public view returns(address addr){\n', '    require(_index < _balancesArray.length);\n', '    require(_index >= 0);\n', '    addr = _balancesArray[_index];\n', '  }\n', '\n', '  function getBalance(uint256 _index) public view returns(uint256 tokens){\n', '    require(_index < _balancesArray.length);\n', '    require(_index >= 0);\n', '    tokens = _balancesMap[_balancesArray[_index]]._tokens;\n', '  }\n', '\n', '  function getBalanceSize() public view returns(uint256 size){\n', '    size = _balancesArray.length;\n', '  }\n', '\n', '  function log(address from, address to, uint256 value) public {\n', '    logEntry memory entry;\n', '    entry.time = now;\n', '    entry.from = from;\n', '    entry.to = to;\n', '    entry.value = value;\n', '    _logs.push(entry);\n', '  }\n', '\n', '  function getLogSize() public view returns(uint256 size){\n', '    size = _logs.length;\n', '  }\n', '\n', '  function getLog(uint256 _index) public view returns(uint time, address from, address to, uint256 value){\n', '    require(_index < _logs.length);\n', '    require(_index >= 0);\n', '    logEntry entry = _logs[_index];\n', '    time = entry.time;\n', '    from = entry.from;\n', '    to = entry.to;\n', '    value = entry.value;\n', '  }\n', '\n', '  //查询账户_owner的账户余额\n', '  function balanceOf(address _owner) public view returns (uint256 balance){\n', '    balance = _balancesMap[_owner]._tokens;\n', '  }\n', '\n', '  function addBalance(address _addr, uint256 _value) private{\n', '    _balancesMap[_addr]._tokens = _balancesMap[_addr]._tokens.add(_value);\n', '  }\n', '\n', '  function subBalance(address _addr, uint256 _value) private{\n', '    _balancesMap[_addr]._tokens = _balancesMap[_addr]._tokens.sub(_value);\n', '  }\n', '\n', '  //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '    require(_balancesMap[msg.sender]._tokens >= _value);\n', '    subBalance(msg.sender, _value);\n', '\n', '    uint index = _balancesMap[_to]._index;\n', '    if(index == 0){\n', '      userToken memory user;\n', '      user._index = _balancesArray.length;\n', '      user._addr = _to;\n', '      user._tokens = _value;\n', '      _balancesMap[_to] = user;\n', '      _balancesArray.push(_to);\n', '    }\n', '    else{\n', '      addBalance(_to, _value);\n', '    }\n', '\n', '    Transfer(msg.sender, _to, _value);\n', '    log(msg.sender, _to, _value);\n', '    success = true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '    success = true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success){\n', '    success = true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view whenNotPaused returns (uint256 remaining){\n', '    remaining = 0;\n', '  }\n', '}']
