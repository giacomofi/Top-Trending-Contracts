['pragma solidity 0.4.21;\n', 'pragma experimental "v0.5.0";\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.*/\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface ERC20TokenInterface {\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '    function totalSupply() external view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface TokenVestingInterface {\n', '    function getReleasableFunds() external view returns (uint256);\n', '\n', '    function release() external;\n', '\n', '    function setWithdrawalAddress(address _newAddress) external;\n', '\n', '    function revoke(string _reason) external view;\n', '\n', '    function getTokenBalance() external view returns (uint256);\n', '\n', '    function updateBalanceOnFunding(uint256 _amount) external;\n', '\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external;\n', '\n', '    function salvageNotAllowedTokensSentToContract(address _to, uint _amount) external;\n', '}\n', '\n', 'interface VestingMasterInterface {\n', '    function amountLockedInVestings() view external returns (uint256);\n', '\n', '    function substractLockedAmount(uint256 _amount) external;\n', '\n', '    function addLockedAmount(uint256 _amount) external;\n', '\n', '    function addInternalBalance(uint256 _amount) external;\n', '}\n', '\n', 'interface ReleasingScheduleInterface {\n', '    function getReleasableFunds(address _vesting) external view returns (uint256);\n', '}\n', '\n', '/** @title Linear releasing schedule contract */\n', 'contract ReleasingScheduleLinearContract {\n', '    /** @dev Contains functionality for releasing funds linearly; set amount on set intervals until funds are available\n', '    * @param _startTime Start time of schedule (not first releas time)\n', '    * @param _tickDuration Interval of payouts\n', '    * @param _amountPerTick Amount to be released per interval\n', '    * @return created contracts address.\n', '    */\n', '    using SafeMath for uint256;\n', '    uint256 public startTime;\n', '    uint256 public tickDuration;\n', '    uint256 public amountPerTick;\n', '\n', '    function ReleasingScheduleLinearContract(uint256 _startTime, uint256 _tickDuration, uint256 _amountPerTick) public{\n', '        startTime = _startTime;\n', '        tickDuration = _tickDuration;\n', '        amountPerTick = _amountPerTick;\n', '    }\n', '\n', '    function getReleasableFunds(address _vesting) public view returns (uint256){\n', '        TokenVestingContract vesting = TokenVestingContract(_vesting);\n', '        uint256 balance = ERC20TokenInterface(vesting.tokenAddress()).balanceOf(_vesting);\n', '        // check if there is balance and if it is active yet\n', '        if (balance == 0 || (startTime >= now)) {\n', '            return 0;\n', '        }\n', '        // all funds that may be released according to vesting schedule \n', '        uint256 vestingScheduleAmount = (now.sub(startTime) / tickDuration) * amountPerTick;\n', '        // deduct already released funds \n', '        uint256 releasableFunds = vestingScheduleAmount.sub(vesting.alreadyReleasedAmount());\n', '        // make sure to release remainder of funds for last payout\n', '        if (releasableFunds > balance) {\n', '            releasableFunds = balance;\n', '        }\n', '        return releasableFunds;\n', '    }\n', '}\n', '\n', 'contract TgeOtherReleasingScheduleContract is ReleasingScheduleLinearContract {\n', '    uint256 constant releaseDate = 1578873600;\n', '    uint256 constant monthLength = 2592000;\n', '\n', '    function TgeOtherReleasingScheduleContract(uint256 _amount, uint256 _startTime) ReleasingScheduleLinearContract(_startTime - monthLength, monthLength, _amount / 12) public {\n', '    }\n', '\n', '    function getReleasableFunds(address _vesting) public view returns (uint256) {\n', '        if (now < releaseDate) {\n', '            return 0;\n', '        }\n', '        return super.getReleasableFunds(_vesting);\n', '    }\n', '}\n', '\n', 'contract TgeTeamReleasingScheduleContract {\n', '    uint256 constant releaseDate = 1578873600;\n', '\n', '    function TgeTeamReleasingScheduleContract() public {}\n', '\n', '    function getReleasableFunds(address _vesting) public view returns (uint256) {\n', '        TokenVestingContract vesting = TokenVestingContract(_vesting);\n', '        if (releaseDate >= now) {\n', '            return 0;\n', '        } else {\n', '            return vesting.getTokenBalance();\n', '        }\n', '\n', '    }\n', '}\n', '\n', '/** @title Vesting contract*/\n', 'contract TokenVestingContract is Owned {\n', '    /** @dev Contains basic vesting functionality. Uses releasing schedule to ascertain amount of funds to release\n', '    * @param _beneficiary Receiver of funds.\n', '    * @param _tokenAddress Address of token contract.\n', '    * @param _revocable Allows owner to terminate vesting, but all funds yet vested still go to beneficiary. Owner gets remainder of funds back.\n', '    * @param _changable Allows that releasing schedule and withdrawal address be changed. Essentialy rendering contract not binding.\n', '    * @param _releasingScheduleContract Address of scheduling contract, that implements getReleasableFunds() function\n', "    * @return created vesting's address.\n", '    */\n', '    using SafeMath for uint256;\n', '\n', '    address public beneficiary;\n', '    address public tokenAddress;\n', '    bool public canReceiveTokens;\n', '    bool public revocable;  // \n', '    bool public changable;  // allows that releasing schedule and withdrawal address be changed. Essentialy rendering contract not binding.\n', '    address public releasingScheduleContract;\n', '    bool fallbackTriggered;\n', '\n', '    bool public revoked;\n', '    uint256 public alreadyReleasedAmount;\n', '    uint256 public internalBalance;\n', '\n', '    event Released(uint256 _amount);\n', '    event RevokedAndDestroyed(string _reason);\n', '    event WithdrawalAddressSet(address _newAddress);\n', '    event TokensReceivedSinceLastCheck(uint256 _amount);\n', '    event VestingReceivedFunding(uint256 _amount);\n', '    event SetReleasingSchedule(address _addy);\n', '    event NotAllowedTokensReceived(uint256 amount);\n', '\n', '    function TokenVestingContract(address _beneficiary, address _tokenAddress, bool _canReceiveTokens, bool _revocable, bool _changable, address _releasingScheduleContract) public {\n', '        beneficiary = _beneficiary;\n', '        tokenAddress = _tokenAddress;\n', '        canReceiveTokens = _canReceiveTokens;\n', '        revocable = _revocable;\n', '        changable = _changable;\n', '        releasingScheduleContract = _releasingScheduleContract;\n', '\n', '        alreadyReleasedAmount = 0;\n', '        revoked = false;\n', '        internalBalance = 0;\n', '        fallbackTriggered = false;\n', '    }\n', '\n', '    function setReleasingSchedule(address _releasingScheduleContract) external onlyOwner {\n', '        require(changable);\n', '        releasingScheduleContract = _releasingScheduleContract;\n', '\n', '        emit SetReleasingSchedule(releasingScheduleContract);\n', '    }\n', '\n', '    function setWithdrawalAddress(address _newAddress) external onlyOwner {\n', '        beneficiary = _newAddress;\n', '\n', '        emit WithdrawalAddressSet(_newAddress);\n', '    }\n', '    /// release tokens that are already vested/releasable\n', '    function release() external returns (uint256 transferedAmount) {\n', '        checkForReceivedTokens();\n', '        require(msg.sender == beneficiary || msg.sender == owner);\n', '        uint256 amountToTransfer = ReleasingScheduleInterface(releasingScheduleContract).getReleasableFunds(this);\n', '        require(amountToTransfer > 0);\n', '        // internal accounting\n', '        alreadyReleasedAmount = alreadyReleasedAmount.add(amountToTransfer);\n', '        internalBalance = internalBalance.sub(amountToTransfer);\n', '        VestingMasterInterface(owner).substractLockedAmount(amountToTransfer);\n', '        // actual transfer\n', '        ERC20TokenInterface(tokenAddress).transfer(beneficiary, amountToTransfer);\n', '        emit Released(amountToTransfer);\n', '        return amountToTransfer;\n', '    }\n', '\n', '    function revoke(string _reason) external onlyOwner {\n', '        require(revocable);\n', '        // returns funds not yet vested according to vesting schedule\n', '        uint256 releasableFunds = ReleasingScheduleInterface(releasingScheduleContract).getReleasableFunds(this);\n', '        ERC20TokenInterface(tokenAddress).transfer(beneficiary, releasableFunds);\n', '        VestingMasterInterface(owner).substractLockedAmount(releasableFunds);\n', "        // have to do it here, can't use return, because contract selfdestructs\n", '        // returns remainder of funds to VestingMaster and kill vesting contract\n', '        VestingMasterInterface(owner).addInternalBalance(getTokenBalance());\n', '        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n', '        emit RevokedAndDestroyed(_reason);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function getTokenBalance() public view returns (uint256 tokenBalance) {\n', '        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n', '    }\n', '    // master calls this when it uploads funds in order to differentiate betwen funds from master and 3rd party\n', '    function updateBalanceOnFunding(uint256 _amount) external onlyOwner {\n', '        internalBalance = internalBalance.add(_amount);\n', '        emit VestingReceivedFunding(_amount);\n', '    }\n', '    // check for changes in balance in order to track amount of locked tokens and notify master\n', '    function checkForReceivedTokens() public {\n', '        if (getTokenBalance() != internalBalance) {\n', '            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n', '            // if not allowed to receive tokens, do not account for them\n', '            if (canReceiveTokens) {\n', '                internalBalance = getTokenBalance();\n', '                VestingMasterInterface(owner).addLockedAmount(receivedFunds);\n', '            } else {\n', '                emit NotAllowedTokensReceived(receivedFunds);\n', '            }\n', '            emit TokensReceivedSinceLastCheck(receivedFunds);\n', '        }\n', '        fallbackTriggered = true;\n', '    }\n', '\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external onlyOwner {\n', '        require(_tokenAddress != tokenAddress);\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function salvageNotAllowedTokensSentToContract(address _to, uint _amount) external onlyOwner {\n', '        // check if there are any new tokens\n', '        checkForReceivedTokens();\n', '        // only allow sending tokens, that were not allowed to be sent to contract\n', '        require(_amount <= getTokenBalance() - internalBalance);\n', '        ERC20TokenInterface(tokenAddress).transfer(_to, _amount);\n', '    }\n', '    function () external{\n', '        fallbackTriggered = true;\n', '    }\n', '}\n', '\n', 'contract VestingMasterContract is Owned {\n', '    using SafeMath for uint256;\n', '\n', '    address public tokenAddress;\n', '    bool public canReceiveTokens;\n', '    address public moderator;\n', '    uint256 public internalBalance;\n', '    uint256 public amountLockedInVestings;\n', '    bool public fallbackTriggered;\n', '\n', '    struct VestingStruct {\n', '        uint256 arrayPointer;\n', '        // custom data\n', '        address beneficiary;\n', '        address releasingScheduleContract;\n', '        string vestingType;\n', '        uint256 vestingVersion;\n', '    }\n', '\n', '    address[] public vestingAddresses;\n', '    mapping(address => VestingStruct) public addressToVestingStruct;\n', '    mapping(address => address) public beneficiaryToVesting;\n', '\n', '    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n', '    event LockedAmountDecreased(uint256 amount);\n', '    event LockedAmountIncreased(uint256 amount);\n', '    event TokensReceivedSinceLastCheck(uint256 amount);\n', '    event TokensReceivedWithApproval(uint256 amount, bytes extraData);\n', '    event NotAllowedTokensReceived(uint256 amount);\n', '\n', '    function VestingMasterContract(address _tokenAddress, bool _canReceiveTokens) public{\n', '        tokenAddress = _tokenAddress;\n', '        canReceiveTokens = _canReceiveTokens;\n', '        internalBalance = 0;\n', '        amountLockedInVestings = 0;\n', '    }\n', '    // todo: make storage lib\n', '    ////////// STORAGE HELPERS  ///////////\n', '    function vestingExists(address _vestingAddress) public view returns (bool exists){\n', '        if (vestingAddresses.length == 0) {return false;}\n', '        return (vestingAddresses[addressToVestingStruct[_vestingAddress].arrayPointer] == _vestingAddress);\n', '    }\n', '\n', '    function storeNewVesting(address _vestingAddress, address _beneficiary, address _releasingScheduleContract, string _vestingType, uint256 _vestingVersion) internal onlyOwner returns (uint256 vestingsLength) {\n', '        require(!vestingExists(_vestingAddress));\n', '        addressToVestingStruct[_vestingAddress].beneficiary = _beneficiary;\n', '        addressToVestingStruct[_vestingAddress].releasingScheduleContract = _releasingScheduleContract;\n', '        addressToVestingStruct[_vestingAddress].vestingType = _vestingType;\n', '        addressToVestingStruct[_vestingAddress].vestingVersion = _vestingVersion;\n', '        beneficiaryToVesting[_beneficiary] = _vestingAddress;\n', '        addressToVestingStruct[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n', '        return vestingAddresses.length;\n', '    }\n', '\n', '    function deleteVestingFromStorage(address _vestingAddress) internal onlyOwner returns (uint256 vestingsLength) {\n', '        require(vestingExists(_vestingAddress));\n', '        delete (beneficiaryToVesting[addressToVestingStruct[_vestingAddress].beneficiary]);\n', '        uint256 indexToDelete = addressToVestingStruct[_vestingAddress].arrayPointer;\n', '        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n', '        vestingAddresses[indexToDelete] = keyToMove;\n', '        addressToVestingStruct[keyToMove].arrayPointer = indexToDelete;\n', '        vestingAddresses.length--;\n', '        return vestingAddresses.length;\n', '    }\n', '\n', '    function addVesting(address _vestingAddress, address _beneficiary, address _releasingScheduleContract, string _vestingType, uint256 _vestingVersion) public {\n', '        uint256 vestingBalance = TokenVestingInterface(_vestingAddress).getTokenBalance();\n', '        amountLockedInVestings = amountLockedInVestings.add(vestingBalance);\n', '        storeNewVesting(_vestingAddress, _beneficiary, _releasingScheduleContract, _vestingType, _vestingVersion);\n', '    }\n', '\n', '    /// releases funds to beneficiary\n', '    function releaseVesting(address _vestingContract) external {\n', '        require(vestingExists(_vestingContract));\n', '        require(msg.sender == addressToVestingStruct[_vestingContract].beneficiary || msg.sender == owner || msg.sender == moderator);\n', '        TokenVestingInterface(_vestingContract).release();\n', '    }\n', '    /// Transfers releasable funds from vesting to beneficiary (caller of this method)\n', '    function releaseMyTokens() external {\n', '        address vesting = beneficiaryToVesting[msg.sender];\n', '        require(vesting != 0);\n', '        TokenVestingInterface(vesting).release();\n', '    }\n', '\n', '    // add funds to vesting contract\n', '    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n', "        // convenience, so you don't have to call it manualy if you just uploaded funds\n", '        checkForReceivedTokens();\n', '        // check if there is actually enough funds\n', '        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n', '        // make sure that fundee is vesting contract on the list\n', '        require(vestingExists(_vestingContract));\n', '        internalBalance = internalBalance.sub(_amount);\n', '        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n', '        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n', '        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n', '    }\n', '\n', '    function getTokenBalance() public constant returns (uint256) {\n', '        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n', '    }\n', '    // revoke vesting; release releasable funds to beneficiary and return remaining to master and kill vesting contract\n', '    function revokeVesting(address _vestingContract, string _reason) external onlyOwner {\n', '        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n', '        subVestingContract.revoke(_reason);\n', '        deleteVestingFromStorage(_vestingContract);\n', '    }\n', '    // when vesting is revoked it sends back remaining tokens and updates internalBalance\n', '    function addInternalBalance(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        internalBalance = internalBalance.add(_amount);\n', '    }\n', '    // vestings notifies if there has been any changes in amount of locked tokens\n', '    function addLockedAmount(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        amountLockedInVestings = amountLockedInVestings.add(_amount);\n', '        emit LockedAmountIncreased(_amount);\n', '    }\n', '    // vestings notifies if there has been any changes in amount of locked tokens\n', '    function substractLockedAmount(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n', '        emit LockedAmountDecreased(_amount);\n', '    }\n', '    // check for changes in balance in order to track amount of locked tokens\n', '    function checkForReceivedTokens() public {\n', '        if (getTokenBalance() != internalBalance) {\n', '            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n', '            if (canReceiveTokens) {\n', '                amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n', '                internalBalance = getTokenBalance();\n', '            }\n', '            else {\n', '                emit NotAllowedTokensReceived(receivedFunds);\n', '            }\n', '            emit TokensReceivedSinceLastCheck(receivedFunds);\n', '        } else {\n', '            emit TokensReceivedSinceLastCheck(0);\n', '        }\n', '        fallbackTriggered = false;\n', '    }\n', '\n', '    function salvageNotAllowedTokensSentToContract(address _contractFrom, address _to, uint _amount) external onlyOwner {\n', '        if (_contractFrom == address(this)) {\n', '            // check if there are any new tokens\n', '            checkForReceivedTokens();\n', '            // only allow sending tokens, that were not allowed to be sent to contract\n', '            require(_amount <= getTokenBalance() - internalBalance);\n', '            ERC20TokenInterface(tokenAddress).transfer(_to, _amount);\n', '        }\n', '        if (vestingExists(_contractFrom)) {\n', '            TokenVestingInterface(_contractFrom).salvageNotAllowedTokensSentToContract(_to, _amount);\n', '        }\n', '    }\n', '\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) external onlyOwner {\n', '        require(_tokenAddress != tokenAddress);\n', '        if (_contractAddress == address(this)) {\n', '            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '        }\n', '        if (vestingExists(_contractAddress)) {\n', '            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n', '        }\n', '    }\n', '\n', '    function killContract() external onlyOwner {\n', '        require(vestingAddresses.length == 0);\n', '        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function setWithdrawalAddress(address _vestingContract, address _beneficiary) external {\n', '        require(vestingExists(_vestingContract));\n', '        TokenVestingContract vesting = TokenVestingContract(_vestingContract);\n', '        // withdrawal address can be changed only by beneficiary or in case vesting is changable also by owner\n', '        require(msg.sender == vesting.beneficiary() || (msg.sender == owner && vesting.changable()));\n', '        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n', '        addressToVestingStruct[_vestingContract].beneficiary = _beneficiary;\n', '    }\n', '\n', '    function receiveApproval(address _from, uint256 _amount, address _tokenAddress, bytes _extraData) external {\n', '        require(canReceiveTokens);\n', '        require(_tokenAddress == tokenAddress);\n', '        ERC20TokenInterface(_tokenAddress).transferFrom(_from, address(this), _amount);\n', '        amountLockedInVestings = amountLockedInVestings.add(_amount);\n', '        internalBalance = internalBalance.add(_amount);\n', '        emit TokensReceivedWithApproval(_amount, _extraData);\n', '    }\n', '\n', '    // Deploys a vesting contract to _beneficiary. Assumes that a releasing\n', '    // schedule contract has already been deployed, so we pass it the address\n', '    // of that contract as _releasingSchedule\n', '    function deployVesting(\n', '        address _beneficiary,\n', '        string _vestingType,\n', '        uint256 _vestingVersion,\n', '        bool _canReceiveTokens,\n', '        bool _revocable,\n', '        bool _changable,\n', '        address _releasingSchedule\n', '    ) public onlyOwner {\n', '        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, _canReceiveTokens, _revocable, _changable, _releasingSchedule);\n', '        addVesting(newVesting, _beneficiary, _releasingSchedule, _vestingType, _vestingVersion);\n', '    }\n', '\n', '    function deployOtherVesting(\n', '        address _beneficiary,\n', '        uint256 _amount,\n', '        uint256 _startTime\n', '    ) public onlyOwner {\n', '        TgeOtherReleasingScheduleContract releasingSchedule = new TgeOtherReleasingScheduleContract(_amount, _startTime);\n', '        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, true, true, true, releasingSchedule);\n', "        addVesting(newVesting, _beneficiary, releasingSchedule, 'other', 1);\n", '        fundVesting(newVesting, _amount);\n', '    }\n', '\n', '    function deployTgeTeamVesting(\n', '    address _beneficiary,\n', '    uint256 _amount\n', '    ) public onlyOwner {\n', '        TgeTeamReleasingScheduleContract releasingSchedule = new TgeTeamReleasingScheduleContract();\n', '        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, true, true, true, releasingSchedule);\n', "        addVesting(newVesting, _beneficiary, releasingSchedule, 'X8 team', 1);\n", '        fundVesting(newVesting, _amount);\n', '    }\n', '\n', '\n', '    /**\n', '    * Used to transfer ownership of a vesting contract to this master contract.\n', '    * The vesting contracts require that the master contract be their owner.\n', '    * Use this when you deploy a TokenVestingContract manually and need to transfer\n', '    * ownership to this master contract. First call transferOwnership on the vesting\n', '    * contract.\n', '    * @param _vesting the vesting contract of which to accept ownership.\n', '    */\n', '    function acceptOwnershipOfVesting(address _vesting) external onlyOwner {\n', '        TokenVestingContract(_vesting).acceptOwnership();\n', '    }\n', '\n', '    function setModerator(address _moderator) external onlyOwner {\n', '        moderator = _moderator;\n', '    }\n', '\n', '    function () external{\n', '        fallbackTriggered = true;\n', '    }\n', '}']