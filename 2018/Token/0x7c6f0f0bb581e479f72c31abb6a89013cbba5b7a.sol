['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Moneda {\n', '    using SafeMath for uint256;\n', '    \n', '    string constant public standard = "ERC20";\n', '    string constant public name = "Moneda Token";\n', '    string constant public symbol = "MND";\n', '    uint8 constant public decimals = 18;\n', '    \n', '    uint256 private _totalSupply = 400000000e18; // Total supply tokens 400mil\n', '    uint256 constant public preICOLimit = 20000000e18; // Pre-ICO limit 5%, 20mil\n', '    uint256 constant public icoLimit = 250000000e18; // ICO limit 62.5%, 250mil\n', '    uint256 constant public companyReserve = 80000000e18; // Company Reserve 20%, 80mil\n', '    uint256 constant public teamReserve = 40000000e18; // Team Reserve 10%, 40mil\n', '    uint256 constant public giveawayReserve = 10000000e18; // referral and giving away 2.5%, 10mil\n', '\n', '    uint256 public preICOEnds = 1525132799; // Monday, April 30, 2018 11:59:59 PM\n', '    uint256 public icoStarts = 1526342400; // Tuesday, May 15, 2018 12:00:00 AM\n', '    uint256 public icoEnds = 1531699199; // Sunday, July 15, 2018 11:59:59 PM\n', '    \n', '    uint256 constant public startTime = 1532822400; // Two weeks after ICO ends, Sunday, July 29, 2018 12:00:00 AM\n', '    uint256 constant public teamCompanyLock = 1563148800; // One Year after ICO Ends, Reserve Tokens of company and team becomes transferable.  Monday, July 15, 2019 12:00:00 AM\n', '\n', '    address public ownerAddr;\n', '    address public companyAddr;\n', '    address public giveawayAddr;\n', '    bool public burned;\n', '\n', '    // Array with all balances\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    // Public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Burned(uint256 amount);\n', '    \n', '    // Initializes contract with initial supply tokens to the creator of the contract\n', '    function Moneda(address _ownerAddr, address _companyAddr, address _giveawayAddr) public {\n', '        ownerAddr = _ownerAddr;\n', '        companyAddr = _companyAddr;\n', '        giveawayAddr = _giveawayAddr;\n', '        balances[ownerAddr] = _totalSupply; // Give the owner all initial tokens\n', '    }\n', '    \n', '    // Gets the total token supply\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Gets the balance of the specified address.\n', '    function balanceOf(address who) public view returns (uint256) {\n', '        return balances[who];\n', '    }\n', '    \n', '    // Function to check the amount of tokens that an owner allowed to a spender.\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '    \n', '    // Transfer some of your tokens to another address\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(now >= startTime); // Check if one month lock is passed\n', '        require(value > 0);\n', '\n', '        if (msg.sender == ownerAddr || msg.sender == companyAddr)\n', '                require(now >= teamCompanyLock);\n', '                \n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    // Transfer tokens from one address to another\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        require(value > 0);\n', '        require(to != address(0));\n', '        require(value <= balances[from]);\n', '        require(value <= allowed[from][msg.sender]);\n', '        \n', '        if (now < icoEnds)  // Check if the crowdsale is already over\n', '            require(from == ownerAddr);\n', '\n', '        if (msg.sender == ownerAddr || msg.sender == companyAddr)\n', '            require(now >= teamCompanyLock);\n', '            \n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '    //Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require((value == 0) || (allowed[msg.sender][spender] == 0));\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '   // Called when ICO is closed. Burns the remaining tokens except the tokens reserved:\n', '    // Anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\n', '    // this ensures that the owner will not posses a majority of the tokens.\n', '    function burn() public {\n', '        // Make sure it&#39;s after ICO and hasn&#39;t been called before.\n', '        require(!burned && now > icoEnds);\n', '        uint256 totalReserve = teamReserve.add(companyReserve);\n', '        uint256 difference = balances[ownerAddr].sub(totalReserve);\n', '        balances[ownerAddr] = teamReserve;\n', '        balances[companyAddr] = companyReserve;\n', '        balances[giveawayAddr] = giveawayReserve;\n', '        _totalSupply = _totalSupply.sub(difference);\n', '        burned = true;\n', '        emit Burned(difference);\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Moneda {\n', '    using SafeMath for uint256;\n', '    \n', '    string constant public standard = "ERC20";\n', '    string constant public name = "Moneda Token";\n', '    string constant public symbol = "MND";\n', '    uint8 constant public decimals = 18;\n', '    \n', '    uint256 private _totalSupply = 400000000e18; // Total supply tokens 400mil\n', '    uint256 constant public preICOLimit = 20000000e18; // Pre-ICO limit 5%, 20mil\n', '    uint256 constant public icoLimit = 250000000e18; // ICO limit 62.5%, 250mil\n', '    uint256 constant public companyReserve = 80000000e18; // Company Reserve 20%, 80mil\n', '    uint256 constant public teamReserve = 40000000e18; // Team Reserve 10%, 40mil\n', '    uint256 constant public giveawayReserve = 10000000e18; // referral and giving away 2.5%, 10mil\n', '\n', '    uint256 public preICOEnds = 1525132799; // Monday, April 30, 2018 11:59:59 PM\n', '    uint256 public icoStarts = 1526342400; // Tuesday, May 15, 2018 12:00:00 AM\n', '    uint256 public icoEnds = 1531699199; // Sunday, July 15, 2018 11:59:59 PM\n', '    \n', '    uint256 constant public startTime = 1532822400; // Two weeks after ICO ends, Sunday, July 29, 2018 12:00:00 AM\n', '    uint256 constant public teamCompanyLock = 1563148800; // One Year after ICO Ends, Reserve Tokens of company and team becomes transferable.  Monday, July 15, 2019 12:00:00 AM\n', '\n', '    address public ownerAddr;\n', '    address public companyAddr;\n', '    address public giveawayAddr;\n', '    bool public burned;\n', '\n', '    // Array with all balances\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    // Public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Burned(uint256 amount);\n', '    \n', '    // Initializes contract with initial supply tokens to the creator of the contract\n', '    function Moneda(address _ownerAddr, address _companyAddr, address _giveawayAddr) public {\n', '        ownerAddr = _ownerAddr;\n', '        companyAddr = _companyAddr;\n', '        giveawayAddr = _giveawayAddr;\n', '        balances[ownerAddr] = _totalSupply; // Give the owner all initial tokens\n', '    }\n', '    \n', '    // Gets the total token supply\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Gets the balance of the specified address.\n', '    function balanceOf(address who) public view returns (uint256) {\n', '        return balances[who];\n', '    }\n', '    \n', '    // Function to check the amount of tokens that an owner allowed to a spender.\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '    \n', '    // Transfer some of your tokens to another address\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(now >= startTime); // Check if one month lock is passed\n', '        require(value > 0);\n', '\n', '        if (msg.sender == ownerAddr || msg.sender == companyAddr)\n', '                require(now >= teamCompanyLock);\n', '                \n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    // Transfer tokens from one address to another\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        require(value > 0);\n', '        require(to != address(0));\n', '        require(value <= balances[from]);\n', '        require(value <= allowed[from][msg.sender]);\n', '        \n', '        if (now < icoEnds)  // Check if the crowdsale is already over\n', '            require(from == ownerAddr);\n', '\n', '        if (msg.sender == ownerAddr || msg.sender == companyAddr)\n', '            require(now >= teamCompanyLock);\n', '            \n', '        balances[from] = balances[from].sub(value);\n', '        balances[to] = balances[to].add(value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '    //Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require((value == 0) || (allowed[msg.sender][spender] == 0));\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '   // Called when ICO is closed. Burns the remaining tokens except the tokens reserved:\n', '    // Anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\n', '    // this ensures that the owner will not posses a majority of the tokens.\n', '    function burn() public {\n', "        // Make sure it's after ICO and hasn't been called before.\n", '        require(!burned && now > icoEnds);\n', '        uint256 totalReserve = teamReserve.add(companyReserve);\n', '        uint256 difference = balances[ownerAddr].sub(totalReserve);\n', '        balances[ownerAddr] = teamReserve;\n', '        balances[companyAddr] = companyReserve;\n', '        balances[giveawayAddr] = giveawayReserve;\n', '        _totalSupply = _totalSupply.sub(difference);\n', '        burned = true;\n', '        emit Burned(difference);\n', '    }\n', '}']
