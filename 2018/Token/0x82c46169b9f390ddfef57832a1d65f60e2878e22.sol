['pragma solidity ^0.4.24;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract FLEBToken{\n', '    \n', ' address public owner;\n', ' string public name = "FLEBToken"; //Token name\n', ' string public symbol = "FLB";\n', ' uint8 public decimals = 18;       //일반적으로 18로 많이 사용.\n', ' uint256 public totalSupply = 0; \n', ' \n', ' mapping(address => uint256) balances;\n', ' mapping(address => mapping(address => uint256)) internal allowed; //누가 누구한테 얼마 만큼 허용 \n', ' \n', ' \n', ' constructor() public{\n', '     owner = msg.sender;\n', ' } \n', ' \n', ' \n', ' function changeOwner(address _addr) public{\n', '     \n', '     require(owner == msg.sender);\n', '     owner = _addr;\n', ' }\n', '  /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', ' function transfer(address _to, uint256 _value) public returns (bool) {\n', '     require(_to != address(0));\n', '     require(_value <= balances[msg.sender]);\n', '     \n', '     balances[msg.sender] = balances[msg.sender] - _value;\n', '     balances[_to] = balances[_to] + _value;\n', '     emit Transfer(msg.sender, _to, _value);\n', '     \n', '     return true;\n', '}\n', '\n', 'function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '}\n', '\n', ' /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', ' */\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '     require(_to != address(0));\n', '     require(_value <= balances[_from]);\n', '     require(_value <= allowed[_from][msg.sender]);\n', '     \n', '     balances[_from] = balances[_from] - _value;\n', '     balances[_to] = balances[_to] + _value;\n', '     \n', '     allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '     emit Transfer(_from, _to, _value);\n', '    \n', '    return true;\n', '}  \n', '\n', '/**\n', ' * Set allowance for other address\n', ' *\n', ' * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', ' *\n', ' * @param _spender The address authorized to spend\n', ' * @param _value the max amount they can spend\n', ' */\n', 'function approve(address _spender, uint256 _value) public returns (bool) {\n', '     allowed[msg.sender][_spender] = _value; //내가(누가)  누가 한테얼마를 허용 \n', '     emit Approval(msg.sender, _spender, _value);\n', '     \n', '     return true;\n', '}\n', '\n', 'function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '}\n', '\n', ' /**\n', '* Set allowance for other address and notify\n', '*\n', '* Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '*\n', '* @param _spender The address authorized to spend\n', '* @param _value the max amount they can spend\n', '* @param _extraData some extra information to send to the approved contract\n', '*/\n', ' \n', 'function approveAndCall(address _spender, uint256 _value, bytes _extraData)  public returns (bool success) {\n', '    \n', '    tokenRecipient spender = tokenRecipient(_spender);\n', '    if (approve(_spender, _value)) {\n', '        spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        return true;\n', '    }\n', '}\n', ' \n', '   /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', ' function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '  }\n', '  \n', '   /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', ' function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '      require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '      require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '      balances[_from] -= _value;                         // Subtract from the targeted balance\n', '      allowed[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '      totalSupply -= _value;                            // Update totalSupply\n', '      emit Burn(_from, _value);\n', '      return true;\n', ' }\n', ' \n', ' function mint(address _to, uint256 _amount) public returns (bool) {\n', ' \n', '     require(msg.sender == owner);\n', '     \n', '     totalSupply = totalSupply + _amount;\n', '     balances[_to] = balances[_to] + _amount;\n', '     \n', '     emit Mint(_to, _amount);\n', '     emit Transfer(address(0), _to, _amount);\n', '     \n', '     return true;\n', ' }\n', ' \n', ' function mintSub(address _to,uint256 _amount) public returns (bool){\n', '     \n', '     require(msg.sender == owner);\n', '     require(balances[msg.sender] >= _amount && balances[msg.sender] != 0 );\n', '     \n', '     totalSupply = totalSupply - _amount;\n', '     balances[_to] = balances[_to] - _amount;\n', '     \n', '     emit Mint(_to,_amount);\n', '     emit Transfer(address(0), _to,_amount);\n', '     \n', '     return true;\n', '     \n', ' }\n', ' \n', ' function close() public {\n', '     \n', '     require(msg.sender == owner);\n', '     selfdestruct(owner);\n', ' }\n', ' \n', ' event Transfer(address indexed from, address indexed to, uint256 value);\n', ' event Approval(address indexed owner, address indexed spender, uint256 value);\n', ' event Mint(address indexed to, uint256 amount); \n', ' // This notifies clients about the amount burnt\n', ' event Burn(address indexed from, uint256 value);\n', ' \n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract FLEBToken{\n', '    \n', ' address public owner;\n', ' string public name = "FLEBToken"; //Token name\n', ' string public symbol = "FLB";\n', ' uint8 public decimals = 18;       //일반적으로 18로 많이 사용.\n', ' uint256 public totalSupply = 0; \n', ' \n', ' mapping(address => uint256) balances;\n', ' mapping(address => mapping(address => uint256)) internal allowed; //누가 누구한테 얼마 만큼 허용 \n', ' \n', ' \n', ' constructor() public{\n', '     owner = msg.sender;\n', ' } \n', ' \n', ' \n', ' function changeOwner(address _addr) public{\n', '     \n', '     require(owner == msg.sender);\n', '     owner = _addr;\n', ' }\n', '  /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', ' function transfer(address _to, uint256 _value) public returns (bool) {\n', '     require(_to != address(0));\n', '     require(_value <= balances[msg.sender]);\n', '     \n', '     balances[msg.sender] = balances[msg.sender] - _value;\n', '     balances[_to] = balances[_to] + _value;\n', '     emit Transfer(msg.sender, _to, _value);\n', '     \n', '     return true;\n', '}\n', '\n', 'function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '}\n', '\n', ' /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` on behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', ' */\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '     require(_to != address(0));\n', '     require(_value <= balances[_from]);\n', '     require(_value <= allowed[_from][msg.sender]);\n', '     \n', '     balances[_from] = balances[_from] - _value;\n', '     balances[_to] = balances[_to] + _value;\n', '     \n', '     allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\n', '     emit Transfer(_from, _to, _value);\n', '    \n', '    return true;\n', '}  \n', '\n', '/**\n', ' * Set allowance for other address\n', ' *\n', ' * Allows `_spender` to spend no more than `_value` tokens on your behalf\n', ' *\n', ' * @param _spender The address authorized to spend\n', ' * @param _value the max amount they can spend\n', ' */\n', 'function approve(address _spender, uint256 _value) public returns (bool) {\n', '     allowed[msg.sender][_spender] = _value; //내가(누가)  누가 한테얼마를 허용 \n', '     emit Approval(msg.sender, _spender, _value);\n', '     \n', '     return true;\n', '}\n', '\n', 'function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '}\n', '\n', ' /**\n', '* Set allowance for other address and notify\n', '*\n', '* Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n', '*\n', '* @param _spender The address authorized to spend\n', '* @param _value the max amount they can spend\n', '* @param _extraData some extra information to send to the approved contract\n', '*/\n', ' \n', 'function approveAndCall(address _spender, uint256 _value, bytes _extraData)  public returns (bool success) {\n', '    \n', '    tokenRecipient spender = tokenRecipient(_spender);\n', '    if (approve(_spender, _value)) {\n', '        spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        return true;\n', '    }\n', '}\n', ' \n', '   /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', ' function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '  }\n', '  \n', '   /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', ' function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '      require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '      require(_value <= allowed[_from][msg.sender]);    // Check allowance\n', '      balances[_from] -= _value;                         // Subtract from the targeted balance\n', "      allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '      totalSupply -= _value;                            // Update totalSupply\n', '      emit Burn(_from, _value);\n', '      return true;\n', ' }\n', ' \n', ' function mint(address _to, uint256 _amount) public returns (bool) {\n', ' \n', '     require(msg.sender == owner);\n', '     \n', '     totalSupply = totalSupply + _amount;\n', '     balances[_to] = balances[_to] + _amount;\n', '     \n', '     emit Mint(_to, _amount);\n', '     emit Transfer(address(0), _to, _amount);\n', '     \n', '     return true;\n', ' }\n', ' \n', ' function mintSub(address _to,uint256 _amount) public returns (bool){\n', '     \n', '     require(msg.sender == owner);\n', '     require(balances[msg.sender] >= _amount && balances[msg.sender] != 0 );\n', '     \n', '     totalSupply = totalSupply - _amount;\n', '     balances[_to] = balances[_to] - _amount;\n', '     \n', '     emit Mint(_to,_amount);\n', '     emit Transfer(address(0), _to,_amount);\n', '     \n', '     return true;\n', '     \n', ' }\n', ' \n', ' function close() public {\n', '     \n', '     require(msg.sender == owner);\n', '     selfdestruct(owner);\n', ' }\n', ' \n', ' event Transfer(address indexed from, address indexed to, uint256 value);\n', ' event Approval(address indexed owner, address indexed spender, uint256 value);\n', ' event Mint(address indexed to, uint256 amount); \n', ' // This notifies clients about the amount burnt\n', ' event Burn(address indexed from, uint256 value);\n', ' \n', '}']
