['/* ==================================================================== */\n', '/* Copyright (c) 2018 The CryptoRacing Project.  All rights reserved.\n', '/* \n', '/*   The first idle car race game of blockchain                 \n', '/* ==================================================================== */\n', 'pragma solidity ^0.4.20;\n', '\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// RaceCoin - Crypto Idle Raceing Game\n', '// https://cryptoracing.online\n', '\n', '\n', 'contract AccessAdmin {\n', '    bool public isPaused = false;\n', '    address public addrAdmin;  \n', '\n', '    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n', '\n', '    function AccessAdmin() public {\n', '        addrAdmin = msg.sender;\n', '    }  \n', '\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == addrAdmin);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!isPaused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(isPaused);\n', '        _;\n', '    }\n', '\n', '    function setAdmin(address _newAdmin) external onlyAdmin {\n', '        require(_newAdmin != address(0));\n', '        emit AdminTransferred(addrAdmin, _newAdmin);\n', '        addrAdmin = _newAdmin;\n', '    }\n', '\n', '    function doPause() external onlyAdmin whenNotPaused {\n', '        isPaused = true;\n', '    }\n', '\n', '    function doUnpause() external onlyAdmin whenPaused {\n', '        isPaused = false;\n', '    }\n', '}\n', '\n', '\n', 'interface IRaceCoin {\n', '    function addTotalEtherPool(uint256 amount) external;\n', '    function addPlayerToList(address player) external;\n', '    function increasePlayersAttribute(address player, uint16[13] param) external;\n', '    function reducePlayersAttribute(address player, uint16[13] param) external;\n', '}\n', '\n', 'contract RaceCoin is ERC20, AccessAdmin, IRaceCoin {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name  = "Race Coin";\n', '    string public constant symbol = "Coin";\n', '    uint8 public constant decimals = 0;\n', '    uint256 private roughSupply;\n', '    uint256 public totalRaceCoinProduction;\n', '   \n', '    //Daily dividend ratio\n', '    uint256 public bonusDivPercent = 20;\n', '\n', '    //Recommendation ratio\n', '    uint256 constant refererPercent = 5;\n', '\n', '    \n', '\n', '    address[] public playerList;\n', '    //Verifying whether duplication is repeated\n', '   // mapping(address => uint256) public isProduction;\n', '\n', '\n', "    uint256 public totalEtherPool; // Eth dividends to be split between players' race coin production\n", '    uint256[] private totalRaceCoinProductionSnapshots; // The total race coin production for each prior day past\n', '    uint256[] private allocatedRaceCoinSnapshots; // The amount of EHT that can be allocated daily\n', '    uint256[] private totalRaceCoinSnapshots; // The total race coin for each prior day past\n', '    uint256 public nextSnapshotTime;\n', '\n', '\n', '\n', '    // Balances for each player\n', '    mapping(address => uint256) private ethBalance;\n', '    mapping(address => uint256) private raceCoinBalance;\n', '    mapping(address => uint256) private refererDivsBalance;\n', '\n', '    mapping(address => uint256) private productionBaseValue; //Player production base value\n', '    mapping(address => uint256) private productionMultiplier; //Player production multiplier\n', '\n', '    mapping(address => uint256) private attackBaseValue; //Player attack base value\n', '    mapping(address => uint256) private attackMultiplier; //Player attack multiplier\n', '    mapping(address => uint256) private attackPower; //Player attack Power\n', '\n', '    mapping(address => uint256) private defendBaseValue; //Player defend base value\n', '    mapping(address => uint256) private defendMultiplier; //Player defend multiplier\n', '    mapping(address => uint256) private defendPower; //Player defend Power\n', '\n', '    mapping(address => uint256) private plunderBaseValue; //Player plunder base value\n', '    mapping(address => uint256) private plunderMultiplier; //Player plunder multiplier\n', '    mapping(address => uint256) private plunderPower; //Player plunder Power\n', '\n', '\n', '\n', '\n', "    mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; // Store player's race coin production for given day (snapshot)\n", "    mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.\n", "    mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots;// Store player's race coin for given day (snapshot)\n", '\n', '\n', '\n', '    mapping(address => uint256) private lastRaceCoinSaveTime; // Seconds (last time player claimed their produced race coin)\n', '    mapping(address => uint256) public lastRaceCoinProductionUpdate; // Days (last snapshot player updated their production)\n', '    mapping(address => uint256) private lastRaceCoinFundClaim; // Days (snapshot number)\n', '    mapping(address => uint256) private battleCooldown; // If user attacks they cannot attack again for short time\n', '\n', '\n', '    // Computational correlation\n', '\n', '\n', '    // Mapping of approved ERC20 transfers (by player)\n', '    mapping(address => mapping(address => uint256)) private allowed;\n', '\n', '\n', '    event ReferalGain(address referal, address player, uint256 amount);\n', '    event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder);\n', '\n', '\n', '     /// @dev Trust contract\n', '    mapping (address => bool) actionContracts;\n', '\n', '    function setActionContract(address _actionAddr, bool _useful) external onlyAdmin {\n', '        actionContracts[_actionAddr] = _useful;\n', '    }\n', '\n', '    function getActionContract(address _actionAddr) external view onlyAdmin returns(bool) {\n', '        return actionContracts[_actionAddr];\n', '    }\n', '    \n', '   \n', '\n', '\n', '    function RaceCoin() public {\n', '        addrAdmin = msg.sender;\n', '    }\n', '    \n', '\n', '    function() external payable {\n', '\n', '    }\n', '\n', '\n', '    function beginWork(uint256 firstDivsTime) external onlyAdmin {\n', '\n', '        nextSnapshotTime = firstDivsTime;\n', '    }\n', '\n', '\n', '     // We will adjust to achieve a balance.\n', '    function adjustDailyDividends(uint256 newBonusPercent) external onlyAdmin whenNotPaused {\n', '\n', '        require(newBonusPercent > 0 && newBonusPercent <= 80);\n', '       \n', '        bonusDivPercent = newBonusPercent;\n', '\n', '    }\n', '\n', '    // Stored race coin (rough supply as it ignores earned/unclaimed RaceCoin)\n', '    function totalSupply() public view returns(uint256) {\n', '        return roughSupply; \n', '    }\n', '\n', '\n', '    function balanceOf(address player) public view returns(uint256) {\n', '        return raceCoinBalance[player] + balanceOfUnclaimedRaceCoin(player);\n', '    }\n', '\n', '\n', '    function balanceOfUnclaimedRaceCoin(address player) internal view returns (uint256) {\n', '        uint256 lastSave = lastRaceCoinSaveTime[player];\n', '        if (lastSave > 0 && lastSave < block.timestamp) {\n', '            return (getRaceCoinProduction(player) * (block.timestamp - lastSave)) / 100;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '\n', '    function getRaceCoinProduction(address player) public view returns (uint256){\n', '        return raceCoinProductionSnapshots[player][lastRaceCoinProductionUpdate[player]];\n', '    }\n', '\n', '\n', '    function etherBalanceOf(address player) public view returns(uint256) {\n', '        return ethBalance[player];\n', '    }\n', '\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersRaceCoin(msg.sender);\n', '        require(amount <= raceCoinBalance[msg.sender]);\n', '        \n', '        raceCoinBalance[msg.sender] -= amount;\n', '        raceCoinBalance[recipient] += amount;\n', '        \n', '        emit Transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersRaceCoin(player);\n', '        require(amount <= allowed[player][msg.sender] && amount <= raceCoinBalance[player]);\n', '        \n', '        raceCoinBalance[player] -= amount;\n', '        raceCoinBalance[recipient] += amount;\n', '        allowed[player][msg.sender] -= amount;\n', '        \n', '        emit Transfer(player, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address approvee, uint256 amount) public returns (bool){\n', '        allowed[msg.sender][approvee] = amount;\n', '        emit Approval(msg.sender, approvee, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address player, address approvee) public view returns(uint256){\n', '        return allowed[player][approvee];\n', '    }\n', '\n', '\n', '    function addPlayerToList(address player) external{\n', '        \n', '        require(actionContracts[msg.sender]);\n', '        require(player != address(0));\n', '\n', '        bool b = false;\n', '\n', '        //Judge whether or not to repeat\n', '        for (uint256 i = 0; i < playerList.length; i++) {\n', '            if(playerList[i] == player){\n', '               b = true;\n', '               break;\n', '            }\n', '        } \n', '\n', '        if(!b){\n', '            playerList.push(player);\n', '        }   \n', '    }\n', '\n', '\n', '    function getPlayerList() external view returns ( address[] ){\n', '        return playerList;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '    function updatePlayersRaceCoin(address player) internal {\n', '        uint256 raceCoinGain = balanceOfUnclaimedRaceCoin(player);\n', '        lastRaceCoinSaveTime[player] = block.timestamp;\n', '        roughSupply += raceCoinGain;\n', '        raceCoinBalance[player] += raceCoinGain;\n', '    }\n', '\n', '    //Increase attribute\n', '    function increasePlayersAttribute(address player, uint16[13] param) external{\n', '\n', '\n', '        require(actionContracts[msg.sender]);\n', '        require(player != address(0));\n', '\n', '\n', '        //Production\n', '        updatePlayersRaceCoin(player);\n', '        uint256 increase;\n', '        uint256 newProduction;\n', '        uint256 previousProduction;\n', '\n', '        previousProduction = getRaceCoinProduction(player);\n', '\n', '        productionBaseValue[player] = productionBaseValue[player].add(param[3]);\n', '        productionMultiplier[player] = productionMultiplier[player].add(param[7]);\n', '\n', '        newProduction = productionBaseValue[player].mul(100 + productionMultiplier[player]).div(100);\n', '\n', '        increase = newProduction.sub(previousProduction);\n', '\n', '        raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length] = newProduction;\n', '        lastRaceCoinProductionUpdate[player] = allocatedRaceCoinSnapshots.length;\n', '        totalRaceCoinProduction += increase;\n', '\n', '\n', '\n', '\n', '        //Attack\n', '        attackBaseValue[player] = attackBaseValue[player].add(param[4]);\n', '        attackMultiplier[player] = attackMultiplier[player].add(param[8]);\n', '        attackPower[player] = attackBaseValue[player].mul(100 + attackMultiplier[player]).div(100);\n', '\n', '\n', '        //Defend\n', '        defendBaseValue[player] = defendBaseValue[player].add(param[5]);\n', '        defendMultiplier[player] = defendMultiplier[player].add(param[9]);\n', '        defendPower[player] = defendBaseValue[player].mul(100 + defendMultiplier[player]).div(100);\n', '\n', '\n', '        //Plunder\n', '        plunderBaseValue[player] = plunderBaseValue[player].add(param[6]);\n', '        plunderMultiplier[player] = plunderMultiplier[player].add(param[10]);\n', '\n', '        plunderPower[player] = plunderBaseValue[player].mul(100 + plunderMultiplier[player]).div(100);\n', '\n', '\n', '    }\n', '\n', '\n', '    //Reduce attribute\n', '    function reducePlayersAttribute(address player, uint16[13] param) external{\n', '\n', '        require(actionContracts[msg.sender]);\n', '        require(player != address(0));\n', '\n', '\n', '        //Production\n', '        updatePlayersRaceCoin(player);\n', '\n', '\n', '        uint256 decrease;\n', '        uint256 newProduction;\n', '        uint256 previousProduction;\n', '\n', '\n', '        previousProduction = getRaceCoinProduction(player);\n', '\n', '        productionBaseValue[player] = productionBaseValue[player].sub(param[3]);\n', '        productionMultiplier[player] = productionMultiplier[player].sub(param[7]);\n', '\n', '        newProduction = productionBaseValue[player].mul(100 + productionMultiplier[player]).div(100);\n', '\n', '        decrease = previousProduction.sub(newProduction);\n', '        \n', '        if (newProduction == 0) { // Special case which tangles with "inactive day" snapshots (claiming divs)\n', '            raceCoinProductionZeroedSnapshots[player][allocatedRaceCoinSnapshots.length] = true;\n', '            delete raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length]; // 0\n', '        } else {\n', '            raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length] = newProduction;\n', '        }\n', '        \n', '        lastRaceCoinProductionUpdate[player] = allocatedRaceCoinSnapshots.length;\n', '        totalRaceCoinProduction -= decrease;\n', '\n', '\n', '\n', '\n', '        //Attack\n', '        attackBaseValue[player] = attackBaseValue[player].sub(param[4]);\n', '        attackMultiplier[player] = attackMultiplier[player].sub(param[8]);\n', '        attackPower[player] = attackBaseValue[player].mul(100 + attackMultiplier[player]).div(100);\n', '\n', '\n', '        //Defend\n', '        defendBaseValue[player] = defendBaseValue[player].sub(param[5]);\n', '        defendMultiplier[player] = defendMultiplier[player].sub(param[9]);\n', '        defendPower[player] = defendBaseValue[player].mul(100 + defendMultiplier[player]).div(100);\n', '\n', '\n', '        //Plunder\n', '        plunderBaseValue[player] = plunderBaseValue[player].sub(param[6]);\n', '        plunderMultiplier[player] = plunderMultiplier[player].sub(param[10]);\n', '        plunderPower[player] = plunderBaseValue[player].mul(100 + plunderMultiplier[player]).div(100);\n', '\n', '\n', '    }\n', '\n', '\n', '    function attackPlayer(address player,address target) external {\n', '        require(battleCooldown[player] < block.timestamp);\n', '        require(target != player);\n', '\n', '        updatePlayersRaceCoin(target);\n', '        require(balanceOf(target) > 0);\n', '        \n', '        uint256 attackerAttackPower = attackPower[player];\n', '        uint256 attackerplunderPower = plunderPower[player];\n', '        uint256 defenderDefendPower = defendPower[target];\n', '        \n', '\n', '        if (battleCooldown[target] > block.timestamp) { // When on battle cooldown, the defense is reduced by 50%\n', '            defenderDefendPower = defenderDefendPower.div(2);\n', '        }\n', '        \n', '        if (attackerAttackPower > defenderDefendPower) {\n', '            battleCooldown[player] = block.timestamp + 30 minutes;\n', '            if (balanceOf(target) > attackerplunderPower) {\n', '               \n', '                uint256 unclaimedRaceCoin = balanceOfUnclaimedRaceCoin(target);\n', '                if (attackerplunderPower > unclaimedRaceCoin) {\n', '                    uint256 raceCoinDecrease = attackerplunderPower - unclaimedRaceCoin;\n', '                    raceCoinBalance[target] -= raceCoinDecrease;\n', '                    roughSupply -= raceCoinDecrease;\n', '                } else {\n', '                    uint256 raceCoinGain = unclaimedRaceCoin - attackerplunderPower;\n', '                    raceCoinBalance[target] += raceCoinGain;\n', '                    roughSupply += raceCoinGain;\n', '                }\n', '                raceCoinBalance[player] += attackerplunderPower;\n', '                emit PlayerAttacked(player, target, true, attackerplunderPower);\n', '            } else {\n', '                emit PlayerAttacked(player, target, true, balanceOf(target));\n', '                raceCoinBalance[player] += balanceOf(target);\n', '                raceCoinBalance[target] = 0;\n', '            }\n', '            \n', '            lastRaceCoinSaveTime[target] = block.timestamp;\n', '            lastRaceCoinSaveTime[player] = block.timestamp;\n', '           \n', '        } else {\n', '            battleCooldown[player] = block.timestamp + 10 minutes;\n', '            emit PlayerAttacked(player, target, false, 0);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function getPlayersBattleStats(address player) external view returns (uint256, uint256, uint256, uint256){\n', '\n', '        return (attackPower[player], defendPower[player], plunderPower[player], battleCooldown[player]);\n', '    }\n', '\n', '    \n', '    function getPlayersAttributesInt(address player) external view returns (uint256, uint256, uint256, uint256){\n', '        return (getRaceCoinProduction(player), attackPower[player], defendPower[player], plunderPower[player]); \n', '    }\n', '\n', '\n', '    function getPlayersAttributesMult(address player) external view returns (uint256, uint256, uint256, uint256){\n', '        return (productionMultiplier[player], attackMultiplier[player], defendMultiplier[player], plunderMultiplier[player]);\n', '    }\n', '    \n', '\n', '    function withdrawEther(uint256 amount) external {\n', '        require(amount <= ethBalance[msg.sender]);\n', '        ethBalance[msg.sender] -= amount;\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '\n', '    function getBalance() external view returns(uint256) {\n', '        return totalEtherPool;\n', '    }\n', '\n', '\n', '    function addTotalEtherPool(uint256 amount) external{\n', '        require(amount > 0);\n', '        totalEtherPool += amount;\n', '    }\n', '\n', '\n', '    // To display \n', '    function getGameInfo(address player) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256){\n', '       \n', '        return (block.timestamp, totalEtherPool, totalRaceCoinProduction,nextSnapshotTime, balanceOf(player), ethBalance[player], getRaceCoinProduction(player));\n', '    }\n', '\n', '\n', '   \n', '\n', '\n', '\n', '    function claimRaceCoinDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n', '        require(startSnapshot <= endSnapShot);\n', '        require(startSnapshot >= lastRaceCoinFundClaim[msg.sender]);\n', '        require(endSnapShot < allocatedRaceCoinSnapshots.length);\n', '        \n', '        uint256 dividendsShare;\n', '\n', '\n', '        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n', '\n', '            uint256 raceCoinDuringSnapshot = raceCoinSnapshots[msg.sender][i];\n', '\n', '            dividendsShare += (allocatedRaceCoinSnapshots[i] * raceCoinDuringSnapshot) / totalRaceCoinSnapshots[i];\n', '        }\n', '\n', '        \n', '        lastRaceCoinFundClaim[msg.sender] = endSnapShot + 1;\n', '        \n', '        uint256 referalDivs;\n', '        if (referer != address(0) && referer != msg.sender) {\n', '            referalDivs = dividendsShare.mul(refererPercent).div(100); // 5%\n', '            ethBalance[referer] += referalDivs;\n', '            refererDivsBalance[referer] += referalDivs;\n', '            emit ReferalGain(referer, msg.sender, referalDivs);\n', '        }\n', '        \n', '        ethBalance[msg.sender] += dividendsShare - referalDivs;\n', '    }\n', '\n', '    // To display \n', '    function viewUnclaimedRaceCoinDividends(address player) external view returns (uint256, uint256, uint256) {\n', '        uint256 startSnapshot = lastRaceCoinFundClaim[player];\n', '        uint256 latestSnapshot = allocatedRaceCoinSnapshots.length - 1; // No snapshots to begin with\n', '        \n', '        uint256 dividendsShare;\n', '        \n', '        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n', '\n', '            uint256 raceCoinDuringSnapshot = raceCoinSnapshots[player][i];\n', '\n', '            dividendsShare += (allocatedRaceCoinSnapshots[i] * raceCoinDuringSnapshot) / totalRaceCoinSnapshots[i];\n', '        }\n', '\n', '        return (dividendsShare, startSnapshot, latestSnapshot);\n', '    }\n', '\n', '\n', '    function getRefererDivsBalance(address player)  external view returns (uint256){\n', '        return refererDivsBalance[player];\n', '    }\n', '\n', '\n', '\n', '    // Allocate  divs for the day (00:00 cron job)\n', '    function snapshotDailyRaceCoinFunding() external onlyAdmin whenNotPaused {\n', '       \n', '        uint256 todaysRaceCoinFund = (totalEtherPool * bonusDivPercent) / 100; // 20% of pool daily\n', '        totalEtherPool -= todaysRaceCoinFund;\n', '        \n', '        totalRaceCoinProductionSnapshots.push(totalRaceCoinProduction);\n', '        allocatedRaceCoinSnapshots.push(todaysRaceCoinFund);\n', '        nextSnapshotTime = block.timestamp + 24 hours;\n', '\n', '        \n', '        for (uint256 i = 0; i < playerList.length; i++) {\n', '            updatePlayersRaceCoin(playerList[i]);\n', '            raceCoinSnapshots[playerList[i]][lastRaceCoinProductionUpdate[playerList[i]]] = raceCoinBalance[playerList[i]];\n', '        } \n', '        totalRaceCoinSnapshots.push(roughSupply);\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']