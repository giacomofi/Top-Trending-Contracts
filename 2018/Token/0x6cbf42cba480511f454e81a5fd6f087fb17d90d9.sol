['pragma solidity ^0.4.16;\n', '\n', '/*SPEND APPROVAL ALERT INTERFACE*/\n', 'interface tokenRecipient { \n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external; \n', '}\n', '\n', 'contract TOC {\n', '/*tokenchanger.io*/\n', '\n', '/*TOC TOKEN*/\n', 'string public name;\n', 'string public symbol;\n', 'uint8 public decimals;\n', 'uint256 public totalSupply;\n', '\n', '/*user coin balance*/\n', 'mapping (address => uint256) public balances;\n', '/*user coin allowances*/\n', 'mapping(address => mapping (address => uint256)) public allowed;\n', '\n', '/*EVENTS*/\t\t\n', '/*broadcast token transfers on the blockchain*/\n', 'event BroadcastTransfer(address indexed from, address indexed to, uint256 value);\n', '/*broadcast token spend approvals on the blockchain*/\n', 'event BroadcastApproval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '/*MINT TOKEN*/\n', 'function TOC() public {\n', 'name = "TOC";\n', 'symbol = "TOC";\n', 'decimals = 18;\n', '/*one billion base units*/\n', 'totalSupply = 10**27;\n', 'balances[msg.sender] = totalSupply; \n', '}\n', '\n', '/*INTERNAL TRANSFER*/\n', 'function _transfer(address _from, address _to, uint _value) internal {    \n', '/*prevent transfer to invalid address*/    \n', 'if(_to == 0x0) revert();\n', '/*check if the sender has enough value to send*/\n', 'if(balances[_from] < _value) revert(); \n', '/*check for overflows*/\n', 'if(balances[_to] + _value < balances[_to]) revert();\n', '/*compute sending and receiving balances before transfer*/\n', 'uint PreviousBalances = balances[_from] + balances[_to];\n', '/*substract from sender*/\n', 'balances[_from] -= _value;\n', '/*add to the recipient*/\n', 'balances[_to] += _value; \n', '/*check integrity of transfer operation*/\n', 'assert(balances[_from] + balances[_to] == PreviousBalances);\n', '/*broadcast transaction*/\n', 'emit BroadcastTransfer(_from, _to, _value); \n', '}\n', '\n', '/*PUBLIC TRANSFERS*/\n', 'function transfer(address _to, uint256 _value) external returns (bool){\n', '_transfer(msg.sender, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE THIRD PARTY SPENDING*/\n', 'function approve(address _spender, uint256 _value) public returns (bool success){\n', '/*update allowance record*/    \n', 'allowed[msg.sender][_spender] = _value;\n', '/*broadcast approval*/\n', 'emit BroadcastApproval(msg.sender, _spender, _value); \n', 'return true;                                        \n', '}\n', '\n', '/*THIRD PARTY TRANSFER*/\n', 'function transferFrom(address _from, address _to, uint256 _value) \n', 'external returns (bool success) {\n', '/*check if the message sender can spend*/\n', 'require(_value <= allowed[_from][msg.sender]); \n', '/*substract from message sender&#39;s spend allowance*/\n', 'allowed[_from][msg.sender] -= _value;\n', '/*transfer tokens*/\n', '_transfer(_from, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE SPEND ALLOWANCE AND CALL SPENDER*/\n', 'function approveAndCall(address _spender, uint256 _value, \n', ' bytes _extraData) external returns (bool success) {\n', 'tokenRecipient \n', 'spender = tokenRecipient(_spender);\n', 'if(approve(_spender, _value)) {\n', 'spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '}\n', 'return true;\n', '}\n', '\n', '}/////////////////////////////////end of toc token contract\n', '\n', '\n', 'pragma solidity ^0.4.16;\n', 'contract BlockPoints{\n', '/////////////////////////////////////////////////////////    \n', '///////(c)2017 tokenchanger.io -all rights reserved////// \n', ' \n', '/*SUPER ADMINS*/\n', 'address Mars = 0x1947f347B6ECf1C3D7e1A58E3CDB2A15639D48Be;\n', 'address Mercury = 0x00795263bdca13104309Db70c11E8404f81576BE;\n', 'address Europa = 0x00e4E3eac5b520BCa1030709a5f6f3dC8B9e1C37;\n', 'address Jupiter = 0x2C76F260707672e240DC639e5C9C62efAfB59867;\n', 'address Neptune = 0xEB04E1545a488A5018d2b5844F564135211d3696;\n', '\n', '/*CONTRACT ADDRESS*/\n', 'function GetContractAddr() public constant returns (address){\n', 'return this;\n', '}\t\n', 'address ContractAddr = GetContractAddr();\n', '\n', '/*TOKEN VARIABLES*/\n', 'string public Name;\n', 'string public Symbol;\n', 'uint8 public Decimals;\n', 'uint256 public TotalSupply;\n', '\n', 'struct Global{\n', 'bool Suspend;\n', 'uint256 Rate;\n', '}\n', '\n', 'struct DApps{\n', 'bool AuthoriseMint;\n', 'bool AuthoriseBurn;\n', 'bool AuthoriseRate;\n', '}\n', ' \n', 'struct Admin{\n', 'bool Authorised; \n', 'uint256 Level;\n', '}\n', '\n', 'struct Coloured{\n', 'uint256 Amount;\n', 'uint256 Rate;\n', '}\n', '\n', 'struct AddressBook{\n', 'address TOCAddr;\n', '}\n', '\n', 'struct Process{\n', 'uint256 n1;\n', 'uint256 n2;\n', 'uint256 n3;\n', 'uint256 n4;\n', 'uint256 n5;\n', '}\n', '\n', '/*INITIALIZE DATA STORES*/\n', 'Process pr;\n', '\n', '/*global operational record*/\n', 'mapping (address => Global) public global;\n', '/*user coin balances*/\n', 'mapping (address => uint256) public balances;\n', '/*list of authorised dapps*/\n', 'mapping (address => DApps) public dapps;\n', '/*special exchange rates for block points*/\n', 'mapping(address => mapping(address => Coloured)) public coloured;\n', '/*list of authorised admins*/\n', 'mapping (address => Admin) public admin;\n', '/*comms address book*/\n', 'mapping (address => AddressBook) public addressbook;\n', '\n', '\n', '/*MINT FIRST TOKEN*/\n', 'function BlockPoints() public {\n', 'Name = &#39;BlockPoints&#39;;\n', 'Symbol = &#39;BKP&#39;;\n', 'Decimals = 0;\n', 'TotalSupply = 1;\n', 'balances[msg.sender] = TotalSupply; \n', '}\n', '\n', '/*broadcast minting of tokens*/\n', 'event BrodMint(address indexed from, address indexed enduser, uint256 amount);\n', '/*broadcast buring of tokens*/\n', 'event BrodBurn(address indexed from, address indexed enduser, uint256 amount);\n', '\n', '/*RECEIVE APPROVAL & WITHDRAW TOC TOKENS*/\n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external returns(bool){ \n', 'TOC\n', 'TOCCall = TOC(_token);\n', 'TOCCall.transferFrom(_from,this,_value);\n', 'return true;\n', '}\n', '\n', '/*AUTHORISE ADMINS*/\n', 'function AuthAdmin (address _admin, bool _authority, uint256 _level) external \n', 'returns(bool){\n', 'if((msg.sender != Mars) && (msg.sender != Mercury) && (msg.sender != Europa) &&\n', '(msg.sender != Jupiter) && (msg.sender != Neptune)) revert();      \n', 'admin[_admin].Authorised = _authority;\n', 'admin[_admin].Level = _level;\n', 'return true;\n', '}\n', '\n', '/*ADD ADDRESSES TO ADDRESS BOOK*/\n', 'function AuthAddr(address _tocaddr) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 3 ) revert();\n', 'addressbook[ContractAddr].TOCAddr = _tocaddr;\n', 'return true;\n', '}\n', '\n', '/*AUTHORISE DAPPS*/\n', 'function AuthDapps (address _dapp, bool _mint, bool _burn, bool _rate) external \n', 'returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5) revert();\n', 'dapps[_dapp].AuthoriseMint = _mint;\n', 'dapps[_dapp].AuthoriseBurn = _burn;\n', 'dapps[_dapp].AuthoriseRate = _rate;\n', 'return true;\n', '}\n', '\n', '/*SUSPEND CONVERSIONS*/\n', 'function AuthSuspend (bool _suspend) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 3) revert();\n', 'global[ContractAddr].Suspend = _suspend;\n', 'return true;\n', '}\n', '\n', '/*SET GLOBAL RATE*/\n', 'function SetRate (uint256 _globalrate) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5) revert();\n', 'global[ContractAddr].Rate = _globalrate;\n', 'return true;\n', '}\n', '\n', '/*LET DAPPS ALLOCATE SPECIAL EXCHANGE RATES*/\n', 'function SpecialRate (address _user, address _dapp, uint256 _amount, uint256 _rate) \n', 'external returns(bool){\n', '/*conduct integrity check*/    \n', 'if(dapps[msg.sender].AuthoriseRate == false) revert(); \n', 'if(dapps[_dapp].AuthoriseRate == false) revert(); \n', 'coloured[_user][_dapp].Amount += _amount;\n', 'coloured[_user][_dapp].Rate = _rate;\n', 'return true;\n', '}\n', '\n', '\n', '/*BLOCK POINTS REWARD*/\n', 'function Reward(address r_to, uint256 r_amount) external returns (bool){\n', '/*conduct integrity check*/    \n', 'if(dapps[msg.sender].AuthoriseMint == false) revert(); \n', '/*mint block point for beneficiary*/\n', 'balances[r_to] += r_amount;\n', '/*increase total supply*/\n', 'TotalSupply += r_amount;\n', '/*broadcast mint*/\n', 'emit BrodMint(msg.sender,r_to,r_amount);     \n', 'return true;\n', '}\n', '\n', '/*GENERIC CONVERSION OF BLOCKPOINTS*/\n', 'function ConvertBkp(uint256 b_amount) external returns (bool){\n', '/*conduct integrity check*/\n', 'require(global[ContractAddr].Suspend == false);\n', 'require(b_amount > 0);\n', 'require(global[ContractAddr].Rate > 0);\n', '/*compute expected balance after conversion*/\n', 'pr.n1 = sub(balances[msg.sender],b_amount);\n', '/*check whether the converting address has enough block points to convert*/\n', 'require(balances[msg.sender] >= b_amount); \n', '/*substract block points from converter and total supply*/\n', 'balances[msg.sender] -= b_amount;\n', 'TotalSupply -= b_amount;\n', '/*determine toc liability*/\n', 'pr.n2 = mul(b_amount,global[ContractAddr].Rate);\n', '/*connect to toc contract*/\n', 'TOC\n', 'TOCCall = TOC(addressbook[ContractAddr].TOCAddr);\n', '/*check integrity of conversion operation*/\n', 'assert(pr.n1 == balances[msg.sender]);\n', '/*send toc to message sender*/\n', 'TOCCall.transfer(msg.sender,pr.n2);\n', 'return true;\n', '}\n', '\n', '/*CONVERSION OF COLOURED BLOCKPOINTS*/\n', 'function ConvertColouredBkp(address _dapp) external returns (bool){\n', '/*conduct integrity check*/\n', 'require(global[ContractAddr].Suspend == false);\n', 'require(coloured[msg.sender][_dapp].Rate > 0);\n', '/*determine conversion amount*/\n', 'uint256 b_amount = coloured[msg.sender][_dapp].Amount;\n', 'require(b_amount > 0);\n', '/*check whether the converting address has enough block points to convert*/\n', 'require(balances[msg.sender] >= b_amount); \n', '/*compute expected balance after conversion*/\n', 'pr.n3 = sub(coloured[msg.sender][_dapp].Amount,b_amount);\n', 'pr.n4 = sub(balances[msg.sender],b_amount);\n', '/*substract block points from converter balances and total supply*/\n', 'coloured[msg.sender][_dapp].Amount -= b_amount;\n', 'balances[msg.sender] -= b_amount;\n', 'TotalSupply -= b_amount;\n', '/*determine toc liability*/\n', 'pr.n5 = mul(b_amount,coloured[msg.sender][_dapp].Rate);\n', '/*connect to toc contract*/\n', 'TOC\n', 'TOCCall = TOC(addressbook[ContractAddr].TOCAddr);\n', '/*check integrity of conversion operation*/\n', 'assert(pr.n3 == coloured[msg.sender][_dapp].Amount);\n', 'assert(pr.n4 == balances[msg.sender]);\n', '/*send toc to message sender*/\n', 'TOCCall.transfer(msg.sender,pr.n5);\n', 'return true;\n', '}\n', '\n', '/*BURN BLOCK POINTS*/\n', 'function Burn(address b_to, uint256 b_amount) external returns (bool){\n', '/*check if dapp can burn blockpoints*/    \n', 'if(dapps[msg.sender].AuthoriseBurn == false) revert();    \n', '/*check whether the burning address has enough block points to burn*/\n', 'require(balances[b_to] >= b_amount); \n', '/*substract blockpoints from burning address balance*/\n', 'balances[b_to] -= b_amount;\n', '/*substract blockpoints from total supply*/\n', 'TotalSupply -= b_amount;\n', '/*broadcast burning*/\n', 'emit BrodBurn(msg.sender, b_to,b_amount); \n', 'return true;\n', '}\n', '\n', '/*SAFE MATHS*/\n', 'function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', 'uint256 c = a * b;\n', 'assert(a == 0 || c / a == b);\n', 'return c;\n', '  }\n', 'function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }  \n', '  \n', '}///////////////////////////////////end of blockpoints contract']
['pragma solidity ^0.4.16;\n', '\n', '/*SPEND APPROVAL ALERT INTERFACE*/\n', 'interface tokenRecipient { \n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external; \n', '}\n', '\n', 'contract TOC {\n', '/*tokenchanger.io*/\n', '\n', '/*TOC TOKEN*/\n', 'string public name;\n', 'string public symbol;\n', 'uint8 public decimals;\n', 'uint256 public totalSupply;\n', '\n', '/*user coin balance*/\n', 'mapping (address => uint256) public balances;\n', '/*user coin allowances*/\n', 'mapping(address => mapping (address => uint256)) public allowed;\n', '\n', '/*EVENTS*/\t\t\n', '/*broadcast token transfers on the blockchain*/\n', 'event BroadcastTransfer(address indexed from, address indexed to, uint256 value);\n', '/*broadcast token spend approvals on the blockchain*/\n', 'event BroadcastApproval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '/*MINT TOKEN*/\n', 'function TOC() public {\n', 'name = "TOC";\n', 'symbol = "TOC";\n', 'decimals = 18;\n', '/*one billion base units*/\n', 'totalSupply = 10**27;\n', 'balances[msg.sender] = totalSupply; \n', '}\n', '\n', '/*INTERNAL TRANSFER*/\n', 'function _transfer(address _from, address _to, uint _value) internal {    \n', '/*prevent transfer to invalid address*/    \n', 'if(_to == 0x0) revert();\n', '/*check if the sender has enough value to send*/\n', 'if(balances[_from] < _value) revert(); \n', '/*check for overflows*/\n', 'if(balances[_to] + _value < balances[_to]) revert();\n', '/*compute sending and receiving balances before transfer*/\n', 'uint PreviousBalances = balances[_from] + balances[_to];\n', '/*substract from sender*/\n', 'balances[_from] -= _value;\n', '/*add to the recipient*/\n', 'balances[_to] += _value; \n', '/*check integrity of transfer operation*/\n', 'assert(balances[_from] + balances[_to] == PreviousBalances);\n', '/*broadcast transaction*/\n', 'emit BroadcastTransfer(_from, _to, _value); \n', '}\n', '\n', '/*PUBLIC TRANSFERS*/\n', 'function transfer(address _to, uint256 _value) external returns (bool){\n', '_transfer(msg.sender, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE THIRD PARTY SPENDING*/\n', 'function approve(address _spender, uint256 _value) public returns (bool success){\n', '/*update allowance record*/    \n', 'allowed[msg.sender][_spender] = _value;\n', '/*broadcast approval*/\n', 'emit BroadcastApproval(msg.sender, _spender, _value); \n', 'return true;                                        \n', '}\n', '\n', '/*THIRD PARTY TRANSFER*/\n', 'function transferFrom(address _from, address _to, uint256 _value) \n', 'external returns (bool success) {\n', '/*check if the message sender can spend*/\n', 'require(_value <= allowed[_from][msg.sender]); \n', "/*substract from message sender's spend allowance*/\n", 'allowed[_from][msg.sender] -= _value;\n', '/*transfer tokens*/\n', '_transfer(_from, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE SPEND ALLOWANCE AND CALL SPENDER*/\n', 'function approveAndCall(address _spender, uint256 _value, \n', ' bytes _extraData) external returns (bool success) {\n', 'tokenRecipient \n', 'spender = tokenRecipient(_spender);\n', 'if(approve(_spender, _value)) {\n', 'spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '}\n', 'return true;\n', '}\n', '\n', '}/////////////////////////////////end of toc token contract\n', '\n', '\n', 'pragma solidity ^0.4.16;\n', 'contract BlockPoints{\n', '/////////////////////////////////////////////////////////    \n', '///////(c)2017 tokenchanger.io -all rights reserved////// \n', ' \n', '/*SUPER ADMINS*/\n', 'address Mars = 0x1947f347B6ECf1C3D7e1A58E3CDB2A15639D48Be;\n', 'address Mercury = 0x00795263bdca13104309Db70c11E8404f81576BE;\n', 'address Europa = 0x00e4E3eac5b520BCa1030709a5f6f3dC8B9e1C37;\n', 'address Jupiter = 0x2C76F260707672e240DC639e5C9C62efAfB59867;\n', 'address Neptune = 0xEB04E1545a488A5018d2b5844F564135211d3696;\n', '\n', '/*CONTRACT ADDRESS*/\n', 'function GetContractAddr() public constant returns (address){\n', 'return this;\n', '}\t\n', 'address ContractAddr = GetContractAddr();\n', '\n', '/*TOKEN VARIABLES*/\n', 'string public Name;\n', 'string public Symbol;\n', 'uint8 public Decimals;\n', 'uint256 public TotalSupply;\n', '\n', 'struct Global{\n', 'bool Suspend;\n', 'uint256 Rate;\n', '}\n', '\n', 'struct DApps{\n', 'bool AuthoriseMint;\n', 'bool AuthoriseBurn;\n', 'bool AuthoriseRate;\n', '}\n', ' \n', 'struct Admin{\n', 'bool Authorised; \n', 'uint256 Level;\n', '}\n', '\n', 'struct Coloured{\n', 'uint256 Amount;\n', 'uint256 Rate;\n', '}\n', '\n', 'struct AddressBook{\n', 'address TOCAddr;\n', '}\n', '\n', 'struct Process{\n', 'uint256 n1;\n', 'uint256 n2;\n', 'uint256 n3;\n', 'uint256 n4;\n', 'uint256 n5;\n', '}\n', '\n', '/*INITIALIZE DATA STORES*/\n', 'Process pr;\n', '\n', '/*global operational record*/\n', 'mapping (address => Global) public global;\n', '/*user coin balances*/\n', 'mapping (address => uint256) public balances;\n', '/*list of authorised dapps*/\n', 'mapping (address => DApps) public dapps;\n', '/*special exchange rates for block points*/\n', 'mapping(address => mapping(address => Coloured)) public coloured;\n', '/*list of authorised admins*/\n', 'mapping (address => Admin) public admin;\n', '/*comms address book*/\n', 'mapping (address => AddressBook) public addressbook;\n', '\n', '\n', '/*MINT FIRST TOKEN*/\n', 'function BlockPoints() public {\n', "Name = 'BlockPoints';\n", "Symbol = 'BKP';\n", 'Decimals = 0;\n', 'TotalSupply = 1;\n', 'balances[msg.sender] = TotalSupply; \n', '}\n', '\n', '/*broadcast minting of tokens*/\n', 'event BrodMint(address indexed from, address indexed enduser, uint256 amount);\n', '/*broadcast buring of tokens*/\n', 'event BrodBurn(address indexed from, address indexed enduser, uint256 amount);\n', '\n', '/*RECEIVE APPROVAL & WITHDRAW TOC TOKENS*/\n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external returns(bool){ \n', 'TOC\n', 'TOCCall = TOC(_token);\n', 'TOCCall.transferFrom(_from,this,_value);\n', 'return true;\n', '}\n', '\n', '/*AUTHORISE ADMINS*/\n', 'function AuthAdmin (address _admin, bool _authority, uint256 _level) external \n', 'returns(bool){\n', 'if((msg.sender != Mars) && (msg.sender != Mercury) && (msg.sender != Europa) &&\n', '(msg.sender != Jupiter) && (msg.sender != Neptune)) revert();      \n', 'admin[_admin].Authorised = _authority;\n', 'admin[_admin].Level = _level;\n', 'return true;\n', '}\n', '\n', '/*ADD ADDRESSES TO ADDRESS BOOK*/\n', 'function AuthAddr(address _tocaddr) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 3 ) revert();\n', 'addressbook[ContractAddr].TOCAddr = _tocaddr;\n', 'return true;\n', '}\n', '\n', '/*AUTHORISE DAPPS*/\n', 'function AuthDapps (address _dapp, bool _mint, bool _burn, bool _rate) external \n', 'returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5) revert();\n', 'dapps[_dapp].AuthoriseMint = _mint;\n', 'dapps[_dapp].AuthoriseBurn = _burn;\n', 'dapps[_dapp].AuthoriseRate = _rate;\n', 'return true;\n', '}\n', '\n', '/*SUSPEND CONVERSIONS*/\n', 'function AuthSuspend (bool _suspend) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 3) revert();\n', 'global[ContractAddr].Suspend = _suspend;\n', 'return true;\n', '}\n', '\n', '/*SET GLOBAL RATE*/\n', 'function SetRate (uint256 _globalrate) external returns(bool){\n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5) revert();\n', 'global[ContractAddr].Rate = _globalrate;\n', 'return true;\n', '}\n', '\n', '/*LET DAPPS ALLOCATE SPECIAL EXCHANGE RATES*/\n', 'function SpecialRate (address _user, address _dapp, uint256 _amount, uint256 _rate) \n', 'external returns(bool){\n', '/*conduct integrity check*/    \n', 'if(dapps[msg.sender].AuthoriseRate == false) revert(); \n', 'if(dapps[_dapp].AuthoriseRate == false) revert(); \n', 'coloured[_user][_dapp].Amount += _amount;\n', 'coloured[_user][_dapp].Rate = _rate;\n', 'return true;\n', '}\n', '\n', '\n', '/*BLOCK POINTS REWARD*/\n', 'function Reward(address r_to, uint256 r_amount) external returns (bool){\n', '/*conduct integrity check*/    \n', 'if(dapps[msg.sender].AuthoriseMint == false) revert(); \n', '/*mint block point for beneficiary*/\n', 'balances[r_to] += r_amount;\n', '/*increase total supply*/\n', 'TotalSupply += r_amount;\n', '/*broadcast mint*/\n', 'emit BrodMint(msg.sender,r_to,r_amount);     \n', 'return true;\n', '}\n', '\n', '/*GENERIC CONVERSION OF BLOCKPOINTS*/\n', 'function ConvertBkp(uint256 b_amount) external returns (bool){\n', '/*conduct integrity check*/\n', 'require(global[ContractAddr].Suspend == false);\n', 'require(b_amount > 0);\n', 'require(global[ContractAddr].Rate > 0);\n', '/*compute expected balance after conversion*/\n', 'pr.n1 = sub(balances[msg.sender],b_amount);\n', '/*check whether the converting address has enough block points to convert*/\n', 'require(balances[msg.sender] >= b_amount); \n', '/*substract block points from converter and total supply*/\n', 'balances[msg.sender] -= b_amount;\n', 'TotalSupply -= b_amount;\n', '/*determine toc liability*/\n', 'pr.n2 = mul(b_amount,global[ContractAddr].Rate);\n', '/*connect to toc contract*/\n', 'TOC\n', 'TOCCall = TOC(addressbook[ContractAddr].TOCAddr);\n', '/*check integrity of conversion operation*/\n', 'assert(pr.n1 == balances[msg.sender]);\n', '/*send toc to message sender*/\n', 'TOCCall.transfer(msg.sender,pr.n2);\n', 'return true;\n', '}\n', '\n', '/*CONVERSION OF COLOURED BLOCKPOINTS*/\n', 'function ConvertColouredBkp(address _dapp) external returns (bool){\n', '/*conduct integrity check*/\n', 'require(global[ContractAddr].Suspend == false);\n', 'require(coloured[msg.sender][_dapp].Rate > 0);\n', '/*determine conversion amount*/\n', 'uint256 b_amount = coloured[msg.sender][_dapp].Amount;\n', 'require(b_amount > 0);\n', '/*check whether the converting address has enough block points to convert*/\n', 'require(balances[msg.sender] >= b_amount); \n', '/*compute expected balance after conversion*/\n', 'pr.n3 = sub(coloured[msg.sender][_dapp].Amount,b_amount);\n', 'pr.n4 = sub(balances[msg.sender],b_amount);\n', '/*substract block points from converter balances and total supply*/\n', 'coloured[msg.sender][_dapp].Amount -= b_amount;\n', 'balances[msg.sender] -= b_amount;\n', 'TotalSupply -= b_amount;\n', '/*determine toc liability*/\n', 'pr.n5 = mul(b_amount,coloured[msg.sender][_dapp].Rate);\n', '/*connect to toc contract*/\n', 'TOC\n', 'TOCCall = TOC(addressbook[ContractAddr].TOCAddr);\n', '/*check integrity of conversion operation*/\n', 'assert(pr.n3 == coloured[msg.sender][_dapp].Amount);\n', 'assert(pr.n4 == balances[msg.sender]);\n', '/*send toc to message sender*/\n', 'TOCCall.transfer(msg.sender,pr.n5);\n', 'return true;\n', '}\n', '\n', '/*BURN BLOCK POINTS*/\n', 'function Burn(address b_to, uint256 b_amount) external returns (bool){\n', '/*check if dapp can burn blockpoints*/    \n', 'if(dapps[msg.sender].AuthoriseBurn == false) revert();    \n', '/*check whether the burning address has enough block points to burn*/\n', 'require(balances[b_to] >= b_amount); \n', '/*substract blockpoints from burning address balance*/\n', 'balances[b_to] -= b_amount;\n', '/*substract blockpoints from total supply*/\n', 'TotalSupply -= b_amount;\n', '/*broadcast burning*/\n', 'emit BrodBurn(msg.sender, b_to,b_amount); \n', 'return true;\n', '}\n', '\n', '/*SAFE MATHS*/\n', 'function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', 'uint256 c = a * b;\n', 'assert(a == 0 || c / a == b);\n', 'return c;\n', '  }\n', 'function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }  \n', '  \n', '}///////////////////////////////////end of blockpoints contract']
