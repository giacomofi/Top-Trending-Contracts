['pragma solidity ^0.4.16;\n', '\n', 'contract Ownable {\n', '    \n', '\taddress public owner;// Адрес владельца\n', '    \n', '\tfunction Ownable() public { // Конструктор, создаль является владельцем\n', '    \towner = msg.sender;\n', '\t}\n', ' \n', '\tmodifier onlyOwner() { // Модификатор "Только владелец"\n', '    \trequire(msg.sender == owner);\n', '    \t_;\n', '\t}\n', ' \n', '\tfunction transferOwnership(address _owner) public onlyOwner { // Передача права собственности на контракт токена\n', '    \towner = _owner;\n', '\t}\n', '    \n', '}\n', '\n', 'contract KVCoin is Ownable{\n', '\n', '  string public name; // Название\n', '  string public symbol; // Символ\n', '  uint8 public decimals; // Знаков после запятой\n', '\t \n', '  uint256 public tokenTotalSupply;// Общее количество токенов\n', '\n', '  function totalSupply() constant returns (uint256 _totalSupply){ // Функция, которая возвращает общее количество токенов\n', '  \treturn tokenTotalSupply;\n', '\t}\n', '   \n', '  mapping (address => uint256) public balances; // Хранение токенов (у кого сколько)\n', '  mapping (address => mapping (address => uint256)) public allowed; // Разрешение на перевод эфиров обратно\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) { // Функция, возвращающая количество токенов на запрашиваемом счёте\n', '  \treturn balances[_owner];\n', '  }\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value); // Событие, сигнализирующее о переводе\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value); // Событие, сигнализируещее об одобрении перевода эфиров обратно\n', '  event Mint(address indexed _to, uint256 _amount); // Выпустить токены\n', '  event Burn(address indexed _from, uint256 _value); // Событие, сигнализируещее о сжигании\n', '\n', '  function KVCoin () {\n', '\tname = "KVCoin"; // Имя токена\n', '\tsymbol = "KVC"; // Символ токена\n', '\tdecimals = 0; // Число знаков после запятой\n', '   \t \n', '\ttokenTotalSupply = 0; // Пока не создано ни одного токена\n', '\t}\n', '\n', '  function _transfer(address _from, address _to, uint256 _value) internal returns (bool){ // Вспомогательная функция перевода токенов\n', '\trequire (_to != 0x0); // Адрес назначения не нулевой\n', '\trequire(balances[_from] >= _value); // У переводящего достаточно токенов\n', '\trequire(balances[_to] + _value >= balances[_to]); // У принимающего не случится переполнения\n', '\n', '\tbalances[_from] -= _value; // Списание токенов у отправителя\n', '\tbalances[_to] += _value; // Зачисление токенов получателю\n', '\n', '\tTransfer(_from, _to, _value);\n', '\tif (_to == address(this)){ // Если монетки переведены на счёт контракта токена, они сжигаются\n', '  \treturn burn();\n', '\t}\n', '\treturn true;\n', '  }\n', '\n', '  function serviceTransfer(address _from, address _to, uint256 _value) { // Функция перевода токенов, для владельца, чтобы исправлять косяки, например\n', '\trequire((msg.sender == owner)||(msg.sender == saleAgent)); // Если вызывающий владелец контракта, или контракт-продавец\n', '\t_transfer(_from, _to, _value);        \t \n', '  }\n', '\n', '    \n', '  function transfer(address _to, uint256 _value) returns (bool success) { // Функция для перевода своих токенов\n', '\treturn _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { // Функция для перевода токенов с чужого счёта  \n', '\trequire(_value <= allowed[_from][_to]);// Проверка, что токены были выделены аккаунтом _from для аккаунта _to\n', '\tallowed[_from][_to] -= _value; // Снятие разрешения перевода\n', '\treturn _transfer(_from, _to, _value);//Отправка токенов\n', '  }\n', ' \n', '  function approve(address _spender, uint256 _value) returns (bool success){ // Функция разрешения перевода токенов со своего счёта\n', '\tallowed[msg.sender][_spender] += _value;\n', '\tApproval(msg.sender, _spender, _value);\n', '\treturn true;\n', '  }\n', '\n', '  address public saleAgent; // Адрес контракта продавца, который уполномочен выпускать токены\n', ' \n', '\tfunction setSaleAgent(address newSaleAgnet) public { // Установка адреса контракта продавца\n', '  \trequire(msg.sender == saleAgent || msg.sender == owner);\n', '  \tsaleAgent = newSaleAgnet;\n', '\t}\n', '    \n', '    \n', '  function mint(address _to, uint256 _amount) public returns (bool) { // Выпуск токенов\n', '\trequire(msg.sender == saleAgent);\n', '\ttokenTotalSupply += _amount;\n', '\tbalances[_to] += _amount;\n', '\tMint(_to, _amount);\n', '\tif (_to == address(this)){ // Если монетки созданы на счёте контракта токена, они сжигаются\n', '  \treturn burn();\n', '\t}\n', '\treturn true;\n', '  }\n', ' \n', '  function() external payable {\n', '\towner.transfer(msg.value);\n', '  }\n', '\n', '  function burn() internal returns (bool success) { // Функция для уничтожения токенов, которые появились на счёте контракта токена\n', '\tuint256 burningTokensAmmount = balances[address(this)]; // Запоминаем количество сжигаемых токенов\n', '\ttokenTotalSupply -= burningTokensAmmount; // Общее количество выпущенных токенов сокращается на количество сжигаемых токенов\n', '\tbalances[address(this)] = 0;                  \t// Количество монет на счёте контракта токена обнуляется\n', '    \n', '\tBurn(msg.sender, burningTokensAmmount);\n', '\treturn true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining){ // Функция, возвращающая значение токенов, которым _owner разрешил управлять _spender`у\n', '\treturn allowed[_owner][_spender];\n', '  }\n', '    \n', '}']