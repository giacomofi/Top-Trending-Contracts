['pragma solidity 0.4.24;\n', '\n', '\n', 'contract SnooKarma {\n', '    \n', '    //The oracle checks the authenticity of the Reddit accounts and their karma\n', '    address public oracle;\n', '    \n', '    //The maintainer manages donations and a small Karma fee\n', '    //The maintainer is in charge of keeping the oracle running\n', '    address public maintainer;\n', '    \n', '    //The owner can replace the oracle or maintainer if they are compromised\n', '    address public owner;\n', '    \n', '    //ERC20 code\n', '    //See https://github.com/ethereum/EIPs/blob/e451b058521ba6ccd5d3205456f755b1d2d52bb8/EIPS/eip-20.md\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping (address => uint)) public allowance;\n', '    string public constant symbol = "SNK";\n', '    string public constant name = "SnooKarma";\n', '    uint8 public constant decimals = 2;\n', '    uint public totalSupply = 0;\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '   \n', '    //The Redeem event is activated when a Reddit user redeems Karma Coins\n', '    event Redeem(string indexed username, address indexed addr, uint karma);\n', '    //END OF ERC20 code\n', ' \n', '    //Keep track of Reddit users and their redeemed karma amount\n', '    mapping(string => uint) redeemedKarma;\n', '    \n', '    //Construct the contract\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        maintainer = msg.sender;\n', '        oracle = msg.sender;\n', '    }\n', '    \n', '    //ERC20 code\n', '    //See https://github.com/ethereum/EIPs/blob/e451b058521ba6ccd5d3205456f755b1d2d52bb8/EIPS/eip-20.md\n', '    function transfer(address destination, uint amount) public returns (bool success) {\n', '        if (balanceOf[msg.sender] >= amount && \n', '            balanceOf[destination] + amount > balanceOf[destination]) {\n', '            balanceOf[msg.sender] -= amount;\n', '            balanceOf[destination] += amount;\n', '            emit Transfer(msg.sender, destination, amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', ' \n', '    function transferFrom (\n', '        address from,\n', '        address to,\n', '        uint amount\n', '    ) public returns (bool success) {\n', '        if (balanceOf[from] >= amount &&\n', '            allowance[from][msg.sender] >= amount &&\n', '            balanceOf[to] + amount > balanceOf[to]) \n', '        {\n', '            balanceOf[from] -= amount;\n', '            allowance[from][msg.sender] -= amount;\n', '            balanceOf[to] += amount;\n', '            emit Transfer(from, to, amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', ' \n', '    function approve(address spender, uint amount) public returns (bool success) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '    //END OF ERC20 code\n', '    \n', '    //SafeAdd function from \n', '    //https://github.com/OpenZeppelin/zeppelin-solidity/blob/6ad275befb9b24177b2a6a72472673a28108937d/contracts/math/SafeMath.sol\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    //Used to enforce permissions\n', '    modifier onlyBy(address account) {\n', '        require(msg.sender == account);\n', '        _;\n', '    }\n', '    \n', '    //The owner can transfer ownership\n', '    function transferOwnership(address newOwner) public onlyBy(owner) {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //The owner can change the oracle\n', '    //This works only if removeOracle() was never called\n', '    function changeOracle(address newOracle) public onlyBy(owner) {\n', '        require(oracle != address(0) && newOracle != address(0));\n', '        oracle = newOracle;\n', '    }\n', '\n', '    //The owner can remove the oracle\n', '    //This can not be reverted and stops the generation of new SnooKarma coins!\n', '    function removeOracle() public onlyBy(owner) {\n', '        oracle = address(0);\n', '    }\n', '    \n', '    //The owner can change the maintainer\n', '    function changeMaintainer(address newMaintainer) public onlyBy(owner) {\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    //Allows the user the redeem an amount of Karma verified by the oracle\n', '    //This function also grants a small extra amount of Karma to the maintainer\n', '    //The maintainer gets 1 extra karma for each 100 redeemed by a user\n', '    function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\n', '        //The identity of the oracle is checked\n', '        require(\n', '            ecrecover(\n', '                keccak256(abi.encodePacked(this, username, karma, sigExp)),\n', '                sigV, sigR, sigS\n', '            ) == oracle\n', '        );\n', '        //The signature must not be expired\n', '        require(block.timestamp < sigExp);\n', '        //The amount of karma needs to be more than the previous redeemed amount\n', '        require(karma > redeemedKarma[username]);\n', '        //The new karma that is available to be redeemed\n', '        uint newUserKarma = karma - redeemedKarma[username];\n', '        //The user&#39;s karma balance is updated with the new karma\n', '        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\n', '        //The maintainer&#39;s extra karma is computed (1 extra karma for each 100 redeemed by a user)\n', '        uint newMaintainerKarma = newUserKarma / 100;\n', '        //The balance of the maintainer is updated\n', '        balanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\n', '        //The total supply (ERC20) is updated\n', '        totalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\n', '        //The amount of karma redeemed by a user is updated\n', '        redeemedKarma[username] = karma;\n', '        //The Redeem event is triggered\n', '        emit Redeem(username, msg.sender, newUserKarma);\n', '    }\n', '    \n', '    //This function is a workaround because this.redeemedKarma cannot be public\n', '    //This is the limitation of the current Solidity compiler\n', '    function redeemedKarmaOf(string username) public view returns(uint) {\n', '        return redeemedKarma[username];\n', '    }\n', '    \n', '    //Receive donations\n', '    function() public payable {  }\n', '    \n', '    //Transfer donations or accidentally received Ethereum\n', '    function transferEthereum(uint amount, address destination) public onlyBy(maintainer) {\n', '        require(destination != address(0));\n', '        destination.transfer(amount);\n', '    }\n', '\n', '    //Transfer donations or accidentally received ERC20 tokens\n', '    function transferTokens(address token, uint amount, address destination) public onlyBy(maintainer) {\n', '        require(destination != address(0));\n', '        SnooKarma tokenContract = SnooKarma(token);\n', '        tokenContract.transfer(destination, amount);\n', '    }\n', ' \n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', 'contract SnooKarma {\n', '    \n', '    //The oracle checks the authenticity of the Reddit accounts and their karma\n', '    address public oracle;\n', '    \n', '    //The maintainer manages donations and a small Karma fee\n', '    //The maintainer is in charge of keeping the oracle running\n', '    address public maintainer;\n', '    \n', '    //The owner can replace the oracle or maintainer if they are compromised\n', '    address public owner;\n', '    \n', '    //ERC20 code\n', '    //See https://github.com/ethereum/EIPs/blob/e451b058521ba6ccd5d3205456f755b1d2d52bb8/EIPS/eip-20.md\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping (address => uint)) public allowance;\n', '    string public constant symbol = "SNK";\n', '    string public constant name = "SnooKarma";\n', '    uint8 public constant decimals = 2;\n', '    uint public totalSupply = 0;\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '   \n', '    //The Redeem event is activated when a Reddit user redeems Karma Coins\n', '    event Redeem(string indexed username, address indexed addr, uint karma);\n', '    //END OF ERC20 code\n', ' \n', '    //Keep track of Reddit users and their redeemed karma amount\n', '    mapping(string => uint) redeemedKarma;\n', '    \n', '    //Construct the contract\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        maintainer = msg.sender;\n', '        oracle = msg.sender;\n', '    }\n', '    \n', '    //ERC20 code\n', '    //See https://github.com/ethereum/EIPs/blob/e451b058521ba6ccd5d3205456f755b1d2d52bb8/EIPS/eip-20.md\n', '    function transfer(address destination, uint amount) public returns (bool success) {\n', '        if (balanceOf[msg.sender] >= amount && \n', '            balanceOf[destination] + amount > balanceOf[destination]) {\n', '            balanceOf[msg.sender] -= amount;\n', '            balanceOf[destination] += amount;\n', '            emit Transfer(msg.sender, destination, amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', ' \n', '    function transferFrom (\n', '        address from,\n', '        address to,\n', '        uint amount\n', '    ) public returns (bool success) {\n', '        if (balanceOf[from] >= amount &&\n', '            allowance[from][msg.sender] >= amount &&\n', '            balanceOf[to] + amount > balanceOf[to]) \n', '        {\n', '            balanceOf[from] -= amount;\n', '            allowance[from][msg.sender] -= amount;\n', '            balanceOf[to] += amount;\n', '            emit Transfer(from, to, amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', ' \n', '    function approve(address spender, uint amount) public returns (bool success) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '    //END OF ERC20 code\n', '    \n', '    //SafeAdd function from \n', '    //https://github.com/OpenZeppelin/zeppelin-solidity/blob/6ad275befb9b24177b2a6a72472673a28108937d/contracts/math/SafeMath.sol\n', '    function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    //Used to enforce permissions\n', '    modifier onlyBy(address account) {\n', '        require(msg.sender == account);\n', '        _;\n', '    }\n', '    \n', '    //The owner can transfer ownership\n', '    function transferOwnership(address newOwner) public onlyBy(owner) {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //The owner can change the oracle\n', '    //This works only if removeOracle() was never called\n', '    function changeOracle(address newOracle) public onlyBy(owner) {\n', '        require(oracle != address(0) && newOracle != address(0));\n', '        oracle = newOracle;\n', '    }\n', '\n', '    //The owner can remove the oracle\n', '    //This can not be reverted and stops the generation of new SnooKarma coins!\n', '    function removeOracle() public onlyBy(owner) {\n', '        oracle = address(0);\n', '    }\n', '    \n', '    //The owner can change the maintainer\n', '    function changeMaintainer(address newMaintainer) public onlyBy(owner) {\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    //Allows the user the redeem an amount of Karma verified by the oracle\n', '    //This function also grants a small extra amount of Karma to the maintainer\n', '    //The maintainer gets 1 extra karma for each 100 redeemed by a user\n', '    function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\n', '        //The identity of the oracle is checked\n', '        require(\n', '            ecrecover(\n', '                keccak256(abi.encodePacked(this, username, karma, sigExp)),\n', '                sigV, sigR, sigS\n', '            ) == oracle\n', '        );\n', '        //The signature must not be expired\n', '        require(block.timestamp < sigExp);\n', '        //The amount of karma needs to be more than the previous redeemed amount\n', '        require(karma > redeemedKarma[username]);\n', '        //The new karma that is available to be redeemed\n', '        uint newUserKarma = karma - redeemedKarma[username];\n', "        //The user's karma balance is updated with the new karma\n", '        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\n', "        //The maintainer's extra karma is computed (1 extra karma for each 100 redeemed by a user)\n", '        uint newMaintainerKarma = newUserKarma / 100;\n', '        //The balance of the maintainer is updated\n', '        balanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\n', '        //The total supply (ERC20) is updated\n', '        totalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\n', '        //The amount of karma redeemed by a user is updated\n', '        redeemedKarma[username] = karma;\n', '        //The Redeem event is triggered\n', '        emit Redeem(username, msg.sender, newUserKarma);\n', '    }\n', '    \n', '    //This function is a workaround because this.redeemedKarma cannot be public\n', '    //This is the limitation of the current Solidity compiler\n', '    function redeemedKarmaOf(string username) public view returns(uint) {\n', '        return redeemedKarma[username];\n', '    }\n', '    \n', '    //Receive donations\n', '    function() public payable {  }\n', '    \n', '    //Transfer donations or accidentally received Ethereum\n', '    function transferEthereum(uint amount, address destination) public onlyBy(maintainer) {\n', '        require(destination != address(0));\n', '        destination.transfer(amount);\n', '    }\n', '\n', '    //Transfer donations or accidentally received ERC20 tokens\n', '    function transferTokens(address token, uint amount, address destination) public onlyBy(maintainer) {\n', '        require(destination != address(0));\n', '        SnooKarma tokenContract = SnooKarma(token);\n', '        tokenContract.transfer(destination, amount);\n', '    }\n', ' \n', '}']
