['pragma solidity 0.4.25;\n', '\n', '\n', '/******************************************/\n', '/*       Owned starts here           */\n', '/******************************************/\n', '\n', 'contract owned \n', '{\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner, "Sender not authorized.");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner\n', '    {\n', '        require(_newOwner != address(0), "0x00 address not allowed.");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public\n', '    {\n', '        require(msg.sender == newOwner, "Sender not authorized.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '/******************************************/\n', '/*       TokenERC20 starts here           */\n', '/******************************************/\n', '\n', 'contract TokenERC20\n', '{\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '   \n', '    constructor() public\n', '    {\n', '        decimals = 18;                       // decimals  \n', '        totalSupply = 0;                     // initialSupply\n', '        name = "LOOiX";                      // Set the name for display purposes\n', '        symbol = "LOOIX";                    // Set the symbol for display purposes\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer token for a specified addresses\n', '    * @param _from The address to transfer from.\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function _transfer(address _from, address _to, uint256 _value) internal\n', '    {\n', '        require(_value > 0, "Transferred value has to be grater than 0."); \n', '        require(_to != address(0), "0x00 address not allowed.");                      // Prevent transfer to 0x0 address.\n', '        require(balanceOf[_from] >= _value, "Not enough funds on sender address.");   // Check if the sender has enough\n', '        require(balanceOf[_to] + _value > balanceOf[_to], "Overflow protection.");    // Check for overflows\n', '        balanceOf[_from] -= _value;                                                   // Subtract from the sender\n', '        balanceOf[_to] += _value;                                                     // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens\n', '    * @param _to The address of the recipient\n', '    * @param _value the amount to send\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns(bool success)\n', '    {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer tokens from other address\n', '    * @param _from The address of the sender\n', '    * @param _to The address of the recipient\n', '    * @param _value the amount to send\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success)\n', '    {\n', '        require(_value <= allowance[_from][msg.sender], "Funds not approved.");     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Set allowance for other address\n', '    * @param _spender The address authorized to spend\n', '    * @param _value the max amount they can spend\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns(bool success)\n', '    {\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0, "Approved funds or value are not 0.");\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '/******************************************/\n', '/*       TokenStaking starts here         */\n', '/******************************************/\n', '\n', 'contract TokenStaking\n', '{\n', '\n', '    uint256 internal stakeID;\n', '    uint256 internal threeMonthTime;\n', '    uint256 internal threeMonthPercentage;\n', '    uint256 internal sixMonthTime;\n', '    uint256 internal sixMonthPercentage;\n', '    uint256 internal twelveMonthTime;\n', '    uint256 internal twelveMonthPercentage;\n', '\n', '    struct stakeInfo    // Struct for user vestings\n', '    {\n', '        uint256 endDate;\n', '        uint256 amount;\n', '        address initiator;\n', '        address receiver;\n', '    }\n', '\n', '    mapping(address => uint256) public stakedBalanceOf;\n', '    mapping(uint256 => stakeInfo) internal vestings;\n', '    mapping(address => uint256[]) internal userVestingIDs;\n', '\n', '    enum StakeOption {three, six, twelve}\n', '\n', '    constructor() TokenStaking() public \n', '    { \n', '        stakeID = 0;\n', '       \n', '        threeMonthTime = 91 days;\n', '        threeMonthPercentage = 1005012520859401063; // e**(0.02*0.25)\n', '                               \n', '        sixMonthTime = 182 days;\n', '        sixMonthPercentage = 1020201340026755810; // e**(0.04*0.5)\n', '\n', '        twelveMonthTime = 365 days;\n', '        twelveMonthPercentage = 1061836546545359622; // e**(0.06*1.0)\n', '    }\n', '\n', '    /**\n', '    * @dev Function to get the stake info from a corresponding ID.\n', '    * @param _id uint256 The ID from which the stake info should be read.\n', '    * @return endDate uint256 specifying the seconds since the UNIX Epoch. amount uint256 specifying the amount that was staked plus the stake bonus.\n', '    */\n', '    function getStakeInfo(uint256 _id) external view returns(uint256 endDate, uint256 amount, address receiver, address initiator)\n', '    {\n', '        return (vestings[_id].endDate, vestings[_id].amount, vestings[_id].receiver, vestings[_id].initiator);\n', '    }\n', '    \n', '    /**\n', '    * @dev Function to get the stake IDs from a given address.\n', '    * @param _address address The address which staked tokens.\n', '    * @return Ids uint256[] An array of stake IDs from the given address.\n', '    */\n', '    function getStakeIDs(address _address) external view returns(uint256[] memory Ids)\n', '    {\n', '        return userVestingIDs[_address];\n', '    }\n', '\n', '    /**\n', '    * @dev Stake an amount of tokens with one of three options.\n', '    * @param _amount uint256 The amount of tokens which will be staked.\n', '    * @param _option StakeOption An enum which decides how long a stake will be frozen (only 0, 1 and 2 are valid values).\n', '    * @return totalSupplyIncreaseds uint256 The total increase in supply from the staked tokens.\n', '    */\n', '    function _stake(uint256 _amount, StakeOption _option, address _receiver) internal returns(uint256 totalSupplyIncrease)\n', '    {\n', '        require(_option >= StakeOption.three && _option <= StakeOption.twelve);\n', '        \n', '        stakeInfo memory stakeStruct;\n', '        stakeStruct.endDate = 0;\n', '        stakeStruct.amount = 0;\n', '        stakeStruct.initiator = msg.sender;\n', '        stakeStruct.receiver = address(0);\n', '\n', '        uint256 tempIncrease;\n', '\n', '        if (_option == StakeOption.three) \n', '        {\n', '            stakeStruct.endDate = now + threeMonthTime;\n', '            stakeStruct.amount = _amount * threeMonthPercentage / (10**18);\n', '            stakeStruct.initiator = msg.sender;\n', '            stakeStruct.receiver = _receiver;\n', '            tempIncrease = (_amount * (threeMonthPercentage - (10**18)) / (10**18));\n', '        } \n', '        else if (_option == StakeOption.six)\n', '        {\n', '            stakeStruct.endDate = now + sixMonthTime;\n', '            stakeStruct.amount = _amount * sixMonthPercentage / (10**18);\n', '            stakeStruct.initiator = msg.sender;\n', '            stakeStruct.receiver = _receiver;\n', '            tempIncrease = (_amount * (sixMonthPercentage - (10**18)) / (10**18));\n', '        } \n', '        else if (_option == StakeOption.twelve)\n', '        {\n', '            stakeStruct.endDate = now + twelveMonthTime;\n', '            stakeStruct.amount = _amount * twelveMonthPercentage / (10**18);\n', '            stakeStruct.initiator = msg.sender;\n', '            stakeStruct.receiver = _receiver;\n', '            tempIncrease = (_amount * (twelveMonthPercentage - (10**18)) / (10**18));\n', '        }\n', '\n', '        stakeID = stakeID + 1;\n', '        vestings[stakeID] = stakeStruct;\n', '        _setVestingID(stakeID, stakeStruct.receiver);\n', '        stakedBalanceOf[msg.sender] += stakeStruct.amount;\n', '        return tempIncrease;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to set a new vesting ID on the userVestingIDs mapping. Free ID slots in the array will be overwritten.\n', '    * @param _id uint256 The new ID that has to be written in the corresponding mapping.\n', '    */\n', '    function _setVestingID(uint256 _id, address _receiver) internal\n', '    {\n', '        bool tempEntryWritten = false;\n', '        uint256 arrayLength = userVestingIDs[_receiver].length;\n', '\n', '        if(arrayLength != 0)\n', '        {\n', '            for (uint256 i = 0; i < arrayLength; i++) \n', '            {\n', '                if (userVestingIDs[_receiver][i] == 0) \n', '                {\n', '                    userVestingIDs[_receiver][i] = _id;\n', '                    tempEntryWritten = true;\n', '                    break;\n', '                } \n', '            }\n', '\n', '            if(!tempEntryWritten)\n', '            {\n', '                userVestingIDs[_receiver].push(_id);\n', '            }\n', '        } \n', '        else\n', '        {\n', '            userVestingIDs[_receiver].push(_id);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Redeem the staked tokens.\n', '    * @return amount uint256 The amount that has been redeemed.\n', '    */\n', '    function _redeem() internal returns(uint256 amount)\n', '    {\n', '        uint256[] memory IdArray = userVestingIDs[msg.sender];\n', '        uint256 tempAmount = 0;\n', '        uint256 finalAmount = 0;\n', '        address tempInitiator = address(0);\n', '\n', '        for(uint256 i = 0; i < IdArray.length; i++)\n', '        {\n', '            if(IdArray[i] != 0 && vestings[IdArray[i]].endDate <= now)\n', '            {\n', '                tempInitiator = vestings[IdArray[i]].initiator;\n', '                tempAmount = vestings[IdArray[i]].amount;\n', '\n', '                stakedBalanceOf[tempInitiator] -= tempAmount;\n', '                finalAmount += tempAmount;\n', '\n', '                // delete the vesting history\n', '                delete userVestingIDs[msg.sender][i];\n', '                delete vestings[IdArray[i]];\n', '            }\n', '        }\n', '\n', '        require(finalAmount > 0, "No funds to redeem.");\n', '        return finalAmount;\n', '    }\n', '}\n', '\n', '\n', '/******************************************/\n', '/*       LOOiXToken starts here       */\n', '/******************************************/\n', '\n', 'contract LOOiXToken is owned, TokenERC20, TokenStaking\n', '{\n', '\n', '    bool public mintingActive;\n', '    address public mintDelegate;\n', '    uint256 public unlockAt;\n', '    uint256 public ICO_totalSupply;\n', '    uint256 internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    mapping(address => uint256) public allocations;\n', '\n', '    event Stake(address indexed _target, uint256 _amount);\n', '    event Redeem(address indexed _target, uint256 _amount);\n', '\n', '    constructor() TokenERC20() public \n', '    {\n', '        mintingActive = true;\n', '        mintDelegate = address(0);\n', '        unlockAt;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier defines addresses allowed to mint. \n', '    */\n', '    modifier mintingAllowed\n', '    {\n', '        require(msg.sender == owner || msg.sender == mintDelegate, "Sender not authorized.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal ERC20 transfer.\n', '    */\n', '    function _transfer(address _from, address _to, uint256 _value) internal\n', '    {\n', '        require(_value > 0, "Transferred value has to be grater than 0.");            // value has to be greater than 0\n', '        require(_to != address(0), "0x00 address not allowed.");                      // Prevent transfer to 0x0 address\n', '        require(balanceOf[_from] >= _value, "Not enough funds on sender address.");   // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to], "Overflow protection.");   // Check for overflows\n', '        balanceOf[_from] -= _value;                                                   // Subtract from the sender\n', '        balanceOf[_to] += _value;                                                     // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance.\n', '    * @param _from Address to transfer from.\n', '    * @param _to Address to transfer to.\n', '    * @param _value Amount to transfer.\n', '    * @return Success of transfer.\n', '    */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\n', '    {\n', '        uint256 allowanceTemp = allowance[_from][msg.sender];\n', '        \n', '        require(allowanceTemp >= _value, "Funds not approved."); \n', '        require(balanceOf[_from] >= _value, "Not enough funds on sender address.");\n', '        require(balanceOf[_to] + _value >= balanceOf[_to], "Overflow protection.");\n', '\n', '        balanceOf[_to] += _value;\n', '        balanceOf[_from] -= _value;\n', '\n', '        if (allowanceTemp < MAX_UINT) \n', '        {\n', '            allowance[_from][msg.sender] -= _value;\n', '        }\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Set new mintDelegate address\n', '    * @param _newDelegate The address authorized to mint\n', '    */  \n', '    function setMintDelegate(address _newDelegate) external onlyOwner\n', '    {\n', '        require(_newDelegate != address(0), "0x00 address not allowed.");\n', '        mintDelegate = _newDelegate;\n', '    }\n', '    \n', '    /**\n', '    * @dev Set unlimited allowance for other address\n', '    * @param _controllerAddress The address authorized to spend\n', '    */   \n', '    function giveAccess(address _controllerAddress) external\n', '    {\n', '        require(msg.sender != owner, "Owner of contract can not use this function.");\n', '        require(_controllerAddress != address(0), "0x00 address not allowed.");\n', '        allowance[msg.sender][_controllerAddress] = MAX_UINT;\n', '        emit Approval(msg.sender, _controllerAddress, MAX_UINT);\n', '    }\n', '\n', '    /**\n', '    * @dev Set allowance for other address to 0\n', '    * @param _controllerAddress The address authorized to spend\n', '    */   \n', '    function revokeAccess(address _controllerAddress) external\n', '    {\n', '        require(_controllerAddress != address(0), "0x00 address not allowed.");\n', '        allowance[msg.sender][_controllerAddress] = 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Withdraw all LOOiX on the contract.\n', '    */ \n', '    function withdrawLOOiX() external onlyOwner\n', '    {\n', '        require(balanceOf[address(this)] > 0, "No funds available.");\n', '        _transfer(address(this), owner, balanceOf[address(this)]);\n', '    }\n', '\n', '    /**\n', '    * @dev Bulk mint function for airdrops. \n', '    * @param _address Address array to mint to.\n', '    * @param _mintAmount Amount array to mint.\n', '    */\n', '    function mintTokenBulk(address[] _address, uint256[] _mintAmount) external mintingAllowed\n', '    {\n', '        require(mintingActive, "The mint functions are not available anymore.");\n', '        uint256 tempAmount = 0;\n', '\n', '        for (uint256 i = 0; i < _address.length; i++) \n', '        {\n', '            if(balanceOf[_address[i]] + _mintAmount[i] >= balanceOf[_address[i]])\n', '            {\n', '                balanceOf[_address[i]] += _mintAmount[i] * (10**18);\n', '                tempAmount += _mintAmount[i] * (10**18);\n', '\n', '                emit Transfer(address(0), _address[i], _mintAmount[i] * (10**18));\n', '            }\n', '        }\n', '\n', '        totalSupply += tempAmount;\n', '    }\n', '\n', '    /**\n', '    * @dev Mint function for creating new tokens. \n', '    * @param _target Address to mint to.\n', '    * @param _mintAmount Amount to mint.\n', '    */\n', '    function mintToken(address _target, uint256 _mintAmount) public mintingAllowed \n', '    {\n', '        require(mintingActive, "The mint functions are not available anymore.");\n', '        require(_target != address(0), "0x00 address not allowed.");\n', '\n', '        balanceOf[_target] += _mintAmount * (10**18);\n', '        totalSupply += _mintAmount * (10**18);\n', '\n', '        emit Transfer(address(0), _target, _mintAmount * (10**18));\n', '    }\n', '\n', '    /**\n', '    * @dev Stops the minting of the token. After this function is called, no new tokens can be minted using the mintToken or mintTokenBulk functions. Irreversible.\n', '    */\n', '    function terminateMinting() external onlyOwner \n', '    {\n', '        require(mintingActive, "The mint functions are not available anymore.");\n', '        uint256 tempTotalSupply = totalSupply;\n', '\n', '        tempTotalSupply = tempTotalSupply + (tempTotalSupply  * 666666666666666666 / 10**18);\n', '        totalSupply = tempTotalSupply;\n', '        ICO_totalSupply = tempTotalSupply;\n', '\n', '        mintingActive = false;\n', '        unlockAt = now + 365 days;\n', '\n', '        // 40% of the total token supply\n', '        allocations[0xefbDBA37BD0e825d43bac88Ce570dcEFf50373C2] = tempTotalSupply * 9500 / 100000;      // 9.5% - Founders Pot.\n', '        allocations[0x75dE233590c8Dd593CE1bB89d68e9f18Ecdf34C8] = tempTotalSupply * 9500 / 100000;      // 9.5% - Development and Management.\n', '        allocations[0x357C2e4253389CE79440e867E9De14E17Bb97D2E] = tempTotalSupply * 3120 / 100000;      // 3.12% - Bonuspool.\n', '        allocations[0xf35FF681cbb69b47488269CE2BA5CaA34133813A] = tempTotalSupply * 14250 / 100000;     // 14.25% - Marketing.\n', '\n', '        balanceOf[0x2A809456adf8bd5A79D598e880f7Bd78e11B4A1c] += tempTotalSupply * 242 / 100000;        \n', '        balanceOf[0x36c321017a8d8655ec7a2b862328678932E53b87] += tempTotalSupply * 242 / 100000;        \n', '        balanceOf[0xc9ebc197Ee00C1E231817b4eb38322C364cFCFCD] += tempTotalSupply * 242 / 100000;\n', '        balanceOf[0x2BE34a67491c6b1f8e0cA3BAA1249c90686CF6FB] += tempTotalSupply * 726 / 100000;\n', '        balanceOf[0x1cF6725538AAcC9574108845D58cF2e89f62bbE9] += tempTotalSupply * 4 / 100000;\n', '        balanceOf[0xc6a3B6ED936bD18FD72e0ae2D50A10B82EF79851] += tempTotalSupply * 130 / 100000;\n', '        balanceOf[0x204Fb77569ca24C09e1425f979141536B89449E3] += tempTotalSupply * 130 / 100000;\n', '\n', '        balanceOf[0xbE3Ece67B61Ef6D3Fd0F8b159d16A80BB04C0F7B] += tempTotalSupply * 164 / 100000;        // Bonuspool.\n', '        balanceOf[0x731953d4c9A01c676fb6b013688AA8D512F5Ec03] += tempTotalSupply * 500 / 100000;        // Development and Management.\n', '        balanceOf[0x84A81f3B42BD99Fd435B1498316F8705f84192bC] += tempTotalSupply * 500 / 100000;        // Founders Pot.\n', '        balanceOf[0xEAeC9b7382e5abEBe76Fc7BDd2Dc22BA1a338918] += tempTotalSupply * 750 / 100000;        // Marketing.\n', '    }\n', '\n', '    /**\n', '    * @dev Public unlock allocated Tokens.\n', '    */\n', '    function unlock() public\n', '    {\n', '        require(!mintingActive, "Function not available as long as minting is possible.");\n', '        require(now > unlockAt, "Unlock date not reached.");\n', '        require(allocations[msg.sender] > 0, "No tokens to unlock.");\n', '        uint256 tempAmount;\n', '\n', '        tempAmount = allocations[msg.sender];\n', '        allocations[msg.sender] = 0;\n', '        balanceOf[msg.sender] += tempAmount;\n', '    }\n', '\n', '    /**\n', '    * @dev Public stake function to stake a given amount of tokens for one of the three options.\n', '    * @param _amount Amount to stake.\n', '    * @param _option StakeOption enum with values from 0 to 2.\n', '    * @return Success of stake.\n', '    */\n', '    function stake(uint256 _amount, StakeOption _option, address _receiver) external returns(bool success)\n', '    {\n', '        require(!mintingActive, "Function not available as long as minting is possible.");\n', '        require(balanceOf[msg.sender] >= _amount, "Not enough funds on sender address.");\n', '        require(_amount >= 100*(10**18), "Amount is less than 100 token.");\n', '        require(_receiver != address(0), "0x00 address not allowed.");\n', '        uint256 supplyIncrease;\n', '        uint256 finalBalance;\n', '\n', '        supplyIncrease = _stake(_amount, _option, _receiver);\n', '        totalSupply += supplyIncrease;\n', '        balanceOf[msg.sender] -= _amount;\n', '        finalBalance = _amount + supplyIncrease;\n', '\n', '        emit Stake(_receiver, _amount);\n', '        emit Transfer(msg.sender, _receiver, finalBalance);\n', '    \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '    * @dev Public redeem function to redeem all redeemable tokens.\n', '    */\n', '    function redeem() public\n', '    {\n', '        require(userVestingIDs[msg.sender].length > 0, "No funds to redeem.");\n', '        uint256 amount;\n', '\n', '        amount = _redeem();\n', '        balanceOf[msg.sender] += amount;\n', '        emit Redeem(msg.sender, amount); \n', '    }\n', '}']