['pragma solidity ^0.4.25;\n', '\n', 'contract CompanyToken {\n', '\n', '    /* variables */\n', '    string public name; /* ERC20 Name */\n', '    string public symbol; /* ERC20 Symbol */\n', '    uint8 public decimals; /* ERC20 Decimals */\n', '    uint256 public totalSupply; /* ERC20 total Supply */\n', '    address public owner; /* Owner address */\n', '    uint256 public rate; /* Token Exchange Rate in Euro */\n', '\tbool public allow_buy; /* allow token payed with eth */\n', '    mapping(address => uint256) balances; /* Token Balances */\n', '\n', '    /* events */    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Mint(address indexed owner, uint256 value);\n', '    event SetOwner(address indexed owner);\n', '    event SetAllowBuy(bool allow_buy);\n', '    event SetRate(uint256 rate);\n', '    event CreateToken(address indexed sender, uint256 value);\n', '    \n', '    /* variables on contract create */\n', '    constructor() public {\n', '        totalSupply = 2500000; /* decimals * real value */\n', '        name = "BSOnders";\n', '        symbol = "BSO";\n', '        decimals = 2;\n', '        rate = 190;\n', '        balances[msg.sender] = totalSupply;\n', '        owner = msg.sender;\n', '        allow_buy = false;\n', '    }\n', '    \n', '    /* modifier */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\tmodifier onlyPayloadSize(uint size) {\n', '\t\tassert(msg.data.length >= size + 4);\n', '\t\t_;\n', '\t}\n', '\t\n', '    /* default ERC20 functions */\n', '    function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) private returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }    \n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* set functions */ \n', '    function setRate(uint256 _value) public onlyOwner returns(bool success) {\n', '        rate = _value;\n', '        emit SetRate(_value);\n', '        return true;\n', '    }        \n', '\n', '    function setOwner(address _owner) public onlyOwner returns (bool success) {\n', '        owner = _owner;\n', '        emit SetOwner(_owner);\n', '        return true;\n', '    }    \n', '\n', '    function setAllowBuy(bool _value) public onlyOwner returns(bool success) {\n', '        allow_buy = _value;\n', '        emit SetAllowBuy(_value);\n', '        return true;\n', '    }\n', '\n', '    /* special functions */\n', '    function distribute(address[] recipients, uint256[] _value) public onlyOwner returns (bool success) {\n', '        for(uint i = 0; i < recipients.length; i++) {\n', '            transferFrom(owner, recipients[i], _value[i]);\n', '        }\n', '        return true;\n', '    }    \n', '   \n', '    function mint(uint256 _value) private returns (bool success) {\n', '        require(_value > 0);\n', '        balances[msg.sender] = balances[msg.sender] + _value;\n', '        totalSupply = totalSupply + _value;\n', '        emit Mint(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /*\n', '    function burn(uint256 _value) public onlyOwner returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        balances[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        balances[_from] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }    \n', '    */\n', '  \n', '    /* private functions */\n', '    function createToken(uint256 _value) private returns (bool success) {\n', '        // require(_value > 0);\n', '        // uint256 tokens = rate * _value * 10 ** uint(decimals) / (1 ether);\n', '        uint256 tokens = rate * _value * 100 / (1 ether);\n', '        mint(tokens);\n', '        emit CreateToken(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '     /* @notice Will receive any eth sent to the contract */\n', '    function() external payable {\n', '        if(allow_buy) {\n', '            createToken(msg.value);\n', '        } else {\n', '            revert(); // Reject any accidental Ether transfer\n', '        }\n', '    }\n', '}']