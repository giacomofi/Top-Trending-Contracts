['pragma solidity ^0.4.25;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract SafeMath {\n', '    \n', '    uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'interface MintableTokenInterface {\n', '    function mint(address _to, uint256 _amount) external;\n', '}\n', '\n', 'contract MintingContract is Owned, SafeMath{\n', '    \n', '    address public tokenAddress;\n', '    uint256 public tokensAlreadyMinted;\n', '\n', '    enum state { crowdsaleMinting, additionalMinting, disabled}\n', '    state public mintingState; \n', '\n', '    uint256 public crowdsaleMintingCap;\n', '    uint256 public tokenTotalSupply;\n', '    \n', '    constructor() public {\n', '        tokensAlreadyMinted = 0;\n', '        crowdsaleMintingCap = 22000000 * 10 ** 18;\n', '        tokenTotalSupply = 44000000 * 10 ** 18;\n', '    }\n', '\n', '    function doCrowdsaleMinting(address _destination, uint _tokensToMint) public onlyOwner {\n', '        require(mintingState == state.crowdsaleMinting);\n', '        require(safeAdd(tokensAlreadyMinted, _tokensToMint) <= crowdsaleMintingCap);\n', '\n', '        MintableTokenInterface(tokenAddress).mint(_destination, _tokensToMint);\n', '        tokensAlreadyMinted = safeAdd(tokensAlreadyMinted, _tokensToMint);\n', '    }\n', '    function doAdditionalMinting(address _destination, uint _tokensToMint) public {\n', '        require(mintingState == state.additionalMinting);\n', '        require(safeAdd(tokensAlreadyMinted, _tokensToMint) <= tokenTotalSupply);\n', '\n', '        MintableTokenInterface(tokenAddress).mint(_destination, _tokensToMint);\n', '        tokensAlreadyMinted = safeAdd(tokensAlreadyMinted, _tokensToMint);\n', '    }\n', '    \n', '    function finishCrowdsaleMinting() onlyOwner public {\n', '        mintingState = state.additionalMinting;\n', '    }\n', '    \n', '    function disableMinting() onlyOwner public {\n', '        mintingState = state.disabled;\n', '    }\n', '\n', '    function setTokenAddress(address _tokenAddress) onlyOwner public {\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '    \n', ' \n', '}']