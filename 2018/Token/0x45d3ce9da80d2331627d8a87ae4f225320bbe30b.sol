['pragma solidity ^0.4.24;\n', 'contract YellowBetterToken\n', '{\n', '    string public constant name = "Yellow Better";\n', '    string public constant symbol = "YBT";\n', '    uint8 public constant decimals = 18;\n', '    uint public constant _totalSupply = 2000000000000000000000000000;\n', '    uint public totalSupply = _totalSupply;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    event Transfer(address indexed, address indexed, uint);\n', '    event Approval(address indexed, address indexed, uint);\n', '    event Burn(address indexed, uint);\n', '    constructor()\n', '    {\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '    function sub(uint a, uint b) private pure returns (uint)\n', '    {\n', '        require(a >= b);\n', '        return a - b;\n', '    }\n', '    function balanceOf(address tokenOwner) view returns (uint)\n', '    {\n', '        return balances[tokenOwner];\n', '    }\n', '    function transfer(address to, uint tokens) returns (bool)\n', '    {\n', '        balances[msg.sender] = sub(balances[msg.sender], tokens);\n', '        balances[to] += tokens;\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    function transferFrom(address from, address to, uint tokens) returns (bool)\n', '    {\n', '        // subtract tokens from both balance and allowance, fail if any is smaller\n', '        balances[from] = sub(balances[from], tokens);\n', '        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens);\n', '        balances[to] += tokens;\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '    function approve(address spender, uint tokens) returns (bool)\n', '    {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    function allowance(address tokenOwner, address spender) view returns (uint)\n', '    {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '    function burn(uint tokens)\n', '    {\n', '        balances[msg.sender] = sub(balances[msg.sender], tokens);\n', '        totalSupply -= tokens;\n', '        emit Burn(msg.sender, tokens);\n', '    }\n', '}\n', 'contract TokenSale\n', '{\n', '    address public creator;\n', '    address public tokenContract;\n', '    uint public tokenPrice; // in wei\n', '    uint public deadline;\n', '    constructor(address source)\n', '    {\n', '        creator = msg.sender;\n', '        tokenContract = source;\n', '    }\n', '    function setPrice(uint price)\n', '    {\n', '        if (msg.sender == creator) tokenPrice = price;\n', '    }\n', '    function setDeadline(uint timestamp)\n', '    {\n', '        if (msg.sender == creator) deadline = timestamp;\n', '    }\n', '    function buyTokens(address beneficiary) payable\n', '    {\n', '        require(\n', '            block.timestamp < deadline\n', '            && tokenPrice > 0\n', '            && YellowBetterToken(tokenContract).transfer(beneficiary, 1000000000000000000 * msg.value / tokenPrice));\n', '    }\n', '    function payout()\n', '    {\n', '        creator.transfer(this.balance);\n', '    }\n', '}']