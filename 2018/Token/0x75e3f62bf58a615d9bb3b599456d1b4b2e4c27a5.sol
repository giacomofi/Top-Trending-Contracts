['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/// @title Contract class\n', '/// @author Infinigon Group\n', '/// @notice Contract class defines the name of the contract\n', 'contract Contract {\n', '    bytes32 public Name;\n', '\n', '    /// @notice Initializes contract with contract name\n', '    /// @param _contractName The name to be given to the contract\n', '    constructor(bytes32 _contractName) public {\n', '        Name = _contractName;\n', '    }\n', '\n', '    function() public payable { }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Default Token\n', '// ----------------------------------------------------------------------------\n', 'contract DeaultERC20 is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "DFLT";\n', '        name = "Default";\n', '        decimals = 18;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ---------------------------------------------------------allowance---------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from token owner&#39;s account to `to` account\n', '    // - Owner&#39;s account must have sufficient balance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account. The `spender` contract function\n', '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Don&#39;t accept ETH\n', '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// IGCoin\n', '// ----------------------------------------------------------------------------\n', 'contract IGCoin is DeaultERC20 {\n', '    using SafeMath for uint;\n', '\n', '    address public reserveAddress; // wei\n', '    uint256 public ask;\n', '    uint256 public bid;\n', '    uint16 public constant reserveRate = 10;\n', '    bool public initialSaleComplete;\n', '    uint256 constant private ICOAmount = 2e6*1e18; // in aToken\n', '    uint256 constant private ICOask = 1*1e18; // in wei per Token\n', '    uint256 constant private ICObid = 0; // in wei per Token\n', '    uint256 constant private InitialSupply = 1e6 * 1e18; // Number of tokens (aToken) minted when contract created\n', '    uint256 public debugVal;\n', '    uint256 public debugVal2;\n', '    uint256 public debugVal3;\n', '    uint256 public debugVal4;\n', '    uint256 constant private R = 12500000;  // matlab R=1.00000008, this R=1/(1.00000008-1)\n', '    uint256 constant private P = 50; // precision\n', '    uint256 constant private lnR = 12500001; // 1/ln(R)   (matlab R)\n', '    uint256 constant private S = 1e8; // s.t. S*R = integer\n', '    uint256 constant private RS = 8; // 1.00000008*S-S=8\n', '    uint256 constant private lnS = 18; // ln(S) = 18\n', '    \n', '    /* Constants to support ln() */\n', '    uint256 private constant ONE = 1;\n', '    uint32 private constant MAX_WETokenHT = 1000000;\n', '    uint8 private constant MIN_PRECISION = 32;\n', '    uint8 private constant MAX_PRECISION = 127;\n', '    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n', '    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n', '    uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\n', '    uint256 private constant FIXED_3 = 0x07fffffffffffffffffffffffffffffff;\n', '    uint256 private constant LN2_MANTISSA = 0x2c5c85fdf473de6af278ece600fcbda;\n', '    uint8   private constant LN2_EXPONENT = 122;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    event FrozenFunds(address target, bool frozen); \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "IG17";\n', '        name = "theTestToken001";\n', '        decimals = 18;\n', '        initialSaleComplete = false;\n', '        _totalSupply = InitialSupply;  // Keep track of all IG Coins created, ever\n', '        balances[owner] = _totalSupply;  // Give the creator all initial IG coins\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '\n', '        reserveAddress = new Contract("Reserve");  // Create contract to hold reserve\n', '        quoteAsk();\n', '        quoteBid();        \n', '    }\n', '\n', '    /// @notice Deposits &#39;_value&#39; in wei to the reserve address\n', '    /// @param _value The number of wei to be transferred to the \n', '    /// reserve address\n', '    function deposit(uint256 _value) private {\n', '        reserveAddress.transfer(_value);\n', '        balances[reserveAddress] += _value;\n', '    }\n', '  \n', '    /// @notice Withdraws &#39;_value&#39; in wei from the reserve address\n', '    /// @param _value The number of wei to be transferred from the \n', '    /// reserve address    \n', '    function withdraw(uint256 _value) private pure {\n', '        // TODO\n', '         _value = _value;\n', '    }\n', '    \n', '    /// @notice Transfers &#39;_value&#39; in wei to the &#39;_to&#39; address\n', '    /// @param _to The recipient address\n', '    /// @param _value The amount of wei to transfer\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        /* Check if sender has balance and for overflows */\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]);\n', '        \n', '        /* Check if amount is nonzero */\n', '        require(_value > 0);\n', '\n', '        /* Add and subtract new balances */\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '    \n', '        /* Notify anyone listening that this transfer took place */\n', '        emit Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice `freeze? Prevent | Allow` `target` from sending \n', '    /// & receiving tokens\n', '    /// @param _target Address to be frozen\n', '    /// @param _freeze either to freeze it or not\n', '    function freezeAccount(address _target, bool _freeze) public onlyOwner {\n', '        frozenAccount[_target] = _freeze;\n', '        emit FrozenFunds(_target, _freeze);\n', '    }    \n', ' \n', '    /// @notice Calculates the ask price in wei per aToken based on the \n', '    /// current reserve amount\n', '    /// @return Price of aToken in wei\n', '    function quoteAsk() public returns (uint256) {\n', '        if(initialSaleComplete)\n', '        {\n', '            ask = fracExp(1e18, R, (_totalSupply/1e18)+1, P);\n', '        }\n', '        else\n', '        {\n', '            ask = ICOask;\n', '        }\n', '\n', '        return ask;\n', '    }\n', '    \n', '    /// @notice Calculates the bid price in wei per aToken based on the \n', '    /// current reserve amount\n', '    /// @return Price of aToken in wei    \n', '    function quoteBid() public returns (uint256) {\n', '        if(initialSaleComplete)\n', '        {\n', '            bid = fracExp(1e18, R, (_totalSupply/1e18)-1, P);\n', '        }\n', '        else\n', '        {\n', '            bid = ICObid;\n', '        }\n', '\n', '        return bid;\n', '    }\n', '\n', '    /// @notice Buys aToken in exchnage for wei at the current ask price\n', '    /// @return refunds remainder of wei from purchase   \n', '    function buy() public payable returns (uint256 amount){\n', '        uint256 refund = 0;\n', '        debugVal = 0;\n', '        \n', '        if(initialSaleComplete)\n', '        {\n', '            uint256 units_to_buy = 0;\n', '\n', '            uint256 etherRemaining = msg.value;             // (wei)\n', '            uint256 etherToReserve = 0;                     // (wei)\n', '\n', '            debugVal = fracExp(S, R, (_totalSupply/1e18),P);\n', '            debugVal2 = RS*msg.value;\n', '            debugVal3 = RS*msg.value/1e18 + fracExp(S, R, (_totalSupply/1e18),P);\n', '            debugVal4 = (ln(debugVal3,1)-lnS);//*lnR-1;\n', '            units_to_buy = debugVal4;\n', '\n', '\n', '            reserveAddress.transfer(etherToReserve);        // send the ask amount to the reserve\n', '            mintToken(msg.sender, amount);                  // Mint the coin\n', '            refund = etherRemaining;\n', '            msg.sender.transfer(refund);                    // Issue refund            \n', '        }\n', '        else\n', '        {\n', '            // TODO don&#39;t sell more than the ICO amount if one transaction is huge\n', '            ask = ICOask;                                   // ICO sale price (wei/Token)\n', '            amount = 1e18*msg.value / ask;                  // calculates the amount of aToken (1e18*wei/(wei/Token))\n', '            refund = msg.value - (amount*ask/1e18);         // calculate refund (wei)\n', '\n', '            // TODO test for overflow attack\n', '            reserveAddress.transfer(msg.value - refund);    // send the full amount of the sale to reserve\n', '            msg.sender.transfer(refund);                    // Issue refund\n', '            balances[reserveAddress] += msg.value-refund;  // All other addresses hold Token Coin, reserveAddress represents ether\n', '            mintToken(msg.sender, amount);                  // Mint the coin (aToken)\n', '\n', '            if(_totalSupply >= ICOAmount)\n', '            {\n', '                initialSaleComplete = true;\n', '            }             \n', '        }\n', '        \n', '        \n', '        return amount;                                    // ends function and returns\n', '    }\n', '\n', '    /// @notice Sells aToken in exchnage for wei at the current bid \n', '    /// price, reduces resreve\n', '    /// @return Proceeds of wei from sale of aToken\n', '    function sell(uint amount) public returns (uint revenue){\n', '        require(initialSaleComplete);\n', '        require(balances[msg.sender] >= bid);            // checks if the sender has enough to sell\n', '        balances[reserveAddress] += amount;                        // adds the amount to owner&#39;s balance\n', '        balances[msg.sender] -= amount;                  // subtracts the amount from seller&#39;s balance\n', '        revenue = amount * bid;\n', '        require(msg.sender.send(revenue));                // sends ether to the seller: it&#39;s important to do this last to prevent recursion attacks\n', '        emit Transfer(msg.sender, reserveAddress, amount);               // executes an event reflecting on the change\n', '        return revenue;                                   // ends function and returns\n', '    }    \n', '    \n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) public {\n', '        balances[target] += mintedAmount;\n', '        _totalSupply += mintedAmount;\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }    \n', '    \n', '\n', '    /// @notice Compute &#39;_k * (1+1/_q) ^ _n&#39;, with precision &#39;_p&#39;\n', '    /// @dev The higher the precision, the higher the gas cost. It should be\n', '    /// something around the log of &#39;n&#39;. When &#39;p == n&#39;, the\n', '    /// precision is absolute (sans possible integer overflows).\n', '    /// Much smaller values are sufficient to get a great approximation.\n', '    /// @param _k input param k\n', '    /// @param _q input param q\n', '    /// @param _n input param n\n', '    /// @param _p input param p\n', '    /// @return &#39;_k * (1+1/_q) ^ _n&#39;   \n', '    function fracExp(uint256 _k, uint256 _q, uint256 _n, uint256 _p) public pure returns (uint256) {\n', '      uint256 s = 0;\n', '      uint256 N = 1;\n', '      uint256 B = 1;\n', '      for (uint256 i = 0; i < _p; ++i){\n', '        s += _k * N / B / (_q**i);\n', '        N  = N * (_n-i);\n', '        B  = B * (i+1);\n', '      }\n', '      return s;\n', '    }\n', '    \n', '    /// @notice Compute the natural logarithm\n', '    /// @dev This functions assumes that the numerator is larger than or equal \n', '    /// to the denominator, because the output would be negative otherwise.\n', '    /// @param _numerator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    /// @param _denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    /// @return is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\n', '    function ln(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\n', '        assert(_numerator <= MAX_NUM);\n', '\n', '        uint256 res = 0;\n', '        uint256 x = _numerator * FIXED_1 / _denominator;\n', '\n', '        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n', '        if (x >= FIXED_2) {\n', '            uint8 count = floorLog2(x / FIXED_1);\n', '            x >>= count; // now x < 2\n', '            res = count * FIXED_1;\n', '        }\n', '\n', '        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n', '        if (x > FIXED_1) {\n', '            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n', '                x = (x * x) / FIXED_1; // now 1 < x < 4\n', '                if (x >= FIXED_2) {\n', '                    x >>= 1; // now 1 < x < 2\n', '                    res += ONE << (i - 1);\n', '                }\n', '            }\n', '        }\n', '        \n', '        return ((res * LN2_MANTISSA) >> LN2_EXPONENT) / FIXED_3;\n', '    }\n', '\n', '    /// @notice Compute the largest integer smaller than or equal to \n', '    /// the binary logarithm of the input\n', '    /// @param _n Operand of the function\n', '    /// @return Floor(Log2(_n))\n', '    function floorLog2(uint256 _n) internal pure returns (uint8) {\n', '        uint8 res = 0;\n', '\n', '        if (_n < 256) {\n', '            // At most 8 iterations\n', '            while (_n > 1) {\n', '                _n >>= 1;\n', '                res += 1;\n', '            }\n', '        }\n', '        else {\n', '            // Exactly 8 iterations\n', '            for (uint8 s = 128; s > 0; s >>= 1) {\n', '                if (_n >= (ONE << s)) {\n', '                    _n >>= s;\n', '                    res |= s;\n', '                }\n', '            }\n', '        }\n', '\n', '        return res;\n', '    }    \n', '  \n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/// @title Contract class\n', '/// @author Infinigon Group\n', '/// @notice Contract class defines the name of the contract\n', 'contract Contract {\n', '    bytes32 public Name;\n', '\n', '    /// @notice Initializes contract with contract name\n', '    /// @param _contractName The name to be given to the contract\n', '    constructor(bytes32 _contractName) public {\n', '        Name = _contractName;\n', '    }\n', '\n', '    function() public payable { }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Default Token\n', '// ----------------------------------------------------------------------------\n', 'contract DeaultERC20 is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "DFLT";\n', '        name = "Default";\n', '        decimals = 18;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ---------------------------------------------------------allowance---------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// IGCoin\n', '// ----------------------------------------------------------------------------\n', 'contract IGCoin is DeaultERC20 {\n', '    using SafeMath for uint;\n', '\n', '    address public reserveAddress; // wei\n', '    uint256 public ask;\n', '    uint256 public bid;\n', '    uint16 public constant reserveRate = 10;\n', '    bool public initialSaleComplete;\n', '    uint256 constant private ICOAmount = 2e6*1e18; // in aToken\n', '    uint256 constant private ICOask = 1*1e18; // in wei per Token\n', '    uint256 constant private ICObid = 0; // in wei per Token\n', '    uint256 constant private InitialSupply = 1e6 * 1e18; // Number of tokens (aToken) minted when contract created\n', '    uint256 public debugVal;\n', '    uint256 public debugVal2;\n', '    uint256 public debugVal3;\n', '    uint256 public debugVal4;\n', '    uint256 constant private R = 12500000;  // matlab R=1.00000008, this R=1/(1.00000008-1)\n', '    uint256 constant private P = 50; // precision\n', '    uint256 constant private lnR = 12500001; // 1/ln(R)   (matlab R)\n', '    uint256 constant private S = 1e8; // s.t. S*R = integer\n', '    uint256 constant private RS = 8; // 1.00000008*S-S=8\n', '    uint256 constant private lnS = 18; // ln(S) = 18\n', '    \n', '    /* Constants to support ln() */\n', '    uint256 private constant ONE = 1;\n', '    uint32 private constant MAX_WETokenHT = 1000000;\n', '    uint8 private constant MIN_PRECISION = 32;\n', '    uint8 private constant MAX_PRECISION = 127;\n', '    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n', '    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n', '    uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\n', '    uint256 private constant FIXED_3 = 0x07fffffffffffffffffffffffffffffff;\n', '    uint256 private constant LN2_MANTISSA = 0x2c5c85fdf473de6af278ece600fcbda;\n', '    uint8   private constant LN2_EXPONENT = 122;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    event FrozenFunds(address target, bool frozen); \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "IG17";\n', '        name = "theTestToken001";\n', '        decimals = 18;\n', '        initialSaleComplete = false;\n', '        _totalSupply = InitialSupply;  // Keep track of all IG Coins created, ever\n', '        balances[owner] = _totalSupply;  // Give the creator all initial IG coins\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '\n', '        reserveAddress = new Contract("Reserve");  // Create contract to hold reserve\n', '        quoteAsk();\n', '        quoteBid();        \n', '    }\n', '\n', "    /// @notice Deposits '_value' in wei to the reserve address\n", '    /// @param _value The number of wei to be transferred to the \n', '    /// reserve address\n', '    function deposit(uint256 _value) private {\n', '        reserveAddress.transfer(_value);\n', '        balances[reserveAddress] += _value;\n', '    }\n', '  \n', "    /// @notice Withdraws '_value' in wei from the reserve address\n", '    /// @param _value The number of wei to be transferred from the \n', '    /// reserve address    \n', '    function withdraw(uint256 _value) private pure {\n', '        // TODO\n', '         _value = _value;\n', '    }\n', '    \n', "    /// @notice Transfers '_value' in wei to the '_to' address\n", '    /// @param _to The recipient address\n', '    /// @param _value The amount of wei to transfer\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        /* Check if sender has balance and for overflows */\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]);\n', '        \n', '        /* Check if amount is nonzero */\n', '        require(_value > 0);\n', '\n', '        /* Add and subtract new balances */\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '    \n', '        /* Notify anyone listening that this transfer took place */\n', '        emit Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice `freeze? Prevent | Allow` `target` from sending \n', '    /// & receiving tokens\n', '    /// @param _target Address to be frozen\n', '    /// @param _freeze either to freeze it or not\n', '    function freezeAccount(address _target, bool _freeze) public onlyOwner {\n', '        frozenAccount[_target] = _freeze;\n', '        emit FrozenFunds(_target, _freeze);\n', '    }    \n', ' \n', '    /// @notice Calculates the ask price in wei per aToken based on the \n', '    /// current reserve amount\n', '    /// @return Price of aToken in wei\n', '    function quoteAsk() public returns (uint256) {\n', '        if(initialSaleComplete)\n', '        {\n', '            ask = fracExp(1e18, R, (_totalSupply/1e18)+1, P);\n', '        }\n', '        else\n', '        {\n', '            ask = ICOask;\n', '        }\n', '\n', '        return ask;\n', '    }\n', '    \n', '    /// @notice Calculates the bid price in wei per aToken based on the \n', '    /// current reserve amount\n', '    /// @return Price of aToken in wei    \n', '    function quoteBid() public returns (uint256) {\n', '        if(initialSaleComplete)\n', '        {\n', '            bid = fracExp(1e18, R, (_totalSupply/1e18)-1, P);\n', '        }\n', '        else\n', '        {\n', '            bid = ICObid;\n', '        }\n', '\n', '        return bid;\n', '    }\n', '\n', '    /// @notice Buys aToken in exchnage for wei at the current ask price\n', '    /// @return refunds remainder of wei from purchase   \n', '    function buy() public payable returns (uint256 amount){\n', '        uint256 refund = 0;\n', '        debugVal = 0;\n', '        \n', '        if(initialSaleComplete)\n', '        {\n', '            uint256 units_to_buy = 0;\n', '\n', '            uint256 etherRemaining = msg.value;             // (wei)\n', '            uint256 etherToReserve = 0;                     // (wei)\n', '\n', '            debugVal = fracExp(S, R, (_totalSupply/1e18),P);\n', '            debugVal2 = RS*msg.value;\n', '            debugVal3 = RS*msg.value/1e18 + fracExp(S, R, (_totalSupply/1e18),P);\n', '            debugVal4 = (ln(debugVal3,1)-lnS);//*lnR-1;\n', '            units_to_buy = debugVal4;\n', '\n', '\n', '            reserveAddress.transfer(etherToReserve);        // send the ask amount to the reserve\n', '            mintToken(msg.sender, amount);                  // Mint the coin\n', '            refund = etherRemaining;\n', '            msg.sender.transfer(refund);                    // Issue refund            \n', '        }\n', '        else\n', '        {\n', "            // TODO don't sell more than the ICO amount if one transaction is huge\n", '            ask = ICOask;                                   // ICO sale price (wei/Token)\n', '            amount = 1e18*msg.value / ask;                  // calculates the amount of aToken (1e18*wei/(wei/Token))\n', '            refund = msg.value - (amount*ask/1e18);         // calculate refund (wei)\n', '\n', '            // TODO test for overflow attack\n', '            reserveAddress.transfer(msg.value - refund);    // send the full amount of the sale to reserve\n', '            msg.sender.transfer(refund);                    // Issue refund\n', '            balances[reserveAddress] += msg.value-refund;  // All other addresses hold Token Coin, reserveAddress represents ether\n', '            mintToken(msg.sender, amount);                  // Mint the coin (aToken)\n', '\n', '            if(_totalSupply >= ICOAmount)\n', '            {\n', '                initialSaleComplete = true;\n', '            }             \n', '        }\n', '        \n', '        \n', '        return amount;                                    // ends function and returns\n', '    }\n', '\n', '    /// @notice Sells aToken in exchnage for wei at the current bid \n', '    /// price, reduces resreve\n', '    /// @return Proceeds of wei from sale of aToken\n', '    function sell(uint amount) public returns (uint revenue){\n', '        require(initialSaleComplete);\n', '        require(balances[msg.sender] >= bid);            // checks if the sender has enough to sell\n', "        balances[reserveAddress] += amount;                        // adds the amount to owner's balance\n", "        balances[msg.sender] -= amount;                  // subtracts the amount from seller's balance\n", '        revenue = amount * bid;\n', "        require(msg.sender.send(revenue));                // sends ether to the seller: it's important to do this last to prevent recursion attacks\n", '        emit Transfer(msg.sender, reserveAddress, amount);               // executes an event reflecting on the change\n', '        return revenue;                                   // ends function and returns\n', '    }    \n', '    \n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) public {\n', '        balances[target] += mintedAmount;\n', '        _totalSupply += mintedAmount;\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }    \n', '    \n', '\n', "    /// @notice Compute '_k * (1+1/_q) ^ _n', with precision '_p'\n", '    /// @dev The higher the precision, the higher the gas cost. It should be\n', "    /// something around the log of 'n'. When 'p == n', the\n", '    /// precision is absolute (sans possible integer overflows).\n', '    /// Much smaller values are sufficient to get a great approximation.\n', '    /// @param _k input param k\n', '    /// @param _q input param q\n', '    /// @param _n input param n\n', '    /// @param _p input param p\n', "    /// @return '_k * (1+1/_q) ^ _n'   \n", '    function fracExp(uint256 _k, uint256 _q, uint256 _n, uint256 _p) public pure returns (uint256) {\n', '      uint256 s = 0;\n', '      uint256 N = 1;\n', '      uint256 B = 1;\n', '      for (uint256 i = 0; i < _p; ++i){\n', '        s += _k * N / B / (_q**i);\n', '        N  = N * (_n-i);\n', '        B  = B * (i+1);\n', '      }\n', '      return s;\n', '    }\n', '    \n', '    /// @notice Compute the natural logarithm\n', '    /// @dev This functions assumes that the numerator is larger than or equal \n', '    /// to the denominator, because the output would be negative otherwise.\n', '    /// @param _numerator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    /// @param _denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    /// @return is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\n', '    function ln(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\n', '        assert(_numerator <= MAX_NUM);\n', '\n', '        uint256 res = 0;\n', '        uint256 x = _numerator * FIXED_1 / _denominator;\n', '\n', '        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n', '        if (x >= FIXED_2) {\n', '            uint8 count = floorLog2(x / FIXED_1);\n', '            x >>= count; // now x < 2\n', '            res = count * FIXED_1;\n', '        }\n', '\n', '        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n', '        if (x > FIXED_1) {\n', '            for (uint8 i = MAX_PRECISION; i > 0; --i) {\n', '                x = (x * x) / FIXED_1; // now 1 < x < 4\n', '                if (x >= FIXED_2) {\n', '                    x >>= 1; // now 1 < x < 2\n', '                    res += ONE << (i - 1);\n', '                }\n', '            }\n', '        }\n', '        \n', '        return ((res * LN2_MANTISSA) >> LN2_EXPONENT) / FIXED_3;\n', '    }\n', '\n', '    /// @notice Compute the largest integer smaller than or equal to \n', '    /// the binary logarithm of the input\n', '    /// @param _n Operand of the function\n', '    /// @return Floor(Log2(_n))\n', '    function floorLog2(uint256 _n) internal pure returns (uint8) {\n', '        uint8 res = 0;\n', '\n', '        if (_n < 256) {\n', '            // At most 8 iterations\n', '            while (_n > 1) {\n', '                _n >>= 1;\n', '                res += 1;\n', '            }\n', '        }\n', '        else {\n', '            // Exactly 8 iterations\n', '            for (uint8 s = 128; s > 0; s >>= 1) {\n', '                if (_n >= (ONE << s)) {\n', '                    _n >>= s;\n', '                    res |= s;\n', '                }\n', '            }\n', '        }\n', '\n', '        return res;\n', '    }    \n', '  \n', '}']
