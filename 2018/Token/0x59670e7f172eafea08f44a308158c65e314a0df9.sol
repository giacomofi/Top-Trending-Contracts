['pragma solidity ^0.4.23;\n', '\n', 'contract PumpAndDump {\n', '\n', '  address owner;\n', '  uint newCoinFee = 0.005 ether;\n', '  uint newCoinFeeIncrease = 0.001 ether;\n', '  uint defaultCoinPrice = 0.001 ether;\n', '  uint coinPriceIncrease = 0.0001 ether;\n', '  uint devFees = 0;\n', '  uint16[] coinIds;\n', '\n', '  struct Coin {\n', '    bool exists;\n', '    string name;\n', '    uint price;\n', '    uint marketValue;\n', '    address[] investors;\n', '  }\n', '\n', '  mapping (uint16 => Coin) coins;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function kill() external {\n', '    require(msg.sender == owner);\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function getNewCoinFee() public constant returns (uint) {\n', '    return newCoinFee;\n', '  }\n', '\n', '  function isCoinIdUnique(uint16 newId) private constant returns (bool) {\n', '    for (uint i = 0; i < coinIds.length; i++) {\n', '      if (coinIds[i] == newId) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '\n', '  function createCoin(uint16 id, string name) public payable {\n', '    require(msg.value >= newCoinFee);\n', '    require(id < 17576); // 26*26*26\n', '    require(bytes(name).length > 0);\n', '    require(isCoinIdUnique(id));\n', '    devFees += msg.value - defaultCoinPrice;\n', '    coins[id].exists = true;\n', '    coins[id].name = name;\n', '    coins[id].price = defaultCoinPrice;\n', '    coins[id].marketValue = defaultCoinPrice;\n', '    coins[id].investors.push(msg.sender);\n', '    coinIds.push(id);\n', '    newCoinFee += newCoinFeeIncrease;\n', '  }\n', '\n', '  function getCoinIds() public view returns (uint16[]) {\n', '    return coinIds;\n', '  }\n', '\n', '  function getCoinInfoFromId(uint16 coinId) public view returns (string, uint, uint, address[]) {\n', '    return (\n', '      coins[coinId].name,\n', '      coins[coinId].price,\n', '      coins[coinId].marketValue,\n', '      coins[coinId].investors\n', '    );\n', '  }\n', '\n', '  function getUserCoinMarketValue(uint16 coinId, uint userIndex) private view returns (uint) {\n', '      uint numInvestors = coins[coinId].investors.length;\n', '      // If this is the most recent investor\n', '      if (numInvestors == userIndex + 1) {\n', '        return coins[coinId].price;\n', '      } else {\n', '        uint numShares = (numInvestors * (numInvestors + 1)) / 2;\n', '        return ((numInvestors - userIndex) * coins[coinId].marketValue) / numShares;\n', '      }\n', '  }\n', '\n', '  function isSenderInvestor(address sender, address[] investors) private pure returns (bool) {\n', '    for (uint i = 0; i < investors.length; i++) {\n', '      if (investors[i] == sender) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function buyCoin(uint16 coinId) public payable {\n', '    require(msg.value >= coins[coinId].price);\n', '    require(coins[coinId].exists);\n', '    require(!isSenderInvestor(msg.sender, coins[coinId].investors));\n', '    coins[coinId].investors.push(msg.sender);\n', '    uint amount = (msg.value * 99) / 100;\n', '    devFees += msg.value - amount;\n', '    coins[coinId].marketValue += amount;\n', '    coins[coinId].price += coinPriceIncrease;\n', '  }\n', '\n', '  function payAndRemoveInvestor(uint16 coinId, uint investorIndex) private {\n', '    uint value = getUserCoinMarketValue(coinId, investorIndex);\n', '    coins[coinId].investors[investorIndex].transfer(value);\n', '    coins[coinId].price -= coinPriceIncrease;\n', '    coins[coinId].marketValue -= value;\n', '    if (coins[coinId].investors.length == 1) {\n', '      delete coins[coinId].investors[0];\n', '    } else {\n', '      uint secondLastIndex = coins[coinId].investors.length - 1;\n', '      for (uint j = investorIndex; j < secondLastIndex; j++) {\n', '        coins[coinId].investors[j] = coins[coinId].investors[j - 1];\n', '      }\n', '    }\n', '    coins[coinId].investors.length -= 1;\n', '  }\n', '\n', '  function sellCoin(uint16 coinId) public {\n', '    bool senderIsInvestor = false;\n', '    uint investorIndex = 0;\n', '    require(coins[coinId].exists);\n', '    for (uint i = 0; i < coins[coinId].investors.length; i++) {\n', '      if (coins[coinId].investors[i] == msg.sender) {\n', '        senderIsInvestor = true;\n', '        investorIndex = i;\n', '        break;\n', '      }\n', '    }\n', '    require(senderIsInvestor);\n', '    payAndRemoveInvestor(coinId, investorIndex);\n', '  }\n', '\n', '  function getDevFees() public view returns (uint) {\n', '    require(msg.sender == owner);\n', '    return devFees;\n', '  }\n', '\n', '  function collectDevFees() public {\n', '    require(msg.sender == owner);\n', '    owner.transfer(devFees);\n', '    devFees = 0;\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract PumpAndDump {\n', '\n', '  address owner;\n', '  uint newCoinFee = 0.005 ether;\n', '  uint newCoinFeeIncrease = 0.001 ether;\n', '  uint defaultCoinPrice = 0.001 ether;\n', '  uint coinPriceIncrease = 0.0001 ether;\n', '  uint devFees = 0;\n', '  uint16[] coinIds;\n', '\n', '  struct Coin {\n', '    bool exists;\n', '    string name;\n', '    uint price;\n', '    uint marketValue;\n', '    address[] investors;\n', '  }\n', '\n', '  mapping (uint16 => Coin) coins;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function kill() external {\n', '    require(msg.sender == owner);\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function getNewCoinFee() public constant returns (uint) {\n', '    return newCoinFee;\n', '  }\n', '\n', '  function isCoinIdUnique(uint16 newId) private constant returns (bool) {\n', '    for (uint i = 0; i < coinIds.length; i++) {\n', '      if (coinIds[i] == newId) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '\n', '  function createCoin(uint16 id, string name) public payable {\n', '    require(msg.value >= newCoinFee);\n', '    require(id < 17576); // 26*26*26\n', '    require(bytes(name).length > 0);\n', '    require(isCoinIdUnique(id));\n', '    devFees += msg.value - defaultCoinPrice;\n', '    coins[id].exists = true;\n', '    coins[id].name = name;\n', '    coins[id].price = defaultCoinPrice;\n', '    coins[id].marketValue = defaultCoinPrice;\n', '    coins[id].investors.push(msg.sender);\n', '    coinIds.push(id);\n', '    newCoinFee += newCoinFeeIncrease;\n', '  }\n', '\n', '  function getCoinIds() public view returns (uint16[]) {\n', '    return coinIds;\n', '  }\n', '\n', '  function getCoinInfoFromId(uint16 coinId) public view returns (string, uint, uint, address[]) {\n', '    return (\n', '      coins[coinId].name,\n', '      coins[coinId].price,\n', '      coins[coinId].marketValue,\n', '      coins[coinId].investors\n', '    );\n', '  }\n', '\n', '  function getUserCoinMarketValue(uint16 coinId, uint userIndex) private view returns (uint) {\n', '      uint numInvestors = coins[coinId].investors.length;\n', '      // If this is the most recent investor\n', '      if (numInvestors == userIndex + 1) {\n', '        return coins[coinId].price;\n', '      } else {\n', '        uint numShares = (numInvestors * (numInvestors + 1)) / 2;\n', '        return ((numInvestors - userIndex) * coins[coinId].marketValue) / numShares;\n', '      }\n', '  }\n', '\n', '  function isSenderInvestor(address sender, address[] investors) private pure returns (bool) {\n', '    for (uint i = 0; i < investors.length; i++) {\n', '      if (investors[i] == sender) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function buyCoin(uint16 coinId) public payable {\n', '    require(msg.value >= coins[coinId].price);\n', '    require(coins[coinId].exists);\n', '    require(!isSenderInvestor(msg.sender, coins[coinId].investors));\n', '    coins[coinId].investors.push(msg.sender);\n', '    uint amount = (msg.value * 99) / 100;\n', '    devFees += msg.value - amount;\n', '    coins[coinId].marketValue += amount;\n', '    coins[coinId].price += coinPriceIncrease;\n', '  }\n', '\n', '  function payAndRemoveInvestor(uint16 coinId, uint investorIndex) private {\n', '    uint value = getUserCoinMarketValue(coinId, investorIndex);\n', '    coins[coinId].investors[investorIndex].transfer(value);\n', '    coins[coinId].price -= coinPriceIncrease;\n', '    coins[coinId].marketValue -= value;\n', '    if (coins[coinId].investors.length == 1) {\n', '      delete coins[coinId].investors[0];\n', '    } else {\n', '      uint secondLastIndex = coins[coinId].investors.length - 1;\n', '      for (uint j = investorIndex; j < secondLastIndex; j++) {\n', '        coins[coinId].investors[j] = coins[coinId].investors[j - 1];\n', '      }\n', '    }\n', '    coins[coinId].investors.length -= 1;\n', '  }\n', '\n', '  function sellCoin(uint16 coinId) public {\n', '    bool senderIsInvestor = false;\n', '    uint investorIndex = 0;\n', '    require(coins[coinId].exists);\n', '    for (uint i = 0; i < coins[coinId].investors.length; i++) {\n', '      if (coins[coinId].investors[i] == msg.sender) {\n', '        senderIsInvestor = true;\n', '        investorIndex = i;\n', '        break;\n', '      }\n', '    }\n', '    require(senderIsInvestor);\n', '    payAndRemoveInvestor(coinId, investorIndex);\n', '  }\n', '\n', '  function getDevFees() public view returns (uint) {\n', '    require(msg.sender == owner);\n', '    return devFees;\n', '  }\n', '\n', '  function collectDevFees() public {\n', '    require(msg.sender == owner);\n', '    owner.transfer(devFees);\n', '    devFees = 0;\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '}']
