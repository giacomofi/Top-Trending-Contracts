['/*\n', '\n', '  Copyright 2018 Dexdex.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function safeMul(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract Members is Ownable {\n', '\n', '  mapping(address => bool) public members; // Mappings of addresses of allowed addresses\n', '\n', '  modifier onlyMembers() {\n', '    require(isValidMember(msg.sender));\n', '    _;\n', '  }\n', '\n', '  /// @dev Check if an address is a valid member.\n', '  function isValidMember(address _member) public view returns(bool) {\n', '    return members[_member];\n', '  }\n', '\n', '  /// @dev Add a valid member address. Only owner.\n', '  function addMember(address _member) public onlyOwner {\n', '    members[_member] = true;\n', '  }\n', '\n', '  /// @dev Remove a member address. Only owner.\n', '  function removeMember(address _member) public onlyOwner {\n', '    delete members[_member];\n', '  }\n', '}\n', '\n', 'contract IFeeWallet {\n', '\n', '  function getFee(\n', '    uint amount) public view returns(uint);\n', '\n', '  function collect(\n', '    address _affiliate) public payable;\n', '}\n', '\n', 'contract FeeWallet is IFeeWallet, Ownable, Members {\n', '\n', '  address public serviceAccount; // Address of service account\n', '  uint public servicePercentage; // Percentage times (1 ether)\n', '  uint public affiliatePercentage; // Percentage times (1 ether)\n', '\n', '  mapping (address => uint) public pendingWithdrawals; // Balances\n', '\n', '  function FeeWallet(\n', '    address _serviceAccount,\n', '    uint _servicePercentage,\n', '    uint _affiliatePercentage) public\n', '  {\n', '    serviceAccount = _serviceAccount;\n', '    servicePercentage = _servicePercentage;\n', '    affiliatePercentage = _affiliatePercentage;\n', '  }\n', '\n', '  /// @dev Set the new service account. Only owner.\n', '  function changeServiceAccount(address _serviceAccount) public onlyOwner {\n', '    serviceAccount = _serviceAccount;\n', '  }\n', '\n', '  /// @dev Set the service percentage. Only owner.\n', '  function changeServicePercentage(uint _servicePercentage) public onlyOwner {\n', '    servicePercentage = _servicePercentage;\n', '  }\n', '\n', '  /// @dev Set the affiliate percentage. Only owner.\n', '  function changeAffiliatePercentage(uint _affiliatePercentage) public onlyOwner {\n', '    affiliatePercentage = _affiliatePercentage;\n', '  }\n', '\n', '  /// @dev Calculates the service fee for a specific amount. Only owner.\n', '  function getFee(uint amount) public view returns(uint)  {\n', '    return SafeMath.safeMul(amount, servicePercentage) / (1 ether);\n', '  }\n', '\n', '  /// @dev Calculates the affiliate amount for a specific amount. Only owner.\n', '  function getAffiliateAmount(uint amount) public view returns(uint)  {\n', '    return SafeMath.safeMul(amount, affiliatePercentage) / (1 ether);\n', '  }\n', '\n', '  /// @dev Collects fees according to last payment receivedi. Only valid smart contracts.\n', '  function collect(\n', '    address _affiliate) public payable onlyMembers\n', '  {\n', '    if(_affiliate == address(0))\n', '      pendingWithdrawals[serviceAccount] += msg.value;\n', '    else {\n', '      uint affiliateAmount = getAffiliateAmount(msg.value);\n', '      pendingWithdrawals[_affiliate] += affiliateAmount;\n', '      pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value, affiliateAmount);\n', '    }\n', '  }\n', '\n', '  /// @dev Withdraw.\n', '  function withdraw() public {\n', '    uint amount = pendingWithdrawals[msg.sender];\n', '    pendingWithdrawals[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '}']
['/*\n', '\n', '  Copyright 2018 Dexdex.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function safeMul(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract Members is Ownable {\n', '\n', '  mapping(address => bool) public members; // Mappings of addresses of allowed addresses\n', '\n', '  modifier onlyMembers() {\n', '    require(isValidMember(msg.sender));\n', '    _;\n', '  }\n', '\n', '  /// @dev Check if an address is a valid member.\n', '  function isValidMember(address _member) public view returns(bool) {\n', '    return members[_member];\n', '  }\n', '\n', '  /// @dev Add a valid member address. Only owner.\n', '  function addMember(address _member) public onlyOwner {\n', '    members[_member] = true;\n', '  }\n', '\n', '  /// @dev Remove a member address. Only owner.\n', '  function removeMember(address _member) public onlyOwner {\n', '    delete members[_member];\n', '  }\n', '}\n', '\n', 'contract IFeeWallet {\n', '\n', '  function getFee(\n', '    uint amount) public view returns(uint);\n', '\n', '  function collect(\n', '    address _affiliate) public payable;\n', '}\n', '\n', 'contract FeeWallet is IFeeWallet, Ownable, Members {\n', '\n', '  address public serviceAccount; // Address of service account\n', '  uint public servicePercentage; // Percentage times (1 ether)\n', '  uint public affiliatePercentage; // Percentage times (1 ether)\n', '\n', '  mapping (address => uint) public pendingWithdrawals; // Balances\n', '\n', '  function FeeWallet(\n', '    address _serviceAccount,\n', '    uint _servicePercentage,\n', '    uint _affiliatePercentage) public\n', '  {\n', '    serviceAccount = _serviceAccount;\n', '    servicePercentage = _servicePercentage;\n', '    affiliatePercentage = _affiliatePercentage;\n', '  }\n', '\n', '  /// @dev Set the new service account. Only owner.\n', '  function changeServiceAccount(address _serviceAccount) public onlyOwner {\n', '    serviceAccount = _serviceAccount;\n', '  }\n', '\n', '  /// @dev Set the service percentage. Only owner.\n', '  function changeServicePercentage(uint _servicePercentage) public onlyOwner {\n', '    servicePercentage = _servicePercentage;\n', '  }\n', '\n', '  /// @dev Set the affiliate percentage. Only owner.\n', '  function changeAffiliatePercentage(uint _affiliatePercentage) public onlyOwner {\n', '    affiliatePercentage = _affiliatePercentage;\n', '  }\n', '\n', '  /// @dev Calculates the service fee for a specific amount. Only owner.\n', '  function getFee(uint amount) public view returns(uint)  {\n', '    return SafeMath.safeMul(amount, servicePercentage) / (1 ether);\n', '  }\n', '\n', '  /// @dev Calculates the affiliate amount for a specific amount. Only owner.\n', '  function getAffiliateAmount(uint amount) public view returns(uint)  {\n', '    return SafeMath.safeMul(amount, affiliatePercentage) / (1 ether);\n', '  }\n', '\n', '  /// @dev Collects fees according to last payment receivedi. Only valid smart contracts.\n', '  function collect(\n', '    address _affiliate) public payable onlyMembers\n', '  {\n', '    if(_affiliate == address(0))\n', '      pendingWithdrawals[serviceAccount] += msg.value;\n', '    else {\n', '      uint affiliateAmount = getAffiliateAmount(msg.value);\n', '      pendingWithdrawals[_affiliate] += affiliateAmount;\n', '      pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value, affiliateAmount);\n', '    }\n', '  }\n', '\n', '  /// @dev Withdraw.\n', '  function withdraw() public {\n', '    uint amount = pendingWithdrawals[msg.sender];\n', '    pendingWithdrawals[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '}']
