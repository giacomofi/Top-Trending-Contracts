['pragma solidity ^0.4.13;\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed _from,\n', '        address indexed _to\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract DataeumToken is Owned, ERC20Interface {\n', '    // Adding safe calculation methods to uint256\n', '    using SafeMath for uint256;\n', '\n', '    // Defining balances mapping (ERC20)\n', '    mapping(address => uint256) balances;\n', '\n', '    // Defining allowances mapping (ERC20)\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    // Defining addresses allowed to bypass global freeze\n', '    mapping(address => bool) public freezeBypassing;\n', '\n', '    // Defining addresses that have custom lockups periods\n', '    mapping(address => uint256) public lockupExpirations;\n', '\n', '    // Token Symbol\n', '    string public constant symbol = "XDT";\n', '\n', '    // Token Name\n', '    string public constant name = "Dataeum Token";\n', '\n', '    // Token Decimals\n', '    uint8 public constant decimals = 18;\n', '\n', '    // Current distributed supply\n', '    uint256 public circulatingSupply = 0;\n', '\n', '    // global freeze one-way toggle\n', '    bool public tradingLive = false;\n', '\n', '    // Total supply of token\n', '    uint256 public totalSupply;\n', '\n', '    /**\n', '     * @notice Event for Lockup period applied to address\n', '     * @param owner Specific lockup address target\n', '     * @param until Timestamp when lockup end (seconds since epoch)\n', '     */\n', '    event LockupApplied(\n', '        address indexed owner,\n', '        uint256 until\n', '    );\n', '\n', '    /**\n', '     * @notice Contract constructor\n', '     * @param _totalSupply Total supply of token wanted\n', '     */\n', '    constructor(uint256 _totalSupply) public {\n', '        totalSupply = _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @notice distribute tokens to an address\n', '     * @param to Who will receive the token\n', '     * @param tokens How much token will be sent\n', '     */\n', '    function distribute(\n', '        address to,\n', '        uint256 tokens\n', '    )\n', '        public onlyOwner\n', '    {\n', '        uint newCirculatingSupply = circulatingSupply.add(tokens);\n', '        require(newCirculatingSupply <= totalSupply);\n', '        circulatingSupply = newCirculatingSupply;\n', '        balances[to] = balances[to].add(tokens);\n', '\n', '        emit Transfer(address(this), to, tokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Prevents the given wallet to transfer its token for the given duration.\n', '     *      This methods resets the lock duration if one is already in place.\n', '     * @param wallet The wallet address to lock\n', '     * @param duration How much time is the token locked from now (in sec)\n', '     */\n', '    function lockup(\n', '        address wallet,\n', '        uint256 duration\n', '    )\n', '        public onlyOwner\n', '    {\n', '        uint256 lockupExpiration = duration.add(now);\n', '        lockupExpirations[wallet] = lockupExpiration;\n', '        emit LockupApplied(wallet, lockupExpiration);\n', '    }\n', '\n', '    /**\n', '     * @notice choose if an address is allowed to bypass the global freeze\n', '     * @param to Target of the freeze bypass status update\n', '     * @param status New status (if true will bypass)\n', '     */\n', '    function setBypassStatus(\n', '        address to,\n', '        bool status\n', '    )\n', '        public onlyOwner\n', '    {\n', '        freezeBypassing[to] = status;\n', '    }\n', '\n', '    /**\n', '     * @notice One-way toggle to allow trading (remove global freeze)\n', '     */\n', '    function setTradingLive() public onlyOwner {\n', '        tradingLive = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Modifier that checks if the conditions are met for a token to be\n', '     * tradable. To be so, it must :\n', '     *  - Global Freeze must be removed, or, "from" must be allowed to bypass it\n', '     *  - "from" must not be in a custom lockup period\n', '     * @param from Who to check the status\n', '     */\n', '    modifier tradable(address from) {\n', '        require(\n', '            (tradingLive || freezeBypassing[from]) && //solium-disable-line indentation\n', '            (lockupExpirations[from] <= now)\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total supply of the token\n', '     * @dev This function is part of the ERC20 standard \n', '     * @return {"supply": "The token supply"}\n', '     */\n', '    function totalSupply() public view returns (uint256 supply) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token balance of `owner`\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param owner The wallet to get the balance of\n', '     * @return {"balance": "The balance of `owner`"}\n', '     */\n', '    function balanceOf(\n', '        address owner\n', '    )\n', '        public view returns (uint256 balance)\n', '    {\n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers `amount` from msg.sender to `destination`\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param destination The address that receives the tokens\n', '     * @param amount Token amount to transfer\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function transfer(\n', '        address destination,\n', '        uint256 amount\n', '    )\n', '        public tradable(msg.sender) returns (bool success)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        balances[destination] = balances[destination].add(amount);\n', '        emit Transfer(msg.sender, destination, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer tokens from an address to another one\n', '     * through an allowance made before\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param from The address that sends the tokens\n', '     * @param to The address that receives the tokens\n', '     * @param tokenAmount Token amount to transfer\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenAmount\n', '    )\n', '        public tradable(from) returns (bool success)\n', '    {\n', '        balances[from] = balances[from].sub(tokenAmount);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokenAmount);\n', '        balances[to] = balances[to].add(tokenAmount);\n', '        emit Transfer(from, to, tokenAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Approve an address to send `tokenAmount` tokens to `msg.sender` (make an allowance)\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param spender The allowed address\n', '     * @param tokenAmount The maximum amount allowed to spend\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function approve(\n', '        address spender,\n', '        uint256 tokenAmount\n', '    )\n', '        public returns (bool success)\n', '    {\n', '        allowed[msg.sender][spender] = tokenAmount;\n', '        emit Approval(msg.sender, spender, tokenAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the remaining allowance for a spender on a given address\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param tokenOwner The address that owns the tokens\n', '     * @param spender The spender\n', '     * @return {"remaining": "The amount of tokens remaining in the allowance"}\n', '     */\n', '    function allowance(\n', '        address tokenOwner,\n', '        address spender\n', '    )\n', '        public view returns (uint256 remaining)\n', '    {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Permits to create an approval on a contract and then call a method\n', '     * on the approved contract right away.\n', '     * @param spender The allowed address\n', '     * @param tokenAmount The maximum amount allowed to spend\n', '     * @param data The data sent back as parameter to the contract (bytes array)\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function approveAndCall(\n', '        address spender,\n', '        uint256 tokenAmount,\n', '        bytes data\n', '    )\n', '        public tradable(spender) returns (bool success)\n', '    {\n', '        allowed[msg.sender][spender] = tokenAmount;\n', '        emit Approval(msg.sender, spender, tokenAmount);\n', '\n', '        ApproveAndCallFallBack(spender)\n', '            .receiveApproval(msg.sender, tokenAmount, this, data);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract\n', '     * @param tokenAddress The received ERC20 token address\n', '     * @param tokenAmount The amount of ERC20 tokens to withdraw from this contract\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function withdrawERC20Token(\n', '        address tokenAddress,\n', '        uint256 tokenAmount\n', '    )\n', '        public onlyOwner returns (bool success)\n', '    {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokenAmount);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @notice Adds two numbers, throws on overflow.\n', '    */\n', '    function add(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256 c)\n', '    {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @notice Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed _from,\n', '        address indexed _to\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract DataeumToken is Owned, ERC20Interface {\n', '    // Adding safe calculation methods to uint256\n', '    using SafeMath for uint256;\n', '\n', '    // Defining balances mapping (ERC20)\n', '    mapping(address => uint256) balances;\n', '\n', '    // Defining allowances mapping (ERC20)\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    // Defining addresses allowed to bypass global freeze\n', '    mapping(address => bool) public freezeBypassing;\n', '\n', '    // Defining addresses that have custom lockups periods\n', '    mapping(address => uint256) public lockupExpirations;\n', '\n', '    // Token Symbol\n', '    string public constant symbol = "XDT";\n', '\n', '    // Token Name\n', '    string public constant name = "Dataeum Token";\n', '\n', '    // Token Decimals\n', '    uint8 public constant decimals = 18;\n', '\n', '    // Current distributed supply\n', '    uint256 public circulatingSupply = 0;\n', '\n', '    // global freeze one-way toggle\n', '    bool public tradingLive = false;\n', '\n', '    // Total supply of token\n', '    uint256 public totalSupply;\n', '\n', '    /**\n', '     * @notice Event for Lockup period applied to address\n', '     * @param owner Specific lockup address target\n', '     * @param until Timestamp when lockup end (seconds since epoch)\n', '     */\n', '    event LockupApplied(\n', '        address indexed owner,\n', '        uint256 until\n', '    );\n', '\n', '    /**\n', '     * @notice Contract constructor\n', '     * @param _totalSupply Total supply of token wanted\n', '     */\n', '    constructor(uint256 _totalSupply) public {\n', '        totalSupply = _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @notice distribute tokens to an address\n', '     * @param to Who will receive the token\n', '     * @param tokens How much token will be sent\n', '     */\n', '    function distribute(\n', '        address to,\n', '        uint256 tokens\n', '    )\n', '        public onlyOwner\n', '    {\n', '        uint newCirculatingSupply = circulatingSupply.add(tokens);\n', '        require(newCirculatingSupply <= totalSupply);\n', '        circulatingSupply = newCirculatingSupply;\n', '        balances[to] = balances[to].add(tokens);\n', '\n', '        emit Transfer(address(this), to, tokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Prevents the given wallet to transfer its token for the given duration.\n', '     *      This methods resets the lock duration if one is already in place.\n', '     * @param wallet The wallet address to lock\n', '     * @param duration How much time is the token locked from now (in sec)\n', '     */\n', '    function lockup(\n', '        address wallet,\n', '        uint256 duration\n', '    )\n', '        public onlyOwner\n', '    {\n', '        uint256 lockupExpiration = duration.add(now);\n', '        lockupExpirations[wallet] = lockupExpiration;\n', '        emit LockupApplied(wallet, lockupExpiration);\n', '    }\n', '\n', '    /**\n', '     * @notice choose if an address is allowed to bypass the global freeze\n', '     * @param to Target of the freeze bypass status update\n', '     * @param status New status (if true will bypass)\n', '     */\n', '    function setBypassStatus(\n', '        address to,\n', '        bool status\n', '    )\n', '        public onlyOwner\n', '    {\n', '        freezeBypassing[to] = status;\n', '    }\n', '\n', '    /**\n', '     * @notice One-way toggle to allow trading (remove global freeze)\n', '     */\n', '    function setTradingLive() public onlyOwner {\n', '        tradingLive = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Modifier that checks if the conditions are met for a token to be\n', '     * tradable. To be so, it must :\n', '     *  - Global Freeze must be removed, or, "from" must be allowed to bypass it\n', '     *  - "from" must not be in a custom lockup period\n', '     * @param from Who to check the status\n', '     */\n', '    modifier tradable(address from) {\n', '        require(\n', '            (tradingLive || freezeBypassing[from]) && //solium-disable-line indentation\n', '            (lockupExpirations[from] <= now)\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the total supply of the token\n', '     * @dev This function is part of the ERC20 standard \n', '     * @return {"supply": "The token supply"}\n', '     */\n', '    function totalSupply() public view returns (uint256 supply) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token balance of `owner`\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param owner The wallet to get the balance of\n', '     * @return {"balance": "The balance of `owner`"}\n', '     */\n', '    function balanceOf(\n', '        address owner\n', '    )\n', '        public view returns (uint256 balance)\n', '    {\n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers `amount` from msg.sender to `destination`\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param destination The address that receives the tokens\n', '     * @param amount Token amount to transfer\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function transfer(\n', '        address destination,\n', '        uint256 amount\n', '    )\n', '        public tradable(msg.sender) returns (bool success)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        balances[destination] = balances[destination].add(amount);\n', '        emit Transfer(msg.sender, destination, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer tokens from an address to another one\n', '     * through an allowance made before\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param from The address that sends the tokens\n', '     * @param to The address that receives the tokens\n', '     * @param tokenAmount Token amount to transfer\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenAmount\n', '    )\n', '        public tradable(from) returns (bool success)\n', '    {\n', '        balances[from] = balances[from].sub(tokenAmount);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokenAmount);\n', '        balances[to] = balances[to].add(tokenAmount);\n', '        emit Transfer(from, to, tokenAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Approve an address to send `tokenAmount` tokens to `msg.sender` (make an allowance)\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param spender The allowed address\n', '     * @param tokenAmount The maximum amount allowed to spend\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function approve(\n', '        address spender,\n', '        uint256 tokenAmount\n', '    )\n', '        public returns (bool success)\n', '    {\n', '        allowed[msg.sender][spender] = tokenAmount;\n', '        emit Approval(msg.sender, spender, tokenAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the remaining allowance for a spender on a given address\n', '     * @dev This function is part of the ERC20 standard\n', '     * @param tokenOwner The address that owns the tokens\n', '     * @param spender The spender\n', '     * @return {"remaining": "The amount of tokens remaining in the allowance"}\n', '     */\n', '    function allowance(\n', '        address tokenOwner,\n', '        address spender\n', '    )\n', '        public view returns (uint256 remaining)\n', '    {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Permits to create an approval on a contract and then call a method\n', '     * on the approved contract right away.\n', '     * @param spender The allowed address\n', '     * @param tokenAmount The maximum amount allowed to spend\n', '     * @param data The data sent back as parameter to the contract (bytes array)\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function approveAndCall(\n', '        address spender,\n', '        uint256 tokenAmount,\n', '        bytes data\n', '    )\n', '        public tradable(spender) returns (bool success)\n', '    {\n', '        allowed[msg.sender][spender] = tokenAmount;\n', '        emit Approval(msg.sender, spender, tokenAmount);\n', '\n', '        ApproveAndCallFallBack(spender)\n', '            .receiveApproval(msg.sender, tokenAmount, this, data);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract\n', '     * @param tokenAddress The received ERC20 token address\n', '     * @param tokenAmount The amount of ERC20 tokens to withdraw from this contract\n', '     * @return {"success": "If the operation completed successfuly"}\n', '     */\n', '    function withdrawERC20Token(\n', '        address tokenAddress,\n', '        uint256 tokenAmount\n', '    )\n', '        public onlyOwner returns (bool success)\n', '    {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokenAmount);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '    * @notice Adds two numbers, throws on overflow.\n', '    */\n', '    function add(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256 c)\n', '    {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @notice Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '}']
