['pragma solidity ^0.4.17;\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an address access to this role\n', '     */\n', '    function add(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address&#39; access to this role\n', '     */\n', '    function remove(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an address has this role\n', '     * // reverts\n', '     */\n', '    function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '    {\n', '        require(has(role, addr));\n', '    }\n', '\n', '    /**\n', '     * @dev check if an address has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return role.bearer[addr];\n', '    }\n', '}\n', '\n', 'contract RBAC {\n', '    using Roles for Roles.Role;\n', '\n', '    mapping (string => Roles.Role) private roles;\n', '\n', '    event RoleAdded(address addr, string roleName);\n', '    event RoleRemoved(address addr, string roleName);\n', '\n', '    /**\n', '     * @dev reverts if addr does not have role\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     * // reverts\n', '     */\n', '    function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '    {\n', '        roles[roleName].check(addr);\n', '    }\n', '\n', '    /**\n', '     * @dev determine if addr has role\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     * @return bool\n', '     */\n', '    function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '    {\n', '        return roles[roleName].has(addr);\n', '    }\n', '\n', '    /**\n', '     * @dev add a role to an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function addRole(address addr, string roleName)\n', '    internal\n', '    {\n', '        roles[roleName].add(addr);\n', '        emit RoleAdded(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev remove a role from an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function removeRole(address addr, string roleName)\n', '    internal\n', '    {\n', '        roles[roleName].remove(addr);\n', '        emit RoleRemoved(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '     * @param roleName the name of the role\n', '     * // reverts\n', '     */\n', '    modifier onlyRole(string roleName)\n', '    {\n', '        checkRole(msg.sender, roleName);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '     * @param roleNames the names of the roles to scope access to\n', '     * // reverts\n', '     *\n', '     * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '     *  see: https://github.com/ethereum/solidity/issues/2467\n', '     */\n', '    // modifier onlyRoles(string[] roleNames) {\n', '    //     bool hasAnyRole = false;\n', '    //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '    //         if (hasRole(msg.sender, roleNames[i])) {\n', '    //             hasAnyRole = true;\n', '    //             break;\n', '    //         }\n', '    //     }\n', '\n', '    //     require(hasAnyRole);\n', '\n', '    //     _;\n', '    // }\n', '}\n', '\n', 'contract RBACWithAdmin is RBAC {\n', '    /**\n', '     * A constant role name for indicating admins.\n', '     */\n', '    string public constant ROLE_ADMIN = "admin";\n', '\n', '    /**\n', '     * @dev modifier to scope access to admins\n', '     * // reverts\n', '     */\n', '    modifier onlyAdmin()\n', '    {\n', '        checkRole(msg.sender, ROLE_ADMIN);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev constructor. Sets msg.sender as admin by default\n', '     */\n', '    function RBACWithAdmin()\n', '    public\n', '    {\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '\n', '    /**\n', '     * @dev add a role to an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '    {\n', '        addRole(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev remove a role from an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '    {\n', '        removeRole(addr, roleName);\n', '    }\n', '}\n', '\n', 'contract NbtToken is StandardToken, Ownable, RBACWithAdmin {\n', '\n', '    /*** EVENTS ***/\n', '\n', '    event ExchangeableTokensInc(address indexed from, uint256 amount);\n', '    event ExchangeableTokensDec(address indexed to, uint256 amount);\n', '\n', '    event CirculatingTokensInc(address indexed from, uint256 amount);\n', '    event CirculatingTokensDec(address indexed to, uint256 amount);\n', '\n', '    event SaleableTokensInc(address indexed from, uint256 amount);\n', '    event SaleableTokensDec(address indexed to, uint256 amount);\n', '\n', '    event StockTokensInc(address indexed from, uint256 amount);\n', '    event StockTokensDec(address indexed to, uint256 amount);\n', '\n', '    event BbAddressUpdated(address indexed ethereum_address, string bb_address);\n', '\n', '    /*** CONSTANTS ***/\n', '\n', '    string public name = &#39;NiceBytes&#39;;\n', '    string public symbol = &#39;NBT&#39;;\n', '\n', '    uint256 public decimals = 8;\n', '\n', '    uint256 public INITIAL_SUPPLY = 10000000000 * 10**decimals; // One time total supply\n', '    uint256 public AIRDROP_START_AT = 1525780800; // May 8, 12:00 UTC\n', '    uint256 public AIRDROPS_COUNT = 82;\n', '    uint256 public AIRDROPS_PERIOD = 86400;\n', '    uint256 public CIRCULATING_BASE = 2000000000 * 10**decimals;\n', '    uint256 public MAX_AIRDROP_VOLUME = 2; // %\n', '    uint256 public INITIAL_EXCHANGEABLE_TOKENS_VOLUME = 1200000000 * 10**decimals;\n', '    uint256 public MAX_AIRDROP_TOKENS = 8000000000 * 10**decimals; // 8 billions\n', '    uint256 public MAX_SALE_VOLUME = 800000000 * 10**decimals;\n', '    uint256 public EXCHANGE_COMMISSION = 200 * 10**decimals; // NBT\n', '    uint256 public MIN_TOKENS_TO_EXCHANGE = 1000 * 10**decimals; // should be bigger than EXCHANGE_COMMISSION\n', '    uint256 public EXCHANGE_RATE = 1000;\n', '    string constant ROLE_EXCHANGER = "exchanger";\n', '\n', '\n', '    /*** STORAGE ***/\n', '\n', '    uint256 public exchangeableTokens;\n', '    uint256 public exchangeableTokensFromSale;\n', '    uint256 public exchangeableTokensFromStock;\n', '    uint256 public circulatingTokens;\n', '    uint256 public circulatingTokensFromSale;\n', '    uint256 public saleableTokens;\n', '    uint256 public stockTokens;\n', '    address public crowdsale;\n', '    address public exchange_commission_wallet;\n', '\n', '    mapping(address => uint256) exchangeBalances;\n', '    mapping(address => string) bbAddresses;\n', '\n', '    /*** MODIFIERS ***/\n', '\n', '    modifier onlyAdminOrExchanger()\n', '    {\n', '        require(\n', '            hasRole(msg.sender, ROLE_ADMIN) ||\n', '            hasRole(msg.sender, ROLE_EXCHANGER)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyCrowdsale()\n', '    {\n', '        require(\n', '            address(msg.sender) == address(crowdsale)\n', '        );\n', '        _;\n', '    }\n', '\n', '    /*** CONSTRUCTOR ***/\n', '\n', '    function NbtToken() public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[this] = INITIAL_SUPPLY;\n', '        stockTokens = INITIAL_SUPPLY;\n', '        emit StockTokensInc(address(0), INITIAL_SUPPLY);\n', '        addRole(msg.sender, ROLE_EXCHANGER);\n', '    }\n', '\n', '    /*** PUBLIC AND EXTERNAL FUNCTIONS ***/\n', '\n', '    /*** getters  ***/\n', '\n', '    function getBbAddress(address _addr) public view returns (string _bbAddress) {\n', '        return bbAddresses[_addr];\n', '    }\n', '\n', '    function howMuchTokensAvailableForExchangeFromStock() public view returns (uint256) {\n', '        uint256 _volume = INITIAL_EXCHANGEABLE_TOKENS_VOLUME;\n', '        uint256 _airdrops = 0;\n', '\n', '        if (now > AIRDROP_START_AT) {\n', '            _airdrops = (now.sub(AIRDROP_START_AT)).div(AIRDROPS_PERIOD);\n', '            _airdrops = _airdrops.add(1);\n', '        }\n', '\n', '        if (_airdrops > AIRDROPS_COUNT) {\n', '            _airdrops = AIRDROPS_COUNT;\n', '        }\n', '\n', '        uint256 _from_airdrops = 0;\n', '        uint256 _base = CIRCULATING_BASE;\n', '        for (uint256 i = 1; i <= _airdrops; i++) {\n', '            _from_airdrops = _from_airdrops.add(_base.mul(MAX_AIRDROP_VOLUME).div(100));\n', '            _base = _base.add(_base.mul(MAX_AIRDROP_VOLUME).div(100));\n', '        }\n', '        if (_from_airdrops > MAX_AIRDROP_TOKENS) {\n', '            _from_airdrops = MAX_AIRDROP_TOKENS;\n', '        }\n', '\n', '        _volume = _volume.add(_from_airdrops);\n', '\n', '        return _volume;\n', '    }\n', '\n', '    /*** setters  ***/\n', '\n', '    function setBbAddress(string _bbAddress) public returns (bool) {\n', '        bbAddresses[msg.sender] = _bbAddress;\n', '        emit BbAddressUpdated(msg.sender, _bbAddress);\n', '        return true;\n', '    }\n', '\n', '    function setCrowdsaleAddress(address _addr) onlyAdmin public returns (bool) {\n', '        require(_addr != address(0) && _addr != address(this));\n', '        crowdsale = _addr;\n', '        return true;\n', '    }\n', '\n', '    function setExchangeCommissionAddress(address _addr) onlyAdmin public returns (bool) {\n', '        require(_addr != address(0) && _addr != address(this));\n', '        exchange_commission_wallet = _addr;\n', '        return true;\n', '    }\n', '\n', '    /*** sale methods  ***/\n', '\n', '    // For balancing of the sale limit between two networks\n', '    function moveTokensFromSaleToExchange(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= balances[crowdsale]);\n', '        balances[crowdsale] = balances[crowdsale].sub(_amount);\n', '        saleableTokens = saleableTokens.sub(_amount);\n', '        exchangeableTokensFromSale = exchangeableTokensFromSale.add(_amount);\n', '        balances[address(this)] = balances[address(this)].add(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        emit SaleableTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(address(crowdsale), _amount);\n', '        return true;\n', '    }\n', '\n', '    function moveTokensFromSaleToCirculating(address _to, uint256 _amount) onlyCrowdsale public returns (bool) {\n', '        saleableTokens = saleableTokens.sub(_amount);\n', '        circulatingTokensFromSale = circulatingTokensFromSale.add(_amount) ;\n', '        circulatingTokens = circulatingTokens.add(_amount) ;\n', '        emit SaleableTokensDec(_to, _amount);\n', '        emit CirculatingTokensInc(address(crowdsale), _amount);\n', '        return true;\n', '    }\n', '\n', '    /*** stock methods  ***/\n', '\n', '    function moveTokensFromStockToExchange(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= stockTokens);\n', '        require(exchangeableTokensFromStock + _amount <= howMuchTokensAvailableForExchangeFromStock());\n', '        stockTokens = stockTokens.sub(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        exchangeableTokensFromStock = exchangeableTokensFromStock.add(_amount);\n', '        emit StockTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    function moveTokensFromStockToSale(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(crowdsale != address(0) && crowdsale != address(this));\n', '        require(_amount <= stockTokens);\n', '        require(_amount + exchangeableTokensFromSale + saleableTokens + circulatingTokensFromSale <= MAX_SALE_VOLUME);\n', '\n', '        stockTokens = stockTokens.sub(_amount);\n', '        saleableTokens = saleableTokens.add(_amount);\n', '        balances[address(this)] = balances[address(this)].sub(_amount);\n', '        balances[crowdsale] = balances[crowdsale].add(_amount);\n', '\n', '        emit Transfer(address(this), crowdsale, _amount);\n', '        emit StockTokensDec(address(crowdsale), _amount);\n', '        emit SaleableTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    /*** exchange methods  ***/\n', '\n', '    function getTokensFromExchange(address _to, uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= exchangeableTokens);\n', '        require(_amount <= balances[address(this)]);\n', '\n', '        exchangeableTokens = exchangeableTokens.sub(_amount);\n', '        circulatingTokens = circulatingTokens.add(_amount);\n', '\n', '        balances[address(this)] = balances[address(this)].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        emit Transfer(address(this), _to, _amount);\n', '        emit ExchangeableTokensDec(_to, _amount);\n', '        emit CirculatingTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    function sendTokensToExchange(uint256 _amount) public returns (bool) {\n', '        require(_amount <= balances[msg.sender]);\n', '        require(_amount >= MIN_TOKENS_TO_EXCHANGE);\n', '        require(!stringsEqual(bbAddresses[msg.sender], &#39;&#39;));\n', '        require(exchange_commission_wallet != address(0) && exchange_commission_wallet != address(this));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount); // ! before sub(_commission)\n', '\n', '        uint256 _commission = EXCHANGE_COMMISSION + _amount % EXCHANGE_RATE;\n', '        _amount = _amount.sub(_commission);\n', '\n', '        circulatingTokens = circulatingTokens.sub(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        exchangeBalances[msg.sender] = exchangeBalances[msg.sender].add(_amount);\n', '\n', '        balances[address(this)] = balances[address(this)].add(_amount);\n', '        balances[exchange_commission_wallet] = balances[exchange_commission_wallet].add(_commission);\n', '\n', '        emit Transfer(msg.sender, address(exchange_commission_wallet), _commission);\n', '        emit Transfer(msg.sender, address(this), _amount);\n', '        emit CirculatingTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function exchangeBalanceOf(address _addr) public view returns (uint256 _tokens) {\n', '        return exchangeBalances[_addr];\n', '    }\n', '\n', '    function decExchangeBalanceOf(address _addr, uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require (exchangeBalances[_addr] > 0);\n', '        require (exchangeBalances[_addr] >= _amount);\n', '        exchangeBalances[_addr] = exchangeBalances[_addr].sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    /*** INTERNAL FUNCTIONS ***/\n', '\n', '    function stringsEqual(string storage _a, string memory _b) internal view returns (bool) {\n', '        bytes storage a = bytes(_a);\n', '        bytes memory b = bytes(_b);\n', '        if (a.length != b.length)\n', '            return false;\n', '        for (uint256 i = 0; i < a.length; i ++)\n', '            if (a[i] != b[i])\n', '                return false;\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    /**\n', '    * @dev total number of tokens in existence\n', '    */\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     *\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an address access to this role\n', '     */\n', '    function add(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an address' access to this role\n", '     */\n', '    function remove(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an address has this role\n', '     * // reverts\n', '     */\n', '    function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '    {\n', '        require(has(role, addr));\n', '    }\n', '\n', '    /**\n', '     * @dev check if an address has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return role.bearer[addr];\n', '    }\n', '}\n', '\n', 'contract RBAC {\n', '    using Roles for Roles.Role;\n', '\n', '    mapping (string => Roles.Role) private roles;\n', '\n', '    event RoleAdded(address addr, string roleName);\n', '    event RoleRemoved(address addr, string roleName);\n', '\n', '    /**\n', '     * @dev reverts if addr does not have role\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     * // reverts\n', '     */\n', '    function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '    {\n', '        roles[roleName].check(addr);\n', '    }\n', '\n', '    /**\n', '     * @dev determine if addr has role\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     * @return bool\n', '     */\n', '    function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '    {\n', '        return roles[roleName].has(addr);\n', '    }\n', '\n', '    /**\n', '     * @dev add a role to an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function addRole(address addr, string roleName)\n', '    internal\n', '    {\n', '        roles[roleName].add(addr);\n', '        emit RoleAdded(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev remove a role from an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function removeRole(address addr, string roleName)\n', '    internal\n', '    {\n', '        roles[roleName].remove(addr);\n', '        emit RoleRemoved(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '     * @param roleName the name of the role\n', '     * // reverts\n', '     */\n', '    modifier onlyRole(string roleName)\n', '    {\n', '        checkRole(msg.sender, roleName);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '     * @param roleNames the names of the roles to scope access to\n', '     * // reverts\n', '     *\n', '     * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '     *  see: https://github.com/ethereum/solidity/issues/2467\n', '     */\n', '    // modifier onlyRoles(string[] roleNames) {\n', '    //     bool hasAnyRole = false;\n', '    //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '    //         if (hasRole(msg.sender, roleNames[i])) {\n', '    //             hasAnyRole = true;\n', '    //             break;\n', '    //         }\n', '    //     }\n', '\n', '    //     require(hasAnyRole);\n', '\n', '    //     _;\n', '    // }\n', '}\n', '\n', 'contract RBACWithAdmin is RBAC {\n', '    /**\n', '     * A constant role name for indicating admins.\n', '     */\n', '    string public constant ROLE_ADMIN = "admin";\n', '\n', '    /**\n', '     * @dev modifier to scope access to admins\n', '     * // reverts\n', '     */\n', '    modifier onlyAdmin()\n', '    {\n', '        checkRole(msg.sender, ROLE_ADMIN);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev constructor. Sets msg.sender as admin by default\n', '     */\n', '    function RBACWithAdmin()\n', '    public\n', '    {\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '    }\n', '\n', '    /**\n', '     * @dev add a role to an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '    {\n', '        addRole(addr, roleName);\n', '    }\n', '\n', '    /**\n', '     * @dev remove a role from an address\n', '     * @param addr address\n', '     * @param roleName the name of the role\n', '     */\n', '    function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '    {\n', '        removeRole(addr, roleName);\n', '    }\n', '}\n', '\n', 'contract NbtToken is StandardToken, Ownable, RBACWithAdmin {\n', '\n', '    /*** EVENTS ***/\n', '\n', '    event ExchangeableTokensInc(address indexed from, uint256 amount);\n', '    event ExchangeableTokensDec(address indexed to, uint256 amount);\n', '\n', '    event CirculatingTokensInc(address indexed from, uint256 amount);\n', '    event CirculatingTokensDec(address indexed to, uint256 amount);\n', '\n', '    event SaleableTokensInc(address indexed from, uint256 amount);\n', '    event SaleableTokensDec(address indexed to, uint256 amount);\n', '\n', '    event StockTokensInc(address indexed from, uint256 amount);\n', '    event StockTokensDec(address indexed to, uint256 amount);\n', '\n', '    event BbAddressUpdated(address indexed ethereum_address, string bb_address);\n', '\n', '    /*** CONSTANTS ***/\n', '\n', "    string public name = 'NiceBytes';\n", "    string public symbol = 'NBT';\n", '\n', '    uint256 public decimals = 8;\n', '\n', '    uint256 public INITIAL_SUPPLY = 10000000000 * 10**decimals; // One time total supply\n', '    uint256 public AIRDROP_START_AT = 1525780800; // May 8, 12:00 UTC\n', '    uint256 public AIRDROPS_COUNT = 82;\n', '    uint256 public AIRDROPS_PERIOD = 86400;\n', '    uint256 public CIRCULATING_BASE = 2000000000 * 10**decimals;\n', '    uint256 public MAX_AIRDROP_VOLUME = 2; // %\n', '    uint256 public INITIAL_EXCHANGEABLE_TOKENS_VOLUME = 1200000000 * 10**decimals;\n', '    uint256 public MAX_AIRDROP_TOKENS = 8000000000 * 10**decimals; // 8 billions\n', '    uint256 public MAX_SALE_VOLUME = 800000000 * 10**decimals;\n', '    uint256 public EXCHANGE_COMMISSION = 200 * 10**decimals; // NBT\n', '    uint256 public MIN_TOKENS_TO_EXCHANGE = 1000 * 10**decimals; // should be bigger than EXCHANGE_COMMISSION\n', '    uint256 public EXCHANGE_RATE = 1000;\n', '    string constant ROLE_EXCHANGER = "exchanger";\n', '\n', '\n', '    /*** STORAGE ***/\n', '\n', '    uint256 public exchangeableTokens;\n', '    uint256 public exchangeableTokensFromSale;\n', '    uint256 public exchangeableTokensFromStock;\n', '    uint256 public circulatingTokens;\n', '    uint256 public circulatingTokensFromSale;\n', '    uint256 public saleableTokens;\n', '    uint256 public stockTokens;\n', '    address public crowdsale;\n', '    address public exchange_commission_wallet;\n', '\n', '    mapping(address => uint256) exchangeBalances;\n', '    mapping(address => string) bbAddresses;\n', '\n', '    /*** MODIFIERS ***/\n', '\n', '    modifier onlyAdminOrExchanger()\n', '    {\n', '        require(\n', '            hasRole(msg.sender, ROLE_ADMIN) ||\n', '            hasRole(msg.sender, ROLE_EXCHANGER)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyCrowdsale()\n', '    {\n', '        require(\n', '            address(msg.sender) == address(crowdsale)\n', '        );\n', '        _;\n', '    }\n', '\n', '    /*** CONSTRUCTOR ***/\n', '\n', '    function NbtToken() public {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[this] = INITIAL_SUPPLY;\n', '        stockTokens = INITIAL_SUPPLY;\n', '        emit StockTokensInc(address(0), INITIAL_SUPPLY);\n', '        addRole(msg.sender, ROLE_EXCHANGER);\n', '    }\n', '\n', '    /*** PUBLIC AND EXTERNAL FUNCTIONS ***/\n', '\n', '    /*** getters  ***/\n', '\n', '    function getBbAddress(address _addr) public view returns (string _bbAddress) {\n', '        return bbAddresses[_addr];\n', '    }\n', '\n', '    function howMuchTokensAvailableForExchangeFromStock() public view returns (uint256) {\n', '        uint256 _volume = INITIAL_EXCHANGEABLE_TOKENS_VOLUME;\n', '        uint256 _airdrops = 0;\n', '\n', '        if (now > AIRDROP_START_AT) {\n', '            _airdrops = (now.sub(AIRDROP_START_AT)).div(AIRDROPS_PERIOD);\n', '            _airdrops = _airdrops.add(1);\n', '        }\n', '\n', '        if (_airdrops > AIRDROPS_COUNT) {\n', '            _airdrops = AIRDROPS_COUNT;\n', '        }\n', '\n', '        uint256 _from_airdrops = 0;\n', '        uint256 _base = CIRCULATING_BASE;\n', '        for (uint256 i = 1; i <= _airdrops; i++) {\n', '            _from_airdrops = _from_airdrops.add(_base.mul(MAX_AIRDROP_VOLUME).div(100));\n', '            _base = _base.add(_base.mul(MAX_AIRDROP_VOLUME).div(100));\n', '        }\n', '        if (_from_airdrops > MAX_AIRDROP_TOKENS) {\n', '            _from_airdrops = MAX_AIRDROP_TOKENS;\n', '        }\n', '\n', '        _volume = _volume.add(_from_airdrops);\n', '\n', '        return _volume;\n', '    }\n', '\n', '    /*** setters  ***/\n', '\n', '    function setBbAddress(string _bbAddress) public returns (bool) {\n', '        bbAddresses[msg.sender] = _bbAddress;\n', '        emit BbAddressUpdated(msg.sender, _bbAddress);\n', '        return true;\n', '    }\n', '\n', '    function setCrowdsaleAddress(address _addr) onlyAdmin public returns (bool) {\n', '        require(_addr != address(0) && _addr != address(this));\n', '        crowdsale = _addr;\n', '        return true;\n', '    }\n', '\n', '    function setExchangeCommissionAddress(address _addr) onlyAdmin public returns (bool) {\n', '        require(_addr != address(0) && _addr != address(this));\n', '        exchange_commission_wallet = _addr;\n', '        return true;\n', '    }\n', '\n', '    /*** sale methods  ***/\n', '\n', '    // For balancing of the sale limit between two networks\n', '    function moveTokensFromSaleToExchange(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= balances[crowdsale]);\n', '        balances[crowdsale] = balances[crowdsale].sub(_amount);\n', '        saleableTokens = saleableTokens.sub(_amount);\n', '        exchangeableTokensFromSale = exchangeableTokensFromSale.add(_amount);\n', '        balances[address(this)] = balances[address(this)].add(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        emit SaleableTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(address(crowdsale), _amount);\n', '        return true;\n', '    }\n', '\n', '    function moveTokensFromSaleToCirculating(address _to, uint256 _amount) onlyCrowdsale public returns (bool) {\n', '        saleableTokens = saleableTokens.sub(_amount);\n', '        circulatingTokensFromSale = circulatingTokensFromSale.add(_amount) ;\n', '        circulatingTokens = circulatingTokens.add(_amount) ;\n', '        emit SaleableTokensDec(_to, _amount);\n', '        emit CirculatingTokensInc(address(crowdsale), _amount);\n', '        return true;\n', '    }\n', '\n', '    /*** stock methods  ***/\n', '\n', '    function moveTokensFromStockToExchange(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= stockTokens);\n', '        require(exchangeableTokensFromStock + _amount <= howMuchTokensAvailableForExchangeFromStock());\n', '        stockTokens = stockTokens.sub(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        exchangeableTokensFromStock = exchangeableTokensFromStock.add(_amount);\n', '        emit StockTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    function moveTokensFromStockToSale(uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(crowdsale != address(0) && crowdsale != address(this));\n', '        require(_amount <= stockTokens);\n', '        require(_amount + exchangeableTokensFromSale + saleableTokens + circulatingTokensFromSale <= MAX_SALE_VOLUME);\n', '\n', '        stockTokens = stockTokens.sub(_amount);\n', '        saleableTokens = saleableTokens.add(_amount);\n', '        balances[address(this)] = balances[address(this)].sub(_amount);\n', '        balances[crowdsale] = balances[crowdsale].add(_amount);\n', '\n', '        emit Transfer(address(this), crowdsale, _amount);\n', '        emit StockTokensDec(address(crowdsale), _amount);\n', '        emit SaleableTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    /*** exchange methods  ***/\n', '\n', '    function getTokensFromExchange(address _to, uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require(_amount <= exchangeableTokens);\n', '        require(_amount <= balances[address(this)]);\n', '\n', '        exchangeableTokens = exchangeableTokens.sub(_amount);\n', '        circulatingTokens = circulatingTokens.add(_amount);\n', '\n', '        balances[address(this)] = balances[address(this)].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        emit Transfer(address(this), _to, _amount);\n', '        emit ExchangeableTokensDec(_to, _amount);\n', '        emit CirculatingTokensInc(address(this), _amount);\n', '        return true;\n', '    }\n', '\n', '    function sendTokensToExchange(uint256 _amount) public returns (bool) {\n', '        require(_amount <= balances[msg.sender]);\n', '        require(_amount >= MIN_TOKENS_TO_EXCHANGE);\n', "        require(!stringsEqual(bbAddresses[msg.sender], ''));\n", '        require(exchange_commission_wallet != address(0) && exchange_commission_wallet != address(this));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount); // ! before sub(_commission)\n', '\n', '        uint256 _commission = EXCHANGE_COMMISSION + _amount % EXCHANGE_RATE;\n', '        _amount = _amount.sub(_commission);\n', '\n', '        circulatingTokens = circulatingTokens.sub(_amount);\n', '        exchangeableTokens = exchangeableTokens.add(_amount);\n', '        exchangeBalances[msg.sender] = exchangeBalances[msg.sender].add(_amount);\n', '\n', '        balances[address(this)] = balances[address(this)].add(_amount);\n', '        balances[exchange_commission_wallet] = balances[exchange_commission_wallet].add(_commission);\n', '\n', '        emit Transfer(msg.sender, address(exchange_commission_wallet), _commission);\n', '        emit Transfer(msg.sender, address(this), _amount);\n', '        emit CirculatingTokensDec(address(this), _amount);\n', '        emit ExchangeableTokensInc(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function exchangeBalanceOf(address _addr) public view returns (uint256 _tokens) {\n', '        return exchangeBalances[_addr];\n', '    }\n', '\n', '    function decExchangeBalanceOf(address _addr, uint256 _amount) onlyAdminOrExchanger public returns (bool) {\n', '        require (exchangeBalances[_addr] > 0);\n', '        require (exchangeBalances[_addr] >= _amount);\n', '        exchangeBalances[_addr] = exchangeBalances[_addr].sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    /*** INTERNAL FUNCTIONS ***/\n', '\n', '    function stringsEqual(string storage _a, string memory _b) internal view returns (bool) {\n', '        bytes storage a = bytes(_a);\n', '        bytes memory b = bytes(_b);\n', '        if (a.length != b.length)\n', '            return false;\n', '        for (uint256 i = 0; i < a.length; i ++)\n', '            if (a[i] != b[i])\n', '                return false;\n', '        return true;\n', '    }\n', '}']
