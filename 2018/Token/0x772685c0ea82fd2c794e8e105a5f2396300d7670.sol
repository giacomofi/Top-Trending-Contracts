['/*\n', 'file:   TestyTestTest.sol\n', 'ver:    0.0.1_deploy\n', 'author: peter godbolt\n', 'date:   15-Mar-2018\n', 'email:  peter AT TestyTest.tech\n', '(c) Peter Godbolt, based on the fine work of Darryl Morris 2018, 2017\n', '\n', 'Testing of an ERC20 Token, backed by a regulated financial product in Australia. Nice.\n', '\n', 'License\n', '-------\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '\n', 'Release Notes\n', '-------------\n', '* way we go\n', '\n', 'Dedications\n', '-------------\n', '* to Tom Waits, Taylor Swift and Jo Jo Siwa\n', '*/\n', '\n', '\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', 'contract TestyTestConfig\n', '{\n', '    // ERC20 token name\n', '    string  public constant name            = "TESTY";\n', '\n', '    // ERC20 trading symbol\n', '    string  public constant symbol          = "TST";\n', '\n', '    // Contract owner at time of deployment.\n', '    address public constant OWNER           = 0x8579A678Fc76cAe308ca280B58E2b8f2ddD41913;\n', '\n', '    // Opening Supply\n', '    uint    public constant TOTAL_TOKENS    = 100;\n', '\n', '    // ERC20 decimal places\n', '    uint8   public constant decimals        = 18;\n', '\n', '\n', '}\n', '\n', '\n', 'library SafeMath\n', '{\n', '    // a add to b\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '    }\n', '\n', '    // a subtract b\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        c = a - b;\n', '        assert(c <= a);\n', '    }\n', '\n', '    // a multiplied by b\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '    }\n', '\n', '    // a divided by b\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        assert(b != 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ReentryProtected\n', '{\n', '    // The reentry protection state mutex.\n', '    bool __reMutex;\n', '\n', '    // Sets and clears mutex in order to block function reentry\n', '    modifier preventReentry() {\n', '        require(!__reMutex);\n', '        __reMutex = true;\n', '        _;\n', '        delete __reMutex;\n', '    }\n', '\n', '    // Blocks function entry if mutex is set\n', '    modifier noReentry() {\n', '        require(!__reMutex);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Token\n', '{\n', '    using SafeMath for uint;\n', '\n', '/* Constants */\n', '\n', '    // none\n', '\n', '/* State variable */\n', '\n', '    /// @return The Total supply of tokens\n', '    uint public totalSupply;\n', '\n', '    /// @return Tokens owned by an address\n', '    mapping (address => uint) balances;\n', '\n', '    /// @return Tokens spendable by a thridparty\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '/* Events */\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _amount);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _amount) is called.\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount);\n', '\n', '/* Modifiers */\n', '\n', '    // none\n', '\n', '/* Functions */\n', '\n', '    // Using an explicit getter allows for function overloading\n', '    function balanceOf(address _addr)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return balances[_addr];\n', '    }\n', '\n', '    // Quick checker on total supply\n', '    function currentSupply()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return totalSupply;\n', '    }\n', '\n', '    // Using an explicit getter allows for function overloading\n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        constant\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        return xfer(msg.sender, _to, _amount);\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_amount <= allowed[_from][msg.sender]);\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        return xfer(_from, _to, _amount);\n', '    }\n', '\n', '    // Process a transfer internally.\n', '    function xfer(address _from, address _to, uint _amount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        require(_amount <= balances[_from]);\n', '\n', '        emit Transfer(_from, _to, _amount);\n', '\n', '        // avoid wasting gas on 0 token transfers\n', '        if(_amount == 0) return true;\n', '\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to]   = balances[_to].add(_amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Approves a third-party spender\n', '    function approve(address _spender, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract TestyTestAbstract\n', '{\n', '\n', '    /// @dev Logged when new owner accepts ownership\n', '    /// @param _from the old owner address\n', '    /// @param _to the new owner address\n', '    event ChangedOwner(address indexed _from, address indexed _to);\n', '\n', '    /// @dev Logged when owner initiates a change of ownership\n', '    /// @param _to the new owner address\n', '    event ChangeOwnerTo(address indexed _to);\n', '\n', '    /// @dev Logged KYC against an address\n', '    /// @param _addr Address to set or clear KYC flag\n', '    /// @param _kyc A boolean flag\n', '    event Kyc(address indexed _addr, bool _kyc);\n', '\n', '// State Variables\n', '//\n', '\n', '    /// @dev An address permissioned to enact owner restricted functions\n', '    /// @return owner\n', '    address public owner;\n', '\n', '    /// @dev An address permissioned to take ownership of the contract\n', '    /// @return new owner address\n', '    address public newOwner;\n', '\n', '    /// @returns KYC flag for an address\n', '    mapping (address => bool) public clearedKyc;\n', '\n', '//\n', '// Modifiers\n', '//\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '//\n', '// Function Abstracts\n', '//\n', '\n', '\n', '    /// @notice Clear the KYC flags for an array of addresses to allow tokens\n', '    /// transfers\n', '    function clearKyc(address[] _addrs) public returns (bool);\n', '\n', '    /// @notice Make bulk transfer of tokens to many addresses\n', '    /// @param _addrs An array of recipient addresses\n', '    /// @param _amounts An array of amounts to transfer to respective addresses\n', '    /// @return Boolean success value\n', '    function transferToMany(address[] _addrs, uint[] _amounts)\n', '        public returns (bool);\n', '\n', '    /// @notice Salvage `_amount` tokens at `_kaddr` and send them to `_to`\n', '    /// @param _kAddr An ERC20 contract address\n', '    /// @param _to and address to send tokens\n', '    /// @param _amount The number of tokens to transfer\n', '    /// @return Boolean success value\n', '    function transferExternalToken(address _kAddr, address _to, uint _amount)\n', '        public returns (bool);\n', '}\n', '\n', '\n', '/*-----------------------------------------------------------------------------\\\n', '\n', 'TestyTest implementation\n', '\n', '\\*----------------------------------------------------------------------------*/\n', '\n', 'contract TestyTest is\n', '    ReentryProtected,\n', '    ERC20Token,\n', '    TestyTestAbstract,\n', '    TestyTestConfig\n', '{\n', '    using SafeMath for uint;\n', '\n', '//\n', '// Constants\n', '//\n', '\n', '    // Token fixed point for decimal places\n', '    uint constant TOKEN = uint(10)**decimals;\n', '\n', '\n', '//\n', '// Functions\n', '//\n', '\n', '    function TestyTest()\n', '        public\n', '    {\n', '\n', '        owner = OWNER;\n', '        totalSupply = TOTAL_TOKENS.mul(TOKEN);\n', '\n', '    }\n', '\n', '    // Default function.\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        // empty, could do stuff\n', '    }\n', '\n', '\n', '//\n', '// Manage supply\n', '//\n', '\n', 'event LowerSupply(address indexed burner, uint256 value);\n', 'event IncreaseSupply(address indexed burner, uint256 value);\n', '\n', '    /**\n', '     * @dev lowers the supply by a specified amount of tokens.\n', '     * @param _value The amount of tokens to lower the supply by.\n', '     */\n', '\n', '    function lowerSupply(uint256 _value)\n', '        public\n', '        onlyOwner\n', '        preventReentry() {\n', '            require(_value > 0);\n', '            address burner = 0x41CaE184095c5DAEeC5B2b2901D156a029B3dAC6;\n', '            balances[burner] = balances[burner].sub(_value);\n', '            totalSupply = totalSupply.sub(_value);\n', '            emit LowerSupply(msg.sender, _value);\n', '    }\n', '\n', '    function increaseSupply(uint256 _value)\n', '        public\n', '        onlyOwner\n', '        preventReentry() {\n', '            require(_value > 0);\n', '            totalSupply = totalSupply.add(_value);\n', '            emit IncreaseSupply(msg.sender, _value);\n', '    }\n', '\n', '//\n', '//  clear KYC onchain\n', '//\n', '\n', '    function clearKyc(address[] _addrs)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint len = _addrs.length;\n', '        for(uint i; i < len; i++) {\n', '            clearedKyc[_addrs[i]] = true;\n', '            emit Kyc(_addrs[i], true);\n', '        }\n', '        return true;\n', '    }\n', '\n', '//\n', '//  re-instate KYC onchain, should circumstances change\n', '//\n', '\n', '    function requireKyc(address[] _addrs)\n', '        public\n', '        noReentry\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint len = _addrs.length;\n', '        for(uint i; i < len; i++) {\n', '            delete clearedKyc[_addrs[i]];\n', '            emit Kyc(_addrs[i], false);\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '//\n', '// ERC20 additional functions\n', '//\n', '\n', '    // Allows a sender to transfer tokens to an array of recipients\n', '    function transferToMany(address[] _addrs, uint[] _amounts)\n', '        public\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        require(_addrs.length == _amounts.length);\n', '        uint len = _addrs.length;\n', '        for(uint i = 0; i < len; i++) {\n', '            xfer(msg.sender, _addrs[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '   // Overload placeholder - could apply further logic\n', '    function xfer(address _from, address _to, uint _amount)\n', '        internal\n', '        noReentry\n', '        returns (bool)\n', '    {\n', '        super.xfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '//\n', '// Contract management functions\n', '//\n', '\n', '    // Initiate a change of owner to `_owner`\n', '    function changeOwner(address _owner)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        emit ChangeOwnerTo(_owner);\n', '        newOwner = _owner;\n', '        return true;\n', '    }\n', '\n', '    // Finalise change of ownership to newOwner\n', '    function acceptOwnership()\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(msg.sender == newOwner);\n', '        emit ChangedOwner(owner, msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '        return true;\n', '    }\n', '\n', '\n', '    // Owner can salvage ERC20 tokens that may have been sent to the account\n', '    function transferExternalToken(address _kAddr, address _to, uint _amount)\n', '        public\n', '        onlyOwner\n', '        preventReentry\n', '        returns (bool)\n', '    {\n', '        require(ERC20Token(_kAddr).transfer(_to, _amount));\n', '        return true;\n', '    }\n', '\n', '\n', '}']