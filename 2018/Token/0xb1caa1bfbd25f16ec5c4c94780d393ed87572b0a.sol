['pragma solidity ^0.4.16;\n', '\n', 'contract EthereumPrivate{\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    string public name = "EthereumPrivate";\n', '    string public symbol = "PETH";\n', '    uint256 public max_supply = 18000000000000;\n', '    uint256 public unspent_supply = 0;\n', '    uint256 public spendable_supply = 0;\n', '    uint256 public circulating_supply = 0;\n', '    uint256 public decimals = 6;\n', '    uint256 public reward = 50000000;\n', '    uint256 public timeOfLastHalving = now;\n', '    uint public timeOfLastIncrease = now;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Mint(address indexed from, uint256 value);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function howCoin() public {\n', '      timeOfLastHalving = now;\n', '    }\n', '\n', '    function updateSupply() internal returns (uint256) {\n', '\n', '      if (now - timeOfLastHalving >= 2100000 minutes) {\n', '        reward /= 2;\n', '        timeOfLastHalving = now;\n', '      }\n', '\n', '      if (now - timeOfLastIncrease >= 150 seconds) {\n', '        uint256 increaseAmount = ((now - timeOfLastIncrease) / 150 seconds) * reward;\n', '        spendable_supply += increaseAmount;\n', '        unspent_supply += increaseAmount;\n', '        timeOfLastIncrease = now;\n', '      }\n', '\n', '      circulating_supply = spendable_supply - unspent_supply;\n', '\n', '      return circulating_supply;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n', '        balanceOf[msg.sender] -= _value;                    // Subtract from the sender\n', '        balanceOf[_to] += _value;                           // Add the same to the recipient\n', '\n', '        updateSupply();\n', '\n', '        /* Notify anyone listening that the transfer took place */\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '    }\n', '    /* Mint new coins by sending ether */\n', '    function mint() public payable {\n', '        require(balanceOf[msg.sender] + _value >= balanceOf[msg.sender]); // Check for overflows\n', '        uint256 _value = msg.value / 100000000;\n', '\n', '        updateSupply();\n', '\n', '        require(unspent_supply - _value <= unspent_supply);\n', '        unspent_supply -= _value; // Remove from unspent supply\n', '        balanceOf[msg.sender] += _value; // Add the same to the recipient\n', '\n', '        updateSupply();\n', '\n', '        /* Notify anyone listening that the minting took place */\n', '        Mint(msg.sender, _value);\n', '\n', '    }\n', '\n', '    function withdraw(uint256 amountToWithdraw) public returns (bool) {\n', '\n', '        // Balance given in HOW\n', '\n', '        require(balanceOf[msg.sender] >= amountToWithdraw);\n', '        require(balanceOf[msg.sender] - amountToWithdraw <= balanceOf[msg.sender]);\n', '\n', '        // Balance checked in HOW, then converted into Wei\n', '        balanceOf[msg.sender] -= amountToWithdraw;\n', '\n', '        // Added back to supply in HOW\n', '        unspent_supply += amountToWithdraw;\n', '        // Converted into Wei\n', '        amountToWithdraw *= 100000000;\n', '\n', '        // Transfered in Wei\n', '        msg.sender.transfer(amountToWithdraw);\n', '\n', '        updateSupply();\n', '\n', '        return true;\n', '    }\n', '}']