['pragma solidity ^0.4.24;\n', '\n', '//test rinkeby address: {ec8d36aec0ee4105b7a36b9aafaa2b6c18585637}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', '*/\n', ' \n', 'library SafeMath \n', '{\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '      if (a==0)\n', '      {\n', '          return 0;\n', '      }\n', '      \n', '    uint256 c = a * b;\n', '    assert(c / a == b); // assert on overflow\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256)\n', '  {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic\n', '{\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic\n', '{\n', '    // founder details\n', '    address public constant FOUNDER_ADDRESS1 = 0xcb8Fb8Bf927e748c0679375B26fb9f2F12f3D5eE;\n', '    address public constant FOUNDER_ADDRESS2 = 0x1Ebfe7c17a22E223965f7B80c02D3d2805DFbE5F;\n', '    address public constant FOUNDER_ADDRESS3 = 0x9C5076C3e95C0421699A6D9d66a219BF5Ba5D826;\n', '    \n', '    address public constant FOUNDER_FUND_1 = 9000000000;\n', '    address public constant FOUNDER_FUND_2 = 9000000000;\n', '    address public constant FOUNDER_FUND_3 = 7000000000;\n', '    \n', '    // deposit address for reserve / crowdsale\n', '    address public constant MEW_RESERVE_FUND = 0xD11ffBea1cE043a8d8dDDb85F258b1b164AF3da4; // multisig\n', '    address public constant MEW_CROWDSALE_FUND = 0x842C4EA879050742b42c8b2E43f1C558AD0d1741; // multisig\n', '    \n', '    uint256 public constant decimals = 18;\n', '    \n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '  \n', '  // all initialised to false - do we want multi-state? maybe... \n', '  mapping(address => uint256) public mCanSpend;\n', '  mapping(address => uint256) public mEtherSpent;\n', '  \n', '  int256 public mEtherValid;\n', '  int256 public mEtherInvalid;\n', '  \n', '  // real\n', '  // standard unlocked tokens will vest immediately on the prime vesting date\n', '  // founder tokens will vest at a rate per day\n', '  uint256 public constant TOTAL_RESERVE_FUND =  40 * (10**9) * 10**decimals;  // 40B reserve created before sale\n', '  uint256 public constant TOTAL_CROWDSALE_FUND =  60 * (10**9) * 10**decimals;  // 40B reserve created before sale\n', '  uint256 public PRIME_VESTING_DATE = 0xffffffffffffffff; // will set to rough dates then fix at end of sale\n', '  uint256 public FINAL_AML_DATE = 0xffffffffffffffff; // will set to rough date + 3 months then fix at end of sale\n', '  uint256 public constant FINAL_AML_DAYS = 90;\n', '  uint256 public constant DAYSECONDS = 24*60*60;//86400; // 1 day in seconds // 1 minute vesting\n', '  \n', '  mapping(address => uint256) public mVestingDays;  // number of days to fully vest\n', '  mapping(address => uint256) public mVestingBalance; // total balance which will vest\n', '  mapping(address => uint256) public mVestingSpent; // total spent\n', '  mapping(address => uint256) public mVestingBegins; // total spent\n', '  \n', '  mapping(address => uint256) public mVestingAllowed; // really just for checking\n', '  \n', '  // used to enquire about the ether spent to buy the tokens\n', '  function GetEtherSpent(address from) view public returns (uint256)\n', '  {\n', '      return mEtherSpent[from];\n', '  }\n', '  \n', '  // removes tokens and returns them to the main pool\n', '  // this is called if \n', '  function RevokeTokens(address target) internal\n', '  {\n', '      //require(mCanSpend[from]==0),"Can only call this if AML hasn&#39;t been completed correctly");\n', '      // block this address from further spending\n', '      require(mCanSpend[target]!=9);\n', '      mCanSpend[target]=9;\n', '      \n', '      uint256 _value = balances[target];\n', '      \n', '      balances[target] = 0;//just wipe the balance\n', '      \n', '      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value);\n', '      \n', '      // let the blockchain know its been revoked\n', '      emit Transfer(target, MEW_RESERVE_FUND, _value);\n', '  }\n', '  \n', '  function LockedCrowdSale(address target) view internal returns (bool)\n', '  {\n', '      if (mCanSpend[target]==0 && mEtherSpent[target]>0)\n', '      {\n', '          return true;\n', '      }\n', '      return false;\n', '  }\n', '  \n', '  function CheckRevoke(address target) internal returns (bool)\n', '  {\n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      // we know if they took part in the crowdsale by checking if they spent ether\n', '      if (LockedCrowdSale(target))\n', '      {\n', '         if (block.timestamp>FINAL_AML_DATE)\n', '         {\n', '             RevokeTokens(target);\n', '             return true;\n', '         }\n', '      }\n', '      \n', '      return false;\n', '  }\n', '  \n', '  function ComputeVestSpend(address target) public returns (uint256)\n', '  {\n', '      require(mCanSpend[target]==2); // only compute for vestable accounts\n', '      int256 vestingDays = int256(mVestingDays[target]);\n', '      int256 vestingProgress = (int256(block.timestamp)-int256(mVestingBegins[target]))/(int256(DAYSECONDS));\n', '      \n', '      // cap the vesting\n', '      if (vestingProgress>vestingDays)\n', '      {\n', '          vestingProgress=vestingDays;\n', '      }\n', '          \n', '      // whole day vesting e.g. day 0 nothing vested, day 1 = 1 day vested    \n', '      if (vestingProgress>0)\n', '      {\n', '              \n', '        int256 allowedVest = ((int256(mVestingBalance[target])*vestingProgress))/vestingDays;\n', '                  \n', '        int256 combined = allowedVest-int256(mVestingSpent[target]);\n', '        \n', '        // store the combined value so people can see their vesting (useful for debug too)\n', '        mVestingAllowed[target] = uint256(combined);\n', '        \n', '        return uint256(combined);\n', '      }\n', '      \n', '      // no vesting allowed\n', '      mVestingAllowed[target]=0;\n', '      \n', '      // cannot spend anything\n', '      return 0;\n', '  }\n', '  \n', '  // 0 locked \n', '  // 1 unlocked\n', '  // 2 vestable\n', '  function canSpend(address from, uint256 amount) internal returns (bool permitted)\n', '  {\n', '      uint256 currentTime = block.timestamp;\n', '      \n', '      // refunded / blocked\n', '      if (mCanSpend[from]==8)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // revoked / blocked\n', '      if (mCanSpend[from]==9)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      if (LockedCrowdSale(from))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      if (mCanSpend[from]==1)\n', '      {\n', '          // tokens can only move when sale is finished\n', '          if (currentTime>PRIME_VESTING_DATE)\n', '          {\n', '             return true;\n', '          }\n', '          return false;\n', '      }\n', '      \n', '      // special vestable tokens\n', '      if (mCanSpend[from]==2)\n', '      {\n', '              \n', '        if (ComputeVestSpend(from)>=amount)\n', '            {\n', '              return true;\n', '            }\n', '            else\n', '            {\n', '              return false;   \n', '            }\n', '      }\n', '      \n', '      return false;\n', '  }\n', '  \n', '   // 0 locked \n', '  // 1 unlocked\n', '  // 2 vestable\n', '  function canTake(address from) view public returns (bool permitted)\n', '  {\n', '      uint256 currentTime = block.timestamp;\n', '      \n', '      // refunded / blocked\n', '      if (mCanSpend[from]==8)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // revoked / blocked\n', '      if (mCanSpend[from]==9)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      if (LockedCrowdSale(from))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      if (mCanSpend[from]==1)\n', '      {\n', '          // tokens can only move when sale is finished\n', '          if (currentTime>PRIME_VESTING_DATE)\n', '          {\n', '             return true;\n', '          }\n', '          return false;\n', '      }\n', '      \n', '      // special vestable tokens\n', '      if (mCanSpend[from]==2)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      return true;\n', '  }\n', '  \n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) \n', '  {\n', '       // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\n', '      {\n', '          return false;\n', '      }\n', '     \n', '    require(canSpend(msg.sender, _value)==true);//, "Cannot spend this amount - AML or not vested")\n', '    require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\n', '    \n', '    if (balances[msg.sender] >= _value) \n', '    {\n', '      // deduct the spend first (this is unlikely attack vector as only a few people will have vesting tokens)\n', '      // special tracker for vestable funds - if have a date up\n', '      if (mCanSpend[msg.sender]==2)\n', '      {\n', '        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\n', '      }\n', '      \n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      emit Transfer(msg.sender, _to, _value);\n', '      \n', '      \n', '      // set can spend on destination as it will be transferred from approved wallet\n', '      mCanSpend[_to]=1;\n', '      \n', '      return true;\n', '    } \n', '    else\n', '    {\n', '      return false;\n', '    }\n', '  }\n', '  \n', '  // in the light of our sanity allow a utility to whole number of tokens and 1/10000 token transfer\n', '  function simpletransfer(address _to, uint256 _whole, uint256 _fraction) public returns (bool success) \n', '  {\n', '    require(_fraction<10000);//, "Fractional part must be less than 10000");\n', '    \n', '    uint256 main = _whole.mul(10**decimals); // works fine now i&#39;ve removed the retarded divide by 0 assert in safemath\n', '    uint256 part = _fraction.mul(10**14);\n', '    uint256 value = main + part;\n', '    \n', '    // just call the transfer\n', '    return transfer(_to, value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 returnbalance) \n', '  {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic \n', '{\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken \n', '{\n', '  // need to add\n', '  // also need\n', '  // invalidate - used to drop all unauthorised buyers, return their tokens to reserve\n', '  // freespend - all transactions now allowed - this could be used to vest tokens?\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) \n', '   {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      require(canSpend(_from, _value)== true);//, "Cannot spend this amount - AML or not vested")\n', '      require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\n', '     \n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) \n', '    {\n', '      balances[_to] = balances[_to].add(_value);\n', '      balances[_from] = balances[_from].sub(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      emit Transfer(_from, _to, _value);\n', '      \n', '      \n', '      // set can spend on destination as it will be transferred from approved wallet\n', '      mCanSpend[_to]=1;\n', '      \n', '      // special tracker for vestable funds - if have a date set\n', '      if (mCanSpend[msg.sender]==2)\n', '      {\n', '        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\n', '      }\n', '      return true;\n', '    } \n', '    else \n', '    {\n', '     //   endsigning();\n', '      return false;\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool)\n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      require(canSpend(msg.sender, _value)==true);//, "Cannot spend this amount - AML or not vested");\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) \n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '      require(canSpend(msg.sender, _addedValue)==true);//, "Cannot spend this amount - AML or not vested");\n', '      \n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success)\n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of &#39;user permissions&#39;.\n', ' */\n', 'contract Ownable\n', '{\n', '  address public owner;\n', '  address internal auxOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public\n', '  {\n', '      \n', '        address newOwner = msg.sender;\n', '        owner = 0;\n', '        owner = newOwner;\n', '    \n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() \n', '  {\n', '    require(msg.sender == owner || msg.sender==auxOwner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public \n', '  {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable\n', '{\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '  uint256 internal mCanPurchase = 1;\n', '  uint256 internal mSetupReserve = 0;\n', '  uint256 internal mSetupCrowd = 0;\n', '  \n', '  //test\n', '  uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\n', '  uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\n', '\n', '  //real\n', '  //uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\n', '  //uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\n', '\n', '\n', '  modifier canMint() \n', '  {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '  \n', '  function allocateVestable(address target, uint256 amount, uint256 vestdays, uint256 vestingdate) public onlyOwner\n', '  {\n', '      //require(msg.sender==CONTRACT_CREATOR, "You are not authorised to create vestable token users");\n', '      // check if we have permission to get in here\n', '      //checksigning();\n', '      \n', '      // prevent anyone except contract signatories from creating their own vestable\n', '      \n', '      // essentially set up a final vesting date\n', '      uint256 vestingAmount = amount * 10**decimals;\n', '    \n', '      // set up the vesting params\n', '      mCanSpend[target]=2;\n', '      mVestingBalance[target] = vestingAmount;\n', '      mVestingDays[target] = vestdays;\n', '      mVestingBegins[target] = vestingdate;\n', '      mVestingSpent[target] = 0;\n', '      \n', '      // load the balance of the actual token fund\n', '      balances[target] = vestingAmount;\n', '      \n', '      // if the tokensale is finalised then use the crowdsale fund which SHOULD be empty.\n', '      // this means we can create new vesting tokens if necessary but only if crowdsale fund has been preload with MEW using multisig wallet\n', '      if (mCanPurchase==0)\n', '      {\n', '        require(vestingAmount <= balances[MEW_CROWDSALE_FUND]);//, "Not enough MEW to allocate vesting post crowdsale");\n', '        balances[MEW_CROWDSALE_FUND] = balances[MEW_CROWDSALE_FUND].sub(vestingAmount); \n', '        // log transfer\n', '        emit Transfer(MEW_CROWDSALE_FUND, target, vestingAmount);\n', '      }\n', '      else\n', '      {\n', '        // deduct tokens from reserve before crowdsale\n', '        require(vestingAmount <= balances[MEW_RESERVE_FUND]);//, "Not enough MEW to allocate vesting during setup");\n', '        balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].sub(vestingAmount);\n', '        // log transfer\n', '        emit Transfer(MEW_RESERVE_FUND, target, vestingAmount);\n', '      }\n', '  }\n', '  \n', '  function SetAuxOwner(address aux) onlyOwner public\n', '  {\n', '      require(auxOwner == 0);//, "Cannot replace aux owner once it has been set");\n', '      // sets the auxilliary owner as the contract owns this address not the creator\n', '      auxOwner = aux;\n', '  }\n', ' \n', '  function Purchase(address _to, uint256 _ether, uint256 _amount, uint256 exchange) onlyOwner public returns (bool) \n', '  {\n', '    require(mCanSpend[_to]==0); // cannot purchase to a validated or vesting wallet (probably works but more debug checks)\n', '    require(mSetupCrowd==1);//, "Only purchase during crowdsale");\n', '    require(mCanPurchase==1);//,"Can only purchase during a sale");\n', '      \n', '    require( _amount >= MINIMUM_ETHER_SPEND * exchange);//, "Must spend at least minimum ether");\n', '    require( (_amount+balances[_to]) <= MAXIMUM_ETHER_SPEND * exchange);//, "Must not spend more than maximum ether");\n', '   \n', '    // bail if we&#39;re out of tokens (will be amazing if this happens but hey!)\n', '    if (balances[MEW_CROWDSALE_FUND]<_amount)\n', '    {\n', '         return false;\n', '    }\n', '\n', '    // lock the tokens for AML - early to prevent transact hack\n', '    mCanSpend[_to] = 0;\n', '    \n', '    // add these ether to the invalid count unless checked\n', '    if (mCanSpend[_to]==0)\n', '    {\n', '        mEtherInvalid = mEtherInvalid + int256(_ether);\n', '    }\n', '    else\n', '    {\n', '        // valid AML checked ether\n', '        mEtherValid = mEtherValid + int256(_ether);\n', '    }\n', '    \n', '    // store how much ether was spent\n', '    mEtherSpent[_to] = _ether;\n', '      \n', '    // broken up to prevent recursive spend hacks (safemath probably does but just in case)\n', '    uint256 newBalance = balances[_to].add(_amount);\n', '    uint256 newCrowdBalance = balances[MEW_CROWDSALE_FUND].sub(_amount);\n', '    \n', '    balances[_to]=0;\n', '    balances[MEW_CROWDSALE_FUND] = 0;\n', '      \n', '    // add in to personal fund\n', '    balances[_to] = newBalance;\n', '    balances[MEW_CROWDSALE_FUND] = newCrowdBalance;\n', '   \n', '    emit Transfer(MEW_CROWDSALE_FUND, _to, _amount);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  function Unlock_Tokens(address target) public onlyOwner\n', '  {\n', '      \n', '      require(mCanSpend[target]==0);//,"Unlocking would fail");\n', '      \n', '      // unlocks locked tokens - must be called on every token wallet after AML check\n', '      //unlocktokens(target);\n', '      \n', '      mCanSpend[target]=1;\n', '      \n', '      \n', '    // get how much ether this person spent on their tokens\n', '    uint256 etherToken = mEtherSpent[target];\n', '    \n', '    // if this is called the ether are now valid and can be spent\n', '    mEtherInvalid = mEtherInvalid - int256(etherToken);\n', '    mEtherValid = mEtherValid + int256(etherToken);\n', '    \n', '  }\n', '  \n', '  \n', '  function Revoke(address target) public onlyOwner\n', '  {\n', '      // revokes tokens and returns to the reserve\n', '      // designed to be used for refunds or to try to reverse theft via phishing etc\n', '      RevokeTokens(target);\n', '  }\n', '  \n', '  function BlockRefunded(address target) public onlyOwner\n', '  {\n', '      require(mCanSpend[target]!=8);\n', '      // clear the spent ether\n', '      //mEtherSpent[target]=0;\n', '      \n', '      // refund marker\n', '      mCanSpend[target]=8;\n', '      \n', '      // does not refund just blocks account from being used for tokens ever again\n', '      mEtherInvalid = mEtherInvalid-int256(mEtherSpent[target]);\n', '  }\n', '  \n', '  function SetupReserve(address multiSig) public onlyOwner\n', '  {\n', '      require(mSetupReserve==0);//, "Reserve has already been initialised");\n', '      require(multiSig>0);//, "Wallet is not valid");\n', '      \n', '      // address the mew reserve fund as the multisig wallet\n', '      //MEW_RESERVE_FUND = multiSig;\n', '      \n', '      // create the reserve\n', '      mint(MEW_RESERVE_FUND, TOTAL_RESERVE_FUND);\n', '     \n', '       // vesting allocates from the reserve fund\n', '      allocateVestable(FOUNDER_ADDRESS1, 9000000000, 365, PRIME_VESTING_DATE);\n', '      allocateVestable(FOUNDER_ADDRESS2, 9000000000, 365, PRIME_VESTING_DATE);\n', '      allocateVestable(FOUNDER_ADDRESS3, 7000000000, 365, PRIME_VESTING_DATE);\n', '  }\n', '  \n', '  function SetupCrowdSale() public onlyOwner\n', '  {\n', '      require(mSetupCrowd==0);//, "Crowdsale has already been initalised");\n', '      // create the reserve\n', '      mint(MEW_CROWDSALE_FUND, TOTAL_CROWDSALE_FUND);\n', '      \n', '      // crowd initialised\n', '      mSetupCrowd=1;\n', '  }\n', '  \n', '  function CloseSaleFund() public onlyOwner\n', '  {\n', '      uint256 remainingFund;\n', '      \n', '      remainingFund = balances[MEW_CROWDSALE_FUND];\n', '      \n', '      balances[MEW_CROWDSALE_FUND] = 0;\n', '      \n', '      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(remainingFund);\n', '      \n', '      // notify the network\n', '      emit Transfer(MEW_CROWDSALE_FUND, MEW_RESERVE_FUND, remainingFund);\n', '      \n', '      // set up the prime vesting date - ie immediate\n', '      // set up the aml date\n', '      PRIME_VESTING_DATE = block.timestamp;\n', '      FINAL_AML_DATE = PRIME_VESTING_DATE + FINAL_AML_DAYS*DAYSECONDS;\n', '      \n', '      // update vesting date (sale end)\n', '      mVestingBegins[FOUNDER_ADDRESS1]=PRIME_VESTING_DATE;\n', '      mVestingBegins[FOUNDER_ADDRESS2]=PRIME_VESTING_DATE;\n', '      mVestingBegins[FOUNDER_ADDRESS3]=PRIME_VESTING_DATE;\n', '      \n', '      // block further token purchasing (forever)\n', '      mCanPurchase = 0;\n', '  }\n', '  \n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) \n', '  {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    \n', '    // allow this minted money to be spent immediately\n', '    mCanSpend[_to] = 1;\n', '    \n', '    emit Mint(_to, _amount);\n', '    emit Transfer(0x0, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner public returns (bool) \n', '  {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract MEWcoin is MintableToken \n', '{\n', '    string public constant name = "MEWcoin (Official vFloorplan Ltd 30/07/18)";\n', '    string public constant symbol = "MEW";\n', '    string public version = "1.0";\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '//test rinkeby address: {ec8d36aec0ee4105b7a36b9aafaa2b6c18585637}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', '*/\n', ' \n', 'library SafeMath \n', '{\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '      if (a==0)\n', '      {\n', '          return 0;\n', '      }\n', '      \n', '    uint256 c = a * b;\n', '    assert(c / a == b); // assert on overflow\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256)\n', '  {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic\n', '{\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic\n', '{\n', '    // founder details\n', '    address public constant FOUNDER_ADDRESS1 = 0xcb8Fb8Bf927e748c0679375B26fb9f2F12f3D5eE;\n', '    address public constant FOUNDER_ADDRESS2 = 0x1Ebfe7c17a22E223965f7B80c02D3d2805DFbE5F;\n', '    address public constant FOUNDER_ADDRESS3 = 0x9C5076C3e95C0421699A6D9d66a219BF5Ba5D826;\n', '    \n', '    address public constant FOUNDER_FUND_1 = 9000000000;\n', '    address public constant FOUNDER_FUND_2 = 9000000000;\n', '    address public constant FOUNDER_FUND_3 = 7000000000;\n', '    \n', '    // deposit address for reserve / crowdsale\n', '    address public constant MEW_RESERVE_FUND = 0xD11ffBea1cE043a8d8dDDb85F258b1b164AF3da4; // multisig\n', '    address public constant MEW_CROWDSALE_FUND = 0x842C4EA879050742b42c8b2E43f1C558AD0d1741; // multisig\n', '    \n', '    uint256 public constant decimals = 18;\n', '    \n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '  \n', '  // all initialised to false - do we want multi-state? maybe... \n', '  mapping(address => uint256) public mCanSpend;\n', '  mapping(address => uint256) public mEtherSpent;\n', '  \n', '  int256 public mEtherValid;\n', '  int256 public mEtherInvalid;\n', '  \n', '  // real\n', '  // standard unlocked tokens will vest immediately on the prime vesting date\n', '  // founder tokens will vest at a rate per day\n', '  uint256 public constant TOTAL_RESERVE_FUND =  40 * (10**9) * 10**decimals;  // 40B reserve created before sale\n', '  uint256 public constant TOTAL_CROWDSALE_FUND =  60 * (10**9) * 10**decimals;  // 40B reserve created before sale\n', '  uint256 public PRIME_VESTING_DATE = 0xffffffffffffffff; // will set to rough dates then fix at end of sale\n', '  uint256 public FINAL_AML_DATE = 0xffffffffffffffff; // will set to rough date + 3 months then fix at end of sale\n', '  uint256 public constant FINAL_AML_DAYS = 90;\n', '  uint256 public constant DAYSECONDS = 24*60*60;//86400; // 1 day in seconds // 1 minute vesting\n', '  \n', '  mapping(address => uint256) public mVestingDays;  // number of days to fully vest\n', '  mapping(address => uint256) public mVestingBalance; // total balance which will vest\n', '  mapping(address => uint256) public mVestingSpent; // total spent\n', '  mapping(address => uint256) public mVestingBegins; // total spent\n', '  \n', '  mapping(address => uint256) public mVestingAllowed; // really just for checking\n', '  \n', '  // used to enquire about the ether spent to buy the tokens\n', '  function GetEtherSpent(address from) view public returns (uint256)\n', '  {\n', '      return mEtherSpent[from];\n', '  }\n', '  \n', '  // removes tokens and returns them to the main pool\n', '  // this is called if \n', '  function RevokeTokens(address target) internal\n', '  {\n', '      //require(mCanSpend[from]==0),"Can only call this if AML hasn\'t been completed correctly");\n', '      // block this address from further spending\n', '      require(mCanSpend[target]!=9);\n', '      mCanSpend[target]=9;\n', '      \n', '      uint256 _value = balances[target];\n', '      \n', '      balances[target] = 0;//just wipe the balance\n', '      \n', '      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value);\n', '      \n', '      // let the blockchain know its been revoked\n', '      emit Transfer(target, MEW_RESERVE_FUND, _value);\n', '  }\n', '  \n', '  function LockedCrowdSale(address target) view internal returns (bool)\n', '  {\n', '      if (mCanSpend[target]==0 && mEtherSpent[target]>0)\n', '      {\n', '          return true;\n', '      }\n', '      return false;\n', '  }\n', '  \n', '  function CheckRevoke(address target) internal returns (bool)\n', '  {\n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      // we know if they took part in the crowdsale by checking if they spent ether\n', '      if (LockedCrowdSale(target))\n', '      {\n', '         if (block.timestamp>FINAL_AML_DATE)\n', '         {\n', '             RevokeTokens(target);\n', '             return true;\n', '         }\n', '      }\n', '      \n', '      return false;\n', '  }\n', '  \n', '  function ComputeVestSpend(address target) public returns (uint256)\n', '  {\n', '      require(mCanSpend[target]==2); // only compute for vestable accounts\n', '      int256 vestingDays = int256(mVestingDays[target]);\n', '      int256 vestingProgress = (int256(block.timestamp)-int256(mVestingBegins[target]))/(int256(DAYSECONDS));\n', '      \n', '      // cap the vesting\n', '      if (vestingProgress>vestingDays)\n', '      {\n', '          vestingProgress=vestingDays;\n', '      }\n', '          \n', '      // whole day vesting e.g. day 0 nothing vested, day 1 = 1 day vested    \n', '      if (vestingProgress>0)\n', '      {\n', '              \n', '        int256 allowedVest = ((int256(mVestingBalance[target])*vestingProgress))/vestingDays;\n', '                  \n', '        int256 combined = allowedVest-int256(mVestingSpent[target]);\n', '        \n', '        // store the combined value so people can see their vesting (useful for debug too)\n', '        mVestingAllowed[target] = uint256(combined);\n', '        \n', '        return uint256(combined);\n', '      }\n', '      \n', '      // no vesting allowed\n', '      mVestingAllowed[target]=0;\n', '      \n', '      // cannot spend anything\n', '      return 0;\n', '  }\n', '  \n', '  // 0 locked \n', '  // 1 unlocked\n', '  // 2 vestable\n', '  function canSpend(address from, uint256 amount) internal returns (bool permitted)\n', '  {\n', '      uint256 currentTime = block.timestamp;\n', '      \n', '      // refunded / blocked\n', '      if (mCanSpend[from]==8)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // revoked / blocked\n', '      if (mCanSpend[from]==9)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      if (LockedCrowdSale(from))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      if (mCanSpend[from]==1)\n', '      {\n', '          // tokens can only move when sale is finished\n', '          if (currentTime>PRIME_VESTING_DATE)\n', '          {\n', '             return true;\n', '          }\n', '          return false;\n', '      }\n', '      \n', '      // special vestable tokens\n', '      if (mCanSpend[from]==2)\n', '      {\n', '              \n', '        if (ComputeVestSpend(from)>=amount)\n', '            {\n', '              return true;\n', '            }\n', '            else\n', '            {\n', '              return false;   \n', '            }\n', '      }\n', '      \n', '      return false;\n', '  }\n', '  \n', '   // 0 locked \n', '  // 1 unlocked\n', '  // 2 vestable\n', '  function canTake(address from) view public returns (bool permitted)\n', '  {\n', '      uint256 currentTime = block.timestamp;\n', '      \n', '      // refunded / blocked\n', '      if (mCanSpend[from]==8)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // revoked / blocked\n', '      if (mCanSpend[from]==9)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      // roll vesting / dates and AML in to a single function\n', '      // this will stop coins being spent on new addresses until after \n', '      if (LockedCrowdSale(from))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      if (mCanSpend[from]==1)\n', '      {\n', '          // tokens can only move when sale is finished\n', '          if (currentTime>PRIME_VESTING_DATE)\n', '          {\n', '             return true;\n', '          }\n', '          return false;\n', '      }\n', '      \n', '      // special vestable tokens\n', '      if (mCanSpend[from]==2)\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      return true;\n', '  }\n', '  \n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) \n', '  {\n', '       // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\n', '      {\n', '          return false;\n', '      }\n', '     \n', '    require(canSpend(msg.sender, _value)==true);//, "Cannot spend this amount - AML or not vested")\n', '    require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\n', '    \n', '    if (balances[msg.sender] >= _value) \n', '    {\n', '      // deduct the spend first (this is unlikely attack vector as only a few people will have vesting tokens)\n', '      // special tracker for vestable funds - if have a date up\n', '      if (mCanSpend[msg.sender]==2)\n', '      {\n', '        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\n', '      }\n', '      \n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      emit Transfer(msg.sender, _to, _value);\n', '      \n', '      \n', '      // set can spend on destination as it will be transferred from approved wallet\n', '      mCanSpend[_to]=1;\n', '      \n', '      return true;\n', '    } \n', '    else\n', '    {\n', '      return false;\n', '    }\n', '  }\n', '  \n', '  // in the light of our sanity allow a utility to whole number of tokens and 1/10000 token transfer\n', '  function simpletransfer(address _to, uint256 _whole, uint256 _fraction) public returns (bool success) \n', '  {\n', '    require(_fraction<10000);//, "Fractional part must be less than 10000");\n', '    \n', "    uint256 main = _whole.mul(10**decimals); // works fine now i've removed the retarded divide by 0 assert in safemath\n", '    uint256 part = _fraction.mul(10**14);\n', '    uint256 value = main + part;\n', '    \n', '    // just call the transfer\n', '    return transfer(_to, value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 returnbalance) \n', '  {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic \n', '{\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken \n', '{\n', '  // need to add\n', '  // also need\n', '  // invalidate - used to drop all unauthorised buyers, return their tokens to reserve\n', '  // freespend - all transactions now allowed - this could be used to vest tokens?\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) \n', '   {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      require(canSpend(_from, _value)== true);//, "Cannot spend this amount - AML or not vested")\n', '      require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\n', '     \n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) \n', '    {\n', '      balances[_to] = balances[_to].add(_value);\n', '      balances[_from] = balances[_from].sub(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      emit Transfer(_from, _to, _value);\n', '      \n', '      \n', '      // set can spend on destination as it will be transferred from approved wallet\n', '      mCanSpend[_to]=1;\n', '      \n', '      // special tracker for vestable funds - if have a date set\n', '      if (mCanSpend[msg.sender]==2)\n', '      {\n', '        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\n', '      }\n', '      return true;\n', '    } \n', '    else \n', '    {\n', '     //   endsigning();\n', '      return false;\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool)\n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '      \n', '      require(canSpend(msg.sender, _value)==true);//, "Cannot spend this amount - AML or not vested");\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) \n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '      require(canSpend(msg.sender, _addedValue)==true);//, "Cannot spend this amount - AML or not vested");\n', '      \n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success)\n', '  {\n', '      // check to see if we should revoke (and revoke if so)\n', '      if (CheckRevoke(msg.sender))\n', '      {\n', '          return false;\n', '      }\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', " * functions, this simplifies the implementation of 'user permissions'.\n", ' */\n', 'contract Ownable\n', '{\n', '  address public owner;\n', '  address internal auxOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public\n', '  {\n', '      \n', '        address newOwner = msg.sender;\n', '        owner = 0;\n', '        owner = newOwner;\n', '    \n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() \n', '  {\n', '    require(msg.sender == owner || msg.sender==auxOwner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public \n', '  {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', 'contract MintableToken is StandardToken, Ownable\n', '{\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '  uint256 internal mCanPurchase = 1;\n', '  uint256 internal mSetupReserve = 0;\n', '  uint256 internal mSetupCrowd = 0;\n', '  \n', '  //test\n', '  uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\n', '  uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\n', '\n', '  //real\n', '  //uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\n', '  //uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\n', '\n', '\n', '  modifier canMint() \n', '  {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '  \n', '  function allocateVestable(address target, uint256 amount, uint256 vestdays, uint256 vestingdate) public onlyOwner\n', '  {\n', '      //require(msg.sender==CONTRACT_CREATOR, "You are not authorised to create vestable token users");\n', '      // check if we have permission to get in here\n', '      //checksigning();\n', '      \n', '      // prevent anyone except contract signatories from creating their own vestable\n', '      \n', '      // essentially set up a final vesting date\n', '      uint256 vestingAmount = amount * 10**decimals;\n', '    \n', '      // set up the vesting params\n', '      mCanSpend[target]=2;\n', '      mVestingBalance[target] = vestingAmount;\n', '      mVestingDays[target] = vestdays;\n', '      mVestingBegins[target] = vestingdate;\n', '      mVestingSpent[target] = 0;\n', '      \n', '      // load the balance of the actual token fund\n', '      balances[target] = vestingAmount;\n', '      \n', '      // if the tokensale is finalised then use the crowdsale fund which SHOULD be empty.\n', '      // this means we can create new vesting tokens if necessary but only if crowdsale fund has been preload with MEW using multisig wallet\n', '      if (mCanPurchase==0)\n', '      {\n', '        require(vestingAmount <= balances[MEW_CROWDSALE_FUND]);//, "Not enough MEW to allocate vesting post crowdsale");\n', '        balances[MEW_CROWDSALE_FUND] = balances[MEW_CROWDSALE_FUND].sub(vestingAmount); \n', '        // log transfer\n', '        emit Transfer(MEW_CROWDSALE_FUND, target, vestingAmount);\n', '      }\n', '      else\n', '      {\n', '        // deduct tokens from reserve before crowdsale\n', '        require(vestingAmount <= balances[MEW_RESERVE_FUND]);//, "Not enough MEW to allocate vesting during setup");\n', '        balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].sub(vestingAmount);\n', '        // log transfer\n', '        emit Transfer(MEW_RESERVE_FUND, target, vestingAmount);\n', '      }\n', '  }\n', '  \n', '  function SetAuxOwner(address aux) onlyOwner public\n', '  {\n', '      require(auxOwner == 0);//, "Cannot replace aux owner once it has been set");\n', '      // sets the auxilliary owner as the contract owns this address not the creator\n', '      auxOwner = aux;\n', '  }\n', ' \n', '  function Purchase(address _to, uint256 _ether, uint256 _amount, uint256 exchange) onlyOwner public returns (bool) \n', '  {\n', '    require(mCanSpend[_to]==0); // cannot purchase to a validated or vesting wallet (probably works but more debug checks)\n', '    require(mSetupCrowd==1);//, "Only purchase during crowdsale");\n', '    require(mCanPurchase==1);//,"Can only purchase during a sale");\n', '      \n', '    require( _amount >= MINIMUM_ETHER_SPEND * exchange);//, "Must spend at least minimum ether");\n', '    require( (_amount+balances[_to]) <= MAXIMUM_ETHER_SPEND * exchange);//, "Must not spend more than maximum ether");\n', '   \n', "    // bail if we're out of tokens (will be amazing if this happens but hey!)\n", '    if (balances[MEW_CROWDSALE_FUND]<_amount)\n', '    {\n', '         return false;\n', '    }\n', '\n', '    // lock the tokens for AML - early to prevent transact hack\n', '    mCanSpend[_to] = 0;\n', '    \n', '    // add these ether to the invalid count unless checked\n', '    if (mCanSpend[_to]==0)\n', '    {\n', '        mEtherInvalid = mEtherInvalid + int256(_ether);\n', '    }\n', '    else\n', '    {\n', '        // valid AML checked ether\n', '        mEtherValid = mEtherValid + int256(_ether);\n', '    }\n', '    \n', '    // store how much ether was spent\n', '    mEtherSpent[_to] = _ether;\n', '      \n', '    // broken up to prevent recursive spend hacks (safemath probably does but just in case)\n', '    uint256 newBalance = balances[_to].add(_amount);\n', '    uint256 newCrowdBalance = balances[MEW_CROWDSALE_FUND].sub(_amount);\n', '    \n', '    balances[_to]=0;\n', '    balances[MEW_CROWDSALE_FUND] = 0;\n', '      \n', '    // add in to personal fund\n', '    balances[_to] = newBalance;\n', '    balances[MEW_CROWDSALE_FUND] = newCrowdBalance;\n', '   \n', '    emit Transfer(MEW_CROWDSALE_FUND, _to, _amount);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  function Unlock_Tokens(address target) public onlyOwner\n', '  {\n', '      \n', '      require(mCanSpend[target]==0);//,"Unlocking would fail");\n', '      \n', '      // unlocks locked tokens - must be called on every token wallet after AML check\n', '      //unlocktokens(target);\n', '      \n', '      mCanSpend[target]=1;\n', '      \n', '      \n', '    // get how much ether this person spent on their tokens\n', '    uint256 etherToken = mEtherSpent[target];\n', '    \n', '    // if this is called the ether are now valid and can be spent\n', '    mEtherInvalid = mEtherInvalid - int256(etherToken);\n', '    mEtherValid = mEtherValid + int256(etherToken);\n', '    \n', '  }\n', '  \n', '  \n', '  function Revoke(address target) public onlyOwner\n', '  {\n', '      // revokes tokens and returns to the reserve\n', '      // designed to be used for refunds or to try to reverse theft via phishing etc\n', '      RevokeTokens(target);\n', '  }\n', '  \n', '  function BlockRefunded(address target) public onlyOwner\n', '  {\n', '      require(mCanSpend[target]!=8);\n', '      // clear the spent ether\n', '      //mEtherSpent[target]=0;\n', '      \n', '      // refund marker\n', '      mCanSpend[target]=8;\n', '      \n', '      // does not refund just blocks account from being used for tokens ever again\n', '      mEtherInvalid = mEtherInvalid-int256(mEtherSpent[target]);\n', '  }\n', '  \n', '  function SetupReserve(address multiSig) public onlyOwner\n', '  {\n', '      require(mSetupReserve==0);//, "Reserve has already been initialised");\n', '      require(multiSig>0);//, "Wallet is not valid");\n', '      \n', '      // address the mew reserve fund as the multisig wallet\n', '      //MEW_RESERVE_FUND = multiSig;\n', '      \n', '      // create the reserve\n', '      mint(MEW_RESERVE_FUND, TOTAL_RESERVE_FUND);\n', '     \n', '       // vesting allocates from the reserve fund\n', '      allocateVestable(FOUNDER_ADDRESS1, 9000000000, 365, PRIME_VESTING_DATE);\n', '      allocateVestable(FOUNDER_ADDRESS2, 9000000000, 365, PRIME_VESTING_DATE);\n', '      allocateVestable(FOUNDER_ADDRESS3, 7000000000, 365, PRIME_VESTING_DATE);\n', '  }\n', '  \n', '  function SetupCrowdSale() public onlyOwner\n', '  {\n', '      require(mSetupCrowd==0);//, "Crowdsale has already been initalised");\n', '      // create the reserve\n', '      mint(MEW_CROWDSALE_FUND, TOTAL_CROWDSALE_FUND);\n', '      \n', '      // crowd initialised\n', '      mSetupCrowd=1;\n', '  }\n', '  \n', '  function CloseSaleFund() public onlyOwner\n', '  {\n', '      uint256 remainingFund;\n', '      \n', '      remainingFund = balances[MEW_CROWDSALE_FUND];\n', '      \n', '      balances[MEW_CROWDSALE_FUND] = 0;\n', '      \n', '      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(remainingFund);\n', '      \n', '      // notify the network\n', '      emit Transfer(MEW_CROWDSALE_FUND, MEW_RESERVE_FUND, remainingFund);\n', '      \n', '      // set up the prime vesting date - ie immediate\n', '      // set up the aml date\n', '      PRIME_VESTING_DATE = block.timestamp;\n', '      FINAL_AML_DATE = PRIME_VESTING_DATE + FINAL_AML_DAYS*DAYSECONDS;\n', '      \n', '      // update vesting date (sale end)\n', '      mVestingBegins[FOUNDER_ADDRESS1]=PRIME_VESTING_DATE;\n', '      mVestingBegins[FOUNDER_ADDRESS2]=PRIME_VESTING_DATE;\n', '      mVestingBegins[FOUNDER_ADDRESS3]=PRIME_VESTING_DATE;\n', '      \n', '      // block further token purchasing (forever)\n', '      mCanPurchase = 0;\n', '  }\n', '  \n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) \n', '  {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    \n', '    // allow this minted money to be spent immediately\n', '    mCanSpend[_to] = 1;\n', '    \n', '    emit Mint(_to, _amount);\n', '    emit Transfer(0x0, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner public returns (bool) \n', '  {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract MEWcoin is MintableToken \n', '{\n', '    string public constant name = "MEWcoin (Official vFloorplan Ltd 30/07/18)";\n', '    string public constant symbol = "MEW";\n', '    string public version = "1.0";\n', '}']
