['pragma solidity ^0.5.0;\n', '\n', 'contract Access{\n', '    mapping(address => bool) winners;\n', '    \n', '    address public owner;\n', '    address public signer;\n', '    bool paused;\n', '    \n', '    bytes32 constant public PAUSED = keccak256(abi.encodePacked("Pause"));\n', '    bytes32 constant public UNPAUSED = keccak256(abi.encodePacked("Unpause"));\n', '    \n', '    constructor(address _signer, address _owner) public payable{\n', '        owner = _owner;\n', '        signer = _signer;\n', '    }\n', '    \n', '    function lock(bytes32 r, bytes32 s) external {\n', '        require(sigCheck(PAUSED, r, s));\n', '        require(!paused);\n', '        \n', '        paused = true;\n', '    }\n', '    \n', '    function unlock(bytes32 r, bytes32 s) external {\n', '        require(sigCheck(UNPAUSED, r, s));\n', '        require(paused);\n', '        \n', '        paused = false;\n', '    }\n', '    \n', '    function withdraw() external {\n', '        require(!paused);\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '    \n', '    function win(address _winner) external {\n', '        require(msg.sender == owner);\n', '        winners[_winner] = true;\n', '    }\n', '    \n', '    \n', '    function sigCheck(bytes32 _hash, bytes32 r, bytes32 s) internal view returns (bool) {\n', '      if(ecrecover(_hash, 27, r, s) == signer){\n', '        return(true);\n', '      }\n', '      else{\n', '        return(ecrecover(_hash, 28, r, s) == signer);\n', '      }\n', '\t}\n', '}']