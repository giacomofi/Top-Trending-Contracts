['pragma solidity ^0.4.24;\n', 'contract OWN \n', '{\n', '    address public owner;\n', '    address internal newOwner;\n', '    constructor() \n', '    public\n', '    payable\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner \n', '    {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    function changeOwner(address _owner)\n', '    onlyOwner \n', '    public\n', '    {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    function confirmOwner()\n', '    public \n', '     { \n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract ERC20 \n', '{\n', '    string  public constant name     = "DRIVER ETHEREUM";\n', '    string  public constant symbol   = "DRETH";\n', '    uint8   public constant decimals =  6;\n', '    uint256 public  totalSupply; //TOTAL \n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    mapping (address => mapping(address => uint256)) public allowance;\n', '    mapping (address => uint256) public balanceOf;\n', '    function balanceOf(address who)\n', '    public constant\n', '    returns (uint)\n', '    {\n', '        return balanceOf[who];\n', '    }\n', '    function approve(address _spender, uint _value)\n', '    public\n', '    {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '    }\n', '    function allowance(address _owner, address _spender) \n', '    public constant \n', '    returns (uint remaining) \n', '    {\n', '        return allowance[_owner][_spender];\n', '    }\n', '    modifier onlyPayloadSize(uint size) \n', '    {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '}\n', 'contract DRIVER is OWN, ERC20\n', '{\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public   Price = 800000000; //INIT\n', '    uint256 internal Minn  = 10000000000000000; //0.01 MIN\n', '    uint256 internal Maxx  = 10000000000000000000; //10 MAX\n', '    uint256 internal Bank; //BANK RESERVE \n', '\n', '    function () \n', '    payable public \n', '    {\n', '        require(msg.value>0);\n', '        require(msg.value >= Minn);\n', '        require(msg.value <= Maxx);\n', '        mintTokens(msg.sender, msg.value);\n', '    }\n', '\n', '    function mintTokens(address _who, uint256 _value) \n', '    internal \n', '        {\n', '        require(_value >= Minn);\n', '        require(_value <= Maxx);\n', '        uint256 tokens = _value / (Price*10/8); //sale price\n', '        require(tokens > 0); \n', '        require(balanceOf[_who] + tokens > balanceOf[_who]);\n', '        totalSupply += tokens; //mint tokens\n', '        balanceOf[_who] += tokens; //add tokens\n', '        uint256 perc = _value.div(100);\n', '        Bank += perc.mul(87);  // add to reserve\n', '        Price = Bank.div(totalSupply); // pump   \n', '        uint256 minus = _value % (Price*10/8); //change\n', '        require(minus > 0);\n', '        chart_call(); //log \n', '        emit Transfer(this, _who, tokens);\n', '        _value=0; tokens=0;\n', '        owner.transfer(perc.mul(6)); //prof\n', '        _who.transfer(minus); //return\n', '        minus=0; \n', '    }    \n', '\n', '    mapping (uint256 => uint256) public chartPrice;//PRICES\n', '    mapping (uint256 => uint256) public chartVolume;//VOLUM\n', '    uint256 public BlockTime=0;//TIMER \n', '    function chart_call()//SAVE STATS\n', '    internal\n', '    {\n', '        uint256 cm = (now.div(1800));//~30min.\n', '        if(cm > BlockTime)\n', '        { \n', '            BlockTime = cm;\n', '            chartPrice[BlockTime]  = Price;\n', '            chartVolume[BlockTime] = totalSupply;\n', '        }\n', '    }\n', '    function transfer (address _to, uint _value) \n', '    public onlyPayloadSize(2 * 32) \n', '    returns (bool success)\n', '    {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        if(_to != address(this)) //standart transfer\n', '        { \n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);  \n', '        }\n', '        else //sale to contract\n', '        {\n', '        balanceOf[msg.sender] -= _value;\n', '        uint256 change = _value.mul(Price);\n', '        require(address(this).balance >= change);\n', '\t\tif(totalSupply > _value){\n', '        uint256 plus = ( address(this).balance - Bank ).div(totalSupply);    \n', '        Bank -= change; \n', '        totalSupply -= _value;\n', '        Bank += (plus.mul(_value)); // increase reserve\n', '        Price = Bank.div(totalSupply); // pump\n', '        chart_call();\n', '        emit Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(totalSupply == _value){ //sale all\n', '        Price = address(this).balance/totalSupply;\n', '        Price = (Price.mul(102)).div(100); //pump\n', '        totalSupply=0;\n', '        Bank=0;\n', '        chart_call();\n', '        emit Transfer(msg.sender, _to, _value);\n', '        owner.transfer(address(this).balance - change);\n', '        }\n', '        msg.sender.transfer(change);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) \n', '    public onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '    {\n', '        require(balanceOf[_from] >= _value);\n', '        require(allowance[_from][msg.sender] >= _value);\n', '        if(_to != address(this))  // standart transfer\n', '        {\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        }\n', '        else //sale to contract\n', '        {\n', '        balanceOf[_from] -= _value;\n', '        uint256 change = _value.mul(Price);\n', '        require(address(this).balance >= change);\n', '        if(totalSupply > _value){ \n', '        uint256 plus = ( address(this).balance - Bank ).div(totalSupply);    \n', '        Bank -= change; \n', '        totalSupply -= _value;\n', '        Bank += (plus.mul(_value)); // increase reserve\n', '        Price = Bank.div(totalSupply); // pump\n', '        chart_call();\n', '        emit Transfer(_from, _to, _value);\n', '        allowance[_from][msg.sender] -= _value;\n', '        }\n', '        if(totalSupply == _value){ //sale all\n', '        Price = address(this).balance/totalSupply;\n', '        Price = (Price.mul(102)).div(100); //pump\n', '        totalSupply=0; \n', '        Bank=0; \n', '        chart_call();\n', '        emit Transfer(_from, _to, _value);\n', '        allowance[_from][msg.sender] -= _value;\n', '        owner.transfer(address(this).balance - change);\n', '        }\n', '        _from.transfer(change);\n', '        }\n', '        return true;\n', '    }\n', '    function money() \n', '    public view \n', '    returns (uint) \n', '    {\n', '        return address(this).balance;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', 'contract OWN \n', '{\n', '    address public owner;\n', '    address internal newOwner;\n', '    constructor() \n', '    public\n', '    payable\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner \n', '    {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    function changeOwner(address _owner)\n', '    onlyOwner \n', '    public\n', '    {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    function confirmOwner()\n', '    public \n', '     { \n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract ERC20 \n', '{\n', '    string  public constant name     = "DRIVER ETHEREUM";\n', '    string  public constant symbol   = "DRETH";\n', '    uint8   public constant decimals =  6;\n', '    uint256 public  totalSupply; //TOTAL \n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    mapping (address => mapping(address => uint256)) public allowance;\n', '    mapping (address => uint256) public balanceOf;\n', '    function balanceOf(address who)\n', '    public constant\n', '    returns (uint)\n', '    {\n', '        return balanceOf[who];\n', '    }\n', '    function approve(address _spender, uint _value)\n', '    public\n', '    {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '    }\n', '    function allowance(address _owner, address _spender) \n', '    public constant \n', '    returns (uint remaining) \n', '    {\n', '        return allowance[_owner][_spender];\n', '    }\n', '    modifier onlyPayloadSize(uint size) \n', '    {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '}\n', 'contract DRIVER is OWN, ERC20\n', '{\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public   Price = 800000000; //INIT\n', '    uint256 internal Minn  = 10000000000000000; //0.01 MIN\n', '    uint256 internal Maxx  = 10000000000000000000; //10 MAX\n', '    uint256 internal Bank; //BANK RESERVE \n', '\n', '    function () \n', '    payable public \n', '    {\n', '        require(msg.value>0);\n', '        require(msg.value >= Minn);\n', '        require(msg.value <= Maxx);\n', '        mintTokens(msg.sender, msg.value);\n', '    }\n', '\n', '    function mintTokens(address _who, uint256 _value) \n', '    internal \n', '        {\n', '        require(_value >= Minn);\n', '        require(_value <= Maxx);\n', '        uint256 tokens = _value / (Price*10/8); //sale price\n', '        require(tokens > 0); \n', '        require(balanceOf[_who] + tokens > balanceOf[_who]);\n', '        totalSupply += tokens; //mint tokens\n', '        balanceOf[_who] += tokens; //add tokens\n', '        uint256 perc = _value.div(100);\n', '        Bank += perc.mul(87);  // add to reserve\n', '        Price = Bank.div(totalSupply); // pump   \n', '        uint256 minus = _value % (Price*10/8); //change\n', '        require(minus > 0);\n', '        chart_call(); //log \n', '        emit Transfer(this, _who, tokens);\n', '        _value=0; tokens=0;\n', '        owner.transfer(perc.mul(6)); //prof\n', '        _who.transfer(minus); //return\n', '        minus=0; \n', '    }    \n', '\n', '    mapping (uint256 => uint256) public chartPrice;//PRICES\n', '    mapping (uint256 => uint256) public chartVolume;//VOLUM\n', '    uint256 public BlockTime=0;//TIMER \n', '    function chart_call()//SAVE STATS\n', '    internal\n', '    {\n', '        uint256 cm = (now.div(1800));//~30min.\n', '        if(cm > BlockTime)\n', '        { \n', '            BlockTime = cm;\n', '            chartPrice[BlockTime]  = Price;\n', '            chartVolume[BlockTime] = totalSupply;\n', '        }\n', '    }\n', '    function transfer (address _to, uint _value) \n', '    public onlyPayloadSize(2 * 32) \n', '    returns (bool success)\n', '    {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        if(_to != address(this)) //standart transfer\n', '        { \n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);  \n', '        }\n', '        else //sale to contract\n', '        {\n', '        balanceOf[msg.sender] -= _value;\n', '        uint256 change = _value.mul(Price);\n', '        require(address(this).balance >= change);\n', '\t\tif(totalSupply > _value){\n', '        uint256 plus = ( address(this).balance - Bank ).div(totalSupply);    \n', '        Bank -= change; \n', '        totalSupply -= _value;\n', '        Bank += (plus.mul(_value)); // increase reserve\n', '        Price = Bank.div(totalSupply); // pump\n', '        chart_call();\n', '        emit Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(totalSupply == _value){ //sale all\n', '        Price = address(this).balance/totalSupply;\n', '        Price = (Price.mul(102)).div(100); //pump\n', '        totalSupply=0;\n', '        Bank=0;\n', '        chart_call();\n', '        emit Transfer(msg.sender, _to, _value);\n', '        owner.transfer(address(this).balance - change);\n', '        }\n', '        msg.sender.transfer(change);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) \n', '    public onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '    {\n', '        require(balanceOf[_from] >= _value);\n', '        require(allowance[_from][msg.sender] >= _value);\n', '        if(_to != address(this))  // standart transfer\n', '        {\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        }\n', '        else //sale to contract\n', '        {\n', '        balanceOf[_from] -= _value;\n', '        uint256 change = _value.mul(Price);\n', '        require(address(this).balance >= change);\n', '        if(totalSupply > _value){ \n', '        uint256 plus = ( address(this).balance - Bank ).div(totalSupply);    \n', '        Bank -= change; \n', '        totalSupply -= _value;\n', '        Bank += (plus.mul(_value)); // increase reserve\n', '        Price = Bank.div(totalSupply); // pump\n', '        chart_call();\n', '        emit Transfer(_from, _to, _value);\n', '        allowance[_from][msg.sender] -= _value;\n', '        }\n', '        if(totalSupply == _value){ //sale all\n', '        Price = address(this).balance/totalSupply;\n', '        Price = (Price.mul(102)).div(100); //pump\n', '        totalSupply=0; \n', '        Bank=0; \n', '        chart_call();\n', '        emit Transfer(_from, _to, _value);\n', '        allowance[_from][msg.sender] -= _value;\n', '        owner.transfer(address(this).balance - change);\n', '        }\n', '        _from.transfer(change);\n', '        }\n', '        return true;\n', '    }\n', '    function money() \n', '    public view \n', '    returns (uint) \n', '    {\n', '        return address(this).balance;\n', '    }\n', '}']
