['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply()public view returns(uint total_Supply);\n', '    function balanceOf(address who)public view returns(uint256);\n', '    function allowance(address owner, address spender)public view returns(uint);\n', '    function transferFrom(address from, address to, uint value)public returns(bool ok);\n', '    function approve(address spender, uint value)public returns(bool ok);\n', '    function transfer(address to, uint value)public returns(bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract MIATOKEN is ERC20\n', '{\n', '    using SafeMath for uint256;\n', '    // Name of the token\n', '    string public constant name = "MIATOKEN";\n', '\n', '    // Symbol of token\n', '    string public constant symbol = "MIA";\n', '    uint8 public constant decimals = 18;\n', '    uint public _totalsupply = 35000000 * 10 ** 18; // 35 Million MIA Token\n', ' \n', '    address public owner;\n', '    address superAdmin = 0x1313d38e988526A43Ab79b69d4C94dD16f4c9936;\n', '    address socialOne = 0x52d4bcF6F328492453fAfEfF9d6Eb73D26766Cff;\n', '    address socialTwo = 0xbFe47a096486B564783f261B324e198ad84Fb8DE;\n', '    address founderOne = 0x5AD7cdD7Cd67Fe7EB17768F04425cf35a91587c9;\n', '    address founderTwo = 0xA90ab8B8Cfa553CC75F9d2C24aE7148E44Cd0ABa;\n', '    address founderThree = 0xd2fdE07Ee7cB86AfBE59F4efb9fFC1528418CC0E;\n', '    address storage1 = 0x5E948d1C6f7C76853E43DbF1F01dcea5263011C5;\n', '    \n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    modifier onlySuperAdmin() {\n', '        require (msg.sender == superAdmin);\n', '        _;\n', '    }\n', '\n', '    function MIATOKEN() public\n', '    {\n', '        owner = msg.sender;\n', '        balances[superAdmin] = 12700000 * 10 ** 18;  // 12.7 million given to superAdmin\n', '        balances[socialOne] = 3500000 * 10 ** 18;  // 3.5 million given to socialOne\n', '        balances[socialTwo] = 3500000 * 10 ** 18;  // 3.5 million given to socialTwo\n', '        balances[founderOne] = 2100000 * 10 ** 18; // 2.1 million given to FounderOne\n', '        balances[founderTwo] = 2100000 * 10 ** 18; // 2.1 million given to FounderTwo\n', '        balances[founderThree] = 2100000 * 10 ** 18; //2.1 million given to founderThree\n', '        balances[storage1] = 9000000 * 10 ** 18; // 9 million given to storage1\n', '        \n', '        emit Transfer(0, superAdmin, balances[superAdmin]);\n', '        emit Transfer(0, socialOne, balances[socialOne]);\n', '        emit Transfer(0, socialTwo, balances[socialTwo]);\n', '        emit Transfer(0, founderOne, balances[founderOne]);\n', '        emit Transfer(0, founderTwo, balances[founderTwo]);\n', '        emit Transfer(0, founderThree, balances[founderThree]);\n', '        emit Transfer(0, storage1, balances[storage1]);\n', '    }\n', '\n', '    // what is the total supply of the ech tokens\n', '    function totalSupply() public view returns(uint256 total_Supply) {\n', '        total_Supply = _totalsupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner)public view returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address _from, address _to, uint256 _amount)public returns(bool success) {\n', '        require(_to != 0x0);\n', '        require(_amount >= 0);\n', '        balances[_from] = (balances[_from]).sub(_amount);\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit  Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount)public returns(bool success) {\n', '        require(_spender != 0x0);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit  Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)public view returns(uint256 remaining) {\n', '        require(_owner != 0x0 && _spender != 0x0);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // Transfer the balance from owner&#39;s account to another account\n', '    function transfer(address _to, uint256 _amount)public returns(bool success) {\n', '        require(_to != 0x0);\n', '        require(balances[msg.sender] >= _amount && _amount >= 0);\n', '        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    //In case the ownership needs to be transferred\n', '    function transferOwnership(address newOwner)public onlySuperAdmin\n', '    {\n', '        require(newOwner != 0x0);\n', '        owner = newOwner;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply()public view returns(uint total_Supply);\n', '    function balanceOf(address who)public view returns(uint256);\n', '    function allowance(address owner, address spender)public view returns(uint);\n', '    function transferFrom(address from, address to, uint value)public returns(bool ok);\n', '    function approve(address spender, uint value)public returns(bool ok);\n', '    function transfer(address to, uint value)public returns(bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract MIATOKEN is ERC20\n', '{\n', '    using SafeMath for uint256;\n', '    // Name of the token\n', '    string public constant name = "MIATOKEN";\n', '\n', '    // Symbol of token\n', '    string public constant symbol = "MIA";\n', '    uint8 public constant decimals = 18;\n', '    uint public _totalsupply = 35000000 * 10 ** 18; // 35 Million MIA Token\n', ' \n', '    address public owner;\n', '    address superAdmin = 0x1313d38e988526A43Ab79b69d4C94dD16f4c9936;\n', '    address socialOne = 0x52d4bcF6F328492453fAfEfF9d6Eb73D26766Cff;\n', '    address socialTwo = 0xbFe47a096486B564783f261B324e198ad84Fb8DE;\n', '    address founderOne = 0x5AD7cdD7Cd67Fe7EB17768F04425cf35a91587c9;\n', '    address founderTwo = 0xA90ab8B8Cfa553CC75F9d2C24aE7148E44Cd0ABa;\n', '    address founderThree = 0xd2fdE07Ee7cB86AfBE59F4efb9fFC1528418CC0E;\n', '    address storage1 = 0x5E948d1C6f7C76853E43DbF1F01dcea5263011C5;\n', '    \n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    modifier onlySuperAdmin() {\n', '        require (msg.sender == superAdmin);\n', '        _;\n', '    }\n', '\n', '    function MIATOKEN() public\n', '    {\n', '        owner = msg.sender;\n', '        balances[superAdmin] = 12700000 * 10 ** 18;  // 12.7 million given to superAdmin\n', '        balances[socialOne] = 3500000 * 10 ** 18;  // 3.5 million given to socialOne\n', '        balances[socialTwo] = 3500000 * 10 ** 18;  // 3.5 million given to socialTwo\n', '        balances[founderOne] = 2100000 * 10 ** 18; // 2.1 million given to FounderOne\n', '        balances[founderTwo] = 2100000 * 10 ** 18; // 2.1 million given to FounderTwo\n', '        balances[founderThree] = 2100000 * 10 ** 18; //2.1 million given to founderThree\n', '        balances[storage1] = 9000000 * 10 ** 18; // 9 million given to storage1\n', '        \n', '        emit Transfer(0, superAdmin, balances[superAdmin]);\n', '        emit Transfer(0, socialOne, balances[socialOne]);\n', '        emit Transfer(0, socialTwo, balances[socialTwo]);\n', '        emit Transfer(0, founderOne, balances[founderOne]);\n', '        emit Transfer(0, founderTwo, balances[founderTwo]);\n', '        emit Transfer(0, founderThree, balances[founderThree]);\n', '        emit Transfer(0, storage1, balances[storage1]);\n', '    }\n', '\n', '    // what is the total supply of the ech tokens\n', '    function totalSupply() public view returns(uint256 total_Supply) {\n', '        total_Supply = _totalsupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner)public view returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address _from, address _to, uint256 _amount)public returns(bool success) {\n', '        require(_to != 0x0);\n', '        require(_amount >= 0);\n', '        balances[_from] = (balances[_from]).sub(_amount);\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit  Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount)public returns(bool success) {\n', '        require(_spender != 0x0);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit  Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)public view returns(uint256 remaining) {\n', '        require(_owner != 0x0 && _spender != 0x0);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', "    // Transfer the balance from owner's account to another account\n", '    function transfer(address _to, uint256 _amount)public returns(bool success) {\n', '        require(_to != 0x0);\n', '        require(balances[msg.sender] >= _amount && _amount >= 0);\n', '        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    //In case the ownership needs to be transferred\n', '    function transferOwnership(address newOwner)public onlySuperAdmin\n', '    {\n', '        require(newOwner != 0x0);\n', '        owner = newOwner;\n', '    }\n', '}']
