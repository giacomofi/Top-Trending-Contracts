['pragma solidity ^0.4.20;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// GZR &#39;Gizer Gaming&#39; token public sale contract\n', '//\n', '// For details, please visit: http://www.gizer.io\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// SafeMath\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'library SafeMath {\n', '\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require( c >= a );\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require( b <= a );\n', '    c = a - b;\n', '  }\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require( a == 0 || c / a == b );\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  mapping(address => bool) public isAdmin;\n', '\n', '  // Events ---------------------------\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  event AdminChange(address indexed _admin, bool _status);\n', '\n', '  // Modifiers ------------------------\n', '\n', '  modifier onlyOwner { require( msg.sender == owner ); _; }\n', '  modifier onlyAdmin { require( isAdmin[msg.sender] ); _; }\n', '\n', '  // Functions ------------------------\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '    isAdmin[owner] = true;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require( _newOwner != address(0x0) );\n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  \n', '  function addAdmin(address _a) public onlyOwner {\n', '    require( isAdmin[_a] == false );\n', '    isAdmin[_a] = true;\n', '    AdminChange(_a, true);\n', '  }\n', '\n', '  function removeAdmin(address _a) public onlyOwner {\n', '    require( isAdmin[_a] == true );\n', '    isAdmin[_a] = false;\n', '    AdminChange(_a, false);\n', '  }\n', '  \n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '  // Events ---------------------------\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '  // Functions ------------------------\n', '\n', '  function totalSupply() public view returns (uint);\n', '  function balanceOf(address _owner) public view returns (uint balance);\n', '  function transfer(address _to, uint _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  function approve(address _spender, uint _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Token is ERC20Interface, Owned {\n', '  \n', '  using SafeMath for uint;\n', '\n', '  uint public tokensIssuedTotal = 0;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping (address => uint)) allowed;\n', '\n', '  // Functions ------------------------\n', '\n', '  /* Total token supply */\n', '\n', '  function totalSupply() public view returns (uint) {\n', '    return tokensIssuedTotal;\n', '  }\n', '\n', '  /* Get the account balance for an address */\n', '\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /* Transfer the balance from owner&#39;s account to another account */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    // amount sent cannot exceed balance\n', '    require( balances[msg.sender] >= _amount );\n', '\n', '    // update balances\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[_to]        = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Allow _spender to withdraw from your account up to _amount */\n', '\n', '  function approve(address _spender, uint _amount) public returns (bool success) {\n', '    // approval amount cannot exceed the balance\n', '    require( balances[msg.sender] >= _amount );\n', '      \n', '    // update allowed amount\n', '    allowed[msg.sender][_spender] = _amount;\n', '    \n', '    // log event\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Spender of tokens transfers tokens from the owner&#39;s balance */\n', '  /* Must be pre-approved by owner */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    // balance checks\n', '    require( balances[_from] >= _amount );\n', '    require( allowed[_from][msg.sender] >= _amount );\n', '\n', '    // update balances and allowed amount\n', '    balances[_from]            = balances[_from].sub(_amount);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '    balances[_to]              = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Returns the amount of tokens approved by the owner */\n', '  /* that can be transferred by spender */\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// GZR public token sale\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract GizerToken is ERC20Token {\n', '\n', '  /* Utility variable */\n', '  \n', '  uint constant E6  = 10**6;\n', '\n', '  /* Basic token data */\n', '\n', '  string public constant name     = "Gizer Gaming Token";\n', '  string public constant symbol   = "GZR";\n', '  uint8  public constant decimals = 6;\n', '\n', '  /* Wallets */\n', '  \n', '  address public wallet;\n', '  address public redemptionWallet;\n', '  address public gizerItemsContract;\n', '\n', '  /* Crowdsale parameters (constants) */\n', '\n', '  uint public constant DATE_ICO_START = 1521122400; // 15-Mar-2018 14:00 UTC 10:00 EST\n', '\n', '  uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6;\n', '  uint public constant TOKEN_SUPPLY_CROWD =  6112926 * E6;\n', '  uint public constant TOKEN_SUPPLY_OWNER =  3887074 * E6; // 2,000,000 tokens reserve\n', '                                                           // 1,887,074 presale tokens\n', '\n', '  uint public constant MIN_CONTRIBUTION = 1 ether / 100;  \n', '  \n', '  uint public constant TOKENS_PER_ETH = 1000;\n', '  \n', '  uint public constant DATE_TOKENS_UNLOCKED = 1539180000; // 10-OCT-2018 14:00 UTC 10:00 EST\n', '\n', '  /* Crowdsale parameters (can be modified by owner) */\n', '  \n', '  uint public date_ico_end = 1523368800; // 10-Apr-2018 14:00 UTC 10:00 EST\n', '\n', '  /* Crowdsale variables */\n', '\n', '  uint public tokensIssuedCrowd  = 0;\n', '  uint public tokensIssuedOwner  = 0;\n', '  uint public tokensIssuedLocked = 0;\n', '  \n', '  uint public etherReceived = 0; // does not include presale ethers\n', '\n', '  /* Keep track of + ethers contributed,\n', '                   + tokens received \n', '                   + tokens locked during Crowdsale */\n', '  \n', '  mapping(address => uint) public etherContributed;\n', '  mapping(address => uint) public tokensReceived;\n', '  mapping(address => uint) public locked;\n', '  \n', '  // Events ---------------------------\n', '  \n', '  event WalletUpdated(address _newWallet);\n', '  event GizerItemsContractUpdated(address _GizerItemsContract);\n', '  event RedemptionWalletUpdated(address _newRedemptionWallet);\n', '  event DateIcoEndUpdated(uint _unixts);\n', '  event TokensIssuedCrowd(address indexed _recipient, uint _tokens, uint _ether);\n', '  event TokensIssuedOwner(address indexed _recipient, uint _tokens, bool _locked);\n', '  event ItemsBought(address indexed _recipient, uint _lastIdx, uint _number);\n', '\n', '  // Basic Functions ------------------\n', '\n', '  /* Initialize */\n', '\n', '  function GizerToken() public {\n', '    require( TOKEN_SUPPLY_OWNER + TOKEN_SUPPLY_CROWD == TOKEN_SUPPLY_TOTAL );\n', '    wallet = owner;\n', '    redemptionWallet = owner;\n', '  }\n', '\n', '  /* Fallback */\n', '  \n', '  function () public payable {\n', '    buyTokens();\n', '  }\n', '\n', '  // Information Functions ------------\n', '  \n', '  /* What time is it? */\n', '  \n', '  function atNow() public view returns (uint) {\n', '    return now;\n', '  }\n', '\n', '  /* Are tokens tradeable */\n', '  \n', '  function tradeable() public view returns (bool) {\n', '    if (atNow() > date_ico_end) return true ;\n', '    return false;\n', '  }\n', '  \n', '  /* Available to mint by owner */\n', '  \n', '  function availableToMint() public view returns (uint available) {\n', '    if (atNow() <= date_ico_end) {\n', '      available = TOKEN_SUPPLY_OWNER.sub(tokensIssuedOwner);\n', '    } else {\n', '      available = TOKEN_SUPPLY_TOTAL.sub(tokensIssuedTotal);\n', '    }\n', '  }\n', '  \n', '  /* Unlocked tokens in an account */\n', '  \n', '  function unlockedTokens(address _account) public view returns (uint _unlockedTokens) {\n', '    if (atNow() <= DATE_TOKENS_UNLOCKED) {\n', '      return balances[_account] - locked[_account];\n', '    } else {\n', '      return balances[_account];\n', '    }\n', '  }\n', '\n', '  // Owner Functions ------------------\n', '  \n', '  /* Change the crowdsale wallet address */\n', '\n', '  function setWallet(address _wallet) public onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    wallet = _wallet;\n', '    WalletUpdated(_wallet);\n', '  }\n', '\n', '  /* Change the redemption wallet address */\n', '\n', '  function setRedemptionWallet(address _wallet) public onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    redemptionWallet = _wallet;\n', '    RedemptionWalletUpdated(_wallet);\n', '  }\n', '  \n', '  /* Change the Gizer Items contract address */\n', '\n', '  function setGizerItemsContract(address _contract) public onlyOwner {\n', '    require( _contract != address(0x0) );\n', '    gizerItemsContract = _contract;\n', '    GizerItemsContractUpdated(_contract);\n', '  }\n', '  \n', '  /* Change the ICO end date */\n', '\n', '  function extendIco(uint _unixts) public onlyOwner {\n', '    require( _unixts > date_ico_end );\n', '    require( _unixts < 1530316800 ); // must be before 30-JUN-2018\n', '    date_ico_end = _unixts;\n', '    DateIcoEndUpdated(_unixts);\n', '  }\n', '  \n', '  /* Minting of tokens by owner */\n', '\n', '  function mintTokens(address _account, uint _tokens) public onlyOwner {\n', '    // check token amount\n', '    require( _tokens <= availableToMint() );\n', '    \n', '    // update\n', '    balances[_account] = balances[_account].add(_tokens);\n', '    tokensIssuedOwner  = tokensIssuedOwner.add(_tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(_tokens);\n', '    \n', '    // log event\n', '    Transfer(0x0, _account, _tokens);\n', '    TokensIssuedOwner(_account, _tokens, false);\n', '  }\n', '\n', '  /* Minting of tokens by owner */\n', '\n', '  function mintTokensLocked(address _account, uint _tokens) public onlyOwner {\n', '    // check token amount\n', '    require( _tokens <= availableToMint() );\n', '    \n', '    // update\n', '    balances[_account] = balances[_account].add(_tokens);\n', '    locked[_account]   = locked[_account].add(_tokens);\n', '    tokensIssuedOwner  = tokensIssuedOwner.add(_tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(_tokens);\n', '    tokensIssuedLocked = tokensIssuedLocked.add(_tokens);\n', '    \n', '    // log event\n', '    Transfer(0x0, _account, _tokens);\n', '    TokensIssuedOwner(_account, _tokens, true);\n', '  }  \n', '  \n', '  /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '  function transferAnyERC20Token(address tokenAddress, uint amount) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  }\n', '\n', '  // Private functions ----------------\n', '\n', '  /* Accept ETH during crowdsale (called by default function) */\n', '\n', '  function buyTokens() private {\n', '    \n', '    // basic checks\n', '    require( atNow() > DATE_ICO_START && atNow() < date_ico_end );\n', '    require( msg.value >= MIN_CONTRIBUTION );\n', '    \n', '    // check token volume\n', '    uint tokensAvailable = TOKEN_SUPPLY_CROWD.sub(tokensIssuedCrowd);\n', '    uint tokens = msg.value.mul(TOKENS_PER_ETH) / 10**12;\n', '    require( tokens <= tokensAvailable );\n', '    \n', '    // issue tokens\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    \n', '    // update global tracking variables\n', '    tokensIssuedCrowd  = tokensIssuedCrowd.add(tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(tokens);\n', '    etherReceived      = etherReceived.add(msg.value);\n', '    \n', '    // update contributor tracking variables\n', '    etherContributed[msg.sender] = etherContributed[msg.sender].add(msg.value);\n', '    tokensReceived[msg.sender]   = tokensReceived[msg.sender].add(tokens);\n', '    \n', '    // transfer Ether out\n', '    if (this.balance > 0) wallet.transfer(this.balance);\n', '\n', '    // log token issuance\n', '    TokensIssuedCrowd(msg.sender, tokens, msg.value);\n', '    Transfer(0x0, msg.sender, tokens);\n', '  }\n', '\n', '  // ERC20 functions ------------------\n', '\n', '  /* Override "transfer" */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    require( tradeable() );\n', '    require( unlockedTokens(msg.sender) >= _amount );\n', '    return super.transfer(_to, _amount);\n', '  }\n', '  \n', '  /* Override "transferFrom" */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    require( tradeable() );\n', '    require( unlockedTokens(_from) >= _amount ); \n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', '  // Bulk token transfer function -----\n', '\n', '  /* Multiple token transfers from one address to save gas */\n', '\n', '  function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '    require( tradeable() );\n', '    require( _addresses.length == _amounts.length );\n', '    require( _addresses.length <= 100 );\n', '    \n', '    // check token amounts\n', '    uint tokens_to_transfer = 0;\n', '    for (uint i = 0; i < _addresses.length; i++) {\n', '      tokens_to_transfer = tokens_to_transfer.add(_amounts[i]);\n', '    }\n', '    require( tokens_to_transfer <= unlockedTokens(msg.sender) );\n', '    \n', '    // do the transfers\n', '    for (i = 0; i < _addresses.length; i++) {\n', '      super.transfer(_addresses[i], _amounts[i]);\n', '    }\n', '  }\n', '  \n', '  // Functions to convert GZR to Gizer items -----------\n', '  \n', '  /* GZR token owner buys one Gizer Item */ \n', '  \n', '  function buyItem() public returns (uint idx) {\n', '    super.transfer(redemptionWallet, E6);\n', '    idx = mintItem(msg.sender);\n', '\n', '    // event\n', '    ItemsBought(msg.sender, idx, 1);\n', '  }\n', '  \n', '  /* GZR token owner buys several Gizer Items (max 100) */ \n', '  \n', '  function buyMultipleItems(uint8 _items) public returns (uint idx) {\n', '    \n', '    // between 0 and 100 items\n', '    require( _items > 0 && _items <= 100 );\n', '\n', '    // transfer GZR tokens to redemption wallet\n', '    super.transfer(redemptionWallet, _items * E6);\n', '    \n', '    // mint tokens, returning indexes of first and last item minted\n', '    for (uint i = 0; i < _items; i++) {\n', '      idx = mintItem(msg.sender);\n', '    }\n', '\n', '    // event\n', '    ItemsBought(msg.sender, idx, _items);\n', '  }\n', '\n', '  /* Internal function to call */\n', '  \n', '  function mintItem(address _owner) internal returns(uint idx) {\n', '    GizerItemsInterface g = GizerItemsInterface(gizerItemsContract);\n', '    idx = g.mint(_owner);\n', '  }\n', '  \n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// GZR Items interface\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract GizerItemsInterface is Owned {\n', '\n', '  function mint(address _to) public onlyAdmin returns (uint idx);\n', '\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', "// GZR 'Gizer Gaming' token public sale contract\n", '//\n', '// For details, please visit: http://www.gizer.io\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// SafeMath\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'library SafeMath {\n', '\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require( c >= a );\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require( b <= a );\n', '    c = a - b;\n', '  }\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require( a == 0 || c / a == b );\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  mapping(address => bool) public isAdmin;\n', '\n', '  // Events ---------------------------\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  event AdminChange(address indexed _admin, bool _status);\n', '\n', '  // Modifiers ------------------------\n', '\n', '  modifier onlyOwner { require( msg.sender == owner ); _; }\n', '  modifier onlyAdmin { require( isAdmin[msg.sender] ); _; }\n', '\n', '  // Functions ------------------------\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '    isAdmin[owner] = true;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require( _newOwner != address(0x0) );\n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  \n', '  function addAdmin(address _a) public onlyOwner {\n', '    require( isAdmin[_a] == false );\n', '    isAdmin[_a] = true;\n', '    AdminChange(_a, true);\n', '  }\n', '\n', '  function removeAdmin(address _a) public onlyOwner {\n', '    require( isAdmin[_a] == true );\n', '    isAdmin[_a] = false;\n', '    AdminChange(_a, false);\n', '  }\n', '  \n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '  // Events ---------------------------\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '  // Functions ------------------------\n', '\n', '  function totalSupply() public view returns (uint);\n', '  function balanceOf(address _owner) public view returns (uint balance);\n', '  function transfer(address _to, uint _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  function approve(address _spender, uint _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Token is ERC20Interface, Owned {\n', '  \n', '  using SafeMath for uint;\n', '\n', '  uint public tokensIssuedTotal = 0;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping (address => uint)) allowed;\n', '\n', '  // Functions ------------------------\n', '\n', '  /* Total token supply */\n', '\n', '  function totalSupply() public view returns (uint) {\n', '    return tokensIssuedTotal;\n', '  }\n', '\n', '  /* Get the account balance for an address */\n', '\n', '  function balanceOf(address _owner) public view returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', "  /* Transfer the balance from owner's account to another account */\n", '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    // amount sent cannot exceed balance\n', '    require( balances[msg.sender] >= _amount );\n', '\n', '    // update balances\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[_to]        = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Allow _spender to withdraw from your account up to _amount */\n', '\n', '  function approve(address _spender, uint _amount) public returns (bool success) {\n', '    // approval amount cannot exceed the balance\n', '    require( balances[msg.sender] >= _amount );\n', '      \n', '    // update allowed amount\n', '    allowed[msg.sender][_spender] = _amount;\n', '    \n', '    // log event\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', "  /* Spender of tokens transfers tokens from the owner's balance */\n", '  /* Must be pre-approved by owner */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    // balance checks\n', '    require( balances[_from] >= _amount );\n', '    require( allowed[_from][msg.sender] >= _amount );\n', '\n', '    // update balances and allowed amount\n', '    balances[_from]            = balances[_from].sub(_amount);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '    balances[_to]              = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Returns the amount of tokens approved by the owner */\n', '  /* that can be transferred by spender */\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// GZR public token sale\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract GizerToken is ERC20Token {\n', '\n', '  /* Utility variable */\n', '  \n', '  uint constant E6  = 10**6;\n', '\n', '  /* Basic token data */\n', '\n', '  string public constant name     = "Gizer Gaming Token";\n', '  string public constant symbol   = "GZR";\n', '  uint8  public constant decimals = 6;\n', '\n', '  /* Wallets */\n', '  \n', '  address public wallet;\n', '  address public redemptionWallet;\n', '  address public gizerItemsContract;\n', '\n', '  /* Crowdsale parameters (constants) */\n', '\n', '  uint public constant DATE_ICO_START = 1521122400; // 15-Mar-2018 14:00 UTC 10:00 EST\n', '\n', '  uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6;\n', '  uint public constant TOKEN_SUPPLY_CROWD =  6112926 * E6;\n', '  uint public constant TOKEN_SUPPLY_OWNER =  3887074 * E6; // 2,000,000 tokens reserve\n', '                                                           // 1,887,074 presale tokens\n', '\n', '  uint public constant MIN_CONTRIBUTION = 1 ether / 100;  \n', '  \n', '  uint public constant TOKENS_PER_ETH = 1000;\n', '  \n', '  uint public constant DATE_TOKENS_UNLOCKED = 1539180000; // 10-OCT-2018 14:00 UTC 10:00 EST\n', '\n', '  /* Crowdsale parameters (can be modified by owner) */\n', '  \n', '  uint public date_ico_end = 1523368800; // 10-Apr-2018 14:00 UTC 10:00 EST\n', '\n', '  /* Crowdsale variables */\n', '\n', '  uint public tokensIssuedCrowd  = 0;\n', '  uint public tokensIssuedOwner  = 0;\n', '  uint public tokensIssuedLocked = 0;\n', '  \n', '  uint public etherReceived = 0; // does not include presale ethers\n', '\n', '  /* Keep track of + ethers contributed,\n', '                   + tokens received \n', '                   + tokens locked during Crowdsale */\n', '  \n', '  mapping(address => uint) public etherContributed;\n', '  mapping(address => uint) public tokensReceived;\n', '  mapping(address => uint) public locked;\n', '  \n', '  // Events ---------------------------\n', '  \n', '  event WalletUpdated(address _newWallet);\n', '  event GizerItemsContractUpdated(address _GizerItemsContract);\n', '  event RedemptionWalletUpdated(address _newRedemptionWallet);\n', '  event DateIcoEndUpdated(uint _unixts);\n', '  event TokensIssuedCrowd(address indexed _recipient, uint _tokens, uint _ether);\n', '  event TokensIssuedOwner(address indexed _recipient, uint _tokens, bool _locked);\n', '  event ItemsBought(address indexed _recipient, uint _lastIdx, uint _number);\n', '\n', '  // Basic Functions ------------------\n', '\n', '  /* Initialize */\n', '\n', '  function GizerToken() public {\n', '    require( TOKEN_SUPPLY_OWNER + TOKEN_SUPPLY_CROWD == TOKEN_SUPPLY_TOTAL );\n', '    wallet = owner;\n', '    redemptionWallet = owner;\n', '  }\n', '\n', '  /* Fallback */\n', '  \n', '  function () public payable {\n', '    buyTokens();\n', '  }\n', '\n', '  // Information Functions ------------\n', '  \n', '  /* What time is it? */\n', '  \n', '  function atNow() public view returns (uint) {\n', '    return now;\n', '  }\n', '\n', '  /* Are tokens tradeable */\n', '  \n', '  function tradeable() public view returns (bool) {\n', '    if (atNow() > date_ico_end) return true ;\n', '    return false;\n', '  }\n', '  \n', '  /* Available to mint by owner */\n', '  \n', '  function availableToMint() public view returns (uint available) {\n', '    if (atNow() <= date_ico_end) {\n', '      available = TOKEN_SUPPLY_OWNER.sub(tokensIssuedOwner);\n', '    } else {\n', '      available = TOKEN_SUPPLY_TOTAL.sub(tokensIssuedTotal);\n', '    }\n', '  }\n', '  \n', '  /* Unlocked tokens in an account */\n', '  \n', '  function unlockedTokens(address _account) public view returns (uint _unlockedTokens) {\n', '    if (atNow() <= DATE_TOKENS_UNLOCKED) {\n', '      return balances[_account] - locked[_account];\n', '    } else {\n', '      return balances[_account];\n', '    }\n', '  }\n', '\n', '  // Owner Functions ------------------\n', '  \n', '  /* Change the crowdsale wallet address */\n', '\n', '  function setWallet(address _wallet) public onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    wallet = _wallet;\n', '    WalletUpdated(_wallet);\n', '  }\n', '\n', '  /* Change the redemption wallet address */\n', '\n', '  function setRedemptionWallet(address _wallet) public onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    redemptionWallet = _wallet;\n', '    RedemptionWalletUpdated(_wallet);\n', '  }\n', '  \n', '  /* Change the Gizer Items contract address */\n', '\n', '  function setGizerItemsContract(address _contract) public onlyOwner {\n', '    require( _contract != address(0x0) );\n', '    gizerItemsContract = _contract;\n', '    GizerItemsContractUpdated(_contract);\n', '  }\n', '  \n', '  /* Change the ICO end date */\n', '\n', '  function extendIco(uint _unixts) public onlyOwner {\n', '    require( _unixts > date_ico_end );\n', '    require( _unixts < 1530316800 ); // must be before 30-JUN-2018\n', '    date_ico_end = _unixts;\n', '    DateIcoEndUpdated(_unixts);\n', '  }\n', '  \n', '  /* Minting of tokens by owner */\n', '\n', '  function mintTokens(address _account, uint _tokens) public onlyOwner {\n', '    // check token amount\n', '    require( _tokens <= availableToMint() );\n', '    \n', '    // update\n', '    balances[_account] = balances[_account].add(_tokens);\n', '    tokensIssuedOwner  = tokensIssuedOwner.add(_tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(_tokens);\n', '    \n', '    // log event\n', '    Transfer(0x0, _account, _tokens);\n', '    TokensIssuedOwner(_account, _tokens, false);\n', '  }\n', '\n', '  /* Minting of tokens by owner */\n', '\n', '  function mintTokensLocked(address _account, uint _tokens) public onlyOwner {\n', '    // check token amount\n', '    require( _tokens <= availableToMint() );\n', '    \n', '    // update\n', '    balances[_account] = balances[_account].add(_tokens);\n', '    locked[_account]   = locked[_account].add(_tokens);\n', '    tokensIssuedOwner  = tokensIssuedOwner.add(_tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(_tokens);\n', '    tokensIssuedLocked = tokensIssuedLocked.add(_tokens);\n', '    \n', '    // log event\n', '    Transfer(0x0, _account, _tokens);\n', '    TokensIssuedOwner(_account, _tokens, true);\n', '  }  \n', '  \n', '  /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '  function transferAnyERC20Token(address tokenAddress, uint amount) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  }\n', '\n', '  // Private functions ----------------\n', '\n', '  /* Accept ETH during crowdsale (called by default function) */\n', '\n', '  function buyTokens() private {\n', '    \n', '    // basic checks\n', '    require( atNow() > DATE_ICO_START && atNow() < date_ico_end );\n', '    require( msg.value >= MIN_CONTRIBUTION );\n', '    \n', '    // check token volume\n', '    uint tokensAvailable = TOKEN_SUPPLY_CROWD.sub(tokensIssuedCrowd);\n', '    uint tokens = msg.value.mul(TOKENS_PER_ETH) / 10**12;\n', '    require( tokens <= tokensAvailable );\n', '    \n', '    // issue tokens\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    \n', '    // update global tracking variables\n', '    tokensIssuedCrowd  = tokensIssuedCrowd.add(tokens);\n', '    tokensIssuedTotal  = tokensIssuedTotal.add(tokens);\n', '    etherReceived      = etherReceived.add(msg.value);\n', '    \n', '    // update contributor tracking variables\n', '    etherContributed[msg.sender] = etherContributed[msg.sender].add(msg.value);\n', '    tokensReceived[msg.sender]   = tokensReceived[msg.sender].add(tokens);\n', '    \n', '    // transfer Ether out\n', '    if (this.balance > 0) wallet.transfer(this.balance);\n', '\n', '    // log token issuance\n', '    TokensIssuedCrowd(msg.sender, tokens, msg.value);\n', '    Transfer(0x0, msg.sender, tokens);\n', '  }\n', '\n', '  // ERC20 functions ------------------\n', '\n', '  /* Override "transfer" */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    require( tradeable() );\n', '    require( unlockedTokens(msg.sender) >= _amount );\n', '    return super.transfer(_to, _amount);\n', '  }\n', '  \n', '  /* Override "transferFrom" */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    require( tradeable() );\n', '    require( unlockedTokens(_from) >= _amount ); \n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', '  // Bulk token transfer function -----\n', '\n', '  /* Multiple token transfers from one address to save gas */\n', '\n', '  function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '    require( tradeable() );\n', '    require( _addresses.length == _amounts.length );\n', '    require( _addresses.length <= 100 );\n', '    \n', '    // check token amounts\n', '    uint tokens_to_transfer = 0;\n', '    for (uint i = 0; i < _addresses.length; i++) {\n', '      tokens_to_transfer = tokens_to_transfer.add(_amounts[i]);\n', '    }\n', '    require( tokens_to_transfer <= unlockedTokens(msg.sender) );\n', '    \n', '    // do the transfers\n', '    for (i = 0; i < _addresses.length; i++) {\n', '      super.transfer(_addresses[i], _amounts[i]);\n', '    }\n', '  }\n', '  \n', '  // Functions to convert GZR to Gizer items -----------\n', '  \n', '  /* GZR token owner buys one Gizer Item */ \n', '  \n', '  function buyItem() public returns (uint idx) {\n', '    super.transfer(redemptionWallet, E6);\n', '    idx = mintItem(msg.sender);\n', '\n', '    // event\n', '    ItemsBought(msg.sender, idx, 1);\n', '  }\n', '  \n', '  /* GZR token owner buys several Gizer Items (max 100) */ \n', '  \n', '  function buyMultipleItems(uint8 _items) public returns (uint idx) {\n', '    \n', '    // between 0 and 100 items\n', '    require( _items > 0 && _items <= 100 );\n', '\n', '    // transfer GZR tokens to redemption wallet\n', '    super.transfer(redemptionWallet, _items * E6);\n', '    \n', '    // mint tokens, returning indexes of first and last item minted\n', '    for (uint i = 0; i < _items; i++) {\n', '      idx = mintItem(msg.sender);\n', '    }\n', '\n', '    // event\n', '    ItemsBought(msg.sender, idx, _items);\n', '  }\n', '\n', '  /* Internal function to call */\n', '  \n', '  function mintItem(address _owner) internal returns(uint idx) {\n', '    GizerItemsInterface g = GizerItemsInterface(gizerItemsContract);\n', '    idx = g.mint(_owner);\n', '  }\n', '  \n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// GZR Items interface\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract GizerItemsInterface is Owned {\n', '\n', '  function mint(address _to) public onlyAdmin returns (uint idx);\n', '\n', '}']
