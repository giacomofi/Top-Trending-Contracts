['pragma solidity ^0.4.18;\n', 'contract Bhinneka {\n', '/* Public variables of the token */\n', 'string public name = "Bhinneka Tunggal Ika";                  // Token Name\n', 'string public symbol = "BTI";                         // Token symbol\n', 'uint public decimals = 18;                            // Token Decimal Point\n', 'address public owner;                                 // Owner of the Token Contract\n', 'uint256 totalBhinneka;                                  // Total Token for the Crowdsale\n', 'uint256 totalToken;                                   // The current total token supply.\n', 'bool public hault = false;                            // Crowdsale State\n', ' /* This creates an array with all balances */\n', 'mapping (address => uint256) balances;\n', 'mapping (address => mapping (address => uint256)) allowed;\n', '/* This generates a public event on the blockchain that will notify clients */\n', 'event Transfer(address indexed from, address indexed to, uint256 value);\n', '/* This notifies clients about the refund amount */\n', ' event Burn(address _from, uint256 _value);\n', ' event Approval(address _from, address _to, uint256 _value);\n', '/* Initializes contract with initial supply tokens to the creator of the contract */\n', 'function Bhinneka (\n', '  address _BTIclan\n', '  ) public {\n', '   owner = msg.sender;                                            // Assigning owner address.\n', '   balances[msg.sender] = 167000000 * (10 ** decimals);            // Assigning Total Token balance to owner\n', '   totalBhinneka = 267000000 * (10 ** decimals);\n', '   balances[_BTIclan] = safeAdd(balances[_BTIclan], 53125000 * (10 ** decimals));\n', '}\n', 'function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', 'modifier onlyPayloadSize(uint size) {\n', '   require(msg.data.length >= size + 4) ;\n', '   _;\n', '}\n', 'modifier onlyowner {\n', '  require (owner == msg.sender);\n', '  _;\n', '}\n', '///@notice Alter the Total Supply.\n', 'function tokensup(uint256 _value) onlyowner public{\n', '  totalBhinneka = safeAdd(totalBhinneka, _value * (10 ** decimals));\n', '  balances[owner] = safeAdd(balances[owner], _value * (10 ** decimals));\n', '}\n', '///@notice Transfer tokens based on type\n', 'function Bhinnekamint( address _client, uint _value, uint _type) onlyowner public {\n', '  uint numBTI;\n', '  require(totalToken <= totalBhinneka);\n', '  if(_type == 1){\n', '      numBTI = _value * 6000 * (10 ** decimals);\n', '  }\n', '  else if (_type == 2){\n', '      numBTI = _value * 5000 * (10 ** decimals);\n', '  }\n', '  balances[owner] = safeSub(balances[owner], numBTI);\n', '  balances[_client] = safeAdd(balances[_client], numBTI);\n', '  totalToken = safeAdd(totalToken, numBTI);\n', '  Transfer(owner, _client, numBTI);\n', '}\n', '///@notice Transfer token with only value\n', 'function BTImint( address _client, uint256 _value) onlyowner public {\n', '  require(totalToken <= totalBhinneka);\n', '  uint256 numBTI = _value * ( 10 ** decimals);\n', '  balances[owner] = safeSub(balances[owner], numBTI);\n', '  balances[_client] = safeAdd(balances[_client], numBTI);\n', '  totalToken = safeAdd(totalToken, numBTI);\n', '  Transfer(owner, _client, numBTI);\n', '}\n', '//Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check requireit doesn&#39;t wrap.\n', '//Replace the if with this one instead.\n', 'function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    require(!hault);\n', '    require(balances[msg.sender] >= _value);\n', '    balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '}\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {\n', '          // Balance or allowance too low\n', '          revert();\n', '      }\n', '      require(!hault);\n', '      balances[_to] = safeAdd(balances[_to], _value);\n', '      balances[_from] = safeSub(balances[_from],_value);\n', '      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '}\n', '/// @dev Sets approved amount of tokens for spender. Returns success.\n', '/// @param _spender Address of allowed account.\n', '/// @param _value Number of approved tokens.\n', '/// @return Returns success of function call.\n', 'function approve(address _spender, uint256 _value)\n', '    public\n', '    returns (bool)\n', '{\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '}\n', '/// @dev Returns number of allowed tokens for given address.\n', '/// @param _owner Address of token owner.\n', '/// @param _spender Address of token spender.\n', '/// @return Returns remaining allowance for spender.\n', 'function allowance(address _owner, address _spender)\n', '    constant\n', '    public\n', '    returns (uint256)\n', '{\n', '    return allowed[_owner][_spender];\n', '}\n', '/// @notice Returns balance of BTI Tokens.\n', '/// @param _from Balance for Address.\n', 'function balanceOf(address _from) public view returns (uint balance) {\n', '    return balances[_from];\n', '  }\n', '\n', '///@notice Returns the Total Number of BTI Tokens.\n', 'function totalSupply() public view returns (uint Supply){\n', '  return totalBhinneka;\n', '}\n', '/// @notice Pause the crowdsale\n', 'function pauseable() public onlyowner {\n', '    hault = true;\n', '  }\n', '/// @notice Unpause the crowdsale\n', 'function unpause() public onlyowner {\n', '    hault = false;\n', '}\n', '\n', '/// @notice Remove `_value` tokens from the system irreversibly\n', 'function burn(uint256 _value) onlyowner public returns (bool success) {\n', '    require (balances[msg.sender] >= _value);                                          // Check if the sender has enough\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);                      // Subtract from the sender\n', '    totalBhinneka = safeSub(totalBhinneka, _value);                                        // Updates totalSupply\n', '    Burn(msg.sender, _value);\n', '    return true;\n', '}\n', '}']