['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20 Token Interface\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC677 transferAndCall token interface\n', ' * @dev See https://github.com/ethereum/EIPs/issues/677 for specification and\n', ' *      discussion.\n', ' */\n', 'contract ERC677 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n', '\n', '    function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * @title Receiver interface for ERC677 transferAndCall\n', ' * @dev See https://github.com/ethereum/EIPs/issues/677 for specification and\n', ' *      discussion.\n', ' */\n', 'contract ERC677Receiver {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title VALID Token\n', ' * @dev ERC20 compatible smart contract for the VALID token. Closely follows\n', ' *      ConsenSys StandardToken.\n', ' */\n', 'contract ValidToken is ERC677, ERC20 {\n', '    // token metadata\n', '    string public constant name = "VALID";\n', '    string public constant symbol = "VLD";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // total supply and maximum amount of tokens\n', '    uint256 public constant maxSupply = 10**9 * 10**uint256(decimals);\n', '    // note: this equals 10**27, which is smaller than uint256 max value (~10**77)\n', '\n', '    // token accounting\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '    // token lockups\n', '    mapping(address => uint256) lockups;\n', '    event TokensLocked(address indexed _holder, uint256 _timeout);\n', '\n', '    // ownership\n', '    address public owner;\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // minting\n', '    bool public mintingDone = false;\n', '    modifier mintingFinished() {\n', '        require(mintingDone == true);\n', '        _;\n', '    }\n', '    modifier mintingInProgress() {\n', '        require(mintingDone == false);\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    function ValidToken() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer the ownership.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // minting functionality\n', '\n', '    function mint(address[] _recipients, uint256[] _amounts) public mintingInProgress onlyOwner {\n', '        require(_recipients.length == _amounts.length);\n', '        require(_recipients.length < 255);\n', '\n', '        for (uint8 i = 0; i < _recipients.length; i++) {\n', '            address recipient = _recipients[i];\n', '            uint256 amount = _amounts[i];\n', '\n', '            // enforce maximum token supply\n', '            require(totalSupply + amount >= totalSupply);\n', '            require(totalSupply + amount <= maxSupply);\n', '\n', '            balances[recipient] += amount;\n', '            totalSupply += amount;\n', '\n', '            Transfer(0, recipient, amount);\n', '        }\n', '    }\n', '\n', '    function lockTokens(address[] _holders, uint256[] _timeouts) public mintingInProgress onlyOwner {\n', '        require(_holders.length == _timeouts.length);\n', '        require(_holders.length < 255);\n', '\n', '        for (uint8 i = 0; i < _holders.length; i++) {\n', '            address holder = _holders[i];\n', '            uint256 timeout = _timeouts[i];\n', '\n', '            // make sure lockup period can not be overwritten\n', '            require(lockups[holder] == 0);\n', '\n', '            lockups[holder] = timeout;\n', '            TokensLocked(holder, timeout);\n', '        }\n', '    }\n', '\n', '    function finishMinting() public mintingInProgress onlyOwner {\n', '        // check hard cap again\n', '        assert(totalSupply <= maxSupply);\n', '\n', '        mintingDone = true;\n', '    }\n', '\n', '    // ERC20 functionality\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public mintingFinished returns (bool) {\n', '        // prevent some common errors\n', '        require(_to != address(0x0));\n', '        require(_to != address(this));\n', '\n', '        // check lockups\n', '        if (lockups[msg.sender] != 0) {\n', '            require(now >= lockups[msg.sender]);\n', '        }\n', '\n', '        // check balance\n', '        require(balances[msg.sender] >= _value);\n', '        assert(balances[_to] + _value >= balances[_to]); // receiver balance overflow check\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public mintingFinished returns (bool) {\n', '        // prevent some common errors\n', '        require(_to != address(0x0));\n', '        require(_to != address(this));\n', '\n', '        // check lockups\n', '        if (lockups[_from] != 0) {\n', '            require(now >= lockups[_from]);\n', '        }\n', '\n', '        // check balance and allowance\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value);\n', '        require(allowance >= _value);\n', '        assert(balances[_to] + _value >= balances[_to]); // receiver balance overflow check\n', '\n', '        allowed[_from][msg.sender] -= _value;\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // no check for zero allowance, see NOTES.md\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC677 functionality\n', '\n', '    function transferAndCall(address _to, uint _value, bytes _data) public mintingFinished returns (bool) {\n', '        require(transfer(_to, _value));\n', '\n', '        Transfer(msg.sender, _to, _value, _data);\n', '\n', '        // call receiver\n', '        if (isContract(_to)) {\n', '            ERC677Receiver receiver = ERC677Receiver(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function isContract(address _addr) private view returns (bool) {\n', '        uint len;\n', '        assembly {\n', '            len := extcodesize(_addr)\n', '        }\n', '        return len > 0;\n', '    }\n', '}']