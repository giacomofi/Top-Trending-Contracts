['pragma solidity ^0.4.24;\n', '\n', 'contract DMIBLog {\n', '    event MIBLog(bytes4 indexed sig, address indexed sender, uint _value) anonymous;\n', '\n', '    modifier mlog {\n', '        emit MIBLog(msg.sig, msg.sender, msg.value);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnerLog(address indexed previousOwner, address indexed newOwner, bytes4 sig);\n', '\n', '    constructor() public { \n', '        owner = msg.sender; \n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner  public {\n', '        require(newOwner != address(0));\n', '        emit OwnerLog(owner, newOwner, msg.sig);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract MIBStop is Ownable, DMIBLog {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() onlyOwner mlog public {\n', '        stopped = true;\n', '    }\n', '    function start() onlyOwner mlog public {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '    \n', '    function safeTransferFrom(\n', '        ERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '    internal\n', '    {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '}\n', '\n', '\n', 'contract MIBTokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    ERC20 mibtokenaddress;\n', '    \n', '    uint8 private nowvestingType = 0;\n', '    uint256 private minimum_wei = 1e18;         // 1eth\n', '    \n', '    uint256 private totalWeiEther;\n', '    \n', '    uint8 k;\n', '    \n', '    mapping(uint8 => uint) assignTokensperType ;\n', '    mapping(uint8 => uint) remainTokensperType ;\n', '    mapping(uint8 => uint) nowTokensperEth;\n', '    mapping(uint8 => uint) distributionTimes;\n', '\n', '    uint8 public iDistribution;\n', '    uint8 public iICO;\n', '\n', '    modifier canDistribute() {\n', '        require(iICO == 1);\n', '        require(iDistribution > 1);\n', '        _;\n', '    }\n', '    \n', '\n', '    enum InvestTypes { Angels, Pre_sales, Ico, Offices, Teams, Advisors, Stocks, MAX_InvestTypes }\n', '    \n', '    event TokenPurchase(address indexed _sender, address indexed _to, uint256 _value1, uint _value2, uint _value3);  \n', '    event MibTokenSend(address indexed _sender, address indexed _to, uint256 _value1, uint _value2, uint _value3);  \n', '    event MibSetLog(address indexed _sender, uint256 _value1, uint _value2, uint _value3);  \n', '\n', '    //vesting, sep, rate, start date, end date, start distribution date\n', '    constructor(\n', '            ERC20 _mibtokenaddress,\n', '            uint [] vesting,\n', '            uint8 [] sep,\n', '            uint [] rate\n', '        ) public {\n', '        \n', '            mibtokenaddress = ERC20(_mibtokenaddress);\n', '    \n', '            //proceed only ico\n', '            nowvestingType = uint8(InvestTypes.Ico);\n', '    \n', '            for(k=0; k<uint8(InvestTypes.MAX_InvestTypes); k++)\n', '            {\n', '                remainTokensperType[k] = remainTokensperType[k].add(vesting[k] * 1e18);\n', '                assignTokensperType[k] = assignTokensperType[k].add(vesting[k] * 1e18);\n', '                nowTokensperEth[k] = rate[k];\n', '                distributionTimes[k] = sep[k];\n', '            }     \n', '    \n', '            totalWeiEther = 0;\n', '        \n', '    }  \n', '    \n', '    function setVestingRate(uint256 _icorate) onlyOwner public {\n', '\n', '        nowTokensperEth[uint8(InvestTypes.Ico)] = _icorate;\n', '        \n', '        emit MibSetLog(msg.sender, 0, 0, _icorate);\n', '    }\n', '\n', '    function setVestingType(uint8 _type) onlyOwner public {\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        nowvestingType = _type;\n', '        //proceed only ico\n', '        nowvestingType = uint8(InvestTypes.Ico);\n', '        \n', '        emit MibSetLog(msg.sender, 0, 0, nowvestingType);\n', '        \n', '    }\n', '    \n', '    function startICO() onlyOwner public {\n', '        require(iDistribution < 1);\n', '        require(iICO < 1);\n', '        iICO = 2;\n', '    }\n', '\n', '    function stopICO() onlyOwner public {\n', '        require(iDistribution <= 1);\n', '        iICO = 1;\n', '    }\n', '    \n', '    function distributionStart() onlyOwner public {\n', '        require(iICO == 1);\n', '        iDistribution = 2;\n', '    }\n', '\n', '    function getDistributionStatus() onlyOwner public view returns(uint8) {\n', '        return iDistribution;\n', '    }\n', '    \n', '    function getNowVestingType() public view returns (uint8) {\n', '        return nowvestingType;\n', '    }\n', '    \n', '    function getassignTokensperType(uint8 _type) public view returns (uint) {\n', '        return assignTokensperType[_type];\n', '    }\n', '    \n', '    function getremainTokensperType(uint8 _type) public view returns (uint) {\n', '        return remainTokensperType[_type];\n', '    }\n', '\n', '    function getTotalWEIEther() onlyOwner public view returns (uint256) { \n', '        return totalWeiEther; \n', '    }\n', '\n', '    function () external payable {\n', '        \n', '        buyTokens(msg.sender, nowvestingType);\n', '    }\n', '    \n', '    function buyTokens(address _to, uint8 _type) public payable {\n', '        uint256 tokens;\n', '        \n', '        require(iICO > 1);\n', '\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        \n', '        tokens = _preValidatePurchase(_to, _type, msg.value);\n', '\n', '        processPurchase(_to, _type, tokens);\n', '        remainTokensperType[_type] = remainTokensperType[_type].sub(tokens);\n', '        \n', '        mibtokenaddress.safeTransfer(_to, tokens);\n', '        \n', '    }\n', '    \n', '    function _preValidatePurchase(\n', '        address _to,\n', '        uint8 _type,\n', '        uint256 _weiAmount\n', '        )\n', '    internal \n', '    view\n', '    returns (uint256)\n', '    {\n', '        uint256 tokens;\n', '        uint256 tmpTokens;\n', '        \n', '        require(_to != address(0));\n', '        require(_weiAmount >= minimum_wei);\n', '\n', '        tokens = nowTokensperEth[nowvestingType].mul(msg.value);\n', '        \n', '        tmpTokens = tokens.mul(20).div(100);\n', '        tokens = tokens.add(tmpTokens);\n', '        \n', '        require(tokens > 0);\n', '        \n', '        require(tokens <= remainTokensperType[_type]);\n', '        \n', '        return tokens;\n', '    }\n', '  \n', '    \n', '    function processPurchase(address _to, uint8 _type, uint256 _tokens) internal {\n', '\n', '        _forwardFunds();\n', '        totalWeiEther += msg.value;\n', '\n', '        emit TokenPurchase(owner, _to, _type, msg.value, _tokens);\n', '    }\n', '\n', '    function ownerSendTokens(address _to, uint8 _type, uint256 _weitokens) \n', '        public \n', '        canDistribute\n', '        onlyOwner\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        uint256 remaintokens;\n', '        \n', '        remaintokens = remainTokensperType[_type];\n', '        \n', '        require(remaintokens >= _weitokens);\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        \n', '        mibtokenaddress.safeTransfer(_to, _weitokens);\n', '        remainTokensperType[_type] = remainTokensperType[_type].sub(_weitokens);\n', '        \n', '        emit MibTokenSend(msg.sender, _to, _type, _weitokens, remainTokensperType[_type]);\n', '        return (remainTokensperType[_type]);\n', '        \n', '    }\n', '    \n', '    function _forwardFunds() internal  {\n', '        owner.transfer(msg.value);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract DMIBLog {\n', '    event MIBLog(bytes4 indexed sig, address indexed sender, uint _value) anonymous;\n', '\n', '    modifier mlog {\n', '        emit MIBLog(msg.sig, msg.sender, msg.value);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnerLog(address indexed previousOwner, address indexed newOwner, bytes4 sig);\n', '\n', '    constructor() public { \n', '        owner = msg.sender; \n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner  public {\n', '        require(newOwner != address(0));\n', '        emit OwnerLog(owner, newOwner, msg.sig);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract MIBStop is Ownable, DMIBLog {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require (!stopped);\n', '        _;\n', '    }\n', '    function stop() onlyOwner mlog public {\n', '        stopped = true;\n', '    }\n', '    function start() onlyOwner mlog public {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '    \n', '    function safeTransferFrom(\n', '        ERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '    internal\n', '    {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '}\n', '\n', '\n', 'contract MIBTokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    ERC20 mibtokenaddress;\n', '    \n', '    uint8 private nowvestingType = 0;\n', '    uint256 private minimum_wei = 1e18;         // 1eth\n', '    \n', '    uint256 private totalWeiEther;\n', '    \n', '    uint8 k;\n', '    \n', '    mapping(uint8 => uint) assignTokensperType ;\n', '    mapping(uint8 => uint) remainTokensperType ;\n', '    mapping(uint8 => uint) nowTokensperEth;\n', '    mapping(uint8 => uint) distributionTimes;\n', '\n', '    uint8 public iDistribution;\n', '    uint8 public iICO;\n', '\n', '    modifier canDistribute() {\n', '        require(iICO == 1);\n', '        require(iDistribution > 1);\n', '        _;\n', '    }\n', '    \n', '\n', '    enum InvestTypes { Angels, Pre_sales, Ico, Offices, Teams, Advisors, Stocks, MAX_InvestTypes }\n', '    \n', '    event TokenPurchase(address indexed _sender, address indexed _to, uint256 _value1, uint _value2, uint _value3);  \n', '    event MibTokenSend(address indexed _sender, address indexed _to, uint256 _value1, uint _value2, uint _value3);  \n', '    event MibSetLog(address indexed _sender, uint256 _value1, uint _value2, uint _value3);  \n', '\n', '    //vesting, sep, rate, start date, end date, start distribution date\n', '    constructor(\n', '            ERC20 _mibtokenaddress,\n', '            uint [] vesting,\n', '            uint8 [] sep,\n', '            uint [] rate\n', '        ) public {\n', '        \n', '            mibtokenaddress = ERC20(_mibtokenaddress);\n', '    \n', '            //proceed only ico\n', '            nowvestingType = uint8(InvestTypes.Ico);\n', '    \n', '            for(k=0; k<uint8(InvestTypes.MAX_InvestTypes); k++)\n', '            {\n', '                remainTokensperType[k] = remainTokensperType[k].add(vesting[k] * 1e18);\n', '                assignTokensperType[k] = assignTokensperType[k].add(vesting[k] * 1e18);\n', '                nowTokensperEth[k] = rate[k];\n', '                distributionTimes[k] = sep[k];\n', '            }     \n', '    \n', '            totalWeiEther = 0;\n', '        \n', '    }  \n', '    \n', '    function setVestingRate(uint256 _icorate) onlyOwner public {\n', '\n', '        nowTokensperEth[uint8(InvestTypes.Ico)] = _icorate;\n', '        \n', '        emit MibSetLog(msg.sender, 0, 0, _icorate);\n', '    }\n', '\n', '    function setVestingType(uint8 _type) onlyOwner public {\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        nowvestingType = _type;\n', '        //proceed only ico\n', '        nowvestingType = uint8(InvestTypes.Ico);\n', '        \n', '        emit MibSetLog(msg.sender, 0, 0, nowvestingType);\n', '        \n', '    }\n', '    \n', '    function startICO() onlyOwner public {\n', '        require(iDistribution < 1);\n', '        require(iICO < 1);\n', '        iICO = 2;\n', '    }\n', '\n', '    function stopICO() onlyOwner public {\n', '        require(iDistribution <= 1);\n', '        iICO = 1;\n', '    }\n', '    \n', '    function distributionStart() onlyOwner public {\n', '        require(iICO == 1);\n', '        iDistribution = 2;\n', '    }\n', '\n', '    function getDistributionStatus() onlyOwner public view returns(uint8) {\n', '        return iDistribution;\n', '    }\n', '    \n', '    function getNowVestingType() public view returns (uint8) {\n', '        return nowvestingType;\n', '    }\n', '    \n', '    function getassignTokensperType(uint8 _type) public view returns (uint) {\n', '        return assignTokensperType[_type];\n', '    }\n', '    \n', '    function getremainTokensperType(uint8 _type) public view returns (uint) {\n', '        return remainTokensperType[_type];\n', '    }\n', '\n', '    function getTotalWEIEther() onlyOwner public view returns (uint256) { \n', '        return totalWeiEther; \n', '    }\n', '\n', '    function () external payable {\n', '        \n', '        buyTokens(msg.sender, nowvestingType);\n', '    }\n', '    \n', '    function buyTokens(address _to, uint8 _type) public payable {\n', '        uint256 tokens;\n', '        \n', '        require(iICO > 1);\n', '\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        \n', '        tokens = _preValidatePurchase(_to, _type, msg.value);\n', '\n', '        processPurchase(_to, _type, tokens);\n', '        remainTokensperType[_type] = remainTokensperType[_type].sub(tokens);\n', '        \n', '        mibtokenaddress.safeTransfer(_to, tokens);\n', '        \n', '    }\n', '    \n', '    function _preValidatePurchase(\n', '        address _to,\n', '        uint8 _type,\n', '        uint256 _weiAmount\n', '        )\n', '    internal \n', '    view\n', '    returns (uint256)\n', '    {\n', '        uint256 tokens;\n', '        uint256 tmpTokens;\n', '        \n', '        require(_to != address(0));\n', '        require(_weiAmount >= minimum_wei);\n', '\n', '        tokens = nowTokensperEth[nowvestingType].mul(msg.value);\n', '        \n', '        tmpTokens = tokens.mul(20).div(100);\n', '        tokens = tokens.add(tmpTokens);\n', '        \n', '        require(tokens > 0);\n', '        \n', '        require(tokens <= remainTokensperType[_type]);\n', '        \n', '        return tokens;\n', '    }\n', '  \n', '    \n', '    function processPurchase(address _to, uint8 _type, uint256 _tokens) internal {\n', '\n', '        _forwardFunds();\n', '        totalWeiEther += msg.value;\n', '\n', '        emit TokenPurchase(owner, _to, _type, msg.value, _tokens);\n', '    }\n', '\n', '    function ownerSendTokens(address _to, uint8 _type, uint256 _weitokens) \n', '        public \n', '        canDistribute\n', '        onlyOwner\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        uint256 remaintokens;\n', '        \n', '        remaintokens = remainTokensperType[_type];\n', '        \n', '        require(remaintokens >= _weitokens);\n', '        require(_type < uint8(InvestTypes.MAX_InvestTypes));\n', '        \n', '        mibtokenaddress.safeTransfer(_to, _weitokens);\n', '        remainTokensperType[_type] = remainTokensperType[_type].sub(_weitokens);\n', '        \n', '        emit MibTokenSend(msg.sender, _to, _type, _weitokens, remainTokensperType[_type]);\n', '        return (remainTokensperType[_type]);\n', '        \n', '    }\n', '    \n', '    function _forwardFunds() internal  {\n', '        owner.transfer(msg.value);\n', '    }\n', '\n', '}']
