['/*\n', 'This file is part of the Cryptaur Contract.\n', '\n', 'The CryptaurToken Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version. See the GNU lesser General Public License\n', 'for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the CryptaurToken Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <<span class="__cf_email__" data-cfemail="9ef7b0ede8f7ecf7f0def0f1ecfaffe8f7f0fab0eceb">[email&#160;protected]</span>>\n', 'Donation address 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B\n', '*/\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    function owned() payable public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Part of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Base {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '}\n', '\n', 'contract CryptaurRewards {\n', '    function payment(address _buyer, address _seller, uint _amount, address _opinionLeader) public returns(uint fee);\n', '}\n', '\n', 'contract CryputarReserveFund {\n', '    function depositNotification(uint _amount) public;\n', '    function withdrawNotification(uint _amount) public;\n', '}\n', '\n', '/**\n', ' * @title Allows to store liked adsress(slave address) connected to the main address (master address)\n', ' */\n', 'contract AddressBook {\n', '\n', '    struct AddressRelations {\n', '        SlaveDictionary slaves;\n', '        bool hasValue;\n', '    }\n', '\n', '    struct SlaveDictionary\n', '    {\n', '        address[] values;\n', '        mapping(address => uint) keys;\n', '    }\n', '\n', '    event WalletLinked(address indexed _master, address indexed _slave);\n', '    event WalletUnlinked(address indexed _master, address indexed _slave);\n', '    event AddressChanged(address indexed _old, address indexed _new);\n', '\n', '    mapping(address => AddressRelations) private masterToSlaves;\n', '    mapping(address => address) private slaveToMasterAddress;\n', '    uint8 public maxLinkedWalletCount = 5;\n', '\n', '    /**\n', '     * Only owner of master wallet can add additional wallet.\n', '     */\n', '    function linkToMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\n', '        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\n', '        require(isMasterWallet(_masterWallet));\n', '        require(!isLinkedWallet(_linkedWallet) && !isMasterWallet(_linkedWallet));\n', '        AddressRelations storage rel = masterToSlaves[_masterWallet];\n', '        require(rel.slaves.values.length < maxLinkedWalletCount);    \n', '        rel.slaves.values.push(_linkedWallet);\n', '        rel.slaves.keys[_linkedWallet] = rel.slaves.values.length - 1;\n', '        slaveToMasterAddress[_linkedWallet] = _masterWallet;\n', '        WalletLinked(_masterWallet, _linkedWallet);\n', '    }\n', ' \n', '    function unLinkFromMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\n', '        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\n', '        require(_masterWallet == getMasterWallet(_linkedWallet));\n', '        SlaveDictionary storage slaves = masterToSlaves[_masterWallet].slaves;\n', '        uint indexToDelete = slaves.keys[_linkedWallet];\n', '        address keyToMove = slaves.values[slaves.values.length - 1];\n', '        slaves.values[indexToDelete] = keyToMove;\n', '        slaves.keys[keyToMove] = indexToDelete;\n', '        slaves.values.length--;\n', '        delete slaves.keys[_linkedWallet];\n', '        delete slaveToMasterAddress[_linkedWallet];\n', '        WalletUnlinked(_masterWallet, _linkedWallet);\n', '    }\n', '\n', '    function getLinkedWallets(address _wallet) public view returns (address[]) {\n', '        return masterToSlaves[_wallet].slaves.values;\n', '    }\n', '\n', '    function isMasterWallet(address _addr) internal constant returns (bool) {\n', '        return masterToSlaves[_addr].hasValue;\n', '    }\n', '\n', '    function isLinkedWallet(address _addr) internal constant returns (bool) {\n', '        return slaveToMasterAddress[_addr] != address(0);\n', '    }\n', '\n', '    /**\n', '     * Guess that address book already had changing address.\n', '     */ \n', '    function applyChangeWalletAddress(address _old, address _new) internal {\n', '        require(isMasterWallet(_old) || isLinkedWallet(_old));\n', '        require(_new != address(0));\n', '        if (isMasterWallet(_old)) {\n', '            // Cannt change master address with existed linked\n', '            require(!isLinkedWallet(_new));\n', '            require(masterToSlaves[_new].slaves.values.length == 0);\n', '            changeMasterAddress(_old, _new);\n', '        }\n', '        else {\n', '            // Cannt change linked address with existed master and linked to another master\n', '            require(!isMasterWallet(_new) && !isLinkedWallet(_new));\n', '            changeLinkedAddress(_old, _new);\n', '        }\n', '    }\n', '\n', '    function changeLinkedAddress(address _old, address _new) private {\n', '        slaveToMasterAddress[_new] = slaveToMasterAddress[_old];     \n', '        SlaveDictionary storage slaves = masterToSlaves[slaveToMasterAddress[_new]].slaves;\n', '        uint index = slaves.keys[_old];\n', '        slaves.values[index] = _new;\n', '        delete slaveToMasterAddress[_old];\n', '    }\n', '    \n', '    function changeMasterAddress(address _old, address _new) private {    \n', '        masterToSlaves[_new] = masterToSlaves[_old];  \n', '        SlaveDictionary storage slaves = masterToSlaves[_new].slaves;\n', '        for (uint8 i = 0; i < slaves.values.length; ++i)\n', '            slaveToMasterAddress[slaves.values[i]] = _new;\n', '        delete masterToSlaves[_old];\n', '    }\n', '\n', '    function addMasterWallet(address _master) internal {\n', '        require(_master != address(0));\n', '        masterToSlaves[_master].hasValue = true;\n', '    }\n', '\n', '    function getMasterWallet(address _wallet) internal constant returns(address) {\n', '        if(isMasterWallet(_wallet))\n', '            return _wallet;\n', '        return slaveToMasterAddress[_wallet];  \n', '    }\n', '\n', '    /**\n', '     * Try to find master address by any other; otherwise add to address book as master.\n', '     */\n', '    function getOrAddMasterWallet(address _wallet) internal returns (address) {\n', '        address masterWallet = getMasterWallet(_wallet);\n', '        if (masterWallet == address(0))\n', '            addMasterWallet(_wallet);\n', '        return _wallet;\n', '    }\n', '}\n', '\n', 'contract CryptaurDepository is owned, AddressBook {\n', '    enum UnlimitedMode {UNLIMITED,LIMITED}\n', '\n', '    event Deposit(address indexed _who, uint _amount, bytes32 _txHash);\n', '    event Withdraw(address indexed _who, uint _amount);\n', '    event Payment(address indexed _buyer, address indexed _seller, uint _amount, address indexed _opinionLeader, bool _dapp);\n', '    event Freeze(address indexed _who, bool _freeze);\n', '    event Share(address indexed _who, address indexed _dapp, uint _amount);\n', '\n', '    ERC20Base cryptaurToken = ERC20Base(0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1);\n', '    address cryptaurRecovery;\n', '    address cryptaurRewards;\n', '    address cryptaurReserveFund;\n', '    address backend;\n', '    modifier onlyBackend {\n', '        require(backend == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrBackend {\n', '        require(owner == msg.sender || backend == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier notFreezed {\n', '        require(freezedAll != true);\n', '        _;\n', '    }\n', '\n', '    mapping(address => uint) internal balances;\n', '    mapping(address => mapping (address => uint256)) public available;\n', '    mapping(address => bool) public freezed;\n', '    mapping(address => mapping(address => UnlimitedMode)) public unlimitedMode;\n', '    bool freezedAll;\n', '  \n', '    function CryptaurDepository() owned() public {}\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return balances[getMasterWallet(_who)];\n', '    }\n', '\n', '    function setUnlimitedMode(bool _unlimited, address _dapp) public {\n', '        address masterWallet = getOrAddMasterWallet(msg.sender);\n', '        unlimitedMode[masterWallet][_dapp] = _unlimited ? UnlimitedMode.UNLIMITED : UnlimitedMode.LIMITED;\n', '    }\n', '\n', '    function transferToToken(address[] _addresses) public onlyOwnerOrBackend {\n', '        for (uint index = 0; index < _addresses.length; index++) {\n', '            address addr = _addresses[index];\n', '            uint amount = balances[addr];\n', '            if (amount > 0) {\n', '                balances[addr] = 0;\n', '                cryptaurToken.transfer(addr, amount);\n', '                Withdraw(addr, amount);\n', '            }        \n', '        }\n', '    }\n', '\n', '    function setBackend(address _backend) onlyOwner public {\n', '        backend = _backend;\n', '    }\n', '\n', '    function setCryptaurRecovery(address _cryptaurRecovery) onlyOwner public {\n', '        cryptaurRecovery = _cryptaurRecovery;\n', '    }\n', '\n', '    function setCryptaurToken(address _cryptaurToken) onlyOwner public {\n', '        cryptaurToken = ERC20Base(_cryptaurToken);\n', '    }\n', '\n', '    function setCryptaurRewards(address _cryptaurRewards) onlyOwner public {\n', '        cryptaurRewards = _cryptaurRewards;\n', '    }\n', '\n', '    function setCryptaurReserveFund(address _cryptaurReserveFund) onlyOwner public {\n', '        cryptaurReserveFund = _cryptaurReserveFund;\n', '    }\n', '    \n', '    function changeAddress(address _old, address _new) public {\n', '        require(msg.sender == cryptaurRecovery);\n', '        applyChangeWalletAddress(_old, _new);\n', '\n', '        balances[_new] += balances[_old];\n', '        balances[_old] = 0;\n', '        AddressChanged(_old, _new);\n', '    }\n', '\n', '    function linkToMasterWallet(address _masterWaller, address _linkedWaller) public {\n', '        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);\n', '        linkToMasterWalletInternal(_masterWaller, _linkedWaller);\n', '    }\n', '\n', '    function unLinkFromMasterWallet(address _masterWaller, address _linkedWaller) public {\n', '        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);\n', '        unLinkFromMasterWalletInternal(_masterWaller, _linkedWaller);\n', '    }\n', '\n', '    function setMaxLinkedWalletCount(uint8 _newMaxCount) public onlyOwnerOrBackend {\n', '        maxLinkedWalletCount = _newMaxCount;\n', '    }\n', '    \n', '    function freeze(address _who, bool _freeze) onlyOwner public {\n', '        address masterWallet = getMasterWallet(_who);\n', '        if (masterWallet == address(0))\n', '            masterWallet = _who;\n', '        freezed[masterWallet] = _freeze;\n', '        Freeze(masterWallet, _freeze);\n', '    }\n', '\n', '    function freeze(bool _freeze) public onlyOwnerOrBackend {\n', '        freezedAll = _freeze;\n', '    }\n', '    \n', '    function deposit(address _who, uint _amount, bytes32 _txHash) onlyBackend public {\n', '        address masterWallet = getOrAddMasterWallet(_who);\n', '        balances[masterWallet] += _amount;\n', '        Deposit(masterWallet, _amount, _txHash);\n', '    }\n', '    \n', '    function withdraw(uint _amount) public notFreezed {\n', '        address masterWallet = getMasterWallet(msg.sender);   \n', '        require(balances[masterWallet] >= _amount);\n', '        require(!freezed[masterWallet]);\n', '        balances[masterWallet] -= _amount;\n', '        cryptaurToken.transfer(masterWallet, _amount);\n', '        Withdraw(masterWallet, _amount);\n', '    }\n', '\n', '    function balanceOf2(address _who, address _dapp) constant public returns (uint) { \n', '        return balanceOf2Internal(getMasterWallet(_who), _dapp);\n', '    }\n', '    \n', '    function balanceOf2Internal(address _who, address _dapp) constant internal returns (uint) {\n', '        uint avail;\n', '        if (!freezed[_who]) {\n', '            if (unlimitedMode[_who][_dapp] == UnlimitedMode.UNLIMITED) {\n', '                avail = balances[_who];\n', '            } \n', '            else {\n', '                avail = available[_who][_dapp];\n', '                if (avail > balances[_who])\n', '                    avail = balances[_who];\n', '            }\n', '        }\n', '        return avail;\n', '    }\n', '    /**\n', '     * @dev Function pay wrapper. Using only for dapp.\n', '     */\n', '    function pay2(address _seller, uint _amount, address _opinionLeader) public notFreezed {\n', '        address dapp = getOrAddMasterWallet(msg.sender);\n', '        address seller = getOrAddMasterWallet(_seller);\n', '        payInternal(dapp, seller, _amount, _opinionLeader);\n', '        available[seller][dapp] += _amount;\n', '    }\n', '\n', '    function pay(address _seller, uint _amount, address _opinionLeader) public notFreezed {\n', '        address buyer = getOrAddMasterWallet(msg.sender);\n', '        address seller = getOrAddMasterWallet(_seller);\n', '        payInternal(buyer, seller, _amount, _opinionLeader);\n', '    }\n', '    \n', '    /**\n', '     * @dev Common internal pay function.\n', '     * OpinionLeader is optional, can be zero.\n', '     */\n', '    function payInternal(address _buyer, address _seller, uint _amount, address _opinionLeader) internal {    \n', '        require(balances[_buyer] >= _amount);\n', '        uint fee;\n', '        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\n', '            fee = CryptaurRewards(cryptaurRewards).payment(_buyer, _seller, _amount, _opinionLeader);\n', '        }\n', '        balances[_buyer] -= _amount;\n', '        balances[_seller] += _amount - fee;\n', '        if (fee != 0) {\n', '            balances[cryptaurReserveFund] += fee;\n', '            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\n', '        }\n', '        Payment(_buyer, _seller, _amount, _opinionLeader, false);\n', '    }\n', '    \n', '    function payDAPP(address _buyer, uint _amount, address _opinionLeader) public notFreezed {\n', '        address buyerMasterWallet = getOrAddMasterWallet(_buyer);\n', '        require(balanceOf2Internal(buyerMasterWallet, msg.sender) >= _amount);\n', '        uint fee;\n', '        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\n', '            fee = CryptaurRewards(cryptaurRewards).payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader);\n', '        }\n', '        balances[buyerMasterWallet] -= _amount;\n', '        balances[msg.sender] += _amount - fee; \n', '        if (unlimitedMode[buyerMasterWallet][msg.sender] == UnlimitedMode.LIMITED)\n', '            available[buyerMasterWallet][msg.sender] -= _amount;\n', '        if (fee != 0) {\n', '            balances[cryptaurReserveFund] += fee;\n', '            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\n', '        }\n', '        Payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader, true);\n', '    }\n', '\n', '    function shareBalance(address _dapp, uint _amount) public notFreezed {\n', '        address masterWallet = getMasterWallet(msg.sender);\n', '        require(masterWallet != address(0));\n', '        available[masterWallet][_dapp] = _amount;\n', '        Share(masterWallet, _dapp, _amount);\n', '    }\n', '    \n', '    function transferFromFund(address _to, uint _amount) public {\n', '        require(msg.sender == owner || msg.sender == cryptaurRewards || msg.sender == backend);\n', '        require(cryptaurReserveFund != address(0));\n', '        require(balances[cryptaurReserveFund] >= _amount);\n', '        address masterWallet = getOrAddMasterWallet(_to);\n', '        balances[masterWallet] += _amount;\n', '        balances[cryptaurReserveFund] -= _amount;\n', '        CryputarReserveFund(cryptaurReserveFund).withdrawNotification(_amount);\n', '    }\n', '}\n', '\n', '// test only\n', 'contract CryptaurDepositoryTest is CryptaurDepository {\n', '    function CryptaurDepositoryTest() CryptaurDepository() {}\n', '\n', '    // test only\n', '    function testDrip(address _who, address _dapp, uint _amount) public {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        address masterWallet = getOrAddMasterWallet(_who);\n', '        balances[masterWallet] = _amount;\n', '        available[masterWallet][_dapp] = _amount;\n', '    }\n', '}']
['/*\n', 'This file is part of the Cryptaur Contract.\n', '\n', 'The CryptaurToken Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version. See the GNU lesser General Public License\n', 'for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the CryptaurToken Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@nordavind.ru>\n', 'Donation address 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B\n', '*/\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    function owned() payable public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Part of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Base {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '}\n', '\n', 'contract CryptaurRewards {\n', '    function payment(address _buyer, address _seller, uint _amount, address _opinionLeader) public returns(uint fee);\n', '}\n', '\n', 'contract CryputarReserveFund {\n', '    function depositNotification(uint _amount) public;\n', '    function withdrawNotification(uint _amount) public;\n', '}\n', '\n', '/**\n', ' * @title Allows to store liked adsress(slave address) connected to the main address (master address)\n', ' */\n', 'contract AddressBook {\n', '\n', '    struct AddressRelations {\n', '        SlaveDictionary slaves;\n', '        bool hasValue;\n', '    }\n', '\n', '    struct SlaveDictionary\n', '    {\n', '        address[] values;\n', '        mapping(address => uint) keys;\n', '    }\n', '\n', '    event WalletLinked(address indexed _master, address indexed _slave);\n', '    event WalletUnlinked(address indexed _master, address indexed _slave);\n', '    event AddressChanged(address indexed _old, address indexed _new);\n', '\n', '    mapping(address => AddressRelations) private masterToSlaves;\n', '    mapping(address => address) private slaveToMasterAddress;\n', '    uint8 public maxLinkedWalletCount = 5;\n', '\n', '    /**\n', '     * Only owner of master wallet can add additional wallet.\n', '     */\n', '    function linkToMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\n', '        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\n', '        require(isMasterWallet(_masterWallet));\n', '        require(!isLinkedWallet(_linkedWallet) && !isMasterWallet(_linkedWallet));\n', '        AddressRelations storage rel = masterToSlaves[_masterWallet];\n', '        require(rel.slaves.values.length < maxLinkedWalletCount);    \n', '        rel.slaves.values.push(_linkedWallet);\n', '        rel.slaves.keys[_linkedWallet] = rel.slaves.values.length - 1;\n', '        slaveToMasterAddress[_linkedWallet] = _masterWallet;\n', '        WalletLinked(_masterWallet, _linkedWallet);\n', '    }\n', ' \n', '    function unLinkFromMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\n', '        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\n', '        require(_masterWallet == getMasterWallet(_linkedWallet));\n', '        SlaveDictionary storage slaves = masterToSlaves[_masterWallet].slaves;\n', '        uint indexToDelete = slaves.keys[_linkedWallet];\n', '        address keyToMove = slaves.values[slaves.values.length - 1];\n', '        slaves.values[indexToDelete] = keyToMove;\n', '        slaves.keys[keyToMove] = indexToDelete;\n', '        slaves.values.length--;\n', '        delete slaves.keys[_linkedWallet];\n', '        delete slaveToMasterAddress[_linkedWallet];\n', '        WalletUnlinked(_masterWallet, _linkedWallet);\n', '    }\n', '\n', '    function getLinkedWallets(address _wallet) public view returns (address[]) {\n', '        return masterToSlaves[_wallet].slaves.values;\n', '    }\n', '\n', '    function isMasterWallet(address _addr) internal constant returns (bool) {\n', '        return masterToSlaves[_addr].hasValue;\n', '    }\n', '\n', '    function isLinkedWallet(address _addr) internal constant returns (bool) {\n', '        return slaveToMasterAddress[_addr] != address(0);\n', '    }\n', '\n', '    /**\n', '     * Guess that address book already had changing address.\n', '     */ \n', '    function applyChangeWalletAddress(address _old, address _new) internal {\n', '        require(isMasterWallet(_old) || isLinkedWallet(_old));\n', '        require(_new != address(0));\n', '        if (isMasterWallet(_old)) {\n', '            // Cannt change master address with existed linked\n', '            require(!isLinkedWallet(_new));\n', '            require(masterToSlaves[_new].slaves.values.length == 0);\n', '            changeMasterAddress(_old, _new);\n', '        }\n', '        else {\n', '            // Cannt change linked address with existed master and linked to another master\n', '            require(!isMasterWallet(_new) && !isLinkedWallet(_new));\n', '            changeLinkedAddress(_old, _new);\n', '        }\n', '    }\n', '\n', '    function changeLinkedAddress(address _old, address _new) private {\n', '        slaveToMasterAddress[_new] = slaveToMasterAddress[_old];     \n', '        SlaveDictionary storage slaves = masterToSlaves[slaveToMasterAddress[_new]].slaves;\n', '        uint index = slaves.keys[_old];\n', '        slaves.values[index] = _new;\n', '        delete slaveToMasterAddress[_old];\n', '    }\n', '    \n', '    function changeMasterAddress(address _old, address _new) private {    \n', '        masterToSlaves[_new] = masterToSlaves[_old];  \n', '        SlaveDictionary storage slaves = masterToSlaves[_new].slaves;\n', '        for (uint8 i = 0; i < slaves.values.length; ++i)\n', '            slaveToMasterAddress[slaves.values[i]] = _new;\n', '        delete masterToSlaves[_old];\n', '    }\n', '\n', '    function addMasterWallet(address _master) internal {\n', '        require(_master != address(0));\n', '        masterToSlaves[_master].hasValue = true;\n', '    }\n', '\n', '    function getMasterWallet(address _wallet) internal constant returns(address) {\n', '        if(isMasterWallet(_wallet))\n', '            return _wallet;\n', '        return slaveToMasterAddress[_wallet];  \n', '    }\n', '\n', '    /**\n', '     * Try to find master address by any other; otherwise add to address book as master.\n', '     */\n', '    function getOrAddMasterWallet(address _wallet) internal returns (address) {\n', '        address masterWallet = getMasterWallet(_wallet);\n', '        if (masterWallet == address(0))\n', '            addMasterWallet(_wallet);\n', '        return _wallet;\n', '    }\n', '}\n', '\n', 'contract CryptaurDepository is owned, AddressBook {\n', '    enum UnlimitedMode {UNLIMITED,LIMITED}\n', '\n', '    event Deposit(address indexed _who, uint _amount, bytes32 _txHash);\n', '    event Withdraw(address indexed _who, uint _amount);\n', '    event Payment(address indexed _buyer, address indexed _seller, uint _amount, address indexed _opinionLeader, bool _dapp);\n', '    event Freeze(address indexed _who, bool _freeze);\n', '    event Share(address indexed _who, address indexed _dapp, uint _amount);\n', '\n', '    ERC20Base cryptaurToken = ERC20Base(0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1);\n', '    address cryptaurRecovery;\n', '    address cryptaurRewards;\n', '    address cryptaurReserveFund;\n', '    address backend;\n', '    modifier onlyBackend {\n', '        require(backend == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrBackend {\n', '        require(owner == msg.sender || backend == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier notFreezed {\n', '        require(freezedAll != true);\n', '        _;\n', '    }\n', '\n', '    mapping(address => uint) internal balances;\n', '    mapping(address => mapping (address => uint256)) public available;\n', '    mapping(address => bool) public freezed;\n', '    mapping(address => mapping(address => UnlimitedMode)) public unlimitedMode;\n', '    bool freezedAll;\n', '  \n', '    function CryptaurDepository() owned() public {}\n', '\n', '    function balanceOf(address _who) constant public returns (uint) {\n', '        return balances[getMasterWallet(_who)];\n', '    }\n', '\n', '    function setUnlimitedMode(bool _unlimited, address _dapp) public {\n', '        address masterWallet = getOrAddMasterWallet(msg.sender);\n', '        unlimitedMode[masterWallet][_dapp] = _unlimited ? UnlimitedMode.UNLIMITED : UnlimitedMode.LIMITED;\n', '    }\n', '\n', '    function transferToToken(address[] _addresses) public onlyOwnerOrBackend {\n', '        for (uint index = 0; index < _addresses.length; index++) {\n', '            address addr = _addresses[index];\n', '            uint amount = balances[addr];\n', '            if (amount > 0) {\n', '                balances[addr] = 0;\n', '                cryptaurToken.transfer(addr, amount);\n', '                Withdraw(addr, amount);\n', '            }        \n', '        }\n', '    }\n', '\n', '    function setBackend(address _backend) onlyOwner public {\n', '        backend = _backend;\n', '    }\n', '\n', '    function setCryptaurRecovery(address _cryptaurRecovery) onlyOwner public {\n', '        cryptaurRecovery = _cryptaurRecovery;\n', '    }\n', '\n', '    function setCryptaurToken(address _cryptaurToken) onlyOwner public {\n', '        cryptaurToken = ERC20Base(_cryptaurToken);\n', '    }\n', '\n', '    function setCryptaurRewards(address _cryptaurRewards) onlyOwner public {\n', '        cryptaurRewards = _cryptaurRewards;\n', '    }\n', '\n', '    function setCryptaurReserveFund(address _cryptaurReserveFund) onlyOwner public {\n', '        cryptaurReserveFund = _cryptaurReserveFund;\n', '    }\n', '    \n', '    function changeAddress(address _old, address _new) public {\n', '        require(msg.sender == cryptaurRecovery);\n', '        applyChangeWalletAddress(_old, _new);\n', '\n', '        balances[_new] += balances[_old];\n', '        balances[_old] = 0;\n', '        AddressChanged(_old, _new);\n', '    }\n', '\n', '    function linkToMasterWallet(address _masterWaller, address _linkedWaller) public {\n', '        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);\n', '        linkToMasterWalletInternal(_masterWaller, _linkedWaller);\n', '    }\n', '\n', '    function unLinkFromMasterWallet(address _masterWaller, address _linkedWaller) public {\n', '        require(msg.sender == owner || msg.sender == backend || msg.sender == cryptaurRecovery);\n', '        unLinkFromMasterWalletInternal(_masterWaller, _linkedWaller);\n', '    }\n', '\n', '    function setMaxLinkedWalletCount(uint8 _newMaxCount) public onlyOwnerOrBackend {\n', '        maxLinkedWalletCount = _newMaxCount;\n', '    }\n', '    \n', '    function freeze(address _who, bool _freeze) onlyOwner public {\n', '        address masterWallet = getMasterWallet(_who);\n', '        if (masterWallet == address(0))\n', '            masterWallet = _who;\n', '        freezed[masterWallet] = _freeze;\n', '        Freeze(masterWallet, _freeze);\n', '    }\n', '\n', '    function freeze(bool _freeze) public onlyOwnerOrBackend {\n', '        freezedAll = _freeze;\n', '    }\n', '    \n', '    function deposit(address _who, uint _amount, bytes32 _txHash) onlyBackend public {\n', '        address masterWallet = getOrAddMasterWallet(_who);\n', '        balances[masterWallet] += _amount;\n', '        Deposit(masterWallet, _amount, _txHash);\n', '    }\n', '    \n', '    function withdraw(uint _amount) public notFreezed {\n', '        address masterWallet = getMasterWallet(msg.sender);   \n', '        require(balances[masterWallet] >= _amount);\n', '        require(!freezed[masterWallet]);\n', '        balances[masterWallet] -= _amount;\n', '        cryptaurToken.transfer(masterWallet, _amount);\n', '        Withdraw(masterWallet, _amount);\n', '    }\n', '\n', '    function balanceOf2(address _who, address _dapp) constant public returns (uint) { \n', '        return balanceOf2Internal(getMasterWallet(_who), _dapp);\n', '    }\n', '    \n', '    function balanceOf2Internal(address _who, address _dapp) constant internal returns (uint) {\n', '        uint avail;\n', '        if (!freezed[_who]) {\n', '            if (unlimitedMode[_who][_dapp] == UnlimitedMode.UNLIMITED) {\n', '                avail = balances[_who];\n', '            } \n', '            else {\n', '                avail = available[_who][_dapp];\n', '                if (avail > balances[_who])\n', '                    avail = balances[_who];\n', '            }\n', '        }\n', '        return avail;\n', '    }\n', '    /**\n', '     * @dev Function pay wrapper. Using only for dapp.\n', '     */\n', '    function pay2(address _seller, uint _amount, address _opinionLeader) public notFreezed {\n', '        address dapp = getOrAddMasterWallet(msg.sender);\n', '        address seller = getOrAddMasterWallet(_seller);\n', '        payInternal(dapp, seller, _amount, _opinionLeader);\n', '        available[seller][dapp] += _amount;\n', '    }\n', '\n', '    function pay(address _seller, uint _amount, address _opinionLeader) public notFreezed {\n', '        address buyer = getOrAddMasterWallet(msg.sender);\n', '        address seller = getOrAddMasterWallet(_seller);\n', '        payInternal(buyer, seller, _amount, _opinionLeader);\n', '    }\n', '    \n', '    /**\n', '     * @dev Common internal pay function.\n', '     * OpinionLeader is optional, can be zero.\n', '     */\n', '    function payInternal(address _buyer, address _seller, uint _amount, address _opinionLeader) internal {    \n', '        require(balances[_buyer] >= _amount);\n', '        uint fee;\n', '        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\n', '            fee = CryptaurRewards(cryptaurRewards).payment(_buyer, _seller, _amount, _opinionLeader);\n', '        }\n', '        balances[_buyer] -= _amount;\n', '        balances[_seller] += _amount - fee;\n', '        if (fee != 0) {\n', '            balances[cryptaurReserveFund] += fee;\n', '            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\n', '        }\n', '        Payment(_buyer, _seller, _amount, _opinionLeader, false);\n', '    }\n', '    \n', '    function payDAPP(address _buyer, uint _amount, address _opinionLeader) public notFreezed {\n', '        address buyerMasterWallet = getOrAddMasterWallet(_buyer);\n', '        require(balanceOf2Internal(buyerMasterWallet, msg.sender) >= _amount);\n', '        uint fee;\n', '        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\n', '            fee = CryptaurRewards(cryptaurRewards).payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader);\n', '        }\n', '        balances[buyerMasterWallet] -= _amount;\n', '        balances[msg.sender] += _amount - fee; \n', '        if (unlimitedMode[buyerMasterWallet][msg.sender] == UnlimitedMode.LIMITED)\n', '            available[buyerMasterWallet][msg.sender] -= _amount;\n', '        if (fee != 0) {\n', '            balances[cryptaurReserveFund] += fee;\n', '            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\n', '        }\n', '        Payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader, true);\n', '    }\n', '\n', '    function shareBalance(address _dapp, uint _amount) public notFreezed {\n', '        address masterWallet = getMasterWallet(msg.sender);\n', '        require(masterWallet != address(0));\n', '        available[masterWallet][_dapp] = _amount;\n', '        Share(masterWallet, _dapp, _amount);\n', '    }\n', '    \n', '    function transferFromFund(address _to, uint _amount) public {\n', '        require(msg.sender == owner || msg.sender == cryptaurRewards || msg.sender == backend);\n', '        require(cryptaurReserveFund != address(0));\n', '        require(balances[cryptaurReserveFund] >= _amount);\n', '        address masterWallet = getOrAddMasterWallet(_to);\n', '        balances[masterWallet] += _amount;\n', '        balances[cryptaurReserveFund] -= _amount;\n', '        CryputarReserveFund(cryptaurReserveFund).withdrawNotification(_amount);\n', '    }\n', '}\n', '\n', '// test only\n', 'contract CryptaurDepositoryTest is CryptaurDepository {\n', '    function CryptaurDepositoryTest() CryptaurDepository() {}\n', '\n', '    // test only\n', '    function testDrip(address _who, address _dapp, uint _amount) public {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        address masterWallet = getOrAddMasterWallet(_who);\n', '        balances[masterWallet] = _amount;\n', '        available[masterWallet][_dapp] = _amount;\n', '    }\n', '}']
