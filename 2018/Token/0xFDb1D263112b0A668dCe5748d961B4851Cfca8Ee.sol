['pragma solidity 0.4.18;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    *  Constructor\n', '    *\n', '    *  Sets contract owner to address of constructor caller\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *  Change Owner\n', '    *\n', '    *  Changes ownership of this contract. Only owner can call this method.\n', '    *\n', '    * @param newOwner - new owner&#39;s address\n', '    */\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        require(newOwner != owner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract FHFTokenInterface {\n', '    /* Public parameters of the token */\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;Forever Has Fallen&#39;;\n', '    string public symbol = &#39;FC&#39;;\n', '    uint8 public decimals = 18;\n', '\n', '    function approveCrowdsale(address _crowdsaleAddress) external;\n', '    function balanceOf(address _address) public constant returns (uint256 balance);\n', '    function vestedBalanceOf(address _address) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _currentValue, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract CrowdsaleParameters {\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // Configuration Independent Parameters\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '    struct AddressTokenAllocation {\n', '        address addr;\n', '        uint256 amount;\n', '    }\n', '\n', '    uint256 public maximumICOCap = 350e6;\n', '\n', '    // ICO period timestamps:\n', '    // 1525777200 = May 8, 2018. 11am GMT\n', '    // 1529406000 = June 19, 2018. 11am GMT\n', '    uint256 public generalSaleStartDate = 1525777200;\n', '    uint256 public generalSaleEndDate = 1529406000;\n', '\n', '    // Vesting\n', '    // 1592564400 = June 19, 2020. 11am GMT\n', '    uint32 internal vestingTeam = 1592564400;\n', '    // 1529406000 = Bounty to ico end date - June 19, 2018. 11am GMT\n', '    uint32 internal vestingBounty = 1529406000;\n', '\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // Production Config\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////\n', '    // QA Config\n', '    ///////////////////////////////////////////////////////////////////////////\n', '\n', '    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x265Fb686cdd2f9a853c519592078cC4d1718C15a, 350e6);\n', '    AddressTokenAllocation internal communityReserve =  AddressTokenAllocation(0x76d472C73681E3DF8a7fB3ca79E5f8915f9C5bA5, 450e6);\n', '    AddressTokenAllocation internal team =              AddressTokenAllocation(0x05d46150ceDF59ED60a86d5623baf522E0EB46a2, 170e6);\n', '    AddressTokenAllocation internal advisors =          AddressTokenAllocation(0x3d5fa25a3C0EB68690075eD810A10170e441413e, 48e5);\n', '    AddressTokenAllocation internal bounty =            AddressTokenAllocation(0xAc2099D2705434f75adA370420A8Dd397Bf7CCA1, 176e5);\n', '    AddressTokenAllocation internal administrative =    AddressTokenAllocation(0x438aB07D5EC30Dd9B0F370e0FE0455F93C95002e, 76e5);\n', '\n', '    address internal playersReserve = 0x8A40B0Cf87DaF12C689ADB5C74a1B2f23B3a33e1;\n', '}\n', '\n', 'contract FHFToken is Owned, CrowdsaleParameters, FHFTokenInterface {\n', '    /* Arrays of all balances, vesting, approvals, and approval uses */\n', '    mapping (address => uint256) private balances;              // Total token balances\n', '    mapping (address => uint256) private balancesEndIcoFreeze;  // Balances frozen for ICO end by address\n', '    mapping (address => uint256) private balances2yearFreeze;  // Balances frozen for 2 years after ICO end by address\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '    mapping (address => mapping (address => bool)) private allowanceUsed;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event VestingTransfer(address indexed from, address indexed to, uint256 value, uint256 vestingTime);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    event Issuance(uint256 _amount); // triggered when the total supply is increased\n', '    event Destruction(uint256 _amount); // triggered when the total supply is decreased\n', '    event NewFHFToken(address _token);\n', '\n', '    /* Miscellaneous */\n', '    uint256 public totalSupply = 0; // 1 000 000 000 when minted\n', '\n', '    /**\n', '    *  Constructor\n', '    *\n', '    *  Initializes contract with initial supply tokens to the creator of the contract\n', '    */\n', '    function FHFToken() public {\n', '        owner = msg.sender;\n', '\n', '        mintToken(generalSaleWallet);\n', '        mintToken(communityReserve);\n', '        mintToken(team);\n', '        mintToken(advisors);\n', '        mintToken(bounty);\n', '        mintToken(administrative);\n', '\n', '        NewFHFToken(address(this));\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *  1. Associate crowdsale contract address with this Token\n', '    *  2. Allocate general sale amount\n', '    *\n', '    * @param _crowdsaleAddress - crowdsale contract address\n', '    */\n', '    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\n', '        uint uintDecimals = decimals;\n', '        uint exponent = 10**uintDecimals;\n', '        uint amount = generalSaleWallet.amount * exponent;\n', '\n', '        allowed[generalSaleWallet.addr][_crowdsaleAddress] = amount;\n', '        Approval(generalSaleWallet.addr, _crowdsaleAddress, amount);\n', '    }\n', '\n', '    /**\n', '    *  Get token balance of an address\n', '    *\n', '    * @param _address - address to query\n', '    * @return Token balance of _address\n', '    */\n', '    function balanceOf(address _address) public constant returns (uint256 balance) {\n', '        return balances[_address];\n', '    }\n', '\n', '    /**\n', '    *  Get vested token balance of an address\n', '    *\n', '    * @param _address - address to query\n', '    * @return balance that has vested\n', '    */\n', '    function vestedBalanceOf(address _address) public constant returns (uint256 balance) {\n', '        if (now < vestingBounty) {\n', '            return balances[_address] - balances2yearFreeze[_address] - balancesEndIcoFreeze[_address];\n', '        }\n', '        if (now < vestingTeam) {\n', '            return balances[_address] - balances2yearFreeze[_address];\n', '        } else {\n', '            return balances[_address];\n', '        }\n', '    }\n', '\n', '    /**\n', '    *  Get token amount allocated for a transaction from _owner to _spender addresses\n', '    *\n', '    * @param _owner - owner address, i.e. address to transfer from\n', '    * @param _spender - spender address, i.e. address to transfer to\n', '    * @return Remaining amount allowed to be transferred\n', '    */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    *  Create token and credit it to target address\n', '    *  Created tokens need to vest\n', '    *\n', '    */\n', '    function mintToken(AddressTokenAllocation tokenAllocation) internal {\n', '        uint uintDecimals = decimals;\n', '        uint exponent = 10**uintDecimals;\n', '        uint mintedAmount = tokenAllocation.amount * exponent;\n', '\n', '        // Mint happens right here: Balance becomes non-zero from zero\n', '        balances[tokenAllocation.addr] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '\n', '        // Emit Issue and Transfer events\n', '        Issuance(mintedAmount);\n', '        Transfer(address(this), tokenAllocation.addr, mintedAmount);\n', '    }\n', '\n', '    /**\n', '    *  Allow another contract to spend some tokens on your behalf\n', '    *\n', '    * @param _spender - address to allocate tokens for\n', '    * @param _value - number of tokens to allocate\n', '    * @return True in case of success, otherwise false\n', '    */\n', '    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\n', '        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        allowanceUsed[msg.sender][_spender] = false;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  Allow another contract to spend some tokens on your behalf\n', '    *\n', '    * @param _spender - address to allocate tokens for\n', '    * @param _currentValue - current number of tokens approved for allocation\n', '    * @param _value - number of tokens to allocate\n', '    * @return True in case of success, otherwise false\n', '    */\n', '    function approve(address _spender, uint256 _currentValue, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _currentValue);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  Send coins from sender&#39;s address to address specified in parameters\n', '    *\n', '    * @param _to - address to send to\n', '    * @param _value - amount to send in Wei\n', '    */\n', '    function transfer(address _to, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\n', '        // Check if the sender has enough\n', '        require(vestedBalanceOf(msg.sender) >= _value);\n', '\n', '        // Subtract from the sender\n', '        // _value is never greater than balance of input validation above\n', '        balances[msg.sender] -= _value;\n', '\n', '        // Overflow is never possible due to input validation above\n', '        balances[_to] += _value;\n', '\n', '        // If tokens issued from this address need to vest (i.e. this address is a team pool), freeze them here\n', '        if ((msg.sender == bounty.addr) && (now < vestingBounty)) {\n', '            balancesEndIcoFreeze[_to] += _value;\n', '        }\n', '        if ((msg.sender == team.addr) && (now < vestingTeam)) {\n', '            balances2yearFreeze[_to] += _value;\n', '        }\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  A contract attempts to get the coins. Tokens should be previously allocated\n', '    *\n', '    * @param _to - address to transfer tokens to\n', '    * @param _from - address to transfer tokens from\n', '    * @param _value - number of tokens to transfer\n', '    * @return True in case of success, otherwise false\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {\n', '        // Check if the sender has enough\n', '        require(vestedBalanceOf(_from) >= _value);\n', '\n', '        // Check allowed\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Subtract from the sender\n', '        // _value is never greater than balance because of input validation above\n', '        balances[_from] -= _value;\n', '        // Add the same to the recipient\n', '        // Overflow is not possible because of input validation above\n', '        balances[_to] += _value;\n', '\n', '        // Deduct allocation\n', '        // _value is never greater than allowed amount because of input validation above\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        // If tokens issued from this address need to vest (i.e. this address is a team pool), freeze them here\n', '        if ((_from == bounty.addr) && (now < vestingBounty)) {\n', '            balancesEndIcoFreeze[_to] += _value;\n', '        }\n', '        if ((_from == team.addr) && (now < vestingTeam)) {\n', '            balances2yearFreeze[_to] += _value;\n', '        }\n', '\n', '        Transfer(_from, _to, _value);\n', '        allowanceUsed[_from][msg.sender] = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *  Default method\n', '    *\n', '    *  This unnamed function is called whenever someone tries to send ether to\n', '    *  it. Just revert transaction because there is nothing that Token can do\n', '    *  with incoming ether.\n', '    *\n', '    *  Missing payable modifier prevents accidental sending of ether\n', '    */\n', '    function() public {\n', '    }\n', '}']