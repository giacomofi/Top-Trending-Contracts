['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', ' *      abstraction called a &#39;slice&#39;. A slice represents a part of a string -\n', ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first &#39;.&#39;,\n', ' *      modifying s to only contain the remainder of the string after the &#39;.&#39;.\n', ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', ' *      `s.splitNew(&#39;.&#39;)` leaves s unmodified, and returns two values\n', ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (self & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (self & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (self & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (self & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-terminated utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', '     * @return A newly allocated string containing the slice&#39;s text.\n', '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to know whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly { b := and(mload(ptr), 0xFF) }\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if(b < 0xE0) {\n', '                ptr += 2;\n', '            } else if(b < 0xF0) {\n', '                ptr += 3;\n', '            } else if(b < 0xF8) {\n', '                ptr += 4;\n', '            } else if(b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice self, slice other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = uint256(-1); // 0xffff...\n', '                if(shortest < 32) {\n', '                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice self, slice other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice self, slice rune) internal pure returns (slice) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if(b < 0xE0) {\n', '            l = 2;\n', '        } else if(b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice self) internal pure returns (slice ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly { word:= mload(mload(add(self, 32))) }\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if(b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if(b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    event log_bytemask(bytes32 mask);\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := sha3(needleptr, needlelen) }\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := sha3(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := sha3(needleptr, needlelen) }\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := sha3(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice self, slice needle) internal pure returns (slice token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice self, slice needle) internal pure returns (slice token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice self, slice needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice self, slice needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice self, slice[] parts) internal pure returns (string) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for(uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        for(i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract SparksterToken is StandardToken, Ownable{\n', '\tusing strings for *;\n', '\tusing SafeMath for uint256;\n', '\tstruct Member {\n', '\t\tmapping(uint256 => uint256) weiBalance; // How much eth has this member contributed for this group?\n', '\t\tmapping(uint256 => uint256) tokenBalance; // The member&#39;s token balance in a specific group.\n', '\t\tint256 transferred; // The amount of tokens the member has transferred out or been transferred in. Sending tokens out will increase this value and accepting tokens in will decrease it. In other words, the more negative this value is, the more unlocked tokens the member holds.\n', '\t\tbool exists; // A flag to see if we have a record of this member or not.\n', '\t}\n', '\n', '\tstruct Group {\n', '\t\tbool distributed; // Whether or not tokens in this group have been distributed.\n', '\t\tbool distributing; // This flag is set when we first enter the distribute function and is there to prevent race conditions, since distribution might take a long time.\n', '\t\tbool unlocked; // Whether or not tokens in this group have been unlocked.\n', '\t\tuint256 ratio; // 1 eth:ratio tokens. This amount represents the decimal amount. ratio*10**decimal = ratio sparks.\n', '\t\tuint256 startTime; // Epoch of crowdsale start time.\n', '\t\tuint256 phase1endTime; // Epoch of phase1 end time.\n', '\t\tuint256 phase2endTime; // Epoch of phase2 end time.\n', '\t\tuint256 deadline; // No contributions allowed after this epoch.\n', '\t\tuint256 max2; // cap of phase2\n', '\t\tuint256 max3; // Total ether this group can collect in phase 3.\n', '\t\tuint256 weiTotal; // How much ether has this group collected?\n', '\t\tuint256 cap; // The hard ether cap.\n', '\t\tuint256 howManyDistributed;\n', '\t\tuint256 howManyTotal; // Total people in this group, set when distributing.\n', '\t}\n', '\n', '\taddress oracleAddress = 0xCb3405Fd5212C8B6a16DeFf9eBa49E69478A61b8;\n', '\tbool public transferLock = true; // A Global transfer lock. Set to lock down all tokens from all groups.\n', '\tbool public allowedToSell = false;\n', '\tbool public allowedToPurchase = false;\n', '\tstring public name;\t\t\t\t\t\t\t\t\t // name for display\n', '\tstring public symbol;\t\t\t\t\t\t\t\t //An identifier\n', '\tuint8 public decimals;\t\t\t\t\t\t\t//How many decimals to show.\n', '\tuint256 public penalty;\n', '\tuint256 public maxGasPrice; // The maximum allowed gas for the purchase function.\n', '\tuint256 internal nextGroupNumber;\n', '\tuint256 public sellPrice; // sellPrice wei:1 spark token; we won&#39;t allow to sell back parts of a token.\n', '\taddress[] internal allMembers;\t\n', '\taddress[] internal allNonMembers;\n', '\tmapping(address => bool) internal nonMemberTransfers;\n', '\tmapping(address => Member) internal members;\n', '\tmapping(uint256 => Group) internal groups;\n', '\tuint256 public openGroupNumber;\n', '\tevent WantsToPurchase(address walletAddress, uint256 weiAmount, uint256 groupNumber, bool inPhase1);\n', '\tevent WantsToDistribute(uint256 groupNumber, uint256 startIndex, uint256 endIndex);\n', '\tevent NearingHardCap(uint256 groupNumber, uint256 remainder);\n', '\tevent ReachedHardCap(uint256 groupNumber);\n', '\tevent DistributeDone(uint256 groupNumber);\n', '\tevent UnlockDone(uint256 groupNumber);\n', '\tevent GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);\n', '\tevent AddToGroup(address walletAddress, uint256 groupNumber);\n', '\tevent ChangedAllowedToSell(bool allowedToSell);\n', '\tevent ChangedAllowedToPurchase(bool allowedToPurchase);\n', '\tevent ChangedTransferLock(bool transferLock);\n', '\tevent SetSellPrice(uint256 sellPrice);\n', '\tevent SplitTokens(uint256 splitFactor);\n', '\tevent ReverseSplitTokens(uint256 splitFactor);\n', '\t\n', '\tmodifier onlyOracleBackend() {\n', '\t\trequire(msg.sender == oracleAddress);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t// Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', '\tmodifier onlyPayloadSize(uint size) {\t \n', '\t\trequire(msg.data.length == size + 4);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canTransfer() {\n', '\t\trequire(!transferLock);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canPurchase() {\n', '\t\trequire(allowedToPurchase);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canSell() {\n', '\t\trequire(allowedToSell);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction() public payable {\n', '\t\tpurchase();\n', '\t}\n', '\n', '\tconstructor() public {\n', '\t\tname = "Sparkster";\t\t\t\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tdecimals = 18;\t\t\t\t\t // Amount of decimals for display purposes\n', '\t\tsymbol = "SPRK";\t\t\t\t\t\t\t// Set the symbol for display purposes\n', '\t\tsetMaximumGasPrice(40);\n', '\t\t// Give all the tokens to the owner to start with.\n', '\t\tmintTokens(435000000);\n', '\t}\n', '\t\n', '\tfunction setOracleAddress(address newAddress) public onlyOwner returns(bool success) {\n', '\t\toracleAddress = newAddress;\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {\n', '\t\tmaxGasPrice = gweiPrice.mul(10**9); // Convert the gwei value to wei.\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction parseAddr(string _a) pure internal returns (address){ // From Oraclize\n', '\t\tbytes memory tmp = bytes(_a);\n', '\t\tuint160 iaddr = 0;\n', '\t\tuint160 b1;\n', '\t\tuint160 b2;\n', '\t\tfor (uint i=2; i<2+2*20; i+=2){\n', '\t\t\tiaddr *= 256;\n', '\t\t\tb1 = uint160(tmp[i]);\n', '\t\t\tb2 = uint160(tmp[i+1]);\n', '\t\t\tif ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n', '\t\t\telse if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n', '\t\t\tif ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n', '\t\t\telse if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n', '\t\t\tiaddr += (b1*16+b2);\n', '\t\t}\n', '\t\treturn address(iaddr);\n', '\t}\n', '\n', '\tfunction parseInt(string _a, uint _b) pure internal returns (uint) {\n', '\t\tbytes memory bresult = bytes(_a);\n', '\t\tuint mint = 0;\n', '\t\tbool decim = false;\n', '\t\tfor (uint i = 0; i < bresult.length; i++) {\n', '\t\t\tif ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n', '\t\t\t\tif (decim) {\n', '\t\t\t\t\tif (_b == 0) break;\n', '\t\t\t\t\t\telse _b--;\n', '\t\t\t\t}\n', '\t\t\t\tmint *= 10;\n', '\t\t\t\tmint += uint(bresult[i]) - 48;\n', '\t\t\t} else if (bresult[i] == 46) decim = true;\n', '\t\t}\n', '\t\treturn mint;\n', '\t}\n', '\n', '\tfunction mintTokens(uint256 amount) public onlyOwner {\n', '\t\t// Here, we&#39;ll consider amount to be the full token amount, so we have to get its decimal value.\n', '\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals);\n', '\t\ttotalSupply_ = totalSupply_.add(decimalAmount);\n', '\t\tbalances[msg.sender] = balances[msg.sender].add(decimalAmount);\n', '\t\temit Transfer(address(0), msg.sender, decimalAmount); // Per erc20 standards-compliance.\n', '\t}\n', '\t\n', '\tfunction purchase() public canPurchase payable returns(bool success) {\n', '\t\trequire(msg.sender != address(0)); // Don&#39;t allow the 0 address.\n', '\t\tMember storage memberRecord = members[msg.sender];\n', '\t\tGroup storage openGroup = groups[openGroupNumber];\n', '\t\trequire(openGroup.ratio > 0); // Group must be initialized.\n', '\t\tuint256 currentTimestamp = block.timestamp;\n', '\t\trequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //the timestamp must be greater than or equal to the start time and less than or equal to the deadline time\n', '\t\trequire(!openGroup.distributing && !openGroup.distributed); // member must exist; Don&#39;t allow to purchase if we&#39;re in the middle of distributing this group; Don&#39;t let someone buy tokens on the current group if that group is already distributed, unlocked or both; don&#39;t allow member to purchase if they&#39;re not part of the open group.\n', '\t\trequire(tx.gasprice <= maxGasPrice); // Restrict maximum gas this transaction is allowed to consume.\n', '\t\tuint256 weiAmount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The amount purchased by the current member\n', '\t\trequire(weiAmount >= 0.1 ether);\n', '\t\tuint256 weiTotal = openGroup.weiTotal.add(weiAmount); // Calculate total contribution of all members in this group.\n', '\t\trequire(weiTotal <= openGroup.cap);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check to see if accepting these funds will put us above the hard ether cap.\n', '\t\tuint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount);\t// Calculate the total amount purchased by the current member\n', '\t\tif(currentTimestamp <= openGroup.phase1endTime){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // whether the current timestamp is in the first phase\n', '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);\n', '\t\t\treturn true;\n', '\t\t} else if (currentTimestamp <= openGroup.phase2endTime) { // Are we in phase 2?\n', '\t\t\trequire(userWeiTotal <= openGroup.max2); // Allow to contribute no more than max2 in phase 2.\n', '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n', '\t\t\treturn true;\n', '\t\t} else { // We&#39;ve passed both phases 1 and 2.\n', '\t\t\trequire(userWeiTotal <= openGroup.max3); // Don&#39;t allow to contribute more than max3 in phase 3.\n', '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction purchaseCallback(string uploadedData) public onlyOracleBackend returns(bool success) {\n', '\t\t// We&#39;ll separate records by a | and individual entries in the record by a :.\n', '\t\tstrings.slice memory uploadedSlice = uploadedData.toSlice();\n', '\t\tstrings.slice memory nextRecord = "".toSlice();\n', '\t\tstrings.slice memory nextDatum = "".toSlice();\n', '\t\tstrings.slice memory recordSeparator = "|".toSlice();\n', '\t\tstrings.slice memory datumSeparator = ":".toSlice();\n', '\t\tuint256 amountForOwner = 0;\n', '\t\twhile (!uploadedSlice.empty()) {\n', '\t\t\tnextRecord = uploadedSlice.split(recordSeparator);\n', '\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\tuint256 accepted = parseInt(nextDatum.toString(), 0);\n', '\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\taddress theAddress = parseAddr(nextDatum.toString());\n', '\t\t\tif (accepted > 0) {\n', '\t\t\t\tMember storage memberRecord = members[theAddress];\n', '\t\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\t\tuint256 weiAmount = parseInt(nextDatum.toString(), 0);\n', '\t\t\t\tamountForOwner = amountForOwner.add(weiAmount);\n', '\t\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\t\tuint256 groupNumber = parseInt(nextDatum.toString(), 0);\n', '\t\t\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\t\t\tuint256 tokenAmount = weiAmount.mul(theGroup.ratio);\t\t\t\t\t\t //calculate member token amount.\n', '\t\t\t\ttheGroup.weiTotal = theGroup.weiTotal.add(weiAmount);\t\t\t\t\t\t\t\t // Calculate the total amount purchased by all members in this group.\n', '\t\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\t\t\t\t\t\t\t\t\t\t\t\t\t\t // Record the total amount purchased by the current member\n', '\t\t\t\tmemberRecord.tokenBalance[groupNumber] = memberRecord.tokenBalance[groupNumber].add(tokenAmount); // Update the member&#39;s token amount.\n', '\t\t\t\tbalances[owner] = balances[owner].sub(tokenAmount); // Update the available number of tokens.\n', '\t\t\t\tif (!memberRecord.exists) { // We&#39;re seeing this one for the first time.\n', '\t\t\t\t\tallMembers.push(theAddress);\n', '\t\t\t\t\tmemberRecord.exists = true;\n', '\t\t\t\t\tif (balances[theAddress] > 0) { // Don&#39;t inadvertently lock their previously held tokens before they became a member.\n', '\t\t\t\t\t\tmemberRecord.transferred = -int(balances[theAddress]);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t} else {\n', '\t\t\t\tif (penalty >= weiAmount) {\n', '\t\t\t\t\tamountForOwner = amountForOwner.add(penalty);\n', '\t\t\t\t\tweiAmount = weiAmount.sub(penalty);\n', '\t\t\t\t}\n', '\t\t\t\tif (address(this).balance >= weiAmount) {\n', '\t\t\t\t\ttheAddress.transfer(weiAmount);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif (internalGetHowMuchUntilHardCap(groupNumber) <= 100 ether) {\n', '\t\t\t\temit NearingHardCap(groupNumber, internalGetHowMuchUntilHardCap(groupNumber));\n', '\t\t\t}\n', '\t\t\tif (theGroup.weiTotal == theGroup.cap) {\n', '\t\t\t\temit ReachedHardCap(groupNumber);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (address(this).balance >= amountForOwner) {\n', '\t\t\towner.transfer(amountForOwner);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction drain() public onlyOwner {\n', '\t\towner.transfer(address(this).balance);\n', '\t}\n', '\t\n', '\tfunction setPenalty(uint256 newPenalty) public onlyOwner returns(bool success) {\n', '\t\tpenalty = newPenalty;\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction sell(uint256 amount) public canSell { // Can&#39;t sell unless owner has allowed it.\n', '\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals); // convert the full token value to the smallest unit possible.\n', '\t\tMember storage theMember = members[msg.sender];\n', '\t\tif (theMember.exists) { // If this seller exists, they have an unlocked balance we need to take care of.\n', '\t\t\tint256 sellValue = theMember.transferred + int(decimalAmount);\n', '\t\t\trequire(sellValue >= theMember.transferred); // Check for overflow.\n', '\t\t\trequire(sellValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they&#39;re not selling more than their unlocked amount.\n', '\t\t\ttheMember.transferred = sellValue;\n', '\t\t}\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(decimalAmount); // Do this before transferring to avoid re-entrance attacks; will throw if result < 0.\n', '\t\t// Amount is considered to be how many full tokens the user wants to sell.\n', '\t\tuint256 totalCost = amount.mul(sellPrice); // sellPrice is the per-full-token value.\n', '\t\trequire(address(this).balance >= totalCost); // The contract must have enough funds to cover the selling.\n', '\t\tbalances[owner] = balances[owner].add(decimalAmount); // Put these tokens back into the available pile.\n', '\t\tmsg.sender.transfer(totalCost); // Pay the seller for their tokens.\n', '\t\temit Transfer(msg.sender, owner, decimalAmount); // Notify exchanges of the sell.\n', '\t}\n', '\n', '\tfunction fundContract() public onlyOwner payable { // For the owner to put funds into the contract.\n', '\t}\n', '\n', '\tfunction setSellPrice(uint256 thePrice) public onlyOwner {\n', '\t\tsellPrice = thePrice;\n', '\t\temit SetSellPrice(sellPrice);\n', '\t}\n', '\t\n', '\tfunction setAllowedToSell(bool value) public onlyOwner {\n', '\t\tallowedToSell = value;\n', '\t\temit ChangedAllowedToSell(allowedToSell);\n', '\t}\n', '\n', '\tfunction setAllowedToPurchase(bool value) public onlyOwner {\n', '\t\tallowedToPurchase = value;\n', '\t\temit ChangedAllowedToPurchase(allowedToPurchase);\n', '\t}\n', '\t\n', '\tfunction createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n', '\t\tGroup storage theGroup = groups[nextGroupNumber];\n', '\t\ttheGroup.startTime = startEpoch;\n', '\t\ttheGroup.phase1endTime = phase1endEpoch;\n', '\t\ttheGroup.phase2endTime = phase2endEpoch;\n', '\t\ttheGroup.deadline = deadlineEpoch;\n', '\t\ttheGroup.max2 = phase2cap;\n', '\t\ttheGroup.max3 = phase3cap;\n', '\t\ttheGroup.cap = etherCap;\n', '\t\ttheGroup.ratio = ratio;\n', '\t\tcreatedGroupNumber = nextGroupNumber;\n', '\t\tnextGroupNumber++;\n', '\t\tsuccess = true;\n', '\t\temit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);\n', '\t}\n', '\n', '\tfunction createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n', '\t\treturn createGroup(0, 0, 0, 0, 0, 0, 0, 0);\n', '\t}\n', '\n', '\tfunction getGroup(uint256 groupNumber) public view returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 weiTotal, uint256 howManyDistributed) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\tdistributed = theGroup.distributed;\n', '\t\tunlocked = theGroup.unlocked;\n', '\t\tphase2cap = theGroup.max2;\n', '\t\tphase3cap = theGroup.max3;\n', '\t\tcap = theGroup.cap;\n', '\t\tratio = theGroup.ratio;\n', '\t\tstartTime = theGroup.startTime;\n', '\t\tphase1endTime = theGroup.phase1endTime;\n', '\t\tphase2endTime = theGroup.phase2endTime;\n', '\t\tdeadline = theGroup.deadline;\n', '\t\tweiTotal = theGroup.weiTotal;\n', '\t\thowManyDistributed = theGroup.howManyDistributed;\n', '\t}\n', '\t\n', '\tfunction internalGetHowMuchUntilHardCap(uint256 groupNumber) internal view returns(uint256 remainder) {\n', '\t\treturn groups[groupNumber].cap.sub(groups[groupNumber].weiTotal);\n', '\t}\n', '\t\n', '\tfunction getHowMuchUntilHardCap() public view returns(uint256 remainder) {\n', '\t\treturn internalGetHowMuchUntilHardCap(openGroupNumber);\n', '\t}\n', '\n', '\tfunction getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\thowManyLeftToDistribute = theGroup.howManyTotal - theGroup.howManyDistributed; // No need to use SafeMath here since we&#39;re guaranteed to not underflow on this line.\n', '\t}\n', '\t\n', '\tfunction addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {\n', '\t\temit AddToGroup(walletAddress, groupNumber);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction distribute(uint256 groupNumber, uint256 howMany) public onlyOwner {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\trequire(groupNumber < nextGroupNumber && !theGroup.distributed); // can&#39;t have already distributed\n', '\t\temit WantsToDistribute(groupNumber, theGroup.howManyDistributed, theGroup.howManyDistributed + howMany);\n', '\t}\n', '\t\n', '\tfunction distributeCallback(uint256 groupNumber, uint256 totalInGroup, address[] addresses) public onlyOracleBackend returns (bool success) {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\ttheGroup.distributing = true;\n', '\t\tuint256 n = addresses.length;\n', '\t\ttheGroup.howManyTotal = totalInGroup;\n', '\t\tfor (uint256 i = 0; i < n; i++) { // This section might be expensive in terms of gas cost!\n', '\t\t\taddress memberAddress = addresses[i];\n', '\t\t\tMember storage currentMember = members[memberAddress];\n', '\t\t\tuint256 balance = currentMember.tokenBalance[groupNumber];\n', '\t\t\tif (balance > 0) { // No need to waste ticks if they have no tokens to distribute\n', '\t\t\t\tbalances[memberAddress] = balances[memberAddress].add(balance);\n', '\t\t\t\temit Transfer(owner, memberAddress, balance); // Notify exchanges of the distribution.\n', '\t\t\t}\n', '\t\t}\n', '\t\ttheGroup.howManyDistributed = theGroup.howManyDistributed.add(n);\n', '\t\tif (theGroup.howManyDistributed == theGroup.howManyTotal) { // Done distributing all members.\n', '\t\t\ttheGroup.distributed = true;\n', '\t\t\ttheGroup.distributing = false;\n', '\t\t\temit DistributeDone(groupNumber);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\tif (!theMember.exists) {\n', '\t\t\treturn balances[walletAddress];\n', '\t\t}\n', '\t\tfor (uint256 i = 0; i < nextGroupNumber; i++) {\n', '\t\t\tif (groups[i].unlocked) {\n', '\t\t\t\tbalance = balance.add(theMember.tokenBalance[i]);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn balance;\n', '\t}\n', '\n', '\tfunction getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\tif (!theMember.exists) {\n', '\t\t\treturn balances[walletAddress];\n', '\t\t}\n', '\t\treturn uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);\n', '\t}\n', '\n', '\tfunction unlock(uint256 groupNumber) public onlyOwner returns (bool success) {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\trequire(theGroup.distributed); // Distribution must have occurred first.\n', '\t\ttheGroup.unlocked = true;\n', '\t\temit UnlockDone(groupNumber);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction setTransferLock(bool value) public onlyOwner {\n', '\t\ttransferLock = value;\n', '\t\temit ChangedTransferLock(transferLock);\n', '\t}\n', '\t\n', '\tfunction burn(uint256 amount) public onlyOwner {\n', '\t\t// Burns tokens from the owner&#39;s supply and doesn&#39;t touch allocated tokens.\n', '\t\t// Decrease totalSupply and leftOver by the amount to burn so we can decrease the circulation.\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(amount); // Will throw if result < 0\n', '\t\ttotalSupply_ = totalSupply_.sub(amount); // Will throw if result < 0\n', '\t\temit Transfer(msg.sender, address(0), amount);\n', '\t}\n', '\t\n', '\tfunction splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\t// SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks\n', '\t\tuint256 n = allMembers.length;\n', '\t\tuint256 ownerBalance = balances[msg.sender];\n', '\t\tuint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance); // We need to mint owner*splitFactor - owner additional tokens.\n', '\t\tbalances[msg.sender] = balances[msg.sender].mul(splitFactor);\n', '\t\ttotalSupply_ = totalSupply_.mul(splitFactor);\n', '\t\temit Transfer(address(0), msg.sender, increaseSupplyBy); // Notify exchange that we&#39;ve minted tokens.\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\tMember storage currentMember = members[allMembers[i]];\n', '\t\t\t// Take care of transferred balance.\n', '\t\t\tcurrentMember.transferred = currentMember.transferred * int(splitFactor);\n', '\t\t\t// Iterate over all of this user&#39;s balances for all groups. If a user is not a part of a group their balance will be 0.\n', '\t\t\tfor (uint256 j = 0; j < nextGroupNumber; j++) {\n', '\t\t\t\tuint256 memberBalance = currentMember.tokenBalance[j];\n', '\t\t\t\tuint256 multiplier = memberBalance.mul(splitFactor);\n', '\t\t\t\tcurrentMember.tokenBalance[j] = multiplier;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Next, increase group ratios by splitFactor, so users will receive ratio + splitFactor tokens per ether.\n', '\t\tn = nextGroupNumber;\n', '\t\trequire(n > 0); // Must have at least one group.\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\tGroup storage currentGroup = groups[i];\n', '\t\t\tcurrentGroup.ratio = currentGroup.ratio.mul(splitFactor);\n', '\t\t}\n', '\t\temit SplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\t// SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks\n', '\t\tuint256 n = allMembers.length;\n', '\t\tuint256 ownerBalance = balances[msg.sender];\n', '\t\tuint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));\n', '\t\t// We don&#39;t use burnTokens here since the amount to subtract might be more than what the owner currently holds in their unallocated supply which will cause the function to throw.\n', '\t\ttotalSupply_ = totalSupply_.div(splitFactor);\n', '\t\tbalances[msg.sender] = ownerBalance.div(splitFactor);\n', '\t\t// Notify the exchanges of how many tokens were burned.\n', '\t\temit Transfer(msg.sender, address(0), decreaseSupplyBy);\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\tMember storage currentMember = members[allMembers[i]];\n', '\t\t\t// Take care of the member&#39;s transferred balance.\n', '\t\t\tcurrentMember.transferred = currentMember.transferred / int(splitFactor);\n', '\t\t\tfor (uint256 j = 0; j < nextGroupNumber; j++) {\n', '\t\t\t\tuint256 memberBalance = currentMember.tokenBalance[j];\n', '\t\t\t\tuint256 divier = memberBalance.div(splitFactor);\n', '\t\t\t\tcurrentMember.tokenBalance[j] = divier;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Next, decrease group ratios by splitFactor, so users will receive ratio - splitFactor tokens per ether.\n', '\t\tn = nextGroupNumber;\n', '\t\trequire(n > 0); // Must have at least one group. Groups are 0-indexed.\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\tGroup storage currentGroup = groups[i];\n', '\t\t\tcurrentGroup.ratio = currentGroup.ratio.div(splitFactor);\n', '\t\t}\n', '\t\temit ReverseSplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\tsplitTokensBeforeDistribution(splitFactor);\n', '\t\tuint256 n = allMembers.length;\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\taddress currentMember = allMembers[i];\n', '\t\t\tuint256 memberBalance = balances[currentMember];\n', '\t\t\tif (memberBalance > 0) {\n', '\t\t\t\tuint256 multiplier1 = memberBalance.mul(splitFactor);\n', '\t\t\t\tuint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);\n', '\t\t\t\tbalances[currentMember] = multiplier1;\n', '\t\t\t\temit Transfer(address(0), currentMember, increaseMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\tn = allNonMembers.length;\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\taddress currentNonMember = allNonMembers[i];\n', '\t\t\t// If this address started out as a nonmember and then became a member, we&#39;ve seen them already in allMembers so don&#39;t grow or shrink them twice.\n', '\t\t\tif (members[currentNonMember].exists) {\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\t\t\tuint256 nonMemberBalance = balances[currentNonMember];\n', '\t\t\tif (nonMemberBalance > 0) {\n', '\t\t\t\tuint256 multiplier2 = nonMemberBalance.mul(splitFactor);\n', '\t\t\t\tuint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);\n', '\t\t\t\tbalances[currentNonMember] = multiplier2;\n', '\t\t\t\temit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\temit SplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\treverseSplitTokensBeforeDistribution(splitFactor);\n', '\t\tuint256 n = allMembers.length;\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\taddress currentMember = allMembers[i];\n', '\t\t\tuint256 memberBalance = balances[currentMember];\n', '\t\t\tif (memberBalance > 0) {\n', '\t\t\t\tuint256 divier1 = memberBalance.div(splitFactor);\n', '\t\t\t\tuint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);\n', '\t\t\t\tbalances[currentMember] = divier1;\n', '\t\t\t\temit Transfer(currentMember, address(0), decreaseMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\tn = allNonMembers.length;\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\taddress currentNonMember = allNonMembers[i];\n', '\t\t\t// If this address started out as a nonmember and then became a member, we&#39;ve seen them already in allMembers so don&#39;t grow or shrink them twice.\n', '\t\t\tif (members[currentNonMember].exists) {\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\t\t\tuint256 nonMemberBalance = balances[currentNonMember];\n', '\t\t\tif (nonMemberBalance > 0) {\n', '\t\t\t\tuint256 divier2 = nonMemberBalance.div(splitFactor);\n', '\t\t\t\tuint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);\n', '\t\t\t\tbalances[currentNonMember] = divier2;\n', '\t\t\t\temit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\temit ReverseSplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\t\t\n', '\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\n', '\t\tMember storage fromMember = members[msg.sender];\n', '\t\tif (fromMember.exists) { // If this is the owner, this check will be false so no need to check specifically for owner here.\n', '\t\t\tint256 transferValue = fromMember.transferred + int(_value);\n', '\t\t\trequire(transferValue >= fromMember.transferred); // Check for overflow.\n', '\t\t\trequire(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don&#39;t transfer out more than their unlocked limit.\n', '\t\t\tfromMember.transferred = transferValue;\n', '\t\t}\n', '\t\t// If any of the parties involved are not members, add them to the nonmembers list.\n', '\t\t// Don&#39;t add the owner, since they&#39;re a special case.\n', '\t\tif (!fromMember.exists && msg.sender != owner) {\n', '\t\t\tbool fromTransferee = nonMemberTransfers[msg.sender];\n', '\t\t\tif (!fromTransferee) { // If we haven&#39;t added this transferee before.\n', '\t\t\t\tnonMemberTransfers[msg.sender] = true;\n', '\t\t\t\tallNonMembers.push(msg.sender);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (!members[_to].exists && _to != owner) {\n', '\t\t\tbool toTransferee = nonMemberTransfers[_to];\n', '\t\t\tif (!toTransferee) { // If we haven&#39;t added this transferee before.\n', '\t\t\t\tnonMemberTransfers[_to] = true;\n', '\t\t\t\tallNonMembers.push(_to);\n', '\t\t\t}\n', '\t\t} else if (members[_to].exists) { // Add this transfer to the unlocked balance\n', '\t\t\tint256 transferInValue = members[_to].transferred - int(_value);\n', '\t\t\trequire(transferInValue <= members[_to].transferred); // Check for underflow.\n', '\t\t\tmembers[_to].transferred = transferInValue;\n', '\t\t}\n', '\t\treturn super.transfer(_to, _value);\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {\n', '\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\n', '\t\tMember storage fromMember = members[_from];\n', '\t\tif (fromMember.exists) { // If _from is the owner, this check will always fail, so we don&#39;t need to check specifically for owner here.\n', '\t\t\tint256 transferValue = fromMember.transferred + int(_value);\n', '\t\t\trequire(transferValue >= fromMember.transferred); // Check for overflow.\n', '\t\t\trequire(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don&#39;t transfer out more than their unlocked limit.\n', '\t\t\tfromMember.transferred = transferValue;\n', '\t\t}\n', '\t\t// If any of the parties involved are not members, add them to the nonmembers list.\n', '\t\t// Don&#39;t add the owner since they&#39;re a special case.\n', '\t\tif (!fromMember.exists && _from != owner) {\n', '\t\t\tbool fromTransferee = nonMemberTransfers[_from];\n', '\t\t\tif (!fromTransferee) { // If we haven&#39;t added this transferee before.\n', '\t\t\t\tnonMemberTransfers[_from] = true;\n', '\t\t\t\tallNonMembers.push(_from);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (!members[_to].exists && _to != owner) {\n', '\t\t\tbool toTransferee = nonMemberTransfers[_to];\n', '\t\t\tif (!toTransferee) { // If we haven&#39;t added this transferee before.\n', '\t\t\t\tnonMemberTransfers[_to] = true;\n', '\t\t\t\tallNonMembers.push(_to);\n', '\t\t\t}\n', '\t\t} else if (members[_to].exists) { // Add this transfer to the unlocked balance\n', '\t\t\tint256 transferInValue = members[_to].transferred - int(_value);\n', '\t\t\trequire(transferInValue <= members[_to].transferred); // Check for underflow.\n', '\t\t\tmembers[_to].transferred = transferInValue;\n', '\t\t}\n', '\t\treturn super.transferFrom(_from, _to, _value);\n', '\t}\n', '\n', '\tfunction setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\topenGroupNumber = groupNumber;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\trequire(theMember.exists);\n', '\t\tif (groups[groupNumber].distributed) // Here, the group will be distributed but tokenBalance will still have a value, so that we know how many tokens to allocate to the unlocked balance.\n', '\t\t\treturn 0;\n', '\t\treturn theMember.tokenBalance[groupNumber];\n', '\t}\n', '\n', '\tfunction checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\n', '\t\treturn getUndistributedBalanceOf(msg.sender, groupNumber);\n', '\t}\n', '\n', '\tfunction transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {\n', '\t\t// Will be used if someone sends tokens to an incorrect address by accident. This way, we have the ability to recover the tokens. For example, sometimes there&#39;s a problem of lost tokens if someone sends tokens to a contract address that can&#39;t utilize the tokens.\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value); // Authorize the owner to spend on someone&#39;s behalf.\n', '\t\tMember storage fromMember = members[_from];\n', '\t\tif (fromMember.exists) {\n', '\t\t\tint256 oldTransferred = fromMember.transferred;\n', '\t\t\tfromMember.transferred -= int(_value); // Unlock this amount.\n', '\t\t\trequire(oldTransferred >= fromMember.transferred); // Check for underflow.\n', '\t\t}\n', '\t\treturn transferFrom(_from, _to, _value);\n', '\t}\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', " *      abstraction called a 'slice'. A slice represents a part of a string -\n", ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first \'.\',\n', " *      modifying s to only contain the remainder of the string after the '.'.\n", ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', " *      `s.splitNew('.')` leaves s unmodified, and returns two values\n", ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string self) internal pure returns (slice) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (self & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (self & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (self & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (self & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-terminated utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice self) internal pure returns (slice) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', "     * @return A newly allocated string containing the slice's text.\n", '     */\n', '    function toString(slice self) internal pure returns (string) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to know whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly { b := and(mload(ptr), 0xFF) }\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if(b < 0xE0) {\n', '                ptr += 2;\n', '            } else if(b < 0xF0) {\n', '                ptr += 3;\n', '            } else if(b < 0xF8) {\n', '                ptr += 4;\n', '            } else if(b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice self, slice other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = uint256(-1); // 0xffff...\n', '                if(shortest < 32) {\n', '                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice self, slice other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice self, slice rune) internal pure returns (slice) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if(b < 0xE0) {\n', '            l = 2;\n', '        } else if(b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice self) internal pure returns (slice ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly { word:= mload(mload(add(self, 32))) }\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if(b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if(b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice self, slice needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice self, slice needle) internal pure returns (slice) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    event log_bytemask(bytes32 mask);\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := sha3(needleptr, needlelen) }\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := sha3(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := sha3(needleptr, needlelen) }\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := sha3(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice self, slice needle) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice self, slice needle) internal pure returns (slice token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice self, slice needle) internal pure returns (slice token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice self, slice needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice self, slice needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice self, slice other) internal pure returns (string) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice self, slice[] parts) internal pure returns (string) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for(uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        for(i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract SparksterToken is StandardToken, Ownable{\n', '\tusing strings for *;\n', '\tusing SafeMath for uint256;\n', '\tstruct Member {\n', '\t\tmapping(uint256 => uint256) weiBalance; // How much eth has this member contributed for this group?\n', "\t\tmapping(uint256 => uint256) tokenBalance; // The member's token balance in a specific group.\n", '\t\tint256 transferred; // The amount of tokens the member has transferred out or been transferred in. Sending tokens out will increase this value and accepting tokens in will decrease it. In other words, the more negative this value is, the more unlocked tokens the member holds.\n', '\t\tbool exists; // A flag to see if we have a record of this member or not.\n', '\t}\n', '\n', '\tstruct Group {\n', '\t\tbool distributed; // Whether or not tokens in this group have been distributed.\n', '\t\tbool distributing; // This flag is set when we first enter the distribute function and is there to prevent race conditions, since distribution might take a long time.\n', '\t\tbool unlocked; // Whether or not tokens in this group have been unlocked.\n', '\t\tuint256 ratio; // 1 eth:ratio tokens. This amount represents the decimal amount. ratio*10**decimal = ratio sparks.\n', '\t\tuint256 startTime; // Epoch of crowdsale start time.\n', '\t\tuint256 phase1endTime; // Epoch of phase1 end time.\n', '\t\tuint256 phase2endTime; // Epoch of phase2 end time.\n', '\t\tuint256 deadline; // No contributions allowed after this epoch.\n', '\t\tuint256 max2; // cap of phase2\n', '\t\tuint256 max3; // Total ether this group can collect in phase 3.\n', '\t\tuint256 weiTotal; // How much ether has this group collected?\n', '\t\tuint256 cap; // The hard ether cap.\n', '\t\tuint256 howManyDistributed;\n', '\t\tuint256 howManyTotal; // Total people in this group, set when distributing.\n', '\t}\n', '\n', '\taddress oracleAddress = 0xCb3405Fd5212C8B6a16DeFf9eBa49E69478A61b8;\n', '\tbool public transferLock = true; // A Global transfer lock. Set to lock down all tokens from all groups.\n', '\tbool public allowedToSell = false;\n', '\tbool public allowedToPurchase = false;\n', '\tstring public name;\t\t\t\t\t\t\t\t\t // name for display\n', '\tstring public symbol;\t\t\t\t\t\t\t\t //An identifier\n', '\tuint8 public decimals;\t\t\t\t\t\t\t//How many decimals to show.\n', '\tuint256 public penalty;\n', '\tuint256 public maxGasPrice; // The maximum allowed gas for the purchase function.\n', '\tuint256 internal nextGroupNumber;\n', "\tuint256 public sellPrice; // sellPrice wei:1 spark token; we won't allow to sell back parts of a token.\n", '\taddress[] internal allMembers;\t\n', '\taddress[] internal allNonMembers;\n', '\tmapping(address => bool) internal nonMemberTransfers;\n', '\tmapping(address => Member) internal members;\n', '\tmapping(uint256 => Group) internal groups;\n', '\tuint256 public openGroupNumber;\n', '\tevent WantsToPurchase(address walletAddress, uint256 weiAmount, uint256 groupNumber, bool inPhase1);\n', '\tevent WantsToDistribute(uint256 groupNumber, uint256 startIndex, uint256 endIndex);\n', '\tevent NearingHardCap(uint256 groupNumber, uint256 remainder);\n', '\tevent ReachedHardCap(uint256 groupNumber);\n', '\tevent DistributeDone(uint256 groupNumber);\n', '\tevent UnlockDone(uint256 groupNumber);\n', '\tevent GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);\n', '\tevent AddToGroup(address walletAddress, uint256 groupNumber);\n', '\tevent ChangedAllowedToSell(bool allowedToSell);\n', '\tevent ChangedAllowedToPurchase(bool allowedToPurchase);\n', '\tevent ChangedTransferLock(bool transferLock);\n', '\tevent SetSellPrice(uint256 sellPrice);\n', '\tevent SplitTokens(uint256 splitFactor);\n', '\tevent ReverseSplitTokens(uint256 splitFactor);\n', '\t\n', '\tmodifier onlyOracleBackend() {\n', '\t\trequire(msg.sender == oracleAddress);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t// Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', '\tmodifier onlyPayloadSize(uint size) {\t \n', '\t\trequire(msg.data.length == size + 4);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canTransfer() {\n', '\t\trequire(!transferLock);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canPurchase() {\n', '\t\trequire(allowedToPurchase);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier canSell() {\n', '\t\trequire(allowedToSell);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction() public payable {\n', '\t\tpurchase();\n', '\t}\n', '\n', '\tconstructor() public {\n', '\t\tname = "Sparkster";\t\t\t\t\t\t\t\t\t// Set the name for display purposes\n', '\t\tdecimals = 18;\t\t\t\t\t // Amount of decimals for display purposes\n', '\t\tsymbol = "SPRK";\t\t\t\t\t\t\t// Set the symbol for display purposes\n', '\t\tsetMaximumGasPrice(40);\n', '\t\t// Give all the tokens to the owner to start with.\n', '\t\tmintTokens(435000000);\n', '\t}\n', '\t\n', '\tfunction setOracleAddress(address newAddress) public onlyOwner returns(bool success) {\n', '\t\toracleAddress = newAddress;\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {\n', '\t\tmaxGasPrice = gweiPrice.mul(10**9); // Convert the gwei value to wei.\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction parseAddr(string _a) pure internal returns (address){ // From Oraclize\n', '\t\tbytes memory tmp = bytes(_a);\n', '\t\tuint160 iaddr = 0;\n', '\t\tuint160 b1;\n', '\t\tuint160 b2;\n', '\t\tfor (uint i=2; i<2+2*20; i+=2){\n', '\t\t\tiaddr *= 256;\n', '\t\t\tb1 = uint160(tmp[i]);\n', '\t\t\tb2 = uint160(tmp[i+1]);\n', '\t\t\tif ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n', '\t\t\telse if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n', '\t\t\tif ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n', '\t\t\telse if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n', '\t\t\tiaddr += (b1*16+b2);\n', '\t\t}\n', '\t\treturn address(iaddr);\n', '\t}\n', '\n', '\tfunction parseInt(string _a, uint _b) pure internal returns (uint) {\n', '\t\tbytes memory bresult = bytes(_a);\n', '\t\tuint mint = 0;\n', '\t\tbool decim = false;\n', '\t\tfor (uint i = 0; i < bresult.length; i++) {\n', '\t\t\tif ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n', '\t\t\t\tif (decim) {\n', '\t\t\t\t\tif (_b == 0) break;\n', '\t\t\t\t\t\telse _b--;\n', '\t\t\t\t}\n', '\t\t\t\tmint *= 10;\n', '\t\t\t\tmint += uint(bresult[i]) - 48;\n', '\t\t\t} else if (bresult[i] == 46) decim = true;\n', '\t\t}\n', '\t\treturn mint;\n', '\t}\n', '\n', '\tfunction mintTokens(uint256 amount) public onlyOwner {\n', "\t\t// Here, we'll consider amount to be the full token amount, so we have to get its decimal value.\n", '\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals);\n', '\t\ttotalSupply_ = totalSupply_.add(decimalAmount);\n', '\t\tbalances[msg.sender] = balances[msg.sender].add(decimalAmount);\n', '\t\temit Transfer(address(0), msg.sender, decimalAmount); // Per erc20 standards-compliance.\n', '\t}\n', '\t\n', '\tfunction purchase() public canPurchase payable returns(bool success) {\n', "\t\trequire(msg.sender != address(0)); // Don't allow the 0 address.\n", '\t\tMember storage memberRecord = members[msg.sender];\n', '\t\tGroup storage openGroup = groups[openGroupNumber];\n', '\t\trequire(openGroup.ratio > 0); // Group must be initialized.\n', '\t\tuint256 currentTimestamp = block.timestamp;\n', '\t\trequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //the timestamp must be greater than or equal to the start time and less than or equal to the deadline time\n', "\t\trequire(!openGroup.distributing && !openGroup.distributed); // member must exist; Don't allow to purchase if we're in the middle of distributing this group; Don't let someone buy tokens on the current group if that group is already distributed, unlocked or both; don't allow member to purchase if they're not part of the open group.\n", '\t\trequire(tx.gasprice <= maxGasPrice); // Restrict maximum gas this transaction is allowed to consume.\n', '\t\tuint256 weiAmount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The amount purchased by the current member\n', '\t\trequire(weiAmount >= 0.1 ether);\n', '\t\tuint256 weiTotal = openGroup.weiTotal.add(weiAmount); // Calculate total contribution of all members in this group.\n', '\t\trequire(weiTotal <= openGroup.cap);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check to see if accepting these funds will put us above the hard ether cap.\n', '\t\tuint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount);\t// Calculate the total amount purchased by the current member\n', '\t\tif(currentTimestamp <= openGroup.phase1endTime){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // whether the current timestamp is in the first phase\n', '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);\n', '\t\t\treturn true;\n', '\t\t} else if (currentTimestamp <= openGroup.phase2endTime) { // Are we in phase 2?\n', '\t\t\trequire(userWeiTotal <= openGroup.max2); // Allow to contribute no more than max2 in phase 2.\n', '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n', '\t\t\treturn true;\n', "\t\t} else { // We've passed both phases 1 and 2.\n", "\t\t\trequire(userWeiTotal <= openGroup.max3); // Don't allow to contribute more than max3 in phase 3.\n", '\t\t\temit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction purchaseCallback(string uploadedData) public onlyOracleBackend returns(bool success) {\n', "\t\t// We'll separate records by a | and individual entries in the record by a :.\n", '\t\tstrings.slice memory uploadedSlice = uploadedData.toSlice();\n', '\t\tstrings.slice memory nextRecord = "".toSlice();\n', '\t\tstrings.slice memory nextDatum = "".toSlice();\n', '\t\tstrings.slice memory recordSeparator = "|".toSlice();\n', '\t\tstrings.slice memory datumSeparator = ":".toSlice();\n', '\t\tuint256 amountForOwner = 0;\n', '\t\twhile (!uploadedSlice.empty()) {\n', '\t\t\tnextRecord = uploadedSlice.split(recordSeparator);\n', '\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\tuint256 accepted = parseInt(nextDatum.toString(), 0);\n', '\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\taddress theAddress = parseAddr(nextDatum.toString());\n', '\t\t\tif (accepted > 0) {\n', '\t\t\t\tMember storage memberRecord = members[theAddress];\n', '\t\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\t\tuint256 weiAmount = parseInt(nextDatum.toString(), 0);\n', '\t\t\t\tamountForOwner = amountForOwner.add(weiAmount);\n', '\t\t\t\tnextDatum = nextRecord.split(datumSeparator);\n', '\t\t\t\tuint256 groupNumber = parseInt(nextDatum.toString(), 0);\n', '\t\t\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\t\t\tuint256 tokenAmount = weiAmount.mul(theGroup.ratio);\t\t\t\t\t\t //calculate member token amount.\n', '\t\t\t\ttheGroup.weiTotal = theGroup.weiTotal.add(weiAmount);\t\t\t\t\t\t\t\t // Calculate the total amount purchased by all members in this group.\n', '\t\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\t\t\t\t\t\t\t\t\t\t\t\t\t\t // Record the total amount purchased by the current member\n', "\t\t\t\tmemberRecord.tokenBalance[groupNumber] = memberRecord.tokenBalance[groupNumber].add(tokenAmount); // Update the member's token amount.\n", '\t\t\t\tbalances[owner] = balances[owner].sub(tokenAmount); // Update the available number of tokens.\n', "\t\t\t\tif (!memberRecord.exists) { // We're seeing this one for the first time.\n", '\t\t\t\t\tallMembers.push(theAddress);\n', '\t\t\t\t\tmemberRecord.exists = true;\n', "\t\t\t\t\tif (balances[theAddress] > 0) { // Don't inadvertently lock their previously held tokens before they became a member.\n", '\t\t\t\t\t\tmemberRecord.transferred = -int(balances[theAddress]);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t} else {\n', '\t\t\t\tif (penalty >= weiAmount) {\n', '\t\t\t\t\tamountForOwner = amountForOwner.add(penalty);\n', '\t\t\t\t\tweiAmount = weiAmount.sub(penalty);\n', '\t\t\t\t}\n', '\t\t\t\tif (address(this).balance >= weiAmount) {\n', '\t\t\t\t\ttheAddress.transfer(weiAmount);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif (internalGetHowMuchUntilHardCap(groupNumber) <= 100 ether) {\n', '\t\t\t\temit NearingHardCap(groupNumber, internalGetHowMuchUntilHardCap(groupNumber));\n', '\t\t\t}\n', '\t\t\tif (theGroup.weiTotal == theGroup.cap) {\n', '\t\t\t\temit ReachedHardCap(groupNumber);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (address(this).balance >= amountForOwner) {\n', '\t\t\towner.transfer(amountForOwner);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction drain() public onlyOwner {\n', '\t\towner.transfer(address(this).balance);\n', '\t}\n', '\t\n', '\tfunction setPenalty(uint256 newPenalty) public onlyOwner returns(bool success) {\n', '\t\tpenalty = newPenalty;\n', '\t\treturn true;\n', '\t}\n', '\t\n', "\tfunction sell(uint256 amount) public canSell { // Can't sell unless owner has allowed it.\n", '\t\tuint256 decimalAmount = amount.mul(uint(10)**decimals); // convert the full token value to the smallest unit possible.\n', '\t\tMember storage theMember = members[msg.sender];\n', '\t\tif (theMember.exists) { // If this seller exists, they have an unlocked balance we need to take care of.\n', '\t\t\tint256 sellValue = theMember.transferred + int(decimalAmount);\n', '\t\t\trequire(sellValue >= theMember.transferred); // Check for overflow.\n', "\t\t\trequire(sellValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they're not selling more than their unlocked amount.\n", '\t\t\ttheMember.transferred = sellValue;\n', '\t\t}\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(decimalAmount); // Do this before transferring to avoid re-entrance attacks; will throw if result < 0.\n', '\t\t// Amount is considered to be how many full tokens the user wants to sell.\n', '\t\tuint256 totalCost = amount.mul(sellPrice); // sellPrice is the per-full-token value.\n', '\t\trequire(address(this).balance >= totalCost); // The contract must have enough funds to cover the selling.\n', '\t\tbalances[owner] = balances[owner].add(decimalAmount); // Put these tokens back into the available pile.\n', '\t\tmsg.sender.transfer(totalCost); // Pay the seller for their tokens.\n', '\t\temit Transfer(msg.sender, owner, decimalAmount); // Notify exchanges of the sell.\n', '\t}\n', '\n', '\tfunction fundContract() public onlyOwner payable { // For the owner to put funds into the contract.\n', '\t}\n', '\n', '\tfunction setSellPrice(uint256 thePrice) public onlyOwner {\n', '\t\tsellPrice = thePrice;\n', '\t\temit SetSellPrice(sellPrice);\n', '\t}\n', '\t\n', '\tfunction setAllowedToSell(bool value) public onlyOwner {\n', '\t\tallowedToSell = value;\n', '\t\temit ChangedAllowedToSell(allowedToSell);\n', '\t}\n', '\n', '\tfunction setAllowedToPurchase(bool value) public onlyOwner {\n', '\t\tallowedToPurchase = value;\n', '\t\temit ChangedAllowedToPurchase(allowedToPurchase);\n', '\t}\n', '\t\n', '\tfunction createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n', '\t\tGroup storage theGroup = groups[nextGroupNumber];\n', '\t\ttheGroup.startTime = startEpoch;\n', '\t\ttheGroup.phase1endTime = phase1endEpoch;\n', '\t\ttheGroup.phase2endTime = phase2endEpoch;\n', '\t\ttheGroup.deadline = deadlineEpoch;\n', '\t\ttheGroup.max2 = phase2cap;\n', '\t\ttheGroup.max3 = phase3cap;\n', '\t\ttheGroup.cap = etherCap;\n', '\t\ttheGroup.ratio = ratio;\n', '\t\tcreatedGroupNumber = nextGroupNumber;\n', '\t\tnextGroupNumber++;\n', '\t\tsuccess = true;\n', '\t\temit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);\n', '\t}\n', '\n', '\tfunction createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n', '\t\treturn createGroup(0, 0, 0, 0, 0, 0, 0, 0);\n', '\t}\n', '\n', '\tfunction getGroup(uint256 groupNumber) public view returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 weiTotal, uint256 howManyDistributed) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\tdistributed = theGroup.distributed;\n', '\t\tunlocked = theGroup.unlocked;\n', '\t\tphase2cap = theGroup.max2;\n', '\t\tphase3cap = theGroup.max3;\n', '\t\tcap = theGroup.cap;\n', '\t\tratio = theGroup.ratio;\n', '\t\tstartTime = theGroup.startTime;\n', '\t\tphase1endTime = theGroup.phase1endTime;\n', '\t\tphase2endTime = theGroup.phase2endTime;\n', '\t\tdeadline = theGroup.deadline;\n', '\t\tweiTotal = theGroup.weiTotal;\n', '\t\thowManyDistributed = theGroup.howManyDistributed;\n', '\t}\n', '\t\n', '\tfunction internalGetHowMuchUntilHardCap(uint256 groupNumber) internal view returns(uint256 remainder) {\n', '\t\treturn groups[groupNumber].cap.sub(groups[groupNumber].weiTotal);\n', '\t}\n', '\t\n', '\tfunction getHowMuchUntilHardCap() public view returns(uint256 remainder) {\n', '\t\treturn internalGetHowMuchUntilHardCap(openGroupNumber);\n', '\t}\n', '\n', '\tfunction getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', "\t\thowManyLeftToDistribute = theGroup.howManyTotal - theGroup.howManyDistributed; // No need to use SafeMath here since we're guaranteed to not underflow on this line.\n", '\t}\n', '\t\n', '\tfunction addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {\n', '\t\temit AddToGroup(walletAddress, groupNumber);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction distribute(uint256 groupNumber, uint256 howMany) public onlyOwner {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', "\t\trequire(groupNumber < nextGroupNumber && !theGroup.distributed); // can't have already distributed\n", '\t\temit WantsToDistribute(groupNumber, theGroup.howManyDistributed, theGroup.howManyDistributed + howMany);\n', '\t}\n', '\t\n', '\tfunction distributeCallback(uint256 groupNumber, uint256 totalInGroup, address[] addresses) public onlyOracleBackend returns (bool success) {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\ttheGroup.distributing = true;\n', '\t\tuint256 n = addresses.length;\n', '\t\ttheGroup.howManyTotal = totalInGroup;\n', '\t\tfor (uint256 i = 0; i < n; i++) { // This section might be expensive in terms of gas cost!\n', '\t\t\taddress memberAddress = addresses[i];\n', '\t\t\tMember storage currentMember = members[memberAddress];\n', '\t\t\tuint256 balance = currentMember.tokenBalance[groupNumber];\n', '\t\t\tif (balance > 0) { // No need to waste ticks if they have no tokens to distribute\n', '\t\t\t\tbalances[memberAddress] = balances[memberAddress].add(balance);\n', '\t\t\t\temit Transfer(owner, memberAddress, balance); // Notify exchanges of the distribution.\n', '\t\t\t}\n', '\t\t}\n', '\t\ttheGroup.howManyDistributed = theGroup.howManyDistributed.add(n);\n', '\t\tif (theGroup.howManyDistributed == theGroup.howManyTotal) { // Done distributing all members.\n', '\t\t\ttheGroup.distributed = true;\n', '\t\t\ttheGroup.distributing = false;\n', '\t\t\temit DistributeDone(groupNumber);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\tif (!theMember.exists) {\n', '\t\t\treturn balances[walletAddress];\n', '\t\t}\n', '\t\tfor (uint256 i = 0; i < nextGroupNumber; i++) {\n', '\t\t\tif (groups[i].unlocked) {\n', '\t\t\t\tbalance = balance.add(theMember.tokenBalance[i]);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn balance;\n', '\t}\n', '\n', '\tfunction getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\tif (!theMember.exists) {\n', '\t\t\treturn balances[walletAddress];\n', '\t\t}\n', '\t\treturn uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);\n', '\t}\n', '\n', '\tfunction unlock(uint256 groupNumber) public onlyOwner returns (bool success) {\n', '\t\tGroup storage theGroup = groups[groupNumber];\n', '\t\trequire(theGroup.distributed); // Distribution must have occurred first.\n', '\t\ttheGroup.unlocked = true;\n', '\t\temit UnlockDone(groupNumber);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction setTransferLock(bool value) public onlyOwner {\n', '\t\ttransferLock = value;\n', '\t\temit ChangedTransferLock(transferLock);\n', '\t}\n', '\t\n', '\tfunction burn(uint256 amount) public onlyOwner {\n', "\t\t// Burns tokens from the owner's supply and doesn't touch allocated tokens.\n", '\t\t// Decrease totalSupply and leftOver by the amount to burn so we can decrease the circulation.\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(amount); // Will throw if result < 0\n', '\t\ttotalSupply_ = totalSupply_.sub(amount); // Will throw if result < 0\n', '\t\temit Transfer(msg.sender, address(0), amount);\n', '\t}\n', '\t\n', '\tfunction splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\t// SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks\n', '\t\tuint256 n = allMembers.length;\n', '\t\tuint256 ownerBalance = balances[msg.sender];\n', '\t\tuint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance); // We need to mint owner*splitFactor - owner additional tokens.\n', '\t\tbalances[msg.sender] = balances[msg.sender].mul(splitFactor);\n', '\t\ttotalSupply_ = totalSupply_.mul(splitFactor);\n', "\t\temit Transfer(address(0), msg.sender, increaseSupplyBy); // Notify exchange that we've minted tokens.\n", '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\tMember storage currentMember = members[allMembers[i]];\n', '\t\t\t// Take care of transferred balance.\n', '\t\t\tcurrentMember.transferred = currentMember.transferred * int(splitFactor);\n', "\t\t\t// Iterate over all of this user's balances for all groups. If a user is not a part of a group their balance will be 0.\n", '\t\t\tfor (uint256 j = 0; j < nextGroupNumber; j++) {\n', '\t\t\t\tuint256 memberBalance = currentMember.tokenBalance[j];\n', '\t\t\t\tuint256 multiplier = memberBalance.mul(splitFactor);\n', '\t\t\t\tcurrentMember.tokenBalance[j] = multiplier;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Next, increase group ratios by splitFactor, so users will receive ratio + splitFactor tokens per ether.\n', '\t\tn = nextGroupNumber;\n', '\t\trequire(n > 0); // Must have at least one group.\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\tGroup storage currentGroup = groups[i];\n', '\t\t\tcurrentGroup.ratio = currentGroup.ratio.mul(splitFactor);\n', '\t\t}\n', '\t\temit SplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\t// SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks\n', '\t\tuint256 n = allMembers.length;\n', '\t\tuint256 ownerBalance = balances[msg.sender];\n', '\t\tuint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));\n', "\t\t// We don't use burnTokens here since the amount to subtract might be more than what the owner currently holds in their unallocated supply which will cause the function to throw.\n", '\t\ttotalSupply_ = totalSupply_.div(splitFactor);\n', '\t\tbalances[msg.sender] = ownerBalance.div(splitFactor);\n', '\t\t// Notify the exchanges of how many tokens were burned.\n', '\t\temit Transfer(msg.sender, address(0), decreaseSupplyBy);\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\tMember storage currentMember = members[allMembers[i]];\n', "\t\t\t// Take care of the member's transferred balance.\n", '\t\t\tcurrentMember.transferred = currentMember.transferred / int(splitFactor);\n', '\t\t\tfor (uint256 j = 0; j < nextGroupNumber; j++) {\n', '\t\t\t\tuint256 memberBalance = currentMember.tokenBalance[j];\n', '\t\t\t\tuint256 divier = memberBalance.div(splitFactor);\n', '\t\t\t\tcurrentMember.tokenBalance[j] = divier;\n', '\t\t\t}\n', '\t\t}\n', '\t\t// Next, decrease group ratios by splitFactor, so users will receive ratio - splitFactor tokens per ether.\n', '\t\tn = nextGroupNumber;\n', '\t\trequire(n > 0); // Must have at least one group. Groups are 0-indexed.\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\tGroup storage currentGroup = groups[i];\n', '\t\t\tcurrentGroup.ratio = currentGroup.ratio.div(splitFactor);\n', '\t\t}\n', '\t\temit ReverseSplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\tsplitTokensBeforeDistribution(splitFactor);\n', '\t\tuint256 n = allMembers.length;\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\taddress currentMember = allMembers[i];\n', '\t\t\tuint256 memberBalance = balances[currentMember];\n', '\t\t\tif (memberBalance > 0) {\n', '\t\t\t\tuint256 multiplier1 = memberBalance.mul(splitFactor);\n', '\t\t\t\tuint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);\n', '\t\t\t\tbalances[currentMember] = multiplier1;\n', '\t\t\t\temit Transfer(address(0), currentMember, increaseMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\tn = allNonMembers.length;\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\taddress currentNonMember = allNonMembers[i];\n', "\t\t\t// If this address started out as a nonmember and then became a member, we've seen them already in allMembers so don't grow or shrink them twice.\n", '\t\t\tif (members[currentNonMember].exists) {\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\t\t\tuint256 nonMemberBalance = balances[currentNonMember];\n', '\t\t\tif (nonMemberBalance > 0) {\n', '\t\t\t\tuint256 multiplier2 = nonMemberBalance.mul(splitFactor);\n', '\t\t\t\tuint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);\n', '\t\t\t\tbalances[currentNonMember] = multiplier2;\n', '\t\t\t\temit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\temit SplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n', '\t\treverseSplitTokensBeforeDistribution(splitFactor);\n', '\t\tuint256 n = allMembers.length;\n', '\t\tfor (uint256 i = 0; i < n; i++) {\n', '\t\t\taddress currentMember = allMembers[i];\n', '\t\t\tuint256 memberBalance = balances[currentMember];\n', '\t\t\tif (memberBalance > 0) {\n', '\t\t\t\tuint256 divier1 = memberBalance.div(splitFactor);\n', '\t\t\t\tuint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);\n', '\t\t\t\tbalances[currentMember] = divier1;\n', '\t\t\t\temit Transfer(currentMember, address(0), decreaseMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\tn = allNonMembers.length;\n', '\t\tfor (i = 0; i < n; i++) {\n', '\t\t\taddress currentNonMember = allNonMembers[i];\n', "\t\t\t// If this address started out as a nonmember and then became a member, we've seen them already in allMembers so don't grow or shrink them twice.\n", '\t\t\tif (members[currentNonMember].exists) {\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\t\t\tuint256 nonMemberBalance = balances[currentNonMember];\n', '\t\t\tif (nonMemberBalance > 0) {\n', '\t\t\t\tuint256 divier2 = nonMemberBalance.div(splitFactor);\n', '\t\t\t\tuint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);\n', '\t\t\t\tbalances[currentNonMember] = divier2;\n', '\t\t\t\temit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);\n', '\t\t\t}\n', '\t\t}\n', '\t\temit ReverseSplitTokens(splitFactor);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\t\t\n', '\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\n', '\t\tMember storage fromMember = members[msg.sender];\n', '\t\tif (fromMember.exists) { // If this is the owner, this check will be false so no need to check specifically for owner here.\n', '\t\t\tint256 transferValue = fromMember.transferred + int(_value);\n', '\t\t\trequire(transferValue >= fromMember.transferred); // Check for overflow.\n', "\t\t\trequire(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don't transfer out more than their unlocked limit.\n", '\t\t\tfromMember.transferred = transferValue;\n', '\t\t}\n', '\t\t// If any of the parties involved are not members, add them to the nonmembers list.\n', "\t\t// Don't add the owner, since they're a special case.\n", '\t\tif (!fromMember.exists && msg.sender != owner) {\n', '\t\t\tbool fromTransferee = nonMemberTransfers[msg.sender];\n', "\t\t\tif (!fromTransferee) { // If we haven't added this transferee before.\n", '\t\t\t\tnonMemberTransfers[msg.sender] = true;\n', '\t\t\t\tallNonMembers.push(msg.sender);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (!members[_to].exists && _to != owner) {\n', '\t\t\tbool toTransferee = nonMemberTransfers[_to];\n', "\t\t\tif (!toTransferee) { // If we haven't added this transferee before.\n", '\t\t\t\tnonMemberTransfers[_to] = true;\n', '\t\t\t\tallNonMembers.push(_to);\n', '\t\t\t}\n', '\t\t} else if (members[_to].exists) { // Add this transfer to the unlocked balance\n', '\t\t\tint256 transferInValue = members[_to].transferred - int(_value);\n', '\t\t\trequire(transferInValue <= members[_to].transferred); // Check for underflow.\n', '\t\t\tmembers[_to].transferred = transferInValue;\n', '\t\t}\n', '\t\treturn super.transfer(_to, _value);\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {\n', '\t\t// If the transferrer has purchased tokens, they must be unlocked before they can be used.\n', '\t\tMember storage fromMember = members[_from];\n', "\t\tif (fromMember.exists) { // If _from is the owner, this check will always fail, so we don't need to check specifically for owner here.\n", '\t\t\tint256 transferValue = fromMember.transferred + int(_value);\n', '\t\t\trequire(transferValue >= fromMember.transferred); // Check for overflow.\n', "\t\t\trequire(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don't transfer out more than their unlocked limit.\n", '\t\t\tfromMember.transferred = transferValue;\n', '\t\t}\n', '\t\t// If any of the parties involved are not members, add them to the nonmembers list.\n', "\t\t// Don't add the owner since they're a special case.\n", '\t\tif (!fromMember.exists && _from != owner) {\n', '\t\t\tbool fromTransferee = nonMemberTransfers[_from];\n', "\t\t\tif (!fromTransferee) { // If we haven't added this transferee before.\n", '\t\t\t\tnonMemberTransfers[_from] = true;\n', '\t\t\t\tallNonMembers.push(_from);\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (!members[_to].exists && _to != owner) {\n', '\t\t\tbool toTransferee = nonMemberTransfers[_to];\n', "\t\t\tif (!toTransferee) { // If we haven't added this transferee before.\n", '\t\t\t\tnonMemberTransfers[_to] = true;\n', '\t\t\t\tallNonMembers.push(_to);\n', '\t\t\t}\n', '\t\t} else if (members[_to].exists) { // Add this transfer to the unlocked balance\n', '\t\t\tint256 transferInValue = members[_to].transferred - int(_value);\n', '\t\t\trequire(transferInValue <= members[_to].transferred); // Check for underflow.\n', '\t\t\tmembers[_to].transferred = transferInValue;\n', '\t\t}\n', '\t\treturn super.transferFrom(_from, _to, _value);\n', '\t}\n', '\n', '\tfunction setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {\n', '\t\trequire(groupNumber < nextGroupNumber);\n', '\t\topenGroupNumber = groupNumber;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\n', '\t\tMember storage theMember = members[walletAddress];\n', '\t\trequire(theMember.exists);\n', '\t\tif (groups[groupNumber].distributed) // Here, the group will be distributed but tokenBalance will still have a value, so that we know how many tokens to allocate to the unlocked balance.\n', '\t\t\treturn 0;\n', '\t\treturn theMember.tokenBalance[groupNumber];\n', '\t}\n', '\n', '\tfunction checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\n', '\t\treturn getUndistributedBalanceOf(msg.sender, groupNumber);\n', '\t}\n', '\n', '\tfunction transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {\n', "\t\t// Will be used if someone sends tokens to an incorrect address by accident. This way, we have the ability to recover the tokens. For example, sometimes there's a problem of lost tokens if someone sends tokens to a contract address that can't utilize the tokens.\n", "\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value); // Authorize the owner to spend on someone's behalf.\n", '\t\tMember storage fromMember = members[_from];\n', '\t\tif (fromMember.exists) {\n', '\t\t\tint256 oldTransferred = fromMember.transferred;\n', '\t\t\tfromMember.transferred -= int(_value); // Unlock this amount.\n', '\t\t\trequire(oldTransferred >= fromMember.transferred); // Check for underflow.\n', '\t\t}\n', '\t\treturn transferFrom(_from, _to, _value);\n', '\t}\n', '}']
