['pragma solidity ^0.4.18;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\tif (a == 0) {\n', '  \treturn 0;\n', '\t}\n', '\tuint256 c = a * b;\n', '\tassert(c / a == b);\n', '\treturn c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\tuint256 c = a / b;\n', '\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\treturn c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\tassert(b <= a);\n', '\treturn a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\tuint256 c = a + b;\n', '\tassert(c >= a);\n', '\treturn c;\n', '  }\n', '}\n', 'contract owned {\n', '\taddress public owner;\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '\tfunction owned() public {\n', '    \towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '    \trequire(msg.sender == owner);\n', '    \t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner public {\n', '    \trequire(newOwner != address(0));\n', '    \tOwnershipTransferred(owner, newOwner);\n', '    \towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract Pausable is owned {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '\trequire(!paused);\n', '\t_;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '\trequire(paused);\n', '\t_;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '\tpaused = true;\n', '\tPause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '\tpaused = false;\n', '\tUnpause();\n', '  }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', 'interface ERC20Token {\n', '\n', ' \n', '\n', '\t/// @param _owner The address from which the balance will be retrieved\n', '\t/// @return The balance\n', '\tfunction balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '\t/// @notice send `_value` token to `_to` from `msg.sender`\n', '\t/// @param _to The address of the recipient\n', '\t/// @param _value The amount of token to be transferred\n', '\t/// @return Whether the transfer was successful or not\n', '\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '\t/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '\t/// @param _from The address of the sender\n', '\t/// @param _to The address of the recipient\n', '\t/// @param _value The amount of token to be transferred\n', '\t/// @return Whether the transfer was successful or not\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    \n', '\n', '\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '}\n', '\n', '\n', '\n', 'contract StandardToken is ERC20Token, Pausable {\n', ' using SafeMath for uint;\n', '  modifier onlyPayloadSize(uint size) {\n', ' \tassert(msg.data.length == size.add(4));\n', ' \t_;\n', '   }\n', '\n', '\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) whenNotPaused external returns (bool success) {\n', '    \t//Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '    \t//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '    \t//Replace the if with this one instead.\n', '    \t//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    \tif (balances[msg.sender] >= _value && _value > 0) {\n', '        \tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '        \tbalances[_to] = balances[_to].add(_value);\n', '        \tTransfer(msg.sender, _to, _value);\n', '        \treturn true;\n', '    \t} else { return false; }\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(2 * 32) whenNotPaused external returns (bool success) {\n', '    \t//same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '    \t//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    \tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        \tbalances[_to] = balances[_to].add(_value);\n', '        \tbalances[_from] = balances[_from].sub(_value);\n', '        \tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        \tTransfer(_from, _to, _value);\n', '        \treturn true;\n', '    \t} else { return false; }\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner) constant external returns (uint256 balance) {\n', '    \treturn balances[_owner];\n', '\t}\n', '    \n', '\t/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '\t/// @param _spender The address of the account able to transfer the tokens\n', '\t/// @param _value The amount of wei to be approved for transfer\n', '\t/// @return Whether the approval was successful or not\n', '\tfunction approve(address _spender, uint256 _value) whenNotPaused public returns (bool success) {\n', '    \trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    \tallowed[msg.sender][_spender] = _value;\n', '    \tApproval(msg.sender, _spender, _value);\n', '    \treturn true;\n', '\t}\n', '\n', '\n', '   \n', '\t/// @param _owner The address of the account owning tokens\n', '\t/// @param _spender The address of the account able to transfer the tokens\n', '\t/// @return Amount of remaining tokens allowed to spent\n', '\tfunction allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '  \treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\tmapping (address => uint256) balances;\n', '\tmapping (address => mapping (address => uint256)) allowed;\n', '\tuint256 public _totalSupply;\n', '}\n', '\n', '\n', '//name this contract whatever you&#39;d like\n', 'contract Cryptoya is StandardToken{\n', ' using SafeMath for uint;\n', '\n', '\n', '\t/* Public variables of the token */\n', '\n', '\t/*\n', '\tNOTE:\n', '\tThe following variables are OPTIONAL vanities. One does not have to include them.\n', '\tThey allow one to customise the token contract & in no way influences the core functionality.\n', '\tSome wallets/interfaces might not even bother to look at this information.\n', '\t*/\n', '\tstring public name;               \t//fancy name: eg Simon Bucks\n', '\tuint8 public decimals;            \t//How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&#39;s like comparing 1 wei to 1 ether.\n', '\tstring public symbol;             \t//An identifier: eg SBX\n', '\tstring public version = &#39;V1.0&#39;;   \t//Version 0.1 standard. Just an arbitrary versioning scheme.\n', '\tuint256 private fulltoken;\n', '\t// This notifies clients about the amount burnt\n', '\tevent Burn(address indexed from, uint256 value);\n', '    \n', '//\n', '// CHANGE THESE VALUES FOR YOUR TOKEN\n', '//\n', '\n', '//make sure this function name matches the contract name above. ERC20Token\n', '\n', '\tfunction Cryptoya(\n', '    \t) public{\n', '    \tfulltoken = 500000000;  \t \n', '    \tdecimals = 18;                        \t// Amount of decimals for display purposes\n', '    \t_totalSupply = fulltoken.mul(10 ** uint256(decimals)); // Update total supply (100000 for example)\n', '    \tbalances[msg.sender] = _totalSupply;           \t// Give the creator all initial tokens (100000 for example)\n', '    \tname = "Cryptoya";                               \t// Set the name for display purposes\n', '    \tsymbol = "CRA";                           \t// Set the symbol for display purposes\n', '\t}\n', ' \tfunction() public {\n', '     \t//not payable fallback function\n', '      \trevert();\n', '\t}\n', '    \t/**\n', ' \t* Set allowance for other address and notify\n', ' \t*\n', ' \t* Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', ' \t*\n', ' \t* @param _spender The address authorized to spend\n', ' \t* @param _value the max amount they can spend\n', ' \t* @param _extraData some extra information to send to the approved contract\n', ' \t*/\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '    \ttokenRecipient spender = tokenRecipient(_spender);\n', '    \tif (approve(_spender, _value)) {\n', '        \tspender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        \treturn true;\n', '       \t}\n', '\t}\n', '    \n', '  \t/// @return total amount of tokens\n', '\tfunction totalSupply() constant public returns (uint256 supply){\n', '   \t \n', '    \treturn _totalSupply;\n', '\t}\n', '\n', '\t/**\n', ' \t* Destroy tokens\n', ' \t*\n', ' \t* Remove `_value` tokens from the system irreversibly\n', ' \t*\n', ' \t* @param _value the amount of money to burn\n', ' \t*/\n', '\tfunction burn(uint256 _value) onlyOwner public returns (bool success) {\n', '    \trequire(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '    \tbalances[msg.sender] = balances[msg.sender].sub(_value);        \t// Subtract from the sender\n', '    \t_totalSupply = _totalSupply.sub(_value);                  \t// Updates totalSupply\n', '    \tBurn(msg.sender, _value);\n', '    \tTransfer(msg.sender, address(0), _value);\n', '    \treturn true;\n', '\t}\n', '\n', '\t/**\n', ' \t* Destroy tokens from other account\n', ' \t*\n', ' \t* Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', ' \t*\n', ' \t* @param _from the address of the sender\n', ' \t* @param _value the amount of money to burn\n', ' \t*/\n', '\tfunction burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {\n', '    \trequire(balances[_from] >= _value);            \t// Check if the targeted balance is enough\n', '    \trequire(_value <= allowed[_from][msg.sender]);\t// Check allowance\n', '    \tbalances[_from] = balances[_from].sub(_value);                     \t// Subtract from the targeted balance\n', '    \tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);         \t// Subtract from the sender&#39;s allowance\n', '    \t_totalSupply = _totalSupply.sub(_value);                          \t// Update totalSupply\n', '    \tBurn(_from, _value);\n', '    \tTransfer(_from, address(0), _value);\n', '    \treturn true;\n', '\t}\n', ' \tfunction onlyPayForFuel() public payable onlyOwner{\n', '    \t// Owner will pay in contract to bear the gas price if transactions made from contract\n', '   \t \n', '\t}\n', '\tfunction withdrawEtherFromcontract(uint _amountineth) public onlyOwner{\n', '    \tuint _amountInwei = _amountineth.mul(10 ** 18);\n', '    \trequire(this.balance > _amountInwei);\n', '  \trequire(msg.sender == owner);\n', '  \towner.transfer(_amountInwei);\n', '\t \n', '\t}\n', '     function withdrawTokensFromContract(uint _amountOfTokens) public onlyOwner{\n', '    \trequire(balances[this] > _amountOfTokens);\n', '    \trequire(msg.sender == owner);\n', '    \tbalances[msg.sender] = balances[msg.sender].add(_amountOfTokens);                    \t// adds the amount to owner&#39;s balance\n', '    \tbalances[this] = balances[this].sub(_amountOfTokens);              \t// subtracts the amount from contract balance\n', '   \t Transfer(this, msg.sender, _amountOfTokens);           \t// execute an event reflecting the change\n', '\t \n', '\t}\n', ' \t \n', '}']