['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    modifier onlyOwner { require(msg.sender == owner); _; }\n', '    event Ownership(address _prevOwner, address _newOwner, uint _timestamp);\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit Ownership(owner, newOwner, now);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\tevent FreezeAccount(address indexed _target, bool _frozen, uint _timestamp);\n', '\tevent CertifyAccount(address indexed _target, bool _certified, uint _timestamp);\n', '}\n', '\n', 'contract ERC20Token is ERC20 {\n', '    using SafeMath for uint;\n', '    uint public totalToken;\n', '\tbool public frozen;\n', '    mapping(address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowances;\n', '\tmapping (address => bool) public frozenAccounts;\n', '\tmapping (address => bool) public certifiedAccounts;\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '\t\trequire(_from != 0x0 && _to != 0x0);\n', '        require(balances[_from] >= _value && _value > 0);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\t\trequire(!frozen);\n', '\t\trequire(!frozenAccounts[_from]);                     \n', '        require(!frozenAccounts[_to]);                       \n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '\t\tassert(balances[_from] + balances[_to] == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        return _transfer(msg.sender, _to,  _value) ;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(allowances[_from][msg.sender] >= _value);     \n', '\t\tallowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return totalToken;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\n', '        allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Lover is ERC20Token, Owned {\n', '\tstring public name = "Lover";\n', '    string public symbol = "LOV";\n', '    uint public constant decimals = 18;\n', '\tstring public note = "(C) loverchain.com all rights reserved";\n', '    uint public burnedToken;\n', '\tuint public fee;\n', '\tmapping (address => string) public keys;\n', '\tmapping (address => string) public signatures;\n', '\tmapping (address => string) public identities;\n', '\tmapping (address => uint) public scores;\n', '\tmapping (address => uint) public levels;\n', '    mapping (address => uint) public stars;\n', '    mapping (address => string) public profiles;\n', '\tmapping (address => string) public properties;\n', '\tmapping (address => string) public rules;\n', '    mapping (address => string) public funds;\n', '\tmapping (address => uint) public nonces;\n', '\tevent Key(address indexed _user, string indexed _key, uint _timestamp);\n', '\tevent Sign(address indexed _user, string indexed _data, uint _timestamp);\n', '\tevent Register(address indexed _user, string indexed _identity, address _certifier, uint _timestamp);\n', '\tevent Rule(address indexed _user, string _rule, address indexed _certifier, uint _timestamp);\n', '\tevent Fund(address indexed _user, string _fund, address indexed _certifier, uint _timestamp);\n', '\tevent Save(address indexed _user, uint _score, uint _level, uint _star, address indexed _certifier, uint _nonce, uint _timestamp);\n', '\tevent Burn(address indexed _from, uint _burntAmount, uint _timestamp);\n', '\n', '    function Lover() public {\n', '\t\ttotalToken = 1000000000000000000000000000;\n', '\t\tbalances[msg.sender] = totalToken;\n', '\t\towner = msg.sender;\n', '\t    frozen = false;\n', '\t\tfee = 100000000000000000000;\n', '\t\tcertifiedAccounts[msg.sender] = true; \n', '    }\n', '\n', '    function burn(uint _burntAmount) public returns (bool success) {\n', '    \trequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n', '\t\trequire(totalToken - _burntAmount >= 100000000000000000000000000);\n', '    \tbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n', '    \ttotalToken = totalToken.sub(_burntAmount);\n', '    \tburnedToken = burnedToken.add(_burntAmount);\n', '    \temit Transfer(msg.sender, 0x0, _burntAmount);\n', '    \temit Burn(msg.sender, _burntAmount, now);\n', '    \treturn true;\n', '\t}\n', '\n', '    function setKey(string _key) public {\n', '        require(bytes(_key).length >= 32);\n', '        keys[msg.sender] = _key;\n', '\t\temit Key(msg.sender, _key, now);\n', '    }\n', '\n', '    function sign(string _data) public {\n', '        require(bytes(_data).length >= 32);\n', '        signatures[msg.sender] = _data;\n', '\t\temit Sign(msg.sender, _data, now);\n', '    }\n', '\n', '\tfunction register(address _user, string _identity) public {\n', '\t\trequire(bytes(_identity).length > 0);\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '\t\tidentities[_user] = _identity;\n', '\t\temit Register(_user, _identity, msg.sender, now);\n', '    }\n', '\n', '    function _save(address _user, uint _score, uint _level, uint _star, string _profile, string _property, address _certifier, uint _nonce, uint _timestamp) internal {\n', '\t\trequire(_nonce == nonces[_user] + 1);  \n', '\t    if(bytes(_profile).length > 16){\n', '\t\t\tprofiles[_user] = _profile;\n', '\t\t}\n', '\t    if(bytes(_property).length > 16){\n', '\t\t    properties[_user] = _property;\n', '\t\t}\n', '\t\tif(_level > levels[_user]){\n', '\t\t\tlevels[_user] = _level;\n', '\t\t}\n', '\t\tscores[_user] = _score;\n', '        stars[_user] = _star;\n', '\t\tnonces[_user] = _nonce;\n', '\t\temit Save(_user, _score, _level, _star, _certifier, _nonce, _timestamp);\n', '    }\n', '\n', '    function save(address _user, uint _score, uint _level, uint _star, string _profile, string _property, uint _nonce) public {\n', '        require(certifiedAccounts[msg.sender]);  \n', '\t\t_save(_user, _score, _level, _star, _profile, _property, msg.sender, _nonce, now);\n', '    }\n', '\n', '\tfunction _assign(address _from, address _to, address _certifier) internal {\n', '\t\trequire(_from != 0x0 && _to != 0x0);\n', '\t\tuint _timestamp = now;\n', '\t\tuint _nonce = nonces[_from];\n', '\t\t_save(_to, scores[_from], levels[_from], stars[_from], profiles[_from], properties[_from], _certifier, _nonce, _timestamp);\n', '        profiles[_from] = "";\n', '        properties[_from] = "";\n', '\t\tscores[_from] = 0; \n', '\t\tlevels[_from] = 0;\n', '\t\tstars[_from] = 0;\n', '    }\n', '\n', '    function assign(address _to) public {\n', '\t\t_transfer(msg.sender, owner, fee);\n', '\t\t_assign(msg.sender, _to, owner);\n', '\t}\n', '\n', '\tfunction assignFrom(address _from, address _to) public {\n', '        require(certifiedAccounts[msg.sender]);\n', '\t    _assign(_from, _to, msg.sender);\n', '    }\n', '\n', '    function setRule(address _user, string _rule) public {\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '        rules[_user] = _rule;\n', '\t\temit Rule(_user, _rule, msg.sender, now);\n', '    }\n', '\n', '\tfunction setFund(address _user, string _fund) public {\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '        funds[_user] = _fund;\n', '\t\temit Fund(_user, _fund, msg.sender, now);\n', '    }\n', '    \n', '  \tfunction freeze(bool _frozen) public onlyOwner {\n', '        frozen = _frozen;\n', '    }\n', '\n', '    function freezeAccount(address _user, bool _frozen) public onlyOwner {\n', '        frozenAccounts[_user] = _frozen;\n', '        emit FreezeAccount(_user, _frozen, now);\n', '    }\n', '    \n', '\tfunction certifyAccount(address _user, bool _certified) public onlyOwner {\n', '        certifiedAccounts[_user] = _certified;\n', '        emit CertifyAccount(_user, _certified, now);\n', '    }\n', '    \n', '\tfunction setName(string _tokenName, string _tokenSymbol) public onlyOwner {\n', '        name = _tokenName;\n', '        symbol = _tokenSymbol; \n', '\t}\n', '\n', '\tfunction setNote(string _tokenNote) public onlyOwner {\n', '        note = _tokenNote;\n', '\t}\n', '\n', '\tfunction setFee(uint _value) public onlyOwner {\n', '        fee = _value;\n', '\t}\n', '\n', '    function random(uint _range) public view returns(uint) {\n', '\t    if(_range == 0) {\n', '\t       return 0;  \n', '\t    }\n', '        uint ran = uint(keccak256(block.difficulty, now));\n', '        return ran % _range;\n', '    }\n', '    \n', '    function shuffle(uint[] _tiles) public view returns(uint[]) {\n', '        uint len = _tiles.length;\n', '        uint[] memory t = _tiles; \n', '        uint temp = 0;\n', '        uint ran = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '           ran = random(i + 1);\n', '          if (ran != i){\n', '              temp = t[i];\n', '              t[i] = t[ran];\n', '              t[ran] = temp;\n', '          }\n', '        }\n', '        return t;\n', '   }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    modifier onlyOwner { require(msg.sender == owner); _; }\n', '    event Ownership(address _prevOwner, address _newOwner, uint _timestamp);\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit Ownership(owner, newOwner, now);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\tevent FreezeAccount(address indexed _target, bool _frozen, uint _timestamp);\n', '\tevent CertifyAccount(address indexed _target, bool _certified, uint _timestamp);\n', '}\n', '\n', 'contract ERC20Token is ERC20 {\n', '    using SafeMath for uint;\n', '    uint public totalToken;\n', '\tbool public frozen;\n', '    mapping(address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowances;\n', '\tmapping (address => bool) public frozenAccounts;\n', '\tmapping (address => bool) public certifiedAccounts;\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '\t\trequire(_from != 0x0 && _to != 0x0);\n', '        require(balances[_from] >= _value && _value > 0);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\t\trequire(!frozen);\n', '\t\trequire(!frozenAccounts[_from]);                     \n', '        require(!frozenAccounts[_to]);                       \n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '\t\tassert(balances[_from] + balances[_to] == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        return _transfer(msg.sender, _to,  _value) ;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(allowances[_from][msg.sender] >= _value);     \n', '\t\tallowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return totalToken;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\n', '        allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Lover is ERC20Token, Owned {\n', '\tstring public name = "Lover";\n', '    string public symbol = "LOV";\n', '    uint public constant decimals = 18;\n', '\tstring public note = "(C) loverchain.com all rights reserved";\n', '    uint public burnedToken;\n', '\tuint public fee;\n', '\tmapping (address => string) public keys;\n', '\tmapping (address => string) public signatures;\n', '\tmapping (address => string) public identities;\n', '\tmapping (address => uint) public scores;\n', '\tmapping (address => uint) public levels;\n', '    mapping (address => uint) public stars;\n', '    mapping (address => string) public profiles;\n', '\tmapping (address => string) public properties;\n', '\tmapping (address => string) public rules;\n', '    mapping (address => string) public funds;\n', '\tmapping (address => uint) public nonces;\n', '\tevent Key(address indexed _user, string indexed _key, uint _timestamp);\n', '\tevent Sign(address indexed _user, string indexed _data, uint _timestamp);\n', '\tevent Register(address indexed _user, string indexed _identity, address _certifier, uint _timestamp);\n', '\tevent Rule(address indexed _user, string _rule, address indexed _certifier, uint _timestamp);\n', '\tevent Fund(address indexed _user, string _fund, address indexed _certifier, uint _timestamp);\n', '\tevent Save(address indexed _user, uint _score, uint _level, uint _star, address indexed _certifier, uint _nonce, uint _timestamp);\n', '\tevent Burn(address indexed _from, uint _burntAmount, uint _timestamp);\n', '\n', '    function Lover() public {\n', '\t\ttotalToken = 1000000000000000000000000000;\n', '\t\tbalances[msg.sender] = totalToken;\n', '\t\towner = msg.sender;\n', '\t    frozen = false;\n', '\t\tfee = 100000000000000000000;\n', '\t\tcertifiedAccounts[msg.sender] = true; \n', '    }\n', '\n', '    function burn(uint _burntAmount) public returns (bool success) {\n', '    \trequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n', '\t\trequire(totalToken - _burntAmount >= 100000000000000000000000000);\n', '    \tbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n', '    \ttotalToken = totalToken.sub(_burntAmount);\n', '    \tburnedToken = burnedToken.add(_burntAmount);\n', '    \temit Transfer(msg.sender, 0x0, _burntAmount);\n', '    \temit Burn(msg.sender, _burntAmount, now);\n', '    \treturn true;\n', '\t}\n', '\n', '    function setKey(string _key) public {\n', '        require(bytes(_key).length >= 32);\n', '        keys[msg.sender] = _key;\n', '\t\temit Key(msg.sender, _key, now);\n', '    }\n', '\n', '    function sign(string _data) public {\n', '        require(bytes(_data).length >= 32);\n', '        signatures[msg.sender] = _data;\n', '\t\temit Sign(msg.sender, _data, now);\n', '    }\n', '\n', '\tfunction register(address _user, string _identity) public {\n', '\t\trequire(bytes(_identity).length > 0);\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '\t\tidentities[_user] = _identity;\n', '\t\temit Register(_user, _identity, msg.sender, now);\n', '    }\n', '\n', '    function _save(address _user, uint _score, uint _level, uint _star, string _profile, string _property, address _certifier, uint _nonce, uint _timestamp) internal {\n', '\t\trequire(_nonce == nonces[_user] + 1);  \n', '\t    if(bytes(_profile).length > 16){\n', '\t\t\tprofiles[_user] = _profile;\n', '\t\t}\n', '\t    if(bytes(_property).length > 16){\n', '\t\t    properties[_user] = _property;\n', '\t\t}\n', '\t\tif(_level > levels[_user]){\n', '\t\t\tlevels[_user] = _level;\n', '\t\t}\n', '\t\tscores[_user] = _score;\n', '        stars[_user] = _star;\n', '\t\tnonces[_user] = _nonce;\n', '\t\temit Save(_user, _score, _level, _star, _certifier, _nonce, _timestamp);\n', '    }\n', '\n', '    function save(address _user, uint _score, uint _level, uint _star, string _profile, string _property, uint _nonce) public {\n', '        require(certifiedAccounts[msg.sender]);  \n', '\t\t_save(_user, _score, _level, _star, _profile, _property, msg.sender, _nonce, now);\n', '    }\n', '\n', '\tfunction _assign(address _from, address _to, address _certifier) internal {\n', '\t\trequire(_from != 0x0 && _to != 0x0);\n', '\t\tuint _timestamp = now;\n', '\t\tuint _nonce = nonces[_from];\n', '\t\t_save(_to, scores[_from], levels[_from], stars[_from], profiles[_from], properties[_from], _certifier, _nonce, _timestamp);\n', '        profiles[_from] = "";\n', '        properties[_from] = "";\n', '\t\tscores[_from] = 0; \n', '\t\tlevels[_from] = 0;\n', '\t\tstars[_from] = 0;\n', '    }\n', '\n', '    function assign(address _to) public {\n', '\t\t_transfer(msg.sender, owner, fee);\n', '\t\t_assign(msg.sender, _to, owner);\n', '\t}\n', '\n', '\tfunction assignFrom(address _from, address _to) public {\n', '        require(certifiedAccounts[msg.sender]);\n', '\t    _assign(_from, _to, msg.sender);\n', '    }\n', '\n', '    function setRule(address _user, string _rule) public {\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '        rules[_user] = _rule;\n', '\t\temit Rule(_user, _rule, msg.sender, now);\n', '    }\n', '\n', '\tfunction setFund(address _user, string _fund) public {\n', '\t\trequire(certifiedAccounts[msg.sender]);\n', '        funds[_user] = _fund;\n', '\t\temit Fund(_user, _fund, msg.sender, now);\n', '    }\n', '    \n', '  \tfunction freeze(bool _frozen) public onlyOwner {\n', '        frozen = _frozen;\n', '    }\n', '\n', '    function freezeAccount(address _user, bool _frozen) public onlyOwner {\n', '        frozenAccounts[_user] = _frozen;\n', '        emit FreezeAccount(_user, _frozen, now);\n', '    }\n', '    \n', '\tfunction certifyAccount(address _user, bool _certified) public onlyOwner {\n', '        certifiedAccounts[_user] = _certified;\n', '        emit CertifyAccount(_user, _certified, now);\n', '    }\n', '    \n', '\tfunction setName(string _tokenName, string _tokenSymbol) public onlyOwner {\n', '        name = _tokenName;\n', '        symbol = _tokenSymbol; \n', '\t}\n', '\n', '\tfunction setNote(string _tokenNote) public onlyOwner {\n', '        note = _tokenNote;\n', '\t}\n', '\n', '\tfunction setFee(uint _value) public onlyOwner {\n', '        fee = _value;\n', '\t}\n', '\n', '    function random(uint _range) public view returns(uint) {\n', '\t    if(_range == 0) {\n', '\t       return 0;  \n', '\t    }\n', '        uint ran = uint(keccak256(block.difficulty, now));\n', '        return ran % _range;\n', '    }\n', '    \n', '    function shuffle(uint[] _tiles) public view returns(uint[]) {\n', '        uint len = _tiles.length;\n', '        uint[] memory t = _tiles; \n', '        uint temp = 0;\n', '        uint ran = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '           ran = random(i + 1);\n', '          if (ran != i){\n', '              temp = t[i];\n', '              t[i] = t[ran];\n', '              t[ran] = temp;\n', '          }\n', '        }\n', '        return t;\n', '   }\n', '}']
