['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '    //internals\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '/// @title Simple Tokens\n', '/// Simple Tokens that can be minted by their owner\n', 'contract SimpleToken is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // This creates a mapping with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    // Another array with spending allowances\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    // The total supply of the token\n', '    uint256 public totalSupply;\n', '\n', '    // Some variables for nice wallet integration\n', '    string public name = "CryptoGold";          // Set the name for display purposes\n', '    string public symbol = "CGC" ;             // Set the symbol for display purposes\n', '    uint8 public decimals = 6;                // Amount of decimals for display purposes\n', '\n', '    // Send coins\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != 0x0);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != 0x0);\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Approve that others can transfer _value tokens for the msg.sender\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowance[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/// @title Multisignature Mintable Token - Allows minting of Tokens by a 2-2-Multisignature\n', '/// @author Henning Kopp - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="99f2f6e9e9d9fbf5f6faf2faf1f8f0f7b4fbfcebf8edecf7feb7fdfc">[email&#160;protected]</a>>\n', 'contract MultiSigMint is SimpleToken {\n', '\n', '    // Address change event\n', '    event newOwner(address indexed oldAddress, address indexed newAddress);\n', '    event newNotary(address indexed oldAddress, address indexed newAddress);    \n', '    event Mint(address indexed minter, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    // The address of the notary\n', '    address public notary;\n', '\n', '    uint256 proposedMintAmnt = 0;\n', '    uint256 proposedBurnAmnt = 0;\n', '\n', '    address proposeOwner = 0x0;\n', '    address proposeNotary = 0x0;\n', '\n', '    function MultiSigMint(address _notary) public {\n', '        require(_notary != 0x0);\n', '        require(msg.sender != _notary);\n', '        notary = _notary;\n', '    }\n', '\n', '    modifier onlyNotary {\n', '        require(msg.sender == notary);\n', '        _;\n', '    }\n', '\n', '    /* Allows the owner to propose the minting of tokens.\n', '     * tokenamount is the amount of tokens to be minted.\n', '     */\n', '    function proposeMinting(uint256 _tokenamount) external onlyOwner returns (bool) {\n', '        require(_tokenamount > 0);\n', '        proposedMintAmnt = _tokenamount;\n', '        return true;\n', '    }\n', '\n', '    /* Allows the notary to confirm the minting of tokens.\n', '     * tokenamount is the amount of tokens to be minted.\n', '     */\n', '    function confirmMinting(uint256 _tokenamount) external onlyNotary returns (bool) {\n', '        if (_tokenamount == proposedMintAmnt) {\n', '            proposedMintAmnt = 0; // reset the amount\n', '            balanceOf[owner] = balanceOf[owner].add(_tokenamount);\n', '            totalSupply = totalSupply.add(_tokenamount);\n', '            emit Mint(owner, _tokenamount);\n', '            emit Transfer(0x0, owner, _tokenamount);\n', '            return true;\n', '        } else {\n', '            proposedMintAmnt = 0; // reset the amount\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Allows the owner to propose the burning of tokens.\n', '     * tokenamount is the amount of tokens to be burned.\n', '     */\n', '    function proposeBurning(uint256 _tokenamount) external onlyOwner returns (bool) {\n', '        require(_tokenamount > 0);\n', '        proposedBurnAmnt = _tokenamount;\n', '        return true;\n', '    }\n', '\n', '    /* Allows the notary to confirm the burning of tokens.\n', '     * tokenamount is the amount of tokens to be burning.\n', '     */\n', '    function confirmBurning(uint256 _tokenamount) external onlyNotary returns (bool) {\n', '        if (_tokenamount == proposedBurnAmnt) {\n', '            proposedBurnAmnt = 0; // reset the amount\n', '            balanceOf[owner] = balanceOf[owner].sub(_tokenamount);\n', '            totalSupply = totalSupply.sub(_tokenamount);\n', '            emit Burn(owner, _tokenamount);\n', '            emit Transfer(owner, 0x0, _tokenamount);\n', '            return true;\n', '        } else {\n', '            proposedBurnAmnt = 0; // reset the amount\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Owner can propose an address change for owner\n', '    The notary has to confirm that address\n', '    */\n', '    function proposeNewOwner(address _newAddress) external onlyOwner {\n', '        proposeOwner = _newAddress;\n', '    }\n', '    function confirmNewOwner(address _newAddress) external onlyNotary returns (bool) {\n', '        if (proposeOwner == _newAddress && _newAddress != 0x0 && _newAddress != notary) {\n', '            proposeOwner = 0x0;\n', '            emit newOwner(owner, _newAddress);\n', '            owner = _newAddress;\n', '            return true;\n', '        } else {\n', '            proposeOwner = 0x0;\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    /* Owner can propose an address change for notary\n', '    The notary has to confirm that address\n', '    */\n', '    function proposeNewNotary(address _newAddress) external onlyOwner {\n', '        proposeNotary = _newAddress;\n', '    }\n', '    function confirmNewNotary(address _newAddress) external onlyNotary returns (bool) {\n', '        if (proposeNotary == _newAddress && _newAddress != 0x0 && _newAddress != owner) {\n', '            proposeNotary = 0x0;\n', '            emit newNotary(notary, _newAddress);\n', '            notary = _newAddress;\n', '            return true;\n', '        } else {\n', '            proposeNotary = 0x0;\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '/// @title Contract with fixed parameters for deployment\n', '/// @author Henning Kopp - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f34302f2f1f3d33303c343c373e3631723d3a2d3e2b2a3138713b3a">[email&#160;protected]</a>>\n', 'contract GoldToken is MultiSigMint {\n', '    function GoldToken(address _notary) public MultiSigMint(_notary) {}\n', '}']
['pragma solidity 0.4.21;\n', '\n', 'library SafeMath {\n', '    //internals\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '/// @title Simple Tokens\n', '/// Simple Tokens that can be minted by their owner\n', 'contract SimpleToken is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // This creates a mapping with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    // Another array with spending allowances\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    // The total supply of the token\n', '    uint256 public totalSupply;\n', '\n', '    // Some variables for nice wallet integration\n', '    string public name = "CryptoGold";          // Set the name for display purposes\n', '    string public symbol = "CGC" ;             // Set the symbol for display purposes\n', '    uint8 public decimals = 6;                // Amount of decimals for display purposes\n', '\n', '    // Send coins\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != 0x0);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != 0x0);\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Approve that others can transfer _value tokens for the msg.sender\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowance[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/// @title Multisignature Mintable Token - Allows minting of Tokens by a 2-2-Multisignature\n', '/// @author Henning Kopp - <kopp@blockchain-beratung.de>\n', 'contract MultiSigMint is SimpleToken {\n', '\n', '    // Address change event\n', '    event newOwner(address indexed oldAddress, address indexed newAddress);\n', '    event newNotary(address indexed oldAddress, address indexed newAddress);    \n', '    event Mint(address indexed minter, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    // The address of the notary\n', '    address public notary;\n', '\n', '    uint256 proposedMintAmnt = 0;\n', '    uint256 proposedBurnAmnt = 0;\n', '\n', '    address proposeOwner = 0x0;\n', '    address proposeNotary = 0x0;\n', '\n', '    function MultiSigMint(address _notary) public {\n', '        require(_notary != 0x0);\n', '        require(msg.sender != _notary);\n', '        notary = _notary;\n', '    }\n', '\n', '    modifier onlyNotary {\n', '        require(msg.sender == notary);\n', '        _;\n', '    }\n', '\n', '    /* Allows the owner to propose the minting of tokens.\n', '     * tokenamount is the amount of tokens to be minted.\n', '     */\n', '    function proposeMinting(uint256 _tokenamount) external onlyOwner returns (bool) {\n', '        require(_tokenamount > 0);\n', '        proposedMintAmnt = _tokenamount;\n', '        return true;\n', '    }\n', '\n', '    /* Allows the notary to confirm the minting of tokens.\n', '     * tokenamount is the amount of tokens to be minted.\n', '     */\n', '    function confirmMinting(uint256 _tokenamount) external onlyNotary returns (bool) {\n', '        if (_tokenamount == proposedMintAmnt) {\n', '            proposedMintAmnt = 0; // reset the amount\n', '            balanceOf[owner] = balanceOf[owner].add(_tokenamount);\n', '            totalSupply = totalSupply.add(_tokenamount);\n', '            emit Mint(owner, _tokenamount);\n', '            emit Transfer(0x0, owner, _tokenamount);\n', '            return true;\n', '        } else {\n', '            proposedMintAmnt = 0; // reset the amount\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Allows the owner to propose the burning of tokens.\n', '     * tokenamount is the amount of tokens to be burned.\n', '     */\n', '    function proposeBurning(uint256 _tokenamount) external onlyOwner returns (bool) {\n', '        require(_tokenamount > 0);\n', '        proposedBurnAmnt = _tokenamount;\n', '        return true;\n', '    }\n', '\n', '    /* Allows the notary to confirm the burning of tokens.\n', '     * tokenamount is the amount of tokens to be burning.\n', '     */\n', '    function confirmBurning(uint256 _tokenamount) external onlyNotary returns (bool) {\n', '        if (_tokenamount == proposedBurnAmnt) {\n', '            proposedBurnAmnt = 0; // reset the amount\n', '            balanceOf[owner] = balanceOf[owner].sub(_tokenamount);\n', '            totalSupply = totalSupply.sub(_tokenamount);\n', '            emit Burn(owner, _tokenamount);\n', '            emit Transfer(owner, 0x0, _tokenamount);\n', '            return true;\n', '        } else {\n', '            proposedBurnAmnt = 0; // reset the amount\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Owner can propose an address change for owner\n', '    The notary has to confirm that address\n', '    */\n', '    function proposeNewOwner(address _newAddress) external onlyOwner {\n', '        proposeOwner = _newAddress;\n', '    }\n', '    function confirmNewOwner(address _newAddress) external onlyNotary returns (bool) {\n', '        if (proposeOwner == _newAddress && _newAddress != 0x0 && _newAddress != notary) {\n', '            proposeOwner = 0x0;\n', '            emit newOwner(owner, _newAddress);\n', '            owner = _newAddress;\n', '            return true;\n', '        } else {\n', '            proposeOwner = 0x0;\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    /* Owner can propose an address change for notary\n', '    The notary has to confirm that address\n', '    */\n', '    function proposeNewNotary(address _newAddress) external onlyOwner {\n', '        proposeNotary = _newAddress;\n', '    }\n', '    function confirmNewNotary(address _newAddress) external onlyNotary returns (bool) {\n', '        if (proposeNotary == _newAddress && _newAddress != 0x0 && _newAddress != owner) {\n', '            proposeNotary = 0x0;\n', '            emit newNotary(notary, _newAddress);\n', '            notary = _newAddress;\n', '            return true;\n', '        } else {\n', '            proposeNotary = 0x0;\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '/// @title Contract with fixed parameters for deployment\n', '/// @author Henning Kopp - <kopp@blockchain-beratung.de>\n', 'contract GoldToken is MultiSigMint {\n', '    function GoldToken(address _notary) public MultiSigMint(_notary) {}\n', '}']
