['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * \n', ' * This contract is used to set admin to the contract  which has some additional features such as minting , burning etc\n', ' * \n', ' */\n', '    contract Owned {\n', '        address public owner;\n', '\n', '        function owned() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        modifier onlyOwner {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '        \n', '        /* This function is used to transfer adminship to new owner\n', '         * @param  _newOwner - address of new admin or owner        \n', '         */\n', '\n', '        function transferOwnership(address _newOwner) onlyOwner public {\n', '            owner = _newOwner;\n', '        }          \n', '    }\n', '\n', '/**\n', ' * This is base ERC20 Contract , basically ERC-20 defines a common list of rules for all Ethereum tokens to follow\n', ' */ \n', '\n', 'contract ERC20 {\n', '  \n', '  using SafeMath for uint256;\n', '\n', '  //This creates an array with all balances \n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) allowed;  \n', '\n', '  //This maintains list of all accounts with token lock\n', '  mapping(address => bool) public isLockedAccount;\n', '    \n', '  // public variables of the token  \n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals = 18;\n', '  uint256 public totalSupply;\n', '   \n', '  // This notifies client about the approval done by owner to spender for a given value\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  // This notifies client about the approval done\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', ' \n', '  \n', '  function ERC20(uint256 _initialSupply,string _tokenName, string _tokenSymbol) public {    \n', '    totalSupply = _initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount     \n', '    balanceOf[msg.sender] = totalSupply;  \n', '    name = _tokenName;\n', '    symbol = _tokenSymbol;   \n', '  }\n', '  \n', '    /* This function is used to transfer tokens to a particular address \n', '     * @param _to receiver address where transfer is to be done\n', '     * @param _value value to be transferred\n', '     */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(!isLockedAccount[msg.sender]);                 // Check if sender is not blacklisted\n', '        require(!isLockedAccount[_to]);                        // Check if receiver is not blacklisted\n', '\t\trequire(balanceOf[msg.sender] > 0);                     \n', '\t\trequire(balanceOf[msg.sender] >= _value);                   // Check if the sender has enough  \n', '\t\trequire(_to != address(0));                                 // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_value > 0);\n', '\t\trequire(balanceOf[_to] .add(_value) >= balanceOf[_to]);     // Check for overflows \n', '\t\trequire(_to != msg.sender);                                 // Check if sender and receiver is not same\n', '\t\tbalanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);  // Subtract value from sender\n', '\t\tbalanceOf[_to] = balanceOf[_to].add(_value);                // Add the value to the receiver\n', '\t\temit Transfer(msg.sender, _to, _value);                     // Notify all clients about the transfer events\n', '        return true;\n', '\t}\n', '\n', '\t/* Send _value amount of tokens from address _from to address _to\n', '     * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '     * tokens on your behalf\n', '     * @param _from address from which amount is to be transferred\n', '     * @param _to address to which amount is transferred\n', '     * @param _amount to which amount is transferred\n', '     */\n', '    function transferFrom(\n', '         address _from,\n', '         address _to,\n', '         uint256 _amount\n', '     ) public returns (bool success)\n', '      { \n', '        require(balanceOf[_from] >= _amount);\n', '        require(allowed[_from][msg.sender] >= _amount);\n', '        require(_amount > 0);\n', '        require(_to != address(0));\n', '        require(_to != msg.sender);          \n', '        balanceOf[_from] = balanceOf[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balanceOf[_to] = balanceOf[_to].add(_amount);\n', '        return true;        \n', '    }\n', '    \n', '    \n', '    /* This function allows _spender to withdraw from your account, multiple times, up to the _value amount.\n', '     * If this function is called again it overwrites the current allowance with _value.\n', '     * @param _spender address of the spender\n', '     * @param _amount amount allowed to be withdrawal\n', '     */\n', '     function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '         require(_spender != msg.sender);\n', '         allowed[msg.sender][_spender] = _amount;\n', '         emit Approval(msg.sender, _spender, _amount);\n', '         return true;\n', '    } \n', '\n', '    /* This function returns the amount of tokens approved by the owner that can be\n', '     * transferred to the spender&#39;s account\n', '     * @param _owner address of the owner\n', '     * @param _spender address of the spender \n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '         return allowed[_owner][_spender];\n', '    }\n', '\n', '    \n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '//This is the Main Railz Token Contract derived from the other two contracts Owned and ERC20\n', 'contract RailzToken is Owned, ERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256  tokenSupply = 2000000000;  //2 billions\n', '             \n', '    // This notifies clients about the amount burnt , only admin is able to burn the contract\n', '    event Burn(address from, uint256 value); \n', '    \n', '    /* This is the main Token Constructor \n', '     * @param _centralAdmin  Address of the admin of the contract\n', '     */\n', '\tfunction RailzToken() \n', '\n', '\tERC20 (tokenSupply,"Railz","RLZ") public\n', '    {\n', '\t\towner = msg.sender;\n', '\t}           \n', '\n', '    /* This function is used to mint additional tokens\n', '     * only admin can invoke this function\n', '     * @param _mintedAmount amount of tokens to be minted  \n', '     */\n', '    function mintTokens(uint256 _mintedAmount) public onlyOwner {\n', '        balanceOf[owner] = balanceOf[owner].add(_mintedAmount);\n', '        totalSupply = totalSupply.add(_mintedAmount);\n', '        Transfer(0, owner, _mintedAmount);      \n', '    }    \n', '\n', '     /**\n', '    * This function Burns a specific amount of tokens.\n', '    * @param _value The amount of token to be burned.\n', '    */\n', '    function burn(uint256 _value) public onlyOwner {\n', '      require(_value <= balanceOf[msg.sender]);\n', '      // no need to require value <= totalSupply, since that would imply the\n', '      // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '      address burner = msg.sender;\n', '      balanceOf[burner] = balanceOf[burner].sub(_value);\n', '      totalSupply = totalSupply.sub(_value);\n', '      Burn(burner, _value);\n', '  }\n', '\n', '   /* This function is used to lock a user&#39;s token , tokens once locked cannot be transferred\n', '     * only admin can invoke this function\n', '     * @param _target address of the target      \n', '     */\n', '    function lockAccount(address _target) public onlyOwner {\n', '        require(_target != address(0));\n', '        isLockedAccount[_target] = true;       \n', '    }\n', '\n', '     /* This function is used to unlock a user&#39;s already locked tokens\n', '     * only admin can invoke this function\n', '     * @param _target address of the target      \n', '     */\n', '    function unlockAccount(address _target) public onlyOwner {\n', '        require(_target != address(0));\n', '        isLockedAccount[_target] = false;       \n', '    }\n', '}']