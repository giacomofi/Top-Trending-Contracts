['pragma solidity 0.4.19;\n', '\n', 'contract BaseContract {\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier isZero(uint256 _amount) {\n', '        require(_amount == 0);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier nonZero(uint256 _amount) {\n', '        require(_amount != 0);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyIf(bool condition) {\n', '        require(condition);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier validIndex(uint256 arrayLength, uint256 index) {\n', '        requireValidIndex(arrayLength, index);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier validString(string value) {\n', '        require(bytes(value).length > 0);\n', '\n', '        _;\n', '    }\n', '\n', '    // mitigate short address attack\n', '    // http://vessenes.com/the-erc20-short-address-attack-explained/\n', '    modifier validParamData(uint256 numParams) {\n', '        uint256 expectedDataLength = (numParams * 32) + 4;\n', '        assert(msg.data.length >= expectedDataLength);\n', '\n', '        _;\n', '    }\n', '\n', '    function requireValidIndex(uint256 arrayLength, uint256 index)\n', '        internal\n', '        pure\n', '    {\n', '        require(index >= 0 && index < arrayLength);\n', '    }\n', '}\n', '\n', 'contract Owned is BaseContract {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    function Owned()\n', '        internal\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev allows transferring the contract ownership\n', '    /// the new owner still needs to accept the transfer\n', '    /// can only be called by the contract owner\n', '    /// @param _newOwner    new contract owner\n', '    function transferOwnership(address _newOwner)\n', '        public\n', '        validParamData(1)\n', '        onlyOwner\n', '        onlyIf(_newOwner != owner)\n', '    {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// @dev used by a new owner to accept an ownership transfer\n', '    function acceptOwnership()\n', '        public\n', '        onlyIf(msg.sender == newOwner)\n', '    {\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '\n', 'contract IToken { \n', '    function totalSupply()\n', '        public view\n', '        returns (uint256);\n', '\n', '    function balanceOf(address _owner)\n', '        public view\n', '        returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        returns (bool);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view\n', '        returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenRetriever is Owned {\n', '    function TokenRetriever()\n', '        internal\n', '    {\n', '    }\n', '\n', '    /// @dev Failsafe mechanism - Allows owner to retrieve tokens from the contract\n', '    /// @param _token The address of ERC20 compatible token\n', '    function retrieveTokens(IToken _token)\n', '        public\n', '        onlyOwner\n', '    {\n', '        uint256 tokenBalance = _token.balanceOf(this);\n', '        if (tokenBalance > 0) {\n', '            _token.transfer(owner, tokenBalance);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Math operations with safety checks\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '// solhint-disable no-simple-event-func-name\n', '\n', '// ERC20 Standard Token implementation\n', 'contract ERC20Token is BaseContract {\n', '    using SafeMath for uint256;\n', '\n', '    string public name = "";\n', '    string public symbol = "";\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /// @dev constructor\n', '    /// @param _name        token name\n', '    /// @param _symbol      token symbol\n', '    /// @param _decimals    decimal points, for display purposes\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals)\n', '        internal\n', '        validString(_name)\n', '        validString(_symbol)\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    /// @dev send coins\n', '    /// throws on any error rather then return a false flag to minimize user errors\n', '    /// @param _to      target address\n', '    /// @param _value   transfer amount\n', "    /// @return true if the transfer was successful, false if it wasn't\n", '    function transfer(address _to, uint256 _value)\n', '        public\n', '        validParamData(2)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '        returns (bool success)\n', '    {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev an account/contract attempts to get the coins\n', '    /// throws on any error rather then return a false flag to minimize user errors\n', '    /// @param _from    source address\n', '    /// @param _to      target address\n', '    /// @param _value   transfer amount\n', "    /// @return true if the transfer was successful, false if it wasn't\n", '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validParamData(3)\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '        returns (bool success)\n', '    {\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev allow another account/contract to spend some tokens on your behalf\n', '    /// throws on any error rather then return a false flag to minimize user errors\n', '    /// also, to minimize the risk of the approve/transferFrom attack vector\n', '    /// (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/)\n', '    /// approve has to be called twice in 2 separate transactions\n', '    /// once to change the allowance to 0 and secondly to change it to the new allowance value\n', '    /// @param _spender approved address\n', '    /// @param _value   allowance amount\n', "    /// @return true if the approval was successful, false if it wasn't\n", '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validParamData(2)\n', '        validAddress(_spender)\n', '        onlyIf(_value == 0 || allowance[msg.sender][_spender] == 0)\n', '        returns (bool success)\n', '    {\n', '        uint256 currentAllowance = allowance[msg.sender][_spender];\n', '\n', '        return changeApprovalCore(_spender, currentAllowance, _value);\n', '    }\n', '\n', '    /// @dev Allow another account/contract to spend some tokens on your behalf\n', '    /// Note: This method is protected against the approve/transferFrom attack vector\n', '    /// (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/)\n', '    /// because the previous value and new value must both be specified.\n', '    function changeApproval(address _spender, uint256 _previousValue, uint256 _value)\n', '        public\n', '        validParamData(3)\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', '        return changeApprovalCore(_spender, _previousValue, _value);\n', '    }\n', '\n', '    function changeApprovalCore(address _spender, uint256 _previousValue, uint256 _value)\n', '        private\n', '        onlyIf(allowance[msg.sender][_spender] == _previousValue)\n', '        returns (bool success)\n', '    {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract XBPToken is BaseContract, Owned, TokenRetriever, ERC20Token {\n', '    using SafeMath for uint256;\n', '\n', '    bool public issuanceEnabled = true;\n', '\n', '    event Issuance(uint256 _amount);\n', '\n', '    function XBPToken()\n', '        public\n', '        ERC20Token("BlitzPredict", "XBP", 18)\n', '    {\n', '    }\n', '\n', '    /// @dev disables/enables token issuance\n', '    /// can only be called by the contract owner\n', '    function disableIssuance()\n', '        public\n', '        onlyOwner\n', '        onlyIf(issuanceEnabled)\n', '    {\n', '        issuanceEnabled = false;\n', '    }\n', '\n', '    /// @dev increases the token supply and sends the new tokens to an account\n', '    /// can only be called by the contract owner\n', '    /// @param _to         account to receive the new amount\n', '    /// @param _amount     amount to increase the supply by\n', '    function issue(address _to, uint256 _amount)\n', '        public\n', '        onlyOwner\n', '        validParamData(2)\n', '        validAddress(_to)\n', '        onlyIf(issuanceEnabled)\n', '        notThis(_to)\n', '    {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balanceOf[_to] = balanceOf[_to].add(_amount);\n', '\n', '        Issuance(_amount);\n', '        Transfer(this, _to, _amount);\n', '    }\n', '}']