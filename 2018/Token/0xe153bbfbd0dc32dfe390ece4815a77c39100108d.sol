['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract BTYCToken is ERC20Interface, Owned {\n', '     using SafeMath for uint;\n', '    /*\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;*/\n', '\n', '    uint256 public sellPrice; //出售价格 1枚代币换多少以太 /1000\n', '\tuint256 public buyPrice; //购买价格 多少以太可购买1枚代币 /1000\n', '\tuint256 public sysPrice; //挖矿的衡量值\n', '\tuint256 public sysPer; //挖矿的增量百分比 /100\n', '\t\n', '\tuint256 public onceOuttime; //增量的时间 测试  \n', '\tuint256 public onceAddTime; //挖矿的时间 测试\n', '\tuint256 public onceoutTimePer; //增量的百分比 测试\n', '\t\n', '\t\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    /* 冻结账户 */\n', '\tmapping(address => bool) public frozenAccount;\n', '\t// 记录各个账户的冻结数目\n', '\t//mapping(address => uint256) public freezeOf;\n', '\t// 记录各个账户的可用数目\n', '\tmapping(address => uint256) public canOf;\n', '\t// 记录各个账户的释放时间\n', '\tmapping(address => uint) public cronoutOf;\n', '\t// 记录各个账户的增量时间\n', '\tmapping(address => uint) public cronaddOf;\n', '\t\n', '\t /* 通知 */\n', '\tevent FrozenFunds(address target, bool frozen);\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public{\n', '       \n', '        \n', '        sellPrice = 510; //出售价格 1枚代币换多少以太 /1000000\n', '    \tbuyPrice =  526; //购买价格 多少以太可购买1枚代币 /1000000\n', '    \tsysPrice = 766; //挖矿的衡量值\n', '    \tsysPer = 225; //挖矿的增量百分比 /100\n', '    \t\n', '    \t//onceOuttime = 86400; //增量的时间 正式 \n', '    \t//onceAddTime = 864000; //挖矿的时间 正式\n', '    \t//onceoutTimePer = 8640000; //增量的百分比 正式\n', '    \t\n', '    \tonceOuttime = 600; //增量的时间 测试  \n', '    \tonceAddTime = 1800; //挖矿的时间 测试\n', '    \tonceoutTimePer = 60000; //增量的百分比 测试\n', '\t\n', '\t\n', '        \n', '       \n', '    }\n', '\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    \n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    \n', '    function canuseOf(address tokenOwner) public view returns (uint balance) {\n', '        return canOf[tokenOwner];\n', '    }\n', '    function myuseOf(address tokenOwner) public returns (uint balance) {\n', '        //return balances[tokenOwner];\n', '        if(cronoutOf[tokenOwner] < 1) {\n', '\t\t\treturn 0;\n', '\t\t}else{\n', '\t\t    uint lefttimes = now - cronoutOf[tokenOwner];\n', '    \t\tif(lefttimes >= onceOuttime) {\n', '    \t\t\tuint leftpers = lefttimes / onceoutTimePer;\n', '    \t\t\tif(leftpers > 1) {\n', '    \t\t\t\tleftpers = 1;\n', '    \t\t\t}\n', '    \t\t\tcanOf[tokenOwner] = balances[tokenOwner] * leftpers;\n', '    \t\t\treturn canOf[tokenOwner];\n', '    \t\t}else{\n', '    \t\t    return canOf[tokenOwner];\n', '    \t\t}\n', '\t\t}\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from token owner&#39;s account to `to` account\n', '    // - Owner&#39;s account must have sufficient balance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        require(!frozenAccount[msg.sender]);\n', '        require(!frozenAccount[to]);\n', '        canOf[msg.sender] = myuseOf(msg.sender);\n', '        canOf[msg.sender] = canOf[msg.sender].sub(tokens);\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    /*\n', '    function buytoken(address user, uint256 amount) public{\n', '        balances[user] = balances[user].sub(amount);\n', '        //buyeth(amount);\n', '        emit Transfer(address(0), user, amount);\n', '    }*/\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account. The `spender` contract function\n', '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    /// 向指定账户拨发资金\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '\t\trequire(!frozenAccount[target]);\n', '\t\tif(cronoutOf[target] < 1) {\n', '\t\t    cronoutOf[target] = now + onceOuttime;\n', '\t\t}\n', '\t\tif(cronaddOf[target] < 1) {\n', '\t\t    cronaddOf[target] = now + onceAddTime;\n', '\t\t}\n', '\n', '\t\tbalances[target] += mintedAmount;\n', '\t\tuint256 amounts = mintedAmount / 100;\n', '\t\tcanOf[target] += amounts;\n', '\t\t//emit Transfer(0, this, mintedAmount);\n', '\t\temit Transfer(this, target, mintedAmount);\n', '\n', '\t}\n', '\t//用户每隔10天挖矿一次\n', '\tfunction mint() public {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(cronaddOf[msg.sender] > 0 && now > cronaddOf[msg.sender]);\n', '\t\tuint256 mintAmount = balances[msg.sender] * sysPer / 10000;\n', '\t\tbalances[msg.sender] += mintAmount;\n', '\t\tcronaddOf[msg.sender] = now + onceAddTime;\n', '\t\t//emit Transfer(0, this, mintAmount);\n', '\t\temit Transfer(this, msg.sender, mintAmount);\n', '\n', '\t}\n', '    \n', '\t/// 冻结 or 解冻账户\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner public {\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\temit FrozenFunds(target, freeze);\n', '\t}\n', '\t// 设置销售购买价格\n', '\tfunction setPrices( uint256 newBuyPrice, uint256 newSellPrice, uint256 systyPrice, uint256 sysPermit) onlyOwner public {\n', '\t\tbuyPrice = newBuyPrice;\n', '\t\tsellPrice = newSellPrice;\n', '\t\tsysPrice = systyPrice;\n', '\t\tsysPer = sysPermit;\n', '\t}\n', '\t// 获取价格 \n', '\tfunction getprice()  public view returns (uint256 bprice,uint256 spice,uint256 sprice,uint256 sper) {\n', '          bprice = buyPrice;\n', '          spice = sellPrice;\n', '          sprice = sysPrice;\n', '          sper = sysPer;\n', '   }\n', '   \n', '\n', '\n', '    \n', '}\n', 'contract BTYC is BTYCToken{\n', '  string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public{\n', '        symbol = "BYTCT";\n', '        name = "BYTYCT Coin";\n', '        decimals = 18;\n', '        _totalSupply = 1000000 * 10**uint(decimals);\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '    function buy(uint money) public payable {\n', '        require(!frozenAccount[msg.sender]);\n', '        uint amount = money / buyPrice;\n', '        balances[msg.sender] += amount;\n', '        msg.sender.transfer(money);\n', '    }\n', '    /*\n', '    function selleth(uint amount) public payable {\n', '        //address user = msg.sender;\n', '        //canOf[user] = myuseOf(user);\n', '        //require(balances[user] >= amount );\n', '        //uint money = amount * sellPrice;\n', '       // balances[msg.sender] += money;\n', '        owner.transfer(amount);\n', '    }*/\n', '    function sell(uint amount)  public returns (bool success){\n', '        //address user = msg.sender;\n', '        //canOf[msg.sender] = myuseOf(msg.sender);\n', '        //require(!frozenAccount[msg.sender]);\n', '        require(canOf[msg.sender] >= amount ); \n', '        balances[msg.sender] -= amount;\n', '        canOf[msg.sender] -= amount;\n', '        uint moneys = amount / sellPrice;\n', '        owner.transfer(moneys);\n', '        //canOf[user] -= amount;\n', '        return true;              \n', '    }\n', '    \n', '\n', '  \n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract BTYCToken is ERC20Interface, Owned {\n', '     using SafeMath for uint;\n', '    /*\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;*/\n', '\n', '    uint256 public sellPrice; //出售价格 1枚代币换多少以太 /1000\n', '\tuint256 public buyPrice; //购买价格 多少以太可购买1枚代币 /1000\n', '\tuint256 public sysPrice; //挖矿的衡量值\n', '\tuint256 public sysPer; //挖矿的增量百分比 /100\n', '\t\n', '\tuint256 public onceOuttime; //增量的时间 测试  \n', '\tuint256 public onceAddTime; //挖矿的时间 测试\n', '\tuint256 public onceoutTimePer; //增量的百分比 测试\n', '\t\n', '\t\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    /* 冻结账户 */\n', '\tmapping(address => bool) public frozenAccount;\n', '\t// 记录各个账户的冻结数目\n', '\t//mapping(address => uint256) public freezeOf;\n', '\t// 记录各个账户的可用数目\n', '\tmapping(address => uint256) public canOf;\n', '\t// 记录各个账户的释放时间\n', '\tmapping(address => uint) public cronoutOf;\n', '\t// 记录各个账户的增量时间\n', '\tmapping(address => uint) public cronaddOf;\n', '\t\n', '\t /* 通知 */\n', '\tevent FrozenFunds(address target, bool frozen);\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public{\n', '       \n', '        \n', '        sellPrice = 510; //出售价格 1枚代币换多少以太 /1000000\n', '    \tbuyPrice =  526; //购买价格 多少以太可购买1枚代币 /1000000\n', '    \tsysPrice = 766; //挖矿的衡量值\n', '    \tsysPer = 225; //挖矿的增量百分比 /100\n', '    \t\n', '    \t//onceOuttime = 86400; //增量的时间 正式 \n', '    \t//onceAddTime = 864000; //挖矿的时间 正式\n', '    \t//onceoutTimePer = 8640000; //增量的百分比 正式\n', '    \t\n', '    \tonceOuttime = 600; //增量的时间 测试  \n', '    \tonceAddTime = 1800; //挖矿的时间 测试\n', '    \tonceoutTimePer = 60000; //增量的百分比 测试\n', '\t\n', '\t\n', '        \n', '       \n', '    }\n', '\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    \n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    \n', '    function canuseOf(address tokenOwner) public view returns (uint balance) {\n', '        return canOf[tokenOwner];\n', '    }\n', '    function myuseOf(address tokenOwner) public returns (uint balance) {\n', '        //return balances[tokenOwner];\n', '        if(cronoutOf[tokenOwner] < 1) {\n', '\t\t\treturn 0;\n', '\t\t}else{\n', '\t\t    uint lefttimes = now - cronoutOf[tokenOwner];\n', '    \t\tif(lefttimes >= onceOuttime) {\n', '    \t\t\tuint leftpers = lefttimes / onceoutTimePer;\n', '    \t\t\tif(leftpers > 1) {\n', '    \t\t\t\tleftpers = 1;\n', '    \t\t\t}\n', '    \t\t\tcanOf[tokenOwner] = balances[tokenOwner] * leftpers;\n', '    \t\t\treturn canOf[tokenOwner];\n', '    \t\t}else{\n', '    \t\t    return canOf[tokenOwner];\n', '    \t\t}\n', '\t\t}\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        require(!frozenAccount[msg.sender]);\n', '        require(!frozenAccount[to]);\n', '        canOf[msg.sender] = myuseOf(msg.sender);\n', '        canOf[msg.sender] = canOf[msg.sender].sub(tokens);\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    /*\n', '    function buytoken(address user, uint256 amount) public{\n', '        balances[user] = balances[user].sub(amount);\n', '        //buyeth(amount);\n', '        emit Transfer(address(0), user, amount);\n', '    }*/\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    /// 向指定账户拨发资金\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '\t\trequire(!frozenAccount[target]);\n', '\t\tif(cronoutOf[target] < 1) {\n', '\t\t    cronoutOf[target] = now + onceOuttime;\n', '\t\t}\n', '\t\tif(cronaddOf[target] < 1) {\n', '\t\t    cronaddOf[target] = now + onceAddTime;\n', '\t\t}\n', '\n', '\t\tbalances[target] += mintedAmount;\n', '\t\tuint256 amounts = mintedAmount / 100;\n', '\t\tcanOf[target] += amounts;\n', '\t\t//emit Transfer(0, this, mintedAmount);\n', '\t\temit Transfer(this, target, mintedAmount);\n', '\n', '\t}\n', '\t//用户每隔10天挖矿一次\n', '\tfunction mint() public {\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(cronaddOf[msg.sender] > 0 && now > cronaddOf[msg.sender]);\n', '\t\tuint256 mintAmount = balances[msg.sender] * sysPer / 10000;\n', '\t\tbalances[msg.sender] += mintAmount;\n', '\t\tcronaddOf[msg.sender] = now + onceAddTime;\n', '\t\t//emit Transfer(0, this, mintAmount);\n', '\t\temit Transfer(this, msg.sender, mintAmount);\n', '\n', '\t}\n', '    \n', '\t/// 冻结 or 解冻账户\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner public {\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\temit FrozenFunds(target, freeze);\n', '\t}\n', '\t// 设置销售购买价格\n', '\tfunction setPrices( uint256 newBuyPrice, uint256 newSellPrice, uint256 systyPrice, uint256 sysPermit) onlyOwner public {\n', '\t\tbuyPrice = newBuyPrice;\n', '\t\tsellPrice = newSellPrice;\n', '\t\tsysPrice = systyPrice;\n', '\t\tsysPer = sysPermit;\n', '\t}\n', '\t// 获取价格 \n', '\tfunction getprice()  public view returns (uint256 bprice,uint256 spice,uint256 sprice,uint256 sper) {\n', '          bprice = buyPrice;\n', '          spice = sellPrice;\n', '          sprice = sysPrice;\n', '          sper = sysPer;\n', '   }\n', '   \n', '\n', '\n', '    \n', '}\n', 'contract BTYC is BTYCToken{\n', '  string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public{\n', '        symbol = "BYTCT";\n', '        name = "BYTYCT Coin";\n', '        decimals = 18;\n', '        _totalSupply = 1000000 * 10**uint(decimals);\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '    function buy(uint money) public payable {\n', '        require(!frozenAccount[msg.sender]);\n', '        uint amount = money / buyPrice;\n', '        balances[msg.sender] += amount;\n', '        msg.sender.transfer(money);\n', '    }\n', '    /*\n', '    function selleth(uint amount) public payable {\n', '        //address user = msg.sender;\n', '        //canOf[user] = myuseOf(user);\n', '        //require(balances[user] >= amount );\n', '        //uint money = amount * sellPrice;\n', '       // balances[msg.sender] += money;\n', '        owner.transfer(amount);\n', '    }*/\n', '    function sell(uint amount)  public returns (bool success){\n', '        //address user = msg.sender;\n', '        //canOf[msg.sender] = myuseOf(msg.sender);\n', '        //require(!frozenAccount[msg.sender]);\n', '        require(canOf[msg.sender] >= amount ); \n', '        balances[msg.sender] -= amount;\n', '        canOf[msg.sender] -= amount;\n', '        uint moneys = amount / sellPrice;\n', '        owner.transfer(moneys);\n', '        //canOf[user] -= amount;\n', '        return true;              \n', '    }\n', '    \n', '\n', '  \n', '}']
