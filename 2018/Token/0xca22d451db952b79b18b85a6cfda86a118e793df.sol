['pragma solidity ^0.4.16;\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC20 {\n', '    using SafeMath for uint;\n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public totalSupply;\n', '   \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '   \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function TokenERC20(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public {\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n', '        name = tokenName;                                       // Set the name for display purposes\n', '        symbol = tokenSymbol;                                   // Set the symbol for display purposes\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public \n', '        returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }   \n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '\n', '        // Subtract from the sender\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    } \n', '}\n', '\n', 'contract WEKUToken is Owned, TokenERC20 {\n', '    \n', '    string public constant TOKEN_SYMBOL  = "WEKU"; \n', '    string public constant TOKEN_NAME    = "WEKU Token";  \n', '    uint public constant INITIAL_SUPPLLY = 4 * 10 ** 8; \n', '\n', '    uint256 deployedTime;   // the time this constract is deployed.\n', '    address team;           // team account\n', '    uint256 teamTotal;      // total amount of token assigned to team.    \n', '    uint256 teamWithdrawed; // total withdrawed of team account\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    function WEKUToken(\n', '        address _team\n', '    ) TokenERC20(INITIAL_SUPPLLY, TOKEN_NAME, TOKEN_SYMBOL) public {\n', '        deployedTime = now;\n', '        team = _team; \n', '        teamTotal = (INITIAL_SUPPLLY * 10 ** 18) / 5; \n', '        // assign 20% to team team once and only once.         \n', '        _transfer(owner, team, teamTotal);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    \n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '        balanceOf[target] = balanceOf[target].add(mintedAmount);\n', '        totalSupply = totalSupply.add(mintedAmount);\n', '\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /// @notice batch assign tokens to users registered in airdrops\n', '    /// @param earlyBirds address[] format in wallet: ["address1", "address2", ...]\n', '    /// @param amount without decimal amount: 10**18\n', '    function assignToEarlyBirds(address[] earlyBirds, uint256 amount) onlyOwner public {\n', '        require(amount > 0);\n', '\n', '        for (uint i = 0; i < earlyBirds.length; i++)\n', '            _transfer(msg.sender, earlyBirds[i], amount * 10 ** 18);\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal { \n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '\n', '        // make sure founders can only withdraw 25% each year after first year    \n', '        if(_from == team){\n', '            bool flag = _limitTeamWithdraw(_value, teamTotal, teamWithdrawed, deployedTime, now);\n', '            if(!flag)\n', '                revert();\n', '        }          \n', '             \n', '        balanceOf[_from] = balanceOf[_from].sub(_value);                  // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                      // Add the same to the recipient\n', '\n', '        if(_from == team) teamWithdrawed = teamWithdrawed.add(_value);    // record how many team withdrawed\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // setperate this function is for unit testing.\n', '    // limited withdraw: \n', '    // after deployed:  40%\n', '    // after one year:  30% \n', '    // after two years: 30%\n', '    function _limitTeamWithdraw(uint _amount, uint _teamTotal, uint _teamWithrawed, uint _deployedTime, uint _currentTime) internal pure returns(bool){\n', '        \n', '        bool flag  = true;\n', '\n', '        uint _tenPercent = _teamTotal / 10;    \n', '        if(_currentTime <= _deployedTime + 1 days && _amount + _teamWithrawed >= _tenPercent * 4) \n', '            flag = false;\n', '        else if(_currentTime <= _deployedTime + 365 days && _amount + _teamWithrawed >= _tenPercent * 7) \n', '            flag = false; \n', '\n', '        return flag;\n', '\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC20 {\n', '    using SafeMath for uint;\n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public totalSupply;\n', '   \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '   \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function TokenERC20(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public {\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n', '        name = tokenName;                                       // Set the name for display purposes\n', '        symbol = tokenSymbol;                                   // Set the symbol for display purposes\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public \n', '        returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }   \n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '\n', '        // Subtract from the sender\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    } \n', '}\n', '\n', 'contract WEKUToken is Owned, TokenERC20 {\n', '    \n', '    string public constant TOKEN_SYMBOL  = "WEKU"; \n', '    string public constant TOKEN_NAME    = "WEKU Token";  \n', '    uint public constant INITIAL_SUPPLLY = 4 * 10 ** 8; \n', '\n', '    uint256 deployedTime;   // the time this constract is deployed.\n', '    address team;           // team account\n', '    uint256 teamTotal;      // total amount of token assigned to team.    \n', '    uint256 teamWithdrawed; // total withdrawed of team account\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    function WEKUToken(\n', '        address _team\n', '    ) TokenERC20(INITIAL_SUPPLLY, TOKEN_NAME, TOKEN_SYMBOL) public {\n', '        deployedTime = now;\n', '        team = _team; \n', '        teamTotal = (INITIAL_SUPPLLY * 10 ** 18) / 5; \n', '        // assign 20% to team team once and only once.         \n', '        _transfer(owner, team, teamTotal);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    \n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '        balanceOf[target] = balanceOf[target].add(mintedAmount);\n', '        totalSupply = totalSupply.add(mintedAmount);\n', '\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /// @notice batch assign tokens to users registered in airdrops\n', '    /// @param earlyBirds address[] format in wallet: ["address1", "address2", ...]\n', '    /// @param amount without decimal amount: 10**18\n', '    function assignToEarlyBirds(address[] earlyBirds, uint256 amount) onlyOwner public {\n', '        require(amount > 0);\n', '\n', '        for (uint i = 0; i < earlyBirds.length; i++)\n', '            _transfer(msg.sender, earlyBirds[i], amount * 10 ** 18);\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal { \n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '\n', '        // make sure founders can only withdraw 25% each year after first year    \n', '        if(_from == team){\n', '            bool flag = _limitTeamWithdraw(_value, teamTotal, teamWithdrawed, deployedTime, now);\n', '            if(!flag)\n', '                revert();\n', '        }          \n', '             \n', '        balanceOf[_from] = balanceOf[_from].sub(_value);                  // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                      // Add the same to the recipient\n', '\n', '        if(_from == team) teamWithdrawed = teamWithdrawed.add(_value);    // record how many team withdrawed\n', '\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    // setperate this function is for unit testing.\n', '    // limited withdraw: \n', '    // after deployed:  40%\n', '    // after one year:  30% \n', '    // after two years: 30%\n', '    function _limitTeamWithdraw(uint _amount, uint _teamTotal, uint _teamWithrawed, uint _deployedTime, uint _currentTime) internal pure returns(bool){\n', '        \n', '        bool flag  = true;\n', '\n', '        uint _tenPercent = _teamTotal / 10;    \n', '        if(_currentTime <= _deployedTime + 1 days && _amount + _teamWithrawed >= _tenPercent * 4) \n', '            flag = false;\n', '        else if(_currentTime <= _deployedTime + 365 days && _amount + _teamWithrawed >= _tenPercent * 7) \n', '            flag = false; \n', '\n', '        return flag;\n', '\n', '    }\n', '}']
