['pragma solidity ^0.4.24;\n', '\n', '\n', 'contract EC {\n', '\n', '    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n', '    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n', '    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '    uint256 constant public a = 0;\n', '    uint256 constant public b = 7;\n', '\n', '    function _jAdd(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jSub(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(n - x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jMul(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, x2, n),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jDiv(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, z2, n),\n', '            mulmod(z1, x2, n)\n', '        );\n', '    }\n', '\n', '    function _inverse(uint256 val) public pure\n', '        returns(uint256 invVal)\n', '    {\n', '        uint256 t = 0;\n', '        uint256 newT = 1;\n', '        uint256 r = n;\n', '        uint256 newR = val;\n', '        uint256 q;\n', '        while (newR != 0) {\n', '            q = r / newR;\n', '\n', '            (t, newT) = (newT, addmod(t, (n - mulmod(q, newT, n)), n));\n', '            (r, newR) = (newR, r - q * newR );\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '    function _ecAdd(\n', '        uint256 x1, uint256 y1, uint256 z1,\n', '        uint256 x2, uint256 y2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 lx;\n', '        uint256 lz;\n', '        uint256 da;\n', '        uint256 db;\n', '\n', '        if (x1 == 0 && y1 == 0) {\n', '            return (x2, y2, z2);\n', '        }\n', '\n', '        if (x2 == 0 && y2 == 0) {\n', '            return (x1, y1, z1);\n', '        }\n', '\n', '        if (x1 == x2 && y1 == y2) {\n', '            (lx, lz) = _jMul(x1, z1, x1, z1);\n', '            (lx, lz) = _jMul(lx, lz, 3, 1);\n', '            (lx, lz) = _jAdd(lx, lz, a, 1);\n', '\n', '            (da,db) = _jMul(y1, z1, 2, 1);\n', '        } else {\n', '            (lx, lz) = _jSub(y2, z2, y1, z1);\n', '            (da, db) = _jSub(x2, z2, x1, z1);\n', '        }\n', '\n', '        (lx, lz) = _jDiv(lx, lz, da, db);\n', '\n', '        (x3, da) = _jMul(lx, lz, lx, lz);\n', '        (x3, da) = _jSub(x3, da, x1, z1);\n', '        (x3, da) = _jSub(x3, da, x2, z2);\n', '\n', '        (y3, db) = _jSub(x1, z1, x3, da);\n', '        (y3, db) = _jMul(y3, db, lx, lz);\n', '        (y3, db) = _jSub(y3, db, y1, z1);\n', '\n', '        if (da != db) {\n', '            x3 = mulmod(x3, db, n);\n', '            y3 = mulmod(y3, da, n);\n', '            z3 = mulmod(da, db, n);\n', '        } else {\n', '            z3 = da;\n', '        }\n', '    }\n', '\n', '    function _ecDouble(uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        (x3, y3, z3) = _ecAdd(x1, y1, z1, x1, y1, z1);\n', '    }\n', '\n', '    function _ecMul(uint256 d, uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 remaining = d;\n', '        uint256 px = x1;\n', '        uint256 py = y1;\n', '        uint256 pz = z1;\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (d == 0) {\n', '            return (0, 0, 1);\n', '        }\n', '\n', '        while (remaining != 0) {\n', '            if ((remaining & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx, acy, acz, px, py, pz);\n', '            }\n', '            remaining = remaining / 2;\n', '            (px, py, pz) = _ecDouble(px, py, pz);\n', '        }\n', '\n', '        (x3, y3, z3) = (acx, acy, acz);\n', '    }\n', '\n', '    function ecadd(\n', '        uint256 x1, uint256 y1,\n', '        uint256 x2, uint256 y2)\n', '        public\n', '        pure\n', '        returns(uint256 x3, uint256 y3)\n', '    {\n', '        uint256 z;\n', '        (x3, y3, z) = _ecAdd(x1, y1, 1, x2, y2, 1);\n', '        z = _inverse(z);\n', '        x3 = mulmod(x3, z, n);\n', '        y3 = mulmod(y3, z, n);\n', '    }\n', '\n', '    function ecmul(uint256 x1, uint256 y1, uint256 scalar) public pure\n', '        returns(uint256 x2, uint256 y2)\n', '    {\n', '        uint256 z;\n', '        (x2, y2, z) = _ecMul(scalar, x1, y1, 1);\n', '        z = _inverse(z);\n', '        x2 = mulmod(x2, z, n);\n', '        y2 = mulmod(y2, z, n);\n', '    }\n', '\n', '    function ecmulVerify(uint256 x1, uint256 y1, uint256 scalar, uint256 qx, uint256 qy) public pure\n', '        returns(bool)\n', '    {\n', '        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n', '        address signer = ecrecover(0, y1 % 2 != 0 ? 28 : 27, bytes32(x1), bytes32(mulmod(scalar, x1, m)));\n', '        address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '        return xyAddress == signer;\n', '    }\n', '\n', '    function publicKey(uint256 privKey) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        return ecmul(gx, gy, privKey);\n', '    }\n', '\n', '    function publicKeyVerify(uint256 privKey, uint256 x, uint256 y) public pure\n', '        returns(bool)\n', '    {\n', '        return ecmulVerify(gx, gy, privKey, x, y);\n', '    }\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 z;\n', '        (qx, qy, z) = _ecMul(privKey, pubX, pubY, 1);\n', '        z = _inverse(z);\n', '        qx = mulmod(qx, z, n);\n', '        qy = mulmod(qy, z, n);\n', '    }\n', '}']