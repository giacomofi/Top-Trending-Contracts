['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '\n', '   ____      _             _  __                                                    \n', '  / ___|___ (_)_ __  ___  | |/ /__ _ _ __ _ __ ___   __ _        ___ ___  _ __ ___  \n', ' | |   / _ \\| | &#39;_ \\/ __| | &#39; // _` | &#39;__| &#39;_ ` _ \\ / _` |      / __/ _ \\| &#39;_ ` _ \\ \n', ' | |__| (_) | | | | \\__ \\ | . \\ (_| | |  | | | | | | (_| |  _  | (_| (_) | | | | | |\n', '  \\____\\___/|_|_| |_|___/ |_|\\_\\__,_|_|  |_| |_| |_|\\__,_| (_)  \\___\\___/|_| |_| |_|\n', '                                                                                    \n', '\n', '*/\n', '\n', 'contract CoinsKarmaFactory is Ownable {\n', '\n', '    event NewCoinsKarma(uint coinsKarmaId, string name, string symbol, uint totalKarmaUp, uint totalKarmaDown, bool exists);\n', '    event NewKarmaVoter(uint karmaVoteId, uint coinsKarmaId, address voterAddress, uint up, uint down, uint voteTime, bool exists);\n', '\n', '    struct CoinsKarma {\n', '        string name;\n', '        string symbol;\n', '        uint totalKarmaUp;\n', '        uint totalKarmaDown;\n', '        bool exists;\n', '    }\n', '\n', '    struct KarmaVotes {\n', '        uint coinsKarmaId;\n', '        address voterAddress;\n', '        uint up;\n', '        uint down;\n', '        uint voteTime;\n', '        bool exists;\n', '    }\n', '\n', '    CoinsKarma[] public coinkarma;\n', '    mapping(string => uint) coinsKarmaCreated;\n', '    mapping(string => uint) coinsKarmaMap;\n', '\n', '    KarmaVotes[] public karmavoters;\n', '    mapping(address => mapping(uint => uint)) karmaVoterCreated;\n', '    mapping(address => mapping(uint => uint)) karmaVoterMap;\n', '\n', '    uint giveKarmaFee = 1800000000000000; // CoinsKarma tries to keep this around $1 and checks regularly to make sure of that. CoinsKarma can change this fee with the alterGiveKarmaFee funciton.\n', '\n', '    /********************************* */\n', '    // karma functions\n', '\n', '    function viewCoinsKarma(uint _coinsKarmaId) view public returns (uint, string, string, uint, uint, bool) {\n', '        CoinsKarma storage coinskarma = coinkarma[_coinsKarmaId];\n', '        return (_coinsKarmaId, coinskarma.name, coinskarma.symbol, coinskarma.totalKarmaUp, coinskarma.totalKarmaDown, coinskarma.exists);\n', '    }\n', '\n', '    function viewCoinsKarmaBySymbol(string _coinSymbol) view public returns (uint, string, string, uint, uint, bool) {\n', '        CoinsKarma storage coinskarma = coinkarma[coinsKarmaMap[_coinSymbol]];\n', '        if (coinskarma.exists == true) {\n', '            return (coinsKarmaMap[_coinSymbol], coinskarma.name, coinskarma.symbol, coinskarma.totalKarmaUp, coinskarma.totalKarmaDown, coinskarma.exists);\n', '        } else {\n', '            return (0, "", "", 0, 0, false);\n', '        }\n', '    }\n', '\n', '    function viewKarmaVotes(uint _karmaVoteId) view public returns (uint, uint, address, uint, uint, uint, bool) {\n', '        KarmaVotes storage karmavotes = karmavoters[_karmaVoteId];\n', '        return (_karmaVoteId, karmavotes.coinsKarmaId, karmavotes.voterAddress, karmavotes.up, karmavotes.down, karmavotes.voteTime, karmavotes.exists);\n', '    }\n', '\n', '    function viewKarmaVotesBySymbol(string _coinSymbol, address _userAddress) view public returns (uint, address, uint, uint, uint, string) {\n', '        uint getCoinsId = coinsKarmaMap[_coinSymbol];\n', '        if (karmavoters[karmaVoterMap[_userAddress][getCoinsId]].exists == true) {\n', '            return (karmavoters[karmaVoterMap[_userAddress][getCoinsId]].coinsKarmaId, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].voterAddress, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].up, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].down, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].voteTime, _coinSymbol);\n', '        } else {\n', '            return (0, 0x0, 0, 0, 0, "");\n', '        }\n', '    }\n', '\n', '    function giveKarma(uint _upOrDown, string _coinName, string _coinSymbol) payable public {\n', '        require(msg.value >= giveKarmaFee);\n', '\n', '        uint upVote = 0;\n', '        uint downVote = 0;\n', '        if(_upOrDown == 1){\n', '            downVote = 1;\n', '        } else if (_upOrDown == 2){\n', '            upVote = 1;\n', '        }\n', '\n', '        uint id;\n', '\n', '        // see if coinName is already created, if not, then create it\n', '        if (coinsKarmaCreated[_coinSymbol] == 0) {\n', '            // create it\n', '            id = coinkarma.push(CoinsKarma(_coinName, _coinSymbol, 0, 0, true)) - 1;\n', '            emit NewCoinsKarma(id, _coinName, _coinSymbol, 0, 0, true);\n', '\n', '            coinsKarmaMap[_coinSymbol] = id;\n', '            coinsKarmaCreated[_coinSymbol] = 1;\n', '\n', '        } else {\n', '            id = coinsKarmaMap[_coinSymbol];\n', '\n', '        }\n', '\n', '        // see if this user has already given karma for this coin\n', '        if (karmaVoterCreated[msg.sender][id] == 0) {\n', '            // hasent, create new KarmaVote\n', '            uint idd = karmavoters.push(KarmaVotes(id, msg.sender, upVote, downVote, now, true)) - 1;\n', '            emit NewKarmaVoter(idd, id, msg.sender, upVote, downVote, now, true);\n', '\n', '            karmaVoterCreated[msg.sender][id] = 1;\n', '            karmaVoterMap[msg.sender][id] = idd;\n', '\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp + upVote;\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown + downVote;\n', '\n', '        }else{\n', '            // has, update KarmaVote\n', '            if (karmavoters[karmaVoterMap[msg.sender][id]].up > 0){\n', '                coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp - 1;\n', '            } else if(karmavoters[karmaVoterMap[msg.sender][id]].down > 0) { \n', '                coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown - 1;\n', '            }\n', '            \n', '            karmavoters[karmaVoterMap[msg.sender][id]].up = upVote;\n', '            karmavoters[karmaVoterMap[msg.sender][id]].down = downVote;\n', '            karmavoters[karmaVoterMap[msg.sender][id]].voteTime = now;\n', '\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp + upVote;\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown + downVote;\n', '\n', '        }\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // admin functions\n', '\n', '    function viewGiveKarmaFee() public view returns(uint) {\n', '        return giveKarmaFee;\n', '    }\n', '\n', '    function alterGiveKarmaFee (uint _giveKarmaFee) public onlyOwner() {\n', '        giveKarmaFee = _giveKarmaFee;\n', '    }\n', '\n', '    function withdrawFromContract(address _to, uint _amount) payable external onlyOwner() {\n', '        _to.transfer(_amount);\n', '\n', '    }\n', '\n', '}']
['pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', '\n', '   ____      _             _  __                                                    \n', '  / ___|___ (_)_ __  ___  | |/ /__ _ _ __ _ __ ___   __ _        ___ ___  _ __ ___  \n', " | |   / _ \\| | '_ \\/ __| | ' // _` | '__| '_ ` _ \\ / _` |      / __/ _ \\| '_ ` _ \\ \n", ' | |__| (_) | | | | \\__ \\ | . \\ (_| | |  | | | | | | (_| |  _  | (_| (_) | | | | | |\n', '  \\____\\___/|_|_| |_|___/ |_|\\_\\__,_|_|  |_| |_| |_|\\__,_| (_)  \\___\\___/|_| |_| |_|\n', '                                                                                    \n', '\n', '*/\n', '\n', 'contract CoinsKarmaFactory is Ownable {\n', '\n', '    event NewCoinsKarma(uint coinsKarmaId, string name, string symbol, uint totalKarmaUp, uint totalKarmaDown, bool exists);\n', '    event NewKarmaVoter(uint karmaVoteId, uint coinsKarmaId, address voterAddress, uint up, uint down, uint voteTime, bool exists);\n', '\n', '    struct CoinsKarma {\n', '        string name;\n', '        string symbol;\n', '        uint totalKarmaUp;\n', '        uint totalKarmaDown;\n', '        bool exists;\n', '    }\n', '\n', '    struct KarmaVotes {\n', '        uint coinsKarmaId;\n', '        address voterAddress;\n', '        uint up;\n', '        uint down;\n', '        uint voteTime;\n', '        bool exists;\n', '    }\n', '\n', '    CoinsKarma[] public coinkarma;\n', '    mapping(string => uint) coinsKarmaCreated;\n', '    mapping(string => uint) coinsKarmaMap;\n', '\n', '    KarmaVotes[] public karmavoters;\n', '    mapping(address => mapping(uint => uint)) karmaVoterCreated;\n', '    mapping(address => mapping(uint => uint)) karmaVoterMap;\n', '\n', '    uint giveKarmaFee = 1800000000000000; // CoinsKarma tries to keep this around $1 and checks regularly to make sure of that. CoinsKarma can change this fee with the alterGiveKarmaFee funciton.\n', '\n', '    /********************************* */\n', '    // karma functions\n', '\n', '    function viewCoinsKarma(uint _coinsKarmaId) view public returns (uint, string, string, uint, uint, bool) {\n', '        CoinsKarma storage coinskarma = coinkarma[_coinsKarmaId];\n', '        return (_coinsKarmaId, coinskarma.name, coinskarma.symbol, coinskarma.totalKarmaUp, coinskarma.totalKarmaDown, coinskarma.exists);\n', '    }\n', '\n', '    function viewCoinsKarmaBySymbol(string _coinSymbol) view public returns (uint, string, string, uint, uint, bool) {\n', '        CoinsKarma storage coinskarma = coinkarma[coinsKarmaMap[_coinSymbol]];\n', '        if (coinskarma.exists == true) {\n', '            return (coinsKarmaMap[_coinSymbol], coinskarma.name, coinskarma.symbol, coinskarma.totalKarmaUp, coinskarma.totalKarmaDown, coinskarma.exists);\n', '        } else {\n', '            return (0, "", "", 0, 0, false);\n', '        }\n', '    }\n', '\n', '    function viewKarmaVotes(uint _karmaVoteId) view public returns (uint, uint, address, uint, uint, uint, bool) {\n', '        KarmaVotes storage karmavotes = karmavoters[_karmaVoteId];\n', '        return (_karmaVoteId, karmavotes.coinsKarmaId, karmavotes.voterAddress, karmavotes.up, karmavotes.down, karmavotes.voteTime, karmavotes.exists);\n', '    }\n', '\n', '    function viewKarmaVotesBySymbol(string _coinSymbol, address _userAddress) view public returns (uint, address, uint, uint, uint, string) {\n', '        uint getCoinsId = coinsKarmaMap[_coinSymbol];\n', '        if (karmavoters[karmaVoterMap[_userAddress][getCoinsId]].exists == true) {\n', '            return (karmavoters[karmaVoterMap[_userAddress][getCoinsId]].coinsKarmaId, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].voterAddress, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].up, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].down, karmavoters[karmaVoterMap[_userAddress][getCoinsId]].voteTime, _coinSymbol);\n', '        } else {\n', '            return (0, 0x0, 0, 0, 0, "");\n', '        }\n', '    }\n', '\n', '    function giveKarma(uint _upOrDown, string _coinName, string _coinSymbol) payable public {\n', '        require(msg.value >= giveKarmaFee);\n', '\n', '        uint upVote = 0;\n', '        uint downVote = 0;\n', '        if(_upOrDown == 1){\n', '            downVote = 1;\n', '        } else if (_upOrDown == 2){\n', '            upVote = 1;\n', '        }\n', '\n', '        uint id;\n', '\n', '        // see if coinName is already created, if not, then create it\n', '        if (coinsKarmaCreated[_coinSymbol] == 0) {\n', '            // create it\n', '            id = coinkarma.push(CoinsKarma(_coinName, _coinSymbol, 0, 0, true)) - 1;\n', '            emit NewCoinsKarma(id, _coinName, _coinSymbol, 0, 0, true);\n', '\n', '            coinsKarmaMap[_coinSymbol] = id;\n', '            coinsKarmaCreated[_coinSymbol] = 1;\n', '\n', '        } else {\n', '            id = coinsKarmaMap[_coinSymbol];\n', '\n', '        }\n', '\n', '        // see if this user has already given karma for this coin\n', '        if (karmaVoterCreated[msg.sender][id] == 0) {\n', '            // hasent, create new KarmaVote\n', '            uint idd = karmavoters.push(KarmaVotes(id, msg.sender, upVote, downVote, now, true)) - 1;\n', '            emit NewKarmaVoter(idd, id, msg.sender, upVote, downVote, now, true);\n', '\n', '            karmaVoterCreated[msg.sender][id] = 1;\n', '            karmaVoterMap[msg.sender][id] = idd;\n', '\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp + upVote;\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown + downVote;\n', '\n', '        }else{\n', '            // has, update KarmaVote\n', '            if (karmavoters[karmaVoterMap[msg.sender][id]].up > 0){\n', '                coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp - 1;\n', '            } else if(karmavoters[karmaVoterMap[msg.sender][id]].down > 0) { \n', '                coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown - 1;\n', '            }\n', '            \n', '            karmavoters[karmaVoterMap[msg.sender][id]].up = upVote;\n', '            karmavoters[karmaVoterMap[msg.sender][id]].down = downVote;\n', '            karmavoters[karmaVoterMap[msg.sender][id]].voteTime = now;\n', '\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaUp + upVote;\n', '            coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown = coinkarma[coinsKarmaMap[_coinSymbol]].totalKarmaDown + downVote;\n', '\n', '        }\n', '\n', '    }\n', '\n', '    /********************************* */\n', '    // admin functions\n', '\n', '    function viewGiveKarmaFee() public view returns(uint) {\n', '        return giveKarmaFee;\n', '    }\n', '\n', '    function alterGiveKarmaFee (uint _giveKarmaFee) public onlyOwner() {\n', '        giveKarmaFee = _giveKarmaFee;\n', '    }\n', '\n', '    function withdrawFromContract(address _to, uint _amount) payable external onlyOwner() {\n', '        _to.transfer(_amount);\n', '\n', '    }\n', '\n', '}']
