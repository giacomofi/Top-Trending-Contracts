['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath\n', '{\n', '    function mul(uint a, uint b) internal returns (uint)\n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal returns (uint)\n', '    {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal returns (uint)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function assert(bool assertion) internal\n', '    {\n', '        if (!assertion)\n', '        {\n', '            throw;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic\n', '{\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function transfer(address to, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic\n', '{\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '    function transferFrom(address from, address to, uint value);\n', '    function approve(address spender, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic\n', '{\n', '    using SafeMath for uint;\n', '    mapping(address => uint) balances;\n', '\n', '    /**\n', '     * @dev Fix for the ERC20 short address attack.\n', '     */\n', '    modifier onlyPayloadSize(uint size)\n', '    {\n', '        if(msg.data.length < size + 4)\n', '        {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20\n', '{\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint the amout of tokens to be transfered\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)\n', '    {\n', '        uint _allowance = allowed[_from][msg.sender];\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint _value)\n', '    {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint specifing the amount of tokens still avaible for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Sophos ERC20 token\n', ' *\n', ' * @dev Implementation of the Sophos Token.\n', ' */\n', 'contract SophosToken is StandardToken\n', '{\n', '    string public name = "Sophos";\n', '    string public symbol = "SOPH";\n', '    uint public decimals = 8 ;\n', '\n', '    // Initial supply is 30,000,000.00000000\n', '    // AKA: 3 * (10 ** ( 7 + decimals )) when expressed as uint\n', '    uint public INITIAL_SUPPLY = 3000000000000000;\n', '\n', '    // Allocation Constants\n', '\n', '    // Expiration Unix Timestamp: Friday, November 1, 2019 12:00:00 AM\n', '    // https://www.unixtimestamp.com\n', '    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;\n', '\n', '    address public constant RAVI_ADDRESS = 0xB75066802f677bb5354F0850A1e1d3968E983BE8;\n', '    uint public constant    RAVI_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address public constant JULIAN_ADDRESS = 0xB2A76D747fC4A076D7f4Db3bA91Be97e94beB01C;\n', '    uint public constant    JULIAN_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address  public constant ABDEL_ADDRESS = 0x9894989fd6CaefCcEB183B8eB668B2d5614bEBb6;\n', '    uint public constant     ABDEL_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address public constant ASHLEY_ADDRESS = 0xb37B31f004dD8259F3171Ca5FBD451C03c3bC0Ae;\n', '    uint public constant    ASHLEY_ALLOCATION = 210000000000000; // 7%\n', '\n', '    function SophosToken()\n', '    {\n', '        // Set total supply\n', '        totalSupply = INITIAL_SUPPLY;\n', '\n', '        // Allocate total supply to sender\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        // Subtract team member allocations from total supply\n', '        balances[msg.sender] -= RAVI_ALLOCATION;\n', '        balances[msg.sender] -= JULIAN_ALLOCATION;\n', '        balances[msg.sender] -= ABDEL_ALLOCATION;\n', '        balances[msg.sender] -= ASHLEY_ALLOCATION;\n', '\n', '        // Credit Team Member Allocation Addresses\n', '        balances[RAVI_ADDRESS]   = RAVI_ALLOCATION;\n', '        balances[JULIAN_ADDRESS] = JULIAN_ALLOCATION;\n', '        balances[ABDEL_ADDRESS]  = ABDEL_ALLOCATION;\n', '        balances[ASHLEY_ADDRESS] = ASHLEY_ALLOCATION;\n', '    }\n', '\n', '    // Stop transactions from team member allocations during lock period\n', '    function isAllocationLocked(address _spender) constant returns (bool)\n', '    {\n', '        return inAllocationLockPeriod() && isTeamMember(_spender);\n', '    }\n', '\n', '    // True if the current timestamp is before the allocation lock period\n', '    function inAllocationLockPeriod() constant returns (bool)\n', '    {\n', '        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n', '    }\n', '\n', '    // Is the spender address one of the Sophos Team?\n', '    function isTeamMember(address _spender) constant returns (bool)\n', '    {\n', '        return _spender == RAVI_ADDRESS  ||\n', '            _spender == JULIAN_ADDRESS ||\n', '            _spender == ABDEL_ADDRESS ||\n', '            _spender == ASHLEY_ADDRESS;\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function approve(address spender, uint tokens)\n', '    {\n', '        if (isAllocationLocked(spender))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.approve(spender, tokens);\n', '        }\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function transfer(address to, uint tokens) onlyPayloadSize(2 * 32)\n', '    {\n', '        if (isAllocationLocked(to))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.transfer(to, tokens);\n', '        }\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32)\n', '    {\n', '        if (isAllocationLocked(from) || isAllocationLocked(to))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.transferFrom(from, to, tokens);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath\n', '{\n', '    function mul(uint a, uint b) internal returns (uint)\n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal returns (uint)\n', '    {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal returns (uint)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function assert(bool assertion) internal\n', '    {\n', '        if (!assertion)\n', '        {\n', '            throw;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic\n', '{\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function transfer(address to, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic\n', '{\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '    function transferFrom(address from, address to, uint value);\n', '    function approve(address spender, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic\n', '{\n', '    using SafeMath for uint;\n', '    mapping(address => uint) balances;\n', '\n', '    /**\n', '     * @dev Fix for the ERC20 short address attack.\n', '     */\n', '    modifier onlyPayloadSize(uint size)\n', '    {\n', '        if(msg.data.length < size + 4)\n', '        {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)\n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) constant returns (uint balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20\n', '{\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint the amout of tokens to be transfered\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)\n', '    {\n', '        uint _allowance = allowed[_from][msg.sender];\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint _value)\n', '    {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint specifing the amount of tokens still avaible for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Sophos ERC20 token\n', ' *\n', ' * @dev Implementation of the Sophos Token.\n', ' */\n', 'contract SophosToken is StandardToken\n', '{\n', '    string public name = "Sophos";\n', '    string public symbol = "SOPH";\n', '    uint public decimals = 8 ;\n', '\n', '    // Initial supply is 30,000,000.00000000\n', '    // AKA: 3 * (10 ** ( 7 + decimals )) when expressed as uint\n', '    uint public INITIAL_SUPPLY = 3000000000000000;\n', '\n', '    // Allocation Constants\n', '\n', '    // Expiration Unix Timestamp: Friday, November 1, 2019 12:00:00 AM\n', '    // https://www.unixtimestamp.com\n', '    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;\n', '\n', '    address public constant RAVI_ADDRESS = 0xB75066802f677bb5354F0850A1e1d3968E983BE8;\n', '    uint public constant    RAVI_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address public constant JULIAN_ADDRESS = 0xB2A76D747fC4A076D7f4Db3bA91Be97e94beB01C;\n', '    uint public constant    JULIAN_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address  public constant ABDEL_ADDRESS = 0x9894989fd6CaefCcEB183B8eB668B2d5614bEBb6;\n', '    uint public constant     ABDEL_ALLOCATION = 120000000000000; // 4%\n', '\n', '    address public constant ASHLEY_ADDRESS = 0xb37B31f004dD8259F3171Ca5FBD451C03c3bC0Ae;\n', '    uint public constant    ASHLEY_ALLOCATION = 210000000000000; // 7%\n', '\n', '    function SophosToken()\n', '    {\n', '        // Set total supply\n', '        totalSupply = INITIAL_SUPPLY;\n', '\n', '        // Allocate total supply to sender\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        // Subtract team member allocations from total supply\n', '        balances[msg.sender] -= RAVI_ALLOCATION;\n', '        balances[msg.sender] -= JULIAN_ALLOCATION;\n', '        balances[msg.sender] -= ABDEL_ALLOCATION;\n', '        balances[msg.sender] -= ASHLEY_ALLOCATION;\n', '\n', '        // Credit Team Member Allocation Addresses\n', '        balances[RAVI_ADDRESS]   = RAVI_ALLOCATION;\n', '        balances[JULIAN_ADDRESS] = JULIAN_ALLOCATION;\n', '        balances[ABDEL_ADDRESS]  = ABDEL_ALLOCATION;\n', '        balances[ASHLEY_ADDRESS] = ASHLEY_ALLOCATION;\n', '    }\n', '\n', '    // Stop transactions from team member allocations during lock period\n', '    function isAllocationLocked(address _spender) constant returns (bool)\n', '    {\n', '        return inAllocationLockPeriod() && isTeamMember(_spender);\n', '    }\n', '\n', '    // True if the current timestamp is before the allocation lock period\n', '    function inAllocationLockPeriod() constant returns (bool)\n', '    {\n', '        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);\n', '    }\n', '\n', '    // Is the spender address one of the Sophos Team?\n', '    function isTeamMember(address _spender) constant returns (bool)\n', '    {\n', '        return _spender == RAVI_ADDRESS  ||\n', '            _spender == JULIAN_ADDRESS ||\n', '            _spender == ABDEL_ADDRESS ||\n', '            _spender == ASHLEY_ADDRESS;\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function approve(address spender, uint tokens)\n', '    {\n', '        if (isAllocationLocked(spender))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.approve(spender, tokens);\n', '        }\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function transfer(address to, uint tokens) onlyPayloadSize(2 * 32)\n', '    {\n', '        if (isAllocationLocked(to))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.transfer(to, tokens);\n', '        }\n', '    }\n', '\n', '    // Function wrapper to check for allocation lock\n', '    function transferFrom(address from, address to, uint tokens) onlyPayloadSize(3 * 32)\n', '    {\n', '        if (isAllocationLocked(from) || isAllocationLocked(to))\n', '        {\n', '            throw;\n', '        }\n', '        else\n', '        {\n', '            super.transferFrom(from, to, tokens);\n', '        }\n', '    }\n', '}']
