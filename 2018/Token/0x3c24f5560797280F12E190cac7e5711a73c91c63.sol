['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface TokenVestingInterface {\n', '    function getReleasableFunds() public view returns(uint256);\n', '    function release() public ;\n', '    function setWithdrawalAddress(address _newAddress) external;\n', '    function revoke(string _reason) public;\n', '    function getTokenBalance() public constant returns(uint256);\n', '    function updateBalanceOnFunding(uint256 _amount) external;\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external;\n', '}\n', '\n', '\n', 'interface VestingMasterInterface{\n', '    function amountLockedInVestings() view public returns (uint256);\n', '    function substractLockedAmount(uint256 _amount) external;\n', '    function addLockedAmount(uint256 _amount) external;\n', '    function addInternalBalance(uint256 _amount) external;\n', '}\n', '\n', 'contract TokenVestingContract is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    address public beneficiary;\n', '    address public tokenAddress;\n', '    uint256 public startTime;\n', '    uint256 public tickDuration;\n', '    uint256 public amountPerTick;\n', '    uint256 public version;\n', '    bool public revocable;\n', '    \n', '\n', '    uint256 public alreadyReleasedAmount;\n', '    bool public revoked;\n', '    uint256 public internalBalance;\n', '    \n', '    event Released(uint256 amount);\n', '    event RevokedAndDestroyed(string reason);\n', '    event WithdrawalAddressSet(address _newAddress);\n', '    event TokensReceivedSinceLastCheck(uint256 amount);\n', '    event VestingReceivedFunding(uint256 amount);\n', '\n', '    function TokenVestingContract(address _beneficiary,\n', '                address _tokenAddress,\n', '                uint256 _startTime, \n', '                uint256 _tickDuration, \n', '                uint256 _amountPerTick,\n', '                uint256 _version,\n', '                bool _revocable\n', '                )public onlyOwner{\n', '                    beneficiary = _beneficiary;\n', '                    tokenAddress = _tokenAddress;\n', '                    startTime = _startTime;\n', '                    tickDuration = _tickDuration;\n', '                    amountPerTick = _amountPerTick;\n', '                    version =  _version;\n', '                    revocable = _revocable;\n', '                    alreadyReleasedAmount = 0;\n', '                    revoked = false;\n', '                    internalBalance = 0;\n', '    }\n', '    \n', '    function getReleasableFunds() public view returns(uint256){\n', '        uint256 balance = ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n', '        // check if there is balance and if it is active yet\n', '        if (balance == 0 || (startTime >= now)){\n', '            return 0;\n', '        }\n', '        // all funds that may be released according to vesting schedule \n', '        uint256 vestingScheduleAmount = (now.sub(startTime) / tickDuration) * amountPerTick;\n', '        // deduct already released funds \n', '        uint256 releasableFunds = vestingScheduleAmount.sub(alreadyReleasedAmount);\n', '        // make sure to release remainder of funds for last payout\n', '        if(releasableFunds > balance){\n', '            releasableFunds = balance;\n', '        }\n', '        return releasableFunds;\n', '    }\n', '    \n', '    function setWithdrawalAddress(address _newAddress) public onlyOwner {\n', '        beneficiary = _newAddress;\n', '        \n', '        emit WithdrawalAddressSet(_newAddress);\n', '    }\n', '    \n', '    function release() public returns(uint256 transferedAmount) {\n', '        checkForReceivedTokens();\n', '        require(msg.sender == beneficiary);//, "Funds may be released only to beneficiary");\n', '        uint256 amountToTransfer = getReleasableFunds();\n', '        require(amountToTransfer > 0);//, "Out of funds");\n', '        // internal accounting\n', '        alreadyReleasedAmount = alreadyReleasedAmount.add(amountToTransfer);\n', '        internalBalance = internalBalance.sub(amountToTransfer);\n', '        VestingMasterInterface(owner).substractLockedAmount(amountToTransfer);\n', '        // actual transfer\n', '        ERC20TokenInterface(tokenAddress).transfer(beneficiary, amountToTransfer);\n', '        emit Released(amountToTransfer);\n', '        return amountToTransfer;\n', '    }\n', '    \n', '    function revoke(string _reason) external onlyOwner {\n', '        require(revocable);\n', '        // returns funds not yet vested according to vesting schedule\n', '        uint256 releasableFunds = getReleasableFunds();\n', '        ERC20TokenInterface(tokenAddress).transfer(beneficiary, releasableFunds);\n', '        VestingMasterInterface(owner).substractLockedAmount(releasableFunds);  // have to do it here, can&#39;t use return, because contract selfdestructs\n', '        // returns remainder of funds to VestingMaster and kill vesting contract\n', '        VestingMasterInterface(owner).addInternalBalance(getTokenBalance());\n', '        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n', '        emit RevokedAndDestroyed(_reason);\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    function getTokenBalance() public view returns(uint256 tokenBalance) {\n', '        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n', '    }\n', '    // todo public or internal?\n', '    // master calls this when it uploads funds in order to differentiate betwen funds from master and 3rd party\n', '    function updateBalanceOnFunding(uint256 _amount) external onlyOwner{\n', '        internalBalance = internalBalance.add(_amount);\n', '        emit VestingReceivedFunding(_amount);\n', '    }\n', '    // check for changes in balance in order to track amount of locked tokens and notify master\n', '    function checkForReceivedTokens() public{\n', '        if (getTokenBalance() != internalBalance){\n', '            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n', '            internalBalance = getTokenBalance();\n', '            VestingMasterInterface(owner).addLockedAmount(receivedFunds);\n', '            emit TokensReceivedSinceLastCheck(receivedFunds);\n', '        }\n', '    }\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external onlyOwner {\n', '        require(_tokenAddress != tokenAddress);\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '}\n', '\n', '\n', 'contract VestingMasterContract is Owned {\n', '    using SafeMath for uint256;\n', '   \n', '    // TODO: set this before deploy\n', '    address public constant tokenAddress = 0xc7C03B8a3FC5719066E185ea616e87B88eba44a3;   \n', '    uint256 public internalBalance = 0;\n', '    uint256 public amountLockedInVestings = 0;\n', '    \n', '    struct VestingStruct{\n', '        uint256 arrayPointer;\n', '        string vestingType;\n', '        uint256 version;\n', '        \n', '    }\n', '    address[] public vestingAddresses;\n', '    mapping (address => VestingStruct) public addressToVesting;\n', '    \n', '    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n', '    event LockedAmountDecreased(uint256 amount);\n', '    event LockedAmountIncreased(uint256 amount);\n', '    event TokensReceivedSinceLastCheck(uint256 amount);\n', '\n', '    ////////// STORAGE HELPERS  ///////////\n', '    function vestingExists(address _vestingAddress) public view returns(bool exists){\n', '        if(vestingAddresses.length == 0) {return false;}\n', '        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n', '    }\n', '    \n', '    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n', '        require(!vestingExists(_vestingAddress));\n', '        addressToVesting[_vestingAddress].version = _version;\n', '        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n', '        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n', '        return vestingAddresses.length;\n', '    }\n', '\n', '    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n', '        require(vestingExists(_vestingAddress));\n', '        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n', '        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n', '        vestingAddresses[indexToDelete] = keyToMove;\n', '        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n', '        vestingAddresses.length--;\n', '        return vestingAddresses.length;\n', '    }\n', '    \n', '    function createNewVesting(\n', '        // todo uncomment\n', '        address _beneficiary,\n', '        uint256 _startTime, \n', '        uint256 _tickDuration, \n', '        uint256 _amountPerTick,\n', '        string _vestingType,\n', '        uint256 _version,\n', '        bool _revocable\n', '        ) \n', '        \n', '        public onlyOwner returns(address){\n', '            TokenVestingContract newVesting = new TokenVestingContract(   \n', '                _beneficiary,\n', '                tokenAddress,\n', '                _startTime, \n', '                _tickDuration, \n', '                _amountPerTick,\n', '                _version,\n', '                _revocable\n', '                );\n', '           \n', '        storeNewVesting(newVesting, _vestingType, _version);\n', '        return newVesting;\n', '    }\n', '    \n', '    // add funds to vesting contract\n', '    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n', '        // convenience, so you don&#39;t have to call it manualy if you just uploaded funds\n', '        checkForReceivedTokens();\n', '        // check if there is actually enough funds\n', '        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n', '        // make sure that fundee is vesting contract on the list\n', '        require(vestingExists(_vestingContract)); \n', '        internalBalance = internalBalance.sub(_amount);\n', '        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n', '        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n', '        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n', '    }\n', '    \n', '    function getTokenBalance() public constant returns(uint256) {\n', '        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n', '    }\n', '    // revoke vesting; release releasable funds to beneficiary and return remaining to master and kill vesting contract\n', '    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n', '        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n', '        subVestingContract.revoke(_reason);\n', '        deleteVestingFromStorage(_vestingContract);\n', '    }\n', '    // when vesting is revoked it sends back remaining tokens and updates internalBalance\n', '    function addInternalBalance(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        internalBalance = internalBalance.add(_amount);\n', '    }\n', '    // vestings notifies if there has been any changes in amount of locked tokens\n', '    function addLockedAmount(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        amountLockedInVestings = amountLockedInVestings.add(_amount);\n', '        emit LockedAmountIncreased(_amount);\n', '    }\n', '    // vestings notifies if there has been any changes in amount of locked tokens\n', '    function substractLockedAmount(uint256 _amount) external {\n', '        require(vestingExists(msg.sender));\n', '        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n', '        emit LockedAmountDecreased(_amount);\n', '    }\n', '    // check for changes in balance in order to track amount of locked tokens\n', '    function checkForReceivedTokens() public{\n', '        if (getTokenBalance() != internalBalance){\n', '            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n', '            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n', '            internalBalance = getTokenBalance();\n', '            emit TokensReceivedSinceLastCheck(receivedFunds);\n', '        }else{\n', '        emit TokensReceivedSinceLastCheck(0);\n', '        }\n', '    }\n', '    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n', '        require(_tokenAddress != tokenAddress);\n', '        if (_contractAddress == address(this)){\n', '            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '        }\n', '        if (vestingExists(_contractAddress)){\n', '            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n', '        }\n', '    }\n', '    \n', '    function killContract() public onlyOwner{\n', '        require(vestingAddresses.length == 0);\n', '        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n', '        selfdestruct(owner);\n', '    }\n', '    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n', '        require(vestingExists(_vestingContract));\n', '        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n', '    }\n', '}\n', '\n', '\n', 'contract EligmaSupplyContract  is Owned {\n', '    address public tokenAddress;\n', '    address public vestingMasterAddress;\n', '    \n', '    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n', '        tokenAddress = _tokenAddress;\n', '        vestingMasterAddress = _vestingMasterAddress;\n', '    }\n', '    \n', '    function totalSupply() view public returns(uint256) {\n', '        return ERC20TokenInterface(tokenAddress).totalSupply();\n', '    }\n', '    \n', '    function lockedSupply() view public returns(uint256) {\n', '        return VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\n', '    }\n', '    \n', '    function avaliableSupply() view public returns(uint256) {\n', '        return ERC20TokenInterface(tokenAddress).totalSupply() - VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\n', '    }\n', '    \n', '    function setTokenAddress(address _tokenAddress) onlyOwner public {\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '    \n', '    function setVestingMasterAddress(address _vestingMasterAddress) onlyOwner public {\n', '        vestingMasterAddress = _vestingMasterAddress;\n', '    }\n', '}']