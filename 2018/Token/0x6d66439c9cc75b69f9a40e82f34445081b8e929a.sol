['pragma solidity ^0.4.21;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '/// ERC20 contract interface With ERC23/ERC223 Extensions\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    // ERC223 and ERC20 functions and events\n', '    function totalSupply() constant public returns (uint256 _supply);\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool ok);\n', '    function transfer(address to, uint256 value, bytes data) public returns (bool ok);\n', '    function name() constant public returns (string _name);\n', '    function symbol() constant public returns (string _symbol);\n', '    function decimals() constant public returns (uint8 _decimals);\n', '\n', '    // ERC20 functions and events\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    \n', '    // ERC20 Event \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event FrozenFunds(address target, bool frozen);\n', '\tevent Burn(address indexed from, uint256 value);\n', '    \n', '}\n', '\n', '/// Include SafeMath Lib\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) revert();\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x < y) revert();\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) revert();\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/// Contract that is working with ERC223 tokens\n', 'contract ContractReceiver {\n', '\tstruct TKN {\n', '        address sender;\n', '        uint256 value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public pure {\n', '      TKN memory tkn;\n', '      tkn.sender = _from;\n', '      tkn.value = _value;\n', '      tkn.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      tkn.sig = bytes4(u);\n', '    }\n', '\t\n', '\tfunction rewiewToken  () public pure returns (address, uint, bytes, bytes4) {\n', '        TKN memory tkn;\n', '        return (tkn.sender, tkn.value, tkn.data, tkn.sig);\n', '    }\n', '}\n', '\n', '/// Realthium is an ERC20 token with ERC223 Extensions\n', 'contract TokenRK50Z is ERC20, SafeMath {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    address public owner;\n', '    bool public SC_locked = false;\n', '    bool public tokenCreated = false;\n', '\tuint public DateCreateToken;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    mapping(address => bool) public frozenAccount;\n', '\tmapping(address => bool) public SmartContract_Allowed;\n', '\n', '    // Initialize\n', '    // Constructor is called only once and can not be called again (Ethereum Solidity specification)\n', '    function TokenRK50Z() public {\n', '        // Security check in case EVM has future flaw or exploit to call constructor multiple times\n', '        require(tokenCreated == false);\n', '\n', '        owner = msg.sender;\n', '        \n', '\t\tname = "RK50Z";\n', '        symbol = "RK50Z";\n', '        decimals = 5;\n', '        totalSupply = 500000000 * 10 ** uint256(decimals);\n', '        balances[owner] = totalSupply;\n', '        emit Transfer(owner, owner, totalSupply);\n', '\t\t\n', '        tokenCreated = true;\n', '\n', '        // Final sanity check to ensure owner balance is greater than zero\n', '        require(balances[owner] > 0);\n', '\n', '\t\t// Date Deploy Contract\n', '\t\tDateCreateToken = now;\n', '    }\n', '\t\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\t// Function to create date token.\n', '    function DateCreateToken() public view returns (uint256 _DateCreateToken) {\n', '\t\treturn DateCreateToken;\n', '\t}\n', '   \t\n', '    // Function to access name of token .\n', '    function name() view public returns (string _name) {\n', '\t\treturn name;\n', '\t}\n', '\t\n', '    // Function to access symbol of token .\n', '    function symbol() public view returns (string _symbol) {\n', '\t\treturn symbol;\n', '    }\n', '\n', '    // Function to access decimals of token .\n', '    function decimals() public view returns (uint8 _decimals) {\t\n', '\t\treturn decimals;\n', '    }\n', '\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() public view returns (uint256 _totalSupply) {\n', '\t\treturn totalSupply;\n', '\t}\n', '\t\n', '\t// Get balance of the address provided\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\t// Get Smart Contract of the address approved\n', '    function SmartContract_Allowed(address _target) constant public returns (bool _sc_address_allowed) {\n', '        return SmartContract_Allowed[_target];\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint256 _value, bytes _data) public  returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        // Once it is Locked, it is Locked forever and no one can lock again\n', '\t\trequire(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\t\n', '        if (isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        } \n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '\n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '        bytes memory empty;\n', '        if (isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        } \n', '        else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '\t// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private view returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length > 0);\n', '    }\n', '\n', '    // function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) revert();\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    // function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '        require(SmartContract_Allowed[_to]);\n', '\t\t\n', '\t\tif (balanceOf(msg.sender) < _value) revert();\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '   \n', '    // Allow transfers if the owner provided an allowance\n', '    // Use SafeMath for the main logic\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        // Once it is Locked, it is Locked forever and no one can lock again\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\t\n', '        // Protect against wrapping uints.\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        balances[_from] = safeSub(balanceOf(_from), _value);\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        }\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once unLocked\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_spender]);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '    }\n', '\t\n', '    /// Set allowance for other address and notify\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_spender]);\n', '\t\t\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\t\n', '\t/// Function to activate Ether reception in the smart Contract address only by the Owner\n', '    function () public payable { \n', '\t\tif(msg.sender != owner) { revert(); }\n', '    }\n', '\n', '\t// Creator/Owner can Locked/Unlock smart contract\n', '    function OWN_contractlocked(bool _locked) onlyOwner public {\n', '        SC_locked = _locked;\n', '    }\n', '\t\n', '\t/// Destroy tokens amount from another account (Caution!!! the operation is destructive and you can not go back)\n', '    function OWN_burnToken(address _from, uint256 _value)  onlyOwner public returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        balances[_from] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\t\n', '\t///Generate other tokens after starting the program\n', '    function OWN_mintToken(uint256 mintedAmount) onlyOwner public {\n', '        //aggiungo i decimali al valore che imposto\n', '        balances[owner] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, owner, mintedAmount);\n', '    }\n', '\t\n', '\t/// Block / Unlock address handling tokens\n', '    function OWN_freezeAddress(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\t\t\n', '\t/// Function to destroy the smart contract\n', '    function OWN_kill() onlyOwner public { \n', '\t\tselfdestruct(owner); \n', '    }\n', '\t\n', '\t/// Function Change Owner\n', '\tfunction OWN_transferOwnership(address newOwner) onlyOwner public {\n', '        // function allowed only if the address is not smart contract\n', '        if (!isContract(newOwner)) {\t\n', '\t\t\towner = newOwner;\n', '\t\t}\n', '    }\n', '\t\n', '\t/// Smart Contract approved\n', '    function OWN_SmartContract_Allowed(address target, bool _allowed) onlyOwner public {\n', '\t\t// function allowed only for smart contract\n', '        if (isContract(target)) {\n', '\t\t\tSmartContract_Allowed[target] = _allowed;\n', '\t\t}\n', '    }\n', '\n', '\t/// Distribution Token from Admin\n', '\tfunction OWN_DistributeTokenAdmin_Multi(address[] addresses, uint256 _value, bool freeze) onlyOwner public {\n', '\t\tfor (uint i = 0; i < addresses.length; i++) {\n', '\t\t\t//Block / Unlock address handling tokens\n', '\t\t\tfrozenAccount[addresses[i]] = freeze;\n', '\t\t\temit FrozenFunds(addresses[i], freeze);\n', '\t\t\t\n', '\t\t\tbytes memory empty;\n', '\t\t\tif (isContract(addresses[i])) {\n', '\t\t\t\ttransferToContract(addresses[i], _value, empty);\n', '\t\t\t} \n', '\t\t\telse {\n', '\t\t\t\ttransferToAddress(addresses[i], _value, empty);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '/// ERC20 contract interface With ERC23/ERC223 Extensions\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    // ERC223 and ERC20 functions and events\n', '    function totalSupply() constant public returns (uint256 _supply);\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool ok);\n', '    function transfer(address to, uint256 value, bytes data) public returns (bool ok);\n', '    function name() constant public returns (string _name);\n', '    function symbol() constant public returns (string _symbol);\n', '    function decimals() constant public returns (uint8 _decimals);\n', '\n', '    // ERC20 functions and events\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    \n', '    // ERC20 Event \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event FrozenFunds(address target, bool frozen);\n', '\tevent Burn(address indexed from, uint256 value);\n', '    \n', '}\n', '\n', '/// Include SafeMath Lib\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) revert();\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x < y) revert();\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) revert();\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/// Contract that is working with ERC223 tokens\n', 'contract ContractReceiver {\n', '\tstruct TKN {\n', '        address sender;\n', '        uint256 value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public pure {\n', '      TKN memory tkn;\n', '      tkn.sender = _from;\n', '      tkn.value = _value;\n', '      tkn.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      tkn.sig = bytes4(u);\n', '    }\n', '\t\n', '\tfunction rewiewToken  () public pure returns (address, uint, bytes, bytes4) {\n', '        TKN memory tkn;\n', '        return (tkn.sender, tkn.value, tkn.data, tkn.sig);\n', '    }\n', '}\n', '\n', '/// Realthium is an ERC20 token with ERC223 Extensions\n', 'contract TokenRK50Z is ERC20, SafeMath {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    address public owner;\n', '    bool public SC_locked = false;\n', '    bool public tokenCreated = false;\n', '\tuint public DateCreateToken;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    mapping(address => bool) public frozenAccount;\n', '\tmapping(address => bool) public SmartContract_Allowed;\n', '\n', '    // Initialize\n', '    // Constructor is called only once and can not be called again (Ethereum Solidity specification)\n', '    function TokenRK50Z() public {\n', '        // Security check in case EVM has future flaw or exploit to call constructor multiple times\n', '        require(tokenCreated == false);\n', '\n', '        owner = msg.sender;\n', '        \n', '\t\tname = "RK50Z";\n', '        symbol = "RK50Z";\n', '        decimals = 5;\n', '        totalSupply = 500000000 * 10 ** uint256(decimals);\n', '        balances[owner] = totalSupply;\n', '        emit Transfer(owner, owner, totalSupply);\n', '\t\t\n', '        tokenCreated = true;\n', '\n', '        // Final sanity check to ensure owner balance is greater than zero\n', '        require(balances[owner] > 0);\n', '\n', '\t\t// Date Deploy Contract\n', '\t\tDateCreateToken = now;\n', '    }\n', '\t\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\t// Function to create date token.\n', '    function DateCreateToken() public view returns (uint256 _DateCreateToken) {\n', '\t\treturn DateCreateToken;\n', '\t}\n', '   \t\n', '    // Function to access name of token .\n', '    function name() view public returns (string _name) {\n', '\t\treturn name;\n', '\t}\n', '\t\n', '    // Function to access symbol of token .\n', '    function symbol() public view returns (string _symbol) {\n', '\t\treturn symbol;\n', '    }\n', '\n', '    // Function to access decimals of token .\n', '    function decimals() public view returns (uint8 _decimals) {\t\n', '\t\treturn decimals;\n', '    }\n', '\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() public view returns (uint256 _totalSupply) {\n', '\t\treturn totalSupply;\n', '\t}\n', '\t\n', '\t// Get balance of the address provided\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\t// Get Smart Contract of the address approved\n', '    function SmartContract_Allowed(address _target) constant public returns (bool _sc_address_allowed) {\n', '        return SmartContract_Allowed[_target];\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint256 _value, bytes _data) public  returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        // Once it is Locked, it is Locked forever and no one can lock again\n', '\t\trequire(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\t\n', '        if (isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        } \n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '\n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '        bytes memory empty;\n', '        if (isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        } \n', '        else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '\t// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private view returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length > 0);\n', '    }\n', '\n', '    // function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) revert();\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    // function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '        require(SmartContract_Allowed[_to]);\n', '\t\t\n', '\t\tif (balanceOf(msg.sender) < _value) revert();\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '   \n', '    // Allow transfers if the owner provided an allowance\n', '    // Use SafeMath for the main logic\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once Locked\n', '        // Once it is Locked, it is Locked forever and no one can lock again\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[_from]);\n', '\t\trequire(!frozenAccount[_to]);\n', '\t\t\n', '        // Protect against wrapping uints.\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        balances[_from] = safeSub(balanceOf(_from), _value);\n', '        if (allowance < MAX_UINT256) {\n', '            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        }\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        // Only allow transfer once unLocked\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_spender]);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '    }\n', '\t\n', '    /// Set allowance for other address and notify\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        require(!SC_locked);\n', '\t\trequire(!frozenAccount[msg.sender]);\n', '\t\trequire(!frozenAccount[_spender]);\n', '\t\t\n', '\t\ttokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\t\n', '\t/// Function to activate Ether reception in the smart Contract address only by the Owner\n', '    function () public payable { \n', '\t\tif(msg.sender != owner) { revert(); }\n', '    }\n', '\n', '\t// Creator/Owner can Locked/Unlock smart contract\n', '    function OWN_contractlocked(bool _locked) onlyOwner public {\n', '        SC_locked = _locked;\n', '    }\n', '\t\n', '\t/// Destroy tokens amount from another account (Caution!!! the operation is destructive and you can not go back)\n', '    function OWN_burnToken(address _from, uint256 _value)  onlyOwner public returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        balances[_from] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\t\n', '\t///Generate other tokens after starting the program\n', '    function OWN_mintToken(uint256 mintedAmount) onlyOwner public {\n', '        //aggiungo i decimali al valore che imposto\n', '        balances[owner] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, owner, mintedAmount);\n', '    }\n', '\t\n', '\t/// Block / Unlock address handling tokens\n', '    function OWN_freezeAddress(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\t\t\n', '\t/// Function to destroy the smart contract\n', '    function OWN_kill() onlyOwner public { \n', '\t\tselfdestruct(owner); \n', '    }\n', '\t\n', '\t/// Function Change Owner\n', '\tfunction OWN_transferOwnership(address newOwner) onlyOwner public {\n', '        // function allowed only if the address is not smart contract\n', '        if (!isContract(newOwner)) {\t\n', '\t\t\towner = newOwner;\n', '\t\t}\n', '    }\n', '\t\n', '\t/// Smart Contract approved\n', '    function OWN_SmartContract_Allowed(address target, bool _allowed) onlyOwner public {\n', '\t\t// function allowed only for smart contract\n', '        if (isContract(target)) {\n', '\t\t\tSmartContract_Allowed[target] = _allowed;\n', '\t\t}\n', '    }\n', '\n', '\t/// Distribution Token from Admin\n', '\tfunction OWN_DistributeTokenAdmin_Multi(address[] addresses, uint256 _value, bool freeze) onlyOwner public {\n', '\t\tfor (uint i = 0; i < addresses.length; i++) {\n', '\t\t\t//Block / Unlock address handling tokens\n', '\t\t\tfrozenAccount[addresses[i]] = freeze;\n', '\t\t\temit FrozenFunds(addresses[i], freeze);\n', '\t\t\t\n', '\t\t\tbytes memory empty;\n', '\t\t\tif (isContract(addresses[i])) {\n', '\t\t\t\ttransferToContract(addresses[i], _value, empty);\n', '\t\t\t} \n', '\t\t\telse {\n', '\t\t\t\ttransferToAddress(addresses[i], _value, empty);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '}']
