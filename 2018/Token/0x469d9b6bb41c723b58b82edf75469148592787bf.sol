['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    address[] public managers;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        managers.push(msg.sender);\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(isManager(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isManager(address manager) view internal returns (bool ok) {\n', '        for (uint i = 0; i < managers.length; i++) {\n', '            if (managers[i] == manager) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function addManager(address manager) onlyOwner public {\n', '        require(manager != 0x0);\n', '        require(!isManager(manager));\n', '        managers.push(manager);\n', '    }\n', '\n', '    function removeManager(address manager) onlyOwner public {\n', '        require(manager != 0x0);\n', '        require(isManager(manager));\n', '        for (uint i = 0; i < managers.length; i++) {\n', '            if (managers[i] == manager) {\n', '                managers[i] = managers[managers.length - 1];\n', '                break;\n', '            }\n', '        }\n', '        managers.length -= 1;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public returns (bool success) {\n', '        require(newOwner != 0x0);\n', '        removeManager(owner);\n', '        addManager(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '    constructor() public payable { }\n', '\n', '    /**\n', '     * @dev Transfers the current balance to the owner and terminates the contract.\n', '     */\n', '    function destroy() onlyOwner public {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function destroyAndSend(address _recipient) onlyOwner public {\n', '        selfdestruct(_recipient);\n', '    }\n', '}\n', '\n', 'contract LooisCornerstoneHolder is Ownable, Destructible {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    ERC20 public token;\n', '    bool public tokenInitialized;\n', '    bool public stopInvest;\n', '    uint256 public totalSupply;\n', '    uint256 public restSupply;\n', '    uint256 public releaseTime;\n', '    uint8 public releasedRoundCount;\n', '\n', '    // release percent of each round\n', '    uint8 public firstRoundPercent;\n', '    uint8 public secondRoundPercent;\n', '    uint8 public thirdRoundPercent;\n', '    uint8 public fourthRoundPercent;\n', '\n', '    address[] public investors;\n', '    mapping(address => uint256) public investorAmount;\n', '    mapping(address => uint256) public releasedAmount;\n', '\n', '    event Release(address indexed _investor, uint256 indexed _value);\n', '\n', '    modifier onlyTokenInitialized() {\n', '        require(tokenInitialized);\n', '        _;\n', '    }\n', '\n', '    constructor(uint8 _firstRoundPercent, uint8 _secondRoundPercent, uint8 _thirdRoundPercent, uint8 _fourthRoundPercent) public {\n', '        require(_firstRoundPercent + _secondRoundPercent + _thirdRoundPercent + _fourthRoundPercent == 100);\n', '\n', '        firstRoundPercent = _firstRoundPercent;\n', '        secondRoundPercent = _secondRoundPercent;\n', '        thirdRoundPercent = _thirdRoundPercent;\n', '        fourthRoundPercent = _fourthRoundPercent;\n', '        tokenInitialized = false;\n', '        stopInvest = false;\n', '        releasedRoundCount = 0;\n', '    }\n', '\n', '    function initTokenAndReleaseTime(ERC20 _token, uint256 _releaseTime) onlyOwner public {\n', '        require(!tokenInitialized);\n', '        require(_releaseTime > block.timestamp);\n', '\n', '        releaseTime = _releaseTime;\n', '        token = _token;\n', '        totalSupply = token.balanceOf(this);\n', '        restSupply = totalSupply;\n', '        tokenInitialized = true;\n', '    }\n', '\n', '    function isInvestor(address _investor) view internal returns (bool ok) {\n', '        for (uint i = 0; i < investors.length; i++) {\n', '            if (investors[i] == _investor) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function addInvestor(address _investor, uint256 _value) onlyManager onlyTokenInitialized public {\n', '        require(_investor != 0x0);\n', '        require(_value > 0);\n', '        require(!stopInvest);\n', '\n', '        uint256 value = 10**18 * _value;\n', '        if (!isInvestor(_investor)) {\n', '            require(restSupply > value);\n', '\n', '            investors.push(_investor);\n', '        } else {\n', '            require(restSupply + investorAmount[_investor] > value);\n', '\n', '            restSupply = restSupply.add(investorAmount[_investor]);\n', '        }\n', '        restSupply = restSupply.sub(value);\n', '        investorAmount[_investor] = value;\n', '    }\n', '\n', '    function removeInvestor(address _investor) onlyManager onlyTokenInitialized public {\n', '        require(_investor != 0x0);\n', '        require(!stopInvest);\n', '        require(isInvestor(_investor));\n', '\n', '        for (uint i = 0; i < investors.length; i++) {\n', '            if (investors[i] == _investor) {\n', '                investors[i] = investors[investors.length - 1];\n', '                restSupply = restSupply.add(investorAmount[_investor]);\n', '                investorAmount[_investor] = 0;\n', '                break;\n', '            }\n', '        }\n', '        investors.length -= 1;\n', '    }\n', '\n', '    function release() onlyManager onlyTokenInitialized public {\n', '        require(releasedRoundCount <= 3);\n', '        require(block.timestamp >= releaseTime);\n', '\n', '        uint8 releasePercent;\n', '        if (releasedRoundCount == 0) {\n', '            releasePercent = firstRoundPercent;\n', '        } else if (releasedRoundCount == 1) {\n', '            releasePercent = secondRoundPercent;\n', '        } else if (releasedRoundCount == 2) {\n', '            releasePercent = thirdRoundPercent;\n', '        } else {\n', '            releasePercent = fourthRoundPercent;\n', '        }\n', '\n', '        for (uint8 i = 0; i < investors.length; i++) {\n', '            address investor = investors[i];\n', '            uint256 amount = investorAmount[investor];\n', '            if (amount > 0) {\n', '                uint256 releaseAmount = amount.div(100).mul(releasePercent);\n', '                if (releasedAmount[investor].add(releaseAmount) > amount) {\n', '                    releaseAmount = amount.sub(releasedAmount[investor]);\n', '                }\n', '                token.safeTransfer(investor, releaseAmount);\n', '                releasedAmount[investor] = releasedAmount[investor].add(releaseAmount);\n', '                emit Release(investor, releaseAmount);\n', '            }\n', '        }\n', '        // Next release time is 30 days later.\n', '        releaseTime = releaseTime.add(60 * 60 * 24 * 30);\n', '        releasedRoundCount = releasedRoundCount + 1;\n', '        stopInvest = true;\n', '    }\n', '\n', '    // if the balance of this contract is not empty, release all balance to the owner\n', '    function releaseRestBalance() onlyOwner onlyTokenInitialized public {\n', '        require(releasedRoundCount > 3);\n', '        uint256 balance = token.balanceOf(this);\n', '        require(balance > 0);\n', '\n', '        token.safeTransfer(owner, balance);\n', '        emit Release(owner, balance);\n', '    }\n', '\n', '    // if the balance of this contract is not empty, release all balance to a recipient\n', '    function releaseRestBalanceAndSend(address _recipient) onlyOwner onlyTokenInitialized public {\n', '        require(_recipient != 0x0);\n', '        require(releasedRoundCount > 3);\n', '        uint256 balance = token.balanceOf(this);\n', '        require(balance > 0);\n', '\n', '        token.safeTransfer(_recipient, balance);\n', '        emit Release(_recipient, balance);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    address[] public managers;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        managers.push(msg.sender);\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(isManager(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isManager(address manager) view internal returns (bool ok) {\n', '        for (uint i = 0; i < managers.length; i++) {\n', '            if (managers[i] == manager) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function addManager(address manager) onlyOwner public {\n', '        require(manager != 0x0);\n', '        require(!isManager(manager));\n', '        managers.push(manager);\n', '    }\n', '\n', '    function removeManager(address manager) onlyOwner public {\n', '        require(manager != 0x0);\n', '        require(isManager(manager));\n', '        for (uint i = 0; i < managers.length; i++) {\n', '            if (managers[i] == manager) {\n', '                managers[i] = managers[managers.length - 1];\n', '                break;\n', '            }\n', '        }\n', '        managers.length -= 1;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public returns (bool success) {\n', '        require(newOwner != 0x0);\n', '        removeManager(owner);\n', '        addManager(newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '    constructor() public payable { }\n', '\n', '    /**\n', '     * @dev Transfers the current balance to the owner and terminates the contract.\n', '     */\n', '    function destroy() onlyOwner public {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function destroyAndSend(address _recipient) onlyOwner public {\n', '        selfdestruct(_recipient);\n', '    }\n', '}\n', '\n', 'contract LooisCornerstoneHolder is Ownable, Destructible {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    ERC20 public token;\n', '    bool public tokenInitialized;\n', '    bool public stopInvest;\n', '    uint256 public totalSupply;\n', '    uint256 public restSupply;\n', '    uint256 public releaseTime;\n', '    uint8 public releasedRoundCount;\n', '\n', '    // release percent of each round\n', '    uint8 public firstRoundPercent;\n', '    uint8 public secondRoundPercent;\n', '    uint8 public thirdRoundPercent;\n', '    uint8 public fourthRoundPercent;\n', '\n', '    address[] public investors;\n', '    mapping(address => uint256) public investorAmount;\n', '    mapping(address => uint256) public releasedAmount;\n', '\n', '    event Release(address indexed _investor, uint256 indexed _value);\n', '\n', '    modifier onlyTokenInitialized() {\n', '        require(tokenInitialized);\n', '        _;\n', '    }\n', '\n', '    constructor(uint8 _firstRoundPercent, uint8 _secondRoundPercent, uint8 _thirdRoundPercent, uint8 _fourthRoundPercent) public {\n', '        require(_firstRoundPercent + _secondRoundPercent + _thirdRoundPercent + _fourthRoundPercent == 100);\n', '\n', '        firstRoundPercent = _firstRoundPercent;\n', '        secondRoundPercent = _secondRoundPercent;\n', '        thirdRoundPercent = _thirdRoundPercent;\n', '        fourthRoundPercent = _fourthRoundPercent;\n', '        tokenInitialized = false;\n', '        stopInvest = false;\n', '        releasedRoundCount = 0;\n', '    }\n', '\n', '    function initTokenAndReleaseTime(ERC20 _token, uint256 _releaseTime) onlyOwner public {\n', '        require(!tokenInitialized);\n', '        require(_releaseTime > block.timestamp);\n', '\n', '        releaseTime = _releaseTime;\n', '        token = _token;\n', '        totalSupply = token.balanceOf(this);\n', '        restSupply = totalSupply;\n', '        tokenInitialized = true;\n', '    }\n', '\n', '    function isInvestor(address _investor) view internal returns (bool ok) {\n', '        for (uint i = 0; i < investors.length; i++) {\n', '            if (investors[i] == _investor) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function addInvestor(address _investor, uint256 _value) onlyManager onlyTokenInitialized public {\n', '        require(_investor != 0x0);\n', '        require(_value > 0);\n', '        require(!stopInvest);\n', '\n', '        uint256 value = 10**18 * _value;\n', '        if (!isInvestor(_investor)) {\n', '            require(restSupply > value);\n', '\n', '            investors.push(_investor);\n', '        } else {\n', '            require(restSupply + investorAmount[_investor] > value);\n', '\n', '            restSupply = restSupply.add(investorAmount[_investor]);\n', '        }\n', '        restSupply = restSupply.sub(value);\n', '        investorAmount[_investor] = value;\n', '    }\n', '\n', '    function removeInvestor(address _investor) onlyManager onlyTokenInitialized public {\n', '        require(_investor != 0x0);\n', '        require(!stopInvest);\n', '        require(isInvestor(_investor));\n', '\n', '        for (uint i = 0; i < investors.length; i++) {\n', '            if (investors[i] == _investor) {\n', '                investors[i] = investors[investors.length - 1];\n', '                restSupply = restSupply.add(investorAmount[_investor]);\n', '                investorAmount[_investor] = 0;\n', '                break;\n', '            }\n', '        }\n', '        investors.length -= 1;\n', '    }\n', '\n', '    function release() onlyManager onlyTokenInitialized public {\n', '        require(releasedRoundCount <= 3);\n', '        require(block.timestamp >= releaseTime);\n', '\n', '        uint8 releasePercent;\n', '        if (releasedRoundCount == 0) {\n', '            releasePercent = firstRoundPercent;\n', '        } else if (releasedRoundCount == 1) {\n', '            releasePercent = secondRoundPercent;\n', '        } else if (releasedRoundCount == 2) {\n', '            releasePercent = thirdRoundPercent;\n', '        } else {\n', '            releasePercent = fourthRoundPercent;\n', '        }\n', '\n', '        for (uint8 i = 0; i < investors.length; i++) {\n', '            address investor = investors[i];\n', '            uint256 amount = investorAmount[investor];\n', '            if (amount > 0) {\n', '                uint256 releaseAmount = amount.div(100).mul(releasePercent);\n', '                if (releasedAmount[investor].add(releaseAmount) > amount) {\n', '                    releaseAmount = amount.sub(releasedAmount[investor]);\n', '                }\n', '                token.safeTransfer(investor, releaseAmount);\n', '                releasedAmount[investor] = releasedAmount[investor].add(releaseAmount);\n', '                emit Release(investor, releaseAmount);\n', '            }\n', '        }\n', '        // Next release time is 30 days later.\n', '        releaseTime = releaseTime.add(60 * 60 * 24 * 30);\n', '        releasedRoundCount = releasedRoundCount + 1;\n', '        stopInvest = true;\n', '    }\n', '\n', '    // if the balance of this contract is not empty, release all balance to the owner\n', '    function releaseRestBalance() onlyOwner onlyTokenInitialized public {\n', '        require(releasedRoundCount > 3);\n', '        uint256 balance = token.balanceOf(this);\n', '        require(balance > 0);\n', '\n', '        token.safeTransfer(owner, balance);\n', '        emit Release(owner, balance);\n', '    }\n', '\n', '    // if the balance of this contract is not empty, release all balance to a recipient\n', '    function releaseRestBalanceAndSend(address _recipient) onlyOwner onlyTokenInitialized public {\n', '        require(_recipient != 0x0);\n', '        require(releasedRoundCount > 3);\n', '        uint256 balance = token.balanceOf(this);\n', '        require(balance > 0);\n', '\n', '        token.safeTransfer(_recipient, balance);\n', '        emit Release(_recipient, balance);\n', '    }\n', '}']
