['pragma solidity ^0.4.18;\n', '// Symbol      : VTA\n', '// Name        : Vita Token\n', '// Total supply: 10 ** 28\n', '// Decimals    : 18\n', '//import &#39;./SafeMath.sol&#39;;\n', '//import &#39;./ERC20Interface.sol&#39;;\n', '//Sobre vita reward:\n', '//El token se crea primero y luego se asigna la direcci&#243;n de vita reward\n', '\n', '// ----- Safe Math\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '//------------\n', '// ----- ERC20Interface\n', 'contract ERC20Interface {\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '//------------\n', '\n', 'contract VitaToken is ERC20Interface, SafeMath {\n', '    string public symbol;\n', '    string public name;\n', '    uint8 public decimals;\n', '    address public manager;\n', '    address public reward_contract;\n', '    uint public crowd_start_date;\n', '    uint public crowd_end_date;\n', '    uint public first_bonus_duration;\n', '    uint public second_bonus_duration;\n', '    uint public extra_bonus_duration;\n', '    //uint public third_bonus_duration;\n', '    uint public first_bonus_amount;\n', '    uint public second_bonus_amount;\n', '    uint public third_bonus_amount;\n', '    uint public extra_bonus_amount;\n', '    uint public ETH_VTA;\n', '    uint public total_reward_amount;\n', '    uint public max_crowd_vitas;\n', '    uint public collected_crowd_vitas;\n', '    //Cantidad total recaudada en wei\n', '    uint public collected_crowd_wei;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => uint) rewards;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    function VitaToken() public {\n', '        symbol = "VTA";\n', '        name = "Vita Token";\n', '        //Razones para usar la cantidad estandar de decimales:\n', '        //Todos los envios de dinero se hacen con wei, que es 1 seguido de 18 ceros\n', '        //Seguir el estandar facilita los calculos, especialmente en el crowdsale\n', '        //\n', '        decimals = 18;\n', '        ETH_VTA = 100000;\n', '        //Weis recaudados en crowdsale\n', '        collected_crowd_wei = 0;\n', '        //3 mil millones mas 18 decimales\n', '        max_crowd_vitas = 3 * 10 ** 27;\n', '        //Vitas recaudadas en crowdsale\n', '        collected_crowd_vitas = 0;\n', '        // 10 mil millones m&#225;s 18 decimales\n', '        totalSupply = 10 ** 28;\n', '        manager = msg.sender;\n', '        //Mitad para reward, mitad para el equipo\n', '        total_reward_amount = totalSupply / 2;\n', '        balances[manager] = totalSupply / 2;\n', '\n', '        crowd_start_date = now;\n', '        extra_bonus_duration = 4 days;\n', '        //El crowdsale termina 122 d&#237;as de lanzar el SC (15 agosto)\n', '        crowd_end_date = crowd_start_date + extra_bonus_duration + 122 days;\n', '        //la duraci&#243;n del primer bono es de 47 d&#237;as (15 de abril - 1 de junio)\n', '        first_bonus_duration = 47 days;\n', '        //la duraci&#243;n del segundo bono es de 30 d&#237;as (1 de junio - 1 de julio)\n', '        second_bonus_duration = 30 days;\n', '        //la duraci&#243;n del tercer bono es de 45 d&#237;as, no es relevante agregarla porque es el caso final (1 de julio - 15 de agosto)\n', '\n', '\n', '        extra_bonus_amount = 40000;\n', '        first_bonus_amount = 35000;\n', '        second_bonus_amount = 20000;\n', '        third_bonus_amount = 10000;\n', '    }\n', '\n', '    modifier restricted(){\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    //Decorador para m&#233;todos que solo pueden ser accedidos a trav&#233;s de Vita reward\n', '    modifier onlyVitaReward(){\n', '        require(msg.sender == reward_contract);\n', '        _;\n', '    }\n', '    //Transferir propiedad del contrato\n', '    function transferOwnership(address new_manager) public restricted {\n', '        emit OwnershipTransferred(manager, new_manager);\n', '        manager = new_manager;\n', '    }\n', '\n', '    //Cambiar el contrato de Vita reward\n', '    function newVitaReward(address new_reward_contract) public restricted {\n', '        uint amount_to_transfer;\n', '        if(reward_contract == address(0)){\n', '            amount_to_transfer = total_reward_amount;\n', '        }else{\n', '            amount_to_transfer = balances[reward_contract];\n', '        }\n', '        balances[new_reward_contract] = amount_to_transfer;\n', '        balances[reward_contract] = 0;\n', '        reward_contract = new_reward_contract;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function rewardsOf(address _owner) public view returns (uint balance) {\n', '        return rewards[_owner];\n', '    }\n', '\n', '    //tokens debe ser el n&#250;mero de tokens seguido del n&#250;mero de decimales\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    //tokens debe ser el n&#250;mero de tokens seguido del n&#250;mero de decimales\n', '    function reward(address patient, address company, uint tokens_patient, uint tokens_company, uint tokens_vita_team) public onlyVitaReward returns (bool success) {\n', '        balances[reward_contract] = safeSub(balances[reward_contract], (tokens_patient + tokens_company + tokens_vita_team));\n', '        //Se envian los tokens del paciente, normalmente el 90%\n', '        balances[patient] = safeAdd(balances[patient], tokens_patient);\n', '        //Se envian los tokens a la compa&#241;ia que hizo la llamada a reward, normalmente 5%\n', '        balances[company] = safeAdd(balances[company], tokens_company);\n', '        //Se envian los tokens al equipo de vita, normalmente 5%\n', '        balances[manager] = safeAdd(balances[manager], tokens_vita_team);\n', '        rewards[patient] = safeAdd(rewards[patient], 1);\n', '        emit Transfer(reward_contract, patient, tokens_patient);\n', '        emit Transfer(reward_contract, company, tokens_company);\n', '        emit Transfer(reward_contract, manager, tokens_vita_team);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces\n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    //\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        require(balances[from] >= tokens && allowed[from][msg.sender] >= tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Permite determinar cuantas VTA tiene un usuario permitido gastar\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function () public payable {\n', '        require(now >= crowd_start_date && now <= crowd_end_date);\n', '        require(collected_crowd_vitas < max_crowd_vitas);\n', '        uint tokens;\n', '        if(now <= crowd_start_date + extra_bonus_duration){\n', '            tokens = msg.value * (ETH_VTA + extra_bonus_amount);\n', '        }else if(now <= crowd_start_date + extra_bonus_duration + first_bonus_duration){\n', '            tokens = msg.value * (ETH_VTA + first_bonus_amount);\n', '        }else if(now <= crowd_start_date + extra_bonus_duration + first_bonus_duration + second_bonus_duration){\n', '            tokens = msg.value * (ETH_VTA + second_bonus_amount);\n', '        }else{\n', '            tokens = msg.value * (ETH_VTA + third_bonus_amount);\n', '        }\n', '\n', '        balances[manager] = safeSub(balances[manager], tokens);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\n', '        emit Transfer(manager, msg.sender, tokens);\n', '        collected_crowd_wei += msg.value;\n', '        collected_crowd_vitas += tokens;\n', '        manager.transfer(msg.value);\n', '    }\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '}']