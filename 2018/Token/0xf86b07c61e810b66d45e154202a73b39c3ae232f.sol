['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 {\n', '      function totalSupply() constant returns (uint256 totalSupply);\n', '      function balanceOf(address _owner) constant returns (uint balance);\n', '      function transfer(address _to, uint _value) returns (bool success);\n', '      function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '      function approve(address _spender, uint _value) returns (bool success);\n', '      function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', ' }\n', '\n', 'contract OGR is ERC20 {\n', '    \n', '       using SafeMath for uint256;\n', '       \n', '       uint public _totalSupply = 0;\n', '       \n', '       bool public executed = false;\n', '       \n', '       address public owner;\n', '       string public symbol;\n', '       string public name;\n', '       uint8 public decimals;\n', '       uint256 public unitsOneEthCanBuy;\n', '       \n', '       mapping(address => uint256) balances;\n', '       mapping(address => mapping(address => uint256)) allowed;\n', '       \n', '       function () payable {\n', '           createTokens();\n', '       }\n', '       \n', '       function ICO (string _symbol, string _name, uint8 _decimals, uint256 _unitsOneEthCanBuy) {\n', '           owner = msg.sender;\n', '           symbol = _symbol;\n', '           name = _name;\n', '           decimals = _decimals;\n', '           unitsOneEthCanBuy = _unitsOneEthCanBuy;\n', '       }\n', '       \n', '       function createTokens() payable {\n', '           require(msg.value > 0);\n', '           uint256 tokens = msg.value.mul(unitsOneEthCanBuy);\n', '           _totalSupply = _totalSupply.add(tokens);\n', '           balances[msg.sender] = balances[msg.sender].add(tokens);\n', '           owner.transfer(msg.value);\n', '\t\t   executed = true;\n', '       }\n', '       \n', '       function totalSupply() constant returns (uint256) {\n', '           return _totalSupply;\n', '       }\n', '       \n', '       function balanceOf (address _owner) constant returns (uint256) {\n', '           return balances[_owner];\n', '       }\n', '       \n', '       function transfer(address _to, uint256 _value) returns (bool) {\n', '           require(balances[msg.sender] >= _value && _value > 0);\n', '           balances[msg.sender] = balances[msg.sender].sub(_value);\n', '           balances[_to] = balances[_to].add(_value);\n', '           Transfer(msg.sender, _to, _value);\n', '           return true;\n', '       }\n', '       \n', '       function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '           require (allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\n', '           balances[_from] = balances[_from].sub(_value);\n', '           balances[_to] = balances[_to].add(_value);\n', '           allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '           Transfer(_from, _to, _value);\n', '           return true;\n', '       }\n', '       \n', '       function approve (address _spender, uint256 _value) returns (bool) {\n', '           allowed[msg.sender][_spender] = _value;\n', '           Approval(msg.sender, _spender, _value);\n', '           return true;\n', '       }\n', '       \n', '       function allowance(address _owner, address _spender) constant returns (uint256) {\n', '           return allowed[_owner][_spender];\n', '       }\n', '       \n', '       event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '       event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20 {\n', '      function totalSupply() constant returns (uint256 totalSupply);\n', '      function balanceOf(address _owner) constant returns (uint balance);\n', '      function transfer(address _to, uint _value) returns (bool success);\n', '      function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '      function approve(address _spender, uint _value) returns (bool success);\n', '      function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', ' }\n', '\n', 'contract OGR is ERC20 {\n', '    \n', '       using SafeMath for uint256;\n', '       \n', '       uint public _totalSupply = 0;\n', '       \n', '       bool public executed = false;\n', '       \n', '       address public owner;\n', '       string public symbol;\n', '       string public name;\n', '       uint8 public decimals;\n', '       uint256 public unitsOneEthCanBuy;\n', '       \n', '       mapping(address => uint256) balances;\n', '       mapping(address => mapping(address => uint256)) allowed;\n', '       \n', '       function () payable {\n', '           createTokens();\n', '       }\n', '       \n', '       function ICO (string _symbol, string _name, uint8 _decimals, uint256 _unitsOneEthCanBuy) {\n', '           owner = msg.sender;\n', '           symbol = _symbol;\n', '           name = _name;\n', '           decimals = _decimals;\n', '           unitsOneEthCanBuy = _unitsOneEthCanBuy;\n', '       }\n', '       \n', '       function createTokens() payable {\n', '           require(msg.value > 0);\n', '           uint256 tokens = msg.value.mul(unitsOneEthCanBuy);\n', '           _totalSupply = _totalSupply.add(tokens);\n', '           balances[msg.sender] = balances[msg.sender].add(tokens);\n', '           owner.transfer(msg.value);\n', '\t\t   executed = true;\n', '       }\n', '       \n', '       function totalSupply() constant returns (uint256) {\n', '           return _totalSupply;\n', '       }\n', '       \n', '       function balanceOf (address _owner) constant returns (uint256) {\n', '           return balances[_owner];\n', '       }\n', '       \n', '       function transfer(address _to, uint256 _value) returns (bool) {\n', '           require(balances[msg.sender] >= _value && _value > 0);\n', '           balances[msg.sender] = balances[msg.sender].sub(_value);\n', '           balances[_to] = balances[_to].add(_value);\n', '           Transfer(msg.sender, _to, _value);\n', '           return true;\n', '       }\n', '       \n', '       function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '           require (allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\n', '           balances[_from] = balances[_from].sub(_value);\n', '           balances[_to] = balances[_to].add(_value);\n', '           allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '           Transfer(_from, _to, _value);\n', '           return true;\n', '       }\n', '       \n', '       function approve (address _spender, uint256 _value) returns (bool) {\n', '           allowed[msg.sender][_spender] = _value;\n', '           Approval(msg.sender, _spender, _value);\n', '           return true;\n', '       }\n', '       \n', '       function allowance(address _owner, address _spender) constant returns (uint256) {\n', '           return allowed[_owner][_spender];\n', '       }\n', '       \n', '       event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '       event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}']
