['pragma solidity ^0.4.18;\n', '\n', '/** SafeMath libs are inspired by:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '  * There is debate as to whether this lib should use assert or require:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/issues/565\n', '\n', '  * `require` is used in these libraries for the following reasons:\n', '  *   - overflows should not be checked in contract function bodies; DRY\n', '  *   - "valid" user input can cause overflows, which should not assert()\n', '  */\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath64 {\n', '  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    uint64 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/DetailedERC20.sol\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/** KarmaToken has the following properties:\n', '  *\n', '  * User Creation:\n', '  * - Self-registration\n', '  *   - Owner signs hash(address, username, endowment), and sends to user\n', '  *   - User registers with username, endowment, and signature to create new account.\n', '  * - Mod creates new user.\n', '  * - Users are first eligible to withdraw dividends for the period after account creation.\n', '  *\n', '  * Karma/Token Rules:\n', '  * - Karma is created by initial user creation endowment.\n', '  * - Karma can also be minted by mod into an existing account.\n', '  * - Karma can only be transferred to existing account holder.\n', '  * - Karma implements the ERC20 token interface.\n', '  *\n', '  * Dividends:\n', '  * - each user can withdraw a dividend once per month.\n', '  * - dividend is total contract value minus owner cut at end of the month, divided by total number of users at end of month.\n', '  * - owner cut is determined at beginning of new period.\n', '  * - user has 1 month to withdraw their dividend from the previous month.\n', '  * - if user does not withdraw their dividend, their share will be given to owner.\n', '  * - mod can place a user on a 1 month "timeout", whereby they won&#39;t be eligible for a dividend.\n', '\n', '  * Eg: 10 eth is sent to the contract in January, owner cut is 30%. \n', '  * There are 70 token holders on Jan 31. At any time in February, each token holder can withdraw .1 eth for their January \n', '  * dividend (unless they were given a "timeout" in January).\n', '  */\n', 'contract Karma is Ownable, DetailedERC20("KarmaToken", "KARMA", 0) {\n', '  // SafeMath libs are responsible for checking overflow.\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '\n', '  struct User {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage users.\n', '  mapping(address => User) public users;\n', '  mapping(bytes20 => address) public usernames;\n', '\n', '  // Manage dividend payments.\n', '  uint256 public epoch; // Timestamp at start of new period.\n', '  uint256 dividendPool; // Total amount of dividends to pay out for last period.\n', '  uint256 public dividend; // Per-user share of last period&#39;s dividend.\n', '  uint256 public ownerCut; // Percentage, in basis points, of owner cut of this period&#39;s payments.\n', '  uint64 public numUsers; // Number of users created before this period.\n', '  uint64 public newUsers; // Number of users created during this period.\n', '  uint16 public currentPeriod = 1;\n', '\n', '  address public moderator;\n', '\n', '  mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event PeriodEnd(uint16 period, uint256 amount, uint64 users);\n', '  event Payment(address indexed from, uint256 amount);\n', '  event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);\n', '  event NewUser(address addr, bytes20 username, uint64 endowment);\n', '\n', '  modifier onlyMod() {\n', '    require(msg.sender == moderator);\n', '    _;\n', '  }\n', '\n', '  function Karma(uint256 _startEpoch) public {\n', '    epoch = _startEpoch;\n', '    moderator = msg.sender;\n', '  }\n', '\n', '  function() payable public {\n', '    Payment(msg.sender, msg.value);\n', '  }\n', '\n', '  /** \n', '   * Owner Functions \n', '   */\n', '\n', '  function setMod(address _newMod) public onlyOwner {\n', '    moderator = _newMod;\n', '  }\n', '\n', '  // Owner should call this on 1st of every month.\n', '  // _ownerCut is new owner cut for new period.\n', '  function newPeriod(uint256 _ownerCut) public onlyOwner {\n', '    require(now >= epoch + 28 days);\n', '    require(_ownerCut <= 10000);\n', '\n', '    uint256 unclaimedDividend = dividendPool;\n', '    uint256 ownerRake = (this.balance-unclaimedDividend) * ownerCut / 10000;\n', '\n', '    dividendPool = this.balance - unclaimedDividend - ownerRake;\n', '\n', '    // Calculate dividend.\n', '    uint64 existingUsers = numUsers;\n', '    if (existingUsers == 0) {\n', '      dividend = 0;\n', '    } else {\n', '      dividend = dividendPool / existingUsers;\n', '    }\n', '\n', '    numUsers = numUsers.add(newUsers);\n', '    newUsers = 0;\n', '    currentPeriod++;\n', '    epoch = now;\n', '    ownerCut = _ownerCut;\n', '\n', '    msg.sender.transfer(ownerRake + unclaimedDividend);\n', '    PeriodEnd(currentPeriod-1, this.balance, existingUsers);\n', '  }\n', '\n', '  /**\n', '    * Mod Functions\n', '    */\n', '\n', '  function createUser(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\n', '    newUser(_addr, _username, _amount);\n', '  }\n', '\n', '  // Send karma to existing account.\n', '  function mint(address _addr, uint64 _amount) public onlyMod {\n', '    require(users[_addr].canWithdrawPeriod != 0);\n', '\n', '    users[_addr].karma = users[_addr].karma.add(_amount);\n', '    totalSupply = totalSupply.add(_amount);\n', '    Mint(_addr, _amount);\n', '  }\n', '\n', '  // If a user has been bad, they won&#39;t be able to receive a dividend :(\n', '  function timeout(address _addr) public onlyMod {\n', '    require(users[_addr].canWithdrawPeriod != 0);\n', '\n', '    users[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '  }\n', '\n', '  /**\n', '    * User Functions\n', '    */\n', '\n', '  // Owner will sign hash(address, username, amount), and address owner uses this \n', '  // signature to register their account.\n', '  function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\n', '    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\n', '    newUser(msg.sender, _username, _endowment);\n', '  }\n', '\n', '  // User can withdraw their share of donations from the previous month.\n', '  function withdraw() public {\n', '    require(users[msg.sender].canWithdrawPeriod != 0);\n', '    require(users[msg.sender].canWithdrawPeriod < currentPeriod);\n', '\n', '    users[msg.sender].canWithdrawPeriod = currentPeriod;\n', '    dividendPool -= dividend;\n', '    msg.sender.transfer(dividend);\n', '    Withdrawal(msg.sender, currentPeriod-1, dividend);\n', '  }\n', '\n', '  /**\n', '    * ERC20 Functions\n', '    */\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return users[_owner].karma;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing user.\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(users[_to].canWithdrawPeriod != 0);\n', '    require(_value <= users[msg.sender].karma);\n', '\n', '    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\n', '    users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value));\n', '    users[_to].karma = users[_to].karma.add(uint64(_value));\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing user.\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(users[_to].canWithdrawPeriod != 0);\n', '    require(_value <= users[_from].karma);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    users[_from].karma = users[_from].karma.sub(uint64(_value));\n', '    users[_to].karma = users[_to].karma.add(uint64(_value));\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * Private Functions\n', '    */\n', '\n', '  // Ensures that username isn&#39;t taken, and account doesn&#39;t already exist for \n', '  // user&#39;s address.\n', '  function newUser(address _addr, bytes20 _username, uint64 _endowment) private {\n', '    require(usernames[_username] == address(0));\n', '    require(users[_addr].canWithdrawPeriod == 0);\n', '\n', '    users[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '    users[_addr].birthPeriod = currentPeriod;\n', '    users[_addr].karma = _endowment;\n', '    users[_addr].username = _username;\n', '    usernames[_username] = _addr;\n', '\n', '    newUsers = newUsers.add(1);\n', '    totalSupply = totalSupply.add(_endowment);\n', '    NewUser(_addr, _username, _endowment);\n', '  }\n', '\n', '  // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/** SafeMath libs are inspired by:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '  * There is debate as to whether this lib should use assert or require:\n', '  *  https://github.com/OpenZeppelin/zeppelin-solidity/issues/565\n', '\n', '  * `require` is used in these libraries for the following reasons:\n', '  *   - overflows should not be checked in contract function bodies; DRY\n', '  *   - "valid" user input can cause overflows, which should not assert()\n', '  */\n', 'library SafeMath {\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath64 {\n', '  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    uint64 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/179\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/DetailedERC20.sol\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '\n', '/** KarmaToken has the following properties:\n', '  *\n', '  * User Creation:\n', '  * - Self-registration\n', '  *   - Owner signs hash(address, username, endowment), and sends to user\n', '  *   - User registers with username, endowment, and signature to create new account.\n', '  * - Mod creates new user.\n', '  * - Users are first eligible to withdraw dividends for the period after account creation.\n', '  *\n', '  * Karma/Token Rules:\n', '  * - Karma is created by initial user creation endowment.\n', '  * - Karma can also be minted by mod into an existing account.\n', '  * - Karma can only be transferred to existing account holder.\n', '  * - Karma implements the ERC20 token interface.\n', '  *\n', '  * Dividends:\n', '  * - each user can withdraw a dividend once per month.\n', '  * - dividend is total contract value minus owner cut at end of the month, divided by total number of users at end of month.\n', '  * - owner cut is determined at beginning of new period.\n', '  * - user has 1 month to withdraw their dividend from the previous month.\n', '  * - if user does not withdraw their dividend, their share will be given to owner.\n', '  * - mod can place a user on a 1 month "timeout", whereby they won\'t be eligible for a dividend.\n', '\n', '  * Eg: 10 eth is sent to the contract in January, owner cut is 30%. \n', '  * There are 70 token holders on Jan 31. At any time in February, each token holder can withdraw .1 eth for their January \n', '  * dividend (unless they were given a "timeout" in January).\n', '  */\n', 'contract Karma is Ownable, DetailedERC20("KarmaToken", "KARMA", 0) {\n', '  // SafeMath libs are responsible for checking overflow.\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '\n', '  struct User {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage users.\n', '  mapping(address => User) public users;\n', '  mapping(bytes20 => address) public usernames;\n', '\n', '  // Manage dividend payments.\n', '  uint256 public epoch; // Timestamp at start of new period.\n', '  uint256 dividendPool; // Total amount of dividends to pay out for last period.\n', "  uint256 public dividend; // Per-user share of last period's dividend.\n", "  uint256 public ownerCut; // Percentage, in basis points, of owner cut of this period's payments.\n", '  uint64 public numUsers; // Number of users created before this period.\n', '  uint64 public newUsers; // Number of users created during this period.\n', '  uint16 public currentPeriod = 1;\n', '\n', '  address public moderator;\n', '\n', '  mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event PeriodEnd(uint16 period, uint256 amount, uint64 users);\n', '  event Payment(address indexed from, uint256 amount);\n', '  event Withdrawal(address indexed to, uint16 indexed period, uint256 amount);\n', '  event NewUser(address addr, bytes20 username, uint64 endowment);\n', '\n', '  modifier onlyMod() {\n', '    require(msg.sender == moderator);\n', '    _;\n', '  }\n', '\n', '  function Karma(uint256 _startEpoch) public {\n', '    epoch = _startEpoch;\n', '    moderator = msg.sender;\n', '  }\n', '\n', '  function() payable public {\n', '    Payment(msg.sender, msg.value);\n', '  }\n', '\n', '  /** \n', '   * Owner Functions \n', '   */\n', '\n', '  function setMod(address _newMod) public onlyOwner {\n', '    moderator = _newMod;\n', '  }\n', '\n', '  // Owner should call this on 1st of every month.\n', '  // _ownerCut is new owner cut for new period.\n', '  function newPeriod(uint256 _ownerCut) public onlyOwner {\n', '    require(now >= epoch + 28 days);\n', '    require(_ownerCut <= 10000);\n', '\n', '    uint256 unclaimedDividend = dividendPool;\n', '    uint256 ownerRake = (this.balance-unclaimedDividend) * ownerCut / 10000;\n', '\n', '    dividendPool = this.balance - unclaimedDividend - ownerRake;\n', '\n', '    // Calculate dividend.\n', '    uint64 existingUsers = numUsers;\n', '    if (existingUsers == 0) {\n', '      dividend = 0;\n', '    } else {\n', '      dividend = dividendPool / existingUsers;\n', '    }\n', '\n', '    numUsers = numUsers.add(newUsers);\n', '    newUsers = 0;\n', '    currentPeriod++;\n', '    epoch = now;\n', '    ownerCut = _ownerCut;\n', '\n', '    msg.sender.transfer(ownerRake + unclaimedDividend);\n', '    PeriodEnd(currentPeriod-1, this.balance, existingUsers);\n', '  }\n', '\n', '  /**\n', '    * Mod Functions\n', '    */\n', '\n', '  function createUser(address _addr, bytes20 _username, uint64 _amount) public onlyMod {\n', '    newUser(_addr, _username, _amount);\n', '  }\n', '\n', '  // Send karma to existing account.\n', '  function mint(address _addr, uint64 _amount) public onlyMod {\n', '    require(users[_addr].canWithdrawPeriod != 0);\n', '\n', '    users[_addr].karma = users[_addr].karma.add(_amount);\n', '    totalSupply = totalSupply.add(_amount);\n', '    Mint(_addr, _amount);\n', '  }\n', '\n', "  // If a user has been bad, they won't be able to receive a dividend :(\n", '  function timeout(address _addr) public onlyMod {\n', '    require(users[_addr].canWithdrawPeriod != 0);\n', '\n', '    users[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '  }\n', '\n', '  /**\n', '    * User Functions\n', '    */\n', '\n', '  // Owner will sign hash(address, username, amount), and address owner uses this \n', '  // signature to register their account.\n', '  function register(bytes20 _username, uint64 _endowment, bytes _sig) public {\n', '    require(recover(keccak256(msg.sender, _username, _endowment), _sig) == owner);\n', '    newUser(msg.sender, _username, _endowment);\n', '  }\n', '\n', '  // User can withdraw their share of donations from the previous month.\n', '  function withdraw() public {\n', '    require(users[msg.sender].canWithdrawPeriod != 0);\n', '    require(users[msg.sender].canWithdrawPeriod < currentPeriod);\n', '\n', '    users[msg.sender].canWithdrawPeriod = currentPeriod;\n', '    dividendPool -= dividend;\n', '    msg.sender.transfer(dividend);\n', '    Withdrawal(msg.sender, currentPeriod-1, dividend);\n', '  }\n', '\n', '  /**\n', '    * ERC20 Functions\n', '    */\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return users[_owner].karma;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing user.\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(users[_to].canWithdrawPeriod != 0);\n', '    require(_value <= users[msg.sender].karma);\n', '\n', '    // Type assertion to uint64 is safe because we require that _value is < uint64 above.\n', '    users[msg.sender].karma = users[msg.sender].karma.sub(uint64(_value));\n', '    users[_to].karma = users[_to].karma.add(uint64(_value));\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // Contrary to most ERC20 implementations, require that recipient is existing user.\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(users[_to].canWithdrawPeriod != 0);\n', '    require(_value <= users[_from].karma);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    users[_from].karma = users[_from].karma.sub(uint64(_value));\n', '    users[_to].karma = users[_to].karma.add(uint64(_value));\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * Private Functions\n', '    */\n', '\n', "  // Ensures that username isn't taken, and account doesn't already exist for \n", "  // user's address.\n", '  function newUser(address _addr, bytes20 _username, uint64 _endowment) private {\n', '    require(usernames[_username] == address(0));\n', '    require(users[_addr].canWithdrawPeriod == 0);\n', '\n', '    users[_addr].canWithdrawPeriod = currentPeriod + 1;\n', '    users[_addr].birthPeriod = currentPeriod;\n', '    users[_addr].karma = _endowment;\n', '    users[_addr].username = _username;\n', '    usernames[_username] = _addr;\n', '\n', '    newUsers = newUsers.add(1);\n', '    totalSupply = totalSupply.add(_endowment);\n', '    NewUser(_addr, _username, _endowment);\n', '  }\n', '\n', '  // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}']
