['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20Basic interface for TradeNetCoin token.\n', ' * @dev Simpler version of ERC20 interface.\n', ' * @dev See https://github.com/ethereum/EIPs/issues/179.\n', ' */\n', 'contract ERC20Basic {\n', '\tuint256 public totalSupply;\n', '\tfunction balanceOf(address who) public constant returns (uint256);\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface for TradeNetCoin token.\n', ' * @dev See https://github.com/ethereum/EIPs/issues/20.\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\tfunction approve(address spender, uint256 value) public returns (bool);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath.\n', ' * @dev Math operations with safety checks that throw on error.\n', ' */\n', 'library SafeMath {\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0.\n', '\t\tuint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold.\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC20Basic interface for TradeNetCoin token.\n', ' * @dev Simpler version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping(address => uint256) balances;\n', '\n', '\t/**\n', '\t* @dev Function transfers token for a specified address.\n', '\t* @param _to is the address to transfer to.\n', '\t* @param _value is The amount to be transferred.\n', '\t*/\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function gets the balance of the specified address.\n', '\t* @param _owner is the address to query the the balance of.\n', '\t* @dev Function returns an uint256 representing the amount owned by the passed address.\n', '\t*/\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC20 interface for TradeNetCoin token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '\tmapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '\t/**\n', '\t* @dev Function transfers tokens from one address to another.\n', '\t* @param _from is the address which you want to send tokens from.\n', '\t* @param _to is the address which you want to transfer to.\n', '\t* @param _value is the amout of tokens to be transfered.\n', '\t*/\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\tuint256 _allowance = allowed[_from][msg.sender];\n', '\n', '\t\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '\t\t// require (_value <= _allowance);\n', '\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function approves the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '\t* @param _spender is the address which will spend the funds.\n', '\t* @param _value is the amount of tokens to be spent.\n', '\t*/\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '\t\t// To change the approve amount you first have to reduce the addresses`\n', '\t\t//  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '\t\t//  already 0 to mitigate the race condition described here:\n', '\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function is to check the amount of tokens that an owner allowed to a spender.\n', '\t* @param _owner is the address which owns the funds.\n', '\t* @param _spender is the address which will spend the funds.\n', '\t* @dev Function returns a uint256 specifing the amount of tokens still avaible for the spender.\n', '\t*/\n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\t/**\n', '\t* @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '\t*/\n', '\tfunction Ownable() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Modifier throws if called by any account other than the owner.\n', '\t*/\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function allows the current owner to transfer control of the contract to a newOwner.\n', '\t* @param newOwner is the address to transfer ownership to.\n', '\t*/\n', '\tfunction transferOwnership(address newOwner) onlyOwner public {\n', '\t\tif (newOwner != address(0)) {\n', '\t\t\towner = newOwner;\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title BurnableToken for TradeNetCoin token.\n', ' * @dev Token that can be irreversibly burned.\n', ' */\n', 'contract BurnableToken is StandardToken, Ownable {\n', '\n', '\t/**\n', '\t* @dev Function burns a specific amount of tokens.\n', '\t* @param _value The amount of token to be burned.\n', '\t*/\n', '\tfunction burn(uint _value) public onlyOwner {\n', '\t\trequire(_value > 0);\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply = totalSupply.sub(_value);\n', '\t\tBurn(burner, _value);\n', '\t}\n', '\tevent Burn(address indexed burner, uint indexed value);\n', '}\n', '\n', '\n', '/**\n', ' * @title TradeNetCoin token.\n', ' * @dev Total supply is 16 million tokens. No opportunity for additional minting of coins.\n', ' * @dev All unsold and unused tokens can be burned in order to more increase token price.\n', ' */\n', 'contract TradeNetCoin is BurnableToken {\n', '\tstring public constant name = "TradeNetCoin";\n', '\tstring public constant symbol = "TNC";\n', '\tuint8 public constant decimals = 2;\n', '\tuint256 public constant INITIAL_SUPPLY = 16000000 *( 10 ** uint256(decimals)); // 16,000,000 tokens\n', '\n', '\tfunction TradeNetCoin() public {\n', '\t\ttotalSupply = INITIAL_SUPPLY;\n', '\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n', '\t}\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20Basic interface for TradeNetCoin token.\n', ' * @dev Simpler version of ERC20 interface.\n', ' * @dev See https://github.com/ethereum/EIPs/issues/179.\n', ' */\n', 'contract ERC20Basic {\n', '\tuint256 public totalSupply;\n', '\tfunction balanceOf(address who) public constant returns (uint256);\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface for TradeNetCoin token.\n', ' * @dev See https://github.com/ethereum/EIPs/issues/20.\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\tfunction approve(address spender, uint256 value) public returns (bool);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath.\n', ' * @dev Math operations with safety checks that throw on error.\n', ' */\n', 'library SafeMath {\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0.\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold.\n", '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC20Basic interface for TradeNetCoin token.\n', ' * @dev Simpler version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping(address => uint256) balances;\n', '\n', '\t/**\n', '\t* @dev Function transfers token for a specified address.\n', '\t* @param _to is the address to transfer to.\n', '\t* @param _value is The amount to be transferred.\n', '\t*/\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function gets the balance of the specified address.\n', '\t* @param _owner is the address to query the the balance of.\n', '\t* @dev Function returns an uint256 representing the amount owned by the passed address.\n', '\t*/\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC20 interface for TradeNetCoin token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '\tmapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '\t/**\n', '\t* @dev Function transfers tokens from one address to another.\n', '\t* @param _from is the address which you want to send tokens from.\n', '\t* @param _to is the address which you want to transfer to.\n', '\t* @param _value is the amout of tokens to be transfered.\n', '\t*/\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\tuint256 _allowance = allowed[_from][msg.sender];\n', '\n', '\t\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '\t\t// require (_value <= _allowance);\n', '\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function approves the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '\t* @param _spender is the address which will spend the funds.\n', '\t* @param _value is the amount of tokens to be spent.\n', '\t*/\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '\t\t// To change the approve amount you first have to reduce the addresses`\n', '\t\t//  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '\t\t//  already 0 to mitigate the race condition described here:\n', '\t\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function is to check the amount of tokens that an owner allowed to a spender.\n', '\t* @param _owner is the address which owns the funds.\n', '\t* @param _spender is the address which will spend the funds.\n', '\t* @dev Function returns a uint256 specifing the amount of tokens still avaible for the spender.\n', '\t*/\n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\t/**\n', '\t* @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '\t*/\n', '\tfunction Ownable() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Modifier throws if called by any account other than the owner.\n', '\t*/\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function allows the current owner to transfer control of the contract to a newOwner.\n', '\t* @param newOwner is the address to transfer ownership to.\n', '\t*/\n', '\tfunction transferOwnership(address newOwner) onlyOwner public {\n', '\t\tif (newOwner != address(0)) {\n', '\t\t\towner = newOwner;\n', '\t\t}\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title BurnableToken for TradeNetCoin token.\n', ' * @dev Token that can be irreversibly burned.\n', ' */\n', 'contract BurnableToken is StandardToken, Ownable {\n', '\n', '\t/**\n', '\t* @dev Function burns a specific amount of tokens.\n', '\t* @param _value The amount of token to be burned.\n', '\t*/\n', '\tfunction burn(uint _value) public onlyOwner {\n', '\t\trequire(_value > 0);\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_value);\n', '\t\ttotalSupply = totalSupply.sub(_value);\n', '\t\tBurn(burner, _value);\n', '\t}\n', '\tevent Burn(address indexed burner, uint indexed value);\n', '}\n', '\n', '\n', '/**\n', ' * @title TradeNetCoin token.\n', ' * @dev Total supply is 16 million tokens. No opportunity for additional minting of coins.\n', ' * @dev All unsold and unused tokens can be burned in order to more increase token price.\n', ' */\n', 'contract TradeNetCoin is BurnableToken {\n', '\tstring public constant name = "TradeNetCoin";\n', '\tstring public constant symbol = "TNC";\n', '\tuint8 public constant decimals = 2;\n', '\tuint256 public constant INITIAL_SUPPLY = 16000000 *( 10 ** uint256(decimals)); // 16,000,000 tokens\n', '\n', '\tfunction TradeNetCoin() public {\n', '\t\ttotalSupply = INITIAL_SUPPLY;\n', '\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n', '\t}\n', '}']
