['/**\n', ' * TokenMinter.sol\n', ' * MPS Token (Mt Pelerin Share) token minter.\n', '\n', ' * More info about MPS : https://github.com/MtPelerin/MtPelerin-share-MPS\n', '\n', ' * The unflattened code is available through this github tag:\n', ' * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1\n', '\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', '\n', ' * @notice All matters regarding the intellectual property of this code \n', ' * @notice or software are subject to Swiss Law without reference to its \n', ' * @notice conflicts of law rules.\n', '\n', ' * @notice License for each contract is available in the respective file\n', ' * @notice or in the LICENSE.md file.\n', ' * @notice https://github.com/MtPelerin/\n', '\n', ' * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\n', ' * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\n', ' */\n', '\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/zeppelin/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/zeppelin/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/IMintable.sol\n', '\n', '/**\n', ' * @title Mintable interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' */\n', 'contract IMintable {\n', '  function mintingFinished() public view returns (bool);\n', '\n', '  function mint(address _to, uint256 _amount) public returns (bool);\n', '  function finishMinting() public returns (bool);\n', ' \n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '}\n', '\n', '// File: contracts/interface/IMintableByLot.sol\n', '\n', '/**\n', ' * @title MintableByLot interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' */\n', 'contract IMintableByLot is IMintable {\n', '  function minterLotId(address _minter) public view returns (uint256);\n', '}\n', '\n', '// File: contracts/zeppelin/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/zeppelin/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/interface/ISeizable.sol\n', '\n', '/**\n', ' * @title ISeizable\n', ' * @dev ISeizable interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract ISeizable {\n', '  function seize(address _account, uint256 _value) public;\n', '  event Seize(address account, uint256 amount);\n', '}\n', '\n', '// File: contracts/Authority.sol\n', '\n', '/**\n', ' * @title Authority\n', ' * @dev The Authority contract has an authority address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * Authority means to represent a legal entity that is entitled to specific rights\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * AU01: Message sender must be an authority\n', ' */\n', 'contract Authority is Ownable {\n', '\n', '  address authority;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the authority.\n', '   */\n', '  modifier onlyAuthority {\n', '    require(msg.sender == authority, "AU01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev return the address associated to the authority\n', '   */\n', '  function authorityAddress() public view returns (address) {\n', '    return authority;\n', '  }\n', '\n', '  /**\n', '   * @dev rdefines an authority\n', '   * @param _name the authority name\n', '   * @param _address the authority address.\n', '   */\n', '  function defineAuthority(string _name, address _address) public onlyOwner {\n', '    emit AuthorityDefined(_name, _address);\n', '    authority = _address;\n', '  }\n', '\n', '  event AuthorityDefined(\n', '    string name,\n', '    address _address\n', '  );\n', '}\n', '\n', '// File: contracts/token/component/SeizableToken.sol\n', '\n', '/**\n', ' * @title SeizableToken\n', ' * @dev BasicToken contract which allows owner to seize accounts\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * ST01: Owner cannot seize itself\n', '*/\n', 'contract SeizableToken is BasicToken, Authority, ISeizable {\n', '  using SafeMath for uint256;\n', '\n', '  // Although very unlikely, the value below may overflow.\n', '  // This contract and its children should expect it to happened and consider\n', '  // this value as only the first 256 bits of the complete value.\n', '  uint256 public allTimeSeized = 0; // overflow may happend\n', '\n', '  /**\n', '   * @dev called by the owner to seize value from the account\n', '   */\n', '  function seize(address _account, uint256 _value)\n', '    public onlyAuthority\n', '  {\n', '    require(_account != owner, "ST01");\n', '\n', '    balances[_account] = balances[_account].sub(_value);\n', '    balances[authority] = balances[authority].add(_value);\n', '\n', '    allTimeSeized += _value;\n', '    emit Seize(_account, _value);\n', '  }\n', '}\n', '\n', '// File: contracts/zeppelin/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/zeppelin/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/interface/IProvableOwnership.sol\n', '\n', '/**\n', ' * @title IProvableOwnership\n', ' * @dev IProvableOwnership interface which describe proof of ownership.\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract IProvableOwnership {\n', '  function proofLength(address _holder) public view returns (uint256);\n', '  function proofAmount(address _holder, uint256 _proofId)\n', '    public view returns (uint256);\n', '\n', '  function proofDateFrom(address _holder, uint256 _proofId)\n', '    public view returns (uint256);\n', '\n', '  function proofDateTo(address _holder, uint256 _proofId)\n', '    public view returns (uint256);\n', '\n', '  function createProof(address _holder) public;\n', '  function checkProof(address _holder, uint256 _proofId, uint256 _at)\n', '    public view returns (uint256);\n', '\n', '  function transferWithProofs(\n', '    address _to,\n', '    uint256 _value,\n', '    bool _proofFrom,\n', '    bool _proofTo\n', '    ) public returns (bool);\n', '\n', '  function transferFromWithProofs(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value,\n', '    bool _proofFrom,\n', '    bool _proofTo\n', '    ) public returns (bool);\n', '\n', '  event ProofOfOwnership(address indexed holder, uint256 proofId);\n', '}\n', '\n', '// File: contracts/interface/IAuditableToken.sol\n', '\n', '/**\n', ' * @title IAuditableToken\n', ' * @dev IAuditableToken interface describing the audited data\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract IAuditableToken {\n', '  function lastTransactionAt(address _address) public view returns (uint256);\n', '  function lastReceivedAt(address _address) public view returns (uint256);\n', '  function lastSentAt(address _address) public view returns (uint256);\n', '  function transactionCount(address _address) public view returns (uint256);\n', '  function receivedCount(address _address) public view returns (uint256);\n', '  function sentCount(address _address) public view returns (uint256);\n', '  function totalReceivedAmount(address _address) public view returns (uint256);\n', '  function totalSentAmount(address _address) public view returns (uint256);\n', '}\n', '\n', '// File: contracts/token/component/AuditableToken.sol\n', '\n', '/**\n', ' * @title AuditableToken\n', ' * @dev AuditableToken contract\n', ' * AuditableToken provides transaction data which can be used\n', ' * in other smart contracts\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract AuditableToken is IAuditableToken, StandardToken {\n', '\n', '   // Although very unlikely, the following values below may overflow:\n', '   //   receivedCount, sentCount, totalReceivedAmount, totalSentAmount\n', '   // This contract and its children should expect it to happen and consider\n', '   // these values as only the first 256 bits of the complete value.\n', '  struct Audit {\n', '    uint256 createdAt;\n', '    uint256 lastReceivedAt;\n', '    uint256 lastSentAt;\n', '    uint256 receivedCount; // potential overflow\n', '    uint256 sentCount; // poential overflow\n', '    uint256 totalReceivedAmount; // potential overflow\n', '    uint256 totalSentAmount; // potential overflow\n', '  }\n', '  mapping(address => Audit) internal audits;\n', '\n', '  /**\n', '   * @dev Time of the creation of the audit struct\n', '   */\n', '  function auditCreatedAt(address _address) public view returns (uint256) {\n', '    return audits[_address].createdAt;\n', '  }\n', '\n', '  /**\n', '   * @dev Time of the last transaction\n', '   */\n', '  function lastTransactionAt(address _address) public view returns (uint256) {\n', '    return ( audits[_address].lastReceivedAt > audits[_address].lastSentAt ) ?\n', '      audits[_address].lastReceivedAt : audits[_address].lastSentAt;\n', '  }\n', '\n', '  /**\n', '   * @dev Time of the last received transaction\n', '   */\n', '  function lastReceivedAt(address _address) public view returns (uint256) {\n', '    return audits[_address].lastReceivedAt;\n', '  }\n', '\n', '  /**\n', '   * @dev Time of the last sent transaction\n', '   */\n', '  function lastSentAt(address _address) public view returns (uint256) {\n', '    return audits[_address].lastSentAt;\n', '  }\n', '\n', '  /**\n', '   * @dev Count of transactions\n', '   */\n', '  function transactionCount(address _address) public view returns (uint256) {\n', '    return audits[_address].receivedCount + audits[_address].sentCount;\n', '  }\n', '\n', '  /**\n', '   * @dev Count of received transactions\n', '   */\n', '  function receivedCount(address _address) public view returns (uint256) {\n', '    return audits[_address].receivedCount;\n', '  }\n', '\n', '  /**\n', '   * @dev Count of sent transactions\n', '   */\n', '  function sentCount(address _address) public view returns (uint256) {\n', '    return audits[_address].sentCount;\n', '  }\n', '\n', '  /**\n', '   * @dev All time received\n', '   */\n', '  function totalReceivedAmount(address _address)\n', '    public view returns (uint256)\n', '  {\n', '    return audits[_address].totalReceivedAmount;\n', '  }\n', '\n', '  /**\n', '   * @dev All time sent\n', '   */\n', '  function totalSentAmount(address _address) public view returns (uint256) {\n', '    return audits[_address].totalSentAmount;\n', '  }\n', '\n', '  /**\n', '   * @dev Overriden transfer function\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    if (!super.transfer(_to, _value)) {\n', '      return false;\n', '    }\n', '    updateAudit(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Overriden transferFrom function\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool)\n', '  {\n', '    if (!super.transferFrom(_from, _to, _value)) {\n', '      return false;\n', '    }\n', '\n', '    updateAudit(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', ' /**\n', '   * @dev currentTime()\n', '   */\n', '  function currentTime() internal view returns (uint256) {\n', '    // solium-disable-next-line security/no-block-members\n', '    return now;\n', '  }\n', '\n', '  /**\n', '   * @dev Update audit data\n', '   */\n', '  function updateAudit(address _sender, address _receiver, uint256 _value)\n', '    private returns (uint256)\n', '  {\n', '    Audit storage senderAudit = audits[_sender];\n', '    senderAudit.lastSentAt = currentTime();\n', '    senderAudit.sentCount++;\n', '    senderAudit.totalSentAmount += _value;\n', '    if (senderAudit.createdAt == 0) {\n', '      senderAudit.createdAt = currentTime();\n', '    }\n', '\n', '    Audit storage receiverAudit = audits[_receiver];\n', '    receiverAudit.lastReceivedAt = currentTime();\n', '    receiverAudit.receivedCount++;\n', '    receiverAudit.totalReceivedAmount += _value;\n', '    if (receiverAudit.createdAt == 0) {\n', '      receiverAudit.createdAt = currentTime();\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/token/component/ProvableOwnershipToken.sol\n', '\n', '/**\n', ' * @title ProvableOwnershipToken\n', ' * @dev ProvableOwnershipToken is a StandardToken\n', ' * with ability to record a proof of ownership\n', ' *\n', ' * When desired a proof of ownership can be generated.\n', ' * The proof is stored within the contract.\n', ' * A proofId is then returned.\n', ' * The proof can later be used to retrieve the amount needed.\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract ProvableOwnershipToken is IProvableOwnership, AuditableToken, Ownable {\n', '  struct Proof {\n', '    uint256 amount;\n', '    uint256 dateFrom;\n', '    uint256 dateTo;\n', '  }\n', '  mapping(address => mapping(uint256 => Proof)) internal proofs;\n', '  mapping(address => uint256) internal proofLengths;\n', '\n', '  /**\n', '   * @dev number of proof stored in the contract\n', '   */\n', '  function proofLength(address _holder) public view returns (uint256) {\n', '    return proofLengths[_holder];\n', '  }\n', '\n', '  /**\n', '   * @dev amount contains for the proofId reccord\n', '   */\n', '  function proofAmount(address _holder, uint256 _proofId)\n', '    public view returns (uint256)\n', '  {\n', '    return proofs[_holder][_proofId].amount;\n', '  }\n', '\n', '  /**\n', '   * @dev date from which the proof is valid\n', '   */\n', '  function proofDateFrom(address _holder, uint256 _proofId)\n', '    public view returns (uint256)\n', '  {\n', '    return proofs[_holder][_proofId].dateFrom;\n', '  }\n', '\n', '  /**\n', '   * @dev date until the proof is valid\n', '   */\n', '  function proofDateTo(address _holder, uint256 _proofId)\n', '    public view returns (uint256)\n', '  {\n', '    return proofs[_holder][_proofId].dateTo;\n', '  }\n', '\n', '  /**\n', '   * @dev called to challenge a proof at a point in the past\n', '   * Return the amount tokens owned by the proof owner at that time\n', '   */\n', '  function checkProof(address _holder, uint256 _proofId, uint256 _at)\n', '    public view returns (uint256)\n', '  {\n', '    if (_proofId < proofLengths[_holder]) {\n', '      Proof storage proof = proofs[_holder][_proofId];\n', '\n', '      if (proof.dateFrom <= _at && _at <= proof.dateTo) {\n', '        return proof.amount;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  /**\n', '   * @dev called to create a proof of token ownership\n', '   */\n', '  function createProof(address _holder) public {\n', '    createProofInternal(\n', '      _holder,\n', '      balanceOf(_holder),\n', '      lastTransactionAt(_holder)\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev transfer function with also create a proof of ownership to any of the participants\n', '   * @param _proofSender if true a proof will be created for the sender\n', '   * @param _proofReceiver if true a proof will be created for the receiver\n', '   */\n', '  function transferWithProofs(\n', '    address _to,\n', '    uint256 _value,\n', '    bool _proofSender,\n', '    bool _proofReceiver\n', '  ) public returns (bool)\n', '  {\n', '    uint256 balanceBeforeFrom = balanceOf(msg.sender);\n', '    uint256 beforeFrom = lastTransactionAt(msg.sender);\n', '    uint256 balanceBeforeTo = balanceOf(_to);\n', '    uint256 beforeTo = lastTransactionAt(_to);\n', '\n', '    if (!super.transfer(_to, _value)) {\n', '      return false;\n', '    }\n', '\n', '    transferPostProcessing(\n', '      msg.sender,\n', '      balanceBeforeFrom,\n', '      beforeFrom,\n', '      _proofSender\n', '    );\n', '    transferPostProcessing(\n', '      _to,\n', '      balanceBeforeTo,\n', '      beforeTo,\n', '      _proofReceiver\n', '    );\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev transfer function with also create a proof of ownership to any of the participants\n', '   * @param _proofSender if true a proof will be created for the sender\n', '   * @param _proofReceiver if true a proof will be created for the receiver\n', '   */\n', '  function transferFromWithProofs(\n', '    address _from,\n', '    address _to, \n', '    uint256 _value,\n', '    bool _proofSender, bool _proofReceiver)\n', '    public returns (bool)\n', '  {\n', '    uint256 balanceBeforeFrom = balanceOf(_from);\n', '    uint256 beforeFrom = lastTransactionAt(_from);\n', '    uint256 balanceBeforeTo = balanceOf(_to);\n', '    uint256 beforeTo = lastTransactionAt(_to);\n', '\n', '    if (!super.transferFrom(_from, _to, _value)) {\n', '      return false;\n', '    }\n', '\n', '    transferPostProcessing(\n', '      _from,\n', '      balanceBeforeFrom,\n', '      beforeFrom,\n', '      _proofSender\n', '    );\n', '    transferPostProcessing(\n', '      _to,\n', '      balanceBeforeTo,\n', '      beforeTo,\n', '      _proofReceiver\n', '    );\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev can be used to force create a proof (with a fake amount potentially !)\n', '   * Only usable by child contract internaly\n', '   */\n', '  function createProofInternal(\n', '    address _holder, uint256 _amount, uint256 _from) internal\n', '  {\n', '    uint proofId = proofLengths[_holder];\n', '    // solium-disable-next-line security/no-block-members\n', '    proofs[_holder][proofId] = Proof(_amount, _from, currentTime());\n', '    proofLengths[_holder] = proofId+1;\n', '    emit ProofOfOwnership(_holder, proofId);\n', '  }\n', '\n', '  /**\n', '   * @dev private function updating contract state after a transfer operation\n', '   */\n', '  function transferPostProcessing(\n', '    address _holder,\n', '    uint256 _balanceBefore,\n', '    uint256 _before,\n', '    bool _proof) private\n', '  {\n', '    if (_proof) {\n', '      createProofInternal(_holder, _balanceBefore, _before);\n', '    }\n', '  }\n', '\n', '  event ProofOfOwnership(address indexed holder, uint256 proofId);\n', '}\n', '\n', '// File: contracts/interface/IClaimable.sol\n', '\n', '/**\n', ' * @title IClaimable\n', ' * @dev IClaimable interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'interface IClaimable {\n', '  function hasClaimsSince(address _address, uint256 at)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: contracts/interface/IWithClaims.sol\n', '\n', '/**\n', ' * @title IWithClaims\n', ' * @dev IWithClaims interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract IWithClaims {\n', '  function claimableLength() public view returns (uint256);\n', '  function claimable(uint256 _claimableId) public view returns (IClaimable);\n', '  function hasClaims(address _holder) public view returns (bool);\n', '  function defineClaimables(IClaimable[] _claimables) public;\n', '\n', '  event ClaimablesDefined(uint256 count);\n', '}\n', '\n', '// File: contracts/token/component/TokenWithClaims.sol\n', '\n', '/**\n', ' * @title TokenWithClaims\n', ' * @dev TokenWithClaims contract\n', ' * TokenWithClaims is a token that will create a\n', ' * proofOfOwnership during transfers if a claim can be made.\n', ' * Holder may ask for the claim later using the proofOfOwnership\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * E01: Claimable address must be defined\n', ' * E02: Claimables parameter must not be empty\n', ' * E03: Claimable does not exist\n', '**/\n', 'contract TokenWithClaims is IWithClaims, ProvableOwnershipToken {\n', '\n', '  IClaimable[] claimables;\n', '\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  constructor(IClaimable[] _claimables) public {\n', '    claimables = _claimables;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of claimables\n', '   */\n', '  function claimableLength() public view returns (uint256) {\n', '    return claimables.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the Claimable associated to the specified claimableId\n', '   */\n', '  function claimable(uint256 _claimableId) public view returns (IClaimable) {\n', '    return claimables[_claimableId];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if there are any claims associated to this token\n', '   * to be made at this time for the _holder\n', '   */\n', '  function hasClaims(address _holder) public view returns (bool) {\n', '    uint256 lastTransaction = lastTransactionAt(_holder);\n', '    for (uint256 i = 0; i < claimables.length; i++) {\n', '      if (claimables[i].hasClaimsSince(_holder, lastTransaction)) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * @dev Override the transfer function with transferWithProofs\n', '   * A proof of ownership will be made if any claims can be made by the participants\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    bool proofFrom = hasClaims(msg.sender);\n', '    bool proofTo = hasClaims(_to);\n', '\n', '    return super.transferWithProofs(\n', '      _to,\n', '      _value,\n', '      proofFrom,\n', '      proofTo\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Override the transfer function with transferWithProofs\n', '   * A proof of ownership will be made if any claims can be made by the participants\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool)\n', '  {\n', '    bool proofFrom = hasClaims(_from);\n', '    bool proofTo = hasClaims(_to);\n', '\n', '    return super.transferFromWithProofs(\n', '      _from,\n', '      _to,\n', '      _value,\n', '      proofFrom,\n', '      proofTo\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev transfer with proofs\n', '   */\n', '  function transferWithProofs(\n', '    address _to,\n', '    uint256 _value,\n', '    bool _proofFrom,\n', '    bool _proofTo\n', '  ) public returns (bool)\n', '  {\n', '    bool proofFrom = _proofFrom || hasClaims(msg.sender);\n', '    bool proofTo = _proofTo || hasClaims(_to);\n', '\n', '    return super.transferWithProofs(\n', '      _to,\n', '      _value,\n', '      proofFrom,\n', '      proofTo\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev transfer from with proofs\n', '   */\n', '  function transferFromWithProofs(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value,\n', '    bool _proofFrom,\n', '    bool _proofTo\n', '  ) public returns (bool)\n', '  {\n', '    bool proofFrom = _proofFrom || hasClaims(_from);\n', '    bool proofTo = _proofTo || hasClaims(_to);\n', '\n', '    return super.transferFromWithProofs(\n', '      _from,\n', '      _to,\n', '      _value,\n', '      proofFrom,\n', '      proofTo\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev define claimables contract to this token\n', '   */\n', '  function defineClaimables(IClaimable[] _claimables) public onlyOwner {\n', '    claimables = _claimables;\n', '    emit ClaimablesDefined(claimables.length);\n', '  }\n', '}\n', '\n', '// File: contracts/interface/IRule.sol\n', '\n', '/**\n', ' * @title IRule\n', ' * @dev IRule interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'interface IRule {\n', '  function isAddressValid(address _address) external view returns (bool);\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: contracts/interface/IWithRules.sol\n', '\n', '/**\n', ' * @title IWithRules\n', ' * @dev IWithRules interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract IWithRules {\n', '  function ruleLength() public view returns (uint256);\n', '  function rule(uint256 _ruleId) public view returns (IRule);\n', '  function validateAddress(address _address) public view returns (bool);\n', '  function validateTransfer(address _from, address _to, uint256 _amount)\n', '    public view returns (bool);\n', '\n', '  function defineRules(IRule[] _rules) public;\n', '\n', '  event RulesDefined(uint256 count);\n', '}\n', '\n', '// File: contracts/rule/WithRules.sol\n', '\n', '/**\n', ' * @title WithRules\n', ' * @dev WithRules contract allows inheriting contract to use a set of validation rules\n', ' * @dev contract owner may add or remove rules\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * WR01: The rules rejected this address\n', ' * WR02: The rules rejected the transfer\n', ' **/\n', 'contract WithRules is IWithRules, Ownable {\n', '\n', '  IRule[] internal rules;\n', '\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  constructor(IRule[] _rules) public {\n', '    rules = _rules;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of rules\n', '   */\n', '  function ruleLength() public view returns (uint256) {\n', '    return rules.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the Rule associated to the specified ruleId\n', '   */\n', '  function rule(uint256 _ruleId) public view returns (IRule) {\n', '    return rules[_ruleId];\n', '  }\n', '\n', '  /**\n', '   * @dev Check if the rules are valid for an address\n', '   */\n', '  function validateAddress(address _address) public view returns (bool) {\n', '    for (uint256 i = 0; i < rules.length; i++) {\n', '      if (!rules[i].isAddressValid(_address)) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Check if the rules are valid\n', '   */\n', '  function validateTransfer(address _from, address _to, uint256 _amount)\n', '    public view returns (bool)\n', '  {\n', '    for (uint256 i = 0; i < rules.length; i++) {\n', '      if (!rules[i].isTransferValid(_from, _to, _amount)) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make functions callable\n', '   * only when participants follow rules\n', '   */\n', '  modifier whenAddressRulesAreValid(address _address) {\n', '    require(validateAddress(_address), "WR01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make transfer functions callable\n', '   * only when participants follow rules\n', '   */\n', '  modifier whenTransferRulesAreValid(\n', '    address _from,\n', '    address _to,\n', '    uint256 _amount)\n', '  {\n', '    require(validateTransfer(_from, _to, _amount), "WR02");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Define rules to the token\n', '   */\n', '  function defineRules(IRule[] _rules) public onlyOwner {\n', '    rules = _rules;\n', '    emit RulesDefined(rules.length);\n', '  }\n', '}\n', '\n', '// File: contracts/token/component/TokenWithRules.sol\n', '\n', '/**\n', ' * @title TokenWithRules\n', ' * @dev TokenWithRules contract\n', ' * TokenWithRules is a token that will apply\n', ' * rules restricting transferability\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' **/\n', 'contract TokenWithRules is StandardToken, WithRules {\n', '\n', '  /**\n', '   * @dev Constructor\n', '   */\n', '  constructor(IRule[] _rules) public WithRules(_rules) { }\n', '\n', '  /**\n', '   * @dev Overriden transfer function\n', '   */\n', '  function transfer(address _to, uint256 _value)\n', '    public whenTransferRulesAreValid(msg.sender, _to, _value)\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Overriden transferFrom function\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public whenTransferRulesAreValid(_from, _to, _value)\n', '    whenAddressRulesAreValid(msg.sender)\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '}\n', '\n', '// File: contracts/token/BridgeToken.sol\n', '\n', '/**\n', ' * @title BridgeToken\n', ' * @dev BridgeToken contract\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' */\n', 'contract BridgeToken is TokenWithRules, TokenWithClaims, SeizableToken {\n', '  string public name;\n', '  string public symbol;\n', '\n', '  /**\n', '   * @dev constructor\n', '   */\n', '  constructor(string _name, string _symbol) \n', '    TokenWithRules(new IRule[](0))\n', '    TokenWithClaims(new IClaimable[](0)) public\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '  }\n', '}\n', '\n', '// File: contracts/token/component/MintableToken.sol\n', '\n', '/**\n', ' * @title MintableToken\n', ' * @dev MintableToken contract\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * MT01: Minting is already finished.\n', '*/\n', 'contract MintableToken is StandardToken, Ownable, IMintable {\n', '\n', '  bool public mintingFinished = false;\n', '\n', '  function mintingFinished() public view returns (bool) {\n', '    return mintingFinished;\n', '  }\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished, "MT01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  ) public canMint onlyOwner returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() public canMint onlyOwner returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '}\n', '\n', '// File: contracts/token/MintableBridgeToken.sol\n', '\n', '/**\n', ' * @title MintableBridgeToken\n', ' * @dev MintableBridgeToken contract\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' */\n', 'contract MintableBridgeToken is BridgeToken, MintableToken {\n', '\n', '  string public name;\n', '  string public symbol;\n', '\n', '  /**\n', '   * @dev constructor\n', '   */\n', '  constructor(string _name, string _symbol)\n', '    BridgeToken(_name, _symbol) public\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/ISaleConfig.sol\n', '\n', '/**\n', ' * @title ISaleConfig interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' */\n', 'contract ISaleConfig {\n', '\n', '  struct Tokensale {\n', '    uint256 lotId;\n', '    uint256 tokenPriceCHFCent;\n', '  }\n', '\n', '  function tokenSupply() public pure returns (uint256);\n', '  function tokensaleLotSupplies() public view returns (uint256[]);\n', '\n', '  function tokenizedSharePercent() public pure returns (uint256); \n', '  function tokenPriceCHF() public pure returns (uint256);\n', '\n', '  function minimalCHFInvestment() public pure returns (uint256);\n', '  function maximalCHFInvestment() public pure returns (uint256);\n', '\n', '  function tokensalesCount() public view returns (uint256);\n', '  function lotId(uint256 _tokensaleId) public view returns (uint256);\n', '  function tokenPriceCHFCent(uint256 _tokensaleId)\n', '    public view returns (uint256);\n', '}\n', '\n', '// File: contracts/tokensale/TokenMinter.sol\n', '\n', '/**\n', ' * @title TokenMinter\n', ' * @dev TokenMinter contract\n', ' * The contract explicit the minting process of the Bridge Token\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * TM01: Configuration must be defined\n', ' * TM02: Final token owner must be defined\n', ' * TM03: There should be at least one lot\n', ' * TM04: Must have one vault per lot\n', ' * TM05: Each vault must be defined\n', ' * TM06: Token must be defined\n', ' * TM07: Token has already been defined\n', ' * TM08: Minter must be the token owner\n', ' * TM09: There should be no token supply\n', ' * TM10: Token minting must not be finished\n', ' * TM11: Minters must match tokensale configuration\n', ' * TM12: Tokensale configuration must match lot definition\n', ' * TM13: Minter is not already configured for the lot\n', ' * TM14: Token must be defined\n', ' * TM15: Amount to mint must be greater than 0\n', ' * TM16: Mintable supply must be greater than amount to mint\n', ' * TM17: Can only finish minting for active minters\n', ' * TM18: No active minters expected for the lot\n', ' * TM19: There should be some remaining supply in the lot\n', ' * TM20: Minting must be successfull\n', ' * TM21: Token minting must not be finished\n', ' * TM22: There should be some unfinished lot(s)\n', ' * TM23: All minting must be processed\n', ' * TM24: Token minting must not be finished\n', ' * TM25: Finish minting must be successful\n', ' * TM26: Token minting must be finished\n', '*/\n', 'contract TokenMinter is IMintableByLot, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  struct MintableLot {\n', '    uint256 mintableSupply;\n', '    address vault;\n', '    mapping(address => bool) minters;\n', '    uint8 activeMinters;\n', '  }\n', '\n', '  MintableLot[] private mintableLots;\n', '  mapping(address => uint256) public minterLotIds;\n', '\n', '  uint256 public totalMintableSupply;\n', '  address public finalTokenOwner;\n', '\n', '  uint8 public activeLots;\n', '\n', '  ISaleConfig public config;\n', '  MintableBridgeToken public token;\n', '\n', '  /**\n', '   * @dev constructor\n', '   */\n', '  constructor(\n', '    ISaleConfig _config,\n', '    address _finalTokenOwner,\n', '    address[] _vaults) public\n', '  {\n', '    require(address(_config) != 0, "TM01");\n', '    require(_finalTokenOwner != 0, "TM02");\n', '\n', '    uint256[] memory lots = _config.tokensaleLotSupplies();\n', '    require(lots.length > 0, "TM03");\n', '    require(_vaults.length == lots.length, "TM04");\n', '\n', '    config = _config;\n', '    finalTokenOwner = _finalTokenOwner;\n', '\n', '    for (uint256 i = 0; i < lots.length; i++) {\n', '      require(_vaults[i] != 0, "TM05");\n', '      uint256 mintableSupply = lots[i];\n', '      mintableLots.push(MintableLot(mintableSupply, _vaults[i], 0));\n', '      totalMintableSupply = totalMintableSupply.add(mintableSupply);\n', '      activeLots++;\n', '      emit LotCreated(i+1, mintableSupply);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev minter lotId\n', '   */\n', '  function minterLotId(address _minter) public view returns (uint256) {\n', '    return minterLotIds[_minter];\n', '  }\n', '\n', '  /**\n', '   * @dev lot mintable supply\n', '   */\n', '  function lotMintableSupply(uint256 _lotId) public view returns (uint256) {\n', '    return mintableLots[_lotId].mintableSupply;\n', '  }\n', '\n', '  /**\n', '   * @dev lot vault\n', '   */\n', '  function lotVault(uint256 _lotId) public view returns (address) {\n', '    return mintableLots[_lotId].vault;\n', '  }\n', '\n', '  /**\n', '   * @dev is lot minter\n', '   */\n', '  function isLotMinter(uint256 _lotId, address _minter)\n', '    public view returns (bool)\n', '  {\n', '    return mintableLots[_lotId].minters[_minter];\n', '  }\n', '\n', '  /**\n', '   * @dev lot active minters\n', '   */\n', '  function lotActiveMinters(uint256 _lotId) public view returns (uint256) {\n', '    return mintableLots[_lotId].activeMinters;\n', '  }\n', '\n', '  /**\n', '   * @dev implement IMintable interface\n', '   */\n', '  function mintingFinished() public view returns (bool) {\n', '    return token.mintingFinished();\n', '  }\n', '\n', '  /**\n', '   * @dev setup token and minters\n', '   **/\n', '  function setup(MintableBridgeToken _token, address[] _minters)\n', '    public onlyOwner\n', '  {\n', '    require(address(_token) != 0, "TM06");\n', '    require(address(token) == 0, "TM07");\n', '    // Ensure it has full ownership over the token to ensure\n', '    // that only this contract will be allowed to mint\n', '    require(_token.owner() == address(this), "TM08");\n', '    token = _token;\n', '    \n', '    // Ensure that the token has not been premint\n', '    require(token.totalSupply() == 0, "TM09");\n', '    require(!token.mintingFinished(), "TM10");\n', '    \n', '    require(_minters.length == config.tokensalesCount(), "TM11");\n', '    for (uint256 i = 0; i < _minters.length; i++) {\n', '      if (_minters[i] != address(0)) {\n', '        setupMinter(_minters[i], i);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev setup minter\n', '   */\n', '  function setupMinter(address _minter, uint256 _tokensaleId)\n', '    public onlyOwner\n', '  {\n', '    uint256 lotId = config.lotId(_tokensaleId);\n', '    require(lotId < mintableLots.length, "TM12");\n', '    MintableLot storage lot = mintableLots[lotId];\n', '    require(!lot.minters[_minter], "TM13");\n', '    lot.minters[_minter] = true;\n', '    lot.activeMinters++;\n', '    minterLotIds[_minter] = lotId;\n', '    emit MinterAdded(lotId, _minter);\n', '  }\n', '\n', '  /**\n', '   * @dev mint the token from the corresponding lot\n', '   */\n', '  function mint(address _to, uint256 _amount)\n', '    public returns (bool)\n', '  {\n', '    require(address(token) != 0, "TM14");\n', '    require(_amount > 0, "TM15");\n', '    \n', '    uint256 lotId = minterLotIds[msg.sender];\n', '    MintableLot storage lot = mintableLots[lotId];\n', '\n', '    require(lot.mintableSupply >= _amount, "TM16");\n', '\n', '    lot.mintableSupply = lot.mintableSupply.sub(_amount);\n', '    totalMintableSupply = totalMintableSupply.sub(_amount);\n', '    return token.mint(_to, _amount);\n', '  }\n', '\n', '  /**\n', '   * @dev update this contract minting to finish\n', '   */\n', '  function finishMinting() public returns (bool) {\n', '    return finishMintingInternal(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev update this contract minting to finish\n', '   */\n', '  function finishMintingRestricted(address _minter)\n', '    public onlyOwner returns (bool)\n', '  {\n', '    return finishMintingInternal(_minter);\n', '  }\n', '\n', '  /**\n', '   * @dev update this contract minting to finish\n', '   */\n', '  function finishMintingInternal(address _minter)\n', '    public returns (bool)\n', '  {\n', '    uint256 lotId = minterLotIds[_minter];\n', '    MintableLot storage lot = mintableLots[lotId];\n', '    require(lot.minters[_minter], "TM17");\n', '\n', '    lot.minters[_minter] = false;\n', '    lot.activeMinters--;\n', '\n', '    if (lot.activeMinters == 0 && lot.mintableSupply == 0) {\n', '      finishLotMintingPrivate(lotId);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev mint remaining non distributed tokens for a lot\n', '   */\n', '  function mintRemainingLot(uint256 _lotId)\n', '    public returns (bool)\n', '  {\n', '    MintableLot storage lot = mintableLots[_lotId];\n', '    require(lot.activeMinters == 0, "TM18");\n', '    require(lot.mintableSupply > 0, "TM19");\n', '\n', '    require(token.mint(lot.vault, lot.mintableSupply), "TM20");\n', '    totalMintableSupply = totalMintableSupply.sub(lot.mintableSupply);\n', '    lot.mintableSupply = 0;\n', ' \n', '    finishLotMintingPrivate(_lotId);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev mint remaining non distributed tokens\n', '   * If some tokens remain unminted (unsold or rounding approximations)\n', '   * they must be minted before the minting can be finished\n', '   **/\n', '  function mintAllRemaining() public onlyOwner returns (bool) {\n', '    require(!token.mintingFinished(), "TM21");\n', '    require(activeLots > 0, "TM22");\n', '   \n', '    if (totalMintableSupply > 0) {\n', '      for (uint256 i = 0; i < mintableLots.length; i++) {\n', '        MintableLot storage lot = mintableLots[i];\n', '        if (lot.mintableSupply > 0) {\n', '          mintRemainingLot(i);\n', '        }\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev finish token minting\n', '   */\n', '  function finishTokenMinting() public onlyOwner returns (bool) {\n', '    require(totalMintableSupply == 0, "TM23");\n', '    require(!token.mintingFinished(), "TM24");\n', '    require(token.finishMinting(), "TM25");\n', '    \n', '    require(token.mintingFinished(), "TM26");\n', '    token.transferOwnership(finalTokenOwner);\n', '    emit TokenReleased();\n', '  }\n', '\n', '  /**\n', '   * @dev finish lot minting\n', '   */\n', '  function finishLotMintingPrivate(uint256 _lotId) private {\n', '    activeLots--;\n', '    emit LotMinted(_lotId);\n', '  }\n', '\n', '  event LotCreated(uint256 lotId, uint256 tokenSupply);\n', '  event MinterAdded(uint256 lotId, address minter);\n', '  event LotMinted(uint256 lotId);\n', '  event TokenReleased();\n', '}']