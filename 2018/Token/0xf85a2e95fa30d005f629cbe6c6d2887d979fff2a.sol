['pragma solidity ^0.4.21;\n', '    \n', '   // ----------------------------------------------------------------------------------------------\n', '   // Project Delta \n', '   // DELTA - New Crypto-Platform with own currency, verified semantic contracts and multi blockchains!\n', '   // Site: http://delta.money\n', '   // Telegram Chat: @deltacoin\n', '   // Telegram News: @deltaico\n', '   // CEO Nechesov Andrey http://facebook.com/Nechesov     \n', '   // Ltd. "Delta"   \n', '   // Tokens Delta: BUY and SELL into this smart contract on exchange\n', '   // ----------------------------------------------------------------------------------------------\n', '    \n', '  library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a * b;\n', '      assert(a == 0 || c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', '      // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '  }\n', '\n', '   // ERC Token Standard #20 Interface\n', '   // https://github.com/ethereum/EIPs/issues/20\n', '\n', '  contract ERC20Interface {\n', '      // Get the total token supply\n', '      function totalSupply() constant returns (uint256 totalSupply);\n', '   \n', '      // Get the account balance of another account with address _owner\n', '      function balanceOf(address _owner) constant returns (uint256 balance);\n', '   \n', '      // Send _value amount of tokens to address _to\n', '      function transfer(address _to, uint256 _value) returns (bool success);\n', '   \n', '      // Send _value amount of tokens from address _from to address _to\n', '      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '   \n', '      // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '      // If this function is called again it overwrites the current allowance with _value.\n', '      // this function is required for some DEX functionality\n', '      function approve(address _spender, uint256 _value) returns (bool success);\n', '   \n', '      // Returns the amount which _spender is still allowed to withdraw from _owner\n', '      function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '   \n', '      // Triggered when tokens are transferred.\n', '      event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '   \n', '      // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '      event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '  }\n', '\n', '  contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '  }      \n', '   \n', '  contract TokenBase is ERC20Interface {\n', '\n', '      using SafeMath for uint;\n', '\n', '      string public constant symbol = "DELTA";\n', '      string public constant name = "DELTA token";\n', '      uint8 public constant decimals = 18; \n', '           \n', '      uint256 public constant maxTokens = (2**32-1)*10**18; \n', '      uint256 public constant ownerSupply = maxTokens*25/100;\n', '      uint256 _totalSupply = ownerSupply;              \n', '\n', '      // For future\n', '      // If migration to a new contract is allowed\n', '      bool public migrationAllowed = false;\n', '\n', '      // New contract address\n', '      address public migrationAddress;\n', '\n', '      // How many tokens were migrated to a new contract \n', '      uint256 public totalMigrated = 0; \n', '      \n', '      // Owner of this contract\n', '      address public owner;\n', '   \n', '      // Balances for each account\n', '      mapping(address => uint256) balances;\n', '   \n', '      // Owner of account approves the transfer of an amount to another account\n', '      mapping(address => mapping (address => uint256)) allowed;\n', '\n', '      // Orders holders who wish sell tokens, save amount\n', '      mapping(address => uint256) public orders_sell_amount;\n', '\n', '      // Orders holders who wish sell tokens, save price\n', '      mapping(address => uint256) public orders_sell_price;\n', '\n', '      //orders list\n', '      address[] public orders_sell_list;\n', '\n', '      // Triggered orders sell/buy\n', '      event Orders_sell(address indexed _from, address indexed _to, uint256 _amount, uint256 _price, uint256 _seller_money, uint256 _buyer_money);\n', '   \n', '      // Functions with this modifier can only be executed by the owner\n', '      modifier onlyOwner() {\n', '          if (msg.sender != owner) {\n', '              throw;\n', '          }\n', '          _;\n', '      }\n', '\n', '      // Migrate tokens to a new contract\n', '      function migrate(uint256 _value) external {\n', '          require(migrationAllowed);\n', '          require(migrationAddress != 0x0);\n', '          require(_value > 0);\n', '          require(_value <= balances[msg.sender]);\n', '\n', '          balances[msg.sender] = balances[msg.sender].sub(_value);\n', '          _totalSupply = _totalSupply.sub(_value);\n', '          totalMigrated = totalMigrated.add(_value);\n', '\n', '          MigrationAgent(migrationAddress).migrateFrom(msg.sender, _value);\n', '      }  \n', '      \n', '      function configureMigrate(bool _migrationAllowed, address _migrationAddress) onlyOwner {\n', '          migrationAllowed = _migrationAllowed;\n', '          migrationAddress = _migrationAddress;\n', '      }\n', '\n', '  }\n', '\n', '  contract DELTA_Token is TokenBase {\n', '\n', '      using SafeMath for uint;\n', '\n', '      uint256 public constant token_price = 10**18*1/100; \n', '\n', '      uint public pre_ico_start = 1522540800;\n', '      uint public ico_start = 1525132800;\n', '      uint public ico_finish = 1530403200;             \n', '\n', '      uint public p1 = 250;             \n', '      uint public p2 = 200;             \n', '      uint public p3 = 150;             \n', '      uint public p4 = 125;             \n', '      uint public p5 = 100;\n', '\n', '      uint public coef = 105;      \n', '   \n', '      // Constructor\n', '      function DELTA_Token() {\n', '          owner = msg.sender;\n', '          balances[owner] = ownerSupply;\n', '      }\n', '      \n', '      //default function for buy tokens      \n', '      function() payable {        \n', '          tokens_buy();        \n', '      }\n', '      \n', '      function totalSupply() constant returns (uint256 totalSupply) {\n', '          totalSupply = _totalSupply;\n', '      }\n', '\n', '      //Withdraw money from contract balance to owner\n', '      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n', '          uint256 balance;\n', '          balance = this.balance;\n', '          if(_amount > 0) balance = _amount;\n', '          owner.send(balance);\n', '          return true;\n', '      }\n', '\n', '      //Change coef\n', '      function change_coef(uint256 _coef) onlyOwner returns (bool result) {\n', '          coef = _coef;\n', '          return true;\n', '      }\n', '\n', '      function change_p1(uint256 _p1) onlyOwner returns (bool result) {\n', '          p1 = _p1;\n', '          return true;\n', '      }\n', '\n', '      function change_p2(uint256 _p2) onlyOwner returns (bool result) {\n', '          p2 = _p2;\n', '          return true;\n', '      }\n', '\n', '      function change_p3(uint256 _p3) onlyOwner returns (bool result) {\n', '          p3 = _p3;\n', '          return true;\n', '      }\n', '\n', '      function change_p4(uint256 _p4) onlyOwner returns (bool result) {\n', '          p4 = _p4;\n', '          return true;\n', '      }\n', '\n', '      function change_p5(uint256 _p5) onlyOwner returns (bool result) {\n', '          p5 = _p5;\n', '          return true;\n', '      }\n', '\n', '      //Change pre_ico_start date\n', '      function change_pre_ico_start(uint256 _pre_ico_start) onlyOwner returns (bool result) {\n', '          pre_ico_start = _pre_ico_start;\n', '          return true;\n', '      }\n', '\n', '      //Change ico_start date\n', '      function change_ico_start(uint256 _ico_start) onlyOwner returns (bool result) {\n', '          ico_start = _ico_start;\n', '          return true;\n', '      }\n', '\n', '      //Change ico_finish date\n', '      function change_ico_finish(uint256 _ico_finish) onlyOwner returns (bool result) {\n', '          ico_finish = _ico_finish;\n', '          return true;\n', '      }\n', '   \n', '      // What is the balance of a particular account?\n', '      function balanceOf(address _owner) constant returns (uint256 balance) {\n', '          return balances[_owner];\n', '      }\n', '   \n', '      // Transfer the balance from owner&#39;s account to another account\n', '      function transfer(address _to, uint256 _amount) returns (bool success) {          \n', '\n', '          if (balances[msg.sender] >= _amount \n', '              && _amount > 0\n', '              && balances[_to] + _amount > balances[_to]) {\n', '              balances[msg.sender] -= _amount;\n', '              balances[_to] += _amount;\n', '              Transfer(msg.sender, _to, _amount);\n', '              return true;\n', '          } else {\n', '              return false;\n', '          }\n', '      }\n', '   \n', '      // Send _value amount of tokens from address _from to address _to\n', '      // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '      // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '      // fees in sub-currencies; the command should fail unless the _from account has\n', '      // deliberately authorized the sender of the message via some mechanism; we propose\n', '      // these standardized APIs for approval:\n', '      function transferFrom(\n', '          address _from,\n', '          address _to,\n', '          uint256 _amount\n', '     ) returns (bool success) {         \n', '\n', '         if (balances[_from] >= _amount\n', '             && allowed[_from][msg.sender] >= _amount\n', '             && _amount > 0\n', '             && balances[_to] + _amount > balances[_to]) {\n', '             balances[_from] -= _amount;\n', '             allowed[_from][msg.sender] -= _amount;\n', '             balances[_to] += _amount;\n', '             Transfer(_from, _to, _amount);\n', '             return true;\n', '         } else {\n', '             return false;\n', '         }\n', '     }\n', '  \n', '     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '     // If this function is called again it overwrites the current allowance with _value.\n', '     function approve(address _spender, uint256 _amount) returns (bool success) {\n', '         allowed[msg.sender][_spender] = _amount;\n', '         Approval(msg.sender, _spender, _amount);\n', '         return true;\n', '     }\n', '  \n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '         return allowed[_owner][_spender];\n', '     } \n', '\n', '      /**\n', '      * Buy tokens on pre-ico and ico \n', '      */\n', '      function tokens_buy() payable returns (bool) { \n', '\n', '        uint tnow = now;        \n', '        \n', '        require(tnow <= ico_finish);\n', '        require(_totalSupply < maxTokens);\n', '        require(msg.value >= token_price);        \n', '\n', '        uint tokens_buy = msg.value*10**18/token_price;\n', '\n', '        require(tokens_buy > 0);   \n', '        \n', '        if(tnow < ico_start + 86400*0){          \n', '          tokens_buy = tokens_buy*p1/100;\n', '        } \n', '        if((ico_start + 86400*0 <= tnow)&&(tnow < ico_start + 86400*2)){\n', '          tokens_buy = tokens_buy*p2/100;\n', '        } \n', '        if((ico_start + 86400*2 <= tnow)&&(tnow < ico_start + 86400*7)){\n', '          tokens_buy = tokens_buy*p3/100;        \n', '        } \n', '        if((ico_start + 86400*7 <= tnow)&&(tnow < ico_start + 86400*14)){\n', '          tokens_buy = tokens_buy*p4/100;        \n', '        }\n', '        if(ico_start + 86400*14 <= tnow){\n', '          tokens_buy = tokens_buy*p5/100;        \n', '        }         \n', '\n', '        require(_totalSupply.add(tokens_buy) <= maxTokens);\n', '        _totalSupply = _totalSupply.add(tokens_buy);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens_buy);         \n', '\n', '        return true;\n', '      }      \n', '\n', '      function orders_sell_total () constant returns (uint) {\n', '        return orders_sell_list.length;\n', '      } \n', '\n', '      function get_orders_sell_amount(address _from) constant returns(uint) {\n', '\n', '        uint _amount_max = 0;\n', '\n', '        if(!(orders_sell_amount[_from] > 0)) return _amount_max;\n', '\n', '        if(balanceOf(_from) > 0) _amount_max = balanceOf(_from);\n', '        if(orders_sell_amount[_from] < _amount_max) _amount_max = orders_sell_amount[_from];\n', '\n', '        return _amount_max;\n', '      }\n', '\n', '      /**\n', '      * Order Sell tokens  \n', '      */\n', '      function order_sell(uint256 _max_amount, uint256 _price) returns (bool) {\n', '\n', '        require(_max_amount > 0);\n', '        require(_price > 0);        \n', '\n', '        orders_sell_amount[msg.sender] = _max_amount;\n', '        orders_sell_price[msg.sender] = (_price*coef).div(100);\n', '        orders_sell_list.push(msg.sender);        \n', '\n', '        return true;\n', '      }\n', '\n', '      function order_buy(address _from, uint256 _max_price) payable returns (bool) {\n', '        \n', '        require(msg.value > 0);\n', '        require(_max_price > 0);        \n', '        require(orders_sell_amount[_from] > 0);\n', '        require(orders_sell_price[_from] > 0); \n', '        require(orders_sell_price[_from] <= _max_price);\n', '\n', '        uint _amount = (msg.value*10**18).div(orders_sell_price[_from]);\n', '        uint _amount_from = get_orders_sell_amount(_from);\n', '\n', '        if(_amount > _amount_from) _amount = _amount_from;        \n', '        require(_amount > 0);        \n', '\n', '        uint _total_money = (orders_sell_price[_from]*_amount).div(10**18);        \n', '        require(_total_money <= msg.value);\n', '\n', '        uint _seller_money = (_total_money*100).div(coef);\n', '        uint _buyer_money = msg.value - _total_money;\n', '\n', '        require(_seller_money > 0);        \n', '        require(_seller_money + _buyer_money <= msg.value);\n', '        \n', '        _from.send(_seller_money);\n', '        msg.sender.send(_buyer_money);\n', '\n', '        orders_sell_amount[_from] -= _amount;        \n', '        balances[_from] -= _amount;\n', '        balances[msg.sender] += _amount; \n', '\n', '        Orders_sell(_from, msg.sender, _amount, orders_sell_price[_from], _seller_money, _buyer_money);\n', '\n', '      }\n', '      \n', ' }']
['pragma solidity ^0.4.21;\n', '    \n', '   // ----------------------------------------------------------------------------------------------\n', '   // Project Delta \n', '   // DELTA - New Crypto-Platform with own currency, verified semantic contracts and multi blockchains!\n', '   // Site: http://delta.money\n', '   // Telegram Chat: @deltacoin\n', '   // Telegram News: @deltaico\n', '   // CEO Nechesov Andrey http://facebook.com/Nechesov     \n', '   // Ltd. "Delta"   \n', '   // Tokens Delta: BUY and SELL into this smart contract on exchange\n', '   // ----------------------------------------------------------------------------------------------\n', '    \n', '  library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a * b;\n', '      assert(a == 0 || c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '  }\n', '\n', '   // ERC Token Standard #20 Interface\n', '   // https://github.com/ethereum/EIPs/issues/20\n', '\n', '  contract ERC20Interface {\n', '      // Get the total token supply\n', '      function totalSupply() constant returns (uint256 totalSupply);\n', '   \n', '      // Get the account balance of another account with address _owner\n', '      function balanceOf(address _owner) constant returns (uint256 balance);\n', '   \n', '      // Send _value amount of tokens to address _to\n', '      function transfer(address _to, uint256 _value) returns (bool success);\n', '   \n', '      // Send _value amount of tokens from address _from to address _to\n', '      function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '   \n', '      // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '      // If this function is called again it overwrites the current allowance with _value.\n', '      // this function is required for some DEX functionality\n', '      function approve(address _spender, uint256 _value) returns (bool success);\n', '   \n', '      // Returns the amount which _spender is still allowed to withdraw from _owner\n', '      function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '   \n', '      // Triggered when tokens are transferred.\n', '      event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '   \n', '      // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '      event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '  }\n', '\n', '  contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '  }      \n', '   \n', '  contract TokenBase is ERC20Interface {\n', '\n', '      using SafeMath for uint;\n', '\n', '      string public constant symbol = "DELTA";\n', '      string public constant name = "DELTA token";\n', '      uint8 public constant decimals = 18; \n', '           \n', '      uint256 public constant maxTokens = (2**32-1)*10**18; \n', '      uint256 public constant ownerSupply = maxTokens*25/100;\n', '      uint256 _totalSupply = ownerSupply;              \n', '\n', '      // For future\n', '      // If migration to a new contract is allowed\n', '      bool public migrationAllowed = false;\n', '\n', '      // New contract address\n', '      address public migrationAddress;\n', '\n', '      // How many tokens were migrated to a new contract \n', '      uint256 public totalMigrated = 0; \n', '      \n', '      // Owner of this contract\n', '      address public owner;\n', '   \n', '      // Balances for each account\n', '      mapping(address => uint256) balances;\n', '   \n', '      // Owner of account approves the transfer of an amount to another account\n', '      mapping(address => mapping (address => uint256)) allowed;\n', '\n', '      // Orders holders who wish sell tokens, save amount\n', '      mapping(address => uint256) public orders_sell_amount;\n', '\n', '      // Orders holders who wish sell tokens, save price\n', '      mapping(address => uint256) public orders_sell_price;\n', '\n', '      //orders list\n', '      address[] public orders_sell_list;\n', '\n', '      // Triggered orders sell/buy\n', '      event Orders_sell(address indexed _from, address indexed _to, uint256 _amount, uint256 _price, uint256 _seller_money, uint256 _buyer_money);\n', '   \n', '      // Functions with this modifier can only be executed by the owner\n', '      modifier onlyOwner() {\n', '          if (msg.sender != owner) {\n', '              throw;\n', '          }\n', '          _;\n', '      }\n', '\n', '      // Migrate tokens to a new contract\n', '      function migrate(uint256 _value) external {\n', '          require(migrationAllowed);\n', '          require(migrationAddress != 0x0);\n', '          require(_value > 0);\n', '          require(_value <= balances[msg.sender]);\n', '\n', '          balances[msg.sender] = balances[msg.sender].sub(_value);\n', '          _totalSupply = _totalSupply.sub(_value);\n', '          totalMigrated = totalMigrated.add(_value);\n', '\n', '          MigrationAgent(migrationAddress).migrateFrom(msg.sender, _value);\n', '      }  \n', '      \n', '      function configureMigrate(bool _migrationAllowed, address _migrationAddress) onlyOwner {\n', '          migrationAllowed = _migrationAllowed;\n', '          migrationAddress = _migrationAddress;\n', '      }\n', '\n', '  }\n', '\n', '  contract DELTA_Token is TokenBase {\n', '\n', '      using SafeMath for uint;\n', '\n', '      uint256 public constant token_price = 10**18*1/100; \n', '\n', '      uint public pre_ico_start = 1522540800;\n', '      uint public ico_start = 1525132800;\n', '      uint public ico_finish = 1530403200;             \n', '\n', '      uint public p1 = 250;             \n', '      uint public p2 = 200;             \n', '      uint public p3 = 150;             \n', '      uint public p4 = 125;             \n', '      uint public p5 = 100;\n', '\n', '      uint public coef = 105;      \n', '   \n', '      // Constructor\n', '      function DELTA_Token() {\n', '          owner = msg.sender;\n', '          balances[owner] = ownerSupply;\n', '      }\n', '      \n', '      //default function for buy tokens      \n', '      function() payable {        \n', '          tokens_buy();        \n', '      }\n', '      \n', '      function totalSupply() constant returns (uint256 totalSupply) {\n', '          totalSupply = _totalSupply;\n', '      }\n', '\n', '      //Withdraw money from contract balance to owner\n', '      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n', '          uint256 balance;\n', '          balance = this.balance;\n', '          if(_amount > 0) balance = _amount;\n', '          owner.send(balance);\n', '          return true;\n', '      }\n', '\n', '      //Change coef\n', '      function change_coef(uint256 _coef) onlyOwner returns (bool result) {\n', '          coef = _coef;\n', '          return true;\n', '      }\n', '\n', '      function change_p1(uint256 _p1) onlyOwner returns (bool result) {\n', '          p1 = _p1;\n', '          return true;\n', '      }\n', '\n', '      function change_p2(uint256 _p2) onlyOwner returns (bool result) {\n', '          p2 = _p2;\n', '          return true;\n', '      }\n', '\n', '      function change_p3(uint256 _p3) onlyOwner returns (bool result) {\n', '          p3 = _p3;\n', '          return true;\n', '      }\n', '\n', '      function change_p4(uint256 _p4) onlyOwner returns (bool result) {\n', '          p4 = _p4;\n', '          return true;\n', '      }\n', '\n', '      function change_p5(uint256 _p5) onlyOwner returns (bool result) {\n', '          p5 = _p5;\n', '          return true;\n', '      }\n', '\n', '      //Change pre_ico_start date\n', '      function change_pre_ico_start(uint256 _pre_ico_start) onlyOwner returns (bool result) {\n', '          pre_ico_start = _pre_ico_start;\n', '          return true;\n', '      }\n', '\n', '      //Change ico_start date\n', '      function change_ico_start(uint256 _ico_start) onlyOwner returns (bool result) {\n', '          ico_start = _ico_start;\n', '          return true;\n', '      }\n', '\n', '      //Change ico_finish date\n', '      function change_ico_finish(uint256 _ico_finish) onlyOwner returns (bool result) {\n', '          ico_finish = _ico_finish;\n', '          return true;\n', '      }\n', '   \n', '      // What is the balance of a particular account?\n', '      function balanceOf(address _owner) constant returns (uint256 balance) {\n', '          return balances[_owner];\n', '      }\n', '   \n', "      // Transfer the balance from owner's account to another account\n", '      function transfer(address _to, uint256 _amount) returns (bool success) {          \n', '\n', '          if (balances[msg.sender] >= _amount \n', '              && _amount > 0\n', '              && balances[_to] + _amount > balances[_to]) {\n', '              balances[msg.sender] -= _amount;\n', '              balances[_to] += _amount;\n', '              Transfer(msg.sender, _to, _amount);\n', '              return true;\n', '          } else {\n', '              return false;\n', '          }\n', '      }\n', '   \n', '      // Send _value amount of tokens from address _from to address _to\n', '      // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '      // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '      // fees in sub-currencies; the command should fail unless the _from account has\n', '      // deliberately authorized the sender of the message via some mechanism; we propose\n', '      // these standardized APIs for approval:\n', '      function transferFrom(\n', '          address _from,\n', '          address _to,\n', '          uint256 _amount\n', '     ) returns (bool success) {         \n', '\n', '         if (balances[_from] >= _amount\n', '             && allowed[_from][msg.sender] >= _amount\n', '             && _amount > 0\n', '             && balances[_to] + _amount > balances[_to]) {\n', '             balances[_from] -= _amount;\n', '             allowed[_from][msg.sender] -= _amount;\n', '             balances[_to] += _amount;\n', '             Transfer(_from, _to, _amount);\n', '             return true;\n', '         } else {\n', '             return false;\n', '         }\n', '     }\n', '  \n', '     // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '     // If this function is called again it overwrites the current allowance with _value.\n', '     function approve(address _spender, uint256 _amount) returns (bool success) {\n', '         allowed[msg.sender][_spender] = _amount;\n', '         Approval(msg.sender, _spender, _amount);\n', '         return true;\n', '     }\n', '  \n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '         return allowed[_owner][_spender];\n', '     } \n', '\n', '      /**\n', '      * Buy tokens on pre-ico and ico \n', '      */\n', '      function tokens_buy() payable returns (bool) { \n', '\n', '        uint tnow = now;        \n', '        \n', '        require(tnow <= ico_finish);\n', '        require(_totalSupply < maxTokens);\n', '        require(msg.value >= token_price);        \n', '\n', '        uint tokens_buy = msg.value*10**18/token_price;\n', '\n', '        require(tokens_buy > 0);   \n', '        \n', '        if(tnow < ico_start + 86400*0){          \n', '          tokens_buy = tokens_buy*p1/100;\n', '        } \n', '        if((ico_start + 86400*0 <= tnow)&&(tnow < ico_start + 86400*2)){\n', '          tokens_buy = tokens_buy*p2/100;\n', '        } \n', '        if((ico_start + 86400*2 <= tnow)&&(tnow < ico_start + 86400*7)){\n', '          tokens_buy = tokens_buy*p3/100;        \n', '        } \n', '        if((ico_start + 86400*7 <= tnow)&&(tnow < ico_start + 86400*14)){\n', '          tokens_buy = tokens_buy*p4/100;        \n', '        }\n', '        if(ico_start + 86400*14 <= tnow){\n', '          tokens_buy = tokens_buy*p5/100;        \n', '        }         \n', '\n', '        require(_totalSupply.add(tokens_buy) <= maxTokens);\n', '        _totalSupply = _totalSupply.add(tokens_buy);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens_buy);         \n', '\n', '        return true;\n', '      }      \n', '\n', '      function orders_sell_total () constant returns (uint) {\n', '        return orders_sell_list.length;\n', '      } \n', '\n', '      function get_orders_sell_amount(address _from) constant returns(uint) {\n', '\n', '        uint _amount_max = 0;\n', '\n', '        if(!(orders_sell_amount[_from] > 0)) return _amount_max;\n', '\n', '        if(balanceOf(_from) > 0) _amount_max = balanceOf(_from);\n', '        if(orders_sell_amount[_from] < _amount_max) _amount_max = orders_sell_amount[_from];\n', '\n', '        return _amount_max;\n', '      }\n', '\n', '      /**\n', '      * Order Sell tokens  \n', '      */\n', '      function order_sell(uint256 _max_amount, uint256 _price) returns (bool) {\n', '\n', '        require(_max_amount > 0);\n', '        require(_price > 0);        \n', '\n', '        orders_sell_amount[msg.sender] = _max_amount;\n', '        orders_sell_price[msg.sender] = (_price*coef).div(100);\n', '        orders_sell_list.push(msg.sender);        \n', '\n', '        return true;\n', '      }\n', '\n', '      function order_buy(address _from, uint256 _max_price) payable returns (bool) {\n', '        \n', '        require(msg.value > 0);\n', '        require(_max_price > 0);        \n', '        require(orders_sell_amount[_from] > 0);\n', '        require(orders_sell_price[_from] > 0); \n', '        require(orders_sell_price[_from] <= _max_price);\n', '\n', '        uint _amount = (msg.value*10**18).div(orders_sell_price[_from]);\n', '        uint _amount_from = get_orders_sell_amount(_from);\n', '\n', '        if(_amount > _amount_from) _amount = _amount_from;        \n', '        require(_amount > 0);        \n', '\n', '        uint _total_money = (orders_sell_price[_from]*_amount).div(10**18);        \n', '        require(_total_money <= msg.value);\n', '\n', '        uint _seller_money = (_total_money*100).div(coef);\n', '        uint _buyer_money = msg.value - _total_money;\n', '\n', '        require(_seller_money > 0);        \n', '        require(_seller_money + _buyer_money <= msg.value);\n', '        \n', '        _from.send(_seller_money);\n', '        msg.sender.send(_buyer_money);\n', '\n', '        orders_sell_amount[_from] -= _amount;        \n', '        balances[_from] -= _amount;\n', '        balances[msg.sender] += _amount; \n', '\n', '        Orders_sell(_from, msg.sender, _amount, orders_sell_price[_from], _seller_money, _buyer_money);\n', '\n', '      }\n', '      \n', ' }']
