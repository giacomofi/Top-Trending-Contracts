['pragma solidity ^0.4.23;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // The Ownable constructor sets the original `owner` \n', '    // of the contract to the sender account.\n', '    constructor()  public {\n', '        owner = msg.sender;\n', '    } \n', '\n', '    // Throw if called by any account other than the current owner\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allow the current owner to transfer control of the contract to a newOwner\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract RAcoinToken is Ownable, ERC20Interface {\n', '    string public constant symbol = "RAC";\n', '    string public constant name = "RAcoinToken";\n', '    uint private _totalSupply;\n', '    uint public constant decimals = 18;\n', '    uint private unmintedTokens = 20000000000*uint(10)**decimals; \n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    //Struct to hold lockup records\n', '    struct LockupRecord {\n', '        uint amount;\n', '        uint unlockTime;\n', '    }\n', '    \n', '    // Balances for each account\n', '    mapping(address => uint) balances;\n', '    \n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint)) allowed; \n', '    \n', '    // Balances for lockup accounts\n', '    mapping(address => LockupRecord)balancesLockup;\n', '\n', '\n', '\n', '    /**\n', '     ====== JACKPOT IMPLEMENTATION ====== \n', '     */\n', '\n', '    // Percentage for jackpot reserving during tokens transfer\n', '    uint public reservingPercentage = 1;\n', '    \n', '    // Minimum amount of jackpot, before reaching it jackpot cannot be distributed. \n', '    // Default value is 100,000 RAC\n', '    uint public jackpotMinimumAmount = 100000 * uint(10)**decimals; \n', '    \n', '    // reservingStep is used for calculating how many times a user will be added to jackpot participants list:\n', '    // times user will be added to jackpotParticipants list = transfer amount / reservingStep\n', '    // the more user transfer tokens using transferWithReserving function the more times he will be added and, \n', '    // as a result, more chances to win the jackpot. Default value is 10,000 RAC\n', '    uint public reservingStep = 10000 * uint(10)**decimals; \n', '    \n', '    // The seed is used each time Jackpot is distributing for generating a random number.\n', '    // First seed has some value, after the every turn of the jackpot distribution will be changed \n', '    uint private seed = 1; // Default seed \n', '    \n', '    // The maximum allowed times when jackpot amount and distribution time will be set by owner,\n', '    // Used only for token sale jackpot distribution \n', '    int public maxAllowedManualDistribution = 111; \n', '\n', '    // Either or not clear the jackpot participants list after the Jackpot distribution\n', '    bool public clearJackpotParticipantsAfterDistribution = false;\n', '\n', '    // Variable that holds last actual index of jackpotParticipants collection\n', '    uint private index = 0; \n', '\n', '    // The list with Jackpot participants. The more times address is in the list, the more chances to win the Jackpot\n', '    address[] private jackpotParticipants; \n', '\n', '    event SetReservingPercentage(uint _value);\n', '    event SetReservingStep(uint _value);\n', '    event SetJackpotMinimumAmount(uint _value);\n', '    event AddAddressToJackpotParticipants(address indexed _sender, uint _times);\n', '    \n', '    //Setting the reservingPercentage value, allowed only for owner\n', '    function setReservingPercentage(uint _value) public onlyOwner returns (bool success) {\n', '        assert(_value > 0 && _value < 100);\n', '        \n', '        reservingPercentage = _value;\n', '        emit SetReservingPercentage(_value);\n', '        return true;\n', '    }\n', '    \n', '    //Setting the reservingStep value, allowed only for owner\n', '    function setReservingStep(uint _value) public onlyOwner returns (bool success) {\n', '        assert(_value > 0);\n', '        reservingStep = _value;\n', '        emit SetReservingStep(_value);\n', '        return true;\n', '    }\n', '    \n', '    //Setting the setJackpotMinimumAmount value, allowed only for owner\n', '    function setJackpotMinimumAmount(uint _value) public onlyOwner returns (bool success) {\n', '        jackpotMinimumAmount = _value;\n', '        emit SetJackpotMinimumAmount(_value);\n', '        return true;\n', '    }\n', '\n', '    //Setting the clearJackpotParticipantsAfterDistribution value, allowed only for owner\n', '    function setPoliticsForJackpotParticipantsList(bool _clearAfterDistribution) public onlyOwner returns (bool success) {\n', '        clearJackpotParticipantsAfterDistribution = _clearAfterDistribution;\n', '        return true;\n', '    }\n', '    \n', '    // Empty the jackpot participants list\n', '    function clearJackpotParticipants() public onlyOwner returns (bool success) {\n', '        index = 0;\n', '        return true;\n', '    }\n', '    \n', '    // Using this function a user transfers tokens and participates in operating jackpot \n', '    // User sets the total transfer amount that includes the Jackpot reserving deposit\n', '    function transferWithReserving(address _to, uint _totalTransfer) public returns (bool success) {\n', '        uint netTransfer = _totalTransfer * (100 - reservingPercentage) / 100; \n', '        require(balances[msg.sender] >= _totalTransfer && (_totalTransfer > netTransfer));\n', '        \n', '        if (transferMain(msg.sender, _to, netTransfer) && (_totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(_totalTransfer, netTransfer, msg.sender);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a user transfers tokens and participates in operating jackpot \n', '    // User sets the net value of transfer without the Jackpot reserving deposit amount \n', '    function transferWithReservingNet(address _to, uint _netTransfer) public returns (bool success) {\n', '        uint totalTransfer = _netTransfer * (100 + reservingPercentage) / 100; \n', '        require(balances[msg.sender] >= totalTransfer && (totalTransfer > _netTransfer));\n', '        \n', '        if (transferMain(msg.sender, _to, _netTransfer) && (totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(totalTransfer, _netTransfer, msg.sender);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a spender transfers tokens and make an owner of funds a participant of the operating Jackpot \n', '    // User sets the total transfer amount that includes the Jackpot reserving deposit\n', '    function transferFromWithReserving(address _from, address _to, uint _totalTransfer) public returns (bool success) {\n', '        uint netTransfer = _totalTransfer * (100 - reservingPercentage) / 100; \n', '        require(balances[_from] >= _totalTransfer && (_totalTransfer > netTransfer));\n', '        \n', '        if (transferFrom(_from, _to, netTransfer) && (_totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(_totalTransfer, netTransfer, _from);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a spender transfers tokens and make an owner of funds a participatants of the operating Jackpot \n', '    // User set the net value of transfer without the Jackpot reserving deposit amount \n', '    function transferFromWithReservingNet(address _from, address _to, uint _netTransfer) public returns (bool success) {\n', '        uint totalTransfer = _netTransfer * (100 + reservingPercentage) / 100; \n', '        require(balances[_from] >= totalTransfer && (totalTransfer > _netTransfer));\n', '\n', '        if (transferFrom(_from, _to, _netTransfer) && (totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(totalTransfer, _netTransfer, _from);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Withdraw deposit of Jackpot amount and add address to Jackpot Participants List according to transaction amount\n', '    function processJackpotDeposit(uint _totalTransfer, uint _netTransfer, address _participant) private returns (bool success) {\n', '        addAddressToJackpotParticipants(_participant, _totalTransfer);\n', '\n', '        uint jackpotDeposit = _totalTransfer - _netTransfer;\n', '        balances[_participant] -= jackpotDeposit;\n', '        balances[0] += jackpotDeposit;\n', '\n', '        emit Transfer(_participant, 0, jackpotDeposit);\n', '        return true;\n', '    }\n', '\n', '    // Add address to Jackpot Participants List\n', '    function addAddressToJackpotParticipants(address _participant, uint _transactionAmount) private returns (bool success) {\n', '        uint timesToAdd = _transactionAmount / reservingStep;\n', '        \n', '        for (uint i = 0; i < timesToAdd; i++){\n', '            if(index == jackpotParticipants.length) {\n', '                jackpotParticipants.length += 1;\n', '            }\n', '            jackpotParticipants[index++] = _participant;\n', '        }\n', '\n', '        emit AddAddressToJackpotParticipants(_participant, timesToAdd);\n', '        return true;        \n', '    }\n', '    \n', '    // Distribute jackpot. For finding a winner we use random number that is produced by multiplying a previous seed  \n', '    // received from previous jackpot distribution and casted to uint last available block hash. \n', '    // Remainder from the received random number and total number of participants will give an index of a winner in the Jackpot participants list\n', '    function distributeJackpot(uint _nextSeed) public onlyOwner returns (bool success) {\n', '        assert(balances[0] >= jackpotMinimumAmount);\n', '        assert(_nextSeed > 0);\n', '\n', '        uint additionalSeed = uint(blockhash(block.number - 1));\n', '        uint rnd = 0;\n', '        \n', '        while(rnd < index) {\n', '            rnd += additionalSeed * seed;\n', '        }\n', '        \n', '        uint winner = rnd % index;\n', '        balances[jackpotParticipants[winner]] += balances[0];\n', '        emit Transfer(0, jackpotParticipants[winner], balances[0]);\n', '        balances[0] = 0;\n', '        seed = _nextSeed;\n', '\n', '        if (clearJackpotParticipantsAfterDistribution) {\n', '            clearJackpotParticipants();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Distribute Token Sale Jackpot by minting token sale jackpot directly to 0x0 address and calling distributeJackpot function \n', '    function distributeTokenSaleJackpot(uint _nextSeed, uint _amount) public onlyOwner returns (bool success) {\n', '        require (maxAllowedManualDistribution > 0);\n', '        if (mintTokens(0, _amount) && distributeJackpot(_nextSeed)) {\n', '            maxAllowedManualDistribution--;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    /** \n', '     ====== ERC20 IMPLEMENTATION ====== \n', '     */\n', '    \n', '    // Return total supply of tokens including locked-up funds and current Jackpot deposit\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Get the balance of the specified address\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Transfer token to a specified address   \n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        return transferMain(msg.sender, _to, _value);\n', '    }\n', '\n', '    // Transfer tokens from one address to another \n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '\n', '        if (transferMain(_from, _to, _value)){\n', '            allowed[_from][msg.sender] -= _value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Main transfer function. Checking of balances is made in calling function\n', '    function transferMain(address _from, address _to, uint _value) private returns (bool success) {\n', '        require(_to != address(0));\n', '        assert(balances[_to] + _value >= balances[_to]);\n', '        \n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Function to check the amount of tokens than an owner allowed to a spender\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '\n', '\n', '    /**\n', '     ====== LOCK-UP IMPLEMENTATION ====== \n', '     */\n', '\n', '    function unlockOwnFunds() public returns (bool success) {\n', '        return unlockFunds(msg.sender);\n', '    }\n', '\n', '    function unlockSupervisedFunds(address _from) public onlyOwner returns (bool success) {\n', '        return unlockFunds(_from);\n', '    }\n', '    \n', '    function unlockFunds(address _owner) private returns (bool success) {\n', '        require(balancesLockup[_owner].unlockTime < now && balancesLockup[_owner].amount > 0);\n', '\n', '        balances[_owner] += balancesLockup[_owner].amount;\n', '        emit Transfer(_owner, _owner, balancesLockup[_owner].amount);\n', '        balancesLockup[_owner].amount = 0;\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOfLockup(address _owner) public view returns (uint balance, uint unlockTime) {\n', '        return (balancesLockup[_owner].amount, balancesLockup[_owner].unlockTime);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     ====== TOKENS MINTING IMPLEMENTATION ====== \n', '     */\n', '\n', '    // Mint RAcoin tokens. No more than 20,000,000,000 RAC can be minted\n', '    function mintTokens(address _target, uint _mintedAmount) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '        balances[_target] += _mintedAmount;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount); \n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin locked-up tokens\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintLockupTokens(address _target, uint _mintedAmount, uint _unlockTime) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '\n', '        balancesLockup[_target].amount += _mintedAmount;\n', '        balancesLockup[_target].unlockTime = _unlockTime;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount); //TODO\n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin tokens for token sale participants and add them to Jackpot list\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintTokensWithIncludingInJackpot(address _target, uint _mintedAmount) public onlyOwner returns (bool success) {\n', '        require(maxAllowedManualDistribution > 0);\n', '        if (mintTokens(_target, _mintedAmount)) {\n', '            addAddressToJackpotParticipants(_target, _mintedAmount);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin tokens and approve the passed address to spend the minted amount of tokens\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintTokensWithApproval(address _target, uint _mintedAmount, address _spender) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '        balances[_target] += _mintedAmount;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        allowed[_target][_spender] += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount);\n', '        return true;\n', '    }\n', '\n', '    // After firing this function no more tokens can be created  \n', '    function stopTokenMinting() public onlyOwner returns (bool success) {\n', '        unmintedTokens = 0;\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // The Ownable constructor sets the original `owner` \n', '    // of the contract to the sender account.\n', '    constructor()  public {\n', '        owner = msg.sender;\n', '    } \n', '\n', '    // Throw if called by any account other than the current owner\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allow the current owner to transfer control of the contract to a newOwner\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract RAcoinToken is Ownable, ERC20Interface {\n', '    string public constant symbol = "RAC";\n', '    string public constant name = "RAcoinToken";\n', '    uint private _totalSupply;\n', '    uint public constant decimals = 18;\n', '    uint private unmintedTokens = 20000000000*uint(10)**decimals; \n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    \n', '    //Struct to hold lockup records\n', '    struct LockupRecord {\n', '        uint amount;\n', '        uint unlockTime;\n', '    }\n', '    \n', '    // Balances for each account\n', '    mapping(address => uint) balances;\n', '    \n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint)) allowed; \n', '    \n', '    // Balances for lockup accounts\n', '    mapping(address => LockupRecord)balancesLockup;\n', '\n', '\n', '\n', '    /**\n', '     ====== JACKPOT IMPLEMENTATION ====== \n', '     */\n', '\n', '    // Percentage for jackpot reserving during tokens transfer\n', '    uint public reservingPercentage = 1;\n', '    \n', '    // Minimum amount of jackpot, before reaching it jackpot cannot be distributed. \n', '    // Default value is 100,000 RAC\n', '    uint public jackpotMinimumAmount = 100000 * uint(10)**decimals; \n', '    \n', '    // reservingStep is used for calculating how many times a user will be added to jackpot participants list:\n', '    // times user will be added to jackpotParticipants list = transfer amount / reservingStep\n', '    // the more user transfer tokens using transferWithReserving function the more times he will be added and, \n', '    // as a result, more chances to win the jackpot. Default value is 10,000 RAC\n', '    uint public reservingStep = 10000 * uint(10)**decimals; \n', '    \n', '    // The seed is used each time Jackpot is distributing for generating a random number.\n', '    // First seed has some value, after the every turn of the jackpot distribution will be changed \n', '    uint private seed = 1; // Default seed \n', '    \n', '    // The maximum allowed times when jackpot amount and distribution time will be set by owner,\n', '    // Used only for token sale jackpot distribution \n', '    int public maxAllowedManualDistribution = 111; \n', '\n', '    // Either or not clear the jackpot participants list after the Jackpot distribution\n', '    bool public clearJackpotParticipantsAfterDistribution = false;\n', '\n', '    // Variable that holds last actual index of jackpotParticipants collection\n', '    uint private index = 0; \n', '\n', '    // The list with Jackpot participants. The more times address is in the list, the more chances to win the Jackpot\n', '    address[] private jackpotParticipants; \n', '\n', '    event SetReservingPercentage(uint _value);\n', '    event SetReservingStep(uint _value);\n', '    event SetJackpotMinimumAmount(uint _value);\n', '    event AddAddressToJackpotParticipants(address indexed _sender, uint _times);\n', '    \n', '    //Setting the reservingPercentage value, allowed only for owner\n', '    function setReservingPercentage(uint _value) public onlyOwner returns (bool success) {\n', '        assert(_value > 0 && _value < 100);\n', '        \n', '        reservingPercentage = _value;\n', '        emit SetReservingPercentage(_value);\n', '        return true;\n', '    }\n', '    \n', '    //Setting the reservingStep value, allowed only for owner\n', '    function setReservingStep(uint _value) public onlyOwner returns (bool success) {\n', '        assert(_value > 0);\n', '        reservingStep = _value;\n', '        emit SetReservingStep(_value);\n', '        return true;\n', '    }\n', '    \n', '    //Setting the setJackpotMinimumAmount value, allowed only for owner\n', '    function setJackpotMinimumAmount(uint _value) public onlyOwner returns (bool success) {\n', '        jackpotMinimumAmount = _value;\n', '        emit SetJackpotMinimumAmount(_value);\n', '        return true;\n', '    }\n', '\n', '    //Setting the clearJackpotParticipantsAfterDistribution value, allowed only for owner\n', '    function setPoliticsForJackpotParticipantsList(bool _clearAfterDistribution) public onlyOwner returns (bool success) {\n', '        clearJackpotParticipantsAfterDistribution = _clearAfterDistribution;\n', '        return true;\n', '    }\n', '    \n', '    // Empty the jackpot participants list\n', '    function clearJackpotParticipants() public onlyOwner returns (bool success) {\n', '        index = 0;\n', '        return true;\n', '    }\n', '    \n', '    // Using this function a user transfers tokens and participates in operating jackpot \n', '    // User sets the total transfer amount that includes the Jackpot reserving deposit\n', '    function transferWithReserving(address _to, uint _totalTransfer) public returns (bool success) {\n', '        uint netTransfer = _totalTransfer * (100 - reservingPercentage) / 100; \n', '        require(balances[msg.sender] >= _totalTransfer && (_totalTransfer > netTransfer));\n', '        \n', '        if (transferMain(msg.sender, _to, netTransfer) && (_totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(_totalTransfer, netTransfer, msg.sender);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a user transfers tokens and participates in operating jackpot \n', '    // User sets the net value of transfer without the Jackpot reserving deposit amount \n', '    function transferWithReservingNet(address _to, uint _netTransfer) public returns (bool success) {\n', '        uint totalTransfer = _netTransfer * (100 + reservingPercentage) / 100; \n', '        require(balances[msg.sender] >= totalTransfer && (totalTransfer > _netTransfer));\n', '        \n', '        if (transferMain(msg.sender, _to, _netTransfer) && (totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(totalTransfer, _netTransfer, msg.sender);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a spender transfers tokens and make an owner of funds a participant of the operating Jackpot \n', '    // User sets the total transfer amount that includes the Jackpot reserving deposit\n', '    function transferFromWithReserving(address _from, address _to, uint _totalTransfer) public returns (bool success) {\n', '        uint netTransfer = _totalTransfer * (100 - reservingPercentage) / 100; \n', '        require(balances[_from] >= _totalTransfer && (_totalTransfer > netTransfer));\n', '        \n', '        if (transferFrom(_from, _to, netTransfer) && (_totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(_totalTransfer, netTransfer, _from);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Using this function a spender transfers tokens and make an owner of funds a participatants of the operating Jackpot \n', '    // User set the net value of transfer without the Jackpot reserving deposit amount \n', '    function transferFromWithReservingNet(address _from, address _to, uint _netTransfer) public returns (bool success) {\n', '        uint totalTransfer = _netTransfer * (100 + reservingPercentage) / 100; \n', '        require(balances[_from] >= totalTransfer && (totalTransfer > _netTransfer));\n', '\n', '        if (transferFrom(_from, _to, _netTransfer) && (totalTransfer >= reservingStep)) {\n', '            processJackpotDeposit(totalTransfer, _netTransfer, _from);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Withdraw deposit of Jackpot amount and add address to Jackpot Participants List according to transaction amount\n', '    function processJackpotDeposit(uint _totalTransfer, uint _netTransfer, address _participant) private returns (bool success) {\n', '        addAddressToJackpotParticipants(_participant, _totalTransfer);\n', '\n', '        uint jackpotDeposit = _totalTransfer - _netTransfer;\n', '        balances[_participant] -= jackpotDeposit;\n', '        balances[0] += jackpotDeposit;\n', '\n', '        emit Transfer(_participant, 0, jackpotDeposit);\n', '        return true;\n', '    }\n', '\n', '    // Add address to Jackpot Participants List\n', '    function addAddressToJackpotParticipants(address _participant, uint _transactionAmount) private returns (bool success) {\n', '        uint timesToAdd = _transactionAmount / reservingStep;\n', '        \n', '        for (uint i = 0; i < timesToAdd; i++){\n', '            if(index == jackpotParticipants.length) {\n', '                jackpotParticipants.length += 1;\n', '            }\n', '            jackpotParticipants[index++] = _participant;\n', '        }\n', '\n', '        emit AddAddressToJackpotParticipants(_participant, timesToAdd);\n', '        return true;        \n', '    }\n', '    \n', '    // Distribute jackpot. For finding a winner we use random number that is produced by multiplying a previous seed  \n', '    // received from previous jackpot distribution and casted to uint last available block hash. \n', '    // Remainder from the received random number and total number of participants will give an index of a winner in the Jackpot participants list\n', '    function distributeJackpot(uint _nextSeed) public onlyOwner returns (bool success) {\n', '        assert(balances[0] >= jackpotMinimumAmount);\n', '        assert(_nextSeed > 0);\n', '\n', '        uint additionalSeed = uint(blockhash(block.number - 1));\n', '        uint rnd = 0;\n', '        \n', '        while(rnd < index) {\n', '            rnd += additionalSeed * seed;\n', '        }\n', '        \n', '        uint winner = rnd % index;\n', '        balances[jackpotParticipants[winner]] += balances[0];\n', '        emit Transfer(0, jackpotParticipants[winner], balances[0]);\n', '        balances[0] = 0;\n', '        seed = _nextSeed;\n', '\n', '        if (clearJackpotParticipantsAfterDistribution) {\n', '            clearJackpotParticipants();\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Distribute Token Sale Jackpot by minting token sale jackpot directly to 0x0 address and calling distributeJackpot function \n', '    function distributeTokenSaleJackpot(uint _nextSeed, uint _amount) public onlyOwner returns (bool success) {\n', '        require (maxAllowedManualDistribution > 0);\n', '        if (mintTokens(0, _amount) && distributeJackpot(_nextSeed)) {\n', '            maxAllowedManualDistribution--;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    /** \n', '     ====== ERC20 IMPLEMENTATION ====== \n', '     */\n', '    \n', '    // Return total supply of tokens including locked-up funds and current Jackpot deposit\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // Get the balance of the specified address\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Transfer token to a specified address   \n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        return transferMain(msg.sender, _to, _value);\n', '    }\n', '\n', '    // Transfer tokens from one address to another \n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '\n', '        if (transferMain(_from, _to, _value)){\n', '            allowed[_from][msg.sender] -= _value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Main transfer function. Checking of balances is made in calling function\n', '    function transferMain(address _from, address _to, uint _value) private returns (bool success) {\n', '        require(_to != address(0));\n', '        assert(balances[_to] + _value >= balances[_to]);\n', '        \n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Function to check the amount of tokens than an owner allowed to a spender\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '\n', '\n', '    /**\n', '     ====== LOCK-UP IMPLEMENTATION ====== \n', '     */\n', '\n', '    function unlockOwnFunds() public returns (bool success) {\n', '        return unlockFunds(msg.sender);\n', '    }\n', '\n', '    function unlockSupervisedFunds(address _from) public onlyOwner returns (bool success) {\n', '        return unlockFunds(_from);\n', '    }\n', '    \n', '    function unlockFunds(address _owner) private returns (bool success) {\n', '        require(balancesLockup[_owner].unlockTime < now && balancesLockup[_owner].amount > 0);\n', '\n', '        balances[_owner] += balancesLockup[_owner].amount;\n', '        emit Transfer(_owner, _owner, balancesLockup[_owner].amount);\n', '        balancesLockup[_owner].amount = 0;\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOfLockup(address _owner) public view returns (uint balance, uint unlockTime) {\n', '        return (balancesLockup[_owner].amount, balancesLockup[_owner].unlockTime);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     ====== TOKENS MINTING IMPLEMENTATION ====== \n', '     */\n', '\n', '    // Mint RAcoin tokens. No more than 20,000,000,000 RAC can be minted\n', '    function mintTokens(address _target, uint _mintedAmount) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '        balances[_target] += _mintedAmount;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount); \n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin locked-up tokens\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintLockupTokens(address _target, uint _mintedAmount, uint _unlockTime) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '\n', '        balancesLockup[_target].amount += _mintedAmount;\n', '        balancesLockup[_target].unlockTime = _unlockTime;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount); //TODO\n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin tokens for token sale participants and add them to Jackpot list\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintTokensWithIncludingInJackpot(address _target, uint _mintedAmount) public onlyOwner returns (bool success) {\n', '        require(maxAllowedManualDistribution > 0);\n', '        if (mintTokens(_target, _mintedAmount)) {\n', '            addAddressToJackpotParticipants(_target, _mintedAmount);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Mint RAcoin tokens and approve the passed address to spend the minted amount of tokens\n', '    // Using different types of minting functions has no effect on total limit of 20,000,000,000 RAC that can be created\n', '    function mintTokensWithApproval(address _target, uint _mintedAmount, address _spender) public onlyOwner returns (bool success) {\n', '        require(_mintedAmount <= unmintedTokens);\n', '        balances[_target] += _mintedAmount;\n', '        unmintedTokens -= _mintedAmount;\n', '        _totalSupply += _mintedAmount;\n', '        allowed[_target][_spender] += _mintedAmount;\n', '        \n', '        emit Transfer(1, _target, _mintedAmount);\n', '        return true;\n', '    }\n', '\n', '    // After firing this function no more tokens can be created  \n', '    function stopTokenMinting() public onlyOwner returns (bool success) {\n', '        unmintedTokens = 0;\n', '        return true;\n', '    }\n', '}']
