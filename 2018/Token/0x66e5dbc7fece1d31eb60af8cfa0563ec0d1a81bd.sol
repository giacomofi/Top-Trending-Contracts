['pragma solidity ^0.4.19;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  //transfer owner to another address\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    if (_newOwner != address(0)) {\n', '      owner = _newOwner;\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20Token is SafeMath {\n', '  string public name;\n', '  string public symbol;\n', '  uint256 public totalSupply;\n', '  uint8 public decimals;\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  modifier onlyPayloadSize(uint size) {   \n', '    require(msg.data.length == size + 4);\n', '    _;\n', '  }\n', '\n', '  /**\n', '    @dev send coins\n', '    throws on any error rather then return a false flag to minimize user errors\n', '\n', '    @param _to      target address\n', '    @param _value   transfer amount\n', '\n', '    @return true if the transfer was successful, false if it wasn&#39;t\n', '  */\n', '  function transfer(address _to, uint256 _value)\n', '      public\n', '      onlyPayloadSize(2 * 32)\n', '      returns (bool success)\n', '  {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    @dev an account/contract attempts to get the coins\n', '    throws on any error rather then return a false flag to minimize user errors\n', '\n', '    @param _from    source address\n', '    @param _to      target address\n', '    @param _value   transfer amount\n', '\n', '    @return true if the transfer was successful, false if it wasn&#39;t\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '  {\n', '    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function approve(address _spender, uint256 _value)\n', '    public\n', '    onlyPayloadSize(2 * 32)\n', '    returns (bool success)\n', '  {\n', '    // if the allowance isn&#39;t 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n', '    require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function balanceOf(address _holder) public constant returns (uint) {\n', '    return balances[_holder];\n', '  }\n', '}\n', '\n', 'contract BitEyeToken is ERC20Token, Ownable {\n', '\n', '  bool public distributed = false;\n', '\n', '  function BitEyeToken() public {\n', '    name = "BitEye Token";\n', '    symbol = "BEY";\n', '    decimals = 18;\n', '    totalSupply = 1000000000 * 1e18;\n', '  }\n', '\n', '  function distribute(address _bitEyeExAddr, address _operationAddr, address _airdropAddr) public onlyOwner {\n', '    require(!distributed);\n', '    distributed = true;\n', '\n', '    balances[_bitEyeExAddr] = 900000000 * 1e18;\n', '    Transfer(address(0), _bitEyeExAddr, 900000000 * 1e18);\n', '\n', '    balances[_operationAddr] = 50000000 * 1e18;\n', '    Transfer(address(0), _operationAddr, 50000000 * 1e18);\n', '\n', '    balances[_airdropAddr] = 50000000 * 1e18;\n', '    Transfer(address(0), _airdropAddr, 50000000 * 1e18);\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint256) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  //transfer owner to another address\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    if (_newOwner != address(0)) {\n', '      owner = _newOwner;\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20Token is SafeMath {\n', '  string public name;\n', '  string public symbol;\n', '  uint256 public totalSupply;\n', '  uint8 public decimals;\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  modifier onlyPayloadSize(uint size) {   \n', '    require(msg.data.length == size + 4);\n', '    _;\n', '  }\n', '\n', '  /**\n', '    @dev send coins\n', '    throws on any error rather then return a false flag to minimize user errors\n', '\n', '    @param _to      target address\n', '    @param _value   transfer amount\n', '\n', "    @return true if the transfer was successful, false if it wasn't\n", '  */\n', '  function transfer(address _to, uint256 _value)\n', '      public\n', '      onlyPayloadSize(2 * 32)\n', '      returns (bool success)\n', '  {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    @dev an account/contract attempts to get the coins\n', '    throws on any error rather then return a false flag to minimize user errors\n', '\n', '    @param _from    source address\n', '    @param _to      target address\n', '    @param _value   transfer amount\n', '\n', "    @return true if the transfer was successful, false if it wasn't\n", '  */\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public\n', '    onlyPayloadSize(3 * 32)\n', '    returns (bool success)\n', '  {\n', '    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '  function approve(address _spender, uint256 _value)\n', '    public\n', '    onlyPayloadSize(2 * 32)\n', '    returns (bool success)\n', '  {\n', "    // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n", '    require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function balanceOf(address _holder) public constant returns (uint) {\n', '    return balances[_holder];\n', '  }\n', '}\n', '\n', 'contract BitEyeToken is ERC20Token, Ownable {\n', '\n', '  bool public distributed = false;\n', '\n', '  function BitEyeToken() public {\n', '    name = "BitEye Token";\n', '    symbol = "BEY";\n', '    decimals = 18;\n', '    totalSupply = 1000000000 * 1e18;\n', '  }\n', '\n', '  function distribute(address _bitEyeExAddr, address _operationAddr, address _airdropAddr) public onlyOwner {\n', '    require(!distributed);\n', '    distributed = true;\n', '\n', '    balances[_bitEyeExAddr] = 900000000 * 1e18;\n', '    Transfer(address(0), _bitEyeExAddr, 900000000 * 1e18);\n', '\n', '    balances[_operationAddr] = 50000000 * 1e18;\n', '    Transfer(address(0), _operationAddr, 50000000 * 1e18);\n', '\n', '    balances[_airdropAddr] = 50000000 * 1e18;\n', '    Transfer(address(0), _airdropAddr, 50000000 * 1e18);\n', '  }\n', '}']
