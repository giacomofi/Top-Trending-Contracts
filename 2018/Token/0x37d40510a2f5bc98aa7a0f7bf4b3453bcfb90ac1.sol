['pragma solidity 0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract BBIToken is StandardToken {\n', '\n', '    string  public constant name    = "Beluga Banking Infrastructure Token";\n', '    string  public constant symbol  = "BBI";\n', '    uint256 public constant decimals= 18;   \n', '    \n', '    uint  public totalUsed   = 0;\n', '    uint  public etherRaised = 0;\n', '\n', '    /*\n', '    *   ICO     : 01-Mar-2018 00:00:00 GMT - 31-Mar-2018 23:59:59 GMT\n', '    */\n', '\n', '    uint public icoEndDate        = 1522540799;   // 31-Mar-2018 23:59:59 GMT  \n', '    uint constant SECONDS_IN_YEAR = 31536000;     // 365 * 24 * 60 * 60 secs\n', '\n', '    // flag for emergency stop or start \n', '    bool public halted = false;              \n', '    \n', '    uint  public etherCap               =  30000 * (10 ** uint256(decimals));  // 30,000 Ether\n', '\n', '    uint  public maxAvailableForSale    =  29800000 * (10 ** uint256(decimals));      // ( 29.8M ) \n', '    uint  public tokensPreSale          =  10200000 * (10 ** uint256(decimals));      // ( 10.2M ) \n', '    uint  public tokensTeam             =  30000000 * (10 ** uint256(decimals));      // ( 30M )\n', '    uint  public tokensCommunity        =   5000000 * (10 ** uint256(decimals));      // ( 5M )\n', '    uint  public tokensMasterNodes      =   5000000 * (10 ** uint256(decimals));      // ( 5M )\n', '    uint  public tokensBankPartners     =   5000000 * (10 ** uint256(decimals));      // ( 5M ) \n', '    uint  public tokensDataProviders    =   5000000 * (10 ** uint256(decimals));      // ( 5M )\n', '\n', '   /* \n', '   * team classification flag\n', '   * for defining the lock period \n', '   */ \n', '\n', '   uint constant teamInternal = 1;   // team and community\n', '   uint constant teamPartners = 2;   // bank partner, data providers etc\n', '   uint constant icoInvestors = 3;   // ico investors\n', '\n', '    /*  \n', '    *  Addresses  \n', '    */\n', '\n', '    address public addressETHDeposit       = 0x0D2b5B427E0Bd97c71D4DF281224540044D279E1;  \n', '    address public addressTeam             = 0x7C898F01e85a5387D58b52C6356B5AE0D5aa48ba;   \n', '    address public addressCommunity        = 0xB7218D5a1f1b304E6bD69ea35C93BA4c1379FA43;  \n', '    address public addressBankPartners     = 0xD5BC3c2894af7CB046398257df7A447F44b0CcA1;  \n', '    address public addressDataProviders    = 0x9f6fce8c014210D823FdFFA274f461BAdC279A42;  \n', '    address public addressMasterNodes      = 0x8ceA6dABB68bc9FCD6982E537A16bC9D219605b0;  \n', '    address public addressPreSale          = 0x2526082305FdB4B999340Db3D53bD2a60F674101;     \n', '    address public addressICOManager       = 0xE5B3eF1fde3761225C9976EBde8D67bb54d7Ae17;\n', '\n', '\n', '    /*\n', '    * Contract Constructor\n', '    */\n', '\n', '    function BBIToken() public {\n', '            \n', '                     totalSupply_ = 90000000 * (10 ** uint256(decimals));    // 90,000,000 - 90M;                 \n', '\n', '                     balances[addressTeam] = tokensTeam;\n', '                     balances[addressCommunity] = tokensCommunity;\n', '                     balances[addressBankPartners] = tokensBankPartners;\n', '                     balances[addressDataProviders] = tokensDataProviders;\n', '                     balances[addressMasterNodes] = tokensMasterNodes;\n', '                     balances[addressPreSale] = tokensPreSale;\n', '                     balances[addressICOManager] = maxAvailableForSale;\n', '                     \n', '                     Transfer(this, addressTeam, tokensTeam);\n', '                     Transfer(this, addressCommunity, tokensCommunity);\n', '                     Transfer(this, addressBankPartners, tokensBankPartners);\n', '                     Transfer(this, addressDataProviders, tokensDataProviders);\n', '                     Transfer(this, addressMasterNodes, tokensMasterNodes);\n', '                     Transfer(this, addressPreSale, tokensPreSale);\n', '                     Transfer(this, addressICOManager, maxAvailableForSale);\n', '                 \n', '            }\n', '    \n', '    /*\n', '    *   Emergency Stop or Start ICO.\n', '    */\n', '\n', '    function  halt() onlyManager public{\n', '        require(msg.sender == addressICOManager);\n', '        halted = true;\n', '    }\n', '\n', '    function  unhalt() onlyManager public {\n', '        require(msg.sender == addressICOManager);\n', '        halted = false;\n', '    }\n', '\n', '    /*\n', '    *   Check whether ICO running or not.\n', '    */\n', '\n', '    modifier onIcoRunning() {\n', '        // Checks, if ICO is running and has not been stopped\n', '        require( halted == false);\n', '        _;\n', '    }\n', '   \n', '    modifier onIcoStopped() {\n', '        // Checks if ICO was stopped or deadline is reached\n', '      require( halted == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        // only ICO manager can do this action\n', '        require(msg.sender == addressICOManager);\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * ERC 20 Standard Token interface transfer function\n', '     * Prevent transfers until ICO period is over.\n', '     * \n', '     * Transfer \n', '     *    - Allow 50% after six months for Community and Team\n', '     *    - Allow all including (Dataproviders, MasterNodes, Bank) after one year\n', '     *    - Allow Investors after ICO end date \n', '     */\n', '\n', '\n', '   function transfer(address _to, uint256 _value) public returns (bool success) \n', '    {\n', '           if ( msg.sender == addressICOManager) { return super.transfer(_to, _value); }           \n', '\n', '           // Team can transfer upto 50% of tokens after six months of ICO end date \n', '           if ( !halted &&  msg.sender == addressTeam &&  SafeMath.sub(balances[msg.sender], _value) >= tokensTeam/2 && (now > icoEndDate + SECONDS_IN_YEAR/2) ) \n', '                { return super.transfer(_to, _value); }         \n', '\n', '           // Community can transfer upto 50% of tokens after six months of ICO end date\n', '           if ( !halted &&  msg.sender == addressCommunity &&  SafeMath.sub(balances[msg.sender], _value) >= tokensCommunity/2 && (now > icoEndDate + SECONDS_IN_YEAR/2) )\n', '                { return super.transfer(_to, _value); }            \n', '           \n', '           // ICO investors can transfer after the ICO period\n', '           if ( !halted && identifyAddress(msg.sender) == icoInvestors && now > icoEndDate ) { return super.transfer(_to, _value); }\n', '           \n', '           // All can transfer after a year from ICO end date \n', '           if ( !halted && now > icoEndDate + SECONDS_IN_YEAR) { return super.transfer(_to, _value); }\n', '\n', '        return false;\n', '         \n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) \n', '    {\n', '           if ( msg.sender == addressICOManager) { return super.transferFrom(_from,_to, _value); }\n', '\n', '           // Team can transfer upto 50% of tokens after six months of ICO end date \n', '           if ( !halted &&  msg.sender == addressTeam &&  SafeMath.sub(balances[msg.sender], _value) >= tokensTeam/2 && (now > icoEndDate + SECONDS_IN_YEAR/2) ) \n', '                { return super.transferFrom(_from,_to, _value); }\n', '           \n', '           // Community can transfer upto 50% of tokens after six months of ICO end date\n', '           if ( !halted &&  msg.sender == addressCommunity &&  SafeMath.sub(balances[msg.sender], _value) >= tokensCommunity/2 && (now > icoEndDate + SECONDS_IN_YEAR/2)) \n', '                { return super.transferFrom(_from,_to, _value); }      \n', '\n', '           // ICO investors can transfer after the ICO period\n', '           if ( !halted && identifyAddress(msg.sender) == icoInvestors && now > icoEndDate ) { return super.transferFrom(_from,_to, _value); }\n', '\n', '           // All can transfer after a year from ICO end date \n', '           if ( !halted && now > icoEndDate + SECONDS_IN_YEAR) { return super.transferFrom(_from,_to, _value); }\n', '\n', '        return false;\n', '    }\n', '\n', '   function identifyAddress(address _buyer) constant public returns(uint) {\n', '        if (_buyer == addressTeam || _buyer == addressCommunity) return teamInternal;\n', '        if (_buyer == addressMasterNodes || _buyer == addressBankPartners || _buyer == addressDataProviders) return teamPartners;\n', '             return icoInvestors;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     * Remove _value tokens from the system irreversibly\n', '     */\n', '\n', '    function  burn(uint256 _value)  onlyManager public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough BBI\n', '        balances[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply_ -= _value;                    // Updates totalSupply\n', '        return true;\n', '    }\n', '\n', '\n', '    /*  \n', '     *  main function for receiving the ETH from the investors \n', '     *  and transferring tokens after calculating the price \n', '     */    \n', '    \n', '    function buyBBITokens(address _buyer, uint256 _value) internal  {\n', '            // prevent transfer to 0x0 address\n', '            require(_buyer != 0x0);\n', '\n', '            // msg value should be more than 0\n', '            require(_value > 0);\n', '\n', '            // if not halted\n', '            require(!halted);\n', '\n', '            // Now is before ICO end date \n', '            require(now < icoEndDate);\n', '\n', '            // total tokens is price (1ETH = 960 tokens) multiplied by the ether value provided \n', '            uint tokens = (SafeMath.mul(_value, 960));\n', '\n', '            // total used + tokens should be less than maximum available for sale\n', '            require(SafeMath.add(totalUsed, tokens) < balances[addressICOManager]);\n', '\n', '            // Ether raised + new value should be less than the Ether cap\n', '            require(SafeMath.add(etherRaised, _value) < etherCap);\n', '            \n', '            balances[_buyer] = SafeMath.add( balances[_buyer], tokens);\n', '            balances[addressICOManager] = SafeMath.sub(balances[addressICOManager], tokens);\n', '            totalUsed += tokens;            \n', '            etherRaised += _value;  \n', '      \n', '            addressETHDeposit.transfer(_value);\n', '            Transfer(this, _buyer, tokens );\n', '        }\n', '\n', '     /*\n', '     *  default fall back function      \n', '     */\n', '    function () payable onIcoRunning public {\n', '                buyBBITokens(msg.sender, msg.value);           \n', '            }\n', '}']