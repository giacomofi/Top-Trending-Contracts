['pragma solidity ^0.4.23;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSStop is DSNote, DSAuth {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require(!stopped);\n', '        _;\n', '    }\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint wad\n', '    ) public returns (bool);\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract DSTokenBase is ERC20, DSMath {\n', '    uint256                                            _supply;\n', '    mapping (address => uint256)                       _balances;\n', '    mapping (address => mapping (address => uint256))  _approvals;\n', '\n', '    constructor(uint supply) public {\n', '        _balances[msg.sender] = supply;\n', '        _supply = supply;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _supply;\n', '    }\n', '    function balanceOf(address src) public view returns (uint) {\n', '        return _balances[src];\n', '    }\n', '    function allowance(address src, address guy) public view returns (uint) {\n', '        return _approvals[src][guy];\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender) {\n', '            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        }\n', '\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        _approvals[msg.sender][guy] = wad;\n', '\n', '        emit Approval(msg.sender, guy, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract DSToken is DSTokenBase(0), DSStop {\n', '\n', '    bytes32  public  symbol;\n', '    uint256  public  decimals = 18; // standard token precision. override to customize\n', '\n', '    constructor(bytes32 symbol_) public {\n', '        symbol = symbol_;\n', '    }\n', '\n', '    event Mint(address indexed guy, uint wad);\n', '    event Burn(address indexed guy, uint wad);\n', '\n', '    function approve(address guy) public stoppable returns (bool) {\n', '        return super.approve(guy, uint(-1));\n', '    }\n', '\n', '    function approve(address guy, uint wad) public stoppable returns (bool) {\n', '        return super.approve(guy, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        stoppable\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n', '            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        }\n', '\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function push(address dst, uint wad) public {\n', '        transferFrom(msg.sender, dst, wad);\n', '    }\n', '    function pull(address src, uint wad) public {\n', '        transferFrom(src, msg.sender, wad);\n', '    }\n', '    function move(address src, address dst, uint wad) public {\n', '        transferFrom(src, dst, wad);\n', '    }\n', '\n', '    function mint(uint wad) public {\n', '        mint(msg.sender, wad);\n', '    }\n', '    function burn(uint wad) public {\n', '        burn(msg.sender, wad);\n', '    }\n', '    function mint(address guy, uint wad) public auth stoppable {\n', '        _balances[guy] = add(_balances[guy], wad);\n', '        _supply = add(_supply, wad);\n', '        emit Mint(guy, wad);\n', '    }\n', '    function burn(address guy, uint wad) public auth stoppable {\n', '        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n', '            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n', '        }\n', '\n', '        _balances[guy] = sub(_balances[guy], wad);\n', '        _supply = sub(_supply, wad);\n', '        emit Burn(guy, wad);\n', '    }\n', '\n', '    // Optional token name\n', '    bytes32   public  name = "";\n', '\n', '    function setName(bytes32 name_) public auth {\n', '        name = name_;\n', '    }\n', '}\n', '\n', '/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\n', 'interface ERC223ReceivingContract {\n', '\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @param _data Data containig a function signature and/or parameters\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '\n', '\n', '    /// @dev For ERC20 backward compatibility, same with above tokenFallback but without data.\n', '    /// The function execution could fail, but do not influence the token transfer.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    //  function tokenFallback(address _from, uint256 _value) public;\n', '}\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '    /// @param _owner The address that sent the ether to create tokens\n', '    /// @return True if the ether is accepted, false if it throws\n', '    function proxyPayment(address _owner) payable public returns (bool);\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param _from The origin of the transfer\n', '    /// @param _to The destination of the transfer\n', '    /// @param _amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '    function onTransfer(address _from, address _to, uint _amount) public returns (bool);\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param _owner The address that calls `approve()`\n', '    /// @param _spender The spender in the `approve()` call\n', '    /// @param _amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract Controlled {\n', '    /// @notice The address of the controller is the only address that can call\n', '    ///  a function with this modifier\n', '    modifier onlyController { if (msg.sender != controller) throw; _; }\n', '\n', '    address public controller;\n', '\n', '    constructor() public { controller = msg.sender;}\n', '\n', '    /// @notice Changes the controller of the contract\n', '    /// @param _newController The new controller of the contract\n', '    function changeController(address _newController) onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', 'interface ERC223 {\n', '    function transfer(address to, uint amount, bytes data) public returns (bool ok);\n', '\n', '    function transferFrom(address from, address to, uint256 amount, bytes data) public returns (bool ok);\n', '\n', '    event ERC223Transfer(address indexed from, address indexed to, uint amount, bytes data);\n', '\n', '    event ReceivingContractTokenFallbackFailed(address indexed from, address indexed to, uint amount);\n', '}\n', '\n', 'contract RING is DSToken("RING"), ERC223, Controlled {\n', '\n', '    constructor() public {\n', '        setName("Evolution Land Global Token");\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n', '    ///  is approved by `_from`\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        // Alerts the token controller of the transfer\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n', '               throw;\n', '        }\n', '\n', '        success = super.transferFrom(_from, _to, _amount);\n', '\n', '        if (success && isContract(_to))\n', '        {\n', '            // ERC20 backward compatiability\n', '            if(!_to.call(bytes4(keccak256("tokenFallback(address,uint256)")), _from, _amount)) {\n', '                // do nothing when error in call in case that the _to contract is not inherited from ERC223ReceivingContract\n', '                // revert();\n', '                // bytes memory empty;\n', '\n', '                emit ReceivingContractTokenFallbackFailed(_from, _to, _amount);\n', '\n', '                // Even the fallback failed if there is such one, the transfer will not be revert since "revert()" is not called.\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * ERC 223\n', '     * Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _amount, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        // Alerts the token controller of the transfer\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n', '               throw;\n', '        }\n', '\n', '        require(super.transferFrom(_from, _to, _amount));\n', '\n', '        if (isContract(_to)) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(_from, _amount, _data);\n', '        }\n', '\n', '        emit ERC223Transfer(_from, _to, _amount, _data);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * ERC 223\n', '     * Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     * https://github.com/ethereum/EIPs/issues/223\n', '     * function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n', '     */\n', '    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\n', '    /// tokenFallback if sender is a contract.\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _amount Number of tokens to transfer.\n', '    /// @param _data Data to be sent to tokenFallback\n', '    /// @return Returns success of function call.\n', '    function transfer(\n', '        address _to,\n', '        uint256 _amount,\n', '        bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        return transferFrom(msg.sender, _to, _amount, _data);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n', '    ///  its behalf. This is a modified version of the ERC20 approve function\n', '    ///  to be a little bit safer\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        // Alerts the token controller of the approve function call\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\n', '                throw;\n', '        }\n', '        \n', '        return super.approve(_spender, _amount);\n', '    }\n', '\n', '    function mint(address _guy, uint _wad) auth stoppable {\n', '        super.mint(_guy, _wad);\n', '\n', '        emit Transfer(0, _guy, _wad);\n', '    }\n', '    function burn(address _guy, uint _wad) auth stoppable {\n', '        super.burn(_guy, _wad);\n', '\n', '        emit Transfer(_guy, 0, _wad);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) returns (bool success) {\n', '        if (!approve(_spender, _amount)) throw;\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Internal function to determine if an address is a contract\n', '    /// @param _addr The address being queried\n', '    /// @return True if `_addr` is a contract\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', '    /// @notice The fallback function: If the contract&#39;s controller has not been\n', '    ///  set to 0, then the `proxyPayment` method is called which relays the\n', '    ///  ether and creates tokens as described in the token controller contract\n', '    function ()  payable {\n', '        if (isContract(controller)) {\n', '            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\n', '                throw;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) onlyController {\n', '        if (_token == 0x0) {\n', '            controller.transfer(address(this).balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '\n', '        emit ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '        uint              wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSStop is DSNote, DSAuth {\n', '\n', '    bool public stopped;\n', '\n', '    modifier stoppable {\n', '        require(!stopped);\n', '        _;\n', '    }\n', '    function stop() public auth note {\n', '        stopped = true;\n', '    }\n', '    function start() public auth note {\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint wad\n', '    ) public returns (bool);\n', '}\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract DSTokenBase is ERC20, DSMath {\n', '    uint256                                            _supply;\n', '    mapping (address => uint256)                       _balances;\n', '    mapping (address => mapping (address => uint256))  _approvals;\n', '\n', '    constructor(uint supply) public {\n', '        _balances[msg.sender] = supply;\n', '        _supply = supply;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _supply;\n', '    }\n', '    function balanceOf(address src) public view returns (uint) {\n', '        return _balances[src];\n', '    }\n', '    function allowance(address src, address guy) public view returns (uint) {\n', '        return _approvals[src][guy];\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender) {\n', '            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        }\n', '\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        _approvals[msg.sender][guy] = wad;\n', '\n', '        emit Approval(msg.sender, guy, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract DSToken is DSTokenBase(0), DSStop {\n', '\n', '    bytes32  public  symbol;\n', '    uint256  public  decimals = 18; // standard token precision. override to customize\n', '\n', '    constructor(bytes32 symbol_) public {\n', '        symbol = symbol_;\n', '    }\n', '\n', '    event Mint(address indexed guy, uint wad);\n', '    event Burn(address indexed guy, uint wad);\n', '\n', '    function approve(address guy) public stoppable returns (bool) {\n', '        return super.approve(guy, uint(-1));\n', '    }\n', '\n', '    function approve(address guy, uint wad) public stoppable returns (bool) {\n', '        return super.approve(guy, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        stoppable\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\n', '            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        }\n', '\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function push(address dst, uint wad) public {\n', '        transferFrom(msg.sender, dst, wad);\n', '    }\n', '    function pull(address src, uint wad) public {\n', '        transferFrom(src, msg.sender, wad);\n', '    }\n', '    function move(address src, address dst, uint wad) public {\n', '        transferFrom(src, dst, wad);\n', '    }\n', '\n', '    function mint(uint wad) public {\n', '        mint(msg.sender, wad);\n', '    }\n', '    function burn(uint wad) public {\n', '        burn(msg.sender, wad);\n', '    }\n', '    function mint(address guy, uint wad) public auth stoppable {\n', '        _balances[guy] = add(_balances[guy], wad);\n', '        _supply = add(_supply, wad);\n', '        emit Mint(guy, wad);\n', '    }\n', '    function burn(address guy, uint wad) public auth stoppable {\n', '        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\n', '            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\n', '        }\n', '\n', '        _balances[guy] = sub(_balances[guy], wad);\n', '        _supply = sub(_supply, wad);\n', '        emit Burn(guy, wad);\n', '    }\n', '\n', '    // Optional token name\n', '    bytes32   public  name = "";\n', '\n', '    function setName(bytes32 name_) public auth {\n', '        name = name_;\n', '    }\n', '}\n', '\n', '/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\n', 'interface ERC223ReceivingContract {\n', '\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @param _data Data containig a function signature and/or parameters\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '\n', '\n', '    /// @dev For ERC20 backward compatibility, same with above tokenFallback but without data.\n', '    /// The function execution could fail, but do not influence the token transfer.\n', '    /// @param _from Transaction initiator, analogue of msg.sender\n', '    /// @param _value Number of tokens to transfer.\n', '    //  function tokenFallback(address _from, uint256 _value) public;\n', '}\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '    /// @param _owner The address that sent the ether to create tokens\n', '    /// @return True if the ether is accepted, false if it throws\n', '    function proxyPayment(address _owner) payable public returns (bool);\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param _from The origin of the transfer\n', '    /// @param _to The destination of the transfer\n', '    /// @param _amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '    function onTransfer(address _from, address _to, uint _amount) public returns (bool);\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param _owner The address that calls `approve()`\n', '    /// @param _spender The spender in the `approve()` call\n', '    /// @param _amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns (bool);\n', '}\n', '\n', '\n', 'contract Controlled {\n', '    /// @notice The address of the controller is the only address that can call\n', '    ///  a function with this modifier\n', '    modifier onlyController { if (msg.sender != controller) throw; _; }\n', '\n', '    address public controller;\n', '\n', '    constructor() public { controller = msg.sender;}\n', '\n', '    /// @notice Changes the controller of the contract\n', '    /// @param _newController The new controller of the contract\n', '    function changeController(address _newController) onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', 'interface ERC223 {\n', '    function transfer(address to, uint amount, bytes data) public returns (bool ok);\n', '\n', '    function transferFrom(address from, address to, uint256 amount, bytes data) public returns (bool ok);\n', '\n', '    event ERC223Transfer(address indexed from, address indexed to, uint amount, bytes data);\n', '\n', '    event ReceivingContractTokenFallbackFailed(address indexed from, address indexed to, uint amount);\n', '}\n', '\n', 'contract RING is DSToken("RING"), ERC223, Controlled {\n', '\n', '    constructor() public {\n', '        setName("Evolution Land Global Token");\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n', '    ///  is approved by `_from`\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        // Alerts the token controller of the transfer\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n', '               throw;\n', '        }\n', '\n', '        success = super.transferFrom(_from, _to, _amount);\n', '\n', '        if (success && isContract(_to))\n', '        {\n', '            // ERC20 backward compatiability\n', '            if(!_to.call(bytes4(keccak256("tokenFallback(address,uint256)")), _from, _amount)) {\n', '                // do nothing when error in call in case that the _to contract is not inherited from ERC223ReceivingContract\n', '                // revert();\n', '                // bytes memory empty;\n', '\n', '                emit ReceivingContractTokenFallbackFailed(_from, _to, _amount);\n', '\n', '                // Even the fallback failed if there is such one, the transfer will not be revert since "revert()" is not called.\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * ERC 223\n', '     * Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _amount, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        // Alerts the token controller of the transfer\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onTransfer(_from, _to, _amount))\n', '               throw;\n', '        }\n', '\n', '        require(super.transferFrom(_from, _to, _amount));\n', '\n', '        if (isContract(_to)) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(_from, _amount, _data);\n', '        }\n', '\n', '        emit ERC223Transfer(_from, _to, _amount, _data);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * ERC 223\n', '     * Added support for the ERC 223 "tokenFallback" method in a "transfer" function with a payload.\n', '     * https://github.com/ethereum/EIPs/issues/223\n', '     * function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\n', '     */\n', '    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\n', '    /// tokenFallback if sender is a contract.\n', '    /// @dev Function that is called when a user or another contract wants to transfer funds.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _amount Number of tokens to transfer.\n', '    /// @param _data Data to be sent to tokenFallback\n', '    /// @return Returns success of function call.\n', '    function transfer(\n', '        address _to,\n', '        uint256 _amount,\n', '        bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        return transferFrom(msg.sender, _to, _amount, _data);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n', '    ///  its behalf. This is a modified version of the ERC20 approve function\n', '    ///  to be a little bit safer\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        // Alerts the token controller of the approve function call\n', '        if (isContract(controller)) {\n', '            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\n', '                throw;\n', '        }\n', '        \n', '        return super.approve(_spender, _amount);\n', '    }\n', '\n', '    function mint(address _guy, uint _wad) auth stoppable {\n', '        super.mint(_guy, _wad);\n', '\n', '        emit Transfer(0, _guy, _wad);\n', '    }\n', '    function burn(address _guy, uint _wad) auth stoppable {\n', '        super.burn(_guy, _wad);\n', '\n', '        emit Transfer(_guy, 0, _wad);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) returns (bool success) {\n', '        if (!approve(_spender, _amount)) throw;\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Internal function to determine if an address is a contract\n', '    /// @param _addr The address being queried\n', '    /// @return True if `_addr` is a contract\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', "    /// @notice The fallback function: If the contract's controller has not been\n", '    ///  set to 0, then the `proxyPayment` method is called which relays the\n', '    ///  ether and creates tokens as described in the token controller contract\n', '    function ()  payable {\n', '        if (isContract(controller)) {\n', '            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\n', '                throw;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) onlyController {\n', '        if (_token == 0x0) {\n', '            controller.transfer(address(this).balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '\n', '        emit ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '}']
