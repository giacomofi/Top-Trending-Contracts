['pragma solidity ^0.4.18;\n', ' library SafeMath {\n', '      function add(uint a, uint b) internal pure returns (uint c) {\n', '          c = a + b;\n', '          require(c >= a);\n', '      }\n', '      function sub(uint a, uint b) internal pure returns (uint c) {\n', '          require(b <= a);\n', '          c = a - b;\n', '      }\n', '      function mul(uint a, uint b) internal pure returns (uint c) {\n', '          c = a * b;\n', '          require(a == 0 || c / a == b);\n', '      }\n', '      function div(uint a, uint b) internal pure returns (uint c) {\n', '          require(b > 0);\n', '          c = a / b;\n', '      }\n', '  }\n', ' contract STASHInterface {\n', '      function totalSupply() public constant returns (uint);\n', '      function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '      function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '      function transfer(address to, uint tokens) public returns (bool success);\n', '      function approve(address spender, uint tokens) public returns (bool success);\n', '      function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '  \n', '      event Transfer(address indexed from, address indexed to, uint tokens);\n', '      event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '  }\n', ' contract ApproveAndCallFallBack {\n', '      function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '  }\n', ' contract Owned {\n', '      address public owner;\n', '      address public newOwner;\n', '  \n', '      event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '      function Owned() public {\n', '          owner = msg.sender;\n', '      }\n', '  \n', '      modifier onlyOwner {\n', '          require(msg.sender == owner);\n', '          _;\n', '      }\n', '  \n', '      function transferOwnership(address _newOwner) public onlyOwner {\n', '          newOwner = _newOwner;\n', '      }\n', '      function acceptOwnership() public {\n', '          require(msg.sender == newOwner);\n', '          OwnershipTransferred(owner, newOwner);\n', '          owner = newOwner;\n', '          newOwner = address(0);\n', '      }\n', '  }\n', ' contract STASHToken is STASHInterface, Owned {\n', '     using SafeMath for uint;\n', ' \n', '     string public symbol;\n', '     string public  name;\n', '     uint8 public decimals;\n', '     uint public _totalSupply;\n', '     uint256 public unitsOneEthCanBuy;     \n', '     uint256 public totalEthInWei;           \n', '     address public fundsWallet;          \n', ' \n', '     mapping(address => uint) balances;\n', '     mapping(address => mapping(address => uint)) allowed;\n', ' \n', ' \n', '     function STASHToken() public {\n', '         symbol = "STASH";\n', '         name = "BitStash";\n', '         decimals = 18;\n', '         _totalSupply = 36000000000 * 10**uint(decimals);\n', '         balances[owner] = _totalSupply;\n', '         Transfer(address(0), owner, _totalSupply);\n', '         unitsOneEthCanBuy = 600000;                                     \n', '         fundsWallet = msg.sender;                                   \n', '     }\n', ' \n', '     function totalSupply() public constant returns (uint) {\n', '         return _totalSupply  - balances[address(0)];\n', '     }\n', ' \n', '     function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '         return balances[tokenOwner];\n', '     }\n', ' \n', '     function transfer(address to, uint tokens) public returns (bool success) {\n', '         balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '         balances[to] = balances[to].add(tokens);\n', '         Transfer(msg.sender, to, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function approve(address spender, uint tokens) public returns (bool success) {\n', '         allowed[msg.sender][spender] = tokens;\n', '         Approval(msg.sender, spender, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '         balances[from] = balances[from].sub(tokens);\n', '         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '         balances[to] = balances[to].add(tokens);\n', '         Transfer(from, to, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '         return allowed[tokenOwner][spender];\n', '     }\n', ' \n', '     function() payable public{\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        if (balances[fundsWallet] < amount) {\n', '            return;\n', '        }\n', '\n', '        balances[fundsWallet] = balances[fundsWallet] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        //Transfer ether to fundsWallet\n', '        fundsWallet.transfer(msg.value);                               \n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\n', '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { revert(); }\n', '        return true;\n', '    }\n', ' \n', '     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '         return STASHInterface(tokenAddress).transfer(owner, tokens);\n', '     }\n', ' }']
['pragma solidity ^0.4.18;\n', ' library SafeMath {\n', '      function add(uint a, uint b) internal pure returns (uint c) {\n', '          c = a + b;\n', '          require(c >= a);\n', '      }\n', '      function sub(uint a, uint b) internal pure returns (uint c) {\n', '          require(b <= a);\n', '          c = a - b;\n', '      }\n', '      function mul(uint a, uint b) internal pure returns (uint c) {\n', '          c = a * b;\n', '          require(a == 0 || c / a == b);\n', '      }\n', '      function div(uint a, uint b) internal pure returns (uint c) {\n', '          require(b > 0);\n', '          c = a / b;\n', '      }\n', '  }\n', ' contract STASHInterface {\n', '      function totalSupply() public constant returns (uint);\n', '      function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '      function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '      function transfer(address to, uint tokens) public returns (bool success);\n', '      function approve(address spender, uint tokens) public returns (bool success);\n', '      function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '  \n', '      event Transfer(address indexed from, address indexed to, uint tokens);\n', '      event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '  }\n', ' contract ApproveAndCallFallBack {\n', '      function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '  }\n', ' contract Owned {\n', '      address public owner;\n', '      address public newOwner;\n', '  \n', '      event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  \n', '      function Owned() public {\n', '          owner = msg.sender;\n', '      }\n', '  \n', '      modifier onlyOwner {\n', '          require(msg.sender == owner);\n', '          _;\n', '      }\n', '  \n', '      function transferOwnership(address _newOwner) public onlyOwner {\n', '          newOwner = _newOwner;\n', '      }\n', '      function acceptOwnership() public {\n', '          require(msg.sender == newOwner);\n', '          OwnershipTransferred(owner, newOwner);\n', '          owner = newOwner;\n', '          newOwner = address(0);\n', '      }\n', '  }\n', ' contract STASHToken is STASHInterface, Owned {\n', '     using SafeMath for uint;\n', ' \n', '     string public symbol;\n', '     string public  name;\n', '     uint8 public decimals;\n', '     uint public _totalSupply;\n', '     uint256 public unitsOneEthCanBuy;     \n', '     uint256 public totalEthInWei;           \n', '     address public fundsWallet;          \n', ' \n', '     mapping(address => uint) balances;\n', '     mapping(address => mapping(address => uint)) allowed;\n', ' \n', ' \n', '     function STASHToken() public {\n', '         symbol = "STASH";\n', '         name = "BitStash";\n', '         decimals = 18;\n', '         _totalSupply = 36000000000 * 10**uint(decimals);\n', '         balances[owner] = _totalSupply;\n', '         Transfer(address(0), owner, _totalSupply);\n', '         unitsOneEthCanBuy = 600000;                                     \n', '         fundsWallet = msg.sender;                                   \n', '     }\n', ' \n', '     function totalSupply() public constant returns (uint) {\n', '         return _totalSupply  - balances[address(0)];\n', '     }\n', ' \n', '     function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '         return balances[tokenOwner];\n', '     }\n', ' \n', '     function transfer(address to, uint tokens) public returns (bool success) {\n', '         balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '         balances[to] = balances[to].add(tokens);\n', '         Transfer(msg.sender, to, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function approve(address spender, uint tokens) public returns (bool success) {\n', '         allowed[msg.sender][spender] = tokens;\n', '         Approval(msg.sender, spender, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '         balances[from] = balances[from].sub(tokens);\n', '         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '         balances[to] = balances[to].add(tokens);\n', '         Transfer(from, to, tokens);\n', '         return true;\n', '     }\n', ' \n', '     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '         return allowed[tokenOwner][spender];\n', '     }\n', ' \n', '     function() payable public{\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        if (balances[fundsWallet] < amount) {\n', '            return;\n', '        }\n', '\n', '        balances[fundsWallet] = balances[fundsWallet] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        //Transfer ether to fundsWallet\n', '        fundsWallet.transfer(msg.value);                               \n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { revert(); }\n', '        return true;\n', '    }\n', ' \n', '     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '         return STASHInterface(tokenAddress).transfer(owner, tokens);\n', '     }\n', ' }']
