['pragma solidity ^0.4.19;\n', '/*\n', ' * Standard token contract with ability to hold some amount on some balances before single initially specified deadline\n', ' * Which is useful for example for holding unsold tokens for a year for next step of project management\n', ' *\n', ' * Implements initial supply and does not allow to supply more tokens later\n', ' *\n', ' */ \n', '\n', 'contract SBCE {\n', '\t/* Public variables of the token */\t\n', '\tstring public constant name = "SBC token";\n', '\tstring public constant symbol = "SBCE";\t\n', '\tuint8 public constant decimals = 8;\n', '\taddress public owner;\n', '\tuint256 public totalSupply_;\n', '\n', '\taddress public airdrop;\n', '\tuint256 public airdropAmount;\n', '\tbool public airdropConjured;\n', '\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '\tmapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\t\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\tevent Burn(address indexed from, uint256 value);\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\t\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction SBCE(uint256 initialSupply) public {\n', '\t\towner=msg.sender;\n', '\t\tbalances[owner] = initialSupply * 100000000;\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\ttotalSupply_ = initialSupply * 100000000;\t\t\t\t\t\t\t\t// Update total supply\n', '\t\tairdropAmount = totalSupply_ / 37 * 100;\n', '\t}\n', '    /*This returns total number of tokens in existence*/\n', '\tfunction totalSupply() public view returns (uint256) {\n', '    \treturn totalSupply_;\n', '  \t}\n', '\t\n', '\t/* Send coins */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\n', '    \trequire(balances[msg.sender] >=_value);\n', '\t\t\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\trequire(balances[_to] + _value >= balances[_to]);\n', '\n', '\t\tbalances[msg.sender] -= _value;\t\t\t\t\t \n', '\t\tbalances[_to] += _value;\t\t\t\t\t\n', '\t\tTransfer(msg.sender, _to, _value);\t\t\t\t  \n', '\t\treturn true;\n', '\t}\n', '\n', '\t/*This pulls the allowed tokens amount from address to another*/\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\t\t\t\t\t\t  \n', '\t\trequire(_value <= balances[_from]);\t\t\t\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\trequire(balances[_to] + _value >= balances[_to]);\t\t\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\t\t\t// Check allowance\n', '\n', '\t\tbalances[_from] -= _value;\t\t\t\t\t\t   \t\t\t// Subtract from the sender\n', '\t\tbalances[_to] += _value;\t\t\t\t\t\t\t \t\t// Add the same to the recipient\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '    \treturn balances[_owner];\n', '\t}\n', '\n', '\t/* Allow another contract to spend some tokens in your behalf. \n', '\tChanging an allowance brings the risk of double spending, when both old and new values will be used */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '    \tallowed[msg.sender][_spender] = _value;\n', '    \tApproval(msg.sender, _spender, _value);\t\t\n', '\t\treturn true;\n', '\t}\t\n', '\t\n', '\t/* This returns the amount of tokens that an owner allowed to a spender. */\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\t/* This function is used to increase the amount of tokens allowed to spend by spender.*/\n', '\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    \trequire(allowed[msg.sender][_spender] + _addedValue >= allowed[msg.sender][_spender]);\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n', '    \tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    \treturn true;\n', '  \t}\n', '\n', '\t/* This function is used to decrease the amount of tokens allowed to spend by spender.*/\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} \n', '\t\telse {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue - _subtractedValue;\n', '\t\t}\n', '\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '  \t}\n', '\n', '\tfunction burn(uint256 _value) public returns (bool) {\t\t\n', '\t\trequire(balances[msg.sender] >= _value ); \t\t\t\t\t\t\t// value > totalSupply is impossible because it means that sender balance is greater than totalSupply.\t\t\t\t\n', '\t\tbalances[msg.sender] -= _value;\t\t\t\t\t  \t\t\t\t\t// Subtract from the sender\n', '\t\ttotalSupply_ -= _value;\t\t\t\t\t\t\t\t\t\t\t\t// Updates totalSupply\n', '\t\tBurn(msg.sender, _value);\t\t\t\t\t\t\t\t\t\t\t// Fires the event about token burn\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool) {\n', '\t\trequire(balances[_from] >= _value );\t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\t\t\t\t\t// Check allowance\n', '\t\tbalances[_from] -= _value;\t\t\t\t\t\t  \t\t\t\t\t// Subtract from the sender\n', '\t\ttotalSupply_ -= _value;\t\t\t\t\t\t\t   \t\t\t\t\t// Updates totalSupply\n', '\t\tBurn(_from, _value);\t\t\t\t\t\t\t\t\t\t\t\t// Fires the event about token burn\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\tOwnershipTransferred(owner, newOwner);\n', '    \towner = newOwner;\n', '\t}\n', '\n', '\tfunction setAirdropReceiver(address _airdrop) public onlyOwner {\n', '\t\trequire(_airdrop != address(0));\n', '\t\tairdrop = _airdrop;\n', '\t}\n', '\n', '\tfunction conjureAirdrop() public onlyOwner {\t\t\t\n', '\t\trequire(totalSupply_ + airdropAmount >= balances[airdrop]);\n', '\t\trequire(airdrop != address(0));\n', '\t\tbalances[airdrop] += airdropAmount;\n', '\t\ttotalSupply_ += airdropAmount;\t\t\n', '\t}\n', '}']
['pragma solidity ^0.4.19;\n', '/*\n', ' * Standard token contract with ability to hold some amount on some balances before single initially specified deadline\n', ' * Which is useful for example for holding unsold tokens for a year for next step of project management\n', ' *\n', ' * Implements initial supply and does not allow to supply more tokens later\n', ' *\n', ' */ \n', '\n', 'contract SBCE {\n', '\t/* Public variables of the token */\t\n', '\tstring public constant name = "SBC token";\n', '\tstring public constant symbol = "SBCE";\t\n', '\tuint8 public constant decimals = 8;\n', '\taddress public owner;\n', '\tuint256 public totalSupply_;\n', '\n', '\taddress public airdrop;\n', '\tuint256 public airdropAmount;\n', '\tbool public airdropConjured;\n', '\n', '\t/* This creates an array with all balances */\n', '\tmapping (address => uint256) public balances;\n', '\tmapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\t\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\tevent Burn(address indexed from, uint256 value);\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\t\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/* Initializes contract with initial supply tokens to the creator of the contract */\n', '\tfunction SBCE(uint256 initialSupply) public {\n', '\t\towner=msg.sender;\n', '\t\tbalances[owner] = initialSupply * 100000000;\t\t\t\t\t\t\t// Give the creator all initial tokens\n', '\t\ttotalSupply_ = initialSupply * 100000000;\t\t\t\t\t\t\t\t// Update total supply\n', '\t\tairdropAmount = totalSupply_ / 37 * 100;\n', '\t}\n', '    /*This returns total number of tokens in existence*/\n', '\tfunction totalSupply() public view returns (uint256) {\n', '    \treturn totalSupply_;\n', '  \t}\n', '\t\n', '\t/* Send coins */\n', '\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\n', '    \trequire(balances[msg.sender] >=_value);\n', '\t\t\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\trequire(balances[_to] + _value >= balances[_to]);\n', '\n', '\t\tbalances[msg.sender] -= _value;\t\t\t\t\t \n', '\t\tbalances[_to] += _value;\t\t\t\t\t\n', '\t\tTransfer(msg.sender, _to, _value);\t\t\t\t  \n', '\t\treturn true;\n', '\t}\n', '\n', '\t/*This pulls the allowed tokens amount from address to another*/\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t\trequire(_to != address(0));\t\t\t\t\t\t  \n', '\t\trequire(_value <= balances[_from]);\t\t\t\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\trequire(balances[_to] + _value >= balances[_to]);\t\t\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\t\t\t// Check allowance\n', '\n', '\t\tbalances[_from] -= _value;\t\t\t\t\t\t   \t\t\t// Subtract from the sender\n', '\t\tbalances[_to] += _value;\t\t\t\t\t\t\t \t\t// Add the same to the recipient\n', '\t\tallowed[_from][msg.sender] -= _value;\n', '\t\tTransfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '    \treturn balances[_owner];\n', '\t}\n', '\n', '\t/* Allow another contract to spend some tokens in your behalf. \n', '\tChanging an allowance brings the risk of double spending, when both old and new values will be used */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n', '    \tallowed[msg.sender][_spender] = _value;\n', '    \tApproval(msg.sender, _spender, _value);\t\t\n', '\t\treturn true;\n', '\t}\t\n', '\t\n', '\t/* This returns the amount of tokens that an owner allowed to a spender. */\n', '\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\t/* This function is used to increase the amount of tokens allowed to spend by spender.*/\n', '\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    \trequire(allowed[msg.sender][_spender] + _addedValue >= allowed[msg.sender][_spender]);\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;\n', '    \tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    \treturn true;\n', '  \t}\n', '\n', '\t/* This function is used to decrease the amount of tokens allowed to spend by spender.*/\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} \n', '\t\telse {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue - _subtractedValue;\n', '\t\t}\n', '\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '  \t}\n', '\n', '\tfunction burn(uint256 _value) public returns (bool) {\t\t\n', '\t\trequire(balances[msg.sender] >= _value ); \t\t\t\t\t\t\t// value > totalSupply is impossible because it means that sender balance is greater than totalSupply.\t\t\t\t\n', '\t\tbalances[msg.sender] -= _value;\t\t\t\t\t  \t\t\t\t\t// Subtract from the sender\n', '\t\ttotalSupply_ -= _value;\t\t\t\t\t\t\t\t\t\t\t\t// Updates totalSupply\n', '\t\tBurn(msg.sender, _value);\t\t\t\t\t\t\t\t\t\t\t// Fires the event about token burn\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool) {\n', '\t\trequire(balances[_from] >= _value );\t\t\t\t\t\t\t\t// Check if the sender has enough\n', '\t\trequire(allowed[_from][msg.sender] >= _value);\t\t\t\t\t// Check allowance\n', '\t\tbalances[_from] -= _value;\t\t\t\t\t\t  \t\t\t\t\t// Subtract from the sender\n', '\t\ttotalSupply_ -= _value;\t\t\t\t\t\t\t   \t\t\t\t\t// Updates totalSupply\n', '\t\tBurn(_from, _value);\t\t\t\t\t\t\t\t\t\t\t\t// Fires the event about token burn\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\tOwnershipTransferred(owner, newOwner);\n', '    \towner = newOwner;\n', '\t}\n', '\n', '\tfunction setAirdropReceiver(address _airdrop) public onlyOwner {\n', '\t\trequire(_airdrop != address(0));\n', '\t\tairdrop = _airdrop;\n', '\t}\n', '\n', '\tfunction conjureAirdrop() public onlyOwner {\t\t\t\n', '\t\trequire(totalSupply_ + airdropAmount >= balances[airdrop]);\n', '\t\trequire(airdrop != address(0));\n', '\t\tbalances[airdrop] += airdropAmount;\n', '\t\ttotalSupply_ += airdropAmount;\t\t\n', '\t}\n', '}']
