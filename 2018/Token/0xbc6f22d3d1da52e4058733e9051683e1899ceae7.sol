['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract owned {\n', '    event TransferOwnership(address _owner, address _newOwner);\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '    event TransferByOwner(address fromAddress, address toAddress, uint tokens);\n', '    event Pause();\n', '    event Unpause();\n', '    \n', '    address public owner;\n', '    address public newOwner = 0x0;\n', '    bool public paused = false;\n', '\n', '    constructor () public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Modifier to make a function callable only when the contract is not paused.\n', '    // ------------------------------------------------------------------------\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Modifier to make a function callable only when the contract is paused.\n', '    // ------------------------------------------------------------------------\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '   \n', '    // ------------------------------------------------------------------------\n', '    // transfer owner to new address\n', '    // ------------------------------------------------------------------------\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '        emit TransferOwnership(owner, _newOwner);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // accept the ownership\n', '    // ------------------------------------------------------------------------\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '      \n', '    // ------------------------------------------------------------------------\n', '    // called by the owner to pause, triggers stopped state\n', '    // ------------------------------------------------------------------------\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // called by the owner to unpause, returns to normal state\n', '    // ------------------------------------------------------------------------\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);  \n', '}\n', '\n', 'contract  GoodsToken is ERC20Interface, owned {\n', '    using SafeMath for uint;   \n', '    string public name; \n', '    string public symbol; \n', '    uint public decimals;\n', '    uint internal maxSupply; \n', '    uint public totalSupply; \n', '    address public beneficiary;\n', '    \n', '    mapping (address => uint) public balances;\n', '    mapping(address => mapping(address => uint)) public allowed;\n', '  \n', '    constructor() public {         \n', '        name = "GoodsToken";    \n', '        symbol = "GDS";    \n', '        decimals = 18;\n', '        maxSupply = 100000000 * (10 ** decimals);   \n', '        totalSupply = maxSupply;//totalSupply.add(maxSupply);\n', '        beneficiary = msg.sender;\n', '        balances[beneficiary] = balances[beneficiary].add(totalSupply);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account tokenOwner\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to to account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address _to, uint _value) public whenNotPaused returns (bool success) {\n', '        if (balances[msg.sender] < _value) revert() ;           \n', '        if (balances[_to] + _value < balances[_to]) revert(); \n', '        balances[msg.sender] = balances[msg.sender].sub(_value); \n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);          \n', '        return true;\n', '    }\n', '    \n', '    //----------------------------------------------------------\n', '    //transfer By Owner \n', '    //----------------------------------------------------------------------------\n', '    function transferByOwner(address _from, address _to, uint _value) public onlyOwner returns (bool success) {\n', '        if (balances[_from] < _value) revert(); \n', '        if (balances[_to] + _value < balances[_to]) revert();\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value); \n', '        emit Transfer(_from, _to, _value);\n', '        emit TransferByOwner(_from, _to, _value);\n', '        return true;\n', '    }\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for spender to transferFrom(...) tokens\n', "    // from the token owner's account\n", '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public whenNotPaused returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Transfer tokens from the from account to the to account\n', '    //\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the from account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '   function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool success) {\n', '        if (balances[_from] < _value) revert();                \n', '        if (balances[_to] + _value < balances[_to]) revert(); \n', '        if (_value > allowed[_from][msg.sender]) revert(); \n', '        balances[_from] = balances[_from].sub(_value);                     \n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value); \n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();  \n', '    }  \n', '}']