['pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;imChat&#39; token contract\n', '//\n', '// Symbol      : IMC\n', '// Name        : IMC\n', '// Total supply: 1000,000,000.000000000000000000\n', '// Decimals    : 8\n', '//\n', '// imChat Technology Service Limited\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', '        assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract IMCToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    address externalContractAddress;\n', '\n', '\n', '    /**\n', '     * 构造函数\n', '     */\n', '    constructor() public {\n', '        symbol = "IMC";\n', '        name = "IMC";\n', '        decimals = 8;\n', '        _totalSupply = 1000000000 * (10 ** uint(decimals));\n', '        balances[owner] = _totalSupply;\n', '        \n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    /**\n', '     * 查询代币总发行量\n', '     * @return unit 余额\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    /**\n', '     * 查询代币余额\n', '     * @param _owner address 查询代币的地址\n', '     * @return balance 余额\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * 私有方法从一个帐户发送给另一个帐户代币\n', '     * @param _from address 发送代币的地址\n', '     * @param _to address 接受代币的地址\n', '     * @param _value uint 接受代币的数量\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal{\n', '        // 确保目标地址不为0x0，因为0x0地址代表销毁\n', '        require(_to != 0x0);\n', '        // 检查发送者是否拥有足够余额\n', '        require(balances[_from] >= _value);\n', '        // 检查是否溢出\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        // 保存数据用于后面的判断\n', '        uint previousBalance = balances[_from].add(balances[_to]);\n', '\n', '        // 从发送者减掉发送额\n', '        balances[_from] = balances[_from].sub(_value);\n', '        // 给接收者加上相同的量\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // 通知任何监听该交易的客户端\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        // 判断发送、接收方的数据是否和转换前一致\n', '        assert(balances[_from].add(balances[_to]) == previousBalance);\n', '    }\n', '\n', '    /**\n', '     * 从主帐户合约调用者发送给别人代币\n', '     * @param _to address 接受代币的地址\n', '     * @param _value uint 接受代币的数量\n', '     * @return success 交易成功\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        // _transfer(msg.sender, _to, _value);\n', '\n', '        if (msg.sender == owner) {\n', '            // ERC20合约owner调用\n', '            _transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        } else {\n', '            // 外部合约调用，需满足合约调用者和代币合约所设置的外部调用合约地址一致性\n', '            require(msg.sender == externalContractAddress);\n', '\n', '            _transfer(owner, _to, _value);\n', '\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 账号之间代币交易转移，调用过程，会检查设置的允许最大交易额\n', '     * @param _from address 发送者地址\n', '     * @param _to address 接受者地址\n', '     * @param _value uint 要转移的代币数量\n', '     * @return success 交易成功\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        \n', '        if (_from == msg.sender) {\n', '            // 自己转账时不需要approve，可以直接进行转账\n', '            _transfer(_from, _to, _value);\n', '\n', '        } else {\n', '            // 授权给第三方时，需检查发送者是否拥有足够余额\n', '            require(allowed[_from][msg.sender] >= _value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '            _transfer(_from, _to, _value);\n', '\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * 允许帐户授权其他帐户代表他们提取代币\n', '    * @param _spender 授权帐户地址\n', '    * @param _value 代币数量\n', '    * @return success 允许成功\n', '    */\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * 查询被授权帐户的允许提取的代币数\n', '    * @param _owner 授权者帐户地址\n', '    * @param _spender 被授权者帐户地址\n', '    * @return remaining 代币数量\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * 设置允许一个地址（合约）以我（创建交易者）的名义可最多花费的代币数。\n', '     * @param _spender 被授权的地址（合约）\n', '     * @param _value 最大可花费代币数\n', '     * @param _extraData 发送给合约的附加数据\n', '     * @return success 设置成功\n', '     */\n', '    function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            // 通知合约\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 设置允许外部合约地址调用当前合约\n', '     * @param _contractAddress 合约地址\n', '     * @return success 设置成功\n', '     */\n', '    function approveContractCall(address _contractAddress) public onlyOwner returns (bool){\n', '        externalContractAddress = _contractAddress;\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 不接收 Ether\n', '     */\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// 发行记录合约\n', '// ----------------------------------------------------------------------------\n', 'contract IMCIssuingRecord is Owned{\n', '    using SafeMath for uint;\n', '\n', '    // 发行记录添加日志\n', '    event IssuingRecordAdd(uint _date, bytes32 _hash, uint _depth, uint _userCount, uint _token, string _fileFormat, uint _stripLen);\n', '\n', '    // 定义IMCToken实例\n', '    IMCToken public imcToken;\n', '\n', '    // 平台账户地址\n', '    address platformAddr;\n', '\n', '    // Token发行统计记录\n', '    struct RecordInfo {\n', '        uint date;  // 记录日期（解锁ID）\n', '        bytes32 hash;  // 文件hash\n', '        uint depth; // 深度\n', '        uint userCount; // 用户数\n', '        uint token; // 发行token数量\n', '        string fileFormat; // 上链存证的文件格式\n', '        uint stripLen; // 上链存证的文件分区\n', '    }\n', '    \n', '    // 分配记录\n', '    mapping(uint => RecordInfo) public issuingRecord;\n', '    \n', '    // 用户数\n', '    uint public userCount;\n', '    \n', '    // 发行总币数\n', '    uint public totalIssuingBalance;\n', '    \n', '    /**\n', '     * 构造函数\n', '     * @param _tokenAddr address ERC20合约地址\n', '     * @param _platformAddr address 平台帐户地址\n', '     */\n', '    constructor(address _tokenAddr, address _platformAddr) public{\n', '        // 初始化IMCToken实例\n', '        imcToken = IMCToken(_tokenAddr);\n', '\n', '        // 初始化平台账户地址\n', '        platformAddr = _platformAddr;\n', '    }\n', '    \n', '    /**\n', '     * 修改platformAddr，只有owner能够修改\n', '     * @param _addr address 地址\n', '     */\n', '    function modifyPlatformAddr(address _addr) public onlyOwner {\n', '        platformAddr = _addr;\n', '    }\n', '\n', '    /**\n', '     * 转账到中间帐户\n', '     * @param _tokens uint 币数量\n', '     * @return success 交易成功\n', '     */\n', '    function sendTokenToPlatform(uint _tokens) internal returns (bool) {\n', '\n', '        imcToken.transfer(platformAddr, _tokens);\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 发行记录添加\n', '     * @param _date uint 记录日期（解锁ID）\n', '     * @param _hash bytes32 文件hash\n', '     * @param _depth uint 深度\n', '     * @param _userCount uint 用户数\n', '     * @param _token uint 发行token数量\n', '     * @param _fileFormat string 上链存证的文件格式\n', '     * @param _stripLen uint 上链存证的文件分区\n', '     * @return success 添加成功\n', '     */\n', '    function issuingRecordAdd(uint _date, bytes32 _hash, uint _depth, uint _userCount, uint _token, string _fileFormat, uint _stripLen) public onlyOwner returns (bool) {\n', '        // 防止重复记录\n', '        require(!(issuingRecord[_date].date > 0));\n', '\n', '        // 累计用户数\n', '        userCount = userCount.add(_userCount);\n', '\n', '        // 累计发行币数\n', '        totalIssuingBalance = totalIssuingBalance.add(_token);\n', '        \n', '        // 记录发行信息\n', '        issuingRecord[_date] = RecordInfo(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n', '\n', '        // 转账到中间帐户\n', '        sendTokenToPlatform(_token);\n', '\n', '        emit IssuingRecordAdd(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n', '        \n', '        return true;\n', '        \n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'imChat' token contract\n", '//\n', '// Symbol      : IMC\n', '// Name        : IMC\n', '// Total supply: 1000,000,000.000000000000000000\n', '// Decimals    : 8\n', '//\n', '// imChat Technology Service Limited\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract IMCToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    address externalContractAddress;\n', '\n', '\n', '    /**\n', '     * 构造函数\n', '     */\n', '    constructor() public {\n', '        symbol = "IMC";\n', '        name = "IMC";\n', '        decimals = 8;\n', '        _totalSupply = 1000000000 * (10 ** uint(decimals));\n', '        balances[owner] = _totalSupply;\n', '        \n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    /**\n', '     * 查询代币总发行量\n', '     * @return unit 余额\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    /**\n', '     * 查询代币余额\n', '     * @param _owner address 查询代币的地址\n', '     * @return balance 余额\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * 私有方法从一个帐户发送给另一个帐户代币\n', '     * @param _from address 发送代币的地址\n', '     * @param _to address 接受代币的地址\n', '     * @param _value uint 接受代币的数量\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal{\n', '        // 确保目标地址不为0x0，因为0x0地址代表销毁\n', '        require(_to != 0x0);\n', '        // 检查发送者是否拥有足够余额\n', '        require(balances[_from] >= _value);\n', '        // 检查是否溢出\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        // 保存数据用于后面的判断\n', '        uint previousBalance = balances[_from].add(balances[_to]);\n', '\n', '        // 从发送者减掉发送额\n', '        balances[_from] = balances[_from].sub(_value);\n', '        // 给接收者加上相同的量\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // 通知任何监听该交易的客户端\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        // 判断发送、接收方的数据是否和转换前一致\n', '        assert(balances[_from].add(balances[_to]) == previousBalance);\n', '    }\n', '\n', '    /**\n', '     * 从主帐户合约调用者发送给别人代币\n', '     * @param _to address 接受代币的地址\n', '     * @param _value uint 接受代币的数量\n', '     * @return success 交易成功\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        // _transfer(msg.sender, _to, _value);\n', '\n', '        if (msg.sender == owner) {\n', '            // ERC20合约owner调用\n', '            _transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        } else {\n', '            // 外部合约调用，需满足合约调用者和代币合约所设置的外部调用合约地址一致性\n', '            require(msg.sender == externalContractAddress);\n', '\n', '            _transfer(owner, _to, _value);\n', '\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 账号之间代币交易转移，调用过程，会检查设置的允许最大交易额\n', '     * @param _from address 发送者地址\n', '     * @param _to address 接受者地址\n', '     * @param _value uint 要转移的代币数量\n', '     * @return success 交易成功\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        \n', '        if (_from == msg.sender) {\n', '            // 自己转账时不需要approve，可以直接进行转账\n', '            _transfer(_from, _to, _value);\n', '\n', '        } else {\n', '            // 授权给第三方时，需检查发送者是否拥有足够余额\n', '            require(allowed[_from][msg.sender] >= _value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '            _transfer(_from, _to, _value);\n', '\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * 允许帐户授权其他帐户代表他们提取代币\n', '    * @param _spender 授权帐户地址\n', '    * @param _value 代币数量\n', '    * @return success 允许成功\n', '    */\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * 查询被授权帐户的允许提取的代币数\n', '    * @param _owner 授权者帐户地址\n', '    * @param _spender 被授权者帐户地址\n', '    * @return remaining 代币数量\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * 设置允许一个地址（合约）以我（创建交易者）的名义可最多花费的代币数。\n', '     * @param _spender 被授权的地址（合约）\n', '     * @param _value 最大可花费代币数\n', '     * @param _extraData 发送给合约的附加数据\n', '     * @return success 设置成功\n', '     */\n', '    function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            // 通知合约\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * 设置允许外部合约地址调用当前合约\n', '     * @param _contractAddress 合约地址\n', '     * @return success 设置成功\n', '     */\n', '    function approveContractCall(address _contractAddress) public onlyOwner returns (bool){\n', '        externalContractAddress = _contractAddress;\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 不接收 Ether\n', '     */\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// 发行记录合约\n', '// ----------------------------------------------------------------------------\n', 'contract IMCIssuingRecord is Owned{\n', '    using SafeMath for uint;\n', '\n', '    // 发行记录添加日志\n', '    event IssuingRecordAdd(uint _date, bytes32 _hash, uint _depth, uint _userCount, uint _token, string _fileFormat, uint _stripLen);\n', '\n', '    // 定义IMCToken实例\n', '    IMCToken public imcToken;\n', '\n', '    // 平台账户地址\n', '    address platformAddr;\n', '\n', '    // Token发行统计记录\n', '    struct RecordInfo {\n', '        uint date;  // 记录日期（解锁ID）\n', '        bytes32 hash;  // 文件hash\n', '        uint depth; // 深度\n', '        uint userCount; // 用户数\n', '        uint token; // 发行token数量\n', '        string fileFormat; // 上链存证的文件格式\n', '        uint stripLen; // 上链存证的文件分区\n', '    }\n', '    \n', '    // 分配记录\n', '    mapping(uint => RecordInfo) public issuingRecord;\n', '    \n', '    // 用户数\n', '    uint public userCount;\n', '    \n', '    // 发行总币数\n', '    uint public totalIssuingBalance;\n', '    \n', '    /**\n', '     * 构造函数\n', '     * @param _tokenAddr address ERC20合约地址\n', '     * @param _platformAddr address 平台帐户地址\n', '     */\n', '    constructor(address _tokenAddr, address _platformAddr) public{\n', '        // 初始化IMCToken实例\n', '        imcToken = IMCToken(_tokenAddr);\n', '\n', '        // 初始化平台账户地址\n', '        platformAddr = _platformAddr;\n', '    }\n', '    \n', '    /**\n', '     * 修改platformAddr，只有owner能够修改\n', '     * @param _addr address 地址\n', '     */\n', '    function modifyPlatformAddr(address _addr) public onlyOwner {\n', '        platformAddr = _addr;\n', '    }\n', '\n', '    /**\n', '     * 转账到中间帐户\n', '     * @param _tokens uint 币数量\n', '     * @return success 交易成功\n', '     */\n', '    function sendTokenToPlatform(uint _tokens) internal returns (bool) {\n', '\n', '        imcToken.transfer(platformAddr, _tokens);\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 发行记录添加\n', '     * @param _date uint 记录日期（解锁ID）\n', '     * @param _hash bytes32 文件hash\n', '     * @param _depth uint 深度\n', '     * @param _userCount uint 用户数\n', '     * @param _token uint 发行token数量\n', '     * @param _fileFormat string 上链存证的文件格式\n', '     * @param _stripLen uint 上链存证的文件分区\n', '     * @return success 添加成功\n', '     */\n', '    function issuingRecordAdd(uint _date, bytes32 _hash, uint _depth, uint _userCount, uint _token, string _fileFormat, uint _stripLen) public onlyOwner returns (bool) {\n', '        // 防止重复记录\n', '        require(!(issuingRecord[_date].date > 0));\n', '\n', '        // 累计用户数\n', '        userCount = userCount.add(_userCount);\n', '\n', '        // 累计发行币数\n', '        totalIssuingBalance = totalIssuingBalance.add(_token);\n', '        \n', '        // 记录发行信息\n', '        issuingRecord[_date] = RecordInfo(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n', '\n', '        // 转账到中间帐户\n', '        sendTokenToPlatform(_token);\n', '\n', '        emit IssuingRecordAdd(_date, _hash, _depth, _userCount, _token, _fileFormat, _stripLen);\n', '        \n', '        return true;\n', '        \n', '    }\n', '\n', '}']
