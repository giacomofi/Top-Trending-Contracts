['pragma solidity ^0.4.23;\n', '///////////////////////////////////////////////////\n', '//  \n', '//  `iCashweb` ICW Token Contract\n', '//\n', '//  Total Tokens: 300,000,000.000000000000000000\n', '//  Name: iCashweb\n', '//  Symbol: ICWeb\n', '//  Decimal Scheme: 18\n', '//  \n', '//  by Nishad Vadgama\n', '///////////////////////////////////////////////////\n', '\n', 'library iMath {\n', '    function mul(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract iSimpleContract {\n', '    function changeRate(\n', '        uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function startMinting(\n', '        bool status\n', '    ) \n', '    public \n', '    returns(bool);  \n', '\n', '    function changeOwnerShip(\n', '        address toWhom\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function releaseMintTokens() \n', '    public \n', '    returns(bool);\n', '\n', '    function transferMintTokens(\n', '        address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function moveMintTokens(\n', '        address from, address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function manageOperable(\n', '        address _from, bool _value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function isOperable(\n', '        address _from\n', '    ) \n', '    public \n', '    view \n', '    returns(bool);\n', '\n', '    event Release(\n', '        address indexed from, uint256 value\n', '    );\n', '\n', '    event Operable(\n', '        address indexed from, address indexed to, bool value\n', '    );\n', '}\n', 'contract iERC01Basic is iSimpleContract {\n', '    function totalSupply() \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function transfer(\n', '        address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function transferTokens()\n', '    public \n', '    payable;\n', '\n', '    event Transfer(\n', '        address indexed from, address indexed to, uint256 value\n', '    );\n', '}\n', 'contract iERC20 is iERC01Basic {\n', '    function allowance(\n', '        address owner, address spender\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function transferFrom(\n', '        address from, address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function approve(\n', '        address spender, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '    event Approval(\n', '        address indexed owner, address indexed spender, uint256 value\n', '    );\n', '}\n', 'contract ICWToken is iERC01Basic {\n', '    using iMath for uint256;\n', '    mapping(address => uint256)     balances;\n', '    mapping(address => bool)        operable;\n', '    address public                  contractModifierAddress;\n', '    uint256                         _totalSupply;\n', '    uint256                         _totalMintSupply;\n', '    uint256                         _maxMintable;\n', '    uint256                         _rate = 100;\n', '    bool                            _mintingStarted;\n', '    bool                            _minted;\n', '\n', '    uint8 public constant           decimals = 18;\n', '    uint256 public constant         INITIAL_SUPPLY = 150000000 * (10 ** uint256(decimals));\n', '\n', '    modifier onlyByOwned() \n', '    {\n', '        require(msg.sender == contractModifierAddress || operable[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    function getMinted() \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return _minted;\n', '    }\n', '\n', '    function getOwner() \n', '    public \n', '    view \n', '    returns(address) {\n', '        return contractModifierAddress;\n', '    }\n', '    \n', '    function getMintingStatus() \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return _mintingStarted;\n', '    }\n', '\n', '    function getRate() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _rate;\n', '    }\n', '\n', '    function totalSupply() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function totalMintSupply() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _totalMintSupply;\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function destroyContract() \n', '    public {\n', '        require(msg.sender == contractModifierAddress);\n', '        selfdestruct(contractModifierAddress);\n', '    }\n', '\n', '    function changeRate(\n', '        uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_value > 0);\n', '        _rate = _value;\n', '        return true;\n', '    }\n', '\n', '    function startMinting(\n', '        bool status_\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        _mintingStarted = status_;\n', '        return true;\n', '    }\n', '\n', '    function changeOwnerShip(\n', '        address _to\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        address oldOwner = contractModifierAddress;\n', '        uint256 balAmount = balances[oldOwner];\n', '        balances[_to] = balances[_to].add(balAmount);\n', '        balances[oldOwner] = 0;\n', '        contractModifierAddress = _to;\n', '        emit Transfer(oldOwner, contractModifierAddress, balAmount);\n', '        return true;\n', '    }\n', '\n', '    function releaseMintTokens() \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_minted == false);\n', '        uint256 releaseAmount = _maxMintable.sub(_totalMintSupply);\n', '        uint256 totalReleased = _totalMintSupply.add(releaseAmount);\n', '        require(_maxMintable >= totalReleased);\n', '        _totalMintSupply = _totalMintSupply.add(releaseAmount);\n', '        balances[contractModifierAddress] = balances[contractModifierAddress].add(releaseAmount);\n', '        emit Transfer(0x0, contractModifierAddress, releaseAmount);\n', '        emit Release(contractModifierAddress, releaseAmount);\n', '        return true;\n', '    }\n', '\n', '    function transferMintTokens(\n', '        address _to, uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned\n', '    returns(bool) {\n', '        uint totalToken = _totalMintSupply.add(_value);\n', '        require(_maxMintable >= totalToken);\n', '        balances[_to] = balances[_to].add(_value);\n', '        _totalMintSupply = _totalMintSupply.add(_value);\n', '        emit Transfer(0x0, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function moveMintTokens(\n', '        address _from, address _to, uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_to != _from);\n', '        require(_value <= balances[_from]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function manageOperable(\n', '        address _from, bool _value\n', '    ) \n', '    public returns(bool) {\n', '        require(msg.sender == contractModifierAddress);\n', '        operable[_from] = _value;\n', '        emit Operable(msg.sender, _from, _value);\n', '        return true;\n', '    }\n', '\n', '    function isOperable(\n', '        address _from\n', '    ) \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return operable[_from];\n', '    }\n', '\n', '    function transferTokens()\n', '    public \n', '    payable {\n', '        require(_mintingStarted == true && msg.value > 0);\n', '        uint tokens = msg.value.mul(_rate);\n', '        uint totalToken = _totalMintSupply.add(tokens);\n', '        require(_maxMintable >= totalToken);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '        _totalMintSupply = _totalMintSupply.add(tokens);\n', '        contractModifierAddress.transfer(msg.value);\n', '        emit Transfer(0x0, msg.sender, tokens);\n', '    }\n', '\n', '    function transfer(\n', '        address _to, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        require(_to != msg.sender);\n', '        require(_value <= balances[msg.sender]);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '}\n', 'contract iCashwebToken is iERC20, ICWToken {\n', '    mapping(\n', '        address => mapping(address => uint256)\n', '    ) internal _allowed;\n', '\n', '    function transferFrom(\n', '        address _from, address _to, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        require(_to != msg.sender);\n', '        require(_value <= balances[_from]);\n', '        require(_value <= _allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(\n', '        address _spender, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        _allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(\n', '        address _owner, address _spender\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender, uint _addedValue\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender, uint _subtractedValue\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        uint oldValue = _allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            _allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            _allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract iCashweb is iCashwebToken {\n', '    string public constant name = "iCashweb";\n', '    string public constant symbol = "ICWeb";\n', '    constructor() \n', '    public {\n', '        _mintingStarted = false;\n', '        _minted = false;\n', '        contractModifierAddress = msg.sender;\n', '        _totalSupply = INITIAL_SUPPLY * 2;\n', '        _maxMintable = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '    function () \n', '    public \n', '    payable {\n', '        transferTokens();\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '///////////////////////////////////////////////////\n', '//  \n', '//  `iCashweb` ICW Token Contract\n', '//\n', '//  Total Tokens: 300,000,000.000000000000000000\n', '//  Name: iCashweb\n', '//  Symbol: ICWeb\n', '//  Decimal Scheme: 18\n', '//  \n', '//  by Nishad Vadgama\n', '///////////////////////////////////////////////////\n', '\n', 'library iMath {\n', '    function mul(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint256 a, uint256 b\n', '    ) \n', '    internal \n', '    pure \n', '    returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract iSimpleContract {\n', '    function changeRate(\n', '        uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function startMinting(\n', '        bool status\n', '    ) \n', '    public \n', '    returns(bool);  \n', '\n', '    function changeOwnerShip(\n', '        address toWhom\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function releaseMintTokens() \n', '    public \n', '    returns(bool);\n', '\n', '    function transferMintTokens(\n', '        address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function moveMintTokens(\n', '        address from, address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function manageOperable(\n', '        address _from, bool _value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function isOperable(\n', '        address _from\n', '    ) \n', '    public \n', '    view \n', '    returns(bool);\n', '\n', '    event Release(\n', '        address indexed from, uint256 value\n', '    );\n', '\n', '    event Operable(\n', '        address indexed from, address indexed to, bool value\n', '    );\n', '}\n', 'contract iERC01Basic is iSimpleContract {\n', '    function totalSupply() \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function transfer(\n', '        address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function transferTokens()\n', '    public \n', '    payable;\n', '\n', '    event Transfer(\n', '        address indexed from, address indexed to, uint256 value\n', '    );\n', '}\n', 'contract iERC20 is iERC01Basic {\n', '    function allowance(\n', '        address owner, address spender\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256);\n', '\n', '    function transferFrom(\n', '        address from, address to, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '\n', '    function approve(\n', '        address spender, uint256 value\n', '    ) \n', '    public \n', '    returns(bool);\n', '    event Approval(\n', '        address indexed owner, address indexed spender, uint256 value\n', '    );\n', '}\n', 'contract ICWToken is iERC01Basic {\n', '    using iMath for uint256;\n', '    mapping(address => uint256)     balances;\n', '    mapping(address => bool)        operable;\n', '    address public                  contractModifierAddress;\n', '    uint256                         _totalSupply;\n', '    uint256                         _totalMintSupply;\n', '    uint256                         _maxMintable;\n', '    uint256                         _rate = 100;\n', '    bool                            _mintingStarted;\n', '    bool                            _minted;\n', '\n', '    uint8 public constant           decimals = 18;\n', '    uint256 public constant         INITIAL_SUPPLY = 150000000 * (10 ** uint256(decimals));\n', '\n', '    modifier onlyByOwned() \n', '    {\n', '        require(msg.sender == contractModifierAddress || operable[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    function getMinted() \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return _minted;\n', '    }\n', '\n', '    function getOwner() \n', '    public \n', '    view \n', '    returns(address) {\n', '        return contractModifierAddress;\n', '    }\n', '    \n', '    function getMintingStatus() \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return _mintingStarted;\n', '    }\n', '\n', '    function getRate() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _rate;\n', '    }\n', '\n', '    function totalSupply() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function totalMintSupply() \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _totalMintSupply;\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function destroyContract() \n', '    public {\n', '        require(msg.sender == contractModifierAddress);\n', '        selfdestruct(contractModifierAddress);\n', '    }\n', '\n', '    function changeRate(\n', '        uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_value > 0);\n', '        _rate = _value;\n', '        return true;\n', '    }\n', '\n', '    function startMinting(\n', '        bool status_\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        _mintingStarted = status_;\n', '        return true;\n', '    }\n', '\n', '    function changeOwnerShip(\n', '        address _to\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        address oldOwner = contractModifierAddress;\n', '        uint256 balAmount = balances[oldOwner];\n', '        balances[_to] = balances[_to].add(balAmount);\n', '        balances[oldOwner] = 0;\n', '        contractModifierAddress = _to;\n', '        emit Transfer(oldOwner, contractModifierAddress, balAmount);\n', '        return true;\n', '    }\n', '\n', '    function releaseMintTokens() \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_minted == false);\n', '        uint256 releaseAmount = _maxMintable.sub(_totalMintSupply);\n', '        uint256 totalReleased = _totalMintSupply.add(releaseAmount);\n', '        require(_maxMintable >= totalReleased);\n', '        _totalMintSupply = _totalMintSupply.add(releaseAmount);\n', '        balances[contractModifierAddress] = balances[contractModifierAddress].add(releaseAmount);\n', '        emit Transfer(0x0, contractModifierAddress, releaseAmount);\n', '        emit Release(contractModifierAddress, releaseAmount);\n', '        return true;\n', '    }\n', '\n', '    function transferMintTokens(\n', '        address _to, uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned\n', '    returns(bool) {\n', '        uint totalToken = _totalMintSupply.add(_value);\n', '        require(_maxMintable >= totalToken);\n', '        balances[_to] = balances[_to].add(_value);\n', '        _totalMintSupply = _totalMintSupply.add(_value);\n', '        emit Transfer(0x0, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function moveMintTokens(\n', '        address _from, address _to, uint256 _value\n', '    ) \n', '    public \n', '    onlyByOwned \n', '    returns(bool) {\n', '        require(_to != _from);\n', '        require(_value <= balances[_from]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function manageOperable(\n', '        address _from, bool _value\n', '    ) \n', '    public returns(bool) {\n', '        require(msg.sender == contractModifierAddress);\n', '        operable[_from] = _value;\n', '        emit Operable(msg.sender, _from, _value);\n', '        return true;\n', '    }\n', '\n', '    function isOperable(\n', '        address _from\n', '    ) \n', '    public \n', '    view \n', '    returns(bool) {\n', '        return operable[_from];\n', '    }\n', '\n', '    function transferTokens()\n', '    public \n', '    payable {\n', '        require(_mintingStarted == true && msg.value > 0);\n', '        uint tokens = msg.value.mul(_rate);\n', '        uint totalToken = _totalMintSupply.add(tokens);\n', '        require(_maxMintable >= totalToken);\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '        _totalMintSupply = _totalMintSupply.add(tokens);\n', '        contractModifierAddress.transfer(msg.value);\n', '        emit Transfer(0x0, msg.sender, tokens);\n', '    }\n', '\n', '    function transfer(\n', '        address _to, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        require(_to != msg.sender);\n', '        require(_value <= balances[msg.sender]);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '}\n', 'contract iCashwebToken is iERC20, ICWToken {\n', '    mapping(\n', '        address => mapping(address => uint256)\n', '    ) internal _allowed;\n', '\n', '    function transferFrom(\n', '        address _from, address _to, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        require(_to != msg.sender);\n', '        require(_value <= balances[_from]);\n', '        require(_value <= _allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(\n', '        address _spender, uint256 _value\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        _allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(\n', '        address _owner, address _spender\n', '    ) \n', '    public \n', '    view \n', '    returns(uint256) {\n', '        return _allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender, uint _addedValue\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        _allowed[msg.sender][_spender] = _allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender, uint _subtractedValue\n', '    ) \n', '    public \n', '    returns(bool) {\n', '        uint oldValue = _allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            _allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            _allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract iCashweb is iCashwebToken {\n', '    string public constant name = "iCashweb";\n', '    string public constant symbol = "ICWeb";\n', '    constructor() \n', '    public {\n', '        _mintingStarted = false;\n', '        _minted = false;\n', '        contractModifierAddress = msg.sender;\n', '        _totalSupply = INITIAL_SUPPLY * 2;\n', '        _maxMintable = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '    function () \n', '    public \n', '    payable {\n', '        transferTokens();\n', '    }\n', '}']
