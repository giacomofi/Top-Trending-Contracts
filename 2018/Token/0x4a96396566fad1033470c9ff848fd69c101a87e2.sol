['/// @title Public Token Register - Allows to register coins and get it from another contract.\n', '/// @author Global Group - <globalinvestplace@gmail.com>\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract IPublicTokenRegister {\n', '\tfunction securityReg(address _securityWallet) public;\n', '\tfunction registerCoin(string _name,string _symbol, address coinTokenContract) public;\n', '\tfunction getSymbol(string _coin) public view returns(string _symbol);\n', '\tfunction getCoinAddress(string _coin) public view returns(address _coinTokenContract);\n', '\tfunction getHexSymbol(string _coin) public view returns(bytes4 _hexSymbol);\n', '\tfunction getIsCoinReg(string _coin) public view returns(bool _isReg);\n', '\tfunction getCoinInfo(string _coin) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg);\n', '\tfunction getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg);\n', '\n', '\tevent RegisterCoin(string _coin, string _name, string _symbol, address _coinTokenContract);\n', '\tevent SecurityReg(address _securityWallet, bool isRegistered);\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract PublicTokenRegister is IPublicTokenRegister, Ownable {\n', '\tmapping(string => Coin) internal coin;\n', '\tmapping(address => bool) internal registeredSecurity;\n', '\taddress[] internal registeredCoins;\n', '\t\n', '\tmodifier onlySecurity {\n', '\t\trequire(registeredSecurity[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '    \n', '    // STRUCTS\n', '\tstruct Coin {\n', '\t\tstring symbol;\n', '\t\taddress coinTokenContract;\n', '\t\tbytes4 hexSymbol;\n', '\t\tbool isReg;\n', '\t}\n', '\n', '    function() public payable {\n', '\t\trevert();\n', '    }\n', '    \n', '    constructor() public {\n', '    }\n', '    \n', '    function registerCoin(string _name, string _symbol, address _coinTokenContract) public onlySecurity {\n', '\t\trequire(coin[_name].isReg == false);\n', '\t\tbytes4 _hexSymbol = convertStringToBytes(_name);\n', '        coin[_name] = Coin ({\n', '            symbol: _symbol,\n', '            coinTokenContract: _coinTokenContract,\n', '            hexSymbol: _hexSymbol,\n', '            isReg: true\n', '        });\n', '        registeredCoins.push(_coinTokenContract);\n', '\t\t\n', '\t\temit RegisterCoin(_name, _name, _symbol, _coinTokenContract);\n', '    }\n', '\t\n', '\tfunction removeCoin(string _name) public onlyOwner {\n', '\t\trequire(coin[_name].isReg == true);\n', '\t\tcoin[_name] = Coin({\n', '\t\t\tsymbol: "",\n', '\t\t\tcoinTokenContract: 0x0,\n', '\t\t\thexSymbol: 0x0,\n', '\t\t\tisReg: false\n', '\t\t});\n', '\t}\n', '\t\n', '\tfunction securityReg(address _securityWallet) public onlyOwner {\n', '\t\trequire(registeredSecurity[_securityWallet] == false);\n', '\t\tregisteredSecurity[_securityWallet] = true;\n', '\t\temit SecurityReg(_securityWallet, true);\n', '\t}\n', '\t\n', '\tfunction getSymbol(string _coinName) public view returns(string _symbol) {\n', '\t\treturn coin[_coinName].symbol;\n', '\t}\n', '\t\n', '\tfunction getHexSymbol(string _coinName) public view returns(bytes4 _hexSymbol) {\n', '\t\treturn coin[_coinName].hexSymbol;\n', '\t}\n', '\t\n', '   \tfunction getCoinAddress(string _coinName) public view returns(address _coinTokenContract) {\n', '\t\treturn coin[_coinName].coinTokenContract;\n', '\t}\n', '\t\n', '\tfunction getIsCoinReg(string _coinName) public view returns(bool _isCoinReg) {\n', '\t\treturn coin[_coinName].isReg;\n', '\t}\n', '\t\n', '\tfunction getCoinInfo(string _coinName) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg) {\n', '\t\treturn (getSymbol(_coinName),getCoinAddress(_coinName),getHexSymbol(_coinName),getIsCoinReg(_coinName));\n', '\t}\n', '\t\n', '\tfunction getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg) {\n', '\t\treturn registeredSecurity[_wallet];\n', '\t}\n', '\t\n', '    function convertStringToBytes(string memory source) internal pure returns (bytes4 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}']
['/// @title Public Token Register - Allows to register coins and get it from another contract.\n', '/// @author Global Group - <globalinvestplace@gmail.com>\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract IPublicTokenRegister {\n', '\tfunction securityReg(address _securityWallet) public;\n', '\tfunction registerCoin(string _name,string _symbol, address coinTokenContract) public;\n', '\tfunction getSymbol(string _coin) public view returns(string _symbol);\n', '\tfunction getCoinAddress(string _coin) public view returns(address _coinTokenContract);\n', '\tfunction getHexSymbol(string _coin) public view returns(bytes4 _hexSymbol);\n', '\tfunction getIsCoinReg(string _coin) public view returns(bool _isReg);\n', '\tfunction getCoinInfo(string _coin) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg);\n', '\tfunction getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg);\n', '\n', '\tevent RegisterCoin(string _coin, string _name, string _symbol, address _coinTokenContract);\n', '\tevent SecurityReg(address _securityWallet, bool isRegistered);\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract PublicTokenRegister is IPublicTokenRegister, Ownable {\n', '\tmapping(string => Coin) internal coin;\n', '\tmapping(address => bool) internal registeredSecurity;\n', '\taddress[] internal registeredCoins;\n', '\t\n', '\tmodifier onlySecurity {\n', '\t\trequire(registeredSecurity[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '    \n', '    // STRUCTS\n', '\tstruct Coin {\n', '\t\tstring symbol;\n', '\t\taddress coinTokenContract;\n', '\t\tbytes4 hexSymbol;\n', '\t\tbool isReg;\n', '\t}\n', '\n', '    function() public payable {\n', '\t\trevert();\n', '    }\n', '    \n', '    constructor() public {\n', '    }\n', '    \n', '    function registerCoin(string _name, string _symbol, address _coinTokenContract) public onlySecurity {\n', '\t\trequire(coin[_name].isReg == false);\n', '\t\tbytes4 _hexSymbol = convertStringToBytes(_name);\n', '        coin[_name] = Coin ({\n', '            symbol: _symbol,\n', '            coinTokenContract: _coinTokenContract,\n', '            hexSymbol: _hexSymbol,\n', '            isReg: true\n', '        });\n', '        registeredCoins.push(_coinTokenContract);\n', '\t\t\n', '\t\temit RegisterCoin(_name, _name, _symbol, _coinTokenContract);\n', '    }\n', '\t\n', '\tfunction removeCoin(string _name) public onlyOwner {\n', '\t\trequire(coin[_name].isReg == true);\n', '\t\tcoin[_name] = Coin({\n', '\t\t\tsymbol: "",\n', '\t\t\tcoinTokenContract: 0x0,\n', '\t\t\thexSymbol: 0x0,\n', '\t\t\tisReg: false\n', '\t\t});\n', '\t}\n', '\t\n', '\tfunction securityReg(address _securityWallet) public onlyOwner {\n', '\t\trequire(registeredSecurity[_securityWallet] == false);\n', '\t\tregisteredSecurity[_securityWallet] = true;\n', '\t\temit SecurityReg(_securityWallet, true);\n', '\t}\n', '\t\n', '\tfunction getSymbol(string _coinName) public view returns(string _symbol) {\n', '\t\treturn coin[_coinName].symbol;\n', '\t}\n', '\t\n', '\tfunction getHexSymbol(string _coinName) public view returns(bytes4 _hexSymbol) {\n', '\t\treturn coin[_coinName].hexSymbol;\n', '\t}\n', '\t\n', '   \tfunction getCoinAddress(string _coinName) public view returns(address _coinTokenContract) {\n', '\t\treturn coin[_coinName].coinTokenContract;\n', '\t}\n', '\t\n', '\tfunction getIsCoinReg(string _coinName) public view returns(bool _isCoinReg) {\n', '\t\treturn coin[_coinName].isReg;\n', '\t}\n', '\t\n', '\tfunction getCoinInfo(string _coinName) public view returns(string _symbol, address coinAddress, bytes4 _hexSymbol, bool _isReg) {\n', '\t\treturn (getSymbol(_coinName),getCoinAddress(_coinName),getHexSymbol(_coinName),getIsCoinReg(_coinName));\n', '\t}\n', '\t\n', '\tfunction getIsSecurityWalletReg(address _wallet) public view returns(bool _isReg) {\n', '\t\treturn registeredSecurity[_wallet];\n', '\t}\n', '\t\n', '    function convertStringToBytes(string memory source) internal pure returns (bytes4 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}']
