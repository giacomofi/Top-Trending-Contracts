['pragma solidity ^0.4.11;\n', '\n', 'contract ERC223 {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public {}\n', '}\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract EtheraffleFreeLOT is ERC223 {\n', '    using SafeMath for uint;\n', '\n', '    string    public name;\n', '    string    public symbol;\n', '    address[] public minters;\n', '    uint      public redeemed;\n', '    uint8     public decimals;\n', '    address[] public destroyers;\n', '    address   public etheraffle;\n', '    uint      public totalSupply;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => bool) public isMinter;\n', '    mapping (address => bool) public isDestroyer;\n', '\n', '\n', '    event LogMinterAddition(address newMinter, uint atTime);\n', '    event LogMinterRemoval(address minterRemoved, uint atTime);\n', '    event LogDestroyerAddition(address newDestroyer, uint atTime);\n', '    event LogDestroyerRemoval(address destroyerRemoved, uint atTime);\n', '    event LogMinting(address indexed toWhom, uint amountMinted, uint atTime);\n', '    event LogDestruction(address indexed toWhom, uint amountDestroyed, uint atTime);\n', '    event LogEtheraffleChange(address prevController, address newController, uint atTime);\n', '    event LogTransfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    /**\n', '     * @dev   Modifier function to prepend to methods rendering them only callable\n', '     *        by the Etheraffle MultiSig wallet.\n', '     */\n', '    modifier onlyEtheraffle() {\n', '        require(msg.sender == etheraffle);\n', '        _;\n', '    }\n', '    /**\n', '     * @dev   Constructor: Sets the meta data & controller for the token.\n', '     *\n', '     * @param _etheraffle   The Etheraffle multisig wallet.\n', '     * @param _amt          Amount to mint on contract creation.\n', '     */\n', '    function EtheraffleFreeLOT(address _etheraffle, uint _amt) {\n', '        name       = "Etheraffle FreeLOT";\n', '        symbol     = "FreeLOT";\n', '        etheraffle = _etheraffle;\n', '        minters.push(_etheraffle);\n', '        destroyers.push(_etheraffle);\n', '        totalSupply              = _amt;\n', '        balances[_etheraffle]    = _amt;\n', '        isMinter[_etheraffle]    = true;\n', '        isDestroyer[_etheraffle] = true;\n', '    }\n', '    /**\n', '     * ERC223 Standard functions:\n', '     *\n', '     * @dev Transfer the specified amount of FreeLOT to the specified address.\n', '     *      Invokes the tokenFallback function if the recipient is a contract.\n', '     *      The token transfer fails if the recipient is a contract but does not\n', '     *      implement the tokenFallback function.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of FreeLOT to be transferred.\n', '     * @param _data   Transaction metadata.\n', '     */\n', '    function transfer(address _to, uint _value, bytes _data) external {\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223 receiver = ERC223(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, _data);\n', '    }\n', '    /**\n', '     * @dev     Transfer the specified amount of FreeLOT to the specified address.\n', '     *          Standard function transfer similar to ERC20 transfer with no\n', '     *          _data param. Added due to backwards compatibility reasons.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of FreeLOT to be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) external {\n', '        uint codeLength;\n', '        bytes memory empty;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223 receiver = ERC223(_to);\n', '            receiver.tokenFallback(msg.sender, _value, empty);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, empty);\n', '    }\n', '    /**\n', '     * @dev     Returns balance of a queried address.\n', '     * @param _owner    The address whose balance will be returned.\n', '     * @return balance  Balance of the of the queried address.\n', '     */\n', '    function balanceOf(address _owner) constant external returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '    /**\n', '     * @dev     Allow changing of contract ownership ready for future upgrades/\n', '     *          changes in management structure.\n', '     *\n', '     * @param _new  New owner/controller address.\n', '     */\n', '    function setEtheraffle(address _new) external onlyEtheraffle {\n', '        LogEtheraffleChange(etheraffle, _new, now);\n', '        etheraffle = _new;\n', '    }\n', '    /**\n', '     * @dev     Allow addition of minters to allow future contracts to\n', '     *          use the role.\n', '     *\n', '     * @param _new  New minter address.\n', '     */\n', '    function addMinter(address _new) external onlyEtheraffle {\n', '        minters.push(_new);\n', '        isMinter[_new] = true;\n', '        LogMinterAddition(_new, now);\n', '    }\n', '    /**\n', '     * @dev     Remove a minter should they no longer require or need the\n', '     *          the privilege.\n', '     *\n', '     * @param _minter    The desired address to be removed.\n', '     */\n', '    function removeMinter(address _minter) external onlyEtheraffle {\n', '        require(isMinter[_minter]);\n', '        isMinter[_minter] = false;\n', '        for(uint i = 0; i < minters.length - 1; i++)\n', '            if(minters[i] == _minter) {\n', '                minters[i] = minters[minters.length - 1];\n', '                break;\n', '            }\n', '        minters.length--;\n', '        LogMinterRemoval(_minter, now);\n', '    }\n', '    /**\n', '     * @dev     Allow addition of a destroyer to allow future contracts to\n', '     *          use the role.\n', '     *\n', '     * @param _new  New destroyer address.\n', '     */\n', '    function addDestroyer(address _new) external onlyEtheraffle {\n', '        destroyers.push(_new);\n', '        isDestroyer[_new] = true;\n', '        LogDestroyerAddition(_new, now);\n', '    }\n', '    /**\n', '     * @dev     Remove a destroyer should they no longer require or need the\n', '     *          the privilege.\n', '     *\n', '     * @param _destroyer    The desired address to be removed.\n', '     */\n', '    function removeDestroyer(address _destroyer) external onlyEtheraffle {\n', '        require(isDestroyer[_destroyer]);\n', '        isDestroyer[_destroyer] = false;\n', '        for(uint i = 0; i < destroyers.length - 1; i++)\n', '            if(destroyers[i] == _destroyer) {\n', '                destroyers[i] = destroyers[destroyers.length - 1];\n', '                break;\n', '            }\n', '        destroyers.length--;\n', '        LogDestroyerRemoval(_destroyer, now);\n', '    }\n', '    /**\n', '     * @dev    This function mints tokens by adding tokens to the total supply\n', '     *         and assigning them to the given address.\n', '     *\n', '     * @param _to      The address recipient of the minted tokens.\n', '     * @param _amt     The amount of tokens to mint & assign.\n', '     */\n', '    function mint(address _to, uint _amt) external {\n', '        require(isMinter[msg.sender]);\n', '        totalSupply   = totalSupply.add(_amt);\n', '        balances[_to] = balances[_to].add(_amt);\n', '        LogMinting(_to, _amt, now);\n', '    }\n', '    /**\n', '     * @dev    This function destroys tokens by subtracting them from the total\n', '     *         supply and removing them from the given address. Increments the\n', '     *         redeemed variable to track the number of "used" tokens. Only\n', '     *         callable by the Etheraffle multisig or a designated destroyer.\n', '     *\n', '     * @param _from    The address from whom the token is destroyed.\n', '     * @param _amt     The amount of tokens to destroy.\n', '     */\n', '    function destroy(address _from, uint _amt) external {\n', '        require(isDestroyer[msg.sender]);\n', '        totalSupply     = totalSupply.sub(_amt);\n', '        balances[_from] = balances[_from].sub(_amt);\n', '        redeemed++;\n', '        LogDestruction(_from, _amt, now);\n', '    }\n', '    /**\n', '     * @dev   Housekeeping- called in the event this contract is no\n', '     *        longer needed. Deletes the code from the blockchain.\n', '     *        Only callable by the Etheraffle address.\n', '     */\n', '    function selfDestruct() external onlyEtheraffle {\n', '        selfdestruct(etheraffle);\n', '    }\n', '    /**\n', '     * @dev   Fallback in case of accidental ether transfer\n', '     */\n', '    function () external payable {\n', '        revert();\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract ERC223 {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public {}\n', '}\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract EtheraffleFreeLOT is ERC223 {\n', '    using SafeMath for uint;\n', '\n', '    string    public name;\n', '    string    public symbol;\n', '    address[] public minters;\n', '    uint      public redeemed;\n', '    uint8     public decimals;\n', '    address[] public destroyers;\n', '    address   public etheraffle;\n', '    uint      public totalSupply;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => bool) public isMinter;\n', '    mapping (address => bool) public isDestroyer;\n', '\n', '\n', '    event LogMinterAddition(address newMinter, uint atTime);\n', '    event LogMinterRemoval(address minterRemoved, uint atTime);\n', '    event LogDestroyerAddition(address newDestroyer, uint atTime);\n', '    event LogDestroyerRemoval(address destroyerRemoved, uint atTime);\n', '    event LogMinting(address indexed toWhom, uint amountMinted, uint atTime);\n', '    event LogDestruction(address indexed toWhom, uint amountDestroyed, uint atTime);\n', '    event LogEtheraffleChange(address prevController, address newController, uint atTime);\n', '    event LogTransfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    /**\n', '     * @dev   Modifier function to prepend to methods rendering them only callable\n', '     *        by the Etheraffle MultiSig wallet.\n', '     */\n', '    modifier onlyEtheraffle() {\n', '        require(msg.sender == etheraffle);\n', '        _;\n', '    }\n', '    /**\n', '     * @dev   Constructor: Sets the meta data & controller for the token.\n', '     *\n', '     * @param _etheraffle   The Etheraffle multisig wallet.\n', '     * @param _amt          Amount to mint on contract creation.\n', '     */\n', '    function EtheraffleFreeLOT(address _etheraffle, uint _amt) {\n', '        name       = "Etheraffle FreeLOT";\n', '        symbol     = "FreeLOT";\n', '        etheraffle = _etheraffle;\n', '        minters.push(_etheraffle);\n', '        destroyers.push(_etheraffle);\n', '        totalSupply              = _amt;\n', '        balances[_etheraffle]    = _amt;\n', '        isMinter[_etheraffle]    = true;\n', '        isDestroyer[_etheraffle] = true;\n', '    }\n', '    /**\n', '     * ERC223 Standard functions:\n', '     *\n', '     * @dev Transfer the specified amount of FreeLOT to the specified address.\n', '     *      Invokes the tokenFallback function if the recipient is a contract.\n', '     *      The token transfer fails if the recipient is a contract but does not\n', '     *      implement the tokenFallback function.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of FreeLOT to be transferred.\n', '     * @param _data   Transaction metadata.\n', '     */\n', '    function transfer(address _to, uint _value, bytes _data) external {\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223 receiver = ERC223(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, _data);\n', '    }\n', '    /**\n', '     * @dev     Transfer the specified amount of FreeLOT to the specified address.\n', '     *          Standard function transfer similar to ERC20 transfer with no\n', '     *          _data param. Added due to backwards compatibility reasons.\n', '     *\n', '     * @param _to     Receiver address.\n', '     * @param _value  Amount of FreeLOT to be transferred.\n', '     */\n', '    function transfer(address _to, uint _value) external {\n', '        uint codeLength;\n', '        bytes memory empty;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to]        = balances[_to].add(_value);\n', '        if(codeLength > 0) {\n', '            ERC223 receiver = ERC223(_to);\n', '            receiver.tokenFallback(msg.sender, _value, empty);\n', '        }\n', '        LogTransfer(msg.sender, _to, _value, empty);\n', '    }\n', '    /**\n', '     * @dev     Returns balance of a queried address.\n', '     * @param _owner    The address whose balance will be returned.\n', '     * @return balance  Balance of the of the queried address.\n', '     */\n', '    function balanceOf(address _owner) constant external returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '    /**\n', '     * @dev     Allow changing of contract ownership ready for future upgrades/\n', '     *          changes in management structure.\n', '     *\n', '     * @param _new  New owner/controller address.\n', '     */\n', '    function setEtheraffle(address _new) external onlyEtheraffle {\n', '        LogEtheraffleChange(etheraffle, _new, now);\n', '        etheraffle = _new;\n', '    }\n', '    /**\n', '     * @dev     Allow addition of minters to allow future contracts to\n', '     *          use the role.\n', '     *\n', '     * @param _new  New minter address.\n', '     */\n', '    function addMinter(address _new) external onlyEtheraffle {\n', '        minters.push(_new);\n', '        isMinter[_new] = true;\n', '        LogMinterAddition(_new, now);\n', '    }\n', '    /**\n', '     * @dev     Remove a minter should they no longer require or need the\n', '     *          the privilege.\n', '     *\n', '     * @param _minter    The desired address to be removed.\n', '     */\n', '    function removeMinter(address _minter) external onlyEtheraffle {\n', '        require(isMinter[_minter]);\n', '        isMinter[_minter] = false;\n', '        for(uint i = 0; i < minters.length - 1; i++)\n', '            if(minters[i] == _minter) {\n', '                minters[i] = minters[minters.length - 1];\n', '                break;\n', '            }\n', '        minters.length--;\n', '        LogMinterRemoval(_minter, now);\n', '    }\n', '    /**\n', '     * @dev     Allow addition of a destroyer to allow future contracts to\n', '     *          use the role.\n', '     *\n', '     * @param _new  New destroyer address.\n', '     */\n', '    function addDestroyer(address _new) external onlyEtheraffle {\n', '        destroyers.push(_new);\n', '        isDestroyer[_new] = true;\n', '        LogDestroyerAddition(_new, now);\n', '    }\n', '    /**\n', '     * @dev     Remove a destroyer should they no longer require or need the\n', '     *          the privilege.\n', '     *\n', '     * @param _destroyer    The desired address to be removed.\n', '     */\n', '    function removeDestroyer(address _destroyer) external onlyEtheraffle {\n', '        require(isDestroyer[_destroyer]);\n', '        isDestroyer[_destroyer] = false;\n', '        for(uint i = 0; i < destroyers.length - 1; i++)\n', '            if(destroyers[i] == _destroyer) {\n', '                destroyers[i] = destroyers[destroyers.length - 1];\n', '                break;\n', '            }\n', '        destroyers.length--;\n', '        LogDestroyerRemoval(_destroyer, now);\n', '    }\n', '    /**\n', '     * @dev    This function mints tokens by adding tokens to the total supply\n', '     *         and assigning them to the given address.\n', '     *\n', '     * @param _to      The address recipient of the minted tokens.\n', '     * @param _amt     The amount of tokens to mint & assign.\n', '     */\n', '    function mint(address _to, uint _amt) external {\n', '        require(isMinter[msg.sender]);\n', '        totalSupply   = totalSupply.add(_amt);\n', '        balances[_to] = balances[_to].add(_amt);\n', '        LogMinting(_to, _amt, now);\n', '    }\n', '    /**\n', '     * @dev    This function destroys tokens by subtracting them from the total\n', '     *         supply and removing them from the given address. Increments the\n', '     *         redeemed variable to track the number of "used" tokens. Only\n', '     *         callable by the Etheraffle multisig or a designated destroyer.\n', '     *\n', '     * @param _from    The address from whom the token is destroyed.\n', '     * @param _amt     The amount of tokens to destroy.\n', '     */\n', '    function destroy(address _from, uint _amt) external {\n', '        require(isDestroyer[msg.sender]);\n', '        totalSupply     = totalSupply.sub(_amt);\n', '        balances[_from] = balances[_from].sub(_amt);\n', '        redeemed++;\n', '        LogDestruction(_from, _amt, now);\n', '    }\n', '    /**\n', '     * @dev   Housekeeping- called in the event this contract is no\n', '     *        longer needed. Deletes the code from the blockchain.\n', '     *        Only callable by the Etheraffle address.\n', '     */\n', '    function selfDestruct() external onlyEtheraffle {\n', '        selfdestruct(etheraffle);\n', '    }\n', '    /**\n', '     * @dev   Fallback in case of accidental ether transfer\n', '     */\n', '    function () external payable {\n', '        revert();\n', '    }\n', '}']
