['pragma solidity ^0.4.21;\n', '\n', 'contract ERC20Interface {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '}\n', '\n', 'contract ERC20Token is ERC20Interface {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Total amount of tokens issued\n', '    uint256 internal totalTokenIssued;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalTokenIssued;\n', '    }\n', '\n', '    /* Get the account balance for an address */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Check whether an address is a contract address */\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(addr) }\n', '        return (size > 0);\n', '    }\n', '\n', '\n', '    /* Transfer the balance from owner&#39;s account to another account */\n', '    function transfer(address _to, uint256 _amount) public returns (bool) {\n', '\n', '        require(_to != address(0x0));\n', '\n', '        // Do not allow to transfer token to contract address to avoid tokens getting stuck\n', '        require(isContract(_to) == false);\n', '\n', '        // amount sent cannot exceed balance\n', '        require(balances[msg.sender] >= _amount);\n', '\n', '        \n', '        // update balances\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to]        = balances[_to].add(_amount);\n', '\n', '        // log event\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '\n', '    /* Allow _spender to withdraw from your account up to _amount */\n', '    function approve(address _spender, uint256 _amount) public returns (bool) {\n', '        \n', '        require(_spender != address(0x0));\n', '\n', '        // update allowed amount\n', '        allowed[msg.sender][_spender] = _amount;\n', '\n', '        // log event\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /* Spender of tokens transfers tokens from the owner&#39;s balance */\n', '    /* Must be pre-approved by owner */\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n', '        \n', '        require(_to != address(0x0));\n', '        \n', '        // Do not allow to transfer token to contract address to avoid tokens getting stuck\n', '        require(isContract(_to) == false);\n', '\n', '        // balance checks\n', '        require(balances[_from] >= _amount);\n', '        require(allowed[_from][msg.sender] >= _amount);\n', '\n', '        // update balances and allowed amount\n', '        balances[_from]            = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to]              = balances[_to].add(_amount);\n', '\n', '        // log event\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /* Returns the amount of tokens approved by the owner */\n', '    /* that can be transferred by spender */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        return (a / b);\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return (a - b);\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract WhiteListManager is Ownable {\n', '\n', '    // The list here will be updated by multiple separate WhiteList contracts\n', '    mapping (address => bool) public list;\n', '\n', '    function unset(address addr) public onlyOwner {\n', '\n', '        list[addr] = false;\n', '    }\n', '\n', '    function unsetMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '            \n', '            unset(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function set(address addr) public onlyOwner {\n', '\n', '        list[addr] = true;\n', '    }\n', '\n', '    function setMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '            \n', '            set(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(address addr) public view returns (bool) {\n', '\n', '        return list[addr];\n', '    }\n', '}\n', '\n', 'contract ShareToken is ERC20Token, WhiteListManager {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "ShareToken";\n', '    string public constant symbol = "SHR";\n', '    uint8  public constant decimals = 2;\n', '\n', '    address public icoContract;\n', '\n', '    // Any token amount must be multiplied by this const to reflect decimals\n', '    uint256 constant E2 = 10**2;\n', '\n', '    mapping(address => bool) public rewardTokenLocked;\n', '    bool public mainSaleTokenLocked = true;\n', '\n', '    uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; // 1,000,000,000 tokens (1 billion)\n', '    uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT  = 6666666667; // 66,666,666.67 tokens (0.066 billion)\n', '    uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT   = 33333333333; // 333,333,333.33 tokens (0.333 billion)\n', '\n', '    uint256 public airDropTokenIssuedTotal;\n', '    uint256 public bountyTokenIssuedTotal;\n', '\n', '    uint256 public constant TOKEN_SUPPLY_SEED_LIMIT      = 500000000 * E2; // 500,000,000 tokens (0.5 billion)\n', '    uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT   = 2500000000 * E2; // 2,500,000,000.00 tokens (2.5 billion)\n', '    uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT;\n', '\n', '    uint256 public seedAndPresaleTokenIssuedTotal;\n', '\n', '    uint8 private constant PRESALE_EVENT    = 0;\n', '    uint8 private constant MAINSALE_EVENT   = 1;\n', '    uint8 private constant BOUNTY_EVENT     = 2;\n', '    uint8 private constant AIRDROP_EVENT    = 3;\n', '\n', '    function ShareToken() public {\n', '\n', '        totalTokenIssued = 0;\n', '        airDropTokenIssuedTotal = 0;\n', '        bountyTokenIssuedTotal = 0;\n', '        seedAndPresaleTokenIssuedTotal = 0;\n', '        mainSaleTokenLocked = true;\n', '    }\n', '\n', '    function unlockMainSaleToken() public onlyOwner {\n', '\n', '        mainSaleTokenLocked = false;\n', '    }\n', '\n', '    function lockMainSaleToken() public onlyOwner {\n', '\n', '        mainSaleTokenLocked = true;\n', '    }\n', '\n', '    function unlockRewardToken(address addr) public onlyOwner {\n', '\n', '        rewardTokenLocked[addr] = false;\n', '    }\n', '\n', '    function unlockRewardTokenMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            unlockRewardToken(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function lockRewardToken(address addr) public onlyOwner {\n', '\n', '        rewardTokenLocked[addr] = true;\n', '    }\n', '\n', '    function lockRewardTokenMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            lockRewardToken(addrList[i]);\n', '        }\n', '    }\n', '\n', '    // Check if a given address is locked. The address can be in the whitelist or in the reward\n', '    function isLocked(address addr) public view returns (bool) {\n', '\n', '        // Main sale is running, any addr is locked\n', '        if (mainSaleTokenLocked) {\n', '            return true;\n', '        } else {\n', '\n', '            // Main sale is ended and thus any whitelist addr is unlocked\n', '            if (isWhitelisted(addr)) {\n', '                return false;\n', '            } else {\n', '                // If the addr is in the reward, it must be checked if locked\n', '                // If the addr is not in the reward, it is considered unlocked\n', '                return rewardTokenLocked[addr];\n', '            }\n', '        }\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '\n', '        return totalTokenIssued.add(seedAndPresaleTokenIssuedTotal).add(airDropTokenIssuedTotal).add(bountyTokenIssuedTotal);\n', '    }\n', '\n', '    function totalMainSaleTokenIssued() public view returns (uint256) {\n', '\n', '        return totalTokenIssued;\n', '    }\n', '\n', '    function totalMainSaleTokenLimit() public view returns (uint256) {\n', '\n', '        return TOKEN_SUPPLY_MAINSALE_LIMIT;\n', '    }\n', '\n', '    function totalPreSaleTokenIssued() public view returns (uint256) {\n', '\n', '        return seedAndPresaleTokenIssuedTotal;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '\n', '        require(isLocked(msg.sender) == false);    \n', '        require(isLocked(_to) == false);\n', '        \n', '        return super.transfer(_to, _amount);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        \n', '        require(isLocked(_from) == false);\n', '        require(isLocked(_to) == false);\n', '        \n', '        return super.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    function setIcoContract(address _icoContract) public onlyOwner {\n', '        \n', '        // Allow to set the ICO contract only once\n', '        require(icoContract == address(0));\n', '        require(_icoContract != address(0));\n', '\n', '        icoContract = _icoContract;\n', '    }\n', '\n', '    function sell(address buyer, uint256 tokens) public returns (bool success) {\n', '      \n', '        require (icoContract != address(0));\n', '        // The sell() method can only be called by the fixedly-set ICO contract\n', '        require (msg.sender == icoContract);\n', '        require (tokens > 0);\n', '        require (buyer != address(0));\n', '\n', '        // Only whitelisted address can buy tokens. Otherwise, refund\n', '        require (isWhitelisted(buyer));\n', '\n', '        require (totalTokenIssued.add(tokens) <= TOKEN_SUPPLY_MAINSALE_LIMIT);\n', '\n', '        // Register tokens issued to the buyer\n', '        balances[buyer] = balances[buyer].add(tokens);\n', '\n', '        // Update total amount of tokens issued\n', '        totalTokenIssued = totalTokenIssued.add(tokens);\n', '\n', '        emit Transfer(address(MAINSALE_EVENT), buyer, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function rewardAirdrop(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        // this check also ascertains _amount is positive\n', '        require(_amount <= TOKEN_SUPPLY_AIRDROP_LIMIT);\n', '\n', '        require(airDropTokenIssuedTotal < TOKEN_SUPPLY_AIRDROP_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_AIRDROP_LIMIT.sub(airDropTokenIssuedTotal);\n', '        if (_amount > remainingTokens) {\n', '            _amount = remainingTokens;\n', '        }\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        airDropTokenIssuedTotal = airDropTokenIssuedTotal.add(_amount);\n', '\n', '        // Lock the receiver\n', '        rewardTokenLocked[_to] = true;\n', '\n', '        emit Transfer(address(AIRDROP_EVENT), _to, _amount);\n', '    }\n', '\n', '    function rewardBounty(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        // this check also ascertains _amount is positive\n', '        require(_amount <= TOKEN_SUPPLY_BOUNTY_LIMIT);\n', '\n', '        require(bountyTokenIssuedTotal < TOKEN_SUPPLY_BOUNTY_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_BOUNTY_LIMIT.sub(bountyTokenIssuedTotal);\n', '        if (_amount > remainingTokens) {\n', '            _amount = remainingTokens;\n', '        }\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        bountyTokenIssuedTotal = bountyTokenIssuedTotal.add(_amount);\n', '\n', '        // Lock the receiver\n', '        rewardTokenLocked[_to] = true;\n', '\n', '        emit Transfer(address(BOUNTY_EVENT), _to, _amount);\n', '    }\n', '\n', '    function rewardBountyMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            rewardBounty(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '\n', '    function rewardAirdropMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            rewardAirdrop(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '\n', '    function handlePresaleToken(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        require(_amount <= TOKEN_SUPPLY_SEED_PRESALE_LIMIT);\n', '\n', '        require(seedAndPresaleTokenIssuedTotal < TOKEN_SUPPLY_SEED_PRESALE_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_SEED_PRESALE_LIMIT.sub(seedAndPresaleTokenIssuedTotal);\n', '        require (_amount <= remainingTokens);\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        seedAndPresaleTokenIssuedTotal = seedAndPresaleTokenIssuedTotal.add(_amount);\n', '\n', '        emit Transfer(address(PRESALE_EVENT), _to, _amount);\n', '\n', '        // Also add to whitelist\n', '        set(_to);\n', '    }\n', '\n', '    function handlePresaleTokenMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            handlePresaleToken(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract ERC20Interface {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _owner) public view returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '}\n', '\n', 'contract ERC20Token is ERC20Interface {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Total amount of tokens issued\n', '    uint256 internal totalTokenIssued;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalTokenIssued;\n', '    }\n', '\n', '    /* Get the account balance for an address */\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Check whether an address is a contract address */\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(addr) }\n', '        return (size > 0);\n', '    }\n', '\n', '\n', "    /* Transfer the balance from owner's account to another account */\n", '    function transfer(address _to, uint256 _amount) public returns (bool) {\n', '\n', '        require(_to != address(0x0));\n', '\n', '        // Do not allow to transfer token to contract address to avoid tokens getting stuck\n', '        require(isContract(_to) == false);\n', '\n', '        // amount sent cannot exceed balance\n', '        require(balances[msg.sender] >= _amount);\n', '\n', '        \n', '        // update balances\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to]        = balances[_to].add(_amount);\n', '\n', '        // log event\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '\n', '    /* Allow _spender to withdraw from your account up to _amount */\n', '    function approve(address _spender, uint256 _amount) public returns (bool) {\n', '        \n', '        require(_spender != address(0x0));\n', '\n', '        // update allowed amount\n', '        allowed[msg.sender][_spender] = _amount;\n', '\n', '        // log event\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', "    /* Spender of tokens transfers tokens from the owner's balance */\n", '    /* Must be pre-approved by owner */\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n', '        \n', '        require(_to != address(0x0));\n', '        \n', '        // Do not allow to transfer token to contract address to avoid tokens getting stuck\n', '        require(isContract(_to) == false);\n', '\n', '        // balance checks\n', '        require(balances[_from] >= _amount);\n', '        require(allowed[_from][msg.sender] >= _amount);\n', '\n', '        // update balances and allowed amount\n', '        balances[_from]            = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to]              = balances[_to].add(_amount);\n', '\n', '        // log event\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /* Returns the amount of tokens approved by the owner */\n', '    /* that can be transferred by spender */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        return (a / b);\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return (a - b);\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract WhiteListManager is Ownable {\n', '\n', '    // The list here will be updated by multiple separate WhiteList contracts\n', '    mapping (address => bool) public list;\n', '\n', '    function unset(address addr) public onlyOwner {\n', '\n', '        list[addr] = false;\n', '    }\n', '\n', '    function unsetMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '            \n', '            unset(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function set(address addr) public onlyOwner {\n', '\n', '        list[addr] = true;\n', '    }\n', '\n', '    function setMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '            \n', '            set(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(address addr) public view returns (bool) {\n', '\n', '        return list[addr];\n', '    }\n', '}\n', '\n', 'contract ShareToken is ERC20Token, WhiteListManager {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "ShareToken";\n', '    string public constant symbol = "SHR";\n', '    uint8  public constant decimals = 2;\n', '\n', '    address public icoContract;\n', '\n', '    // Any token amount must be multiplied by this const to reflect decimals\n', '    uint256 constant E2 = 10**2;\n', '\n', '    mapping(address => bool) public rewardTokenLocked;\n', '    bool public mainSaleTokenLocked = true;\n', '\n', '    uint256 public constant TOKEN_SUPPLY_MAINSALE_LIMIT = 1000000000 * E2; // 1,000,000,000 tokens (1 billion)\n', '    uint256 public constant TOKEN_SUPPLY_AIRDROP_LIMIT  = 6666666667; // 66,666,666.67 tokens (0.066 billion)\n', '    uint256 public constant TOKEN_SUPPLY_BOUNTY_LIMIT   = 33333333333; // 333,333,333.33 tokens (0.333 billion)\n', '\n', '    uint256 public airDropTokenIssuedTotal;\n', '    uint256 public bountyTokenIssuedTotal;\n', '\n', '    uint256 public constant TOKEN_SUPPLY_SEED_LIMIT      = 500000000 * E2; // 500,000,000 tokens (0.5 billion)\n', '    uint256 public constant TOKEN_SUPPLY_PRESALE_LIMIT   = 2500000000 * E2; // 2,500,000,000.00 tokens (2.5 billion)\n', '    uint256 public constant TOKEN_SUPPLY_SEED_PRESALE_LIMIT = TOKEN_SUPPLY_SEED_LIMIT + TOKEN_SUPPLY_PRESALE_LIMIT;\n', '\n', '    uint256 public seedAndPresaleTokenIssuedTotal;\n', '\n', '    uint8 private constant PRESALE_EVENT    = 0;\n', '    uint8 private constant MAINSALE_EVENT   = 1;\n', '    uint8 private constant BOUNTY_EVENT     = 2;\n', '    uint8 private constant AIRDROP_EVENT    = 3;\n', '\n', '    function ShareToken() public {\n', '\n', '        totalTokenIssued = 0;\n', '        airDropTokenIssuedTotal = 0;\n', '        bountyTokenIssuedTotal = 0;\n', '        seedAndPresaleTokenIssuedTotal = 0;\n', '        mainSaleTokenLocked = true;\n', '    }\n', '\n', '    function unlockMainSaleToken() public onlyOwner {\n', '\n', '        mainSaleTokenLocked = false;\n', '    }\n', '\n', '    function lockMainSaleToken() public onlyOwner {\n', '\n', '        mainSaleTokenLocked = true;\n', '    }\n', '\n', '    function unlockRewardToken(address addr) public onlyOwner {\n', '\n', '        rewardTokenLocked[addr] = false;\n', '    }\n', '\n', '    function unlockRewardTokenMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            unlockRewardToken(addrList[i]);\n', '        }\n', '    }\n', '\n', '    function lockRewardToken(address addr) public onlyOwner {\n', '\n', '        rewardTokenLocked[addr] = true;\n', '    }\n', '\n', '    function lockRewardTokenMany(address[] addrList) public onlyOwner {\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            lockRewardToken(addrList[i]);\n', '        }\n', '    }\n', '\n', '    // Check if a given address is locked. The address can be in the whitelist or in the reward\n', '    function isLocked(address addr) public view returns (bool) {\n', '\n', '        // Main sale is running, any addr is locked\n', '        if (mainSaleTokenLocked) {\n', '            return true;\n', '        } else {\n', '\n', '            // Main sale is ended and thus any whitelist addr is unlocked\n', '            if (isWhitelisted(addr)) {\n', '                return false;\n', '            } else {\n', '                // If the addr is in the reward, it must be checked if locked\n', '                // If the addr is not in the reward, it is considered unlocked\n', '                return rewardTokenLocked[addr];\n', '            }\n', '        }\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '\n', '        return totalTokenIssued.add(seedAndPresaleTokenIssuedTotal).add(airDropTokenIssuedTotal).add(bountyTokenIssuedTotal);\n', '    }\n', '\n', '    function totalMainSaleTokenIssued() public view returns (uint256) {\n', '\n', '        return totalTokenIssued;\n', '    }\n', '\n', '    function totalMainSaleTokenLimit() public view returns (uint256) {\n', '\n', '        return TOKEN_SUPPLY_MAINSALE_LIMIT;\n', '    }\n', '\n', '    function totalPreSaleTokenIssued() public view returns (uint256) {\n', '\n', '        return seedAndPresaleTokenIssuedTotal;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '\n', '        require(isLocked(msg.sender) == false);    \n', '        require(isLocked(_to) == false);\n', '        \n', '        return super.transfer(_to, _amount);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n', '        \n', '        require(isLocked(_from) == false);\n', '        require(isLocked(_to) == false);\n', '        \n', '        return super.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    function setIcoContract(address _icoContract) public onlyOwner {\n', '        \n', '        // Allow to set the ICO contract only once\n', '        require(icoContract == address(0));\n', '        require(_icoContract != address(0));\n', '\n', '        icoContract = _icoContract;\n', '    }\n', '\n', '    function sell(address buyer, uint256 tokens) public returns (bool success) {\n', '      \n', '        require (icoContract != address(0));\n', '        // The sell() method can only be called by the fixedly-set ICO contract\n', '        require (msg.sender == icoContract);\n', '        require (tokens > 0);\n', '        require (buyer != address(0));\n', '\n', '        // Only whitelisted address can buy tokens. Otherwise, refund\n', '        require (isWhitelisted(buyer));\n', '\n', '        require (totalTokenIssued.add(tokens) <= TOKEN_SUPPLY_MAINSALE_LIMIT);\n', '\n', '        // Register tokens issued to the buyer\n', '        balances[buyer] = balances[buyer].add(tokens);\n', '\n', '        // Update total amount of tokens issued\n', '        totalTokenIssued = totalTokenIssued.add(tokens);\n', '\n', '        emit Transfer(address(MAINSALE_EVENT), buyer, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function rewardAirdrop(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        // this check also ascertains _amount is positive\n', '        require(_amount <= TOKEN_SUPPLY_AIRDROP_LIMIT);\n', '\n', '        require(airDropTokenIssuedTotal < TOKEN_SUPPLY_AIRDROP_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_AIRDROP_LIMIT.sub(airDropTokenIssuedTotal);\n', '        if (_amount > remainingTokens) {\n', '            _amount = remainingTokens;\n', '        }\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        airDropTokenIssuedTotal = airDropTokenIssuedTotal.add(_amount);\n', '\n', '        // Lock the receiver\n', '        rewardTokenLocked[_to] = true;\n', '\n', '        emit Transfer(address(AIRDROP_EVENT), _to, _amount);\n', '    }\n', '\n', '    function rewardBounty(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        // this check also ascertains _amount is positive\n', '        require(_amount <= TOKEN_SUPPLY_BOUNTY_LIMIT);\n', '\n', '        require(bountyTokenIssuedTotal < TOKEN_SUPPLY_BOUNTY_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_BOUNTY_LIMIT.sub(bountyTokenIssuedTotal);\n', '        if (_amount > remainingTokens) {\n', '            _amount = remainingTokens;\n', '        }\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        bountyTokenIssuedTotal = bountyTokenIssuedTotal.add(_amount);\n', '\n', '        // Lock the receiver\n', '        rewardTokenLocked[_to] = true;\n', '\n', '        emit Transfer(address(BOUNTY_EVENT), _to, _amount);\n', '    }\n', '\n', '    function rewardBountyMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            rewardBounty(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '\n', '    function rewardAirdropMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            rewardAirdrop(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '\n', '    function handlePresaleToken(address _to, uint256 _amount) public onlyOwner {\n', '\n', '        require(_amount <= TOKEN_SUPPLY_SEED_PRESALE_LIMIT);\n', '\n', '        require(seedAndPresaleTokenIssuedTotal < TOKEN_SUPPLY_SEED_PRESALE_LIMIT);\n', '\n', '        uint256 remainingTokens = TOKEN_SUPPLY_SEED_PRESALE_LIMIT.sub(seedAndPresaleTokenIssuedTotal);\n', '        require (_amount <= remainingTokens);\n', '\n', '        // Register tokens to the receiver\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // Update total amount of tokens issued\n', '        seedAndPresaleTokenIssuedTotal = seedAndPresaleTokenIssuedTotal.add(_amount);\n', '\n', '        emit Transfer(address(PRESALE_EVENT), _to, _amount);\n', '\n', '        // Also add to whitelist\n', '        set(_to);\n', '    }\n', '\n', '    function handlePresaleTokenMany(address[] addrList, uint256[] amountList) public onlyOwner {\n', '\n', '        require(addrList.length == amountList.length);\n', '\n', '        for (uint256 i = 0; i < addrList.length; i++) {\n', '\n', '            handlePresaleToken(addrList[i], amountList[i]);\n', '        }\n', '    }\n', '}']
