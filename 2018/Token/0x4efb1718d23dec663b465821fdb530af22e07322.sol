['pragma solidity ^0.4.24;\n', '/**\n', '* @notice Block Coin Bit Token Contract\n', '* @dev ERC-223 Token Standar Compliant\n', '* Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="731212011c1d04121f07160115011200160133141e121a1f5d101c1e">[email&#160;protected]</a>\n', '*/\n', '\n', '/**\n', ' * @title SafeMath by OpenZeppelin\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a * b;\n', '      assert(a == 0 || c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a / b;\n', '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC223 Token interface\n', ' * @dev Code based on Dexaran&#39;s one on github as recommended on ERC223 discussion\n', ' */\n', '\n', 'contract ERC223Interface {\n', '\n', '  function balanceOf(address who) constant public returns (uint256);\n', '\n', '  function name() constant public returns (string _name);\n', '  function symbol() constant public returns (string _symbol);\n', '  function decimals() constant public returns (uint8 _decimals);\n', '  function totalSupply() constant public returns (uint256 _supply);\n', '\n', '  function mintToken(address _target, uint256 _mintedAmount) public returns (bool success);\n', '  function burnToken(uint256 _burnedAmount) public returns (bool success);\n', '\n', '  function transfer(address to, uint256 value) public returns (bool ok);\n', '  function transfer(address to, uint256 value, bytes data) public returns (bool ok);\n', '  function transfer(address to, uint256 value, bytes data, bytes custom_fallback) public returns (bool ok);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n', '  event Burned(address indexed _target, uint256 _value);\n', '}\n', '\n', ' contract ContractReceiver {\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', '/**\n', '* @title Admin parameters\n', '* @dev Define administration parameters for this contract\n', '*/\n', 'contract admined { //This token contract is administered\n', '    address public admin; //Admin address is public\n', '    bool public lockSupply; //Mint and Burn Lock flag\n', '\n', '    /**\n', '    * @dev Contract constructor\n', '    * define initial administrator\n', '    */\n', '    constructor() internal {\n', '        admin = msg.sender; //Set initial admin to contract creator\n', '        emit Admined(admin);\n', '    }\n', '\n', '    modifier onlyAdmin() { //A modifier to define admin-only functions\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier supplyLock() { //A modifier to lock mint and burn transactions\n', '        require(lockSupply == false);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @dev Function to set new admin address\n', '    * @param _newAdmin The address to transfer administration to\n', '    */\n', '    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered\n', '        require(_newAdmin != 0);\n', '        admin = _newAdmin;\n', '        emit TransferAdminship(admin);\n', '    }\n', '\n', '   /**\n', '    * @dev Function to set mint and burn locks\n', '    * @param _set boolean flag (true | false)\n', '    */\n', '    function setSupplyLock(bool _set) onlyAdmin public { //Only the admin can set a lock on supply\n', '        lockSupply = _set;\n', '        emit SetSupplyLock(_set);\n', '    }\n', '\n', '    //All admin actions have a log for public review\n', '    event SetSupplyLock(bool _set);\n', '    event TransferAdminship(address newAdminister);\n', '    event Admined(address administer);\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC223 Token definition\n', ' * @dev Code based on Dexaran&#39;s one on github as recommended on ERC223 discussion\n', ' */\n', '\n', 'contract ERC223Token is admined,ERC223Interface {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  string public name    = "Block Coin Bit";\n', '  string public symbol  = "BLCB";\n', '  uint8 public decimals = 8;\n', '  uint256 public totalSupply;\n', '  address initialOwner = 0x0D77002Affd96A22635bB46EC98F23EB99e12253;\n', '\n', '  constructor() public\n', '  {\n', '    bytes memory empty;\n', '    totalSupply = 12000000000 * (10 ** uint256(decimals));\n', '    balances[initialOwner] = totalSupply;\n', '    emit Transfer(0, this, totalSupply, empty);\n', '    emit Transfer(this, initialOwner, balances[initialOwner], empty);\n', '  }\n', '\n', '\n', '  // Function to access name of token .\n', '  function name() constant public returns (string _name) {\n', '      return name;\n', '  }\n', '  // Function to access symbol of token .\n', '  function symbol() constant public returns (string _symbol) {\n', '      return symbol;\n', '  }\n', '  // Function to access decimals of token .\n', '  function decimals() constant public returns (uint8 _decimals) {\n', '      return decimals;\n', '  }\n', '  // Function to access total supply of tokens .\n', '  function totalSupply() constant public returns (uint256 _totalSupply) {\n', '      return totalSupply;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  // Standard function transfer similar to ERC20 transfer with no _data .\n', '  // Added due to backwards compatibility reasons .\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '\n', '    //standard function transfer similar to ERC20 transfer with no _data\n', '    //added due to backwards compatibility reasons\n', '    bytes memory empty;\n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, empty);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, empty);\n', '    }\n', '  }\n', '\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n', '\n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, _data);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint256 _value, bytes _data, bytes _custom_fallback) public returns (bool success) {\n', '\n', '    if(isContract(_to)) {\n', '        require(balanceOf(msg.sender) >= _value);\n', '        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '        balances[_to] = balanceOf(_to).add(_value);\n', '        assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) private view returns (bool is_contract) {\n', '      uint256 length;\n', '      assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '      }\n', '      return (length>0);\n', '    }\n', '\n', '  //function that is called when transaction target is an address\n', '  function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '    require(balanceOf(msg.sender) >= _value);\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '    require(balanceOf(msg.sender) >= _value);\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    ContractReceiver receiver = ContractReceiver(_to);\n', '    receiver.tokenFallback(msg.sender, _value, _data);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function mintToken(address _target, uint256 _mintedAmount) onlyAdmin supplyLock public returns (bool success) {\n', '    bytes memory empty;\n', '    balances[_target] = SafeMath.add(balances[_target], _mintedAmount);\n', '    totalSupply = SafeMath.add(totalSupply, _mintedAmount);\n', '    emit Transfer(0, this, _mintedAmount,empty);\n', '    emit Transfer(this, _target, _mintedAmount,empty);\n', '    return true;\n', '  }\n', '\n', '  function burnToken(uint256 _burnedAmount) onlyAdmin supplyLock public returns (bool success) {\n', '    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _burnedAmount);\n', '    totalSupply = SafeMath.sub(totalSupply, _burnedAmount);\n', '    emit Burned(msg.sender, _burnedAmount);\n', '    return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '/**\n', '* @notice Block Coin Bit Token Contract\n', '* @dev ERC-223 Token Standar Compliant\n', '* Contact: aaronwalterfraser@gmail.com\n', '*/\n', '\n', '/**\n', ' * @title SafeMath by OpenZeppelin\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a * b;\n', '      assert(a == 0 || c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a / b;\n', '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC223 Token interface\n', " * @dev Code based on Dexaran's one on github as recommended on ERC223 discussion\n", ' */\n', '\n', 'contract ERC223Interface {\n', '\n', '  function balanceOf(address who) constant public returns (uint256);\n', '\n', '  function name() constant public returns (string _name);\n', '  function symbol() constant public returns (string _symbol);\n', '  function decimals() constant public returns (uint8 _decimals);\n', '  function totalSupply() constant public returns (uint256 _supply);\n', '\n', '  function mintToken(address _target, uint256 _mintedAmount) public returns (bool success);\n', '  function burnToken(uint256 _burnedAmount) public returns (bool success);\n', '\n', '  function transfer(address to, uint256 value) public returns (bool ok);\n', '  function transfer(address to, uint256 value, bytes data) public returns (bool ok);\n', '  function transfer(address to, uint256 value, bytes data, bytes custom_fallback) public returns (bool ok);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n', '  event Burned(address indexed _target, uint256 _value);\n', '}\n', '\n', ' contract ContractReceiver {\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', '/**\n', '* @title Admin parameters\n', '* @dev Define administration parameters for this contract\n', '*/\n', 'contract admined { //This token contract is administered\n', '    address public admin; //Admin address is public\n', '    bool public lockSupply; //Mint and Burn Lock flag\n', '\n', '    /**\n', '    * @dev Contract constructor\n', '    * define initial administrator\n', '    */\n', '    constructor() internal {\n', '        admin = msg.sender; //Set initial admin to contract creator\n', '        emit Admined(admin);\n', '    }\n', '\n', '    modifier onlyAdmin() { //A modifier to define admin-only functions\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier supplyLock() { //A modifier to lock mint and burn transactions\n', '        require(lockSupply == false);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @dev Function to set new admin address\n', '    * @param _newAdmin The address to transfer administration to\n', '    */\n', '    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered\n', '        require(_newAdmin != 0);\n', '        admin = _newAdmin;\n', '        emit TransferAdminship(admin);\n', '    }\n', '\n', '   /**\n', '    * @dev Function to set mint and burn locks\n', '    * @param _set boolean flag (true | false)\n', '    */\n', '    function setSupplyLock(bool _set) onlyAdmin public { //Only the admin can set a lock on supply\n', '        lockSupply = _set;\n', '        emit SetSupplyLock(_set);\n', '    }\n', '\n', '    //All admin actions have a log for public review\n', '    event SetSupplyLock(bool _set);\n', '    event TransferAdminship(address newAdminister);\n', '    event Admined(address administer);\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC223 Token definition\n', " * @dev Code based on Dexaran's one on github as recommended on ERC223 discussion\n", ' */\n', '\n', 'contract ERC223Token is admined,ERC223Interface {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  string public name    = "Block Coin Bit";\n', '  string public symbol  = "BLCB";\n', '  uint8 public decimals = 8;\n', '  uint256 public totalSupply;\n', '  address initialOwner = 0x0D77002Affd96A22635bB46EC98F23EB99e12253;\n', '\n', '  constructor() public\n', '  {\n', '    bytes memory empty;\n', '    totalSupply = 12000000000 * (10 ** uint256(decimals));\n', '    balances[initialOwner] = totalSupply;\n', '    emit Transfer(0, this, totalSupply, empty);\n', '    emit Transfer(this, initialOwner, balances[initialOwner], empty);\n', '  }\n', '\n', '\n', '  // Function to access name of token .\n', '  function name() constant public returns (string _name) {\n', '      return name;\n', '  }\n', '  // Function to access symbol of token .\n', '  function symbol() constant public returns (string _symbol) {\n', '      return symbol;\n', '  }\n', '  // Function to access decimals of token .\n', '  function decimals() constant public returns (uint8 _decimals) {\n', '      return decimals;\n', '  }\n', '  // Function to access total supply of tokens .\n', '  function totalSupply() constant public returns (uint256 _totalSupply) {\n', '      return totalSupply;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  // Standard function transfer similar to ERC20 transfer with no _data .\n', '  // Added due to backwards compatibility reasons .\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '\n', '    //standard function transfer similar to ERC20 transfer with no _data\n', '    //added due to backwards compatibility reasons\n', '    bytes memory empty;\n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, empty);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, empty);\n', '    }\n', '  }\n', '\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n', '\n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, _data);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint256 _value, bytes _data, bytes _custom_fallback) public returns (bool success) {\n', '\n', '    if(isContract(_to)) {\n', '        require(balanceOf(msg.sender) >= _value);\n', '        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '        balances[_to] = balanceOf(_to).add(_value);\n', '        assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) private view returns (bool is_contract) {\n', '      uint256 length;\n', '      assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '      }\n', '      return (length>0);\n', '    }\n', '\n', '  //function that is called when transaction target is an address\n', '  function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '    require(balanceOf(msg.sender) >= _value);\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '    require(balanceOf(msg.sender) >= _value);\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    ContractReceiver receiver = ContractReceiver(_to);\n', '    receiver.tokenFallback(msg.sender, _value, _data);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function mintToken(address _target, uint256 _mintedAmount) onlyAdmin supplyLock public returns (bool success) {\n', '    bytes memory empty;\n', '    balances[_target] = SafeMath.add(balances[_target], _mintedAmount);\n', '    totalSupply = SafeMath.add(totalSupply, _mintedAmount);\n', '    emit Transfer(0, this, _mintedAmount,empty);\n', '    emit Transfer(this, _target, _mintedAmount,empty);\n', '    return true;\n', '  }\n', '\n', '  function burnToken(uint256 _burnedAmount) onlyAdmin supplyLock public returns (bool success) {\n', '    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _burnedAmount);\n', '    totalSupply = SafeMath.sub(totalSupply, _burnedAmount);\n', '    emit Burned(msg.sender, _burnedAmount);\n', '    return true;\n', '  }\n', '\n', '}']
