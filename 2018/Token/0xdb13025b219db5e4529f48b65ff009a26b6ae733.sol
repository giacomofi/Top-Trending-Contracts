['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function allowance(address _owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner=0xE2d9b8259F74a46b5E3f74A30c7867be0a5f5185;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', ' constructor() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /// @dev counter to allow mutex lock with only one SSTORE operation\n', '  uint256 private _guardCounter;\n', '\n', '  constructor() internal {\n', '    // The counter starts at one to prevent changing it from zero to a non-zero\n', '    // value, which is a more expensive operation.\n', '    _guardCounter = 1;\n', '  }\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * Calling a `nonReentrant` function from another `nonReentrant`\n', '   * function is not supported. It is possible to prevent this from happening\n', '   * by making the `nonReentrant` function external, and make it call a\n', '   * `private` function that does the actual work.\n', '   */\n', '  modifier nonReentrant() {\n', '    _guardCounter += 1;\n', '    uint256 localCounter = _guardCounter;\n', '    _;\n', '    require(localCounter == _guardCounter);\n', '  }\n', '\n', '}\n', 'contract Haltable is Ownable  {\n', '    \n', '  bool public halted;\n', '  \n', '   modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier stopNonOwnersInEmergency {\n', '    if (halted && msg.sender != owner) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', 'contract Ubricoin is IERC20,Ownable,ReentrancyGuard,Haltable{\n', '  \n', '  using SafeMath for uint256;\n', '\n', '  // UBN Token parameters\n', "  string public name = 'Ubricoin';\n", "  string public symbol = 'UBN';\n", "  string public version = '2.0';\n", '  uint256 public constant RATE = 1000;  //1 ether = 1000 Ubricoins tokens\n', '  \n', '  // min tokens to be a holder, 0.1\n', '  uint256 public constant MIN_HOLDER_TOKENS = 10 ** uint256(decimals - 1);\n', '  \n', '  // 18 decimals is the strongly suggested default, avoid changing it\n', '  uint8   public constant decimals = 18;\n', '  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n', '  uint256 public totalSupply_;           // amount of tokens already sold/supply                                 \n', '  uint256 public constant TOTAL_SUPPLY = 10000000000 * decimalFactor; // The initialSupply or totalSupply of  100% Released at Token Distribution (TD)\n', '  uint256 public constant SALES_SUPPLY =  1300000000 * decimalFactor; // 2.30% Released at Token Distribution (TD)\n', '  \n', '  // Funds supply constants // tokens to be Distributed at every stage \n', '  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  1500000000 * decimalFactor; // 17.3% Released at TD \n', '  uint256 public AVAILABLE_AIRDROP_SUPPLY  =  2000000000 * decimalFactor; // 22.9% Released at TD/Eco System Allocated\n', '  uint256 public AVAILABLE_OWNER_SUPPLY    =  2000000000 * decimalFactor; // 22.9% Released at TD \n', '  uint256 public AVAILABLE_TEAMS_SUPPLY    =  3000000000 * decimalFactor; // 34.5% Released at TD \n', '  uint256 public AVAILABLE_BONUS_SUPPLY    =   200000000 * decimalFactor; // 0.10% Released at TD \n', '  uint256 public claimedTokens = 0;\n', '  \n', '  // Funds supply addresses constants // tokens distribution\n', '  address public constant AVAILABLE_FOUNDER_SUPPLY_ADDRESS = 0xAC762012330350DDd97Cc64B133536F8E32193a8; //AVAILABLE_FOUNDER_SUPPLY_ADDRESS 1\n', '  address public constant AVAILABLE_AIRDROP_SUPPLY_ADDRESS = 0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09; //AVAILABLE_AIRDROP_SUPPLY_ADDRESS 2 Eco system Allocated\n', '  address public constant AVAILABLE_OWNER_SUPPLY_ADDRESS = 0xE2d9b8259F74a46b5E3f74A30c7867be0a5f5185;   //AVAILABLE_OWNER_SUPPLY_ADDRESS   3\n', '  address public constant AVAILABLE_BONUS_SUPPLY_ADDRESS = 0xDE59297Bf5D1D1b9d38D8F50e55A270eb9aE136e;   //AVAILABLE_BONUS1_SUPPLY_ADDRESS  4\n', '  address public constant AVAILABLE_TEAMS_SUPPLY_ADDRESS = 0x9888375f4663891770DaaaF9286d97d44FeFC82E;   //AVAILABLE_RESERVE_TEAM_SUPPLY_ADDRESS 5\n', '\n', '  // Token holders\n', '  address[] public holders;\n', '  \n', '\n', '  // ICO address\n', '  address public icoAddress;\n', '  mapping (address => uint256) balances;  // This creates an array with all balances\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '  \n', '  // Keeps track of whether or not an Ubricoin airdrop has been made to a particular address\n', '  mapping (address => bool) public airdrops;\n', '  \n', '  mapping (address => uint256) public holderNumber; // Holders number\n', '  \n', '  // This generates a public event on the blockchain that will notify clients\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event TransferredToken(address indexed to, uint256 value);\n', '  event FailedTransfer(address indexed to, uint256 value);\n', '  // This notifies clients about the amount burnt , only admin is able to burn the contract\n', '  event Burn(address from, uint256 value); \n', '  event AirDropped ( address[] _recipient, uint256 _amount, uint256 claimedTokens);\n', '  event AirDrop_many ( address[] _recipient, uint256[] _amount, uint256 claimedTokens);\n', '  \n', ' \n', '    /**\n', '     * @dev Constructor that gives a portion of all existing tokens to various addresses.\n', '     * @dev Distribute founder, airdrop,owner, reserve_team and bonus_supply tokens\n', '     * @dev and Ico address for the remaining tokens\n', '     */\n', '  constructor () public  { \n', '      \n', '        // Allocate tokens to the available_founder_supply_address fund 1\n', '        balances[AVAILABLE_FOUNDER_SUPPLY_ADDRESS] = AVAILABLE_FOUNDER_SUPPLY;\n', '        holders.push(AVAILABLE_FOUNDER_SUPPLY_ADDRESS);\n', '        emit Transfer(0x0, AVAILABLE_FOUNDER_SUPPLY_ADDRESS, AVAILABLE_FOUNDER_SUPPLY);\n', '\n', '        // Allocate tokens to the available_airdrop_supply_address fund 2 eco system allocated\n', '        balances[AVAILABLE_AIRDROP_SUPPLY_ADDRESS] = AVAILABLE_AIRDROP_SUPPLY;\n', '        holders.push(AVAILABLE_AIRDROP_SUPPLY_ADDRESS);\n', '        emit Transfer(0x0, AVAILABLE_AIRDROP_SUPPLY_ADDRESS, AVAILABLE_AIRDROP_SUPPLY);\n', '\n', '        // Allocate tokens to the available_owner_supply_address fund 3\n', '        balances[AVAILABLE_OWNER_SUPPLY_ADDRESS] = AVAILABLE_OWNER_SUPPLY;\n', '        holders.push(AVAILABLE_OWNER_SUPPLY_ADDRESS);\n', '        emit Transfer(0x0, AVAILABLE_OWNER_SUPPLY_ADDRESS, AVAILABLE_OWNER_SUPPLY);\n', '\n', '        // Allocate tokens to the available_reserve_team_supply_address fund 4\n', '        balances[AVAILABLE_TEAMS_SUPPLY_ADDRESS] = AVAILABLE_TEAMS_SUPPLY;\n', '        holders.push(AVAILABLE_TEAMS_SUPPLY_ADDRESS);\n', '        emit Transfer(0x0, AVAILABLE_TEAMS_SUPPLY_ADDRESS, AVAILABLE_TEAMS_SUPPLY);\n', '        \n', '        // Allocate tokens to the available_reserve_team_supply_address fund 5\n', '        balances[AVAILABLE_BONUS_SUPPLY_ADDRESS] = AVAILABLE_BONUS_SUPPLY;\n', '        holders.push(AVAILABLE_BONUS_SUPPLY_ADDRESS);\n', '        emit Transfer(0x0, AVAILABLE_BONUS_SUPPLY_ADDRESS, AVAILABLE_BONUS_SUPPLY);\n', '\n', '        totalSupply_ = TOTAL_SUPPLY.sub(SALES_SUPPLY);\n', '        \n', '    }\n', '    \n', '   /**\n', '     * @dev Function fallback/payable to buy tokens from contract by sending ether.\n', '     * @notice Buy tokens from contract by sending ether\n', "     * @dev This are the tokens allocated for sale's supply\n", '     */\n', '  function () payable nonReentrant external  {\n', '      \n', '    require(msg.data.length == 0);\n', '    require(msg.value > 0);\n', '    \n', '      uint256 tokens = msg.value.mul(RATE); // calculates the aamount\n', '      balances[msg.sender] = balances[msg.sender].add(tokens);\n', '      totalSupply_ = totalSupply_.add(tokens);\n', '      owner.transfer(msg.value);  //make transfer\n', '      \n', '    }\n', '\n', '    /**\n', '     * @dev set ICO address and allocate sale supply to it\n', '     *      Tokens left for payment using ethers\n', '     */\n', '  function setICO(address _icoAddress) public onlyOwner {\n', '      \n', '    require(_icoAddress != address(0));\n', '    require(icoAddress  == address(0));\n', '    require(totalSupply_ == TOTAL_SUPPLY.sub(SALES_SUPPLY));\n', '      \n', '       // Allocate tokens to the ico contract\n', '       balances[_icoAddress] = SALES_SUPPLY;\n', '       emit Transfer(0x0, _icoAddress, SALES_SUPPLY);\n', '\n', '       icoAddress = _icoAddress;\n', '       totalSupply_ = TOTAL_SUPPLY;\n', '       \n', '    }\n', '\n', '    /**\n', '     * @dev total number of tokens in existence\n', '     */\n', '  function totalSupply() public view returns (uint256) {\n', '      \n', '      return totalSupply_;\n', '      \n', '    }\n', '    \n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint256 representing the amount owned by the passed address.\n', '     */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '      \n', '      return balances[_owner];\n', '      \n', '    }\n', '  \n', '\n', '   /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining ) {\n', '      \n', '      return allowed[_owner][_spender];\n', '      \n', '    }\n', '    \n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '  function _transfer(address _from, address _to, uint256 _value) internal {\n', '      \n', '    require(_to != 0x0);                 // Prevent transfer to 0x0 address. Use burn() instead\n', '    require(balances[_from] >= _value);  // Check if the sender has enough\n', '    require(balances[_to] + _value >= balances[_to]);             // Check for overflows\n', '     \n', '      uint256 previousBalances = balances[_from] + balances[_to];   // Save this for an assertion in the future\n', '      balances[_from] -= _value;   // Subtract from the sender\n', '      balances[_to] += _value;     // Add the same to the recipient\n', '      emit Transfer(_from, _to, _value);\n', '      \n', '      // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '      assert(balances[_from] + balances[_to] == previousBalances);  \n', '      \n', '    }\n', '    \n', '   \n', '    /**\n', '     * Standard transfer function \n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      \n', '       require(balances[msg.sender] > 0);                     \n', '       require(balances[msg.sender] >= _value);  // Check if the sender has enough  \n', '       require(_to != address(0x0));             // Prevent transfer to 0x0 address. Use burn() instead\n', '       \n', '       require(_value > 0);\t\n', '       require(_to != msg.sender);               // Check if sender and receiver is not same\n', '       require(_value <= balances[msg.sender]);\n', '\n', '       // SafeMath.sub will throw if there is not enough balance.\n', '       balances[msg.sender] = balances[msg.sender].sub(_value); // Subtract value from sender\n', '       balances[_to] = balances[_to].add(_value);               // Add the value to the receiver\n', '       emit Transfer(msg.sender, _to, _value);                  // Notify all clients about the transfer events\n', '       return true;\n', '       \n', '    }\n', '    \n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      \n', '    require(_to != address(0x0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);  // Check allowance\n', '\n', '      balances[_from] = balances[_from].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      emit Transfer(_from, _to, _value);\n', '      return true;\n', '      \n', '   }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '    */\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '      \n', '      allowed[msg.sender][_spender] = _value;\n', '      emit  Approval(msg.sender, _spender, _value);\n', '      return true;\n', '      \n', '    }\n', '    \n', '  // get holders count\n', '  function getHoldersCount() public view returns (uint256) {\n', '      \n', '        return holders.length;\n', '    }\n', '    \n', '  // preserve holders list\n', '  function preserveHolders(address _from, address _to, uint256 _value) internal {\n', '      \n', '        if (balances[_from].sub(_value) < MIN_HOLDER_TOKENS) \n', '            removeHolder(_from);\n', '        if (balances[_to].add(_value) >= MIN_HOLDER_TOKENS) \n', '            addHolder(_to);   \n', '    }\n', '\n', '  // remove holder from the holders list\n', '  function removeHolder(address _holder) internal {\n', '      \n', '        uint256 _number = holderNumber[_holder];\n', '\n', '        if (_number == 0 || holders.length == 0 || _number > holders.length)\n', '            return;\n', '\n', '        uint256 _index = _number.sub(1);\n', '        uint256 _lastIndex = holders.length.sub(1);\n', '        address _lastHolder = holders[_lastIndex];\n', '\n', '        if (_index != _lastIndex) {\n', '            holders[_index] = _lastHolder;\n', '            holderNumber[_lastHolder] = _number;\n', '        }\n', '\n', '        holderNumber[_holder] = 0;\n', '        holders.length = _lastIndex;\n', '    } \n', '\n', '  // add holder to the holders list\n', '  function addHolder(address _holder) internal {\n', '      \n', '        if (holderNumber[_holder] == 0) {\n', '            holders.push(_holder);\n', '            holderNumber[_holder] = holders.length;\n', '            \n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', ' function _burn(address account, uint256 value) external onlyOwner {\n', '     \n', '      require(balances[msg.sender] >= value);   // Check if the sender has enough\n', '      balances[msg.sender] -= value;            // Subtract from the sender\n', '      totalSupply_ -= value;                    // Updates totalSupply\n', '      emit Burn(msg.sender, value);\n', '      //return true;\n', '      \n', '      require(account != address(0x0));\n', '\n', '      totalSupply_ = totalSupply_.sub(value);\n', '      balances[account] = balances[account].sub(value);\n', '      emit Transfer(account, address(0X0), value);\n', '     \n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '  function _burnFrom(address account, uint256 value) external onlyOwner {\n', '      \n', '      require(balances[account] >= value);               // Check if the targeted balance is enough\n', '      require(value <= allowed[account][msg.sender]);    // Check allowance\n', '      balances[account] -= value;                        // Subtract from the targeted balance\n', "      allowed[account][msg.sender] -= value;             // Subtract from the sender's allowance\n", '      totalSupply_ -= value;                             // Update totalSupply\n', '      emit Burn(account, value);\n', '      // return true; \n', '      \n', '      allowed[account][msg.sender] = allowed[account][msg.sender].sub(value);\n', '      emit Burn(account, value);\n', '      emit Approval(account, msg.sender, allowed[account][msg.sender]);\n', '      \n', '    }\n', '    \n', '  function validPurchase() internal returns (bool) {\n', '      \n', '      bool lessThanMaxInvestment = msg.value <= 1000 ether; // change the value to whatever you need\n', '      return validPurchase() && lessThanMaxInvestment;\n', '      \n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param target The account that will receive the created tokens.\n', '     * @param mintedAmount The amount that will be created.\n', "     * @dev  perform a minting/create new UBN's for new allocations\n", '     * @param  target is the address to mint tokens to\n', '     * \n', '     */\n', '  function mintToken(address target, uint256 mintedAmount) public onlyOwner {\n', '      \n', '      balances[target] += mintedAmount;\n', '      totalSupply_ += mintedAmount;\n', '      \n', '      emit Transfer(0, owner, mintedAmount);\n', '      emit Transfer(owner, target, mintedAmount);\n', '      \n', '    }\n', '    \n', '    /**\n', '    * @dev perform a transfer of allocations\n', '    * @param _recipient is a list of recipients\n', '    * \n', '    * Below function can be used when you want to send every recipeint with different number of tokens\n', '    * \n', '    */\n', '  function airDrop_many(address[] _recipient, uint256[] _amount) public onlyOwner {\n', '        \n', '        require(msg.sender == owner);\n', '        require(_recipient.length == _amount.length);\n', '        uint256 amount = _amount[i] * uint256(decimalFactor);\n', '        uint256 airdropped;\n', '    \n', '        for (uint i=0; i < _recipient.length; i++) {\n', '           if (!airdrops[_recipient[i]]) {\n', '                airdrops[_recipient[i]] = true;\n', '                require(Ubricoin.transfer(_recipient[i], _amount[i] * decimalFactor));\n', '                //Ubricoin.transfer(_recipient[i], _amount[i]);\n', '                airdropped = airdropped.add(amount );\n', '            } else{\n', '                \n', '                 emit FailedTransfer(_recipient[i], airdropped); \n', '        }\n', '        \n', '    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n', '    //totalSupply_ = totalSupply_.sub(airdropped);\n', '    claimedTokens = claimedTokens.add(airdropped);\n', '    emit AirDrop_many(_recipient, _amount, claimedTokens);\n', '    \n', '        }\n', '    }\n', '    \n', '   /**\n', '    * @dev perform a transfer of allocations\n', '    * @param _recipient is a list of recipients\n', '    * \n', '    * this function can be used when you want to send same number of tokens to all the recipients\n', '    * \n', '    */\n', '  function airDrop(address[] _recipient, uint256 _amount) public onlyOwner {\n', '      \n', '        require(_amount > 0);\n', '        uint256 airdropped;\n', '        uint256 amount = _amount * uint256(decimalFactor);\n', '        for (uint256 index = 0; index < _recipient.length; index++) {\n', '            if (!airdrops[_recipient[index]]) {\n', '                airdrops[_recipient[index]] = true;\n', '                require(Ubricoin.transfer(_recipient[index], amount * decimalFactor ));\n', '                airdropped = airdropped.add(amount );\n', '            }else{\n', '            \n', '            emit FailedTransfer(_recipient[index], airdropped); \n', '        }\n', '    }\n', '        \n', '    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n', '    //totalSupply_ = totalSupply_.sub(airdropped);\n', '    claimedTokens = claimedTokens.add(airdropped);\n', '    emit AirDropped(_recipient, _amount, claimedTokens);\n', '    \n', '    }\n', '    \n', '\n', '}']