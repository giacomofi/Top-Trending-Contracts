['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = true;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '\n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'interface TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract TokenERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        TokenRecipient spender = TokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract PaymentInterface {\n', '    function buyBlueStarEgg(address _master, uint _tokens, uint16 _amount) public returns(uint);\n', '}\n', '\n', 'contract DragonTreasureToken is BasicAccessControl, TokenERC20 {\n', '    // metadata\n', '    string public constant name = "DragonTreasureToken";\n', '    string public constant symbol = "DTT";\n', '    uint256 public constant decimals = 8;\n', '    string public version = "1.0";\n', '\n', '    // deposit address\n', '    address public inGameRewardAddress;\n', '    address public userGrowPoolAddress;\n', '    address public developerAddress;\n', '    address public paymentContract;\n', '\n', '    // for future feature\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    bool public trading = false;\n', '    mapping (address => bool) public frozenAccount;\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    modifier isTrading {\n', '        require(trading == true || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier requirePaymentContract {\n', '        require(paymentContract != address(0));\n', '        _;\n', '    }\n', '\n', '    function () payable public {}\n', '\n', '    // constructor\n', '    function DragonTreasureToken(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress) public {\n', '        require(_inGameRewardAddress != address(0));\n', '        require(_userGrowPoolAddress != address(0));\n', '        require(_developerAddress != address(0));\n', '        inGameRewardAddress = _inGameRewardAddress;\n', '        userGrowPoolAddress = _userGrowPoolAddress;\n', '        developerAddress = _developerAddress;\n', '\n', '        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\n', '        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\n', '        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\n', '        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\n', '    }\n', '\n', '    // moderators\n', '    function setAddress(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) onlyModerators external {\n', '        inGameRewardAddress = _inGameRewardAddress;\n', '        userGrowPoolAddress = _userGrowPoolAddress;\n', '        developerAddress = _developerAddress;\n', '        paymentContract = _paymentContract;\n', '    }\n', '\n', '    // public\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);\n', '        require (balanceOf[_from] >= _value);\n', '        require (balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(!frozenAccount[_from]);\n', '        require(!frozenAccount[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        frozenAccount[_target] = _freeze;\n', '        FrozenFunds(_target, _freeze);\n', '    }\n', '\n', '    function buy() payable isTrading public {\n', '        uint amount = msg.value / buyPrice;\n', '        _transfer(this, msg.sender, amount);\n', '    }\n', '\n', '    function sell(uint256 amount) isTrading public {\n', '        require(this.balance >= amount * sellPrice);\n', '        _transfer(msg.sender, this, amount);\n', '        msg.sender.transfer(amount * sellPrice);\n', '    }\n', '\n', '    function buyBlueStarEgg(uint _tokens, uint16 _amount) isActive requirePaymentContract external {\n', '        if (_tokens > balanceOf[msg.sender])\n', '            revert();\n', '        PaymentInterface payment = PaymentInterface(paymentContract);\n', '        uint deductedTokens = payment.buyBlueStarEgg(msg.sender, _tokens, _amount);\n', '        if (deductedTokens == 0 || deductedTokens > _tokens)\n', '            revert();\n', '        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract BasicAccessControl {\n', '    address public owner;\n', '    // address[] public moderators;\n', '    uint16 public totalModerators = 0;\n', '    mapping (address => bool) public moderators;\n', '    bool public isMaintaining = true;\n', '\n', '    function BasicAccessControl() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyModerators() {\n', '        require(msg.sender == owner || moderators[msg.sender] == true);\n', '        _;\n', '    }\n', '\n', '    modifier isActive {\n', '        require(!isMaintaining);\n', '        _;\n', '    }\n', '\n', '    function ChangeOwner(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '    }\n', '\n', '\n', '    function AddModerator(address _newModerator) onlyOwner public {\n', '        if (moderators[_newModerator] == false) {\n', '            moderators[_newModerator] = true;\n', '            totalModerators += 1;\n', '        }\n', '    }\n', '\n', '    function RemoveModerator(address _oldModerator) onlyOwner public {\n', '        if (moderators[_oldModerator] == true) {\n', '            moderators[_oldModerator] = false;\n', '            totalModerators -= 1;\n', '        }\n', '    }\n', '\n', '    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n', '        isMaintaining = _isMaintaining;\n', '    }\n', '}\n', '\n', 'interface TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract TokenERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        TokenRecipient spender = TokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract PaymentInterface {\n', '    function buyBlueStarEgg(address _master, uint _tokens, uint16 _amount) public returns(uint);\n', '}\n', '\n', 'contract DragonTreasureToken is BasicAccessControl, TokenERC20 {\n', '    // metadata\n', '    string public constant name = "DragonTreasureToken";\n', '    string public constant symbol = "DTT";\n', '    uint256 public constant decimals = 8;\n', '    string public version = "1.0";\n', '\n', '    // deposit address\n', '    address public inGameRewardAddress;\n', '    address public userGrowPoolAddress;\n', '    address public developerAddress;\n', '    address public paymentContract;\n', '\n', '    // for future feature\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    bool public trading = false;\n', '    mapping (address => bool) public frozenAccount;\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    modifier isTrading {\n', '        require(trading == true || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier requirePaymentContract {\n', '        require(paymentContract != address(0));\n', '        _;\n', '    }\n', '\n', '    function () payable public {}\n', '\n', '    // constructor\n', '    function DragonTreasureToken(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress) public {\n', '        require(_inGameRewardAddress != address(0));\n', '        require(_userGrowPoolAddress != address(0));\n', '        require(_developerAddress != address(0));\n', '        inGameRewardAddress = _inGameRewardAddress;\n', '        userGrowPoolAddress = _userGrowPoolAddress;\n', '        developerAddress = _developerAddress;\n', '\n', '        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\n', '        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\n', '        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\n', '        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\n', '    }\n', '\n', '    // moderators\n', '    function setAddress(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) onlyModerators external {\n', '        inGameRewardAddress = _inGameRewardAddress;\n', '        userGrowPoolAddress = _userGrowPoolAddress;\n', '        developerAddress = _developerAddress;\n', '        paymentContract = _paymentContract;\n', '    }\n', '\n', '    // public\n', '    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\n', '        if (_amount > this.balance) {\n', '            revert();\n', '        }\n', '        _sendTo.transfer(_amount);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);\n', '        require (balanceOf[_from] >= _value);\n', '        require (balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(!frozenAccount[_from]);\n', '        require(!frozenAccount[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        frozenAccount[_target] = _freeze;\n', '        FrozenFunds(_target, _freeze);\n', '    }\n', '\n', '    function buy() payable isTrading public {\n', '        uint amount = msg.value / buyPrice;\n', '        _transfer(this, msg.sender, amount);\n', '    }\n', '\n', '    function sell(uint256 amount) isTrading public {\n', '        require(this.balance >= amount * sellPrice);\n', '        _transfer(msg.sender, this, amount);\n', '        msg.sender.transfer(amount * sellPrice);\n', '    }\n', '\n', '    function buyBlueStarEgg(uint _tokens, uint16 _amount) isActive requirePaymentContract external {\n', '        if (_tokens > balanceOf[msg.sender])\n', '            revert();\n', '        PaymentInterface payment = PaymentInterface(paymentContract);\n', '        uint deductedTokens = payment.buyBlueStarEgg(msg.sender, _tokens, _amount);\n', '        if (deductedTokens == 0 || deductedTokens > _tokens)\n', '            revert();\n', '        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\n', '    }\n', '}']
