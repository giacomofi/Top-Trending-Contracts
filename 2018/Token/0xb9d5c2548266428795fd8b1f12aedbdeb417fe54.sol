['pragma solidity ^0.4.18;\n', '// ----------------------------------------------------------------------------\n', '// &#39;TOG&#39; token contract\n', '//\n', '// Deployed to     : 0x916186f2959aC103C458485A2681C0cd805ad7A2\n', '// Symbol          : TOG\n', '// Name            : Tool of God Token\n', '// Total supply    : 1000000000\n', '// Frozen Amount   :  400000000\n', '// First Release   :   50000000\n', '// Seconad Release :   50000000\n', '// Decimals        : 8\n', '//\n', '//\n', '// (c) by <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="94d3f5e6edbadce1f5faf3d4e0fbecf6e0f7baf7fbf9ba">[email&#160;protected]</a>\n', '// ----------------------------------------------------------------------------\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'contract SafeMath {\n', '    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Constructor() public { owner = msg.sender; }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract TOGToken is ERC20Interface, Owned, SafeMath {\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint256 public _totalSupply;\n', '    uint256 public _frozeAmount;\n', '    uint256 _firstUnlockAmmount;\n', '    uint256 _secondUnlockAmmount;\n', '    uint256 _firstUnlockTime;\n', '    uint256 _secondUnlockTime;\n', '\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '\n', '    function Constructor() public {\n', '        symbol = "TOG";\n', '        name = "Tool of God Token";\n', '        decimals = 8;               // decimals 可以有的小数点个数，最小的代币单位。\n', '        _totalSupply = 1000000000;   // 总共发行10亿枚\n', '        _frozeAmount =  400000000;   // 冻结4亿枚\n', '        _firstUnlockAmmount  =  50000000;  //第一年解冻数量\n', '        _secondUnlockAmmount =  50000000;  //第一年解冻数量\n', '        balances[msg.sender] = 500000000;\n', '        _firstUnlockTime  = now + 31536000;\n', '        _secondUnlockTime = now + 63072000;\n', '        emit Transfer(address(0), msg.sender, 500000000);\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    \n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function releaseFirstUnlock() public onlyOwner returns (bool success){\n', '        require(now >= _firstUnlockTime);\n', '        require(_firstUnlockAmmount > 0);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], _firstUnlockAmmount);\n', '        _firstUnlockAmmount = 0;\n', '        emit Transfer(address(0), msg.sender, _firstUnlockAmmount);\n', '        return true;\n', '    }\n', '\n', '    function releaseSecondUnlock() public onlyOwner returns (bool success){\n', '        require(now >= _secondUnlockTime);\n', '        require(_secondUnlockAmmount > 0);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], _secondUnlockAmmount);\n', '        _secondUnlockAmmount = 0;\n', '        emit Transfer(address(0), msg.sender, _secondUnlockAmmount);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 tokens) public returns (bool success) {\n', '        require (to != 0x0);                                             // 收币帐户不能为空帐号\n', '        require (balances[msg.sender] >= tokens);                        // 转出帐户的余额足够\n', '        require (balances[to] + tokens >= balances[to]);                 // 转入帐户余额未溢出  \n', '        uint256 previousBalances = balances[msg.sender] + balances[to];  // 两帐户总余额\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);    // 转出\n', '        balances[to] = safeAdd(balances[to], tokens);                    // 转入\n', '        emit Transfer(msg.sender, to, tokens);\n', '        assert(balances[msg.sender] + balances[to] == previousBalances); //两帐户总余额不变\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n', '        require (to != 0x0);                               // 收币帐户不能为空帐号\n', '        require (balances[from] >= tokens);                // 转出帐户的余额足够\n', '        require (balances[to] + tokens >= balances[to]);   // 转入帐户余额未溢出                    \n', '        uint256 previousBalances = balances[from] + balances[to];\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        assert(balances[from] + balances[to] == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '// ----------------------------------------------------------------------------\n', "// 'TOG' token contract\n", '//\n', '// Deployed to     : 0x916186f2959aC103C458485A2681C0cd805ad7A2\n', '// Symbol          : TOG\n', '// Name            : Tool of God Token\n', '// Total supply    : 1000000000\n', '// Frozen Amount   :  400000000\n', '// First Release   :   50000000\n', '// Seconad Release :   50000000\n', '// Decimals        : 8\n', '//\n', '//\n', '// (c) by Gary.Huang@toxbtc.com.\n', '// ----------------------------------------------------------------------------\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'contract SafeMath {\n', '    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Constructor() public { owner = msg.sender; }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract TOGToken is ERC20Interface, Owned, SafeMath {\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint256 public _totalSupply;\n', '    uint256 public _frozeAmount;\n', '    uint256 _firstUnlockAmmount;\n', '    uint256 _secondUnlockAmmount;\n', '    uint256 _firstUnlockTime;\n', '    uint256 _secondUnlockTime;\n', '\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '\n', '    function Constructor() public {\n', '        symbol = "TOG";\n', '        name = "Tool of God Token";\n', '        decimals = 8;               // decimals 可以有的小数点个数，最小的代币单位。\n', '        _totalSupply = 1000000000;   // 总共发行10亿枚\n', '        _frozeAmount =  400000000;   // 冻结4亿枚\n', '        _firstUnlockAmmount  =  50000000;  //第一年解冻数量\n', '        _secondUnlockAmmount =  50000000;  //第一年解冻数量\n', '        balances[msg.sender] = 500000000;\n', '        _firstUnlockTime  = now + 31536000;\n', '        _secondUnlockTime = now + 63072000;\n', '        emit Transfer(address(0), msg.sender, 500000000);\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    \n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function releaseFirstUnlock() public onlyOwner returns (bool success){\n', '        require(now >= _firstUnlockTime);\n', '        require(_firstUnlockAmmount > 0);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], _firstUnlockAmmount);\n', '        _firstUnlockAmmount = 0;\n', '        emit Transfer(address(0), msg.sender, _firstUnlockAmmount);\n', '        return true;\n', '    }\n', '\n', '    function releaseSecondUnlock() public onlyOwner returns (bool success){\n', '        require(now >= _secondUnlockTime);\n', '        require(_secondUnlockAmmount > 0);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], _secondUnlockAmmount);\n', '        _secondUnlockAmmount = 0;\n', '        emit Transfer(address(0), msg.sender, _secondUnlockAmmount);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 tokens) public returns (bool success) {\n', '        require (to != 0x0);                                             // 收币帐户不能为空帐号\n', '        require (balances[msg.sender] >= tokens);                        // 转出帐户的余额足够\n', '        require (balances[to] + tokens >= balances[to]);                 // 转入帐户余额未溢出  \n', '        uint256 previousBalances = balances[msg.sender] + balances[to];  // 两帐户总余额\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);    // 转出\n', '        balances[to] = safeAdd(balances[to], tokens);                    // 转入\n', '        emit Transfer(msg.sender, to, tokens);\n', '        assert(balances[msg.sender] + balances[to] == previousBalances); //两帐户总余额不变\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n', '        require (to != 0x0);                               // 收币帐户不能为空帐号\n', '        require (balances[from] >= tokens);                // 转出帐户的余额足够\n', '        require (balances[to] + tokens >= balances[to]);   // 转入帐户余额未溢出                    \n', '        uint256 previousBalances = balances[from] + balances[to];\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        assert(balances[from] + balances[to] == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
