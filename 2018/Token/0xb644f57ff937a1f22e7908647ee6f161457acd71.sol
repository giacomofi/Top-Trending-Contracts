['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/interfaces/BurnableTokenInterface.sol\n', '\n', '/**\n', ' * @title Burnable Token Interface\n', ' * @author Bram Hoven\n', ' * @notice Interface for communicating with the burnable token\n', ' */\n', 'interface BurnableTokenInterface {\n', '  /**\n', '   * @notice Triggered when tokens are burned\n', '   * @param _triggerer Address which triggered the burning\n', '   * @param _from Address from which the tokens are burned\n', '   * @param _tokens Amount of tokens burned\n', '   */\n', '  event TokensBurned(address indexed _triggerer, address indexed _from, uint256 _tokens);\n', '\n', '  /**\n', '   * @notice Called when tokens have to be burned\n', '   * @param _tokens Amount of tokens to be burned\n', '   */\n', '  function burnTokens(uint256 _tokens) external;\n', '}\n', '\n', '// File: contracts/interfaces/ContractManagerInterface.sol\n', '\n', '/**\n', ' * @title Contract Manager Interface\n', ' * @author Bram Hoven\n', ' * @notice Interface for communicating with the contract manager\n', ' */\n', 'interface ContractManagerInterface {\n', '  /**\n', '   * @notice Triggered when contract is added\n', '   * @param _address Address of the new contract\n', '   * @param _contractName Name of the new contract\n', '   */\n', '  event ContractAdded(address indexed _address, string _contractName);\n', '\n', '  /**\n', '   * @notice Triggered when contract is removed\n', '   * @param _contractName Name of the contract that is removed\n', '   */\n', '  event ContractRemoved(string _contractName);\n', '\n', '  /**\n', '   * @notice Triggered when contract is updated\n', '   * @param _oldAddress Address where the contract used to be\n', '   * @param _newAddress Address where the new contract is deployed\n', '   * @param _contractName Name of the contract that has been updated\n', '   */\n', '  event ContractUpdated(address indexed _oldAddress, address indexed _newAddress, string _contractName);\n', '\n', '  /**\n', '   * @notice Triggered when authorization status changed\n', '   * @param _address Address who will gain or lose authorization to _contractName\n', '   * @param _authorized Boolean whether or not the address is authorized\n', '   * @param _contractName Name of the contract\n', '   */\n', '  event AuthorizationChanged(address indexed _address, bool _authorized, string _contractName);\n', '\n', '  /**\n', '   * @notice Check whether the accessor is authorized to access that contract\n', '   * @param _contractName Name of the contract that is being accessed\n', '   * @param _accessor Address who wants to access that contract\n', '   */\n', '  function authorize(string _contractName, address _accessor) external view returns (bool);\n', '\n', '  /**\n', '   * @notice Add a new contract to the manager\n', '   * @param _contractName Name of the new contract\n', '   * @param _address Address of the new contract\n', '   */\n', '  function addContract(string _contractName, address _address) external;\n', '\n', '  /**\n', '   * @notice Get a contract by its name\n', '   * @param _contractName Name of the contract\n', '   */\n', '  function getContract(string _contractName) external view returns (address _contractAddress);\n', '\n', '  /**\n', '   * @notice Remove an existing contract\n', '   * @param _contractName Name of the contract that will be removed\n', '   */\n', '  function removeContract(string _contractName) external;\n', '\n', '  /**\n', '   * @notice Update an existing contract (changing the address)\n', '   * @param _contractName Name of the existing contract\n', '   * @param _newAddress Address where the new contract is deployed\n', '   */\n', '  function updateContract(string _contractName, address _newAddress) external;\n', '\n', '  /**\n', '   * @notice Change whether an address is authorized to use a specific contract or not\n', '   * @param _contractName Name of the contract to which the accessor will gain authorization or not\n', '   * @param _authorizedAddress Address which will have its authorisation status changed\n', '   * @param _authorized Boolean whether the address will have access or not\n', '   */\n', '  function setAuthorizedContract(string _contractName, address _authorizedAddress, bool _authorized) external;\n', '}\n', '\n', '// File: contracts/interfaces/MintableTokenInterface.sol\n', '\n', '/**\n', ' * @title Mintable Token Interface\n', ' * @author Bram Hoven\n', ' * @notice Interface for communicating with the mintable token\n', ' */\n', 'interface MintableTokenInterface {\n', '  /**\n', '   * @notice Triggered when tokens are minted\n', '   * @param _from Address which triggered the minting\n', '   * @param _to Address on which the tokens are deposited\n', '   * @param _tokens Amount of tokens minted\n', '   */\n', '  event TokensMinted(address indexed _from, address indexed _to, uint256 _tokens);\n', '\n', '  /**\n', '   * @notice Triggered when the deposit address changes\n', '   * @param _old Old deposit address\n', '   * @param _new New deposit address\n', '   */\n', '  event DepositAddressChanged(address indexed _old, address indexed _new);\n', '\n', '  /**\n', '   * @notice Called when new tokens are needed in circulation\n', '   * @param _tokens Amount of tokens to be created\n', '   */\n', '  function mintTokens(uint256 _tokens) external;\n', '\n', '  /**\n', '   * @notice Called when tokens are bought in token sale\n', '   * @param _beneficiary Address on which tokens are deposited\n', '   * @param _tokens Amount of tokens to be created\n', '   */\n', '  function sendBoughtTokens(address _beneficiary, uint256 _tokens) external;\n', '\n', '  /**\n', '   * @notice Called when deposit address needs to change\n', '   * @param _depositAddress Address on which minted tokens are deposited\n', '   */\n', '  function changeDepositAddress(address _depositAddress) external;\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/token/BasicToken.sol\n', '\n', 'contract BasicToken is ERC20Basic, ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  bool public locked = true;\n', '\n', '  event TokensUnlocked();\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(!locked);\n', '    \n', '    _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address internally\n', '  * @param _from The address to transfer from.\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(!locked);\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    require(!locked);\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    require(!locked);\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    require(!locked);\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    require(!locked);\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  } \n', '\n', '  /**\n', '   * @notice Called to unlock tokens after sale has ended\n', '   */\n', '  function unlockTokens() public {\n', '    require(locked);\n', '\n', '    locked = false;\n', '\n', '    emit TokensUnlocked();\n', '  }\n', '}\n', '\n', '// File: contracts/token/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable Token\n', ' * @author Bram Hoven\n', ' * @notice Contract for a token which can be minted during the sale or after\n', ' */\n', 'contract MintableToken is MintableTokenInterface, BasicToken {\n', '  // Address on which minted coins will be deposited (and burned if needed)\n', '  address public depositAddress;\n', '  // Name of this contract\n', '  string public contractName;\n', '  // Contract Manager\n', '  ContractManagerInterface internal contractManager;\n', '\n', '  /**\n', '   * @notice Constructor for creating mintable token\n', '   * @param _depositAddress Address on which minted coins will be deposited\n', '   * @param _contractName Name of this contract for lookup in contract manager\n', '   * @param _contractManager Address where the contract manager is located\n', '   */\n', '  constructor(address _depositAddress, string _contractName, address _contractManager) public {\n', '    depositAddress = _depositAddress;\n', '    contractName = _contractName;\n', '    contractManager = ContractManagerInterface(_contractManager);\n', '  }\n', '\n', '  /**\n', '   * @notice Called when new tokens are needed in circulation\n', '   * @param _tokens Amount for tokens to be created\n', '   */\n', '  function mintTokens(uint256 _tokens) external {\n', '    require(!locked);\n', '    require(contractManager.authorize(contractName, msg.sender));\n', '    require(_tokens != 0);\n', '\n', '    totalSupply_ = totalSupply_.add(_tokens);\n', '    balances[depositAddress] = balances[depositAddress].add(_tokens);\n', '\n', '    emit TokensMinted(msg.sender, depositAddress, _tokens);\n', '  }\n', '  \n', '  /**\n', '   * @notice Called when tokens are bought in token sale\n', '   * @param _beneficiary Address on which tokens are deposited\n', '   * @param _tokens Amount of tokens to be created\n', '   */\n', '  function sendBoughtTokens(address _beneficiary, uint256 _tokens) external {\n', '    require(locked);\n', '    require(contractManager.authorize(contractName, msg.sender));\n', '    require(_beneficiary != address(0));\n', '    require(_tokens != 0);\n', '\n', '    totalSupply_ = totalSupply_.add(_tokens);\n', '    balances[depositAddress] = balances[depositAddress].add(_tokens);\n', '\n', '    emit TokensMinted(msg.sender, depositAddress, _tokens);\n', '\n', '    _transfer(depositAddress, _beneficiary, _tokens);\n', '  }\n', '\n', '  /**\n', '   * @notice Called when deposit address needs to change\n', '   * @param _depositAddress Address on which minted tokens are deposited\n', '   */\n', '  function changeDepositAddress(address _depositAddress) external {\n', '    require(contractManager.authorize(contractName, msg.sender));\n', '    require(_depositAddress != address(0));\n', '    require(_depositAddress != depositAddress);\n', '\n', '    address oldDepositAddress = depositAddress;\n', '    depositAddress = _depositAddress;\n', '\n', '    emit DepositAddressChanged(oldDepositAddress, _depositAddress);\n', '  }\n', '}\n', '\n', '// File: contracts/token/BurnableToken.sol\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @author Bram Hoven\n', ' * @notice Contract for a token which can be burned during the sale or after\n', ' */\n', 'contract BurnableToken is BurnableTokenInterface, MintableToken {\n', '\n', '  /**\n', '   * @notice Constructor for creating burnable token\n', '   * @param _depositAddress Address on which minted coins will be deposited\n', '   * @param _contractName Name of this contract for lookup in contract manager\n', '   * @param _contractManager Address where the contract manager is located\n', '   */\n', '  constructor(address _depositAddress, string _contractName, address _contractManager) public MintableToken(_depositAddress, _contractName, _contractManager) {\n', '  }\n', '\n', '  /**\n', '   * @notice Called when tokens have to be burned (only after sale)\n', '   * @param _tokens Amount of tokens to be burned\n', '   */\n', '  function burnTokens(uint256 _tokens) external {\n', '    require(!locked);\n', '    require(contractManager.authorize(contractName, msg.sender));\n', '\n', '    require(depositAddress != address(0));\n', '    require(_tokens != 0);\n', '    require(_tokens <= balances[depositAddress]);\n', '\n', '    balances[depositAddress] = balances[depositAddress].sub(_tokens);\n', '    totalSupply_ = totalSupply_.sub(_tokens);\n', '\n', '    emit TokensBurned(msg.sender, depositAddress, _tokens);\n', '  }\n', '}\n', '\n', '// File: contracts/token/FidaToken.sol\n', '\n', '/**\n', ' * @title Fida Token\n', ' * @author Bram Hoven\n', ' * @notice Token contract for the fida token\n', ' */\n', 'contract FidaToken is BurnableToken {\n', '  string public name = "fida";\n', '  string public symbol = "fida";\n', '  uint8 public decimals = 18;\n', '  \n', '  /**\n', '   * @notice Constructor which creates the fida token\n', '   * @param _depositAddress Address on which minted tokens are deposited\n', '   * @param _contractName Name of this contract for lookup in contract manager\n', '   * @param _contractManager Address where the contract manager is located\n', '   */\n', '  constructor(address _depositAddress, string _contractName, address _contractManager) public BurnableToken(_depositAddress, _contractName, _contractManager) {}\n', '\n', '  /**\n', '   * @notice Unlock tokens, hereafter they will be tradable\n', '   */\n', '  function unlockTokens() public {\n', '    require(contractManager.authorize(contractName, msg.sender));\n', '\n', '    BasicToken.unlockTokens();\n', '  }\n', '}']