['pragma solidity ^0.4.21;\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint256 z = x + y;\n', '      require((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      require(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint z = x * y;\n', '      require((x == 0) || (z / x == y));\n', '      return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '      bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '      return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => bool) internal authbook;\n', '    address[] public operators;\n', '    address public owner;\n', '    bool public powerStatus = true;\n', '    function Authorization()\n', '        public\n', '        payable\n', '    {\n', '        owner = msg.sender;\n', '        assignOperator(msg.sender);\n', '    }\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(checkOperator(msg.sender));\n', '        _;\n', '    }\n', '    modifier onlyActive\n', '    {\n', '        assert(powerStatus);\n', '        _;\n', '    }\n', '    function powerSwitch(\n', '        bool onOff_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        powerStatus = onOff_;\n', '    }\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if(user_ != address(0) && !authbook[user_]) {\n', '            authbook[user_] = true;\n', '            operators.push(user_);\n', '        }\n', '    }\n', '    \n', '    function dismissOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        delete authbook[user_];\n', '        for(uint i = 0; i < operators.length; i++) {\n', '            if(operators[i] == user_) {\n', '                operators[i] = operators[operators.length - 1];\n', '                operators.length -= 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function checkOperator(address user_)\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return authbook[user_];\n', '    }\n', '}\n', '\n', 'contract StandardToken is SafeMath {\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Issue(address indexed _to, uint256 indexed _value);\n', '    event Burn(address indexed _from, uint256 indexed _value);\n', '\n', '    /* constructure */\n', '    function StandardToken() public payable {}\n', '\n', '    /* Send coins */\n', '    function transfer(\n', '        address to_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        if(balances[msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], amount_);\n', '            balances[to_] = safeAdd(balances[to_], amount_);\n', '            emit Transfer(msg.sender, to_, amount_);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(\n', '        address from_,\n', '        address to_,\n', '        uint256 amount_\n', '    ) public returns(bool success) {\n', '        if(balances[from_] >= amount_ && allowed[from_][msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[to_] = safeAdd(balances[to_], amount_);\n', '            balances[from_] = safeSub(balances[from_], amount_);\n', '            allowed[from_][msg.sender] = safeSub(allowed[from_][msg.sender], amount_);\n', '            emit Transfer(from_, to_, amount_);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        constant\n', '        public\n', '    returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '    returns (bool success) {\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract XPAAssetToken is StandardToken, Authorization {\n', '    // metadata\n', '    address[] public burners;\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public defaultExchangeRate;\n', '    uint256 public constant decimals = 18;\n', '\n', '    // constructor\n', '    function XPAAssetToken(\n', '        string symbol_,\n', '        string name_,\n', '        uint256 defaultExchangeRate_\n', '    )\n', '        public\n', '    {\n', '        totalSupply = 0;\n', '        symbol = symbol_;\n', '        name = name_;\n', '        defaultExchangeRate = defaultExchangeRate_ > 0 ? defaultExchangeRate_ : 0.01 ether;\n', '    }\n', '\n', '    function transferOwnership(\n', '        address newOwner_\n', '    )\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '\n', '    function create(\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool success) {\n', '        if(amount_ > 0 && user_ != address(0)) {\n', '            totalSupply = safeAdd(totalSupply, amount_);\n', '            balances[user_] = safeAdd(balances[user_], amount_);\n', '            emit Issue(owner, amount_);\n', '            emit Transfer(owner, user_, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        require(allowToBurn(msg.sender));\n', '        if(amount_ > 0 && balances[msg.sender] >= amount_) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], amount_);\n', '            totalSupply = safeSub(totalSupply, amount_);\n', '            emit Transfer(msg.sender, owner, amount_);\n', '            emit Burn(owner, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burnFrom(\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        require(allowToBurn(msg.sender));\n', '        if(balances[user_] >= amount_ && allowed[user_][msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[user_] = safeSub(balances[user_], amount_);\n', '            totalSupply = safeSub(totalSupply, amount_);\n', '            allowed[user_][msg.sender] = safeSub(allowed[user_][msg.sender], amount_);\n', '            emit Transfer(user_, owner, amount_);\n', '            emit Burn(owner, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function getDefaultExchangeRate(\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return defaultExchangeRate;\n', '    }\n', '\n', '    function getSymbol(\n', '    )\n', '        public\n', '        view\n', '    returns(bytes32) {\n', '        return keccak256(symbol);\n', '    }\n', '\n', '    function assignBurner(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                return;\n', '            }\n', '        }\n', '        burners.push(account_);\n', '    }\n', '\n', '    function dismissBunner(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                burners[i] = burners[burners.length - 1];\n', '                burners.length -= 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function allowToBurn(\n', '        address account_\n', '    )\n', '        public\n', '        view\n', '    returns(bool) {\n', '        if(checkOperator(account_)) {\n', '            return true;\n', '        }\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '}']