['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', '     if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert( c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '    //assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    //assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public{\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOnwership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner,newOwner);\n', '        owner=newOwner;\n', '        newOwner=address(0);\n', '    }\n', '\n', '}\n', '\n', 'contract ContractReceiver { function tokenFallback(address _from,uint _value,bytes _data)  external;}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC223 is Owned{\n', '    //Use safemath library to check overflows and underflows\n', '    using SafeMath for uint256;\n', '\n', '    // Public variables of the token\n', '\n', '    string  public name="Littafi Token";\n', '    string  public symbol="LITT";\n', '    uint8   public decimals = 18;// 18 decimals is the strongly suggested default, avoid changing it\n', '    uint256 public totalSupply=1000000000; //1,000,000,000 tokens\n', '    address[] public littHolders;\n', '    uint256 public buyRate=10000;\n', '    bool    public saleIsOn=true;\n', '\n', '     //Admin structure\n', '    struct Admin{\n', '        bool isAdmin;\n', '        address beAdmin;\n', '    }\n', '\n', '    //Contract mutation access modifier\n', '    modifier onlyAdmin{\n', '        require(msg.sender == owner || admins[msg.sender].isAdmin);\n', '        _;\n', '    }\n', '\n', '    //Create an array of admins\n', '    mapping(address => Admin) admins;\n', '    \n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    //This notifies clients about an approval request for transferFrom()\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    //Notifies contract owner about a successfult terminated/destroyed contract\n', '    event LogContractDestroyed(address indexed contractAddress, bytes30 _extraData);\n', '\n', '    //Notifies clients about token sale\n', '    event LogTokenSale(address indexed _client, uint256 _amountTransacted);\n', '\n', '    //Notifies clients of newly set buy/sell prices\n', '    event LogNewPrices(address indexed _admin, uint256 _buyRate);\n', '\n', '    //Notifies of newly minted tokensevent\n', '    event LogMintedTokens(address indexed _this, uint256 _amount);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    constructor() public {\n', '        totalSupply = totalSupply*10**uint256(decimals);  // Update total supply with the decimal amount\n', '        balanceOf[this]=totalSupply;\n', '        Owned(msg.sender);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '\n', '    if(isContract(_to)) {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '        emit Transfer(msg.sender, _to, _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '\n', '        return true;\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '     }\n', '   }\n', '    \n', '    function transfer(address _to, uint256 _value, bytes _data)public  returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '     \n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, _data);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint256 _value)public returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '      \n', '     bytes memory empty;\n', '     if(isContract(_to)) {\n', '        return transferToContract(_to, _value, empty);\n', '     }\n', '     else {\n', '        return transferToAddress(_to, _value, empty);\n', '     }\n', '   }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) public view returns (bool) {\n', '      uint length;\n', '      assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '      }\n', '      return (length>0);\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '     require(balanceOf[msg.sender] > _value); \n', '     \n', '     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '     balanceOf[_to] = balanceOf[_to].add(_value);\n', '     emit Transfer(msg.sender, _to, _value, _data);\n', '     emit Transfer(msg.sender, _to, _value);\n', '     return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '     require(balanceOf[msg.sender] > _value); \n', '       \n', '     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '     balanceOf[_to] = balanceOf[_to].add(_value);\n', '     ContractReceiver receiver = ContractReceiver(_to);\n', '     receiver.tokenFallback(msg.sender, _value, _data);\n', '     emit Transfer(msg.sender, _to, _value);\n', '     emit Transfer(msg.sender, _to, _value, _data);\n', '     return true;\n', '    }\n', '\n', '    function transferToOwner(uint256 _amount) public onlyOwner(){\n', '        require(balanceOf[this] > convert(_amount));\n', '        uint256 amount=convert(_amount);\n', '        balanceOf[this]=balanceOf[this].sub(amount);\n', '        balanceOf[owner]=balanceOf[owner].add(amount);\n', '        emit Transfer(this,owner,amount);\n', '    }\n', '    /**\n', '     * Conversion\n', '     *\n', '     * @param _value convert to proper value for math operations\n', '     *///0x44b6782dde9118baafe20a39098b1b46589cd378\n', '    function convert(uint256 _value) internal view returns (uint256) {\n', '         return _value*10**uint256(decimals);\n', '     }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public onlyOwner {\n', '        require(balanceOf[this] >= convert(_value)); \n', '        uint256 value=convert(_value);\n', '        // Check if the contract has enough\n', '        balanceOf[this]=balanceOf[this].sub(value);    // Subtract from the contract\n', '        totalSupply=totalSupply.sub(value);     // Updates totalSupply\n', '        emit Burn(this, value);\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze) public onlyAdmin {\n', '        require(target != owner);\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function mintToken(uint256 mintedAmount) public onlyOwner {\n', '        uint256 mint=convert(mintedAmount);\n', '        balanceOf[this] =balanceOf[this].add(mint);\n', '        totalSupply =totalSupply.add(mint);\n', '\n', '        emit LogMintedTokens(this, mint);\n', '    }\n', '\n', '    function setPrices(uint256 newBuyRate) public onlyAdmin{\n', '        buyRate = newBuyRate;\n', '        emit LogNewPrices(msg.sender,buyRate);\n', '    }\n', '\n', '    function buy() payable public {\n', '        require(msg.value > 0);\n', '        require(msg.sender != owner && saleIsOn == true);\n', '        uint256 amount=msg.value.mul(buyRate);\n', '        uint256 percentile=amount.add(getEthRate(msg.value).mul(amount).div(100));\n', '        balanceOf[msg.sender]=balanceOf[msg.sender].add(percentile);  // calculates the amount and makes the transaction\n', '        balanceOf[this]=balanceOf[this].sub(percentile);\n', '        littHolders.push(msg.sender);\n', '        owner.transfer(msg.value);\n', '        emit LogTokenSale(msg.sender,percentile);\n', '    }\n', '\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    function destroyContract() public onlyOwner {\n', '       selfdestruct(owner);\n', '       transferOwnership(0x0);\n', '       emit LogContractDestroyed(this, "Contract has been destroyed");\n', '   }\n', '   \n', '    function getEthRate(uint256 _value) private pure returns(uint256){\n', '       require(_value > 0 );\n', '       if(_value < 3 ether)\n', '         return 10;\n', '       if(_value >= 3 ether && _value < 5 ether )\n', '         return 20;\n', '       if(_value >= 5 ether && _value < 24 ether )\n', '         return 30;\n', '       if(_value >= 24 ether )\n', '         return 40;\n', '   }\n', '   \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n', '        transfer(_to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender,_spender,_value);\n', '        return true;\n', '    }\n', '    \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '   \n', '    function setName(string _name) public onlyOwner() returns (bool success) {\n', '        name=_name;\n', '        return true;\n', '    }\n', '    \n', '    function setSaleStatus(bool _bool) public onlyOwner() returns (bool success){\n', '        saleIsOn=_bool;\n', '        return true;\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', '     if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert( c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '    //assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    //assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public{\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOnwership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner,newOwner);\n', '        owner=newOwner;\n', '        newOwner=address(0);\n', '    }\n', '\n', '}\n', '\n', 'contract ContractReceiver { function tokenFallback(address _from,uint _value,bytes _data)  external;}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract TokenERC223 is Owned{\n', '    //Use safemath library to check overflows and underflows\n', '    using SafeMath for uint256;\n', '\n', '    // Public variables of the token\n', '\n', '    string  public name="Littafi Token";\n', '    string  public symbol="LITT";\n', '    uint8   public decimals = 18;// 18 decimals is the strongly suggested default, avoid changing it\n', '    uint256 public totalSupply=1000000000; //1,000,000,000 tokens\n', '    address[] public littHolders;\n', '    uint256 public buyRate=10000;\n', '    bool    public saleIsOn=true;\n', '\n', '     //Admin structure\n', '    struct Admin{\n', '        bool isAdmin;\n', '        address beAdmin;\n', '    }\n', '\n', '    //Contract mutation access modifier\n', '    modifier onlyAdmin{\n', '        require(msg.sender == owner || admins[msg.sender].isAdmin);\n', '        _;\n', '    }\n', '\n', '    //Create an array of admins\n', '    mapping(address => Admin) admins;\n', '    \n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    //This notifies clients about an approval request for transferFrom()\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    //Notifies contract owner about a successfult terminated/destroyed contract\n', '    event LogContractDestroyed(address indexed contractAddress, bytes30 _extraData);\n', '\n', '    //Notifies clients about token sale\n', '    event LogTokenSale(address indexed _client, uint256 _amountTransacted);\n', '\n', '    //Notifies clients of newly set buy/sell prices\n', '    event LogNewPrices(address indexed _admin, uint256 _buyRate);\n', '\n', '    //Notifies of newly minted tokensevent\n', '    event LogMintedTokens(address indexed _this, uint256 _amount);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    constructor() public {\n', '        totalSupply = totalSupply*10**uint256(decimals);  // Update total supply with the decimal amount\n', '        balanceOf[this]=totalSupply;\n', '        Owned(msg.sender);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '\n', '    if(isContract(_to)) {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '        emit Transfer(msg.sender, _to, _value);\n', '        emit Transfer(msg.sender, _to, _value, _data);\n', '\n', '        return true;\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '     }\n', '   }\n', '    \n', '    function transfer(address _to, uint256 _value, bytes _data)public  returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '     \n', '    if(isContract(_to)) {\n', '        return transferToContract(_to, _value, _data);\n', '    }\n', '    else {\n', '        return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint256 _value)public returns (bool success) {\n', '     require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n', '      \n', '     bytes memory empty;\n', '     if(isContract(_to)) {\n', '        return transferToContract(_to, _value, empty);\n', '     }\n', '     else {\n', '        return transferToAddress(_to, _value, empty);\n', '     }\n', '   }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) public view returns (bool) {\n', '      uint length;\n', '      assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '      }\n', '      return (length>0);\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '     require(balanceOf[msg.sender] > _value); \n', '     \n', '     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '     balanceOf[_to] = balanceOf[_to].add(_value);\n', '     emit Transfer(msg.sender, _to, _value, _data);\n', '     emit Transfer(msg.sender, _to, _value);\n', '     return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) {\n', '     require(balanceOf[msg.sender] > _value); \n', '       \n', '     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '     balanceOf[_to] = balanceOf[_to].add(_value);\n', '     ContractReceiver receiver = ContractReceiver(_to);\n', '     receiver.tokenFallback(msg.sender, _value, _data);\n', '     emit Transfer(msg.sender, _to, _value);\n', '     emit Transfer(msg.sender, _to, _value, _data);\n', '     return true;\n', '    }\n', '\n', '    function transferToOwner(uint256 _amount) public onlyOwner(){\n', '        require(balanceOf[this] > convert(_amount));\n', '        uint256 amount=convert(_amount);\n', '        balanceOf[this]=balanceOf[this].sub(amount);\n', '        balanceOf[owner]=balanceOf[owner].add(amount);\n', '        emit Transfer(this,owner,amount);\n', '    }\n', '    /**\n', '     * Conversion\n', '     *\n', '     * @param _value convert to proper value for math operations\n', '     *///0x44b6782dde9118baafe20a39098b1b46589cd378\n', '    function convert(uint256 _value) internal view returns (uint256) {\n', '         return _value*10**uint256(decimals);\n', '     }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public onlyOwner {\n', '        require(balanceOf[this] >= convert(_value)); \n', '        uint256 value=convert(_value);\n', '        // Check if the contract has enough\n', '        balanceOf[this]=balanceOf[this].sub(value);    // Subtract from the contract\n', '        totalSupply=totalSupply.sub(value);     // Updates totalSupply\n', '        emit Burn(this, value);\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze) public onlyAdmin {\n', '        require(target != owner);\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function mintToken(uint256 mintedAmount) public onlyOwner {\n', '        uint256 mint=convert(mintedAmount);\n', '        balanceOf[this] =balanceOf[this].add(mint);\n', '        totalSupply =totalSupply.add(mint);\n', '\n', '        emit LogMintedTokens(this, mint);\n', '    }\n', '\n', '    function setPrices(uint256 newBuyRate) public onlyAdmin{\n', '        buyRate = newBuyRate;\n', '        emit LogNewPrices(msg.sender,buyRate);\n', '    }\n', '\n', '    function buy() payable public {\n', '        require(msg.value > 0);\n', '        require(msg.sender != owner && saleIsOn == true);\n', '        uint256 amount=msg.value.mul(buyRate);\n', '        uint256 percentile=amount.add(getEthRate(msg.value).mul(amount).div(100));\n', '        balanceOf[msg.sender]=balanceOf[msg.sender].add(percentile);  // calculates the amount and makes the transaction\n', '        balanceOf[this]=balanceOf[this].sub(percentile);\n', '        littHolders.push(msg.sender);\n', '        owner.transfer(msg.value);\n', '        emit LogTokenSale(msg.sender,percentile);\n', '    }\n', '\n', '    function () public payable {\n', '        buy();\n', '    }\n', '\n', '    function destroyContract() public onlyOwner {\n', '       selfdestruct(owner);\n', '       transferOwnership(0x0);\n', '       emit LogContractDestroyed(this, "Contract has been destroyed");\n', '   }\n', '   \n', '    function getEthRate(uint256 _value) private pure returns(uint256){\n', '       require(_value > 0 );\n', '       if(_value < 3 ether)\n', '         return 10;\n', '       if(_value >= 3 ether && _value < 5 ether )\n', '         return 20;\n', '       if(_value >= 5 ether && _value < 24 ether )\n', '         return 30;\n', '       if(_value >= 24 ether )\n', '         return 40;\n', '   }\n', '   \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n', '        transfer(_to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender,_spender,_value);\n', '        return true;\n', '    }\n', '    \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '   \n', '    function setName(string _name) public onlyOwner() returns (bool success) {\n', '        name=_name;\n', '        return true;\n', '    }\n', '    \n', '    function setSaleStatus(bool _bool) public onlyOwner() returns (bool success){\n', '        saleIsOn=_bool;\n', '        return true;\n', '    }\n', '\n', '\n', '}']
