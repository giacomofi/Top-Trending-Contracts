['pragma solidity ^0.4.16;\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        safeassert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        safeassert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        safeassert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '    \n', '    function safeassert(bool assertion) internal {\n', '        require(assertion);\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    function Owner() {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address new_owner) onlyOwner public {\n', '        require(new_owner != 0x0);\n', '        owner = new_owner;\n', '    }\n', '}\n', '\n', 'contract EtherIncPrivate is ERC20Interface,Owner,SafeMath {\n', '    string public symbol;\n', '    string public name;\n', '    uint public decimals = 18;\n', '    \n', '    uint256 rate = 2000;\n', '    \n', '    uint256 _totalSupply;\n', '    bool privateIco = true;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    mapping(address => uint256) balances;\n', '    mapping(address => Whitelist) public whitelist;\n', '    mapping(address => uint256) public withdrawable;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    \n', '    \n', '    struct Whitelist {\n', '        uint256 amount;\n', '        address beneficiary;\n', '        bool active;\n', '    }\n', '    \n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4) ;\n', '        _;\n', '    }\n', '    \n', '    function endprivateIco(bool __status) onlyOwner public {\n', '        if(__status){\n', '            privateIco = false;\n', '        }\n', '    }\n', '    \n', '    function totalSupply() constant returns (uint256 __totalSupply) {        \n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function EtherIncPrivate() {\n', '        name = "EtherInc Private";\n', '        symbol = "ETI-P";\n', '        owner = msg.sender;\n', '        _totalSupply = 0;\n', '    }\n', '    \n', '    function () payable {\n', '        require(privateIco);\n', '        Whitelist storage w = whitelist[msg.sender];\n', '        require(w.active && msg.value >= w.amount);\n', '        uint256 token_amount = safeMul(msg.value, rate);\n', '        _totalSupply = safeAdd(_totalSupply, token_amount);\n', '        balances[msg.sender] = token_amount;\n', '        (w.beneficiary).transfer(msg.value);\n', '        Transfer(address(this), msg.sender, token_amount);\n', '    }\n', '    \n', '    function transfer(\n', '        address _to, uint256 _amount\n', '    ) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0\n', '            && safeAdd(balances[_to], _amount) > balances[_to]) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '        if (balances[_from] >= _amount\n', '        && allowed[_from][msg.sender] >= _amount\n', '        && _amount > 0\n', '        && safeAdd(balances[_to], _amount) > balances[_to]) {\n', '            balances[_from] = safeSub(balances[_from], _amount);\n', '            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _amount);\n', '            balances[_to] = safeAdd(balances[_to], _amount);\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function approve(\n', '        address _spender, uint256 _amount\n', '    ) public returns (bool success) {\n', '        require(balances[msg.sender] >= _amount);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(\n', '        address _owner, address _spender\n', '    ) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function whitelist_pool(\n', '        address _pool, address _beneficiary, uint _amount\n', '    ) onlyPayloadSize(2 * 32) onlyOwner public returns (bool success) {\n', '        Whitelist storage w = whitelist[_pool];\n', '        // check already whitelisted \n', '        require(!w.active);\n', '        \n', '        w.active = true;\n', '        w.beneficiary = _beneficiary;\n', '        w.amount = _amount * 1 ether;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function withdraw_to_eti() onlyPayloadSize(2 * 32) public returns (bool success) {\n', '        require(privateIco && balances[msg.sender] > 0);\n', '        \n', '        uint256 amount = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        withdrawable[msg.sender] = amount;\n', '        return true;\n', '    }\n', '}']