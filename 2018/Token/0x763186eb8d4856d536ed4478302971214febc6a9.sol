['pragma solidity ^0.4.18;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '        return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}\n', '\n', 'contract BETR_TOKEN {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "Better Betting";\n', '    string public symbol = "BETR";\n', '    uint256 public constant decimals = 18;\n', '\n', '    uint256 public hardCap = 650000000 * (10 ** decimals);\n', '    uint256 public totalSupply;\n', '\n', '    address public escrow; // reference to escrow contract for transaction and authorization\n', '    address public owner; // reference to the contract creator\n', '    address public tgeIssuer = 0xba81ACCC7074B5D9ABDAa25c30DbaD96BF44D660;\n', '\n', '    bool public tgeActive;\n', '    uint256 public tgeDuration = 30 days;\n', '    uint256 public tgeStartTime;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed; // third party authorisations for token transfering\n', '    mapping (address => bool) public escrowAllowed; // per address switch authorizing the escrow to escrow user tokens\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function BETR_TOKEN() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTgeIssuer {\n', '        require(msg.sender == tgeIssuer);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEscrow {\n', '        require(msg.sender == escrow);\n', '        _;\n', '    }\n', '\n', '    modifier tgeRunning {\n', '        require(tgeActive && block.timestamp < tgeStartTime + tgeDuration);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(\n', '            _to != address(0) &&\n', '            balances[msg.sender] >= _value &&\n', '            balances[_to] + _value > balances[_to]\n', '        );\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require (\n', '          _from != address(0) &&\n', '          _to != address(0) &&\n', '          balances[_from] >= _value &&\n', '          allowed[_from][msg.sender] >= _value &&\n', '          balances[_to] + _value > balances[_to]\n', '        );\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(_spender != address(0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowEscrow(bool _choice) external returns(bool) {\n', '      escrowAllowed[msg.sender] = _choice;\n', '      return true;\n', '    }\n', '\n', '    function escrowFrom(address _from, uint256 _value) external onlyEscrow returns(bool) {\n', '      require (\n', '        _from != address(0) &&\n', '        balances[_from] >= _value &&\n', '        escrowAllowed[_from] &&\n', '        _value > 0\n', '      );\n', '      balances[_from] = balances[_from].sub(_value);\n', '      balances[escrow] = balances[escrow].add(_value);\n', '      Transfer(_from, escrow, _value);\n', '      return true;\n', '    }\n', '\n', '    function escrowReturn(address _to, uint256 _value, uint256 _fee) external onlyEscrow returns(bool) {\n', '        require(\n', '            _to != address(0) &&\n', '            _value > 0\n', '        );\n', '        if(_fee > 0) {\n', '            require(_fee < totalSupply && _fee < balances[escrow]);\n', '            totalSupply = totalSupply.sub(_fee);\n', '            balances[escrow] = balances[escrow].sub(_fee);\n', '        }\n', '        require(transfer(_to, _value));\n', '        return true;\n', '    }\n', '\n', '    function mint(address _user, uint256 _tokensAmount) public onlyTgeIssuer tgeRunning returns(bool) {\n', '        uint256 newSupply = totalSupply.add(_tokensAmount);\n', '        require(\n', '            _user != address(0) &&\n', '            _tokensAmount > 0 &&\n', '             newSupply < hardCap\n', '        );\n', '        balances[_user] = balances[_user].add(_tokensAmount);\n', '        totalSupply = newSupply;\n', '        Transfer(0x0, _user, _tokensAmount);\n', '        return true;\n', '    }\n', '\n', '    function reserveTokensGroup(address[] _users, uint256[] _tokensAmounts) external onlyOwner {\n', '        require(_users.length == _tokensAmounts.length);\n', '        uint256 newSupply;\n', '        for(uint8 i = 0; i < _users.length; i++){\n', '            newSupply = totalSupply.add(_tokensAmounts[i].mul(10 ** decimals));\n', '            require(\n', '                _users[i] != address(0) &&\n', '                _tokensAmounts[i] > 0 &&\n', '                newSupply < hardCap\n', '            );\n', '            balances[_users[i]] = balances[_users[i]].add(_tokensAmounts[i].mul(10 ** decimals));\n', '            totalSupply = newSupply;\n', '            Transfer(0x0, _users[i], _tokensAmounts[i]);\n', '        }\n', '    }\n', '\n', '    function reserveTokens(address _user, uint256 _tokensAmount) external onlyOwner {\n', '        uint256 newSupply = totalSupply.add(_tokensAmount.mul(10 ** decimals));\n', '        require(\n', '            _user != address(0) &&\n', '            _tokensAmount > 0 &&\n', '            newSupply < hardCap\n', '        );\n', '        balances[_user] = balances[_user].add(_tokensAmount.mul(10 ** decimals));\n', '        totalSupply = newSupply;\n', '        Transfer(0x0, _user, _tokensAmount);\n', '    }\n', '\n', '    function startTge() external onlyOwner {\n', '        tgeActive = true;\n', '        if(tgeStartTime == 0) tgeStartTime = block.timestamp;\n', '    }\n', '\n', '    function stopTge(bool _restart) external onlyOwner {\n', '      tgeActive = false;\n', '      if(_restart) tgeStartTime = 0;\n', '    }\n', '\n', '    function extendTge(uint256 _time) external onlyOwner {\n', '      tgeDuration = tgeDuration.add(_time);\n', '    }\n', '\n', '    function setEscrow(address _escrow) external onlyOwner {\n', '        escrow = _escrow;\n', '    }\n', '\n', '    function setTgeIssuer(address _tgeIssuer) external onlyOwner {\n', '        tgeIssuer = _tgeIssuer;\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']