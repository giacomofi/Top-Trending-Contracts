['pragma solidity ^0.4.24;\n', '\n', '/** \n', 'Do not transfer tokens to TimelockERC20 directly (via transfer method)! Tokens will be stuck permanently.\n', 'Use approvals and accept method.\n', '**/\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', 'contract IERC20{\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '  function transferFrom(address from, address to, uint value) external returns (bool);\n', '  function approve(address spender, uint value) external returns (bool);\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address who) external view returns (uint);\n', '  function transfer(address to, uint value) external returns (bool);\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract ITimeMachine {\n', '  function getTimestamp_() internal view returns (uint);\n', '}\n', '\n', '\n', 'contract TimeMachineP is ITimeMachine {\n', '  /**\n', '  * @dev get current real timestamp\n', '  * @return current real timestamp\n', '  */\n', '  function getTimestamp_() internal view returns(uint) {\n', '    return block.timestamp;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract SafeERC20Timelock is ITimeMachine, Ownable {\n', '  using SafeMath for uint;\n', '\n', '  event Lock(address indexed _from, address indexed _for, uint indexed timestamp, uint value);\n', '  event Withdraw(address indexed _for, uint indexed timestamp, uint value);\n', '\n', '\n', '\n', '  mapping (address => mapping(uint => uint)) public balance;\n', '  IERC20 public token;\n', '  uint public totalBalance;\n', '\n', '  constructor (address _token) public {\n', '    token = IERC20(_token);\n', '  }\n', '\n', '  function contractBalance_() internal view returns(uint) {\n', '    return token.balanceOf(this);\n', '  }\n', '\n', '  /**\n', '  * @dev accept token into timelock\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp lock timestamp\n', '  * @return result of operation: true if success\n', '  */\n', '  function accept(address _for, uint _timestamp, uint _tvalue) public returns(bool){\n', '    require(_for != address(0));\n', '    require(_for != address(this));\n', '    require(_timestamp > getTimestamp_());\n', '    require(_tvalue > 0);\n', '    uint _contractBalance = contractBalance_();\n', '    uint _balance = balance[_for][_timestamp];\n', '    uint _totalBalance = totalBalance;\n', '    require(token.transferFrom(msg.sender, this, _tvalue));\n', '    uint _value = contractBalance_().sub(_contractBalance);\n', '    balance[_for][_timestamp] = _balance.add(_value);\n', '    totalBalance = _totalBalance.add(_value);\n', '    emit Lock(msg.sender, _for, _timestamp, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev release timelock tokens\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function release_(address _for, uint[] _timestamp, uint[] _value) internal returns(bool) {\n', '    uint _len = _timestamp.length;\n', '    require(_len == _value.length);\n', '    uint _totalValue;\n', '    uint _curValue;\n', '    uint _curTimestamp;\n', '    uint _subValue;\n', '    uint _now = getTimestamp_();\n', '    for (uint i = 0; i < _len; i++){\n', '      _curTimestamp = _timestamp[i];\n', '      _curValue = balance[_for][_curTimestamp];\n', '      _subValue = _value[i];\n', '      require(_curValue >= _subValue);\n', '      require(_curTimestamp <= _now);\n', '      balance[_for][_curTimestamp] = _curValue.sub(_subValue);\n', '      _totalValue = _totalValue.add(_subValue);\n', '      emit Withdraw(_for, _curTimestamp, _subValue);\n', '    }\n', '    totalBalance = totalBalance.sub(_totalValue);\n', '    require(token.transfer(_for, _totalValue));\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev release timelock tokens\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function release(uint[] _timestamp, uint[] _value) external returns(bool) {\n', '    return release_(msg.sender, _timestamp, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev release timelock tokens by force\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function releaseForce(address _for, uint[] _timestamp, uint[] _value) external returns(bool) {\n', '    return release_(_for, _timestamp, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Allow to use functions of other contract from this contract\n', '  * @param _token address of ERC20 contract to call\n', '  * @param _to address to transfer ERC20 tokens\n', '  * @param _amount amount to transfer\n', '  * @return result of operation, true if success\n', '  */\n', '  function saveLockedERC20Tokens(address _token, address _to, uint  _amount) onlyOwner external returns (bool) {\n', '    require(IERC20(_token).transfer(_to, _amount));\n', '    require(totalBalance <= contractBalance_());\n', '    return true;\n', '  }\n', '\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', 'contract SafeERC20TimelockProd is TimeMachineP, SafeERC20Timelock {\n', '  constructor () public SafeERC20Timelock(0x45245bc59219eeaaf6cd3f382e078a461ff9de7b) {\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/** \n', 'Do not transfer tokens to TimelockERC20 directly (via transfer method)! Tokens will be stuck permanently.\n', 'Use approvals and accept method.\n', '**/\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', 'contract IERC20{\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '  function transferFrom(address from, address to, uint value) external returns (bool);\n', '  function approve(address spender, uint value) external returns (bool);\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address who) external view returns (uint);\n', '  function transfer(address to, uint value) external returns (bool);\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract ITimeMachine {\n', '  function getTimestamp_() internal view returns (uint);\n', '}\n', '\n', '\n', 'contract TimeMachineP is ITimeMachine {\n', '  /**\n', '  * @dev get current real timestamp\n', '  * @return current real timestamp\n', '  */\n', '  function getTimestamp_() internal view returns(uint) {\n', '    return block.timestamp;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract SafeERC20Timelock is ITimeMachine, Ownable {\n', '  using SafeMath for uint;\n', '\n', '  event Lock(address indexed _from, address indexed _for, uint indexed timestamp, uint value);\n', '  event Withdraw(address indexed _for, uint indexed timestamp, uint value);\n', '\n', '\n', '\n', '  mapping (address => mapping(uint => uint)) public balance;\n', '  IERC20 public token;\n', '  uint public totalBalance;\n', '\n', '  constructor (address _token) public {\n', '    token = IERC20(_token);\n', '  }\n', '\n', '  function contractBalance_() internal view returns(uint) {\n', '    return token.balanceOf(this);\n', '  }\n', '\n', '  /**\n', '  * @dev accept token into timelock\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp lock timestamp\n', '  * @return result of operation: true if success\n', '  */\n', '  function accept(address _for, uint _timestamp, uint _tvalue) public returns(bool){\n', '    require(_for != address(0));\n', '    require(_for != address(this));\n', '    require(_timestamp > getTimestamp_());\n', '    require(_tvalue > 0);\n', '    uint _contractBalance = contractBalance_();\n', '    uint _balance = balance[_for][_timestamp];\n', '    uint _totalBalance = totalBalance;\n', '    require(token.transferFrom(msg.sender, this, _tvalue));\n', '    uint _value = contractBalance_().sub(_contractBalance);\n', '    balance[_for][_timestamp] = _balance.add(_value);\n', '    totalBalance = _totalBalance.add(_value);\n', '    emit Lock(msg.sender, _for, _timestamp, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev release timelock tokens\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function release_(address _for, uint[] _timestamp, uint[] _value) internal returns(bool) {\n', '    uint _len = _timestamp.length;\n', '    require(_len == _value.length);\n', '    uint _totalValue;\n', '    uint _curValue;\n', '    uint _curTimestamp;\n', '    uint _subValue;\n', '    uint _now = getTimestamp_();\n', '    for (uint i = 0; i < _len; i++){\n', '      _curTimestamp = _timestamp[i];\n', '      _curValue = balance[_for][_curTimestamp];\n', '      _subValue = _value[i];\n', '      require(_curValue >= _subValue);\n', '      require(_curTimestamp <= _now);\n', '      balance[_for][_curTimestamp] = _curValue.sub(_subValue);\n', '      _totalValue = _totalValue.add(_subValue);\n', '      emit Withdraw(_for, _curTimestamp, _subValue);\n', '    }\n', '    totalBalance = totalBalance.sub(_totalValue);\n', '    require(token.transfer(_for, _totalValue));\n', '    return true;\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev release timelock tokens\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function release(uint[] _timestamp, uint[] _value) external returns(bool) {\n', '    return release_(msg.sender, _timestamp, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev release timelock tokens by force\n', '  * @param _for address of future tokenholder\n', '  * @param _timestamp array of timestamps to unlock\n', '  * @param _value array of amounts to unlock\n', '  * @return result of operation: true if success\n', '  */\n', '  function releaseForce(address _for, uint[] _timestamp, uint[] _value) external returns(bool) {\n', '    return release_(_for, _timestamp, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Allow to use functions of other contract from this contract\n', '  * @param _token address of ERC20 contract to call\n', '  * @param _to address to transfer ERC20 tokens\n', '  * @param _amount amount to transfer\n', '  * @return result of operation, true if success\n', '  */\n', '  function saveLockedERC20Tokens(address _token, address _to, uint  _amount) onlyOwner external returns (bool) {\n', '    require(IERC20(_token).transfer(_to, _amount));\n', '    require(totalBalance <= contractBalance_());\n', '    return true;\n', '  }\n', '\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', 'contract SafeERC20TimelockProd is TimeMachineP, SafeERC20Timelock {\n', '  constructor () public SafeERC20Timelock(0x45245bc59219eeaaf6cd3f382e078a461ff9de7b) {\n', '  }\n', '}']
