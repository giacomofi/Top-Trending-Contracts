['pragma solidity 0.4.18;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library MathUtils {\n', '    using SafeMath for uint256;\n', '\n', '    // Divisor used for representing percentages\n', '    uint256 public constant PERC_DIVISOR = 1000000;\n', '\n', '    /*\n', '     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\n', '     * @param _amount Amount that is supposed to be a percentage\n', '     */\n', '    function validPerc(uint256 _amount) internal pure returns (bool) {\n', '        return _amount <= PERC_DIVISOR;\n', '    }\n', '\n', '    /*\n', '     * @dev Compute percentage of a value with the percentage represented by a fraction\n', '     * @param _amount Amount to take the percentage of\n', '     * @param _fracNum Numerator of fraction representing the percentage\n', '     * @param _fracDenom Denominator of fraction representing the percentage\n', '     */\n', '    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n', '        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\n', '    }\n', '\n', '    /*\n', '     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\n', '     * @param _amount Amount to take the percentage of\n', '     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\n', '     */\n', '    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\n', '        return _amount.mul(_fracNum).div(PERC_DIVISOR);\n', '    }\n', '\n', '    /*\n', '     * @dev Compute percentage representation of a fraction\n', '     * @param _fracNum Numerator of fraction represeting the percentage\n', '     * @param _fracDenom Denominator of fraction represeting the percentage\n', '     */\n', '    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n', '        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\n', '    }\n', '}\n', '\n', 'contract ILivepeerToken is ERC20, Ownable {\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function burn(uint256 _amount) public;\n', '}\n', '\n', 'contract IController is Pausable {\n', '    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\n', '\n', '    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\n', '    function updateController(bytes32 _id, address _controller) external;\n', '    function getContract(bytes32 _id) public view returns (address);\n', '}\n', '\n', 'contract IManager {\n', '    event SetController(address controller);\n', '    event ParameterUpdate(string param);\n', '\n', '    function setController(address _controller) external;\n', '}\n', '\n', 'contract Manager is IManager {\n', '    // Controller that contract is registered with\n', '    IController public controller;\n', '\n', '    // Check if sender is controller\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller));\n', '        _;\n', '    }\n', '\n', '    // Check if sender is controller owner\n', '    modifier onlyControllerOwner() {\n', '        require(msg.sender == controller.owner());\n', '        _;\n', '    }\n', '\n', '    // Check if controller is not paused\n', '    modifier whenSystemNotPaused() {\n', '        require(!controller.paused());\n', '        _;\n', '    }\n', '\n', '    // Check if controller is paused\n', '    modifier whenSystemPaused() {\n', '        require(controller.paused());\n', '        _;\n', '    }\n', '\n', '    function Manager(address _controller) public {\n', '        controller = IController(_controller);\n', '    }\n', '\n', '    /*\n', '     * @dev Set controller. Only callable by current controller\n', '     * @param _controller Controller contract address\n', '     */\n', '    function setController(address _controller) external onlyController {\n', '        controller = IController(_controller);\n', '\n', '        SetController(_controller);\n', '    }\n', '}\n', '\n', '/*\n', ' * @title Interface for BondingManager\n', ' */\n', 'contract IBondingManager {\n', '    event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\n', '    event TranscoderEvicted(address indexed transcoder);\n', '    event TranscoderResigned(address indexed transcoder);\n', '    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\n', '    event Reward(address indexed transcoder, uint256 amount);\n', '    event Bond(address indexed delegate, address indexed delegator);\n', '    event Unbond(address indexed delegate, address indexed delegator);\n', '    event WithdrawStake(address indexed delegator);\n', '    event WithdrawFees(address indexed delegator);\n', '\n', '    // External functions\n', '    function setActiveTranscoders() external;\n', '    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\n', '    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\n', '    function electActiveTranscoder(uint256 _maxPricePerSegment, bytes32 _blockHash, uint256 _round) external view returns (address);\n', '\n', '    // Public functions\n', '    function transcoderTotalStake(address _transcoder) public view returns (uint256);\n', '    function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256);\n', '    function isRegisteredTranscoder(address _transcoder) public view returns (bool);\n', '    function getTotalBonded() public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title RoundsManager interface\n', ' */\n', 'contract IRoundsManager {\n', '    // Events\n', '    event NewRound(uint256 round);\n', '\n', '    // External functions\n', '    function initializeRound() external;\n', '\n', '    // Public functions\n', '    function blockNum() public view returns (uint256);\n', '    function blockHash(uint256 _block) public view returns (bytes32);\n', '    function currentRound() public view returns (uint256);\n', '    function currentRoundStartBlock() public view returns (uint256);\n', '    function currentRoundInitialized() public view returns (bool);\n', '    function currentRoundLocked() public view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Minter interface\n', ' */\n', 'contract IMinter {\n', '    // Events\n', '    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\n', '\n', '    // External functions\n', '    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\n', '    function trustedTransferTokens(address _to, uint256 _amount) external;\n', '    function trustedBurnTokens(uint256 _amount) external;\n', '    function trustedWithdrawETH(address _to, uint256 _amount) external;\n', '    function depositETH() external payable returns (bool);\n', '    function setCurrentRewardTokens() external;\n', '\n', '    // Public functions\n', '    function getController() public view returns (IController);\n', '}\n', '\n', '/**\n', ' * @title Minter\n', ' * @dev Manages inflation rate and the minting of new tokens for each round of the Livepeer protocol\n', ' */\n', 'contract Minter is Manager, IMinter {\n', '    using SafeMath for uint256;\n', '\n', '    // Per round inflation rate\n', '    uint256 public inflation;\n', '    // Change in inflation rate per round until the target bonding rate is achieved\n', '    uint256 public inflationChange;\n', '    // Target bonding rate\n', '    uint256 public targetBondingRate;\n', '\n', '    // Current number of mintable tokens. Reset every round\n', '    uint256 public currentMintableTokens;\n', '    // Current number of minted tokens. Reset every round\n', '    uint256 public currentMintedTokens;\n', '\n', '    // Checks if caller is BondingManager\n', '    modifier onlyBondingManager() {\n', '        require(msg.sender == controller.getContract(keccak256("BondingManager")));\n', '        _;\n', '    }\n', '\n', '    // Checks if caller is RoundsManager\n', '    modifier onlyRoundsManager() {\n', '        require(msg.sender == controller.getContract(keccak256("RoundsManager")));\n', '        _;\n', '    }\n', '\n', '    // Checks if caller is either BondingManager or JobsManager\n', '    modifier onlyBondingManagerOrJobsManager() {\n', '        require(msg.sender == controller.getContract(keccak256("BondingManager")) || msg.sender == controller.getContract(keccak256("JobsManager")));\n', '        _;\n', '    }\n', '\n', '    // Checks if caller is either the currently registered Minter or JobsManager\n', '    modifier onlyMinterOrJobsManager() {\n', '        require(msg.sender == controller.getContract(keccak256("Minter")) || msg.sender == controller.getContract(keccak256("JobsManager")));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Minter constructor\n', '     * @param _inflation Base inflation rate as a percentage of current total token supply\n', '     * @param _inflationChange Change in inflation rate each round (increase or decrease) if target bonding rate is not achieved\n', '     * @param _targetBondingRate Target bonding rate as a percentage of total bonded tokens / total token supply\n', '     */\n', '    function Minter(address _controller, uint256 _inflation, uint256 _inflationChange, uint256 _targetBondingRate) public Manager(_controller) {\n', '        // Inflation must be valid percentage\n', '        require(MathUtils.validPerc(_inflation));\n', '        // Inflation change must be valid percentage\n', '        require(MathUtils.validPerc(_inflationChange));\n', '        // Target bonding rate must be valid percentage\n', '        require(MathUtils.validPerc(_targetBondingRate));\n', '\n', '        inflation = _inflation;\n', '        inflationChange = _inflationChange;\n', '        targetBondingRate = _targetBondingRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Set targetBondingRate. Only callable by Controller owner\n', '     * @param _targetBondingRate Target bonding rate as a percentage of total bonded tokens / total token supply\n', '     */\n', '    function setTargetBondingRate(uint256 _targetBondingRate) external onlyControllerOwner {\n', '        // Must be valid percentage\n', '        require(MathUtils.validPerc(_targetBondingRate));\n', '\n', '        targetBondingRate = _targetBondingRate;\n', '\n', '        ParameterUpdate("targetBondingRate");\n', '    }\n', '\n', '    /**\n', '     * @dev Set inflationChange. Only callable by Controller owner\n', '     * @param _inflationChange Inflation change as a percentage of total token supply\n', '     */\n', '    function setInflationChange(uint256 _inflationChange) external onlyControllerOwner {\n', '        // Must be valid percentage\n', '        require(MathUtils.validPerc(_inflationChange));\n', '\n', '        inflationChange = _inflationChange;\n', '\n', '        ParameterUpdate("inflationChange");\n', '    }\n', '\n', '    /**\n', '     * @dev Migrate to a new Minter by transferring ownership of the token as well\n', '     * as the current Minter&#39;s token balance to the new Minter. Only callable by Controller when system is paused\n', '     * @param _newMinter Address of new Minter\n', '     */\n', '    function migrateToNewMinter(IMinter _newMinter) external onlyControllerOwner whenSystemPaused {\n', '        // New Minter cannot be the current Minter\n', '        require(_newMinter != this);\n', '        // Check for null address\n', '        require(address(_newMinter) != address(0));\n', '\n', '        IController newMinterController = _newMinter.getController();\n', '        // New Minter must have same Controller as current Minter\n', '        require(newMinterController == controller);\n', '        // New Minter&#39;s Controller must have the current Minter registered\n', '        require(newMinterController.getContract(keccak256("Minter")) == address(this));\n', '\n', '        // Transfer ownership of token to new Minter\n', '        livepeerToken().transferOwnership(_newMinter);\n', '        // Transfer current Minter&#39;s token balance to new Minter\n', '        livepeerToken().transfer(_newMinter, livepeerToken().balanceOf(this));\n', '        // Transfer current Minter&#39;s ETH balance to new Minter\n', '        _newMinter.depositETH.value(this.balance)();\n', '    }\n', '\n', '    /**\n', '     * @dev Create reward based on a fractional portion of the mintable tokens for the current round\n', '     * @param _fracNum Numerator of fraction (active transcoder&#39;s stake)\n', '     * @param _fracDenom Denominator of fraction (total active stake)\n', '     */\n', '    function createReward(uint256 _fracNum, uint256 _fracDenom) external onlyBondingManager whenSystemNotPaused returns (uint256) {\n', '        // Compute and mint fraction of mintable tokens to include in reward\n', '        uint256 mintAmount = MathUtils.percOf(currentMintableTokens, _fracNum, _fracDenom);\n', '        // Update amount of minted tokens for round\n', '        currentMintedTokens = currentMintedTokens.add(mintAmount);\n', '        // Minted tokens must not exceed mintable tokens\n', '        require(currentMintedTokens <= currentMintableTokens);\n', '        // Mint new tokens\n', '        livepeerToken().mint(this, mintAmount);\n', '\n', '        // Reward = minted tokens\n', '        return mintAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens to a receipient. Only callable by BondingManager - always trusts BondingManager\n', '     * @param _to Recipient address\n', '     * @param _amount Amount of tokens\n', '     */\n', '    function trustedTransferTokens(address _to, uint256 _amount) external onlyBondingManager whenSystemNotPaused {\n', '        livepeerToken().transfer(_to, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Burn tokens. Only callable by BondingManager - always trusts BondingManager\n', '     * @param _amount Amount of tokens to burn\n', '     */\n', '    function trustedBurnTokens(uint256 _amount) external onlyBondingManager whenSystemNotPaused {\n', '        livepeerToken().burn(_amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw ETH to a recipient. Only callable by BondingManager or JobsManager - always trusts these two contracts\n', '     * @param _to Recipient address\n', '     * @param _amount Amount of ETH\n', '     */\n', '    function trustedWithdrawETH(address _to, uint256 _amount) external onlyBondingManagerOrJobsManager whenSystemNotPaused {\n', '        _to.transfer(_amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Deposit ETH to this contract. Only callable by the currently registered Minter or JobsManager\n', '     */\n', '    function depositETH() external payable onlyMinterOrJobsManager whenSystemNotPaused returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Set inflation and mintable tokens for the round. Only callable by the RoundsManager\n', '     */\n', '    function setCurrentRewardTokens() external onlyRoundsManager whenSystemNotPaused {\n', '        setInflation();\n', '\n', '        // Set mintable tokens based upon current inflation and current total token supply\n', '        currentMintableTokens = MathUtils.percOf(livepeerToken().totalSupply(), inflation);\n', '        currentMintedTokens = 0;\n', '\n', '        SetCurrentRewardTokens(currentMintableTokens, inflation);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns Controller interface\n', '     */\n', '    function getController() public view returns (IController) {\n', '        return controller;\n', '    }\n', '\n', '    /**\n', '     * @dev Set inflation based upon the current bonding rate and target bonding rate\n', '     */\n', '    function setInflation() internal {\n', '        uint256 currentBondingRate = 0;\n', '        uint256 totalSupply = livepeerToken().totalSupply();\n', '\n', '        if (totalSupply > 0) {\n', '            uint256 totalBonded = bondingManager().getTotalBonded();\n', '            currentBondingRate = MathUtils.percPoints(totalBonded, totalSupply);\n', '        }\n', '\n', '        if (currentBondingRate < targetBondingRate) {\n', '            // Bonding rate is below the target - increase inflation\n', '            inflation = inflation.add(inflationChange);\n', '        } else if (currentBondingRate > targetBondingRate) {\n', '            // Bonding rate is above the target - decrease inflation\n', '            if (inflationChange > inflation) {\n', '                inflation = 0;\n', '            } else {\n', '                inflation = inflation.sub(inflationChange);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns LivepeerToken interface\n', '     */\n', '    function livepeerToken() internal view returns (ILivepeerToken) {\n', '        return ILivepeerToken(controller.getContract(keccak256("LivepeerToken")));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns BondingManager interface\n', '     */\n', '    function bondingManager() internal view returns (IBondingManager) {\n', '        return IBondingManager(controller.getContract(keccak256("BondingManager")));\n', '    }\n', '}']