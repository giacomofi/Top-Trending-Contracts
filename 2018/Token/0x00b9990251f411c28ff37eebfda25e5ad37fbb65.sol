['pragma solidity ^0.4.18;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract NecashTokenBase {\n', '    string public constant _myTokeName = &#39;Necash Token&#39;;\n', '    string public constant _mySymbol = &#39;NEC&#39;;\n', '    uint public constant _myinitialSupply = 20000000;\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    function NecashTokenBase() public {\n', '        totalSupply = _myinitialSupply * (10 ** uint256(decimals));\n', '        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n', '        name = _myTokeName;                                   // Set the name for display purposes\n', '        symbol = _mySymbol;                               // Set the symbol for display purposes\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract NecashToken is owned, NecashTokenBase {\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function NecashToken() NecashTokenBase() public {}\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '        balanceOf[_from] -= _value;                         // Subtract from the sender\n', '        balanceOf[_to] += _value;                           // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is owned {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', '  @title NeCashTokenSale\n', '**/\n', 'contract NeCashTokenSale is owned, Pausable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '        EVENTS\n', '    **/\n', '    event Purchase(address indexed buyer, uint256 weiAmount, uint256 tokenAmount);\n', '    event Finalized(uint256 tokensSold, uint256 weiAmount);\n', '\n', '    /**\n', '        CONTRACT VARIABLES\n', '    **/\n', '    NecashToken public necashToken;\n', '\n', '    uint256 public startTime;\n', '    uint256 public weiRaised;\n', '    uint256 public tokensSold;\n', '    bool public finalized = false;\n', '    address public wallet;\n', '\n', '    uint256 public maxGasPrice = 50000000000;\n', '    uint256 public tokenPerEth = 1000;\n', '\n', '    uint256[4] public rates;\n', '\n', '    mapping (address => uint256) public contributors;\n', '\n', '    uint256 public constant minimumPurchase = 0.1 ether;\n', '    uint256 public constant maximumPurchase = 10 ether;\n', '\n', '    /**\n', '      @dev ICO CONSTRUCTOR\n', '    **/\n', '    function NeCashTokenSale() public\n', '    {\n', '        necashToken = NecashToken(address(0xd4e179eadf65d230c0c0ab7540edf03715596c92));\n', '\n', '        startTime = 1530362569;\n', '        wallet = address(0xBC03d69aF2E5c329F5b4eE09ad01AcC8A7e8F719);\n', '    }\n', '\n', '\n', '    /**\n', '        PUBLIC FUNCTIONS\n', '\n', '    **/\n', '\n', '    /**\n', '      @dev Fallback function that accepts eth and buy tokens\n', '    **/\n', '    function () payable whenNotPaused public {\n', '        buyTokens();\n', '    }\n', '\n', '    /**\n', '      @dev Allows participants to buy tokens\n', '    **/\n', '    function buyTokens() payable whenNotPaused public {\n', '        require(isValidPurchase());\n', '\n', '        uint256 amount = msg.value;\n', '        uint256 tokens = calculateTokenAmount(amount);\n', '\n', '        uint256 maxSellToken = necashToken.balanceOf(address(this));\n', '        if(tokens > maxSellToken){\n', '            uint256 possibleTokens = maxSellToken.sub(tokens);\n', '            uint256 change = calculatePriceForTokens(tokens.sub(possibleTokens));\n', '            msg.sender.transfer(change);\n', '            tokens = possibleTokens;\n', '            amount = amount.sub(change);\n', '        }\n', '\n', '        contributors[msg.sender] = contributors[msg.sender].add(amount);\n', '        necashToken.transfer(msg.sender, tokens);\n', '\n', '        tokensSold = tokensSold.add(tokens);\n', '        weiRaised = weiRaised.add(amount);\n', '        forwardFunds(amount);\n', '        Purchase(msg.sender, amount, tokens);\n', '    }\n', '\n', '    /**\n', '      @dev allows the owner to change the max gas price\n', '      @param _gasPrice uint256 the new maximum gas price\n', '    **/\n', '    function changeMaxGasprice(uint256 _gasPrice)\n', '      public onlyOwner whenNotPaused\n', '    {\n', '        maxGasPrice = _gasPrice;\n', '    }\n', '\n', '    /**\n', '      @dev allows the owner to change token price\n', '      @param _tokens uint256 the new token price\n', '    **/\n', '    function changeTokenPrice(uint256 _tokens)\n', '      public onlyOwner whenNotPaused\n', '    {\n', '        tokenPerEth = _tokens;\n', '    }\n', '\n', '    /**\n', '      @dev Triggers the finalization process\n', '    **/\n', '    function endSale() public onlyOwner whenNotPaused {\n', '        require(finalized == false);\n', '        finalizeSale();\n', '    }\n', '\n', '    /**\n', '        INTERNAL FUNCTIONS\n', '\n', '    **/\n', '\n', '    /**\n', '      @dev Checks if purchase is valid\n', '      @return Bool Indicating if purchase is valid\n', '    **/\n', '    function isValidPurchase() view internal returns(bool valid) {\n', '        require(now >= startTime);\n', '        require(msg.value >= minimumPurchase);\n', '        require(msg.value <= maximumPurchase);\n', '        require(tx.gasprice <= maxGasPrice);\n', '        \n', '        return true;\n', '    }\n', '\n', '    /**\n', '      @dev Internal function that redirects recieved funds to wallet\n', '      @param _amount uint256 The amount to be fowarded\n', '    **/\n', '    function forwardFunds(uint256 _amount) internal {\n', '        wallet.transfer(_amount);\n', '    }\n', '\n', '    /**\n', '      @dev Calculates the amount of tokens that buyer will recieve\n', '      @param weiAmount uint256 The amount, in Wei, that will be bought\n', '      @return uint256 Representing the amount of tokens that weiAmount buys in\n', '      the current stage of the sale\n', '    **/\n', '    function calculateTokenAmount(uint256 weiAmount) view internal returns(uint256 tokenAmount){\n', '        return weiAmount.mul(tokenPerEth);\n', '    }\n', '\n', '    /**\n', '      @dev Calculates wei cost of specific amount of tokens\n', '      @param tokenAmount uint256 The amount of tokens to be calculated\n', '      @return uint256 Representing the total cost, in wei, for tokenAmount\n', '    **/\n', '    function calculatePriceForTokens(uint256 tokenAmount) view internal returns(uint256 weiAmount){\n', '        return tokenAmount.div(tokenPerEth);\n', '    }\n', '\n', '    /**\n', '      @dev Triggers the sale finalizations process\n', '    **/\n', '    function finalizeSale() internal {\n', '        finalized = true;\n', '        Finalized(tokensSold, weiRaised);\n', '    }\n', '}']