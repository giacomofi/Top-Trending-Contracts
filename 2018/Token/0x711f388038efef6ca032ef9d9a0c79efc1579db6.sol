['pragma solidity ^0.4.11;\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) throw;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract BitcoinStore is Ownable, SafeMath {\n', '\n', '  address constant public Bitcoin_address =0xB6eD7644C69416d67B522e20bC294A9a9B405B31;// TESTNET CONTRACT: 0x9D2Cc383E677292ed87f63586086CfF62a009010;\n', '  uint public bitcoin_ratio = 400*1E8;\n', '  uint public eth_ratio = 1*1E18;\n', '\n', '  function update_eth_ratio( uint new_eth_ratio) \n', '  onlyOwner\n', '  {\n', '    eth_ratio = new_eth_ratio;\n', '  }\n', '\n', '  function update_bitcoin_ratio(uint new_bitcoin_ratio) \n', '  onlyOwner\n', '  {\n', '    bitcoin_ratio = new_bitcoin_ratio;\n', '  }\n', '\n', '  function update_ratio(uint new_bitcoin_ratio, uint new_eth_ratio) \n', '  onlyOwner\n', '  {\n', '    bitcoin_ratio = new_bitcoin_ratio;\n', '    eth_ratio = new_eth_ratio;\n', '  }\n', '\n', '  function send(address _tokenAddr, address dest, uint value)\n', '  onlyOwner\n', '  {\n', '      ERC20(_tokenAddr).transfer(dest, value);\n', '  }\n', '\n', '  function multisend(address _tokenAddr, address[] dests, uint[] values)\n', '  onlyOwner\n', '  returns (uint) {\n', '      uint i = 0;\n', '      while (i < dests.length) {\n', '         ERC20(_tokenAddr).transfer(dests[i], values[i]);\n', '         i += 1;\n', '      }\n', '      return(i);\n', '  }\n', '\n', '  /* fallback function for when ether is sent to the contract */\n', '  function () external payable {\n', '    require(eth_ratio > 0); // safe divide\n', '    uint buytokens = safeMul(bitcoin_ratio , msg.value)/eth_ratio;\n', '    ERC20(Bitcoin_address).transfer(msg.sender, buytokens);\n', '\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  function buy() public payable {\n', '    require(eth_ratio > 0); // safe divide\n', '    uint buytokens = safeMul(bitcoin_ratio , msg.value)/eth_ratio;\n', '    ERC20(Bitcoin_address).transfer(msg.sender, buytokens);\n', '    \n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '  function withdraw() onlyOwner {\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '}']