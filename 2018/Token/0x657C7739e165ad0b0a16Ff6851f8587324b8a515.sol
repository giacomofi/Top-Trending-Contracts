['//Honestis deployment\n', 'pragma solidity ^0.4.11;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  /* Token supply got increased and a new owner received these tokens */\n', '  event Minted(address receiver, uint amount);\n', '\n', '  /* Actual balances of token holders */\n', '  mapping(address => uint) balances;\n', '\n', '  /* approve() allowances */\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /* Interface declaration */\n', '  function isToken() public constant returns (bool weAre) {\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '//  Honestis Network Token \n', 'contract HonestisNetworkTokenWire3{\n', '\n', '    string public name = "Honestis.Network Token Version 1";\n', '    string public symbol = "HNT";\n', '    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n', '    // The funding cap in weis.\n', '// was not reached about 93% was sold    uint256 public constant tokenCreationCap = 66200 * 1000 * ether ;\n', '\t\n', '    // Receives ETH and its own H.N Token endowment.\n', '    address public honestisFort = 0xF03e8E4cbb2865fCc5a02B61cFCCf86E9aE021b5;\n', '    // NOT APPLY\n', '    address public migrationMaster = 0x0f32f4b37684be8a1ce1b2ed765d2d893fa1b419;\n', '    // The current total token supply.\n', '\t//totalsupply\n', '  //  uint256 public constant allchainstotalsupply =61172163.78335328 ether;\n', '//    uint256 public constant supply on chain 1st and 2nd     =57872163.78335328 ether;\n', '//\tuint256 public constant supply4chains34 = 3300000.0 ether;\n', 'uint256 public constant supply = 3300000.0 ether;\n', '\t\t//61172163 783353280000000000\n', '\t// was 61168800\n', '\t//chains:\n', '\taddress public firstChainHNw1 = 0x0;\n', '\taddress public secondChainHNw2 = 0x0;\n', '\taddress public thirdChainETH = 0x0;\n', '\taddress public fourthChainETC = 0x0;\n', '\t\t\t\t\n', '\tstruct sendTokenAway{\n', '\t\tStandardToken coinContract;\n', '\t\tuint amount;\n', '\t\taddress recipient;\n', '\t}\n', '\tmapping(uint => sendTokenAway) transfers;\n', '\tuint numTransfers=0;\n', '\t\n', '  mapping (address => uint256) balances;\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\tevent UpdatedTokenInformation(string newName, string newSymbol);\t\n', ' \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\t\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  function HonestisNetworkTokenWire3() {\n', '// BALANCES\t\t\n', '//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n', '// funcje transfer , fransfer from, allow, allowance , wywalic migrate i mastera , owner tylko do zmiany nazwy ??, total security check \n', '//early adopters community 1\n', '//balances[0xd57908dbe0e1353771db7f953E74a7936a5aAd70]=                   61172163783353280000000000;\n', '// 1st and 2nd chain balances[0xd57908dbe0e1353771db7f953E74a7936a5aAd70]=57872163783353280000000000;\n', '// 3rd and 4th chain 3300000 000000000000000000;                          +3300000000000000000000000;\n', ' balances[0x8585d5a25b1fa2a0e6c3bcfc098195bac9789be2]=3300000000000000000000000;\n', '}\n', '\n', '  \n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '    //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '    //Replace the if with this one instead.\n', '    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    //if (balances[msg.sender] >= _value && _value > 0) {\n', '      balances[msg.sender] -= _value;\n', '      balances[_to] += _value;\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    } else { return false; }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '    //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '      balances[_to] += _value;\n', '      balances[_from] -= _value;\n', '      allowed[_from][msg.sender] -= _value;\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    } else { return false; }\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '\tfunction() payable {\n', '\n', '   }\n', '\n', '\n', 'function justSendDonations() external {\n', '    if (msg.sender != honestisFort) throw;\n', '\tif (!honestisFort.send(this.balance)) throw;\n', '}\n', '\t\n', '  function setTokenInformation(string _name, string _symbol) {\n', '    \n', '\t   if (msg.sender != honestisFort) {\n', '      throw;\n', '    }\n', '\tname = _name;\n', '    symbol = _symbol;\n', '\n', '    UpdatedTokenInformation(name, symbol);\n', '  }\n', '\n', 'function setChainsAddresses(address chainAd, int chainnumber) {\n', '    \n', '\t   if (msg.sender != honestisFort) {\n', '      throw;\n', '    }\n', '\tif(chainnumber==1){firstChainHNw1=chainAd;}\n', '\tif(chainnumber==2){secondChainHNw2=chainAd;}\n', '\tif(chainnumber==3){thirdChainETH=chainAd;}\n', '\tif(chainnumber==4){fourthChainETC=chainAd;}\t\t\n', '  } \n', '\n', '  function HonestisnetworkICOregulations() external returns(string wow) {\n', '\treturn &#39;Regulations of preICO and ICO are present at website  honestis.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules&#39;;\n', '}\n', '// if accidentally other token was donated to Project Dev\n', '\n', '\n', '\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\n', '\t\tif (msg.sender != honestisFort) {\n', '\t\tthrow;\n', '\t\t}\n', '\t\tsendTokenAway t = transfers[numTransfers];\n', '\t\tt.coinContract = StandardToken(StandardTokenAddress);\n', '\t\tt.amount = amount;\n', '\t\tt.recipient = receiver;\n', '\t\tt.coinContract.transfer(receiver, amount);\n', '\t\tnumTransfers++;\n', '\t}\n', '\n', '\n', '\n', '\n', '}\n', '\n', '\n', '//------------------------------------------------------']