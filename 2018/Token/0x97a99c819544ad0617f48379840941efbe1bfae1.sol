['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract SupportedContract {\n', '  // Members can call any contract that exposes a `theCyberMessage` method.\n', '  function theCyberMessage(string) public;\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  // We want to be able to recover & donate any tokens sent to the contract.\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', 'contract theCyber {\n', '  // theCyber is a decentralized club. It does not support equity memberships,\n', '  // payment of dues, or payouts to the members. Instead, it is meant to enable\n', '  // dapps that allow members to communicate with one another or that provide\n', '  // arbitrary incentives or special access to the club&#39;s members. To become a\n', '  // member of theCyber, you must be added by an existing member. Furthermore,\n', '  // existing memberships can be revoked if a given member becomes inactive for\n', '  // too long. Total membership is capped and unique addresses are required.\n', '\n', '  event NewMember(uint8 indexed memberId, bytes32 memberName, address indexed memberAddress);\n', '  event NewMemberName(uint8 indexed memberId, bytes32 newMemberName);\n', '  event NewMemberKey(uint8 indexed memberId, string newMemberKey);\n', '  event MembershipTransferred(uint8 indexed memberId, address newMemberAddress);\n', '  event MemberProclaimedInactive(uint8 indexed memberId, uint8 indexed proclaimingMemberId);\n', '  event MemberHeartbeated(uint8 indexed memberId);\n', '  event MembershipRevoked(uint8 indexed memberId, uint8 indexed revokingMemberId);\n', '  event BroadcastMessage(uint8 indexed memberId, string message);\n', '  event DirectMessage(uint8 indexed memberId, uint8 indexed toMemberId, string message);\n', '  event Call(uint8 indexed memberId, address indexed contractAddress, string message);\n', '  event FundsDonated(uint8 indexed memberId, uint256 value);\n', '  event TokensDonated(uint8 indexed memberId, address tokenContractAddress, uint256 value);\n', '\n', '  // There can only be 256 members (member number 0 to 255) in theCyber.\n', '  uint16 private constant MAXMEMBERS_ = 256;\n', '\n', '  // A membership that has been marked as inactive for 90 days may be revoked.\n', '  uint64 private constant INACTIVITYTIMEOUT_ = 90 days;\n', '\n', '  // Set the ethereum tip jar (ethereumfoundation.eth) as the donation address.\n', '  address private constant DONATIONADDRESS_ = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\n', '\n', '  // A member has a name, a public key, a date they joined, and a date they were\n', '  // marked as inactive (which is equial to 0 if they are currently active).\n', '  struct Member {\n', '    bool member;\n', '    bytes32 name;\n', '    string pubkey;\n', '    uint64 memberSince;\n', '    uint64 inactiveSince;\n', '  }\n', '\n', '  // Set up a fixed array of members indexed by member id.\n', '  Member[MAXMEMBERS_] internal members_;\n', '\n', '  // Map addresses to booleans designating that they control the membership.\n', '  mapping (address => bool) internal addressIsMember_;\n', '\n', '  // Map addresses to member ids.\n', '  mapping (address => uint8) internal addressToMember_;\n', '\n', '  // Map member ids to addresses that own the membership.\n', '  mapping (uint => address) internal memberToAddress_;\n', '\n', '  // Most methods of the contract, like adding new members or revoking existing\n', '  // inactive members, can only be called by a valid member.\n', '  modifier membersOnly() {\n', '    // Only allow transactions originating from a designated member address.\n', '    require(addressIsMember_[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  // In the constructor function, set up the contract creator as the first\n', '  // member so that other new members can be added.\n', '  function theCyber() public {\n', '    // Log the addition of the first member (contract creator).\n', '    NewMember(0, "", msg.sender);\n', '\n', '    // Set up the member: status, name, key, member since & inactive since.\n', '    members_[0] = Member(true, bytes32(""), "", uint64(now), 0);\n', '    \n', '    // Set up the address associated with the member.\n', '    memberToAddress_[0] = msg.sender;\n', '\n', '    // Point the address to member&#39;s id.\n', '    addressToMember_[msg.sender] = 0;\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[msg.sender] = true;\n', '  }\n', '\n', '  // Existing members can designate new users by specifying an unused member id\n', '  // and address. The new member&#39;s initial member name should also be supplied.\n', '  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\n', '    // Members need a non-null address.\n', '    require(_memberAddress != address(0));\n', '\n', '    // Existing members (that have not fallen inactive) cannot be replaced.\n', '    require (!members_[_memberId].member);\n', '\n', '    // One address cannot hold more than one membership.\n', '    require (!addressIsMember_[_memberAddress]);\n', '\n', '    // Log the addition of a new member: (member id, name, address).\n', '    NewMember(_memberId, _memberName, _memberAddress);\n', '\n', '    // Set up the member: status, name, `member since` & `inactive since`.\n', '    members_[_memberId] = Member(true, _memberName, "", uint64(now), 0);\n', '    \n', '    // Set up the address associated with the member id.\n', '    memberToAddress_[_memberId] = _memberAddress;\n', '\n', '    // Point the address to the member id.\n', '    addressToMember_[_memberAddress] = _memberId;\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[_memberAddress] = true;\n', '  }\n', '\n', '  // Members can set a name (encoded as a hex value) that will be associated\n', '  // with their membership.\n', '  function changeName(bytes32 _newMemberName) public membersOnly {\n', '    // Log the member&#39;s name change: (member id, new name).\n', '    NewMemberName(addressToMember_[msg.sender], _newMemberName);\n', '\n', '    // Change the member&#39;s name.\n', '    members_[addressToMember_[msg.sender]].name = _newMemberName;\n', '  }\n', '\n', '  // Members can set a public key that will be used for verifying signed\n', '  // messages from the member or encrypting messages intended for the member.\n', '  function changeKey(string _newMemberKey) public membersOnly {\n', '    // Log the member&#39;s key change: (member id, new member key).\n', '    NewMemberKey(addressToMember_[msg.sender], _newMemberKey);\n', '\n', '    // Change the member&#39;s public key.\n', '    members_[addressToMember_[msg.sender]].pubkey = _newMemberKey;\n', '  }\n', '\n', '  // Members can transfer their membership to a new address; when they do, the\n', '  // fields on the membership are all reset.\n', '  function transferMembership(address _newMemberAddress) public membersOnly {\n', '    // Members need a non-null address.\n', '    require(_newMemberAddress != address(0));\n', '\n', '    // Memberships cannot be transferred to existing members.\n', '    require (!addressIsMember_[_newMemberAddress]);\n', '\n', '    // Log transfer of membership: (member id, new address).\n', '    MembershipTransferred(addressToMember_[msg.sender], _newMemberAddress);\n', '    \n', '    // Revoke members-only access for the old member.\n', '    delete addressIsMember_[msg.sender];\n', '    \n', '    // Reset fields on the membership.\n', '    members_[addressToMember_[msg.sender]].memberSince = uint64(now);\n', '    members_[addressToMember_[msg.sender]].inactiveSince = 0;\n', '    members_[addressToMember_[msg.sender]].name = bytes32("");\n', '    members_[addressToMember_[msg.sender]].pubkey = "";\n', '    \n', '    // Replace the address associated with the member id.\n', '    memberToAddress_[addressToMember_[msg.sender]] = _newMemberAddress;\n', '\n', '    // Point the new address to the member id and clean up the old pointer.\n', '    addressToMember_[_newMemberAddress] = addressToMember_[msg.sender];\n', '    delete addressToMember_[msg.sender];\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[_newMemberAddress] = true;\n', '  }\n', '\n', '  // As a mechanism to remove members that are no longer active due to lost keys\n', '  // or a lack of engagement, other members may proclaim them as inactive.\n', '  function proclaimInactive(uint8 _memberId) public membersOnly {\n', '    // Members must exist and be currently active to proclaim inactivity.\n', '    require(members_[_memberId].member);\n', '    require(memberIsActive(_memberId));\n', '    \n', '    // Members cannot proclaim themselves as inactive (safety measure).\n', '    require(addressToMember_[msg.sender] != _memberId);\n', '\n', '    // Log proclamation of inactivity: (inactive member id, member id, time).\n', '    MemberProclaimedInactive(_memberId, addressToMember_[msg.sender]);\n', '    \n', '    // Set the `inactiveSince` field on the inactive member.\n', '    members_[_memberId].inactiveSince = uint64(now);\n', '  }\n', '\n', '  // Members that have erroneously been marked as inactive may send a heartbeat\n', '  // to prove that they are still active, voiding the `inactiveSince` property.\n', '  function heartbeat() public membersOnly {\n', '    // Log that the member has heartbeated and is still active.\n', '    MemberHeartbeated(addressToMember_[msg.sender]);\n', '\n', '    // Designate member as active by voiding their `inactiveSince` field.\n', '    members_[addressToMember_[msg.sender]].inactiveSince = 0;\n', '  }\n', '\n', '  // If a member has been marked inactive for the duration of the inactivity\n', '  // timeout, another member may revoke their membership and delete them.\n', '  function revokeMembership(uint8 _memberId) public membersOnly {\n', '    // Members must exist in order to be revoked.\n', '    require(members_[_memberId].member);\n', '\n', '    // Members must be designated as inactive.\n', '    require(!memberIsActive(_memberId));\n', '\n', '    // Members cannot revoke themselves (safety measure).\n', '    require(addressToMember_[msg.sender] != _memberId);\n', '\n', '    // Members must be inactive for the duration of the inactivity timeout.\n', '    require(now >= members_[_memberId].inactiveSince + INACTIVITYTIMEOUT_);\n', '\n', '    // Log that the membership has been revoked.\n', '    MembershipRevoked(_memberId, addressToMember_[msg.sender]);\n', '\n', '    // Revoke members-only access for the member.\n', '    delete addressIsMember_[memberToAddress_[_memberId]];\n', '\n', '    // Delete the pointer linking the address to the member id.\n', '    delete addressToMember_[memberToAddress_[_memberId]];\n', '    \n', '    // Delete the address associated with the member id.\n', '    delete memberToAddress_[_memberId];\n', '\n', '    // Finally, delete the member.\n', '    delete members_[_memberId];\n', '  }\n', '\n', '  // While most messaging is intended to occur off-chain using supplied keys,\n', '  // members can also broadcast a message as an on-chain event.\n', '  function broadcastMessage(string _message) public membersOnly {\n', '    // Log the message.\n', '    BroadcastMessage(addressToMember_[msg.sender], _message);\n', '  }\n', '\n', '  // In addition, members can send direct messagees as an on-chain event. These\n', '  // messages are intended to be encrypted using the recipient&#39;s public key.\n', '  function directMessage(uint8 _toMemberId, string _message) public membersOnly {\n', '    // Log the message.\n', '    DirectMessage(addressToMember_[msg.sender], _toMemberId, _message);\n', '  }\n', '\n', '  // Members can also pass a message to any contract that supports it (via the\n', '  // `theCyberMessage(string)` function), designated by the contract address.\n', '  function passMessage(address _contractAddress, string _message) public membersOnly {\n', '    // Log that another contract has been called and passed a message.\n', '    Call(addressToMember_[msg.sender], _contractAddress, _message);\n', '\n', '    // call the method of the target contract and pass in the message.\n', '    SupportedContract(_contractAddress).theCyberMessage(_message);\n', '  }\n', '\n', '  // The contract is not payable by design, but could end up with a balance as\n', '  // a recipient of a selfdestruct / coinbase of a mined block.\n', '  function donateFunds() public membersOnly {\n', '    // Log the donation of any funds that have made their way into the contract.\n', '    FundsDonated(addressToMember_[msg.sender], this.balance);\n', '\n', '    // Send all available funds to the donation address.\n', '    DONATIONADDRESS_.transfer(this.balance);\n', '  }\n', '\n', '  // We also want to be able to access any tokens that are sent to the contract.\n', '  function donateTokens(address _tokenContractAddress) public membersOnly {\n', '    // Make sure that we didn&#39;t pass in the current contract address by mistake.\n', '    require(_tokenContractAddress != address(this));\n', '\n', '    // Log the donation of any tokens that have been sent into the contract.\n', '    TokensDonated(addressToMember_[msg.sender], _tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\n', '\n', '    // Send all available tokens at the given contract to the donation address.\n', '    ERC20(_tokenContractAddress).transfer(DONATIONADDRESS_, ERC20(_tokenContractAddress).balanceOf(this));\n', '  }\n', '\n', '  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId) {\n', '    return (\n', '      addressIsMember_[_memberAddress],\n', '      addressToMember_[_memberAddress]\n', '    );\n', '  }\n', '\n', '  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress) {\n', '    return (\n', '      members_[_memberId].name,\n', '      members_[_memberId].pubkey,\n', '      members_[_memberId].memberSince,\n', '      members_[_memberId].inactiveSince,\n', '      memberToAddress_[_memberId]\n', '    );\n', '  }\n', '\n', '  function maxMembers() public pure returns(uint16) {\n', '    return MAXMEMBERS_;\n', '  }\n', '\n', '  function inactivityTimeout() public pure returns(uint64) {\n', '    return INACTIVITYTIMEOUT_;\n', '  }\n', '\n', '  function donationAddress() public pure returns(address) {\n', '    return DONATIONADDRESS_;\n', '  }\n', '\n', '  function memberIsActive(uint8 _memberId) internal view returns (bool) {\n', '    return (members_[_memberId].inactiveSince == 0);\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract SupportedContract {\n', '  // Members can call any contract that exposes a `theCyberMessage` method.\n', '  function theCyberMessage(string) public;\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  // We want to be able to recover & donate any tokens sent to the contract.\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', 'contract theCyber {\n', '  // theCyber is a decentralized club. It does not support equity memberships,\n', '  // payment of dues, or payouts to the members. Instead, it is meant to enable\n', '  // dapps that allow members to communicate with one another or that provide\n', "  // arbitrary incentives or special access to the club's members. To become a\n", '  // member of theCyber, you must be added by an existing member. Furthermore,\n', '  // existing memberships can be revoked if a given member becomes inactive for\n', '  // too long. Total membership is capped and unique addresses are required.\n', '\n', '  event NewMember(uint8 indexed memberId, bytes32 memberName, address indexed memberAddress);\n', '  event NewMemberName(uint8 indexed memberId, bytes32 newMemberName);\n', '  event NewMemberKey(uint8 indexed memberId, string newMemberKey);\n', '  event MembershipTransferred(uint8 indexed memberId, address newMemberAddress);\n', '  event MemberProclaimedInactive(uint8 indexed memberId, uint8 indexed proclaimingMemberId);\n', '  event MemberHeartbeated(uint8 indexed memberId);\n', '  event MembershipRevoked(uint8 indexed memberId, uint8 indexed revokingMemberId);\n', '  event BroadcastMessage(uint8 indexed memberId, string message);\n', '  event DirectMessage(uint8 indexed memberId, uint8 indexed toMemberId, string message);\n', '  event Call(uint8 indexed memberId, address indexed contractAddress, string message);\n', '  event FundsDonated(uint8 indexed memberId, uint256 value);\n', '  event TokensDonated(uint8 indexed memberId, address tokenContractAddress, uint256 value);\n', '\n', '  // There can only be 256 members (member number 0 to 255) in theCyber.\n', '  uint16 private constant MAXMEMBERS_ = 256;\n', '\n', '  // A membership that has been marked as inactive for 90 days may be revoked.\n', '  uint64 private constant INACTIVITYTIMEOUT_ = 90 days;\n', '\n', '  // Set the ethereum tip jar (ethereumfoundation.eth) as the donation address.\n', '  address private constant DONATIONADDRESS_ = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\n', '\n', '  // A member has a name, a public key, a date they joined, and a date they were\n', '  // marked as inactive (which is equial to 0 if they are currently active).\n', '  struct Member {\n', '    bool member;\n', '    bytes32 name;\n', '    string pubkey;\n', '    uint64 memberSince;\n', '    uint64 inactiveSince;\n', '  }\n', '\n', '  // Set up a fixed array of members indexed by member id.\n', '  Member[MAXMEMBERS_] internal members_;\n', '\n', '  // Map addresses to booleans designating that they control the membership.\n', '  mapping (address => bool) internal addressIsMember_;\n', '\n', '  // Map addresses to member ids.\n', '  mapping (address => uint8) internal addressToMember_;\n', '\n', '  // Map member ids to addresses that own the membership.\n', '  mapping (uint => address) internal memberToAddress_;\n', '\n', '  // Most methods of the contract, like adding new members or revoking existing\n', '  // inactive members, can only be called by a valid member.\n', '  modifier membersOnly() {\n', '    // Only allow transactions originating from a designated member address.\n', '    require(addressIsMember_[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  // In the constructor function, set up the contract creator as the first\n', '  // member so that other new members can be added.\n', '  function theCyber() public {\n', '    // Log the addition of the first member (contract creator).\n', '    NewMember(0, "", msg.sender);\n', '\n', '    // Set up the member: status, name, key, member since & inactive since.\n', '    members_[0] = Member(true, bytes32(""), "", uint64(now), 0);\n', '    \n', '    // Set up the address associated with the member.\n', '    memberToAddress_[0] = msg.sender;\n', '\n', "    // Point the address to member's id.\n", '    addressToMember_[msg.sender] = 0;\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[msg.sender] = true;\n', '  }\n', '\n', '  // Existing members can designate new users by specifying an unused member id\n', "  // and address. The new member's initial member name should also be supplied.\n", '  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\n', '    // Members need a non-null address.\n', '    require(_memberAddress != address(0));\n', '\n', '    // Existing members (that have not fallen inactive) cannot be replaced.\n', '    require (!members_[_memberId].member);\n', '\n', '    // One address cannot hold more than one membership.\n', '    require (!addressIsMember_[_memberAddress]);\n', '\n', '    // Log the addition of a new member: (member id, name, address).\n', '    NewMember(_memberId, _memberName, _memberAddress);\n', '\n', '    // Set up the member: status, name, `member since` & `inactive since`.\n', '    members_[_memberId] = Member(true, _memberName, "", uint64(now), 0);\n', '    \n', '    // Set up the address associated with the member id.\n', '    memberToAddress_[_memberId] = _memberAddress;\n', '\n', '    // Point the address to the member id.\n', '    addressToMember_[_memberAddress] = _memberId;\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[_memberAddress] = true;\n', '  }\n', '\n', '  // Members can set a name (encoded as a hex value) that will be associated\n', '  // with their membership.\n', '  function changeName(bytes32 _newMemberName) public membersOnly {\n', "    // Log the member's name change: (member id, new name).\n", '    NewMemberName(addressToMember_[msg.sender], _newMemberName);\n', '\n', "    // Change the member's name.\n", '    members_[addressToMember_[msg.sender]].name = _newMemberName;\n', '  }\n', '\n', '  // Members can set a public key that will be used for verifying signed\n', '  // messages from the member or encrypting messages intended for the member.\n', '  function changeKey(string _newMemberKey) public membersOnly {\n', "    // Log the member's key change: (member id, new member key).\n", '    NewMemberKey(addressToMember_[msg.sender], _newMemberKey);\n', '\n', "    // Change the member's public key.\n", '    members_[addressToMember_[msg.sender]].pubkey = _newMemberKey;\n', '  }\n', '\n', '  // Members can transfer their membership to a new address; when they do, the\n', '  // fields on the membership are all reset.\n', '  function transferMembership(address _newMemberAddress) public membersOnly {\n', '    // Members need a non-null address.\n', '    require(_newMemberAddress != address(0));\n', '\n', '    // Memberships cannot be transferred to existing members.\n', '    require (!addressIsMember_[_newMemberAddress]);\n', '\n', '    // Log transfer of membership: (member id, new address).\n', '    MembershipTransferred(addressToMember_[msg.sender], _newMemberAddress);\n', '    \n', '    // Revoke members-only access for the old member.\n', '    delete addressIsMember_[msg.sender];\n', '    \n', '    // Reset fields on the membership.\n', '    members_[addressToMember_[msg.sender]].memberSince = uint64(now);\n', '    members_[addressToMember_[msg.sender]].inactiveSince = 0;\n', '    members_[addressToMember_[msg.sender]].name = bytes32("");\n', '    members_[addressToMember_[msg.sender]].pubkey = "";\n', '    \n', '    // Replace the address associated with the member id.\n', '    memberToAddress_[addressToMember_[msg.sender]] = _newMemberAddress;\n', '\n', '    // Point the new address to the member id and clean up the old pointer.\n', '    addressToMember_[_newMemberAddress] = addressToMember_[msg.sender];\n', '    delete addressToMember_[msg.sender];\n', '\n', '    // Grant members-only access to the new member.\n', '    addressIsMember_[_newMemberAddress] = true;\n', '  }\n', '\n', '  // As a mechanism to remove members that are no longer active due to lost keys\n', '  // or a lack of engagement, other members may proclaim them as inactive.\n', '  function proclaimInactive(uint8 _memberId) public membersOnly {\n', '    // Members must exist and be currently active to proclaim inactivity.\n', '    require(members_[_memberId].member);\n', '    require(memberIsActive(_memberId));\n', '    \n', '    // Members cannot proclaim themselves as inactive (safety measure).\n', '    require(addressToMember_[msg.sender] != _memberId);\n', '\n', '    // Log proclamation of inactivity: (inactive member id, member id, time).\n', '    MemberProclaimedInactive(_memberId, addressToMember_[msg.sender]);\n', '    \n', '    // Set the `inactiveSince` field on the inactive member.\n', '    members_[_memberId].inactiveSince = uint64(now);\n', '  }\n', '\n', '  // Members that have erroneously been marked as inactive may send a heartbeat\n', '  // to prove that they are still active, voiding the `inactiveSince` property.\n', '  function heartbeat() public membersOnly {\n', '    // Log that the member has heartbeated and is still active.\n', '    MemberHeartbeated(addressToMember_[msg.sender]);\n', '\n', '    // Designate member as active by voiding their `inactiveSince` field.\n', '    members_[addressToMember_[msg.sender]].inactiveSince = 0;\n', '  }\n', '\n', '  // If a member has been marked inactive for the duration of the inactivity\n', '  // timeout, another member may revoke their membership and delete them.\n', '  function revokeMembership(uint8 _memberId) public membersOnly {\n', '    // Members must exist in order to be revoked.\n', '    require(members_[_memberId].member);\n', '\n', '    // Members must be designated as inactive.\n', '    require(!memberIsActive(_memberId));\n', '\n', '    // Members cannot revoke themselves (safety measure).\n', '    require(addressToMember_[msg.sender] != _memberId);\n', '\n', '    // Members must be inactive for the duration of the inactivity timeout.\n', '    require(now >= members_[_memberId].inactiveSince + INACTIVITYTIMEOUT_);\n', '\n', '    // Log that the membership has been revoked.\n', '    MembershipRevoked(_memberId, addressToMember_[msg.sender]);\n', '\n', '    // Revoke members-only access for the member.\n', '    delete addressIsMember_[memberToAddress_[_memberId]];\n', '\n', '    // Delete the pointer linking the address to the member id.\n', '    delete addressToMember_[memberToAddress_[_memberId]];\n', '    \n', '    // Delete the address associated with the member id.\n', '    delete memberToAddress_[_memberId];\n', '\n', '    // Finally, delete the member.\n', '    delete members_[_memberId];\n', '  }\n', '\n', '  // While most messaging is intended to occur off-chain using supplied keys,\n', '  // members can also broadcast a message as an on-chain event.\n', '  function broadcastMessage(string _message) public membersOnly {\n', '    // Log the message.\n', '    BroadcastMessage(addressToMember_[msg.sender], _message);\n', '  }\n', '\n', '  // In addition, members can send direct messagees as an on-chain event. These\n', "  // messages are intended to be encrypted using the recipient's public key.\n", '  function directMessage(uint8 _toMemberId, string _message) public membersOnly {\n', '    // Log the message.\n', '    DirectMessage(addressToMember_[msg.sender], _toMemberId, _message);\n', '  }\n', '\n', '  // Members can also pass a message to any contract that supports it (via the\n', '  // `theCyberMessage(string)` function), designated by the contract address.\n', '  function passMessage(address _contractAddress, string _message) public membersOnly {\n', '    // Log that another contract has been called and passed a message.\n', '    Call(addressToMember_[msg.sender], _contractAddress, _message);\n', '\n', '    // call the method of the target contract and pass in the message.\n', '    SupportedContract(_contractAddress).theCyberMessage(_message);\n', '  }\n', '\n', '  // The contract is not payable by design, but could end up with a balance as\n', '  // a recipient of a selfdestruct / coinbase of a mined block.\n', '  function donateFunds() public membersOnly {\n', '    // Log the donation of any funds that have made their way into the contract.\n', '    FundsDonated(addressToMember_[msg.sender], this.balance);\n', '\n', '    // Send all available funds to the donation address.\n', '    DONATIONADDRESS_.transfer(this.balance);\n', '  }\n', '\n', '  // We also want to be able to access any tokens that are sent to the contract.\n', '  function donateTokens(address _tokenContractAddress) public membersOnly {\n', "    // Make sure that we didn't pass in the current contract address by mistake.\n", '    require(_tokenContractAddress != address(this));\n', '\n', '    // Log the donation of any tokens that have been sent into the contract.\n', '    TokensDonated(addressToMember_[msg.sender], _tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\n', '\n', '    // Send all available tokens at the given contract to the donation address.\n', '    ERC20(_tokenContractAddress).transfer(DONATIONADDRESS_, ERC20(_tokenContractAddress).balanceOf(this));\n', '  }\n', '\n', '  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId) {\n', '    return (\n', '      addressIsMember_[_memberAddress],\n', '      addressToMember_[_memberAddress]\n', '    );\n', '  }\n', '\n', '  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress) {\n', '    return (\n', '      members_[_memberId].name,\n', '      members_[_memberId].pubkey,\n', '      members_[_memberId].memberSince,\n', '      members_[_memberId].inactiveSince,\n', '      memberToAddress_[_memberId]\n', '    );\n', '  }\n', '\n', '  function maxMembers() public pure returns(uint16) {\n', '    return MAXMEMBERS_;\n', '  }\n', '\n', '  function inactivityTimeout() public pure returns(uint64) {\n', '    return INACTIVITYTIMEOUT_;\n', '  }\n', '\n', '  function donationAddress() public pure returns(address) {\n', '    return DONATIONADDRESS_;\n', '  }\n', '\n', '  function memberIsActive(uint8 _memberId) internal view returns (bool) {\n', '    return (members_[_memberId].inactiveSince == 0);\n', '  }\n', '}']
