['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) revert();\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (x < y) revert();\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) pure internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) revert();\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Owned{\n', '  address public owner;\n', '  event TransferOwnerShip(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner{\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnerShip(address newOwner) onlyOwner public{\n', '      require(newOwner != address(0));\n', '      emit TransferOwnerShip(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Transferable\n', ' * @dev The Transferable contract provides basic authorization control\n', ' */\n', 'contract Transferable is Owned {\n', '  bool  public transferable = true;\n', '  event EnableTransfer();\n', '  event DisableTransfer();\n', '\n', '  modifier whenTransferable(){\n', '    require(transferable || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotTransferable() {\n', '      require(!transferable);\n', '      \n', '      _;\n', '  }\n', '\n', '  function enableTransfer() onlyOwner  public {\n', '    transferable = true;\n', '    emit EnableTransfer();\n', '  } \n', '\n', '  function disableTransfer() onlyOwner public\n', '  {\n', '      transferable = false;\n', '      emit DisableTransfer();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic{\n', '  function totalSupply()              public view returns (uint256);\n', '  function balanceOf(address _owner)  public view returns (uint256 balance);\n', '  function transfer(address _to,uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from,address _to,uint256 _value) public returns (bool success);\n', '  function approve(address _spender,uint _value) public returns (bool success);\n', '  function allowance(address _owner,address _spender) public view returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from,address indexed _to,uint256 _value);\n', '  event Approval(address indexed _owner,address indexed _spender,uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 Standard Token\n', ' * @dev Basic version of StandardToken, with transferable.\n', ' */\n', 'contract ERC20StandardToken is ERC20Basic,Transferable{\n', '    using SafeMath for uint256;\n', '    \n', '    /* This creates an array with all balances */\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping (address => uint256) public freezeOf;\n', '    \n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '      return balanceOf[_owner];\n', '    }\n', '\n', '   function _transfer(address _from,address _to, uint256 _value) internal {\n', '    require(_to != 0x0);\n', '    uint256 previousBalances = balanceOf[_from].safeAdd(balanceOf[_to]);\n', '    balanceOf[_from] = balanceOf[_from].safeSub(_value);\n', '    balanceOf[_to]   = balanceOf[_to].safeAdd(_value);\n', '\n', '    emit Transfer(_from,_to,_value);\n', '    assert(balanceOf[_from].safeAdd(balanceOf[_to]) == previousBalances);\n', '   }\n', '\n', '  /* Send coins */\n', '  function transfer(address _to, uint256 _value) public whenTransferable returns (bool success){\n', '    _transfer(msg.sender,_to,_value);\n', '    return true;\n', '  }\n', '\n', '   /* A contract attempts to get the coins */\n', '  function transferFrom(address _from,address _to,uint256 _value) public whenTransferable returns (bool success){\n', '    require(allowance[_from][msg.sender] >= _value);\n', '    allowance[_from][msg.sender] = allowance[_from][msg.sender].safeSub(_value);\n', '    \n', '    _transfer(_from,_to,_value);\n', '    return true;  \n', '  }\n', '\n', '  /* Allow another contract to spend some tokens in your behalf */\n', '  function approve(address _spender,uint256 _value) public whenTransferable returns (bool success){\n', '    require(_value > 0);\n', '    require(_spender != 0x0);\n', '    allowance[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender,_spender,_value);\n', '    return true;\n', '  }\n', '  \n', '  function allowance(address _owner, address _spender) public whenTransferable view returns (uint256 remaining) {\n', '      return allowance[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract MyToken is ERC20StandardToken{\n', '  \n', '  string  public name;\n', '  string  public symbol;\n', '  uint8   public decimals;\n', '  uint256 public totalSupply;\n', '\n', '  /* This notifies clients about the amount burnt */\n', '  event Burn(address indexed _from, uint256 _value);\n', '\n', '  /* This notifies clients about the amount frozen */\n', '  event Freeze(address indexed from, uint256 value);\n', '\n', '  /* This notifies clients about the amount unfrozen */\n', '  event Unfreeze(address indexed from, uint256 value);\n', '  \n', '  /* Initializes contract with initial supply tokens to the creator of the contract */  \n', '  constructor(string tokenName,string tokenSymbol,uint8 decimalUints,uint256 initialSupply) public{\n', '    totalSupply           = initialSupply * 10 ** uint256(decimalUints);  // Set total supply\n', '    balanceOf[msg.sender] = totalSupply;                                 // Give the creator all initial tokens\n', '    name                  = tokenName;                                  // Set the name for display purposes\n', '    symbol                = tokenSymbol;                               // Set the symbol for display purposes\n', '    decimals              = decimalUints;                             // Amount of decimals for display purposes\n', '  }\n', '\n', '  /* This return total supply token */\n', '  function totalSupply() public view returns (uint256){\n', '     return totalSupply;\n', '  }\n', ' \n', ' /* Burn token */\n', '  function burn(uint256 _value) onlyOwner public returns (bool success){\n', '    require(balanceOf[msg.sender] >= _value);\n', '    balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\n', '    totalSupply = totalSupply.safeSub(_value);\n', '    emit Burn(msg.sender,_value);\n', '    return true;\n', '  }\n', '\n', ' /* Burn token from one address */\n', '  function burnFrom(address _from ,uint256 _value) onlyOwner public returns (bool success){\n', '    require(balanceOf[_from] >= _value);\n', '    balanceOf[_from] = balanceOf[_from].safeSub(_value);\n', '    totalSupply = totalSupply.safeSub(_value);\n', '    emit Burn(_from,_value);\n', '    return true;\n', '  }\n', '\n', ' /* Mint token to one address */\n', '  function mintToken(address _to,uint256 mintedAmount) onlyOwner public returns(bool success){\n', '    require(_to != 0x0);\n', '    balanceOf[_to] = balanceOf[_to].safeAdd(mintedAmount);\n', '    totalSupply = totalSupply.safeAdd(mintedAmount);\n', '    emit Transfer(0,address(this),mintedAmount);\n', '    emit Transfer(address(this),_to,mintedAmount);\n', '    return true;\n', '  }\n', '  \n', '  /* Fress token from one address */\n', '  function freeze(address _from,uint256 _value) onlyOwner public returns (bool success) {\n', '    require(_value > 0);\n', '    require(balanceOf[_from] >= _value);\n', '    balanceOf[_from] = balanceOf[_from].safeSub( _value);                      \n', '    freezeOf[_from] = freezeOf[_from].safeAdd(_value);               \n', '    emit Freeze(_from, _value);\n', '    return true;\n', '  }\n', '  \n', '  /* UnFress token from one address */\n', '  function unfreeze(address _from,uint256 _value) onlyOwner public returns (bool success) {\n', '    require(_value > 0);\n', '    require(freezeOf[_from] >= _value);\n', '    freezeOf[_from] = freezeOf[_from].safeSub(_value);                      \n', '    balanceOf[_from] = balanceOf[_from].safeAdd(_value);\n', '    emit Unfreeze(_from, _value);\n', '    return true;\n', '  }\n', '\n', '  /* This notifies clients about the contract self destruct */\n', '  event LogSelfDestruct(address sender, uint amount);\n', '  /* contract self destruct */\n', '  function killThisContract() public onlyOwner {\n', '      emit LogSelfDestruct(msg.sender, address(this).balance);\n', '      selfdestruct(owner);\n', '  }\n', '}']