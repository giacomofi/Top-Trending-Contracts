['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Interface {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '    function approve(address _spender, uint _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public constant returns (uint);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract WeduToken is ERC20Interface {\n', '    /**\n', '     * @dev Constant parameters\n', '     */\n', '    string private TOKEN_NAME;\n', '    string private TOKEN_SYMBOL;\n', '    uint8 private DECIMAL;\n', '    uint private WEDU_UNIT;\n', '\n', '    /**\n', '     * @dev Management parameters\n', '     */\n', '    address owner;\n', '    mapping(address => bool) internal blackList;\n', '\n', '    /**\n', '     * @dev Balance parameters\n', '     */\n', '    uint private totalSupplyValue;\n', '    struct BalanceType {\n', '        uint locked;\n', '        uint unlocked;\n', '    }\n', '\n', '    mapping(address => mapping (address => uint)) internal allowed;\n', '    mapping(address => BalanceType) internal balanceValue;\n', '\n', '\n', '    /**\n', '     * @dev Modifier, Only owner can execute the function\n', '     */\n', '    modifier onlyOwner() { require(owner == msg.sender, "Not a owner"); _;}\n', '\n', '    /**\n', '     * @dev Event, called when the number of token changed\n', '     */\n', '    event ChangeNumberofToken(uint oldValue, uint newValue);\n', '\n', '    /**\n', '     * @dev Constructor, Initialize the name, symbol, etc.\n', '     */\n', '    constructor() public {\n', '        TOKEN_NAME = "Educo-op";\n', '        TOKEN_SYMBOL = "WEDU";\n', '\n', '        DECIMAL = 18;\n', '        WEDU_UNIT = 1000000000000000000;\n', '        totalSupplyValue = 10000000000 * WEDU_UNIT;\n', '\n', '        owner = msg.sender;\n', '        balanceValue[owner].unlocked = totalSupplyValue;\n', '    }\n', '\n', '    /**\n', '     * @dev Main info for WEDU token\n', '     */\n', '    function name() public constant returns (string){ return TOKEN_NAME; }\n', '    function symbol() public constant returns (string){ return TOKEN_SYMBOL; }\n', '    function decimals() public constant returns (uint8){ return DECIMAL; }\n', '    function totalSupply() public constant returns (uint){ return totalSupplyValue; }\n', '\n', '    /**\n', '     * @dev Balance info of WEDU token for each user\n', '     */\n', '    function balanceOf(address _user) public constant returns (uint){ return balanceValue[_user].unlocked+balanceValue[_user].locked; }\n', '    function balanceOfLocked(address _user) public constant returns (uint){ return balanceValue[_user].locked; }\n', '    function balanceOfUnlocked(address _user) public constant returns (uint){ return balanceValue[_user].unlocked; }\n', '\n', '    /**\n', '     * @dev Lock the WEDU token in users\n', '     * @param _who The user for locking WEDU token\n', '     * @param _value The amount of locking WEDU token\n', '     */\n', '    function lockBalance(address _who, uint _value) public onlyOwner {\n', '        // Check the unlocked balance of a user\n', '        require(_value <= balanceValue[_who].unlocked, "Unsufficient balance");\n', '\n', '        uint totalBalanceValue = balanceValue[_who].locked + balanceValue[_who].unlocked;\n', '\n', '        balanceValue[_who].unlocked -= _value;\n', '        balanceValue[_who].locked += _value;\n', '\n', '        assert(totalBalanceValue == balanceValue[_who].locked + balanceValue[_who].unlocked);\n', '    }\n', '\n', '    /**\n', '     * @dev Unlock the WEDU token in users\n', '     * @param _who The user for unlocking WEDU token\n', '     * @param _value The amount of unlocking WEDU token\n', '     */\n', '    function unlockBalance(address _who, uint _value) public onlyOwner {\n', '        // Check the locked balance of a user\n', '        require(_value <= balanceValue[_who].locked, "Unsufficient balance");\n', '\n', '        uint totalBalanceValue = balanceValue[_who].locked + balanceValue[_who].unlocked;\n', '\n', '        balanceValue[_who].locked -= _value;\n', '        balanceValue[_who].unlocked += _value;\n', '\n', '        assert(totalBalanceValue == balanceValue[_who].locked + balanceValue[_who].unlocked);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer the WEDU token\n', '     * @param _from The user who will transmit WEDU token\n', '     * @param _to The user who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal returns (bool){\n', '        // Check the address\n', '        require(_from != address(0), "Address is wrong");\n', '        require(_from != owner, "Owner uses the privateTransfer");\n', '        require(_to != address(0), "Address is wrong");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[_from], "Sender in blacklist");\n', '        require(!blackList[_to], "Receiver in blacklist");\n', '\n', '        // Check the unlocked balance of a user\n', '        require(_value <= balanceValue[_from].unlocked, "Unsufficient balance");\n', '        require(balanceValue[_to].unlocked <= balanceValue[_to].unlocked + _value, "Overflow");\n', '\n', '        uint previousBalances = balanceValue[_from].unlocked + balanceValue[_to].unlocked;\n', '\n', '        balanceValue[_from].unlocked -= _value;\n', '        balanceValue[_to].unlocked += _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        assert(balanceValue[_from].unlocked + balanceValue[_to].unlocked == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool){\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Educo-op transfers the WEDU token to a user\n', '     * @param _to The user who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to a user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function privateTransfer(address _to, uint _value) public onlyOwner returns (bool) {\n', '        // Check the address\n', '        require(_to != address(0), "Address is wrong");\n', '\n', '        // Account balance validation\n', '        require(_value <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '        require(balanceValue[_to].unlocked <= balanceValue[_to].unlocked + _value, "Overflow");\n', '\n', '        uint previousBalances = balanceValue[owner].unlocked + balanceValue[_to].locked;\n', '\n', '        balanceValue[owner].unlocked -= _value;\n', '        balanceValue[_to].locked += _value;\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        assert(balanceValue[owner].unlocked + balanceValue[_to].locked == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Educo-op transfers the WEDU token to multiple users simultaneously\n', '     * @param _tos The users who will receive WEDU token\n', '     * @param _nums The number of users that will receive WEDU token\n', '     * @param _submitBalance The amount of WEDU token transmits to users\n', '     * @return True when the WEDU token transfer success to all users\n', '     */\n', '    function multipleTransfer(address[] _tos, uint _nums, uint _submitBalance) public onlyOwner returns (bool){\n', '        // Check the input parameters\n', '        require(_tos.length == _nums, "Number of users who receives the token is not match");\n', '        require(_submitBalance < 100000000 * WEDU_UNIT, "Too high submit balance");\n', '        require(_nums < 256, "Two high number of users");\n', '        require(_nums*_submitBalance <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '\n', '        balanceValue[owner].unlocked -= (_nums*_submitBalance);\n', '        uint8 numIndex;\n', '        for(numIndex=0; numIndex < _nums; numIndex++){\n', '            require(balanceValue[_tos[numIndex]].unlocked == 0, "Already user has token");\n', '            require(_tos[numIndex] != address(0));\n', '            balanceValue[_tos[numIndex]].unlocked = _submitBalance;\n', '\n', '            emit Transfer(owner, _tos[numIndex], _submitBalance);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Receive the WEDU token from other user\n', '     * @param _from The users who will transmit WEDU token\n', '     * @param _to The users who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool){\n', '        // Check the unlocked balance and allowed balance of a user\n', '        require(allowed[_from][msg.sender] <= balanceValue[_from].unlocked, "Unsufficient allowed balance");\n', '        require(_value <= allowed[_from][msg.sender], "Unsufficient balance");\n', '\n', '        allowed[_from][msg.sender] -= _value;\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the WEDU token transfer to other user\n', '     * @param _spender A user allowed to receive WEDU token\n', '     * @param _value The amount of WEDU token allowed to receive at a user\n', '     * @return True when the WEDU token successfully allowed\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool){\n', '        // Check the address\n', '        require(msg.sender != owner, "Owner uses the privateTransfer");\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(_value <= balanceValue[msg.sender].unlocked, "Unsufficient balance");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        // Is really first Approve??\n', '        require(allowed[msg.sender][_spender] == 0, "Already allowed token exists");\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the amount of WEDU token that allowed to the user\n', '     * @param _owner A user who allowed WEDU token transmission\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @return The amount of WEDU token that allowed to the user\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint){\n', '        // Only the user who related with the token allowance can see the allowance value\n', '        require(msg.sender == _owner || msg.sender == _spender);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of WEDU token that allowed to the user\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @param _addedValue The amount of WEDU token for increasing\n', '     * @return True when the amount of allowed WEDU token successfully increases\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool){\n', '        // Check the address\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(allowed[msg.sender][_spender] > 0, "Not approved until yet");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        require(_addedValue + oldValue <= balanceValue[msg.sender].unlocked, "Unsufficient balance");\n', '\n', '        allowed[msg.sender][_spender] = _addedValue + oldValue;\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of WEDU token that allowed to the user\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @param _substractedValue The amount of WEDU token for decreasing\n', '     * @return True when the amount of allowed WEDU token successfully decreases\n', '     */\n', '    function decreaseApproval(address _spender, uint _substractedValue) public returns (bool){\n', '        // Check the address\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(allowed[msg.sender][_spender] > 0, "Not approved until yet");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_substractedValue > oldValue){\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue - _substractedValue;\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Add the blacklist member\n', '     * @param _who A user who will be blocked\n', '     */\n', '    function addBlackList(address _who) public onlyOwner {\n', '        require(!blackList[_who], "Already, sender in blacklist");\n', '        blackList[_who] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove the blacklist member\n', '     * @param _who A user who will be unblocked\n', '     */\n', '    function removalBlackList(address _who) public onlyOwner {\n', '        require(blackList[_who], "Sender does not included in blacklist");\n', '        blackList[_who] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the total amount of WEDU token\n', '     * @param _value The amount of WEDU token for increasing\n', '     * @return True when the amount of total WEDU token successfully increases\n', '     */\n', '    function tokenIssue(uint _value) public onlyOwner returns (bool) {\n', '        require(totalSupplyValue <= totalSupplyValue + _value, "Overflow");\n', '        uint oldTokenNum = totalSupplyValue;\n', '\n', '        totalSupplyValue += _value;\n', '        balanceValue[owner].unlocked += _value;\n', '\n', '        emit ChangeNumberofToken(oldTokenNum, totalSupplyValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the total amount of WEDU token\n', '     * @param _value The amount of WEDU token for decreasing\n', '     * @return True when the amount of total WEDU token successfully decreases\n', '     */\n', '    function tokenBurn(uint _value) public onlyOwner returns (bool) {\n', '        require(_value <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '        uint oldTokenNum = totalSupplyValue;\n', '\n', '        totalSupplyValue -= _value;\n', '        balanceValue[owner].unlocked -= _value;\n', '\n', '        emit ChangeNumberofToken(oldTokenNum, totalSupplyValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Migrate the owner of this contract\n', '     * @param _owner The user who will receive the manager authority\n', '     * @return The user who receivee the manager authority\n', '     */\n', '    function ownerMigration (address _owner) public onlyOwner returns (address) {\n', '        owner = _owner;\n', '        return owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Kill contract\n', '     */\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Interface {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function decimals() public constant returns (uint8);\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address _owner) public constant returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '    function approve(address _spender, uint _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public constant returns (uint);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract WeduToken is ERC20Interface {\n', '    /**\n', '     * @dev Constant parameters\n', '     */\n', '    string private TOKEN_NAME;\n', '    string private TOKEN_SYMBOL;\n', '    uint8 private DECIMAL;\n', '    uint private WEDU_UNIT;\n', '\n', '    /**\n', '     * @dev Management parameters\n', '     */\n', '    address owner;\n', '    mapping(address => bool) internal blackList;\n', '\n', '    /**\n', '     * @dev Balance parameters\n', '     */\n', '    uint private totalSupplyValue;\n', '    struct BalanceType {\n', '        uint locked;\n', '        uint unlocked;\n', '    }\n', '\n', '    mapping(address => mapping (address => uint)) internal allowed;\n', '    mapping(address => BalanceType) internal balanceValue;\n', '\n', '\n', '    /**\n', '     * @dev Modifier, Only owner can execute the function\n', '     */\n', '    modifier onlyOwner() { require(owner == msg.sender, "Not a owner"); _;}\n', '\n', '    /**\n', '     * @dev Event, called when the number of token changed\n', '     */\n', '    event ChangeNumberofToken(uint oldValue, uint newValue);\n', '\n', '    /**\n', '     * @dev Constructor, Initialize the name, symbol, etc.\n', '     */\n', '    constructor() public {\n', '        TOKEN_NAME = "Educo-op";\n', '        TOKEN_SYMBOL = "WEDU";\n', '\n', '        DECIMAL = 18;\n', '        WEDU_UNIT = 1000000000000000000;\n', '        totalSupplyValue = 10000000000 * WEDU_UNIT;\n', '\n', '        owner = msg.sender;\n', '        balanceValue[owner].unlocked = totalSupplyValue;\n', '    }\n', '\n', '    /**\n', '     * @dev Main info for WEDU token\n', '     */\n', '    function name() public constant returns (string){ return TOKEN_NAME; }\n', '    function symbol() public constant returns (string){ return TOKEN_SYMBOL; }\n', '    function decimals() public constant returns (uint8){ return DECIMAL; }\n', '    function totalSupply() public constant returns (uint){ return totalSupplyValue; }\n', '\n', '    /**\n', '     * @dev Balance info of WEDU token for each user\n', '     */\n', '    function balanceOf(address _user) public constant returns (uint){ return balanceValue[_user].unlocked+balanceValue[_user].locked; }\n', '    function balanceOfLocked(address _user) public constant returns (uint){ return balanceValue[_user].locked; }\n', '    function balanceOfUnlocked(address _user) public constant returns (uint){ return balanceValue[_user].unlocked; }\n', '\n', '    /**\n', '     * @dev Lock the WEDU token in users\n', '     * @param _who The user for locking WEDU token\n', '     * @param _value The amount of locking WEDU token\n', '     */\n', '    function lockBalance(address _who, uint _value) public onlyOwner {\n', '        // Check the unlocked balance of a user\n', '        require(_value <= balanceValue[_who].unlocked, "Unsufficient balance");\n', '\n', '        uint totalBalanceValue = balanceValue[_who].locked + balanceValue[_who].unlocked;\n', '\n', '        balanceValue[_who].unlocked -= _value;\n', '        balanceValue[_who].locked += _value;\n', '\n', '        assert(totalBalanceValue == balanceValue[_who].locked + balanceValue[_who].unlocked);\n', '    }\n', '\n', '    /**\n', '     * @dev Unlock the WEDU token in users\n', '     * @param _who The user for unlocking WEDU token\n', '     * @param _value The amount of unlocking WEDU token\n', '     */\n', '    function unlockBalance(address _who, uint _value) public onlyOwner {\n', '        // Check the locked balance of a user\n', '        require(_value <= balanceValue[_who].locked, "Unsufficient balance");\n', '\n', '        uint totalBalanceValue = balanceValue[_who].locked + balanceValue[_who].unlocked;\n', '\n', '        balanceValue[_who].locked -= _value;\n', '        balanceValue[_who].unlocked += _value;\n', '\n', '        assert(totalBalanceValue == balanceValue[_who].locked + balanceValue[_who].unlocked);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer the WEDU token\n', '     * @param _from The user who will transmit WEDU token\n', '     * @param _to The user who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal returns (bool){\n', '        // Check the address\n', '        require(_from != address(0), "Address is wrong");\n', '        require(_from != owner, "Owner uses the privateTransfer");\n', '        require(_to != address(0), "Address is wrong");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[_from], "Sender in blacklist");\n', '        require(!blackList[_to], "Receiver in blacklist");\n', '\n', '        // Check the unlocked balance of a user\n', '        require(_value <= balanceValue[_from].unlocked, "Unsufficient balance");\n', '        require(balanceValue[_to].unlocked <= balanceValue[_to].unlocked + _value, "Overflow");\n', '\n', '        uint previousBalances = balanceValue[_from].unlocked + balanceValue[_to].unlocked;\n', '\n', '        balanceValue[_from].unlocked -= _value;\n', '        balanceValue[_to].unlocked += _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        assert(balanceValue[_from].unlocked + balanceValue[_to].unlocked == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool){\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Educo-op transfers the WEDU token to a user\n', '     * @param _to The user who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to a user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function privateTransfer(address _to, uint _value) public onlyOwner returns (bool) {\n', '        // Check the address\n', '        require(_to != address(0), "Address is wrong");\n', '\n', '        // Account balance validation\n', '        require(_value <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '        require(balanceValue[_to].unlocked <= balanceValue[_to].unlocked + _value, "Overflow");\n', '\n', '        uint previousBalances = balanceValue[owner].unlocked + balanceValue[_to].locked;\n', '\n', '        balanceValue[owner].unlocked -= _value;\n', '        balanceValue[_to].locked += _value;\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        assert(balanceValue[owner].unlocked + balanceValue[_to].locked == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Educo-op transfers the WEDU token to multiple users simultaneously\n', '     * @param _tos The users who will receive WEDU token\n', '     * @param _nums The number of users that will receive WEDU token\n', '     * @param _submitBalance The amount of WEDU token transmits to users\n', '     * @return True when the WEDU token transfer success to all users\n', '     */\n', '    function multipleTransfer(address[] _tos, uint _nums, uint _submitBalance) public onlyOwner returns (bool){\n', '        // Check the input parameters\n', '        require(_tos.length == _nums, "Number of users who receives the token is not match");\n', '        require(_submitBalance < 100000000 * WEDU_UNIT, "Too high submit balance");\n', '        require(_nums < 256, "Two high number of users");\n', '        require(_nums*_submitBalance <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '\n', '        balanceValue[owner].unlocked -= (_nums*_submitBalance);\n', '        uint8 numIndex;\n', '        for(numIndex=0; numIndex < _nums; numIndex++){\n', '            require(balanceValue[_tos[numIndex]].unlocked == 0, "Already user has token");\n', '            require(_tos[numIndex] != address(0));\n', '            balanceValue[_tos[numIndex]].unlocked = _submitBalance;\n', '\n', '            emit Transfer(owner, _tos[numIndex], _submitBalance);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Receive the WEDU token from other user\n', '     * @param _from The users who will transmit WEDU token\n', '     * @param _to The users who will receive WEDU token\n', '     * @param _value The amount of WEDU token transmits to user\n', '     * @return True when the WEDU token transfer success\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool){\n', '        // Check the unlocked balance and allowed balance of a user\n', '        require(allowed[_from][msg.sender] <= balanceValue[_from].unlocked, "Unsufficient allowed balance");\n', '        require(_value <= allowed[_from][msg.sender], "Unsufficient balance");\n', '\n', '        allowed[_from][msg.sender] -= _value;\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the WEDU token transfer to other user\n', '     * @param _spender A user allowed to receive WEDU token\n', '     * @param _value The amount of WEDU token allowed to receive at a user\n', '     * @return True when the WEDU token successfully allowed\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool){\n', '        // Check the address\n', '        require(msg.sender != owner, "Owner uses the privateTransfer");\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(_value <= balanceValue[msg.sender].unlocked, "Unsufficient balance");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        // Is really first Approve??\n', '        require(allowed[msg.sender][_spender] == 0, "Already allowed token exists");\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the amount of WEDU token that allowed to the user\n', '     * @param _owner A user who allowed WEDU token transmission\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @return The amount of WEDU token that allowed to the user\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint){\n', '        // Only the user who related with the token allowance can see the allowance value\n', '        require(msg.sender == _owner || msg.sender == _spender);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of WEDU token that allowed to the user\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @param _addedValue The amount of WEDU token for increasing\n', '     * @return True when the amount of allowed WEDU token successfully increases\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool){\n', '        // Check the address\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(allowed[msg.sender][_spender] > 0, "Not approved until yet");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        require(_addedValue + oldValue <= balanceValue[msg.sender].unlocked, "Unsufficient balance");\n', '\n', '        allowed[msg.sender][_spender] = _addedValue + oldValue;\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of WEDU token that allowed to the user\n', '     * @param _spender A user who allowed WEDU token reception\n', '     * @param _substractedValue The amount of WEDU token for decreasing\n', '     * @return True when the amount of allowed WEDU token successfully decreases\n', '     */\n', '    function decreaseApproval(address _spender, uint _substractedValue) public returns (bool){\n', '        // Check the address\n', '        require(_spender != address(0), "Address is wrong");\n', '        require(allowed[msg.sender][_spender] > 0, "Not approved until yet");\n', '\n', '        // Check a user included in blacklist\n', '        require(!blackList[msg.sender], "Sender in blacklist");\n', '        require(!blackList[_spender], "Receiver in blacklist");\n', '\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_substractedValue > oldValue){\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue - _substractedValue;\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Add the blacklist member\n', '     * @param _who A user who will be blocked\n', '     */\n', '    function addBlackList(address _who) public onlyOwner {\n', '        require(!blackList[_who], "Already, sender in blacklist");\n', '        blackList[_who] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove the blacklist member\n', '     * @param _who A user who will be unblocked\n', '     */\n', '    function removalBlackList(address _who) public onlyOwner {\n', '        require(blackList[_who], "Sender does not included in blacklist");\n', '        blackList[_who] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the total amount of WEDU token\n', '     * @param _value The amount of WEDU token for increasing\n', '     * @return True when the amount of total WEDU token successfully increases\n', '     */\n', '    function tokenIssue(uint _value) public onlyOwner returns (bool) {\n', '        require(totalSupplyValue <= totalSupplyValue + _value, "Overflow");\n', '        uint oldTokenNum = totalSupplyValue;\n', '\n', '        totalSupplyValue += _value;\n', '        balanceValue[owner].unlocked += _value;\n', '\n', '        emit ChangeNumberofToken(oldTokenNum, totalSupplyValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the total amount of WEDU token\n', '     * @param _value The amount of WEDU token for decreasing\n', '     * @return True when the amount of total WEDU token successfully decreases\n', '     */\n', '    function tokenBurn(uint _value) public onlyOwner returns (bool) {\n', '        require(_value <= balanceValue[owner].unlocked, "Unsufficient balance");\n', '        uint oldTokenNum = totalSupplyValue;\n', '\n', '        totalSupplyValue -= _value;\n', '        balanceValue[owner].unlocked -= _value;\n', '\n', '        emit ChangeNumberofToken(oldTokenNum, totalSupplyValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Migrate the owner of this contract\n', '     * @param _owner The user who will receive the manager authority\n', '     * @return The user who receivee the manager authority\n', '     */\n', '    function ownerMigration (address _owner) public onlyOwner returns (address) {\n', '        owner = _owner;\n', '        return owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Kill contract\n', '     */\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
