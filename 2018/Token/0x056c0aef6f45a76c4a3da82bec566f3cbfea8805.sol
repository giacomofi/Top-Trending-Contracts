['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function decimals() public view returns(uint digits);\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract BurnableToken is ERC20 {\n', '\n', '    function burn(uint256 _value) public returns (bool success);\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success);\n', '\n', '    event Burn(address indexed _from, uint256 _value);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address newOwner=0x0;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    ///change the owner\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// accept the ownership\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    /// `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Controlled is Ownable{\n', '\n', '    function Controlled() public {\n', '        exclude[msg.sender] = true;\n', '        exclude[this] = true;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        if(msg.sender != owner){\n', '            require(admins[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '\n', '    mapping(address => bool) admins;\n', '\n', '    // Flag that determines if the token is transferable or not.\n', '    bool public transferEnabled = false;\n', '\n', '    // frozen account\n', '    mapping(address => bool) exclude;\n', '    mapping(address => bool) locked;\n', '    mapping(address => bool) public frozenAccount;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '\n', '    function setAdmin(address _addr, bool isAdmin) public onlyOwner\n', '    returns (bool success){\n', '        admins[_addr]=isAdmin;\n', '        return true;\n', '    }\n', '\n', '\n', '    function enableTransfer(bool _enable) public onlyOwner{\n', '        transferEnabled=_enable;\n', '    }\n', '\n', '\n', '    function setExclude(address _addr, bool isExclude) public onlyOwner returns (bool success){\n', '        exclude[_addr]=isExclude;\n', '        return true;\n', '    }\n', '\n', '    function setLock(address _addr, bool isLock) public onlyAdmin returns (bool success){\n', '        locked[_addr]=isLock;\n', '        return true;\n', '    }\n', '\n', '\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    modifier transferAllowed(address _addr) {\n', '        require(!frozenAccount[_addr]);\n', '        if (!exclude[_addr]) {\n', '            require(transferEnabled);\n', '            require(!locked[_addr]);\n', '        }\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract TokenERC20 is  ERC20, BurnableToken, Controlled {\n', '\n', '    using SafeMath for uint256;\n', '\n', '   // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    string public version = &#39;v1.0&#39;;\n', '\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balanceOf\n', '    mapping (address => uint256)  public balanceOf;\n', '    mapping (address => mapping (address => uint256))  public allowance;\n', '\n', '\n', '    function totalSupply() public view returns (uint supply){\n', '        return totalSupply;\n', '    }\n', '    function decimals() public view returns(uint digits){\n', '        return decimals;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance){\n', '        return balanceOf[_owner];\n', '    }\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining){\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) transferAllowed(_from) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) transferAllowed(_from) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '    returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '    public\n', '    returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '     /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract AdvancedToken is  TokenERC20 {\n', '\n', '    uint  constant internal ETH_DECIMALS = 18;\n', '    uint  constant internal PRECISION = (10**18);\n', '\n', '    // allocate end time, default is now plus 1 days\n', '    uint256 public allocateEndTime;\n', '\n', '    function AdvancedToken() public {\n', '       allocateEndTime = now + 1 days;\n', '    }\n', '\n', '    // Allocate tokens to the users\n', '    // @param _owners The owners list of the token\n', '    // @param _values The value list of the token (value = _value * 10 ** decimals)\n', '    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\n', '        require(allocateEndTime > now);\n', '        require(_owners.length == _values.length);\n', '        for(uint256 i = 0; i < _owners.length ; i++){\n', '            address to = _owners[i];\n', '            uint256 value = _values[i] * 10 ** uint256(decimals);\n', '            require(totalSupply + value > totalSupply && balanceOf[to] + value > balanceOf[to]) ;\n', '            totalSupply += value;\n', '            balanceOf[to] += value;\n', '        }\n', '    }\n', '\n', '\n', '    //Early stage investing\n', '    bool enableEarlyStage = false;\n', '    uint256 public totalEarlyStage;\n', '    uint256 remainEarlyStage;\n', '    uint256 earlyStagePrice;   //PRECISION=10**18\n', '    uint256 earlyStageGiftRate;     //x/10000\n', '\n', '    // air drop token\n', '    bool enableAirdrop = false;\n', '    uint256 public totalAirdrop;\n', '    uint256 remainAirdrop;\n', '    mapping (address => bool) dropList;\n', '    uint256 public airdropValue;\n', '\n', '\n', '    modifier canEarlyStage() {\n', '        require(enableEarlyStage && remainEarlyStage>0 && earlyStagePrice>0 && balanceOf[this]>0);\n', '        _;\n', '    }\n', '\n', '    modifier canAirdrop() {\n', '        require(enableAirdrop && remainAirdrop>0);\n', '        _;\n', '    }\n', '\n', '    modifier canGetTokens() {\n', '        require(enableAirdrop && remainAirdrop>0 &&  airdropValue>0);\n', '        require(dropList[msg.sender] == false);\n', '        _;\n', '    }\n', '\n', '    function setEarlyParams (bool isEarlyStage, uint256 _price, uint256 _earlyStageGiftRate) onlyOwner public {\n', '        if(isEarlyStage){\n', '            require(_price>0);\n', '            require(_earlyStageGiftRate>=0 && _earlyStageGiftRate<= 10000 );\n', '        }\n', '        enableEarlyStage = isEarlyStage;\n', '        if(_price>0){\n', '            earlyStagePrice = _price;\n', '        }\n', '        if(_earlyStageGiftRate>0){\n', '            earlyStageGiftRate = _earlyStageGiftRate;\n', '        }\n', '\n', '    }\n', '\n', '    function setAirdropParams (bool isAirdrop, uint256 _value) onlyAdmin public {\n', '        if(isAirdrop){\n', '            require(_value>0);\n', '        }\n', '        airdropValue = _value;\n', '    }\n', '\n', '\n', '    function setAirdorpList(address[] addresses, bool hasDrop) onlyAdmin public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            dropList[addresses[i]] = hasDrop;\n', '        }\n', '    }\n', '\n', '\n', '    /// @notice Buy tokens from contract by sending ether\n', '     function buy() payable public {\n', '         _buy(msg.value);\n', '     }\n', '\n', '    function _buy(uint256 value)  private returns(uint256){\n', '        uint256 amount = 0;\n', '        if(value>0){\n', '            amount = uint256(PRECISION).mul(value).div(earlyStagePrice).div(10**uint256(ETH_DECIMALS-decimals));    // calculates the amount\n', '        }\n', '        if(amount>0){\n', '            _transfer(this, msg.sender, amount);\n', '            if(earlyStageGiftRate>0){\n', '                _transfer(this, msg.sender, amount.mul(earlyStageGiftRate).div(10000));\n', '            }\n', '        }\n', '        return amount;\n', '    }\n', '\n', '\n', '    function () payable public {\n', '        if(msg.value>0){\n', '            _buy(msg.value);\n', '        }\n', '        if( enableAirdrop && remainAirdrop>0  &&  airdropValue>0 && dropList[msg.sender] == false){\n', '             _getTokens();\n', '        }\n', '    }\n', '\n', '\n', '    function _airdrop(address _owner, uint256 _value)  canAirdrop private returns(bool) {\n', '        require(_value>0);\n', '        _transfer(this, _owner, _value);\n', '        return true;\n', '    }\n', '\n', '     // drop token\n', '    function airdrop(address[] _owners, uint256 _value) onlyAdmin canAirdrop public {\n', '         require(_value>0 && remainAirdrop>= _value * _owners.length);\n', '         for(uint256 i = 0; i < _owners.length ; i++){\n', '             _airdrop(_owners[i], _value);\n', '        }\n', '     }\n', '\n', '\n', '    function _getTokens()  private returns(bool) {\n', '        address investor = msg.sender;\n', '        uint256 toGive = airdropValue;\n', '        if (toGive > 0) {\n', '            _airdrop(investor, toGive);\n', '            dropList[investor] = true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * Proxy transfer  token. When some users of the ethereum account has no ether,\n', '    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\n', '    * @param _from\n', '    * @param _to\n', '    * @param _value\n', '    * @param feeProxy\n', '    * @param _v\n', '    * @param _r\n', '    * @param _s\n', '    */\n', '    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n', '        require(_value + _feeProxy >= _value);\n', '        require(balanceOf[_from] >=_value  + _feeProxy);\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\n', '        require(_from == ecrecover(h,_v,_r,_s));\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(balanceOf[msg.sender] + _feeProxy > balanceOf[msg.sender]);\n', '        balanceOf[_from] -= (_value  + _feeProxy);\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        if(_feeProxy>0){\n', '            balanceOf[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '\n', '    // support withdraw\n', '    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw all ERC20 compatible tokens\n', '     * @param token ERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyOwner {\n', '        require(token.transfer(sendTo, amount));\n', '        TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    event EtherWithdraw(uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint amount, address sendTo) external onlyOwner {\n', '        sendTo.transfer(amount);\n', '        EtherWithdraw(amount, sendTo);\n', '    }\n', '\n', '\n', '    // The nonce for avoid transfer replay attacks\n', '    mapping(address => uint256) nonces;\n', '\n', '    /*\n', '     * Get the nonce\n', '     * @param _addr\n', '     */\n', '    function getNonce(address _addr) public constant returns (uint256){\n', '        return nonces[_addr];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract SafeasyToken is AdvancedToken {\n', '\n', '   function SafeasyToken() public{\n', '        name = "Safeasy Token";\n', '        decimals = 6;\n', '        symbol = "SET";\n', '        version = &#39;v1.1&#39;;\n', '\n', '        uint256 initialSupply = uint256(2* 10 ** 9);\n', '        totalSupply = initialSupply.mul( 10 ** uint256(decimals));\n', '\n', '        enableEarlyStage = true;\n', '        totalEarlyStage = totalSupply.div(100).mul(30);\n', '        remainEarlyStage = totalEarlyStage;\n', '        earlyStagePrice = 10 ** 14; // 10**18=1:1eth, 10**15=1000:1eth\n', '        earlyStageGiftRate = 2000;  // 100=1%\n', '        enableAirdrop = true;\n', '        totalAirdrop = totalSupply.div(100).mul(15);\n', '        remainAirdrop = totalAirdrop;\n', '        airdropValue = 50000000;\n', '\n', '        uint256 totalDistributed = totalEarlyStage.add(totalAirdrop);\n', '        balanceOf[this] = totalDistributed;\n', '        balanceOf[msg.sender] = totalSupply.sub(totalDistributed);\n', '\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function decimals() public view returns(uint digits);\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract BurnableToken is ERC20 {\n', '\n', '    function burn(uint256 _value) public returns (bool success);\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success);\n', '\n', '    event Burn(address indexed _from, uint256 _value);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address newOwner=0x0;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    ///change the owner\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// accept the ownership\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    /// `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Controlled is Ownable{\n', '\n', '    function Controlled() public {\n', '        exclude[msg.sender] = true;\n', '        exclude[this] = true;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        if(msg.sender != owner){\n', '            require(admins[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '\n', '    mapping(address => bool) admins;\n', '\n', '    // Flag that determines if the token is transferable or not.\n', '    bool public transferEnabled = false;\n', '\n', '    // frozen account\n', '    mapping(address => bool) exclude;\n', '    mapping(address => bool) locked;\n', '    mapping(address => bool) public frozenAccount;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '\n', '    function setAdmin(address _addr, bool isAdmin) public onlyOwner\n', '    returns (bool success){\n', '        admins[_addr]=isAdmin;\n', '        return true;\n', '    }\n', '\n', '\n', '    function enableTransfer(bool _enable) public onlyOwner{\n', '        transferEnabled=_enable;\n', '    }\n', '\n', '\n', '    function setExclude(address _addr, bool isExclude) public onlyOwner returns (bool success){\n', '        exclude[_addr]=isExclude;\n', '        return true;\n', '    }\n', '\n', '    function setLock(address _addr, bool isLock) public onlyAdmin returns (bool success){\n', '        locked[_addr]=isLock;\n', '        return true;\n', '    }\n', '\n', '\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    modifier transferAllowed(address _addr) {\n', '        require(!frozenAccount[_addr]);\n', '        if (!exclude[_addr]) {\n', '            require(transferEnabled);\n', '            require(!locked[_addr]);\n', '        }\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract TokenERC20 is  ERC20, BurnableToken, Controlled {\n', '\n', '    using SafeMath for uint256;\n', '\n', '   // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', "    string public version = 'v1.0';\n", '\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balanceOf\n', '    mapping (address => uint256)  public balanceOf;\n', '    mapping (address => mapping (address => uint256))  public allowance;\n', '\n', '\n', '    function totalSupply() public view returns (uint supply){\n', '        return totalSupply;\n', '    }\n', '    function decimals() public view returns(uint digits){\n', '        return decimals;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance){\n', '        return balanceOf[_owner];\n', '    }\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining){\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) transferAllowed(_from) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) transferAllowed(_from) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '    returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '    public\n', '    returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '     /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '        totalSupply -= _value;                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract AdvancedToken is  TokenERC20 {\n', '\n', '    uint  constant internal ETH_DECIMALS = 18;\n', '    uint  constant internal PRECISION = (10**18);\n', '\n', '    // allocate end time, default is now plus 1 days\n', '    uint256 public allocateEndTime;\n', '\n', '    function AdvancedToken() public {\n', '       allocateEndTime = now + 1 days;\n', '    }\n', '\n', '    // Allocate tokens to the users\n', '    // @param _owners The owners list of the token\n', '    // @param _values The value list of the token (value = _value * 10 ** decimals)\n', '    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\n', '        require(allocateEndTime > now);\n', '        require(_owners.length == _values.length);\n', '        for(uint256 i = 0; i < _owners.length ; i++){\n', '            address to = _owners[i];\n', '            uint256 value = _values[i] * 10 ** uint256(decimals);\n', '            require(totalSupply + value > totalSupply && balanceOf[to] + value > balanceOf[to]) ;\n', '            totalSupply += value;\n', '            balanceOf[to] += value;\n', '        }\n', '    }\n', '\n', '\n', '    //Early stage investing\n', '    bool enableEarlyStage = false;\n', '    uint256 public totalEarlyStage;\n', '    uint256 remainEarlyStage;\n', '    uint256 earlyStagePrice;   //PRECISION=10**18\n', '    uint256 earlyStageGiftRate;     //x/10000\n', '\n', '    // air drop token\n', '    bool enableAirdrop = false;\n', '    uint256 public totalAirdrop;\n', '    uint256 remainAirdrop;\n', '    mapping (address => bool) dropList;\n', '    uint256 public airdropValue;\n', '\n', '\n', '    modifier canEarlyStage() {\n', '        require(enableEarlyStage && remainEarlyStage>0 && earlyStagePrice>0 && balanceOf[this]>0);\n', '        _;\n', '    }\n', '\n', '    modifier canAirdrop() {\n', '        require(enableAirdrop && remainAirdrop>0);\n', '        _;\n', '    }\n', '\n', '    modifier canGetTokens() {\n', '        require(enableAirdrop && remainAirdrop>0 &&  airdropValue>0);\n', '        require(dropList[msg.sender] == false);\n', '        _;\n', '    }\n', '\n', '    function setEarlyParams (bool isEarlyStage, uint256 _price, uint256 _earlyStageGiftRate) onlyOwner public {\n', '        if(isEarlyStage){\n', '            require(_price>0);\n', '            require(_earlyStageGiftRate>=0 && _earlyStageGiftRate<= 10000 );\n', '        }\n', '        enableEarlyStage = isEarlyStage;\n', '        if(_price>0){\n', '            earlyStagePrice = _price;\n', '        }\n', '        if(_earlyStageGiftRate>0){\n', '            earlyStageGiftRate = _earlyStageGiftRate;\n', '        }\n', '\n', '    }\n', '\n', '    function setAirdropParams (bool isAirdrop, uint256 _value) onlyAdmin public {\n', '        if(isAirdrop){\n', '            require(_value>0);\n', '        }\n', '        airdropValue = _value;\n', '    }\n', '\n', '\n', '    function setAirdorpList(address[] addresses, bool hasDrop) onlyAdmin public {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            dropList[addresses[i]] = hasDrop;\n', '        }\n', '    }\n', '\n', '\n', '    /// @notice Buy tokens from contract by sending ether\n', '     function buy() payable public {\n', '         _buy(msg.value);\n', '     }\n', '\n', '    function _buy(uint256 value)  private returns(uint256){\n', '        uint256 amount = 0;\n', '        if(value>0){\n', '            amount = uint256(PRECISION).mul(value).div(earlyStagePrice).div(10**uint256(ETH_DECIMALS-decimals));    // calculates the amount\n', '        }\n', '        if(amount>0){\n', '            _transfer(this, msg.sender, amount);\n', '            if(earlyStageGiftRate>0){\n', '                _transfer(this, msg.sender, amount.mul(earlyStageGiftRate).div(10000));\n', '            }\n', '        }\n', '        return amount;\n', '    }\n', '\n', '\n', '    function () payable public {\n', '        if(msg.value>0){\n', '            _buy(msg.value);\n', '        }\n', '        if( enableAirdrop && remainAirdrop>0  &&  airdropValue>0 && dropList[msg.sender] == false){\n', '             _getTokens();\n', '        }\n', '    }\n', '\n', '\n', '    function _airdrop(address _owner, uint256 _value)  canAirdrop private returns(bool) {\n', '        require(_value>0);\n', '        _transfer(this, _owner, _value);\n', '        return true;\n', '    }\n', '\n', '     // drop token\n', '    function airdrop(address[] _owners, uint256 _value) onlyAdmin canAirdrop public {\n', '         require(_value>0 && remainAirdrop>= _value * _owners.length);\n', '         for(uint256 i = 0; i < _owners.length ; i++){\n', '             _airdrop(_owners[i], _value);\n', '        }\n', '     }\n', '\n', '\n', '    function _getTokens()  private returns(bool) {\n', '        address investor = msg.sender;\n', '        uint256 toGive = airdropValue;\n', '        if (toGive > 0) {\n', '            _airdrop(investor, toGive);\n', '            dropList[investor] = true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /*\n', '    * Proxy transfer  token. When some users of the ethereum account has no ether,\n', '    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\n', '    * @param _from\n', '    * @param _to\n', '    * @param _value\n', '    * @param feeProxy\n', '    * @param _v\n', '    * @param _r\n', '    * @param _s\n', '    */\n', '    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\n', '        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n', '        require(_value + _feeProxy >= _value);\n', '        require(balanceOf[_from] >=_value  + _feeProxy);\n', '        uint256 nonce = nonces[_from];\n', '        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\n', '        require(_from == ecrecover(h,_v,_r,_s));\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(balanceOf[msg.sender] + _feeProxy > balanceOf[msg.sender]);\n', '        balanceOf[_from] -= (_value  + _feeProxy);\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        if(_feeProxy>0){\n', '            balanceOf[msg.sender] += _feeProxy;\n', '            Transfer(_from, msg.sender, _feeProxy);\n', '        }\n', '        nonces[_from] = nonce + 1;\n', '        return true;\n', '    }\n', '\n', '    // support withdraw\n', '    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw all ERC20 compatible tokens\n', '     * @param token ERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyOwner {\n', '        require(token.transfer(sendTo, amount));\n', '        TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    event EtherWithdraw(uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint amount, address sendTo) external onlyOwner {\n', '        sendTo.transfer(amount);\n', '        EtherWithdraw(amount, sendTo);\n', '    }\n', '\n', '\n', '    // The nonce for avoid transfer replay attacks\n', '    mapping(address => uint256) nonces;\n', '\n', '    /*\n', '     * Get the nonce\n', '     * @param _addr\n', '     */\n', '    function getNonce(address _addr) public constant returns (uint256){\n', '        return nonces[_addr];\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract SafeasyToken is AdvancedToken {\n', '\n', '   function SafeasyToken() public{\n', '        name = "Safeasy Token";\n', '        decimals = 6;\n', '        symbol = "SET";\n', "        version = 'v1.1';\n", '\n', '        uint256 initialSupply = uint256(2* 10 ** 9);\n', '        totalSupply = initialSupply.mul( 10 ** uint256(decimals));\n', '\n', '        enableEarlyStage = true;\n', '        totalEarlyStage = totalSupply.div(100).mul(30);\n', '        remainEarlyStage = totalEarlyStage;\n', '        earlyStagePrice = 10 ** 14; // 10**18=1:1eth, 10**15=1000:1eth\n', '        earlyStageGiftRate = 2000;  // 100=1%\n', '        enableAirdrop = true;\n', '        totalAirdrop = totalSupply.div(100).mul(15);\n', '        remainAirdrop = totalAirdrop;\n', '        airdropValue = 50000000;\n', '\n', '        uint256 totalDistributed = totalEarlyStage.add(totalAirdrop);\n', '        balanceOf[this] = totalDistributed;\n', '        balanceOf[msg.sender] = totalSupply.sub(totalDistributed);\n', '\n', '    }\n', '}']
