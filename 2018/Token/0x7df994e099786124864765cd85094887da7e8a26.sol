['pragma solidity ^0.4.23;\n', '\n', 'contract APS{\n', '    string public name; // AutopaymentParkingSystem\n', '    string public symbol; // APS\n', '    uint256 public decimals = 18;\n', '    uint256 public totalSupply; \n', '    address public centralMinter; // Urbana\n', '    uint256 public divisor; // Denominator used with buyPrice, sellPrice. If value(APS) > value(ETH), divisor = 1. Otherwise, divisor = 10**N()\n', '    uint256 public buyPrice; // Numerator used with divisor. 1 APS = ($buyPrice) ETH.\n', '    uint256 public sellPrice;  // Numerator used with divisor. 1 APS = ($sellPrice) ETH.\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping(address => uint256)) allowed;\n', '    mapping (address => bool) public frozenAccount; // freezing balances of invalid account\n', '\n', '    event SetPrice(uint256 buyPrice, uint256 sellPrice);\n', '    event MintToken(uint256 amount);\n', '    event BurnToken(uint256 amount);\n', '    event FrozenAccounts(address target, bool frozen);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);    \n', '    function APS(\n', '        string tokenName,\n', '        string tokenSymbol,\n', '        uint256 initialSupply\n', '    ) public {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        totalSupply = initialSupply * 10 ** decimals;\n', '        balanceOf[msg.sender] = totalSupply; \n', '        centralMinter = msg.sender;\n', '    }\n', '\n', '    modifier onlyCentralMinter {\n', '        require(msg.sender == centralMinter);\n', '        _;\n', '    }\n', '\n', '    /*  \n', '     * CentralMinter Functions \n', '     * Functions related with controlling amount of APS in circulation\n', '     * Functions related with controlling node accounts\n', '     */\n', '\n', '    // Set buy/sell price of APS\n', '    function setPrices(uint256 newBuyPrice,uint256 newSellPrice, uint256 newDivisor) public onlyCentralMinter {\n', '        buyPrice = newBuyPrice;\n', '        sellPrice = newSellPrice;\n', '        divisor = newDivisor;\n', '        emit SetPrice(buyPrice,sellPrice);\n', '    }\n', '\n', '    // Issue new tokens in circulation\n', '    function mintToken(uint256 mintedAmount) public onlyCentralMinter{\n', '        balanceOf[centralMinter] += mintedAmount;\n', '        totalSupply += mintedAmount;\n', '        emit MintToken(mintedAmount);\n', '    }\n', '\n', '    // Remove tokens from circulation to control token prcie\n', '    function burnToken(uint256 burnedAmount) public onlyCentralMinter{\n', '        balanceOf[centralMinter] -= burnedAmount;\n', '        totalSupply -= burnedAmount;\n', '        emit BurnToken(burnedAmount);\n', '    }\n', '\n', '    function freezeAccount(address target,bool freeze) public onlyCentralMinter{\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenAccounts(target,freeze);\n', '    }\n', '\n', '    /*  \n', '     * Node functions\n', '     * Functions related with buying/selling APS\n', '     * ERC20 Token functions\n', '     */\n', '    \n', '    function buy() payable public returns (uint256 amount) {\n', '        if(divisor == 1) amount = msg.value / buyPrice;\n', '        else amount = msg.value * (divisor/buyPrice);\n', '        require(balanceOf[centralMinter]>= amount);\n', '        balanceOf[msg.sender] += amount;\n', '        balanceOf[centralMinter] -= amount;\n', '        emit Transfer(centralMinter,msg.sender,amount);\n', '        return amount;       \n', '    }\n', '\n', '    \n', '    function sell(uint256 amount) payable public returns (uint256 revenue) {\n', '        require(balanceOf[msg.sender]>=amount);\n', '        balanceOf[msg.sender] -= amount;\n', '        balanceOf[centralMinter] += amount;\n', '        revenue = amount * sellPrice / divisor;\n', '        msg.sender.transfer(revenue); \n', '        emit Transfer(msg.sender,centralMinter,amount);\n', '        return revenue;\n', '    }\n', '\n', '    /*  ERC20 Token Functions\n', '     *  NOTE : ERC223, ERC721 could be used as an alternative to current ERC20 Tokens\n', '     */\n', '\n', '    // ERC20 Standard: Get the total token supply\n', '    function totalSupply() public constant returns (uint256){\n', '        return totalSupply;\n', '    }\n', '\n', '    // ERC20 Standard: Get the account balance of another account with address tokenOwner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance){\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    // ERC20 Standard: Returns the amount which spender is still allowed to withdraw from tokenOwner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require(_to != 0x0);\n', '        require(!frozenAccount[_from]);\n', '        require(!frozenAccount[_to]);\n', '        require(balanceOf[_from]>= _value);\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        uint256 totalBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from,_to,_value);\n', '        assert(totalBalances == balanceOf[_from] + balanceOf[_to]);\n', '    }\n', '\n', '    // ERC20 Standard: Send tokens amount of tokens to address to\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        _transfer(msg.sender,_to,_value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 Standard: Allow spender to withdraw from your account, multiple times, up to the tokens amount. \n', '    function approve(address _spender, uint256 _value) public returns (bool success){\n', '        require(_spender != 0x0);\n', '        require(balanceOf[msg.sender]>=_value);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender,_spender,_value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 Standard: send tokens from address from to address to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\n', '        require(allowed[_from][msg.sender]>=_value);\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from,_to,_value);\n', '        // emit Transfer(msg.sender,_from,_to,_value);\n', '        emit Transfer(_from,_to,_value);\n', '        return true;\n', '    }\n', '}']