['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Utils/Math.sol\n', '\n', 'library MathUtils {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint result = a + b;\n', '\n', '        if (a == 0 || b == 0) {\n', '            return result;\n', '        }\n', '\n', '        require(result > a && result > b);\n', '\n', '        return result;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(a >= b);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint result = a * b;\n', '\n', '        require(result / a == b);\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/Balance.sol\n', '\n', 'contract Balance {\n', '    mapping(address => uint) public balances;\n', '\n', '    // ERC20 function\n', '    function balanceOf(address account) public constant returns (uint) {\n', '        return balances[account];\n', '    }\n', '\n', '    modifier hasSufficientBalance(address account, uint balance) {\n', '        require(balances[account] >= balance);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Utils/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function isOwner() view public returns (bool) {\n', '        return msg.sender == owner;\n', '    }\n', '\n', '    modifier grantOwner {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/CrowdsaleState.sol\n', '\n', 'interface CrowdsaleState {\n', '    function isCrowdsaleSuccessful() external view returns(bool);\n', '}\n', '\n', '// File: contracts/Token/HardCap.sol\n', '\n', 'interface HardCap {\n', '    function getHardCap() external pure returns(uint);\n', '}\n', '\n', '// File: contracts/Token/Crowdsale.sol\n', '\n', 'contract Crowdsale is Ownable {\n', '    address public crowdsaleContract;\n', '\n', '    function isCrowdsale() internal view returns(bool) {\n', '        return crowdsaleSet() && msg.sender == crowdsaleContract;\n', '    }\n', '\n', '    function crowdsaleSet() internal view returns(bool) {\n', '        return crowdsaleContract != address(0);\n', '    }\n', '\n', '    function addressIsCrowdsale(address _address) public view returns(bool) {\n', '        return crowdsaleSet() && crowdsaleContract == _address;\n', '    }\n', '\n', '    function setCrowdsaleContract(address crowdsale) public grantOwner {\n', '        require(crowdsaleContract == address(0));\n', '        crowdsaleContract = crowdsale;\n', '    }\n', '\n', '    function crowdsaleSuccessful() internal view returns(bool) {\n', '        require(crowdsaleSet());\n', '        return CrowdsaleState(crowdsaleContract).isCrowdsaleSuccessful();\n', '    }\n', '\n', '    function getCrowdsaleHardCap() internal view returns(uint) {\n', '        require(crowdsaleSet());\n', '        return HardCap(crowdsaleContract).getHardCap();\n', '    }\n', '}\n', '\n', '// File: contracts/Token/TotalSupply.sol\n', '\n', 'contract TotalSupply {\n', '    uint public totalSupply = 1000000000 * 10**18;\n', '\n', '    // ERC20 function\n', '    function totalSupply() external constant returns (uint) {\n', '        return totalSupply;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/Burnable.sol\n', '\n', 'contract Burnable is TotalSupply, Balance, Ownable, Crowdsale {\n', '    using MathUtils for uint;\n', '\n', '    event Burn(address account, uint value);\n', '\n', '    function burn(uint amount) public grantBurner hasSufficientBalance(msg.sender, amount) {\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Burn(msg.sender, amount);\n', '    }\n', '\n', '    modifier grantBurner {\n', '        require(isCrowdsale());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/TokenRecipient.sol\n', '\n', 'interface TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', '// File: contracts/Token/CryptoPoliceOfficerToken.sol\n', '\n', '/// ERC20 compliant token contract\n', 'contract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable {\n', '    using MathUtils for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '\n', '    mapping(address => mapping(address => uint)) allowances;\n', '    \n', '    bool public publicTransfersEnabled = false;\n', '    uint public releaseStartTime;\n', '\n', '    uint public lockedAmount;\n', '    TokenLock[] public locks;\n', '\n', '    struct TokenLock {\n', '        uint amount;\n', '        uint timespan;\n', '        bool released;\n', '    }\n', '\n', '    event Transfer(\n', '        address indexed fromAccount,\n', '        address indexed destination,\n', '        uint amount\n', '    );\n', '    \n', '    event Approval(\n', '        address indexed fromAccount,\n', '        address indexed destination,\n', '        uint amount\n', '    );\n', '    \n', '    constructor(\n', '        string tokenName,\n', '        string tokenSymbol\n', '    )\n', '        public\n', '    {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '    \n', '    function _transfer(\n', '        address source,\n', '        address destination,\n', '        uint amount\n', '    )\n', '        internal\n', '        hasSufficientBalance(source, amount)\n', '        whenTransferable(destination)\n', '        hasUnlockedAmount(source, amount)\n', '    {\n', '        require(destination != address(this) && destination != 0x0);\n', '\n', '        if (amount > 0) {\n', '            balances[source] -= amount;\n', '            balances[destination] = balances[destination].add(amount);\n', '        }\n', '\n', '        emit Transfer(source, destination, amount);\n', '    }\n', '\n', '    function transfer(address destination, uint amount)\n', '    public returns (bool)\n', '    {\n', '        _transfer(msg.sender, destination, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address source,\n', '        address destination,\n', '        uint amount\n', '    )\n', '        public returns (bool)\n', '    {\n', '        require(allowances[source][msg.sender] >= amount);\n', '\n', '        allowances[source][msg.sender] -= amount;\n', '\n', '        _transfer(source, destination, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Allow destination address to withdraw funds from account that is caller\n', '     * of this function\n', '     *\n', '     * @param destination The one who receives permission\n', '     * @param amount How much funds can be withdrawn\n', '     * @return Whether or not approval was successful\n', '     */\n', '    function approve(\n', '        address destination,\n', '        uint amount\n', '    )\n', '        public returns (bool)\n', '    {\n', '        allowances[msg.sender][destination] = amount;\n', '        emit Approval(msg.sender, destination, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function allowance(\n', '        address fromAccount,\n', '        address destination\n', '    )\n', '        public constant returns (uint)\n', '    {\n', '        return allowances[fromAccount][destination];\n', '    }\n', '\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _value,\n', '        bytes _extraData\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        TokenRecipient spender = TokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function enablePublicTransfers()\n', '    public grantOwner\n', '    {\n', '        require(crowdsaleSuccessful());\n', '        \n', '        publicTransfersEnabled = true;\n', '        releaseStartTime = now;\n', '    }\n', '\n', '    function addTokenLock(uint amount, uint timespan)\n', '    public grantOwner\n', '    {\n', '        require(releaseStartTime == 0);\n', '        requireOwnerUnlockedAmount(amount);\n', '\n', '        locks.push(TokenLock({\n', '            amount: amount,\n', '            timespan: timespan,\n', '            released: false\n', '        }));\n', '\n', '        lockedAmount += amount;\n', '    }\n', '\n', '    function releaseLockedTokens(uint8 idx)\n', '    public grantOwner\n', '    {\n', '        require(releaseStartTime > 0);\n', '        require(!locks[idx].released);\n', '        require((releaseStartTime + locks[idx].timespan) < now);\n', '\n', '        locks[idx].released = true;\n', '        lockedAmount -= locks[idx].amount;\n', '    }\n', '\n', '    function requireOwnerUnlockedAmount(uint amount)\n', '    internal view\n', '    {\n', '        require(balanceOf(owner).sub(lockedAmount) >= amount);\n', '    }\n', '\n', '    function setCrowdsaleContract(address crowdsale)\n', '    public grantOwner\n', '    {\n', '        super.setCrowdsaleContract(crowdsale);\n', '        transfer(crowdsale, getCrowdsaleHardCap());\n', '    }\n', '\n', '    modifier hasUnlockedAmount(address account, uint amount) {\n', '        if (owner == account) {\n', '            requireOwnerUnlockedAmount(amount);\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier whenTransferable(address destination) {\n', '        require(publicTransfersEnabled\n', '            || isCrowdsale()\n', '            || (isOwner() && addressIsCrowdsale(destination) && balanceOf(crowdsaleContract) == 0)\n', '            || (isOwner() && !crowdsaleSet())\n', '        );\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Utils/Math.sol\n', '\n', 'library MathUtils {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint result = a + b;\n', '\n', '        if (a == 0 || b == 0) {\n', '            return result;\n', '        }\n', '\n', '        require(result > a && result > b);\n', '\n', '        return result;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(a >= b);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint result = a * b;\n', '\n', '        require(result / a == b);\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/Balance.sol\n', '\n', 'contract Balance {\n', '    mapping(address => uint) public balances;\n', '\n', '    // ERC20 function\n', '    function balanceOf(address account) public constant returns (uint) {\n', '        return balances[account];\n', '    }\n', '\n', '    modifier hasSufficientBalance(address account, uint balance) {\n', '        require(balances[account] >= balance);\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Utils/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function isOwner() view public returns (bool) {\n', '        return msg.sender == owner;\n', '    }\n', '\n', '    modifier grantOwner {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/CrowdsaleState.sol\n', '\n', 'interface CrowdsaleState {\n', '    function isCrowdsaleSuccessful() external view returns(bool);\n', '}\n', '\n', '// File: contracts/Token/HardCap.sol\n', '\n', 'interface HardCap {\n', '    function getHardCap() external pure returns(uint);\n', '}\n', '\n', '// File: contracts/Token/Crowdsale.sol\n', '\n', 'contract Crowdsale is Ownable {\n', '    address public crowdsaleContract;\n', '\n', '    function isCrowdsale() internal view returns(bool) {\n', '        return crowdsaleSet() && msg.sender == crowdsaleContract;\n', '    }\n', '\n', '    function crowdsaleSet() internal view returns(bool) {\n', '        return crowdsaleContract != address(0);\n', '    }\n', '\n', '    function addressIsCrowdsale(address _address) public view returns(bool) {\n', '        return crowdsaleSet() && crowdsaleContract == _address;\n', '    }\n', '\n', '    function setCrowdsaleContract(address crowdsale) public grantOwner {\n', '        require(crowdsaleContract == address(0));\n', '        crowdsaleContract = crowdsale;\n', '    }\n', '\n', '    function crowdsaleSuccessful() internal view returns(bool) {\n', '        require(crowdsaleSet());\n', '        return CrowdsaleState(crowdsaleContract).isCrowdsaleSuccessful();\n', '    }\n', '\n', '    function getCrowdsaleHardCap() internal view returns(uint) {\n', '        require(crowdsaleSet());\n', '        return HardCap(crowdsaleContract).getHardCap();\n', '    }\n', '}\n', '\n', '// File: contracts/Token/TotalSupply.sol\n', '\n', 'contract TotalSupply {\n', '    uint public totalSupply = 1000000000 * 10**18;\n', '\n', '    // ERC20 function\n', '    function totalSupply() external constant returns (uint) {\n', '        return totalSupply;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/Burnable.sol\n', '\n', 'contract Burnable is TotalSupply, Balance, Ownable, Crowdsale {\n', '    using MathUtils for uint;\n', '\n', '    event Burn(address account, uint value);\n', '\n', '    function burn(uint amount) public grantBurner hasSufficientBalance(msg.sender, amount) {\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Burn(msg.sender, amount);\n', '    }\n', '\n', '    modifier grantBurner {\n', '        require(isCrowdsale());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Token/TokenRecipient.sol\n', '\n', 'interface TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', '// File: contracts/Token/CryptoPoliceOfficerToken.sol\n', '\n', '/// ERC20 compliant token contract\n', 'contract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable {\n', '    using MathUtils for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '\n', '    mapping(address => mapping(address => uint)) allowances;\n', '    \n', '    bool public publicTransfersEnabled = false;\n', '    uint public releaseStartTime;\n', '\n', '    uint public lockedAmount;\n', '    TokenLock[] public locks;\n', '\n', '    struct TokenLock {\n', '        uint amount;\n', '        uint timespan;\n', '        bool released;\n', '    }\n', '\n', '    event Transfer(\n', '        address indexed fromAccount,\n', '        address indexed destination,\n', '        uint amount\n', '    );\n', '    \n', '    event Approval(\n', '        address indexed fromAccount,\n', '        address indexed destination,\n', '        uint amount\n', '    );\n', '    \n', '    constructor(\n', '        string tokenName,\n', '        string tokenSymbol\n', '    )\n', '        public\n', '    {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '    \n', '    function _transfer(\n', '        address source,\n', '        address destination,\n', '        uint amount\n', '    )\n', '        internal\n', '        hasSufficientBalance(source, amount)\n', '        whenTransferable(destination)\n', '        hasUnlockedAmount(source, amount)\n', '    {\n', '        require(destination != address(this) && destination != 0x0);\n', '\n', '        if (amount > 0) {\n', '            balances[source] -= amount;\n', '            balances[destination] = balances[destination].add(amount);\n', '        }\n', '\n', '        emit Transfer(source, destination, amount);\n', '    }\n', '\n', '    function transfer(address destination, uint amount)\n', '    public returns (bool)\n', '    {\n', '        _transfer(msg.sender, destination, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address source,\n', '        address destination,\n', '        uint amount\n', '    )\n', '        public returns (bool)\n', '    {\n', '        require(allowances[source][msg.sender] >= amount);\n', '\n', '        allowances[source][msg.sender] -= amount;\n', '\n', '        _transfer(source, destination, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Allow destination address to withdraw funds from account that is caller\n', '     * of this function\n', '     *\n', '     * @param destination The one who receives permission\n', '     * @param amount How much funds can be withdrawn\n', '     * @return Whether or not approval was successful\n', '     */\n', '    function approve(\n', '        address destination,\n', '        uint amount\n', '    )\n', '        public returns (bool)\n', '    {\n', '        allowances[msg.sender][destination] = amount;\n', '        emit Approval(msg.sender, destination, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function allowance(\n', '        address fromAccount,\n', '        address destination\n', '    )\n', '        public constant returns (uint)\n', '    {\n', '        return allowances[fromAccount][destination];\n', '    }\n', '\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _value,\n', '        bytes _extraData\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        TokenRecipient spender = TokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function enablePublicTransfers()\n', '    public grantOwner\n', '    {\n', '        require(crowdsaleSuccessful());\n', '        \n', '        publicTransfersEnabled = true;\n', '        releaseStartTime = now;\n', '    }\n', '\n', '    function addTokenLock(uint amount, uint timespan)\n', '    public grantOwner\n', '    {\n', '        require(releaseStartTime == 0);\n', '        requireOwnerUnlockedAmount(amount);\n', '\n', '        locks.push(TokenLock({\n', '            amount: amount,\n', '            timespan: timespan,\n', '            released: false\n', '        }));\n', '\n', '        lockedAmount += amount;\n', '    }\n', '\n', '    function releaseLockedTokens(uint8 idx)\n', '    public grantOwner\n', '    {\n', '        require(releaseStartTime > 0);\n', '        require(!locks[idx].released);\n', '        require((releaseStartTime + locks[idx].timespan) < now);\n', '\n', '        locks[idx].released = true;\n', '        lockedAmount -= locks[idx].amount;\n', '    }\n', '\n', '    function requireOwnerUnlockedAmount(uint amount)\n', '    internal view\n', '    {\n', '        require(balanceOf(owner).sub(lockedAmount) >= amount);\n', '    }\n', '\n', '    function setCrowdsaleContract(address crowdsale)\n', '    public grantOwner\n', '    {\n', '        super.setCrowdsaleContract(crowdsale);\n', '        transfer(crowdsale, getCrowdsaleHardCap());\n', '    }\n', '\n', '    modifier hasUnlockedAmount(address account, uint amount) {\n', '        if (owner == account) {\n', '            requireOwnerUnlockedAmount(amount);\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier whenTransferable(address destination) {\n', '        require(publicTransfersEnabled\n', '            || isCrowdsale()\n', '            || (isOwner() && addressIsCrowdsale(destination) && balanceOf(crowdsaleContract) == 0)\n', '            || (isOwner() && !crowdsaleSet())\n', '        );\n', '        _;\n', '    }\n', '}']
