['pragma solidity ^0.4.20;\n', '    \n', '// Simple contract to split stakes coming into Locus | One Puzzle. \n', '// 80% of buy in goes to the jackpot, and the remaining 20% goes \n', '// to a dev wallet to support future puzzle development. \n', '   \n', 'contract LocusOne {\n', '\n', '    \taddress devAcct;\n', '    \taddress potAcct;\n', '    \tuint fee;\n', '    \tuint pot;\n', '        address public owner;\n', '        \n', '        // PAUSE EVENTS - onlyOwner can pause contract to lock new registration\n', '        // once the bounty has reached its goal.\n', '        \n', '        event Pause();\n', '        event Unpause();\n', '\n', '        bool public paused = false;\n', '        \n', '        \n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '        \n', '    function LocusOne () public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '      modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '    function() public payable {\n', '    require (!paused);    \n', '    _split(msg.value);\n', '    }\n', '\n', '    function _split(uint _stake) internal {\n', '        // protects users from staking less than the required amount to claim the bounty\n', '        require (msg.value >= 0.1 ether);\n', '        // Define the Locus dev account\n', '        devAcct = 0x1daa0BFDEDfB133ec6aEd2F66D64cA88BeC3f0B4;\n', '        // Define the Locus Pot account (what you&#39;re all playing for)      \n', '        potAcct = 0x708294833AEF21a305200b3463A832Ac97852f2e;\n', '\n', '        // 20% of the total Ether sent will be used to pay devs/support project.\n', '        fee = div(_stake, 5);\n', '        \n', '        // The remaining amount of Ether wll be sent to fund/stake the pot.\n', '        pot = sub(_stake, fee);\n', '\n', '        devAcct.transfer(fee);\n', '        potAcct.transfer(pot);\n', '\n', '    }\n', '\n', '\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '            // The below are safemath implementations of the four arithmetic operators\n', '    // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    // not needed until later\n', '    //function sumproduct(uint256 sn, uint256 %cl) internal pure returns (uint256) {\n', '    //    uint256 c = a * b;\n', '    //    assert(c / a == b);\n', '    //    return c;\n', '    //}\n', ' }']
['pragma solidity ^0.4.20;\n', '    \n', '// Simple contract to split stakes coming into Locus | One Puzzle. \n', '// 80% of buy in goes to the jackpot, and the remaining 20% goes \n', '// to a dev wallet to support future puzzle development. \n', '   \n', 'contract LocusOne {\n', '\n', '    \taddress devAcct;\n', '    \taddress potAcct;\n', '    \tuint fee;\n', '    \tuint pot;\n', '        address public owner;\n', '        \n', '        // PAUSE EVENTS - onlyOwner can pause contract to lock new registration\n', '        // once the bounty has reached its goal.\n', '        \n', '        event Pause();\n', '        event Unpause();\n', '\n', '        bool public paused = false;\n', '        \n', '        \n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '        \n', '    function LocusOne () public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '      modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '    function() public payable {\n', '    require (!paused);    \n', '    _split(msg.value);\n', '    }\n', '\n', '    function _split(uint _stake) internal {\n', '        // protects users from staking less than the required amount to claim the bounty\n', '        require (msg.value >= 0.1 ether);\n', '        // Define the Locus dev account\n', '        devAcct = 0x1daa0BFDEDfB133ec6aEd2F66D64cA88BeC3f0B4;\n', "        // Define the Locus Pot account (what you're all playing for)      \n", '        potAcct = 0x708294833AEF21a305200b3463A832Ac97852f2e;\n', '\n', '        // 20% of the total Ether sent will be used to pay devs/support project.\n', '        fee = div(_stake, 5);\n', '        \n', '        // The remaining amount of Ether wll be sent to fund/stake the pot.\n', '        pot = sub(_stake, fee);\n', '\n', '        devAcct.transfer(fee);\n', '        potAcct.transfer(pot);\n', '\n', '    }\n', '\n', '\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '            // The below are safemath implementations of the four arithmetic operators\n', '    // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    // not needed until later\n', '    //function sumproduct(uint256 sn, uint256 %cl) internal pure returns (uint256) {\n', '    //    uint256 c = a * b;\n', '    //    assert(c / a == b);\n', '    //    return c;\n', '    //}\n', ' }']
