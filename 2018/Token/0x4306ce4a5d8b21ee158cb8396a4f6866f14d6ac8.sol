['pragma solidity ^0.4.9;\n', '\n', ' /*\n', ' * Contract that is working with ERC223 tokens\n', ' */\n', ' \n', 'contract ContractReceiver {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '} \n', '\n', ' /**\n', ' * ERC223 token by Dexaran\n', ' *\n', ' * https://github.com/Dexaran/ERC223-tokens\n', ' */\n', ' \n', ' \n', ' /* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', ' \n', 'contract CoinvestToken is SafeMath {\n', '    \n', '    address public maintainer;\n', '    address public icoContract; // icoContract is needed to allow it to transfer tokens during crowdsale.\n', '    uint256 public lockupEndTime; // lockupEndTime is needed to determine when users may start transferring.\n', '    \n', '    bool public ERC223Transfer_enabled = false;\n', '    bool public Transfer_data_enabled = false;\n', '    bool public Transfer_nodata_enabled = true;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '    event ERC223Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed _from, address indexed _spender, uint indexed _amount);\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '  \n', '\n', '    string public constant symbol = "COIN";\n', '    string public constant name = "Coinvest COIN Token";\n', '    \n', '    uint8 public constant decimals = 18;\n', '    uint256 public totalSupply = 107142857 * (10 ** 18);\n', '    \n', '    /**\n', '     * @dev Set owner and beginning balance.\n', '     * @param _lockupEndTime The time at which the token may be traded.\n', '    **/\n', '    function CoinvestToken(uint256 _lockupEndTime)\n', '      public\n', '    {\n', '        balances[msg.sender] = totalSupply;\n', '        lockupEndTime = _lockupEndTime;\n', '        maintainer = msg.sender;\n', '    }\n', '  \n', '  \n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) transferable returns (bool success) {\n', '      \n', '        if(isContract(_to)) {\n', '            if (balanceOf(msg.sender) < _value) throw;\n', '            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '            balances[_to] = safeAdd(balanceOf(_to), _value);\n', '            assert(_to.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data));\n', '            if(Transfer_data_enabled)\n', '            {\n', '                Transfer(msg.sender, _to, _value, _data);\n', '            }\n', '            if(Transfer_nodata_enabled)\n', '            {\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            if(ERC223Transfer_enabled)\n', '            {\n', '                ERC223Transfer(msg.sender, _to, _value, _data);\n', '            }\n', '            return true;\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '\n', '    function ERC20transfer(address _to, uint _value, bytes _data) transferable returns (bool success) {\n', '        bytes memory empty;\n', '        return transferToAddress(_to, _value, empty);\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) transferable returns (bool success) {\n', '        if(isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) transferable returns (bool success) {\n', '      \n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) public returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length>0);\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        if(Transfer_data_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        if(Transfer_nodata_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(ERC223Transfer_enabled)\n', '        {\n', '            ERC223Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        if(Transfer_data_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        if(Transfer_nodata_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(ERC223Transfer_enabled)\n', '        {\n', '            ERC223Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function totalSupply() constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev An allowed address can transfer tokens from another&#39;s address.\n', '     * @param _from The owner of the tokens to be transferred.\n', '     * @param _to The address to which the tokens will be transferred.\n', '     * @param _amount The amount of tokens to be transferred.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '      external\n', '      transferable\n', '    returns (bool success)\n', '    {\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\n', '\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        bytes memory empty;\n', '        \n', '        Transfer(_from, _to, _amount, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves a wallet to transfer tokens on one&#39;s behalf.\n', '     * @param _spender The wallet approved to spend tokens.\n', '     * @param _amount The amount of tokens approved to spend.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) \n', '      external\n', '      transferable // Protect from unlikely maintainer-receiver trickery\n', '    {\n', '        require(balances[msg.sender] >= _amount);\n', '        \n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Allow the owner to take ERC20 tokens off of this contract if they are accidentally sent.\n', '    **/\n', '    function token_escape(address _tokenContract)\n', '      external\n', '      only_maintainer\n', '    {\n', '        CoinvestToken lostToken = CoinvestToken(_tokenContract);\n', '        \n', '        uint256 stuckTokens = lostToken.balanceOf(address(this));\n', '        lostToken.transfer(maintainer, stuckTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Allow maintainer to set the ico contract for transferable permissions.\n', '    **/\n', '    function setIcoContract(address _icoContract)\n', '      external\n', '      only_maintainer\n', '    {\n', '        require(icoContract == 0);\n', '        icoContract = _icoContract;\n', '    }\n', '\n', '    /**\n', '     * @dev Allowed amount for a user to spend of another&#39;s tokens.\n', '     * @param _owner The owner of the tokens approved to spend.\n', '     * @param _spender The address of the user allowed to spend the tokens.\n', '    **/\n', '    function allowance(address _owner, address _spender) \n', '      external\n', '      constant \n', '    returns (uint256) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function adjust_ERC223Transfer(bool _value) only_maintainer\n', '    {\n', '        ERC223Transfer_enabled = _value;\n', '    }\n', '    \n', '    function adjust_Transfer_nodata(bool _value) only_maintainer\n', '    {\n', '        Transfer_nodata_enabled = _value;\n', '    }\n', '    \n', '    function adjust_Transfer_data(bool _value) only_maintainer\n', '    {\n', '        Transfer_data_enabled = _value;\n', '    }\n', '    \n', '    modifier only_maintainer\n', '    {\n', '        assert(msg.sender == maintainer);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Allows the current maintainer to transfer maintenance of the contract to a new maintainer.\n', '     * @param newMaintainer The address to transfer ownership to.\n', '     */\n', '    function transferMaintainer(address newMaintainer) only_maintainer public {\n', '        require(newMaintainer != address(0));\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    modifier transferable\n', '    {\n', '        if (block.timestamp < lockupEndTime) {\n', '            require(msg.sender == maintainer || msg.sender == icoContract);\n', '        }\n', '        _;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.9;\n', '\n', ' /*\n', ' * Contract that is working with ERC223 tokens\n', ' */\n', ' \n', 'contract ContractReceiver {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '} \n', '\n', ' /**\n', ' * ERC223 token by Dexaran\n', ' *\n', ' * https://github.com/Dexaran/ERC223-tokens\n', ' */\n', ' \n', ' \n', ' /* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', ' \n', 'contract CoinvestToken is SafeMath {\n', '    \n', '    address public maintainer;\n', '    address public icoContract; // icoContract is needed to allow it to transfer tokens during crowdsale.\n', '    uint256 public lockupEndTime; // lockupEndTime is needed to determine when users may start transferring.\n', '    \n', '    bool public ERC223Transfer_enabled = false;\n', '    bool public Transfer_data_enabled = false;\n', '    bool public Transfer_nodata_enabled = true;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '    event ERC223Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed _from, address indexed _spender, uint indexed _amount);\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '  \n', '\n', '    string public constant symbol = "COIN";\n', '    string public constant name = "Coinvest COIN Token";\n', '    \n', '    uint8 public constant decimals = 18;\n', '    uint256 public totalSupply = 107142857 * (10 ** 18);\n', '    \n', '    /**\n', '     * @dev Set owner and beginning balance.\n', '     * @param _lockupEndTime The time at which the token may be traded.\n', '    **/\n', '    function CoinvestToken(uint256 _lockupEndTime)\n', '      public\n', '    {\n', '        balances[msg.sender] = totalSupply;\n', '        lockupEndTime = _lockupEndTime;\n', '        maintainer = msg.sender;\n', '    }\n', '  \n', '  \n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) transferable returns (bool success) {\n', '      \n', '        if(isContract(_to)) {\n', '            if (balanceOf(msg.sender) < _value) throw;\n', '            balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '            balances[_to] = safeAdd(balanceOf(_to), _value);\n', '            assert(_to.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data));\n', '            if(Transfer_data_enabled)\n', '            {\n', '                Transfer(msg.sender, _to, _value, _data);\n', '            }\n', '            if(Transfer_nodata_enabled)\n', '            {\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            if(ERC223Transfer_enabled)\n', '            {\n', '                ERC223Transfer(msg.sender, _to, _value, _data);\n', '            }\n', '            return true;\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '\n', '    function ERC20transfer(address _to, uint _value, bytes _data) transferable returns (bool success) {\n', '        bytes memory empty;\n', '        return transferToAddress(_to, _value, empty);\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) transferable returns (bool success) {\n', '        if(isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) transferable returns (bool success) {\n', '      \n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) public returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length>0);\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        if(Transfer_data_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        if(Transfer_nodata_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(ERC223Transfer_enabled)\n', '        {\n', '            ERC223Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        if(Transfer_data_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        if(Transfer_nodata_enabled)\n', '        {\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        if(ERC223Transfer_enabled)\n', '        {\n', '            ERC223Transfer(msg.sender, _to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function totalSupply() constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', "     * @dev An allowed address can transfer tokens from another's address.\n", '     * @param _from The owner of the tokens to be transferred.\n', '     * @param _to The address to which the tokens will be transferred.\n', '     * @param _amount The amount of tokens to be transferred.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '      external\n', '      transferable\n', '    returns (bool success)\n', '    {\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\n', '\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        bytes memory empty;\n', '        \n', '        Transfer(_from, _to, _amount, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev Approves a wallet to transfer tokens on one's behalf.\n", '     * @param _spender The wallet approved to spend tokens.\n', '     * @param _amount The amount of tokens approved to spend.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) \n', '      external\n', '      transferable // Protect from unlikely maintainer-receiver trickery\n', '    {\n', '        require(balances[msg.sender] >= _amount);\n', '        \n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Allow the owner to take ERC20 tokens off of this contract if they are accidentally sent.\n', '    **/\n', '    function token_escape(address _tokenContract)\n', '      external\n', '      only_maintainer\n', '    {\n', '        CoinvestToken lostToken = CoinvestToken(_tokenContract);\n', '        \n', '        uint256 stuckTokens = lostToken.balanceOf(address(this));\n', '        lostToken.transfer(maintainer, stuckTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Allow maintainer to set the ico contract for transferable permissions.\n', '    **/\n', '    function setIcoContract(address _icoContract)\n', '      external\n', '      only_maintainer\n', '    {\n', '        require(icoContract == 0);\n', '        icoContract = _icoContract;\n', '    }\n', '\n', '    /**\n', "     * @dev Allowed amount for a user to spend of another's tokens.\n", '     * @param _owner The owner of the tokens approved to spend.\n', '     * @param _spender The address of the user allowed to spend the tokens.\n', '    **/\n', '    function allowance(address _owner, address _spender) \n', '      external\n', '      constant \n', '    returns (uint256) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function adjust_ERC223Transfer(bool _value) only_maintainer\n', '    {\n', '        ERC223Transfer_enabled = _value;\n', '    }\n', '    \n', '    function adjust_Transfer_nodata(bool _value) only_maintainer\n', '    {\n', '        Transfer_nodata_enabled = _value;\n', '    }\n', '    \n', '    function adjust_Transfer_data(bool _value) only_maintainer\n', '    {\n', '        Transfer_data_enabled = _value;\n', '    }\n', '    \n', '    modifier only_maintainer\n', '    {\n', '        assert(msg.sender == maintainer);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Allows the current maintainer to transfer maintenance of the contract to a new maintainer.\n', '     * @param newMaintainer The address to transfer ownership to.\n', '     */\n', '    function transferMaintainer(address newMaintainer) only_maintainer public {\n', '        require(newMaintainer != address(0));\n', '        maintainer = newMaintainer;\n', '    }\n', '    \n', '    modifier transferable\n', '    {\n', '        if (block.timestamp < lockupEndTime) {\n', '            require(msg.sender == maintainer || msg.sender == icoContract);\n', '        }\n', '        _;\n', '    }\n', '    \n', '}']
