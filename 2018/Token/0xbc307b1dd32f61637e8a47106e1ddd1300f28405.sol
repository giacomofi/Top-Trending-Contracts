['pragma solidity ^0.4.8;\n', '\n', '\n', 'contract SafeMath {\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', 'contract ALBtoken is SafeMath{\n', '    // Token information\n', '    uint256 public vigencia;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\taddress public owner;\n', '\t\n', '\t\n', '      //Token Variables\t\n', '    uint256[] public TokenMineSupply;\n', '    uint256 public _MineId;\n', '    uint256 totalSupplyFloat;\n', '    uint256 oldValue;\n', '    uint256 subValue;\n', '    uint256 oldTotalSupply;\n', '    uint256 TokensToModify;\n', '    bool firstTime;\n', '\t\n', '\t  \n', '     struct Minas {\n', '     uint256 id;\n', '\t string name;\n', '\t uint tokensupply;\n', '\t bool active;\n', '\t  }\n', '\n', '\n', '    //Mapping\n', '\t/* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\tmapping(uint256=>Minas) public participatingMines;\n', '    \n', '\t//Events\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    /* This notifies clients about the amount burn*/\n', '    event Burn(address indexed from, uint256 value);\n', '\t/* This notifies clients about the token add*/\n', '    event AddToken(address indexed from, uint256 value);    \n', '    /*This notifies clients about new mine created or updated*/\n', '    event MineCreated (uint256 MineId, string MineName, uint MineSupply);\n', '    event MineUpdated (uint256 MineId, string MineName, uint MineSupply, bool Estate);\n', '\t\n', '\t\n', '\n', '   /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function ALBtoken(){\n', '        totalSupply = 0;      // Update total supply\n', '        name = "Albarit";     // Set the name for display purposes\n', '        symbol = "ALB";       // Set the symbol for display purposes\n', '        decimals = 3;         // Amount of decimals for display purposes\n', '        balanceOf[msg.sender] = totalSupply;  // Give the creator all initial tokens\n', '\t\towner = msg.sender;  //Set contrac&#39;s owner\n', '\t\tvigencia =2178165600;\n', '\t\tfirstTime = false;\n', '    }\n', '\n', '\t//Administrator \n', '\t modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '        \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient\n', '        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '       }\n', '    \n', '    \n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '\t\tif(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '\t\t\n', '\t\tif(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '\t\t\n', '\t\tif (_value <= 0) throw; \n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '       \n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n', '        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance\n', '        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient\n', '        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\t\n', '\t/* A contract attempts to get the coins */\n', '    function transferFromRoot(address _from, address _to, uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n', '        \n', '        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient\n', '        \n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function addToken(uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '        //totalSupply = SafeMath.safeAdd(totalSupply,_value);                                // Updates totalSupply\n', '        emit AddToken(msg.sender, _value);\n', '        balanceOf[owner]=SafeMath.safeAdd(balanceOf[owner], _value); \n', '        return true;\n', '    }\n', '    \n', '\tfunction burn(uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '        if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '        \n', '        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough\n', '\t\tif (_value <= 0) throw; \n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender\n', '        //totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\t\n', '\t// transfer balance to owner\n', '\tfunction withdrawEther(uint256 amount) onlyOwner{\n', '\t\tif(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '\t\tif(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '\t\t\n', '\t\tif(msg.sender != owner)throw;\n', '\t\towner.transfer(amount);\n', '\t}\n', '\t\n', '\t// can accept ether\n', '\tfunction() payable {\n', '    }\n', '\n', '  function RegisterMine(string _name, uint _tokensupply) onlyOwner\n', '   {\n', '     if (firstTime == false)\n', '     {\n', '         firstTime = true;\n', '     }\n', '     else\n', '     {\n', '      if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '     } \n', '     \n', '      if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '      \n', '       \n', '       /*Register new mine&#39;s data*/\n', '\t   participatingMines[_MineId] = Minas ({\n', '\t       id: _MineId,\n', '\t\t   name: _name,\n', '\t\t   tokensupply: _tokensupply,\n', '\t\t   active: true\n', '\t   });\n', '\t   \n', '\t   /*add to array new item with new mine&#39;s token supply */\n', '\t   TokenMineSupply.push(_tokensupply);\n', '\t   \n', '\t   /*add to array new item with new mine&#39;s token supply */\n', '\t   \n', '\t   /*Uptade Albarit&#39;s total supply*/\n', '\t    /*uint256*/ totalSupplyFloat = 0;\n', '        for (uint8 i = 0; i < TokenMineSupply.length; i++)\n', '        {\n', '            totalSupplyFloat = safeAdd(TokenMineSupply[i], totalSupplyFloat);\n', '        } \n', '        \n', '        totalSupply = totalSupplyFloat;\n', '        addToken(_tokensupply);\n', '        emit MineCreated (_MineId, _name, _tokensupply);\n', '         _MineId = safeAdd(_MineId, 1);\n', '\n', '   }\n', '   \n', '   \n', '   function ModifyMine(uint256 _Id, bool _state, string _name, uint _tokensupply) onlyOwner \n', '   {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '       \n', '       /*uint256*/ oldValue = 0;\n', '       /*uint256*/ subValue = 0;\n', '       /*uint256*/ oldTotalSupply = totalSupply;\n', '       /*uint256*/ TokensToModify = 0;\n', '      /*update mine&#39;s data*/ \n', '\t   participatingMines[_Id].active = _state;\n', '\t   participatingMines[_Id].name = _name;\n', '   \t   participatingMines[_Id].tokensupply = _tokensupply;\n', '   \t   \n', '   \t   oldValue = TokenMineSupply[_Id];\n', '   \t   \n', '   \t    if (_tokensupply > oldValue) {\n', '          TokenMineSupply[_Id] = _tokensupply;\n', '      } else {\n', '          subValue = safeSub(oldValue, _tokensupply);\n', '          TokenMineSupply[_Id]=safeSub(TokenMineSupply[_Id], subValue);\n', '      }\n', '   \t   \n', '   \t   /*Uint256*/ totalSupplyFloat = 0;\n', '   \t   \n', '        for (uint8 i = 0; i < TokenMineSupply.length; i++)\n', '        {\n', '            totalSupplyFloat = safeAdd(TokenMineSupply[i], totalSupplyFloat);\n', '        } \n', '        \n', '        emit MineUpdated(_Id, _name, _tokensupply,  _state);\n', '          totalSupply = totalSupplyFloat;\n', '          \n', '          \n', '        /*_tokensupply > oldValue*/\n', '      if (totalSupply > oldTotalSupply) {\n', '          TokensToModify = safeSub(totalSupply, oldTotalSupply);\n', '          addToken(TokensToModify);\n', '        } \n', '           /*_tokensupply > oldValue*/\n', '      if (totalSupply < oldTotalSupply) {\n', '          TokensToModify = safeSub(oldTotalSupply, totalSupply);\n', '          burn(TokensToModify);\n', '        } \n', '        \n', '   }\n', '   \n', 'function getTokenByMineID() external view returns (uint256[]) {\n', '  return TokenMineSupply;\n', '}\n', '\n', 'function ModifyVigencia(uint256 _vigencia) onlyOwner\n', '{\n', '    if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '    vigencia = _vigencia;\n', '}\n', '\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', 'contract SafeMath {\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', 'contract ALBtoken is SafeMath{\n', '    // Token information\n', '    uint256 public vigencia;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\tuint256 public totalSupply;\n', '\taddress public owner;\n', '\t\n', '\t\n', '      //Token Variables\t\n', '    uint256[] public TokenMineSupply;\n', '    uint256 public _MineId;\n', '    uint256 totalSupplyFloat;\n', '    uint256 oldValue;\n', '    uint256 subValue;\n', '    uint256 oldTotalSupply;\n', '    uint256 TokensToModify;\n', '    bool firstTime;\n', '\t\n', '\t  \n', '     struct Minas {\n', '     uint256 id;\n', '\t string name;\n', '\t uint tokensupply;\n', '\t bool active;\n', '\t  }\n', '\n', '\n', '    //Mapping\n', '\t/* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\tmapping(uint256=>Minas) public participatingMines;\n', '    \n', '\t//Events\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    /* This notifies clients about the amount burn*/\n', '    event Burn(address indexed from, uint256 value);\n', '\t/* This notifies clients about the token add*/\n', '    event AddToken(address indexed from, uint256 value);    \n', '    /*This notifies clients about new mine created or updated*/\n', '    event MineCreated (uint256 MineId, string MineName, uint MineSupply);\n', '    event MineUpdated (uint256 MineId, string MineName, uint MineSupply, bool Estate);\n', '\t\n', '\t\n', '\n', '   /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function ALBtoken(){\n', '        totalSupply = 0;      // Update total supply\n', '        name = "Albarit";     // Set the name for display purposes\n', '        symbol = "ALB";       // Set the symbol for display purposes\n', '        decimals = 3;         // Amount of decimals for display purposes\n', '        balanceOf[msg.sender] = totalSupply;  // Give the creator all initial tokens\n', "\t\towner = msg.sender;  //Set contrac's owner\n", '\t\tvigencia =2178165600;\n', '\t\tfirstTime = false;\n', '    }\n', '\n', '\t//Administrator \n', '\t modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '        \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient\n', '        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '       }\n', '    \n', '    \n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '\t\tif(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '\t\t\n', '\t\tif(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '\t\t\n', '\t\tif (_value <= 0) throw; \n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '       \n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n', '        if (_value > allowance[_from][msg.sender]) throw;     // Check allowance\n', '        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient\n', '        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\t\n', '\t/* A contract attempts to get the coins */\n', '    function transferFromRoot(address _from, address _to, uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '        if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\tif (_value <= 0) throw; \n', '        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n', '        \n', '        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient\n', '        \n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function addToken(uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '        //totalSupply = SafeMath.safeAdd(totalSupply,_value);                                // Updates totalSupply\n', '        emit AddToken(msg.sender, _value);\n', '        balanceOf[owner]=SafeMath.safeAdd(balanceOf[owner], _value); \n', '        return true;\n', '    }\n', '    \n', '\tfunction burn(uint256 _value) onlyOwner returns (bool success) {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '        if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '        \n', '        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough\n', '\t\tif (_value <= 0) throw; \n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender\n', '        //totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\t\n', '\t// transfer balance to owner\n', '\tfunction withdrawEther(uint256 amount) onlyOwner{\n', '\t\tif(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '\t\tif(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '\t\t\n', '\t\tif(msg.sender != owner)throw;\n', '\t\towner.transfer(amount);\n', '\t}\n', '\t\n', '\t// can accept ether\n', '\tfunction() payable {\n', '    }\n', '\n', '  function RegisterMine(string _name, uint _tokensupply) onlyOwner\n', '   {\n', '     if (firstTime == false)\n', '     {\n', '         firstTime = true;\n', '     }\n', '     else\n', '     {\n', '      if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '     } \n', '     \n', '      if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '      \n', '       \n', "       /*Register new mine's data*/\n", '\t   participatingMines[_MineId] = Minas ({\n', '\t       id: _MineId,\n', '\t\t   name: _name,\n', '\t\t   tokensupply: _tokensupply,\n', '\t\t   active: true\n', '\t   });\n', '\t   \n', "\t   /*add to array new item with new mine's token supply */\n", '\t   TokenMineSupply.push(_tokensupply);\n', '\t   \n', "\t   /*add to array new item with new mine's token supply */\n", '\t   \n', "\t   /*Uptade Albarit's total supply*/\n", '\t    /*uint256*/ totalSupplyFloat = 0;\n', '        for (uint8 i = 0; i < TokenMineSupply.length; i++)\n', '        {\n', '            totalSupplyFloat = safeAdd(TokenMineSupply[i], totalSupplyFloat);\n', '        } \n', '        \n', '        totalSupply = totalSupplyFloat;\n', '        addToken(_tokensupply);\n', '        emit MineCreated (_MineId, _name, _tokensupply);\n', '         _MineId = safeAdd(_MineId, 1);\n', '\n', '   }\n', '   \n', '   \n', '   function ModifyMine(uint256 _Id, bool _state, string _name, uint _tokensupply) onlyOwner \n', '   {\n', '       if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '       \n', '       if(block.timestamp >= vigencia)\n', '       {\n', '           throw;\n', '       }\n', '       \n', '       \n', '       /*uint256*/ oldValue = 0;\n', '       /*uint256*/ subValue = 0;\n', '       /*uint256*/ oldTotalSupply = totalSupply;\n', '       /*uint256*/ TokensToModify = 0;\n', "      /*update mine's data*/ \n", '\t   participatingMines[_Id].active = _state;\n', '\t   participatingMines[_Id].name = _name;\n', '   \t   participatingMines[_Id].tokensupply = _tokensupply;\n', '   \t   \n', '   \t   oldValue = TokenMineSupply[_Id];\n', '   \t   \n', '   \t    if (_tokensupply > oldValue) {\n', '          TokenMineSupply[_Id] = _tokensupply;\n', '      } else {\n', '          subValue = safeSub(oldValue, _tokensupply);\n', '          TokenMineSupply[_Id]=safeSub(TokenMineSupply[_Id], subValue);\n', '      }\n', '   \t   \n', '   \t   /*Uint256*/ totalSupplyFloat = 0;\n', '   \t   \n', '        for (uint8 i = 0; i < TokenMineSupply.length; i++)\n', '        {\n', '            totalSupplyFloat = safeAdd(TokenMineSupply[i], totalSupplyFloat);\n', '        } \n', '        \n', '        emit MineUpdated(_Id, _name, _tokensupply,  _state);\n', '          totalSupply = totalSupplyFloat;\n', '          \n', '          \n', '        /*_tokensupply > oldValue*/\n', '      if (totalSupply > oldTotalSupply) {\n', '          TokensToModify = safeSub(totalSupply, oldTotalSupply);\n', '          addToken(TokensToModify);\n', '        } \n', '           /*_tokensupply > oldValue*/\n', '      if (totalSupply < oldTotalSupply) {\n', '          TokensToModify = safeSub(oldTotalSupply, totalSupply);\n', '          burn(TokensToModify);\n', '        } \n', '        \n', '   }\n', '   \n', 'function getTokenByMineID() external view returns (uint256[]) {\n', '  return TokenMineSupply;\n', '}\n', '\n', 'function ModifyVigencia(uint256 _vigencia) onlyOwner\n', '{\n', '    if(totalSupply == 0)\n', '        {\n', '            selfdestruct(owner);\n', '        }\n', '    vigencia = _vigencia;\n', '}\n', '\n', '}']
