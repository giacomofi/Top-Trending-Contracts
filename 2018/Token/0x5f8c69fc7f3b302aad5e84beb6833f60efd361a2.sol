['pragma solidity ^0.4.19;\n', '\n', '// LeeSungCoin Made By PinkCherry - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82ebecf1e3ecebf6fbf1e9e3ecc2e5efe3ebeeace1edef">[email&#160;protected]</a>\n', '// LeeSungCoin Request Question - <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e2898d908783818d8b8c918d8e97968b8d8ca2858f838b8ecc818d8f">[email&#160;protected]</a>\n', '\n', 'library SafeMath\n', '{\n', '  \tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\n', '\t\treturn c;\n', '  \t}\n', '\n', '  \tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a / b;\n', '\n', '\t\treturn c;\n', '  \t}\n', '\n', '  \tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tassert(b <= a);\n', '\n', '\t\treturn a - b;\n', '  \t}\n', '\n', '  \tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\n', '\t\treturn c;\n', '  \t}\n', '}\n', '\n', '\n', 'contract OwnerHelper\n', '{\n', '  \taddress public owner;\n', '\n', '  \tevent OwnerTransferPropose(address indexed _from, address indexed _to);\n', '\n', '  \tmodifier onlyOwner\n', '\t{\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '  \t}\n', '\n', '  \tfunction OwnerHelper() public\n', '\t{\n', '\t\towner = msg.sender;\n', '  \t}\n', '\n', '  \tfunction transferOwnership(address _to) onlyOwner public\n', '\t{\n', '            require(_to != owner);\n', '    \t\trequire(_to != address(0x0));\n', '    \t\towner = _to;\n', '    \t\tOwnerTransferPropose(owner, _to);\n', '  \t}\n', '\n', '}\n', '\n', '\n', 'contract ERC20Interface\n', '{\n', '  \tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '  \tevent Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\tevent Burned(address indexed _burner, uint _value);\n', '\n', '  \tfunction totalSupply() public constant returns (uint);\n', '  \tfunction balanceOf(address _owner) public constant returns (uint balance);\n', '  \tfunction transfer(address _to, uint _value) public returns (bool success);\n', '  \tfunction transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  \tfunction approve(address _spender, uint _value) public returns (bool success);\n', '  \tfunction allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\tfunction burn(uint _burnAmount) public returns (bool success);\n', '}\n', '\n', '\n', 'contract ERC20Token is ERC20Interface, OwnerHelper\n', '{\n', '  \tusing SafeMath for uint;\n', '\n', '  \tuint public tokensIssuedTotal = 0;\n', '  \taddress public constant burnAddress = 0;\n', '\n', '  \tmapping(address => uint) balances;\n', '  \tmapping(address => mapping (address => uint)) allowed;\n', '\n', '  \tfunction totalSupply() public constant returns (uint)\n', '\t{\n', '\t\treturn tokensIssuedTotal;\n', '  \t}\n', '\n', '  \tfunction balanceOf(address _owner) public constant returns (uint balance)\n', '\t{\n', '\t\treturn balances[_owner];\n', '  \t}\n', '\n', '\tfunction transfer(address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( balances[msg.sender] >= _amount );\n', '\n', '\t    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '\t\tbalances[_to]        = balances[_to].add(_amount);\n', '\n', '\t\tTransfer(msg.sender, _to, _amount);\n', '    \n', '\t\treturn true;\n', '  \t}\n', '\n', '  \tfunction approve(address _spender, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire ( balances[msg.sender] >= _amount );\n', '\n', '\t\tallowed[msg.sender][_spender] = _amount;\n', '    \t\t\n', '\t\tApproval(msg.sender, _spender, _amount);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '  \tfunction transferFrom(address _from, address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( balances[_from] >= _amount );\n', '\t\trequire( allowed[_from][msg.sender] >= _amount );\n', '\t\tbalances[_from]            = balances[_from].sub(_amount);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '\t\tbalances[_to]              = balances[_to].add(_amount);\n', '\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '  \t}\n', '\n', '  \tfunction allowance(address _owner, address _spender) public constant returns (uint remaining)\n', '\t{\n', '\t\treturn allowed[_owner][_spender];\n', '  \t}\n', '\n', '\tfunction burn(uint _burnAmount) public returns (bool success)\n', '\t{\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_burnAmount);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.sub(_burnAmount);\n', '\t\tBurned(burner, _burnAmount);\n', '\t\tTransfer(burner, burnAddress, _burnAmount);\n', '\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', 'contract LeeSungCoin is ERC20Token\n', '{\n', '\tuint constant E18 = 10**18;\n', '\n', '  \tstring public constant name \t= "LeeSungCoin";\n', '  \tstring public constant symbol \t= "LSC";\n', '  \tuint public constant decimals \t= 18;\n', '\n', '\taddress public wallet;\n', '\taddress public adminWallet;\n', '\taddress public IcoContract;\n', '\n', '\tuint public constant totalCoinCap   = 2000000000 * E18;\n', '\tuint public constant icoCoinCap     = 1400000000 * E18;\n', '\tuint public constant mktCoinCap     =  600000000 * E18;\n', '\tuint public constant preSaleCoinCap =  480000000 * E18;\n', '\n', '\tuint public coinPerEth = 20000 * E18;\n', '\n', '\tuint public constant privateSaleBonus\t = 30;\n', '\tuint public constant preSaleFirstBonus\t = 20;\n', '\tuint public constant preSaleSecondBonus  = 15;\n', '\tuint public constant mainSaleFirstBonus\t = 5;\n', '\tuint public constant mainSaleSecondBonus = 0;\n', '\n', '  \tuint public constant preSaleFirstStartDate = 1517788800; // 2018-02-05 00:00 UTC\n', '  \tuint public constant preSaleFirstEndDate   = 1518307200; // 2018-02-11 00:00 UTC\n', '\n', '  \tuint public constant preSaleSecondStartDate = 1518393600; // 2018-02-12 00:00 UTC\n', '  \tuint public constant preSaleSecondEndDate   = 1518912000; // 2018-02-18 00:00 UTC\n', '\n', '\n', '  \tuint public constant mainSaleFirstStartDate = 1519603200; // 2018-02-26 00:00 UTC\n', '  \tuint public constant mainSaleFirstEndDate   = 1520121600; // 2018-03-04 00:00 UTC\n', '\n', '  \tuint public constant mainSaleSecondStartDate = 1520208000; // 2018-03-05 00:00 UTC\n', '  \tuint public constant mainSaleSecondEndDate   = 1520726400; // 2018-03-11 00:00 UTC\n', '\n', '\tuint public constant transferCooldown = 2 days;\n', '\n', '\tuint public constant preSaleMinEth  = 1 ether;\n', '\tuint public constant mainSaleMinEth =  1 ether / 2; // 0.5 Ether\n', '\n', '  \tuint public priEtherReceived = 0; // Ether actually received by the contract\n', '  \tuint public icoEtherReceived = 0; // Ether actually received by the contract\n', '\n', '    uint public coinIssuedTotal     = 0;\n', '  \tuint public coinIssuedIco       = 0;\n', '  \tuint public coinIssuedMkt       = 0;\n', '\t\n', '\tuint public coinBurnIco = 0;\n', '\tuint public coinBurnMkt = 0;\n', '\n', '  \tmapping(address => uint) public icoEtherContributed;\n', '  \tmapping(address => uint) public icoCoinReceived;\n', '  \tmapping(address => bool) public refundClaimed;\n', '  \tmapping(address => bool) public coinLocked;\n', '  \t\n', ' \tevent WalletChange(address _newWallet);\n', '  \tevent AdminWalletChange(address _newAdminWallet);\n', '  \tevent CoinMinted(address indexed _owner, uint _tokens, uint _balance);\n', '  \tevent CoinIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed);\n', '  \tevent Refund(address indexed _owner, uint _amount, uint _tokens);\n', '  \tevent LockRemove(address indexed _participant);\n', '\tevent WithDraw(address indexed _to, uint _amount);\n', '\tevent OwnerReclaim(address indexed _from, address indexed _owner, uint _amount);\n', '\n', '  \tfunction LeeSungCoin() public\n', '\t{\n', '\t\trequire( icoCoinCap + mktCoinCap == totalCoinCap );\n', '\t\twallet = owner;\n', '\t\tadminWallet = owner;\n', '\t\t\n', '\t\tIcoContract = 0x6E5B3dBFB6a85D11e5d0d4A5618C53838Da63900;\n', '\t\tpriEtherReceived = 517 ether;\n', '\t\ticoEtherReceived = 112260255293000000000;\n', '  \t}\n', '\n', '  \tfunction () payable public\n', '\t{\n', '    \tbuyCoin();\n', '  \t}\n', '  \t\n', '  \tfunction atNow() public constant returns (uint)\n', '\t{\n', '\t\treturn now;\n', '  \t}\n', '\n', '  \tfunction buyCoin() private\n', '\t{\n', '\t\tuint nowTime = atNow();\n', '\n', '\t\tuint saleTime = 0; // 1 : preSaleFirst, 2 : preSaleSecond, 3 : mainSaleFirst, 4 : mainSaleSecond\n', '\n', '\t\tuint minEth = 0;\n', '\t\tuint maxEth = 300 ether;\n', '\n', '\t\tuint coins = 0;\n', '\t\tuint coinBonus = 0;\n', '\t\tuint coinCap = 0;\n', '\n', '\t\tif (nowTime > preSaleFirstStartDate && nowTime < preSaleFirstEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 1;\n', '\t\t\tminEth = preSaleMinEth;\n', '\t\t\tcoinBonus = preSaleFirstBonus;\n', '\t\t\tcoinCap = preSaleCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > preSaleSecondStartDate && nowTime < preSaleSecondEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 2;\n', '\t\t\tminEth = preSaleMinEth;\n', '\t\t\tcoinBonus = preSaleSecondBonus;\n', '\t\t\tcoinCap = preSaleCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > mainSaleFirstStartDate && nowTime < mainSaleFirstEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 3;\n', '\t\t\tminEth = mainSaleMinEth;\n', '\t\t\tcoinBonus = mainSaleFirstBonus;\n', '\t\t\tcoinCap = icoCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > mainSaleSecondStartDate && nowTime < mainSaleSecondEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 4;\n', '\t\t\tminEth = mainSaleMinEth;\n', '\t\t\tcoinBonus = mainSaleSecondBonus;\n', '\t\t\tcoinCap = icoCoinCap;\n', '\t\t}\n', '\t\t\n', '\t\trequire( saleTime >= 1 && saleTime <= 4 );\n', '\t\trequire( msg.value >= minEth );\n', '\t\trequire( icoEtherContributed[msg.sender].add(msg.value) <= maxEth );\n', '\n', '\t\tcoins = coinPerEth.mul(msg.value) / 1 ether;\n', '      \tcoins = coins.mul(100 + coinBonus) / 100;\n', '\n', '\t\trequire( coinIssuedIco.add(coins) <= coinCap );\n', '\n', '\t\tbalances[msg.sender]        = balances[msg.sender].add(coins);\n', '\t    icoCoinReceived[msg.sender] = icoCoinReceived[msg.sender].add(coins);\n', '\t\tcoinIssuedIco               = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal           = tokensIssuedTotal.add(coins);\n', '    \n', '\t\ticoEtherReceived                = icoEtherReceived.add(msg.value);\n', '\t\ticoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value);\n', '    \n', '\t\tcoinLocked[msg.sender] = true;\n', '    \n', '\t\tTransfer(0x0, msg.sender, coins);\n', '\t\tCoinIssued(msg.sender, coins, balances[msg.sender], msg.value);\n', '\n', '\t\twallet.transfer(this.balance);\n', '  \t}\n', '\n', ' \tfunction isTransferable() public constant returns (bool transferable)\n', '\t{\n', '\t\tif ( atNow() < mainSaleSecondEndDate + transferCooldown )\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\treturn true;\n', '  \t}\n', '\n', '\tfunction coinLockRemove(address _participant) public\n', '\t{\n', '\t\trequire( msg.sender == adminWallet || msg.sender == owner );\n', '\t\tcoinLocked[_participant] = false;\n', '\t\tLockRemove(_participant);\n', '  \t}\n', '\n', '\tfunction coinLockRmoveMultiple(address[] _participants) public\n', '\t{\n', '\t\trequire( msg.sender == adminWallet || msg.sender == owner );\n', '    \t\t\n', '\t\tfor (uint i = 0; i < _participants.length; i++)\n', '\t\t{\n', '  \t\t\tcoinLocked[_participants[i]] = false;\n', '  \t\t\tLockRemove(_participants[i]);\n', '\t\t}\n', '  \t}\n', '\n', '  \tfunction changeWallet(address _wallet) onlyOwner public\n', '\t{\n', '    \t\trequire( _wallet != address(0x0) );\n', '    \t\twallet = _wallet;\n', '    \t\tWalletChange(wallet);\n', '  \t}\n', '\n', '  \tfunction changeAdminWallet(address _wallet) onlyOwner public\n', '\t{\n', '    \t\trequire( _wallet != address(0x0) );\n', '    \t\tadminWallet = _wallet;\n', '    \t\tAdminWalletChange(adminWallet);\n', '  \t}\n', '\n', '  \tfunction mintMarketing(address _participant, uint _amount) onlyOwner public\n', '\t{\n', '\t\tuint coins = _amount * E18;\n', '\t\t\n', '\t\trequire( coins <= mktCoinCap.sub(coinIssuedMkt) );\n', '\t\t\n', '\t\tbalances[_participant] = balances[_participant].add(coins);\n', '\t\t\n', '\t\tcoinIssuedMkt   = coinIssuedMkt.add(coins);\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tcoinLocked[_participant] = true;\n', '\t\t\n', '\t\tTransfer(0x0, _participant, coins);\n', '\t\tCoinMinted(_participant, coins, balances[_participant]);\n', '  \t}\n', '  \t\n', '  \tfunction mintIcoTokenMultiple(address[] _addresses, uint[] _amounts) onlyOwner public\n', '  \t{\n', '\t\tuint coins = 0;\n', '\t\t\n', '\t\tfor (uint i = 0; i < _addresses.length; i++)\n', '\t\t{\n', '\t\t    coins = _amounts[i] * E18;\n', '\t\t    \n', '\t\t    balances[_addresses[i]] = balances[_addresses[i]].add(coins);\n', '    \n', '\t\t    coinIssuedIco       = coinIssuedIco.add(coins);\n', '\t\t    coinIssuedTotal     = coinIssuedTotal.add(coins);\n', '\t\t    tokensIssuedTotal   = tokensIssuedTotal.add(coins);\n', '    \n', '\t\t    coinLocked[_addresses[i]] = true;\n', '\t\t    Transfer(0x0, _addresses[i], coins);\n', '\t        CoinMinted(_addresses[i], coins, balances[_addresses[i]]);\n', '\t\t}\n', '  \t}\n', '  \t\n', '  \tfunction ownerWithdraw() external onlyOwner\n', '\t{\n', '\t\tuint amount = this.balance;\n', '\t\twallet.transfer(amount);\n', '\t\tWithDraw(msg.sender, amount);\n', '  \t}\n', '  \t\n', '  \tfunction transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner public returns (bool success)\n', '\t{\n', '  \t\treturn ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  \t}\n', '  \t\n', '  \tfunction transfer(address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[msg.sender] == false );\n', '\t\trequire( coinLocked[_to] == false );\n', '\t\treturn super.transfer(_to, _amount);\n', '  \t}\n', '  \t\n', '  \tfunction transferFrom(address _from, address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[_from] == false );\n', '\t\trequire( coinLocked[_to] == false );\n', '\t\treturn super.transferFrom(_from, _to, _amount);\n', '  \t}\n', '\n', '  \tfunction transferMultiple(address[] _addresses, uint[] _amounts) external\n', '  \t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[msg.sender] == false );\n', '\t\trequire( _addresses.length == _amounts.length );\n', '\t\t\n', '\t\tfor (uint i = 0; i < _addresses.length; i++)\n', '\t\t{\n', '  \t\t\tif (coinLocked[_addresses[i]] == false) \n', '\t\t\t{\n', '\t\t\t\tsuper.transfer(_addresses[i], _amounts[i]);\n', '\t\t\t}\n', '\t\t}\n', '  \t}\n', '\n', '  \tfunction reclaimFunds() external\n', '\t{\n', '\t\tuint coins;\n', '\t\tuint amount;\n', '\n', '\t\trequire( atNow() > mainSaleSecondEndDate );\n', '\t\trequire( !refundClaimed[msg.sender] );\n', '\t\trequire( icoEtherContributed[msg.sender] > 0 );\n', '\n', '\t\tcoins = icoCoinReceived[msg.sender];\n', '\t\tamount = icoEtherContributed[msg.sender];\n', '\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(coins);\n', '\t\ttokensIssuedTotal    = tokensIssuedTotal.sub(coins);\n', '\n', '\t\trefundClaimed[msg.sender] = true;\n', '\n', '\t\tmsg.sender.transfer(amount);\n', '\n', '\t\tTransfer(msg.sender, 0x0, coins);\n', '\t\tRefund(msg.sender, amount, coins);\n', '  \t}\n', '  \t\n', '    function transferToOwner(address _from) onlyOwner public\n', '    {\n', '\t\trequire( coinLocked[_from] == false );\n', '        uint amount = balanceOf(_from);\n', '        \n', '        balances[_from] = balances[_from].sub(amount);\n', '        balances[owner] = balances[owner].add(amount);\n', '        \n', '        Transfer(_from, owner, amount);\n', '        OwnerReclaim(_from, owner, amount);\n', '    }\n', '\n', '\tfunction burnIcoCoins() onlyOwner public returns (bool success)\n', '\t{\n', '\t    uint coins = 1400000000 * E18;\n', '\t    coins = coins.sub(coinIssuedIco);\n', '\t    \n', '\t    address burner = msg.sender;\n', '\t    \n', '\t\tbalances[burner] = balances[burner].add(coins);\n', '\t\t\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\tcoinIssuedIco   = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tTransfer(0x0, burner, coins);\n', '\t\t\n', '        coinIssuedTotal = coinIssuedTotal.sub(coins);\n', '        coinIssuedIco = coinIssuedIco.sub(coins);\n', '        coinBurnIco = coinBurnIco.add(coins);\n', '\t\t\n', '\t\treturn super.burn(coins);\n', '\t}\n', '\n', '\tfunction burnMktCoins() onlyOwner public returns (bool success)\n', '\t{\n', '\t    uint coins = 600000000 * E18;\n', '\t    coins = coins.sub(coinIssuedMkt);\n', '\t    \n', '\t    address burner = msg.sender;\n', '\t    \n', '\t\tbalances[burner] = balances[burner].add(coins);\n', '\t\t\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\tcoinIssuedIco   = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tTransfer(0x0, burner, coins);\n', '\t\t\n', '        coinIssuedTotal = coinIssuedTotal.sub(coins);\n', '        coinIssuedMkt = coinIssuedMkt.sub(coins);\n', '        coinBurnMkt = coinBurnMkt.add(coins);\n', '\t\t\n', '\t\treturn super.burn(coins);\n', '\t}\n', '\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// LeeSungCoin Made By PinkCherry - insanityskan@gmail.com\n', '// LeeSungCoin Request Question - koreacoinsolution@gmail.com\n', '\n', 'library SafeMath\n', '{\n', '  \tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '    {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\n', '\t\treturn c;\n', '  \t}\n', '\n', '  \tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a / b;\n', '\n', '\t\treturn c;\n', '  \t}\n', '\n', '  \tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tassert(b <= a);\n', '\n', '\t\treturn a - b;\n', '  \t}\n', '\n', '  \tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\n', '\t\treturn c;\n', '  \t}\n', '}\n', '\n', '\n', 'contract OwnerHelper\n', '{\n', '  \taddress public owner;\n', '\n', '  \tevent OwnerTransferPropose(address indexed _from, address indexed _to);\n', '\n', '  \tmodifier onlyOwner\n', '\t{\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '  \t}\n', '\n', '  \tfunction OwnerHelper() public\n', '\t{\n', '\t\towner = msg.sender;\n', '  \t}\n', '\n', '  \tfunction transferOwnership(address _to) onlyOwner public\n', '\t{\n', '            require(_to != owner);\n', '    \t\trequire(_to != address(0x0));\n', '    \t\towner = _to;\n', '    \t\tOwnerTransferPropose(owner, _to);\n', '  \t}\n', '\n', '}\n', '\n', '\n', 'contract ERC20Interface\n', '{\n', '  \tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '  \tevent Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\tevent Burned(address indexed _burner, uint _value);\n', '\n', '  \tfunction totalSupply() public constant returns (uint);\n', '  \tfunction balanceOf(address _owner) public constant returns (uint balance);\n', '  \tfunction transfer(address _to, uint _value) public returns (bool success);\n', '  \tfunction transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  \tfunction approve(address _spender, uint _value) public returns (bool success);\n', '  \tfunction allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\tfunction burn(uint _burnAmount) public returns (bool success);\n', '}\n', '\n', '\n', 'contract ERC20Token is ERC20Interface, OwnerHelper\n', '{\n', '  \tusing SafeMath for uint;\n', '\n', '  \tuint public tokensIssuedTotal = 0;\n', '  \taddress public constant burnAddress = 0;\n', '\n', '  \tmapping(address => uint) balances;\n', '  \tmapping(address => mapping (address => uint)) allowed;\n', '\n', '  \tfunction totalSupply() public constant returns (uint)\n', '\t{\n', '\t\treturn tokensIssuedTotal;\n', '  \t}\n', '\n', '  \tfunction balanceOf(address _owner) public constant returns (uint balance)\n', '\t{\n', '\t\treturn balances[_owner];\n', '  \t}\n', '\n', '\tfunction transfer(address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( balances[msg.sender] >= _amount );\n', '\n', '\t    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '\t\tbalances[_to]        = balances[_to].add(_amount);\n', '\n', '\t\tTransfer(msg.sender, _to, _amount);\n', '    \n', '\t\treturn true;\n', '  \t}\n', '\n', '  \tfunction approve(address _spender, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire ( balances[msg.sender] >= _amount );\n', '\n', '\t\tallowed[msg.sender][_spender] = _amount;\n', '    \t\t\n', '\t\tApproval(msg.sender, _spender, _amount);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '  \tfunction transferFrom(address _from, address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( balances[_from] >= _amount );\n', '\t\trequire( allowed[_from][msg.sender] >= _amount );\n', '\t\tbalances[_from]            = balances[_from].sub(_amount);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '\t\tbalances[_to]              = balances[_to].add(_amount);\n', '\n', '\t\tTransfer(_from, _to, _amount);\n', '\t\treturn true;\n', '  \t}\n', '\n', '  \tfunction allowance(address _owner, address _spender) public constant returns (uint remaining)\n', '\t{\n', '\t\treturn allowed[_owner][_spender];\n', '  \t}\n', '\n', '\tfunction burn(uint _burnAmount) public returns (bool success)\n', '\t{\n', '\t\taddress burner = msg.sender;\n', '\t\tbalances[burner] = balances[burner].sub(_burnAmount);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.sub(_burnAmount);\n', '\t\tBurned(burner, _burnAmount);\n', '\t\tTransfer(burner, burnAddress, _burnAmount);\n', '\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', 'contract LeeSungCoin is ERC20Token\n', '{\n', '\tuint constant E18 = 10**18;\n', '\n', '  \tstring public constant name \t= "LeeSungCoin";\n', '  \tstring public constant symbol \t= "LSC";\n', '  \tuint public constant decimals \t= 18;\n', '\n', '\taddress public wallet;\n', '\taddress public adminWallet;\n', '\taddress public IcoContract;\n', '\n', '\tuint public constant totalCoinCap   = 2000000000 * E18;\n', '\tuint public constant icoCoinCap     = 1400000000 * E18;\n', '\tuint public constant mktCoinCap     =  600000000 * E18;\n', '\tuint public constant preSaleCoinCap =  480000000 * E18;\n', '\n', '\tuint public coinPerEth = 20000 * E18;\n', '\n', '\tuint public constant privateSaleBonus\t = 30;\n', '\tuint public constant preSaleFirstBonus\t = 20;\n', '\tuint public constant preSaleSecondBonus  = 15;\n', '\tuint public constant mainSaleFirstBonus\t = 5;\n', '\tuint public constant mainSaleSecondBonus = 0;\n', '\n', '  \tuint public constant preSaleFirstStartDate = 1517788800; // 2018-02-05 00:00 UTC\n', '  \tuint public constant preSaleFirstEndDate   = 1518307200; // 2018-02-11 00:00 UTC\n', '\n', '  \tuint public constant preSaleSecondStartDate = 1518393600; // 2018-02-12 00:00 UTC\n', '  \tuint public constant preSaleSecondEndDate   = 1518912000; // 2018-02-18 00:00 UTC\n', '\n', '\n', '  \tuint public constant mainSaleFirstStartDate = 1519603200; // 2018-02-26 00:00 UTC\n', '  \tuint public constant mainSaleFirstEndDate   = 1520121600; // 2018-03-04 00:00 UTC\n', '\n', '  \tuint public constant mainSaleSecondStartDate = 1520208000; // 2018-03-05 00:00 UTC\n', '  \tuint public constant mainSaleSecondEndDate   = 1520726400; // 2018-03-11 00:00 UTC\n', '\n', '\tuint public constant transferCooldown = 2 days;\n', '\n', '\tuint public constant preSaleMinEth  = 1 ether;\n', '\tuint public constant mainSaleMinEth =  1 ether / 2; // 0.5 Ether\n', '\n', '  \tuint public priEtherReceived = 0; // Ether actually received by the contract\n', '  \tuint public icoEtherReceived = 0; // Ether actually received by the contract\n', '\n', '    uint public coinIssuedTotal     = 0;\n', '  \tuint public coinIssuedIco       = 0;\n', '  \tuint public coinIssuedMkt       = 0;\n', '\t\n', '\tuint public coinBurnIco = 0;\n', '\tuint public coinBurnMkt = 0;\n', '\n', '  \tmapping(address => uint) public icoEtherContributed;\n', '  \tmapping(address => uint) public icoCoinReceived;\n', '  \tmapping(address => bool) public refundClaimed;\n', '  \tmapping(address => bool) public coinLocked;\n', '  \t\n', ' \tevent WalletChange(address _newWallet);\n', '  \tevent AdminWalletChange(address _newAdminWallet);\n', '  \tevent CoinMinted(address indexed _owner, uint _tokens, uint _balance);\n', '  \tevent CoinIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed);\n', '  \tevent Refund(address indexed _owner, uint _amount, uint _tokens);\n', '  \tevent LockRemove(address indexed _participant);\n', '\tevent WithDraw(address indexed _to, uint _amount);\n', '\tevent OwnerReclaim(address indexed _from, address indexed _owner, uint _amount);\n', '\n', '  \tfunction LeeSungCoin() public\n', '\t{\n', '\t\trequire( icoCoinCap + mktCoinCap == totalCoinCap );\n', '\t\twallet = owner;\n', '\t\tadminWallet = owner;\n', '\t\t\n', '\t\tIcoContract = 0x6E5B3dBFB6a85D11e5d0d4A5618C53838Da63900;\n', '\t\tpriEtherReceived = 517 ether;\n', '\t\ticoEtherReceived = 112260255293000000000;\n', '  \t}\n', '\n', '  \tfunction () payable public\n', '\t{\n', '    \tbuyCoin();\n', '  \t}\n', '  \t\n', '  \tfunction atNow() public constant returns (uint)\n', '\t{\n', '\t\treturn now;\n', '  \t}\n', '\n', '  \tfunction buyCoin() private\n', '\t{\n', '\t\tuint nowTime = atNow();\n', '\n', '\t\tuint saleTime = 0; // 1 : preSaleFirst, 2 : preSaleSecond, 3 : mainSaleFirst, 4 : mainSaleSecond\n', '\n', '\t\tuint minEth = 0;\n', '\t\tuint maxEth = 300 ether;\n', '\n', '\t\tuint coins = 0;\n', '\t\tuint coinBonus = 0;\n', '\t\tuint coinCap = 0;\n', '\n', '\t\tif (nowTime > preSaleFirstStartDate && nowTime < preSaleFirstEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 1;\n', '\t\t\tminEth = preSaleMinEth;\n', '\t\t\tcoinBonus = preSaleFirstBonus;\n', '\t\t\tcoinCap = preSaleCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > preSaleSecondStartDate && nowTime < preSaleSecondEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 2;\n', '\t\t\tminEth = preSaleMinEth;\n', '\t\t\tcoinBonus = preSaleSecondBonus;\n', '\t\t\tcoinCap = preSaleCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > mainSaleFirstStartDate && nowTime < mainSaleFirstEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 3;\n', '\t\t\tminEth = mainSaleMinEth;\n', '\t\t\tcoinBonus = mainSaleFirstBonus;\n', '\t\t\tcoinCap = icoCoinCap;\n', '\t\t}\n', '\n', '\t\tif (nowTime > mainSaleSecondStartDate && nowTime < mainSaleSecondEndDate)\n', '\t\t{\n', '\t\t\tsaleTime = 4;\n', '\t\t\tminEth = mainSaleMinEth;\n', '\t\t\tcoinBonus = mainSaleSecondBonus;\n', '\t\t\tcoinCap = icoCoinCap;\n', '\t\t}\n', '\t\t\n', '\t\trequire( saleTime >= 1 && saleTime <= 4 );\n', '\t\trequire( msg.value >= minEth );\n', '\t\trequire( icoEtherContributed[msg.sender].add(msg.value) <= maxEth );\n', '\n', '\t\tcoins = coinPerEth.mul(msg.value) / 1 ether;\n', '      \tcoins = coins.mul(100 + coinBonus) / 100;\n', '\n', '\t\trequire( coinIssuedIco.add(coins) <= coinCap );\n', '\n', '\t\tbalances[msg.sender]        = balances[msg.sender].add(coins);\n', '\t    icoCoinReceived[msg.sender] = icoCoinReceived[msg.sender].add(coins);\n', '\t\tcoinIssuedIco               = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal           = tokensIssuedTotal.add(coins);\n', '    \n', '\t\ticoEtherReceived                = icoEtherReceived.add(msg.value);\n', '\t\ticoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value);\n', '    \n', '\t\tcoinLocked[msg.sender] = true;\n', '    \n', '\t\tTransfer(0x0, msg.sender, coins);\n', '\t\tCoinIssued(msg.sender, coins, balances[msg.sender], msg.value);\n', '\n', '\t\twallet.transfer(this.balance);\n', '  \t}\n', '\n', ' \tfunction isTransferable() public constant returns (bool transferable)\n', '\t{\n', '\t\tif ( atNow() < mainSaleSecondEndDate + transferCooldown )\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\treturn true;\n', '  \t}\n', '\n', '\tfunction coinLockRemove(address _participant) public\n', '\t{\n', '\t\trequire( msg.sender == adminWallet || msg.sender == owner );\n', '\t\tcoinLocked[_participant] = false;\n', '\t\tLockRemove(_participant);\n', '  \t}\n', '\n', '\tfunction coinLockRmoveMultiple(address[] _participants) public\n', '\t{\n', '\t\trequire( msg.sender == adminWallet || msg.sender == owner );\n', '    \t\t\n', '\t\tfor (uint i = 0; i < _participants.length; i++)\n', '\t\t{\n', '  \t\t\tcoinLocked[_participants[i]] = false;\n', '  \t\t\tLockRemove(_participants[i]);\n', '\t\t}\n', '  \t}\n', '\n', '  \tfunction changeWallet(address _wallet) onlyOwner public\n', '\t{\n', '    \t\trequire( _wallet != address(0x0) );\n', '    \t\twallet = _wallet;\n', '    \t\tWalletChange(wallet);\n', '  \t}\n', '\n', '  \tfunction changeAdminWallet(address _wallet) onlyOwner public\n', '\t{\n', '    \t\trequire( _wallet != address(0x0) );\n', '    \t\tadminWallet = _wallet;\n', '    \t\tAdminWalletChange(adminWallet);\n', '  \t}\n', '\n', '  \tfunction mintMarketing(address _participant, uint _amount) onlyOwner public\n', '\t{\n', '\t\tuint coins = _amount * E18;\n', '\t\t\n', '\t\trequire( coins <= mktCoinCap.sub(coinIssuedMkt) );\n', '\t\t\n', '\t\tbalances[_participant] = balances[_participant].add(coins);\n', '\t\t\n', '\t\tcoinIssuedMkt   = coinIssuedMkt.add(coins);\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tcoinLocked[_participant] = true;\n', '\t\t\n', '\t\tTransfer(0x0, _participant, coins);\n', '\t\tCoinMinted(_participant, coins, balances[_participant]);\n', '  \t}\n', '  \t\n', '  \tfunction mintIcoTokenMultiple(address[] _addresses, uint[] _amounts) onlyOwner public\n', '  \t{\n', '\t\tuint coins = 0;\n', '\t\t\n', '\t\tfor (uint i = 0; i < _addresses.length; i++)\n', '\t\t{\n', '\t\t    coins = _amounts[i] * E18;\n', '\t\t    \n', '\t\t    balances[_addresses[i]] = balances[_addresses[i]].add(coins);\n', '    \n', '\t\t    coinIssuedIco       = coinIssuedIco.add(coins);\n', '\t\t    coinIssuedTotal     = coinIssuedTotal.add(coins);\n', '\t\t    tokensIssuedTotal   = tokensIssuedTotal.add(coins);\n', '    \n', '\t\t    coinLocked[_addresses[i]] = true;\n', '\t\t    Transfer(0x0, _addresses[i], coins);\n', '\t        CoinMinted(_addresses[i], coins, balances[_addresses[i]]);\n', '\t\t}\n', '  \t}\n', '  \t\n', '  \tfunction ownerWithdraw() external onlyOwner\n', '\t{\n', '\t\tuint amount = this.balance;\n', '\t\twallet.transfer(amount);\n', '\t\tWithDraw(msg.sender, amount);\n', '  \t}\n', '  \t\n', '  \tfunction transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner public returns (bool success)\n', '\t{\n', '  \t\treturn ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  \t}\n', '  \t\n', '  \tfunction transfer(address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[msg.sender] == false );\n', '\t\trequire( coinLocked[_to] == false );\n', '\t\treturn super.transfer(_to, _amount);\n', '  \t}\n', '  \t\n', '  \tfunction transferFrom(address _from, address _to, uint _amount) public returns (bool success)\n', '\t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[_from] == false );\n', '\t\trequire( coinLocked[_to] == false );\n', '\t\treturn super.transferFrom(_from, _to, _amount);\n', '  \t}\n', '\n', '  \tfunction transferMultiple(address[] _addresses, uint[] _amounts) external\n', '  \t{\n', '\t\trequire( isTransferable() );\n', '\t\trequire( coinLocked[msg.sender] == false );\n', '\t\trequire( _addresses.length == _amounts.length );\n', '\t\t\n', '\t\tfor (uint i = 0; i < _addresses.length; i++)\n', '\t\t{\n', '  \t\t\tif (coinLocked[_addresses[i]] == false) \n', '\t\t\t{\n', '\t\t\t\tsuper.transfer(_addresses[i], _amounts[i]);\n', '\t\t\t}\n', '\t\t}\n', '  \t}\n', '\n', '  \tfunction reclaimFunds() external\n', '\t{\n', '\t\tuint coins;\n', '\t\tuint amount;\n', '\n', '\t\trequire( atNow() > mainSaleSecondEndDate );\n', '\t\trequire( !refundClaimed[msg.sender] );\n', '\t\trequire( icoEtherContributed[msg.sender] > 0 );\n', '\n', '\t\tcoins = icoCoinReceived[msg.sender];\n', '\t\tamount = icoEtherContributed[msg.sender];\n', '\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(coins);\n', '\t\ttokensIssuedTotal    = tokensIssuedTotal.sub(coins);\n', '\n', '\t\trefundClaimed[msg.sender] = true;\n', '\n', '\t\tmsg.sender.transfer(amount);\n', '\n', '\t\tTransfer(msg.sender, 0x0, coins);\n', '\t\tRefund(msg.sender, amount, coins);\n', '  \t}\n', '  \t\n', '    function transferToOwner(address _from) onlyOwner public\n', '    {\n', '\t\trequire( coinLocked[_from] == false );\n', '        uint amount = balanceOf(_from);\n', '        \n', '        balances[_from] = balances[_from].sub(amount);\n', '        balances[owner] = balances[owner].add(amount);\n', '        \n', '        Transfer(_from, owner, amount);\n', '        OwnerReclaim(_from, owner, amount);\n', '    }\n', '\n', '\tfunction burnIcoCoins() onlyOwner public returns (bool success)\n', '\t{\n', '\t    uint coins = 1400000000 * E18;\n', '\t    coins = coins.sub(coinIssuedIco);\n', '\t    \n', '\t    address burner = msg.sender;\n', '\t    \n', '\t\tbalances[burner] = balances[burner].add(coins);\n', '\t\t\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\tcoinIssuedIco   = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tTransfer(0x0, burner, coins);\n', '\t\t\n', '        coinIssuedTotal = coinIssuedTotal.sub(coins);\n', '        coinIssuedIco = coinIssuedIco.sub(coins);\n', '        coinBurnIco = coinBurnIco.add(coins);\n', '\t\t\n', '\t\treturn super.burn(coins);\n', '\t}\n', '\n', '\tfunction burnMktCoins() onlyOwner public returns (bool success)\n', '\t{\n', '\t    uint coins = 600000000 * E18;\n', '\t    coins = coins.sub(coinIssuedMkt);\n', '\t    \n', '\t    address burner = msg.sender;\n', '\t    \n', '\t\tbalances[burner] = balances[burner].add(coins);\n', '\t\t\n', '\t\tcoinIssuedTotal = coinIssuedTotal.add(coins);\n', '\t\tcoinIssuedIco   = coinIssuedIco.add(coins);\n', '\t\ttokensIssuedTotal = tokensIssuedTotal.add(coins);\n', '\t\t\n', '\t\tTransfer(0x0, burner, coins);\n', '\t\t\n', '        coinIssuedTotal = coinIssuedTotal.sub(coins);\n', '        coinIssuedMkt = coinIssuedMkt.sub(coins);\n', '        coinBurnMkt = coinBurnMkt.add(coins);\n', '\t\t\n', '\t\treturn super.burn(coins);\n', '\t}\n', '\n', '}']
