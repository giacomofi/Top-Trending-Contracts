['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Return true if sender is owner or super-owner of the contract\n', '    function isOwner() internal view returns(bool success) {\n', '        if (msg.sender == owner) return true;\n', '        return false;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].safeSub(_value);\n', '        balances[_to] = balances[_to].safeAdd(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amout of tokens to be transfered\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // require (_value <= _allowance);\n', '\n', '        balances[_to] = balances[_to].safeAdd(_value);\n', '        balances[_from] = balances[_from].safeSub(_value);\n', '        allowed[_from][msg.sender] = _allowance.safeSub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].safeAdd(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.safeSub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '     */\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ENTA is Standard ERC20 token\n', ' */\n', 'contract ENTA is StandardToken,Owned {\n', '\n', '    string public name = "ENTA";\n', '    string public symbol = "ENTA";\n', '    uint256 public decimals = 8;\n', '    uint256 public INITIAL_SUPPLY = 2000000000 * (10 ** decimals); // Two billion\n', '    uint256 public publicSell = 1530374400;//2018-07-01\n', '\n', '    bool public allowTransfers = true; // if true then allow coin transfers\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    event FrozenFunds(address indexed target, bool frozen);\n', '    event MinedBalancesUnlocked(address indexed target, uint256 amount);\n', '\n', '    struct MinedBalance {\n', '        uint256 total;\n', '        uint256 left;\n', '    }\n', '\n', '    mapping(address => MinedBalance) minedBalances;\n', '\n', '    constructor() public {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '\n', '    function transferMined(address to, uint256 tokens) public onlyOwner returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].safeSub(tokens);\n', '        minedBalances[to].total = minedBalances[to].total.safeAdd(tokens);\n', '        minedBalances[to].left = minedBalances[to].left.safeAdd(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to to account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // - @dev override\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint256 tokens) public returns (bool success) {\n', '        if (!isOwner()) {\n', '            require (allowTransfers);\n', '            require(!frozenAccount[msg.sender]);                                        // Check if sender is frozen\n', '            require(!frozenAccount[to]);                                               // Check if recipient is frozen\n', '        }\n', '        \n', '        if (now >= publicSell) {\n', '            uint256 month = (now-publicSell)/(30 days);\n', '            if(month>=7){\n', '                unlockMinedBalances(100);\n', '            } else if(month>=6){\n', '                unlockMinedBalances(90);\n', '            } else if(month>=3){\n', '                unlockMinedBalances(80);\n', '            } else if(month>=2){\n', '                unlockMinedBalances(60);\n', '            } else if(month>=1){\n', '                unlockMinedBalances(40);\n', '            } else if(month>=0){\n', '                unlockMinedBalances(20);\n', '            }\n', '        }\n', '        return super.transfer(to,tokens);\n', '    }\n', '\n', '    function unlockMinedBalances(uint256 unlockPercent) internal {\n', '        uint256 lockedMinedTokens = minedBalances[msg.sender].total*(100-unlockPercent)/100;\n', '        if(minedBalances[msg.sender].left > lockedMinedTokens){\n', '            uint256 unlock = minedBalances[msg.sender].left.safeSub(lockedMinedTokens);\n', '            minedBalances[msg.sender].left = lockedMinedTokens;\n', '            balances[msg.sender] = balances[msg.sender].safeAdd(unlock);\n', '            emit MinedBalancesUnlocked(msg.sender,unlock);\n', '        }\n', '    }\n', '\n', '    function setAllowTransfers(bool _allowTransfers) onlyOwner public {\n', '        allowTransfers = _allowTransfers;\n', '    }\n', '\n', '    function destroyToken(address target, uint256 amount) onlyOwner public {\n', '        balances[target] = balances[target].safeSub(amount);\n', '        totalSupply = totalSupply.safeSub(amount);\n', '        emit Transfer(target, this, amount);\n', '        emit Transfer(this, 0, amount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    // @dev override\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        if (!isOwner()) {\n', '            require (allowTransfers);\n', '            require(!frozenAccount[_from]);                                          // Check if sender is frozen\n', '            require(!frozenAccount[_to]);                                            // Check if recipient is frozen\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account tokenOwner\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public view returns (uint256 balance) {\n', '        return balances[tokenOwner].safeAdd(minedBalances[tokenOwner].left);\n', '    }\n', '}']