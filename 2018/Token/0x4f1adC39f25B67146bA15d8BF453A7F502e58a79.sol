['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------------------------\n', '// Moviecoin Token by Xender Limited.\n', '// An ERC20 standard\n', '//\n', '// author: Xender Team\n', '// Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="33405641455a5056734b565d5756411d505c5e">[email&#160;protected]</a>\n', '// ----------------------------------------------------------------------------------------------\n', '\n', '/*\n', '    Standard Token interface\n', '*/\n', 'contract ERC20Interface {\n', '     // Get the total token name\n', '    function name() public constant returns (string);\n', '\n', '    // Get the total token symbol\n', '    function symbol() public constant returns (string); \n', '\n', '    // Get the total token decimals\n', '    function decimals() public constant returns (uint);\n', '\n', '    // Get the total token supply\n', '    function totalSupply() public constant returns (uint256);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256);\n', '  \n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    \n', '    // transfer _value amount of token approved by address _from\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    // approve an address with _value amount of tokens\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '    // get remaining token approved by _owner to _spender\n', '    function allowance(address _owner, address _spender) public constant returns (uint256);\n', '   \n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*\n', '    owned manager\n', '*/\n', 'contract Owned {\n', '\n', '\t// Owner of this contract\n', '    address owner;\n', '    \n', '    // permit transaction\n', '    bool isLock = true;\n', '    \n', '    // white list\n', '    mapping(address => bool) whitelisted;\n', ' \n', '    \n', '    function Owned() public {\n', '        owner = msg.sender;\n', '        whitelisted[owner] = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\t\n', '\tmodifier isUnlock () {\n', '        if (isLock){\n', '            require(whitelisted[msg.sender] == true);\n', '        }\n', '        _;\n', '    }\n', '\t\n', '\t /**\n', '     * add new address to white list\n', '     */\n', '     function addWhitelist(address _white) public onlyOwner {\n', '         whitelisted[_white] = true;\n', '     }\n', '     \n', '    /**\n', '     * remove address from white list\n', '     */\n', '    function removeWhitelist(address _white) public onlyOwner {\n', '        whitelisted[_white] = false;\n', '    }\n', '      \n', '    /**\n', '     * check whether the address is in the white list\n', '     */\n', '    function checkWhitelist(address _addr) public view returns (bool) {\n', '        return whitelisted[_addr];\n', '    }\n', '    \n', '    /**\n', '    * unlock token. Only after unlock can it be traded.\n', '    */\n', '    function unlockToken() public onlyOwner returns (bool) {\n', '        isLock = false;\n', '        return isLock;\n', '    } \n', '}\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() public {\n', '    }\n', '    \n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        require(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        require(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '}\n', '\n', '/*\n', '    Moviecoin Token\n', '*/\n', 'contract Moviecoin is ERC20Interface, Owned, Utils {\n', '    string name_ = &#39;Dayibi&#39;;  \n', '    string  symbol_ = &#39;DYB&#39;;\n', '    uint8 decimals_ = 8; \n', '    uint256 totalSupply_ = 10 ** 18;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function Moviecoin() public {\n', '        balances[msg.sender] = totalSupply_;\n', '        Transfer(0x0, msg.sender, totalSupply_);\n', '    }\n', '\n', '  /**\n', '  * @dev token&#39;s symbol\n', '  */\n', '  \n', '  function name() public constant returns (string){\n', '      return name_;\n', '  }\n', '  \n', '  /**\n', '   * @dev set token name\n', '   */\n', '   function setName(string _name) public onlyOwner {\n', '       name_ = _name;\n', '   }\n', '\n', '  \n', '  /**\n', '  * @dev token&#39;s symbol\n', '  */\n', '  function symbol() public constant returns (string){\n', '      return symbol_;\n', '  }\n', '  \n', '   /**\n', '   * @dev set token symbol\n', '   */\n', '   function setSymbol(string _symbol) public onlyOwner {\n', '       symbol_ = _symbol;\n', '   }\n', '    \n', '  /**\n', '  * @dev token&#39;s decimals\n', '  */\n', '   function decimals() public constant returns (uint){\n', '        return decimals_;\n', '   }\n', ' \n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Get the account balance of another account with address _owner\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256) {\n', '        return balances[_owner];\n', '  }\n', ' \n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public isUnlock returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public isUnlock returns (bool) {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public isUnlock validAddress(_spender) returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  \n', '  /**\n', '   * @dev Don&#39;t accept ETH\n', '   */\n', '   function () public payable {\n', '       revert();\n', '   }\n', '   \n', '   /**\n', '    * @dev Owner can transfer out any accidentally sent ERC20 tokens\n', '    */\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '}']