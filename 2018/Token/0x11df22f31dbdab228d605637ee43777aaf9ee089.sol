['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath{\n', '    // Multiples 2 numbers, throws on overflow is detected.\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        if(_y == 0){\n', '            return 0;\n', '        }\n', '        result = _x*_y;\n', '        assert(_x == result/_y);\n', '        return result;\n', '    }\n', '    //Divides 2 numbers, solidity automatically throws if _y is 0.\n', '    function div(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        result = _x / _y;\n', '        return result;\n', '    }\n', '    //Adds 2 numbers, throws on overflow.\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        result = _x + _y;\n', '        assert(result >= _x);\n', '        return result;\n', '    }\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        assert(_x >= _y);\n', '        result = _x - _y;\n', '        return result;\n', '    }\n', '}\n', 'interface ReceiverContract{\n', '    function tokenFallback(address _sender, uint256 _amount, bytes _data) external;\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '    function deleteOwner() public onlyOwner{\n', '        emit ownerGone(owner);\n', '        owner = 0x0;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '    constructor(){\n', '        paused = false;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        require(paused == false);\n', '        _;\n', '    }\n', '}\n', 'contract ERC223Interface is Haltable, ERC20Interface{\n', '    function transfer(address _to, uint _amount, bytes _data) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens, bytes data);\n', '    event BalanceBurned(address indexed from, uint amount);\n', '}\n', '\n', '\n', 'contract ABIO is ERC223Interface{\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    //Getter functions are defined automatically for the following variables.\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    address ICOAddress;\n', '    address PICOAddress;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _supply) public{\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _supply;\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '\n', '    function supplyPICO(address _preIco) onlyOwner{\n', '        require(_preIco != 0x0 && PICOAddress == 0x0);\n', '        PICOAddress = _preIco;\n', '    }\n', '    function supplyICO(address _ico) onlyOwner{\n', '        require(_ico != 0x0 && ICOAddress == 0x0);\n', '        ICOAddress = _ico;\n', '    }\n', '    function burnMyBalance() public {\n', '        require(msg.sender != 0x0);\n', '        require(msg.sender == ICOAddress || msg.sender == PICOAddress);\n', '        uint b = balanceOf(msg.sender);\n', '        totalSupply = totalSupply.sub(b);\n', '        balances[msg.sender] = 0;\n', '        emit BalanceBurned(msg.sender, b);\n', '    }\n', '    /**\n', '     * @notice Underlying transfer function; it is called by public functions later.\n', '     * @dev This architecture saves >30000 gas as compared to having two independent public functions\n', '     *      for transfer with and without `_data`.\n', '     **/\n', '    function _transfer(address _from, address _to, uint256 _amount, bytes _data) internal returns (bool success){\n', '        require(_to != 0x0);\n', '        require(_amount <= balanceOf(_from));\n', '\n', '        uint256 initialBalances = balanceOf(_from).add(balanceOf(_to));\n', '\n', '        balances[_from] = balanceOf(_from).sub(_amount);\n', '        balances[_to] = balanceOf(_to).add(_amount);\n', '\n', '        if(isContract(_to)){\n', '            ReceiverContract receiver = ReceiverContract(_to);\n', '            receiver.tokenFallback(_from, _amount, _data);\n', '        }\n', '        assert(initialBalances == balanceOf(_from).add(balanceOf(_to)));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer with addidition data.\n', '     * @param _data will be sent to tokenFallback() if receiver is a contract.\n', '     **/\n', '    function transfer(address _to, uint256 _amount, bytes _data) stopOnPause public returns (bool success){\n', '        if (_transfer(msg.sender, _to, _amount, _data)){\n', '            emit Transfer(msg.sender, _to, _amount, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer without additional data.\n', '     * @dev An empty `bytes` instance will be created and sent to `tokenFallback()` if receiver is a contract.\n', '     **/\n', '    function transfer(address _to, uint256 _amount) stopOnPause public returns (bool success){\n', '        bytes memory empty;\n', '        if (_transfer(msg.sender, _to, _amount, empty)){\n', '            emit Transfer(msg.sender , _to, _amount);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Transfers `_amount` from `_from` to `_to` without additional data.\n', '     * @dev Only if `approve` has been called before!\n', '     * @param _data will be sent to tokenFallback() if receiver is a contract.\n', '     **/\n', '    function transferFrom(address _from, address _to, uint256 _amount, bytes _data) stopOnPause public returns (bool success){\n', '        require(_from != 0x0);\n', '        require(allowance(_from, msg.sender) >= _amount);\n', '\n', '\n', '        allowed[_from][msg.sender] = allowance(_from, msg.sender).sub(_amount);\n', '        assert(_transfer(_from, _to, _amount, _data));\n', '        emit Transfer(_from, _to, _amount, _data);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers `_amount` from `_from` to `_to` with additional data.\n', '     * @dev Only if `approve` has been called before!\n', '     * @dev An empty `bytes` instance will be created and sent to `tokenFallback()` if receiver is a contract.\n', '     **/\n', '    function transferFrom(address _from, address _to, uint256 _amount) stopOnPause  public returns (bool success){\n', '        require(_from != 0x0);\n', '        require(allowance(_from, msg.sender) >= _amount);\n', '\n', '        bytes memory empty;\n', '        allowed[_from][msg.sender] = allowance(_from, msg.sender).sub(_amount);\n', '        assert(_transfer(_from, _to, _amount, empty));\n', '        emit Transfer(_from, _to, _amount, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice gives `_spender` allowance to spend `amount` from sender&#39;s balance.\n', '     **/\n', '    function approve(address _spender, uint256 _amount) stopOnPause public returns (bool success){\n', '        require(_spender != 0x0);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Checks how much a certain user allowed to a different one.\n', '     **/\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a contract is behind an address.\n', '     * @dev Does it by checking if it has ANY code.\n', '     **/\n', '    function isContract(address _addr) public view returns(bool is_contract){\n', '        uint length;\n', '        assembly {\n', '            //retrieve the code length/size on target address\n', '            length := extcodesize(_addr)\n', '        }\n', '      return (length>0);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns balance of an address.\n', '     * @dev Returns `0` the address was never seen before.\n', '     **/\n', '    function balanceOf(address _addr) public view returns (uint256){\n', '        return balances[_addr];\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library SafeMath{\n', '    // Multiples 2 numbers, throws on overflow is detected.\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        if(_y == 0){\n', '            return 0;\n', '        }\n', '        result = _x*_y;\n', '        assert(_x == result/_y);\n', '        return result;\n', '    }\n', '    //Divides 2 numbers, solidity automatically throws if _y is 0.\n', '    function div(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        result = _x / _y;\n', '        return result;\n', '    }\n', '    //Adds 2 numbers, throws on overflow.\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        result = _x + _y;\n', '        assert(result >= _x);\n', '        return result;\n', '    }\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256 result){\n', '        assert(_x >= _y);\n', '        result = _x - _y;\n', '        return result;\n', '    }\n', '}\n', 'interface ReceiverContract{\n', '    function tokenFallback(address _sender, uint256 _amount, bytes _data) external;\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '    function deleteOwner() public onlyOwner{\n', '        emit ownerGone(owner);\n', '        owner = 0x0;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '    constructor(){\n', '        paused = false;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        require(paused == false);\n', '        _;\n', '    }\n', '}\n', 'contract ERC223Interface is Haltable, ERC20Interface{\n', '    function transfer(address _to, uint _amount, bytes _data) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens, bytes data);\n', '    event BalanceBurned(address indexed from, uint amount);\n', '}\n', '\n', '\n', 'contract ABIO is ERC223Interface{\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    //Getter functions are defined automatically for the following variables.\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    address ICOAddress;\n', '    address PICOAddress;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _supply) public{\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _supply;\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '\n', '    function supplyPICO(address _preIco) onlyOwner{\n', '        require(_preIco != 0x0 && PICOAddress == 0x0);\n', '        PICOAddress = _preIco;\n', '    }\n', '    function supplyICO(address _ico) onlyOwner{\n', '        require(_ico != 0x0 && ICOAddress == 0x0);\n', '        ICOAddress = _ico;\n', '    }\n', '    function burnMyBalance() public {\n', '        require(msg.sender != 0x0);\n', '        require(msg.sender == ICOAddress || msg.sender == PICOAddress);\n', '        uint b = balanceOf(msg.sender);\n', '        totalSupply = totalSupply.sub(b);\n', '        balances[msg.sender] = 0;\n', '        emit BalanceBurned(msg.sender, b);\n', '    }\n', '    /**\n', '     * @notice Underlying transfer function; it is called by public functions later.\n', '     * @dev This architecture saves >30000 gas as compared to having two independent public functions\n', '     *      for transfer with and without `_data`.\n', '     **/\n', '    function _transfer(address _from, address _to, uint256 _amount, bytes _data) internal returns (bool success){\n', '        require(_to != 0x0);\n', '        require(_amount <= balanceOf(_from));\n', '\n', '        uint256 initialBalances = balanceOf(_from).add(balanceOf(_to));\n', '\n', '        balances[_from] = balanceOf(_from).sub(_amount);\n', '        balances[_to] = balanceOf(_to).add(_amount);\n', '\n', '        if(isContract(_to)){\n', '            ReceiverContract receiver = ReceiverContract(_to);\n', '            receiver.tokenFallback(_from, _amount, _data);\n', '        }\n', '        assert(initialBalances == balanceOf(_from).add(balanceOf(_to)));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer with addidition data.\n', '     * @param _data will be sent to tokenFallback() if receiver is a contract.\n', '     **/\n', '    function transfer(address _to, uint256 _amount, bytes _data) stopOnPause public returns (bool success){\n', '        if (_transfer(msg.sender, _to, _amount, _data)){\n', '            emit Transfer(msg.sender, _to, _amount, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer without additional data.\n', '     * @dev An empty `bytes` instance will be created and sent to `tokenFallback()` if receiver is a contract.\n', '     **/\n', '    function transfer(address _to, uint256 _amount) stopOnPause public returns (bool success){\n', '        bytes memory empty;\n', '        if (_transfer(msg.sender, _to, _amount, empty)){\n', '            emit Transfer(msg.sender , _to, _amount);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Transfers `_amount` from `_from` to `_to` without additional data.\n', '     * @dev Only if `approve` has been called before!\n', '     * @param _data will be sent to tokenFallback() if receiver is a contract.\n', '     **/\n', '    function transferFrom(address _from, address _to, uint256 _amount, bytes _data) stopOnPause public returns (bool success){\n', '        require(_from != 0x0);\n', '        require(allowance(_from, msg.sender) >= _amount);\n', '\n', '\n', '        allowed[_from][msg.sender] = allowance(_from, msg.sender).sub(_amount);\n', '        assert(_transfer(_from, _to, _amount, _data));\n', '        emit Transfer(_from, _to, _amount, _data);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers `_amount` from `_from` to `_to` with additional data.\n', '     * @dev Only if `approve` has been called before!\n', '     * @dev An empty `bytes` instance will be created and sent to `tokenFallback()` if receiver is a contract.\n', '     **/\n', '    function transferFrom(address _from, address _to, uint256 _amount) stopOnPause  public returns (bool success){\n', '        require(_from != 0x0);\n', '        require(allowance(_from, msg.sender) >= _amount);\n', '\n', '        bytes memory empty;\n', '        allowed[_from][msg.sender] = allowance(_from, msg.sender).sub(_amount);\n', '        assert(_transfer(_from, _to, _amount, empty));\n', '        emit Transfer(_from, _to, _amount, empty);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @notice gives `_spender` allowance to spend `amount` from sender's balance.\n", '     **/\n', '    function approve(address _spender, uint256 _amount) stopOnPause public returns (bool success){\n', '        require(_spender != 0x0);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Checks how much a certain user allowed to a different one.\n', '     **/\n', '    function allowance(address _owner, address _spender) public view returns (uint256){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a contract is behind an address.\n', '     * @dev Does it by checking if it has ANY code.\n', '     **/\n', '    function isContract(address _addr) public view returns(bool is_contract){\n', '        uint length;\n', '        assembly {\n', '            //retrieve the code length/size on target address\n', '            length := extcodesize(_addr)\n', '        }\n', '      return (length>0);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns balance of an address.\n', '     * @dev Returns `0` the address was never seen before.\n', '     **/\n', '    function balanceOf(address _addr) public view returns (uint256){\n', '        return balances[_addr];\n', '    }\n', '}']
