['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Token is Ownable {\n', '\n', '  /// @return total amount of tokens\n', '  function totalSupply() view public returns (uint256 supply) {}\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '      //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '      //Replace the if with this one instead.\n', '      //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    if (balances[msg.sender] >= _value && _value > 0) {\n', '      balances[msg.sender] -= _value;\n', '      balances[_to] += _value;\n', '      emit Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '      }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '      //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '      balances[_to] += _value;\n', '      balances[_from] -= _value;\n', '      allowed[_from][msg.sender] -= _value;\n', '      emit Transfer(_from, _to, _value);\n', '      return true;\n', '    } else { \n', '      return false;\n', '      }\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  uint256 public totalSupply;\n', '}\n', '\n', 'contract Bitotal is StandardToken { \n', '\n', '  /* Public variables of the token */\n', '\n', '  /*\n', '  NOTE:\n', '  The following variables are OPTIONAL vanities. One does not have to include them.\n', '  They allow one to customise the token contract & in no way influences the core functionality.\n', '  Some wallets/interfaces might not even bother to look at this information.\n', '  */\n', '  string public name;                   // Token Name\n', '  uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18\n', '  string public symbol;                 // An identifier: eg SBX, XPR etc..\n', '  string public version = "1.0"; \n', '  uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', '  uint256 public totalEthInWei;         // WEI is the smallest unit of ETH \n', '  address public fundsWallet;           // Where should the raised ETH go?\n', '  uint256 public maxSupply;\n', '  uint256 public maxTransferPerTimeframe;\n', '  uint256 public timeFrame;\n', '  bool public paused;\n', '  bool public restrictTransfers;\n', '  mapping (address => uint256) public lastTransfer;\n', '  mapping (address => uint256) public transfered;\n', '\n', '  modifier NotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  // This is a constructor function \n', '  // which means the following function name has to match the contract name declared above\n', '  constructor() public {\n', '    fundsWallet = msg.sender; \n', '    balances[fundsWallet] = 100000000;               \n', '    totalSupply = 100000000;    \n', '    maxSupply = 500000000;                    \n', '    name = "Bitotal";                                   \n', '    decimals = 2;                                               \n', '    symbol = "TFUND";                                             \n', '    unitsOneEthCanBuy = 15;                                       \n', '    timeFrame = 86399;      \n', '    maxTransferPerTimeframe = 300;                            \n', '  }\n', '\n', '  function() payable public {\n', '    require(msg.value > 1 finney);\n', '    totalEthInWei = totalEthInWei + msg.value;\n', '    uint256 amount = msg.value * unitsOneEthCanBuy;\n', '    amount = (amount * 100) / 1 ether;\n', '    mintTokens(msg.sender, amount);\n', '    fundsWallet.transfer(msg.value);                               \n', '  }\n', '\n', '  function mintTokens(address _to, uint256 _amount) private {\n', '    require((totalSupply + _amount) <= maxSupply);\n', '    balances[_to] += _amount;\n', '    totalSupply += _amount;\n', '    emit Transfer(0x0, _to, _amount);\n', '  }\n', '\n', '  function setWalletAddress(address _newWallet) onlyOwner public {\n', '    require(_newWallet != address(0x0));\n', '    fundsWallet = _newWallet;\n', '  }\n', '\n', '  function pause(bool _paused) onlyOwner public {\n', '    paused = _paused;\n', '  }\n', '\n', '  function setTimeFrame(uint256 _time) onlyOwner public {\n', '    timeFrame = _time;\n', '  }\n', '\n', '  function restrict(bool _restricted) onlyOwner public {\n', '    restrictTransfers = _restricted;\n', '  }\n', '\n', '  function maxTransferAmount(uint256 _amount) onlyOwner public {\n', '    maxTransferPerTimeframe = _amount;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) NotPaused public returns (bool success) {\n', '    uint256 _lastTransfer;\n', '\n', '    _lastTransfer = lastTransfer[msg.sender] + timeFrame;\n', '\n', '    if ( _lastTransfer < now) {\n', '        \n', '      transfered[msg.sender] = 0;\n', '      lastTransfer[msg.sender] = now;\n', '    }\n', '     \n', '    if ((_value <= (maxTransferPerTimeframe - transfered[msg.sender])) || !restrictTransfers) {\n', '      \n', '      if (restrictTransfers) {\n', '        transfered[msg.sender] += _value;\n', '      }\n', '      super.transfer(_to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) NotPaused public returns (bool success) {\n', '    uint256 _lastTransfer;\n', '\n', '    _lastTransfer = lastTransfer[_from] + timeFrame;\n', '    if ( _lastTransfer < now) {\n', '      transfered[_from] = 0;\n', '      lastTransfer[_from] = now;\n', '    }\n', '    if ((_value <= (maxTransferPerTimeframe - transfered[_from])) || !restrictTransfers) {\n', '      if (restrictTransfers) {\n', '        transfered[_from] += _value;\n', '      }\n', '      super.transferFrom(_from, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Token is Ownable {\n', '\n', '  /// @return total amount of tokens\n', '  function totalSupply() view public returns (uint256 supply) {}\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', "      //Default assumes totalSupply can't be over max (2^256 - 1).\n", "      //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '      //Replace the if with this one instead.\n', '      //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    if (balances[msg.sender] >= _value && _value > 0) {\n', '      balances[msg.sender] -= _value;\n', '      balances[_to] += _value;\n', '      emit Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '      }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '      //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '      balances[_to] += _value;\n', '      balances[_from] -= _value;\n', '      allowed[_from][msg.sender] -= _value;\n', '      emit Transfer(_from, _to, _value);\n', '      return true;\n', '    } else { \n', '      return false;\n', '      }\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  uint256 public totalSupply;\n', '}\n', '\n', 'contract Bitotal is StandardToken { \n', '\n', '  /* Public variables of the token */\n', '\n', '  /*\n', '  NOTE:\n', '  The following variables are OPTIONAL vanities. One does not have to include them.\n', '  They allow one to customise the token contract & in no way influences the core functionality.\n', '  Some wallets/interfaces might not even bother to look at this information.\n', '  */\n', '  string public name;                   // Token Name\n', '  uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18\n', '  string public symbol;                 // An identifier: eg SBX, XPR etc..\n', '  string public version = "1.0"; \n', '  uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', '  uint256 public totalEthInWei;         // WEI is the smallest unit of ETH \n', '  address public fundsWallet;           // Where should the raised ETH go?\n', '  uint256 public maxSupply;\n', '  uint256 public maxTransferPerTimeframe;\n', '  uint256 public timeFrame;\n', '  bool public paused;\n', '  bool public restrictTransfers;\n', '  mapping (address => uint256) public lastTransfer;\n', '  mapping (address => uint256) public transfered;\n', '\n', '  modifier NotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  // This is a constructor function \n', '  // which means the following function name has to match the contract name declared above\n', '  constructor() public {\n', '    fundsWallet = msg.sender; \n', '    balances[fundsWallet] = 100000000;               \n', '    totalSupply = 100000000;    \n', '    maxSupply = 500000000;                    \n', '    name = "Bitotal";                                   \n', '    decimals = 2;                                               \n', '    symbol = "TFUND";                                             \n', '    unitsOneEthCanBuy = 15;                                       \n', '    timeFrame = 86399;      \n', '    maxTransferPerTimeframe = 300;                            \n', '  }\n', '\n', '  function() payable public {\n', '    require(msg.value > 1 finney);\n', '    totalEthInWei = totalEthInWei + msg.value;\n', '    uint256 amount = msg.value * unitsOneEthCanBuy;\n', '    amount = (amount * 100) / 1 ether;\n', '    mintTokens(msg.sender, amount);\n', '    fundsWallet.transfer(msg.value);                               \n', '  }\n', '\n', '  function mintTokens(address _to, uint256 _amount) private {\n', '    require((totalSupply + _amount) <= maxSupply);\n', '    balances[_to] += _amount;\n', '    totalSupply += _amount;\n', '    emit Transfer(0x0, _to, _amount);\n', '  }\n', '\n', '  function setWalletAddress(address _newWallet) onlyOwner public {\n', '    require(_newWallet != address(0x0));\n', '    fundsWallet = _newWallet;\n', '  }\n', '\n', '  function pause(bool _paused) onlyOwner public {\n', '    paused = _paused;\n', '  }\n', '\n', '  function setTimeFrame(uint256 _time) onlyOwner public {\n', '    timeFrame = _time;\n', '  }\n', '\n', '  function restrict(bool _restricted) onlyOwner public {\n', '    restrictTransfers = _restricted;\n', '  }\n', '\n', '  function maxTransferAmount(uint256 _amount) onlyOwner public {\n', '    maxTransferPerTimeframe = _amount;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) NotPaused public returns (bool success) {\n', '    uint256 _lastTransfer;\n', '\n', '    _lastTransfer = lastTransfer[msg.sender] + timeFrame;\n', '\n', '    if ( _lastTransfer < now) {\n', '        \n', '      transfered[msg.sender] = 0;\n', '      lastTransfer[msg.sender] = now;\n', '    }\n', '     \n', '    if ((_value <= (maxTransferPerTimeframe - transfered[msg.sender])) || !restrictTransfers) {\n', '      \n', '      if (restrictTransfers) {\n', '        transfered[msg.sender] += _value;\n', '      }\n', '      super.transfer(_to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) NotPaused public returns (bool success) {\n', '    uint256 _lastTransfer;\n', '\n', '    _lastTransfer = lastTransfer[_from] + timeFrame;\n', '    if ( _lastTransfer < now) {\n', '      transfered[_from] = 0;\n', '      lastTransfer[_from] = now;\n', '    }\n', '    if ((_value <= (maxTransferPerTimeframe - transfered[_from])) || !restrictTransfers) {\n', '      if (restrictTransfers) {\n', '        transfered[_from] += _value;\n', '      }\n', '      super.transferFrom(_from, _to, _value);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '}']
