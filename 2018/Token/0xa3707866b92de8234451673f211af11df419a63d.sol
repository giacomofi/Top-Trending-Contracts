['pragma solidity 0.4.21;\n', '\n', '/// @title ERC20 ERC20 Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Chenyo\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract AirDropContract {\n', '\n', '    event AirDropped(address addr, uint amount);\n', '\n', '    function drop(\n', '        address tokenAddress,\n', '        address conTokenAddress,  //额外token条件地址,如不需要,保持和tokenAddress相同即可\n', '        uint amount,\n', '        uint[2] minmaxTokenBalance,\n', '        uint[2] minmaxConBalance,  //额外token min-max条件\n', '        uint[2] minmaxEthBalance,\n', '        address[] recipients) public {\n', '\n', '        require(tokenAddress != 0x0);\n', '        require(conTokenAddress != 0x0);\n', '        require(amount > 0);\n', '        require(minmaxTokenBalance[1] >= minmaxTokenBalance[0]);\n', '        require(minmaxConBalance[1] >= minmaxConBalance[0]);\n', '        require(minmaxEthBalance[1] >= minmaxEthBalance[0]);\n', '\n', '        ERC20 token = ERC20(tokenAddress);\n', '        ERC20 contoken = ERC20(conTokenAddress);\n', '\n', '        uint balance = token.balanceOf(msg.sender);\n', '        uint allowance = token.allowance(msg.sender, address(this));\n', '        uint available = balance > allowance ? allowance : balance;\n', '\n', '        for (uint i = 0; i < recipients.length; i++) {\n', '            require(available >= amount);\n', '            address recipient = recipients[i];\n', '            if (isQualitifiedAddress(\n', '                token,\n', '                contoken,\n', '                recipient,\n', '                minmaxTokenBalance,\n', '                minmaxConBalance,\n', '                minmaxEthBalance\n', '            )) {\n', '                available -= amount;\n', '                require(token.transferFrom(msg.sender, recipient, amount));\n', '\n', '                AirDropped(recipient, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function isQualitifiedAddress(\n', '        ERC20 token,\n', '        ERC20 contoken,\n', '        address addr,\n', '        uint[2] minmaxTokenBalance,\n', '        uint[2] minmaxConBalance,\n', '        uint[2] minmaxEthBalance\n', '        )\n', '        public\n', '        view\n', '        returns (bool result)\n', '    {\n', '        result = addr != 0x0 && addr != msg.sender && !isContract(addr);\n', '\n', '        uint ethBalance = addr.balance;\n', '        uint tokenBbalance = token.balanceOf(addr);\n', '        uint conTokenBalance = contoken.balanceOf(addr);\n', '\n', '        result = result && (ethBalance>= minmaxEthBalance[0] &&\n', '            ethBalance <= minmaxEthBalance[1] &&\n', '            tokenBbalance >= minmaxTokenBalance[0] &&\n', '            tokenBbalance <= minmaxTokenBalance[1] &&\n', '            conTokenBalance >= minmaxConBalance[0] &&\n', '            conTokenBalance <= minmaxConBalance[1]);\n', '    }\n', '\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function () payable public {\n', '        revert();\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '/// @title ERC20 ERC20 Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Chenyo\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract AirDropContract {\n', '\n', '    event AirDropped(address addr, uint amount);\n', '\n', '    function drop(\n', '        address tokenAddress,\n', '        address conTokenAddress,  //额外token条件地址,如不需要,保持和tokenAddress相同即可\n', '        uint amount,\n', '        uint[2] minmaxTokenBalance,\n', '        uint[2] minmaxConBalance,  //额外token min-max条件\n', '        uint[2] minmaxEthBalance,\n', '        address[] recipients) public {\n', '\n', '        require(tokenAddress != 0x0);\n', '        require(conTokenAddress != 0x0);\n', '        require(amount > 0);\n', '        require(minmaxTokenBalance[1] >= minmaxTokenBalance[0]);\n', '        require(minmaxConBalance[1] >= minmaxConBalance[0]);\n', '        require(minmaxEthBalance[1] >= minmaxEthBalance[0]);\n', '\n', '        ERC20 token = ERC20(tokenAddress);\n', '        ERC20 contoken = ERC20(conTokenAddress);\n', '\n', '        uint balance = token.balanceOf(msg.sender);\n', '        uint allowance = token.allowance(msg.sender, address(this));\n', '        uint available = balance > allowance ? allowance : balance;\n', '\n', '        for (uint i = 0; i < recipients.length; i++) {\n', '            require(available >= amount);\n', '            address recipient = recipients[i];\n', '            if (isQualitifiedAddress(\n', '                token,\n', '                contoken,\n', '                recipient,\n', '                minmaxTokenBalance,\n', '                minmaxConBalance,\n', '                minmaxEthBalance\n', '            )) {\n', '                available -= amount;\n', '                require(token.transferFrom(msg.sender, recipient, amount));\n', '\n', '                AirDropped(recipient, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function isQualitifiedAddress(\n', '        ERC20 token,\n', '        ERC20 contoken,\n', '        address addr,\n', '        uint[2] minmaxTokenBalance,\n', '        uint[2] minmaxConBalance,\n', '        uint[2] minmaxEthBalance\n', '        )\n', '        public\n', '        view\n', '        returns (bool result)\n', '    {\n', '        result = addr != 0x0 && addr != msg.sender && !isContract(addr);\n', '\n', '        uint ethBalance = addr.balance;\n', '        uint tokenBbalance = token.balanceOf(addr);\n', '        uint conTokenBalance = contoken.balanceOf(addr);\n', '\n', '        result = result && (ethBalance>= minmaxEthBalance[0] &&\n', '            ethBalance <= minmaxEthBalance[1] &&\n', '            tokenBbalance >= minmaxTokenBalance[0] &&\n', '            tokenBbalance <= minmaxTokenBalance[1] &&\n', '            conTokenBalance >= minmaxConBalance[0] &&\n', '            conTokenBalance <= minmaxConBalance[1]);\n', '    }\n', '\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function () payable public {\n', '        revert();\n', '    }\n', '}']
