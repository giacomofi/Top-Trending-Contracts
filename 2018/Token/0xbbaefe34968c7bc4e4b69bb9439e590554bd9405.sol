['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/MarketDataStorage.sol\n', '\n', 'contract MarketDataStorage is Ownable {\n', '    // vars\n', '    address[] supportedTokens;\n', '    mapping (address => bool) public supportedTokensMapping; // same as supportedTokens just in a mapping for quicker lookup\n', '    mapping (address => uint[]) public currentTokenMarketData; // represent the last token data\n', '    mapping (bytes32 => bool) internal validIds; // for Oraclize callbacks\n', '    address dataUpdater; // who is allowed to update data\n', '\n', '    // modifiers\n', '    modifier updaterOnly() {\n', '        require(\n', '            msg.sender == dataUpdater,\n', '            "updater not allowed"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier supportedTokenOnly(address token_address) {\n', '        require(\n', '            isTokenSupported(token_address),\n', '            "Can&#39;t update a non supported token"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor (address[] _supportedTokens, address _dataUpdater) Ownable() public {\n', '        dataUpdater = _dataUpdater;\n', '\n', '        // to populate supportedTokensMapping\n', '        for (uint i=0; i<_supportedTokens.length; i++) {\n', '            addSupportedToken(_supportedTokens[i]);\n', '        }\n', '    }\n', '\n', '    function numberOfSupportedTokens() view public returns (uint) {\n', '        return supportedTokens.length;\n', '    }\n', '\n', '    function getSupportedTokenByIndex(uint idx) view public returns (address token_address, bool supported_status) {\n', '        address token = supportedTokens[idx];\n', '        return (token, supportedTokensMapping[token]);\n', '    }\n', '\n', '    function getMarketDataByTokenIdx(uint idx) view public returns (address token_address, uint volume, uint depth, uint marketcap) {\n', '        (address token, bool status) = getSupportedTokenByIndex(idx);\n', '\n', '        (uint _volume, uint _depth, uint _marketcap) = getMarketData(token);\n', '\n', '        return (token, _volume, _depth, _marketcap);\n', '    }\n', '\n', '    function getMarketData(address token_address) view public returns (uint volume, uint depth, uint marketcap) {\n', '        // we do not throw an exception for non supported tokens, simply return 0,0,0\n', '        if (!supportedTokensMapping[token_address]) {\n', '            return (0,0,0);\n', '        }\n', '\n', '        uint[] memory data = currentTokenMarketData[token_address];\n', '        return (data[0], data[1], data[2]);\n', '    }\n', '\n', '    function addSupportedToken(address token_address) public onlyOwner {\n', '        require(\n', '            isTokenSupported(token_address) == false,\n', '            "Token already added"\n', '        );\n', '\n', '        supportedTokens.push(token_address);\n', '        supportedTokensMapping[token_address] = true;\n', '\n', '        currentTokenMarketData[token_address] = [0,0,0]; // until next update\n', '    }\n', '\n', '    function isTokenSupported(address token_address) view public returns (bool) {\n', '        return supportedTokensMapping[token_address];\n', '    }\n', '\n', '    // update Data\n', '    function updateMarketData(address token_address,\n', '        uint volume,\n', '        uint depth,\n', '        uint marketcap)\n', '    external\n', '    updaterOnly\n', '    supportedTokenOnly(token_address) {\n', '        currentTokenMarketData[token_address] = [volume,depth,marketcap];\n', '    }\n', '}\n', '\n', '// File: contracts/WarOfTokens.sol\n', '\n', 'contract WarOfTokens is Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    struct AttackInfo {\n', '        address attacker;\n', '        address attackee;\n', '        uint attackerScore;\n', '        uint attackeeScore;\n', '        bytes32 attackId;\n', '        bool completed;\n', '        uint hodlSpellBlockNumber;\n', '        mapping (address => uint256) attackerWinnings;\n', '        mapping (address => uint256) attackeeWinnings;\n', '    }\n', '\n', '    // events\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    event UserActiveStatusChanged(address user, bool isActive);\n', '    event Attack (\n', '        address indexed attacker,\n', '        address indexed attackee,\n', '        bytes32 attackId,\n', '        uint attackPrizePercent,\n', '        uint base,\n', '        uint hodlSpellBlockNumber\n', '    );\n', '    event AttackCompleted (\n', '        bytes32 indexed attackId,\n', '        address indexed winner,\n', '        uint attackeeActualScore\n', '    );\n', '\n', '    // vars\n', '    /**\n', '    *   mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    */\n', '    mapping (address => mapping (address => uint256)) public tokens;\n', '    mapping (address => bool) public activeUsers;\n', '    address public cdtTokenAddress;\n', '    uint256 public minCDTToParticipate;\n', '    MarketDataStorage public marketDataOracle;\n', '    uint public maxAttackPrizePercent; // if attacker and attackee have the same score, whats the max % of their assets will be as prize\n', '    uint attackPricePrecentBase = 1000; // since EVM doesn&#39;t support floating numbers yet.\n', '    uint public maxOpenAttacks = 5;\n', '    mapping (bytes32 => AttackInfo) public attackIdToInfo;\n', '    mapping (address => mapping(address => bytes32)) public userToUserToAttackId;\n', '    mapping (address => uint) public cntUserAttacks; // keeps track of how many un-completed attacks user has\n', '\n', '\n', '    // modifiers\n', '    modifier activeUserOnly(address user) {\n', '        require(\n', '            isActiveUser(user),\n', '            "User not active"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(address _cdtTokenAddress,\n', '        uint256 _minCDTToParticipate,\n', '        address _marketDataOracleAddress,\n', '        uint _maxAttackPrizeRatio)\n', '    Pausable()\n', '    public {\n', '        cdtTokenAddress = _cdtTokenAddress;\n', '        minCDTToParticipate = _minCDTToParticipate;\n', '        marketDataOracle = MarketDataStorage(_marketDataOracleAddress);\n', '        setMaxAttackPrizePercent(_maxAttackPrizeRatio);\n', '    }\n', '\n', '    // don&#39;t allow default\n', '    function() public {\n', '        revert("Please do not send ETH without calling the deposit function. We will not do it automatically to validate your intent");\n', '    }\n', '\n', '    // user management\n', '    function isActiveUser(address user) view public returns (bool) {\n', '        return activeUsers[user];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  balances management\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // taken from https://etherscan.io/address/0x8d12a197cb00d4747a1fe03395095ce2a5cc6819#code\n', '    /**\n', '    *   disabled when contract is paused\n', '    */\n', '    function deposit() payable external whenNotPaused {\n', '        tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    /**\n', '    *   disabled when contract is paused\n', '    */\n', '    function depositToken(address token, uint amount) external whenNotPaused {\n', '        //remember to call StandardToken(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '        require(\n', '            token!=0,\n', '            "unrecognized token"\n', '        );\n', '        assert(StandardToken(token).transferFrom(msg.sender, this, amount));\n', '        tokens[token][msg.sender] =  tokens[token][msg.sender].add(amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function withdraw(uint amount) external {\n', '        tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n', '        assert(msg.sender.call.value(amount)());\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) external {\n', '        require(\n', '            token!=0,\n', '            "unrecognized token"\n', '        );\n', '        tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '        assert(StandardToken(token).transfer(msg.sender, amount));\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address token, address user) view public returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  combat functions\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '    function setMaxAttackPrizePercent(uint newAttackPrize) onlyOwner public {\n', '        require(\n', '            newAttackPrize < 5,\n', '            "max prize is 5 percent of funds"\n', '        );\n', '        maxAttackPrizePercent = newAttackPrize;\n', '    }\n', '\n', '    function setMaxOpenAttacks(uint newValue) onlyOwner public {\n', '        maxOpenAttacks = newValue;\n', '    }\n', '\n', '    function openAttacksCount(address user) view public returns (uint) {\n', '        return cntUserAttacks[user];\n', '    }\n', '\n', '    function isTokenSupported(address token_address) view public returns (bool) {\n', '        return marketDataOracle.isTokenSupported(token_address);\n', '    }\n', '\n', '    function getUserScore(address user)\n', '    view\n', '    public\n', '    whenNotPaused\n', '    returns (uint) {\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '        uint aggregated_score = 0;\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, uint volume, uint depth, uint marketcap) = marketDataOracle.getMarketDataByTokenIdx(i);\n', '            uint256 user_balance = balanceOf(token_address, user);\n', '\n', '            aggregated_score = aggregated_score + _calculateScore(user_balance, volume, depth, marketcap);\n', '        }\n', '\n', '        return aggregated_score;\n', '    }\n', '\n', '    function _calculateScore(uint256 balance, uint volume, uint depth, uint marketcap) pure internal returns (uint) {\n', '        return balance * volume * depth * marketcap;\n', '    }\n', '\n', '    function attack(address attackee)\n', '    external\n', '    activeUserOnly(msg.sender)\n', '    activeUserOnly(attackee)\n', '    {\n', '        require(\n', '            msg.sender != attackee,\n', '            "Can&#39;t attack yourself"\n', '        );\n', '        require(\n', '            userToUserToAttackId[msg.sender][attackee] == 0,\n', '            "Cannot attack while pending attack exists, please complete attack"\n', '        );\n', '        require(\n', '            openAttacksCount(msg.sender) < maxOpenAttacks,\n', '            "Too many open attacks for attacker"\n', '        );\n', '        require(\n', '            openAttacksCount(attackee) < maxOpenAttacks,\n', '            "Too many open attacks for attackee"\n', '        );\n', '\n', '        (uint attackPrizePercent, uint attackerScore, uint attackeeScore) = attackPrizeRatio(attackee);\n', '\n', '        AttackInfo memory attackInfo = AttackInfo(\n', '            msg.sender,\n', '            attackee,\n', '            attackerScore,\n', '            attackeeScore,\n', '            sha256(abi.encodePacked(msg.sender, attackee, block.blockhash(block.number-1))), // attack Id\n', '            false,\n', '            block.number // block after insertion of attack tx the complete function can be called\n', '        );\n', '        _registerAttack(attackInfo);\n', '\n', '        _calculateWinnings(attackIdToInfo[attackInfo.attackId], attackPrizePercent);\n', '\n', '        emit Attack(\n', '            attackInfo.attacker,\n', '            attackInfo.attackee,\n', '            attackInfo.attackId,\n', '            attackPrizePercent,\n', '            attackPricePrecentBase,\n', '            attackInfo.hodlSpellBlockNumber\n', '        );\n', '    }\n', '\n', '    /**\n', '    *   Returns the % of the attacker/ attackee funds are for winning/ loosing\n', '    *   we multiple the values by a base since solidity does not support\n', '    *   floating values.\n', '    */\n', '    function attackPrizeRatio(address attackee)\n', '    view\n', '    public\n', '    returns (uint attackPrizePercent, uint attackerScore, uint attackeeScore) {\n', '        uint _attackerScore = getUserScore(msg.sender);\n', '        require(\n', '            _attackerScore > 0,\n', '            "attacker score is 0"\n', '        );\n', '        uint _attackeeScore = getUserScore(attackee);\n', '        require(\n', '            _attackeeScore > 0,\n', '            "attackee score is 0"\n', '        );\n', '\n', '        uint howCloseAreThey = _attackeeScore.mul(attackPricePrecentBase).div(_attackerScore);\n', '\n', '        return (howCloseAreThey, _attackerScore, _attackeeScore);\n', '    }\n', '\n', '    function attackerPrizeByToken(bytes32 attackId, address token_address) view public returns (uint256) {\n', '        return attackIdToInfo[attackId].attackerWinnings[token_address];\n', '    }\n', '\n', '    function attackeePrizeByToken(bytes32 attackId, address token_address) view public returns (uint256) {\n', '        return attackIdToInfo[attackId].attackeeWinnings[token_address];\n', '    }\n', '\n', '    // anyone can call the complete attack function.\n', '    function completeAttack(bytes32 attackId) public {\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        (address winner, uint attackeeActualScore) = getWinner(attackId);\n', '\n', '        // distribuite winngs\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, bool status) = marketDataOracle.getSupportedTokenByIndex(i);\n', '\n', '            if (attackInfo.attacker == winner) {\n', '                uint winnings = attackInfo.attackerWinnings[token_address];\n', '\n', '                if (winnings > 0) {\n', '                    tokens[token_address][attackInfo.attackee] = tokens[token_address][attackInfo.attackee].sub(winnings);\n', '                    tokens[token_address][attackInfo.attacker] = tokens[token_address][attackInfo.attacker].add(winnings);\n', '                }\n', '            }\n', '            else {\n', '                uint loosings = attackInfo.attackeeWinnings[token_address];\n', '\n', '                if (loosings > 0) {\n', '                    tokens[token_address][attackInfo.attacker] = tokens[token_address][attackInfo.attacker].sub(loosings);\n', '                    tokens[token_address][attackInfo.attackee] = tokens[token_address][attackInfo.attackee].add(loosings);\n', '                }\n', '            }\n', '        }\n', '\n', '        // cleanup\n', '        _unregisterAttack(attackId);\n', '\n', '        emit AttackCompleted(\n', '            attackId,\n', '            winner,\n', '            attackeeActualScore\n', '        );\n', '    }\n', '\n', '    function getWinner(bytes32 attackId) public view returns(address winner, uint attackeeActualScore) {\n', '        require(\n', '            block.number >= attackInfo.hodlSpellBlockNumber,\n', '            "attack can not be completed at this block, please wait"\n', '        );\n', '\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        //  block.blockhash records only for the recent 256 blocks\n', '        //  https://solidity.readthedocs.io/en/v0.3.1/units-and-global-variables.html#block-and-transaction-properties\n', '        //  So... attacker has 256 blocks to call completeAttack\n', '        //  otherwise win goes automatically to the attackee\n', '        if (block.number - attackInfo.hodlSpellBlockNumber >= 256) {\n', '            return (attackInfo.attackee, attackInfo.attackeeScore);\n', '        }\n', '\n', '        bytes32 blockHash = block.blockhash(attackInfo.hodlSpellBlockNumber);\n', '        return _calculateWinnerBasedOnEntropy(attackInfo, blockHash);\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  internal functions\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // validates user active status\n', '    function _validateUserActive(address user) private {\n', '        // get CDT balance\n', '        uint256 cdt_balance = balanceOf(cdtTokenAddress, user);\n', '\n', '        bool new_active_state = cdt_balance >= minCDTToParticipate;\n', '        bool current_active_state = activeUsers[user]; // could be false if never set up\n', '\n', '        if (current_active_state != new_active_state) { // only emit on activity change\n', '            emit UserActiveStatusChanged(user, new_active_state);\n', '        }\n', '\n', '        activeUsers[user] = new_active_state;\n', '    }\n', '\n', '    function _registerAttack(AttackInfo attackInfo) internal {\n', '        userToUserToAttackId[attackInfo.attacker][attackInfo.attackee] = attackInfo.attackId;\n', '        userToUserToAttackId[attackInfo.attackee][attackInfo.attacker] = attackInfo.attackId;\n', '\n', '        attackIdToInfo[attackInfo.attackId] = attackInfo;\n', '\n', '        // update open attacks counter\n', '        cntUserAttacks[attackInfo.attacker] = cntUserAttacks[attackInfo.attacker].add(1);\n', '        cntUserAttacks[attackInfo.attackee] = cntUserAttacks[attackInfo.attackee].add(1);\n', '    }\n', '\n', '    function _unregisterAttack(bytes32 attackId) internal {\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        cntUserAttacks[attackInfo.attacker] = cntUserAttacks[attackInfo.attacker].sub(1);\n', '        cntUserAttacks[attackInfo.attackee] = cntUserAttacks[attackInfo.attackee].sub(1);\n', '\n', '        delete userToUserToAttackId[attackInfo.attacker][attackInfo.attackee];\n', '        delete userToUserToAttackId[attackInfo.attackee][attackInfo.attacker];\n', '\n', '        delete attackIdToInfo[attackId];\n', '    }\n', '\n', '    /**\n', '       if the attacker has a higher/ equal score to the attackee than the prize will be at max maxAttackPrizePercent\n', '       if the attacker has lower score than the prize can be higher than maxAttackPrizePercent since he takes a bigger risk\n', '   */\n', '    function _calculateWinnings(AttackInfo storage attackInfo, uint attackPrizePercent) internal {\n', '        // get all user balances and calc winnings from that\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '\n', '        uint actualPrizeRation = attackPrizePercent\n', '        .mul(maxAttackPrizePercent);\n', '\n', '\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, bool status) = marketDataOracle.getSupportedTokenByIndex(i);\n', '\n', '            if (status) {\n', '                // attacker\n', '                uint256 _b1 = balanceOf(token_address, attackInfo.attacker);\n', '                if (_b1 > 0) {\n', '                    uint256 _w1 = _b1.mul(actualPrizeRation).div(attackPricePrecentBase * 100); // 100 since maxAttackPrizePercent has 100 basis\n', '                    attackInfo.attackeeWinnings[token_address] = _w1;\n', '                }\n', '\n', '                // attackee\n', '                uint256 _b2 = balanceOf(token_address, attackInfo.attackee);\n', '                if (_b2 > 0) {\n', '                    uint256 _w2 = _b2.mul(actualPrizeRation).div(attackPricePrecentBase * 100); // 100 since maxAttackPrizePercent has 100 basis\n', '                    attackInfo.attackerWinnings[token_address] = _w2;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    //\n', '    // winner logic:\n', '    //  1) get difference in scores between players times 2\n', '    //  2) get hodl spell block number (decided in the attack call), do hash % {result of step 1}\n', '    //  3) block hash mod 10 to decide direction\n', '    //  4) if result step 3 > 1 than we add result step 2 to attackee&#39;s score (80% chance for this to happen)\n', '    //  5) else reduce attacke&#39;s score by result of step 2\n', '    //\n', '    //\n', '    //\n', '    // Since the attacker decides if to attack or not we give the attackee a defending chance by\n', '    // adopting the random HODL spell.\n', '    // if the attacker has a higher score than attackee than the HODL spell will randomly add (most probably) to the\n', '    // attackee score. this might or might not be enought to beat the attacker.\n', '    //\n', '    // if the attacker has a lower score than the attackee than he takes a bigger chance in attacking and he will get a bigger reward.\n', '    //\n', '    //\n', '    // just like in crypto life, HODLing has its risks and rewards. Be carefull in your trading decisions!\n', '    function _calculateWinnerBasedOnEntropy(AttackInfo storage attackInfo, bytes32 entropy) view internal returns(address, uint) {\n', '        uint attackeeActualScore = attackInfo.attackeeScore;\n', '        uint modul = _absSubtraction(attackInfo.attackerScore, attackInfo.attackeeScore);\n', '        modul = modul.mul(2); // attacker score is now right in the middle of the range\n', '        uint hodlSpell = uint(entropy) % modul;\n', '        uint direction = uint(entropy) % 10;\n', '        uint directionThreshold = 1;\n', '\n', '        // direction is 80% chance positive (meaning adding the hodl spell)\n', '        // to the weakest player\n', '        if (attackInfo.attackerScore < attackInfo.attackeeScore) {\n', '            directionThreshold = 8;\n', '        }\n', '\n', '        // winner calculation\n', '        if (direction > directionThreshold) {\n', '            attackeeActualScore = attackeeActualScore.add(hodlSpell);\n', '        }\n', '        else {\n', '            attackeeActualScore = _safeSubtract(attackeeActualScore, hodlSpell);\n', '        }\n', '        if (attackInfo.attackerScore > attackeeActualScore) { return (attackInfo.attacker, attackeeActualScore); }\n', '        else { return (attackInfo.attackee, attackeeActualScore); }\n', '    }\n', '\n', '    // will subtract 2 uint and returns abs(result).\n', '    // example: a=2,b=3 returns 1\n', '    // example: a=3,b=2 returns 1\n', '    function _absSubtraction(uint a, uint b) pure internal returns (uint) {\n', '        if (b>a) {\n', '            return b-a;\n', '        }\n', '\n', '        return a-b;\n', '    }\n', '\n', '    // example: a=2,b=3 returns 0\n', '    // example: a=3,b=2 returns 1\n', '    function _safeSubtract(uint a, uint b) pure internal returns (uint) {\n', '        if (b > a) {\n', '            return 0;\n', '        }\n', '\n', '        return a-b;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/MarketDataStorage.sol\n', '\n', 'contract MarketDataStorage is Ownable {\n', '    // vars\n', '    address[] supportedTokens;\n', '    mapping (address => bool) public supportedTokensMapping; // same as supportedTokens just in a mapping for quicker lookup\n', '    mapping (address => uint[]) public currentTokenMarketData; // represent the last token data\n', '    mapping (bytes32 => bool) internal validIds; // for Oraclize callbacks\n', '    address dataUpdater; // who is allowed to update data\n', '\n', '    // modifiers\n', '    modifier updaterOnly() {\n', '        require(\n', '            msg.sender == dataUpdater,\n', '            "updater not allowed"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier supportedTokenOnly(address token_address) {\n', '        require(\n', '            isTokenSupported(token_address),\n', '            "Can\'t update a non supported token"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor (address[] _supportedTokens, address _dataUpdater) Ownable() public {\n', '        dataUpdater = _dataUpdater;\n', '\n', '        // to populate supportedTokensMapping\n', '        for (uint i=0; i<_supportedTokens.length; i++) {\n', '            addSupportedToken(_supportedTokens[i]);\n', '        }\n', '    }\n', '\n', '    function numberOfSupportedTokens() view public returns (uint) {\n', '        return supportedTokens.length;\n', '    }\n', '\n', '    function getSupportedTokenByIndex(uint idx) view public returns (address token_address, bool supported_status) {\n', '        address token = supportedTokens[idx];\n', '        return (token, supportedTokensMapping[token]);\n', '    }\n', '\n', '    function getMarketDataByTokenIdx(uint idx) view public returns (address token_address, uint volume, uint depth, uint marketcap) {\n', '        (address token, bool status) = getSupportedTokenByIndex(idx);\n', '\n', '        (uint _volume, uint _depth, uint _marketcap) = getMarketData(token);\n', '\n', '        return (token, _volume, _depth, _marketcap);\n', '    }\n', '\n', '    function getMarketData(address token_address) view public returns (uint volume, uint depth, uint marketcap) {\n', '        // we do not throw an exception for non supported tokens, simply return 0,0,0\n', '        if (!supportedTokensMapping[token_address]) {\n', '            return (0,0,0);\n', '        }\n', '\n', '        uint[] memory data = currentTokenMarketData[token_address];\n', '        return (data[0], data[1], data[2]);\n', '    }\n', '\n', '    function addSupportedToken(address token_address) public onlyOwner {\n', '        require(\n', '            isTokenSupported(token_address) == false,\n', '            "Token already added"\n', '        );\n', '\n', '        supportedTokens.push(token_address);\n', '        supportedTokensMapping[token_address] = true;\n', '\n', '        currentTokenMarketData[token_address] = [0,0,0]; // until next update\n', '    }\n', '\n', '    function isTokenSupported(address token_address) view public returns (bool) {\n', '        return supportedTokensMapping[token_address];\n', '    }\n', '\n', '    // update Data\n', '    function updateMarketData(address token_address,\n', '        uint volume,\n', '        uint depth,\n', '        uint marketcap)\n', '    external\n', '    updaterOnly\n', '    supportedTokenOnly(token_address) {\n', '        currentTokenMarketData[token_address] = [volume,depth,marketcap];\n', '    }\n', '}\n', '\n', '// File: contracts/WarOfTokens.sol\n', '\n', 'contract WarOfTokens is Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    struct AttackInfo {\n', '        address attacker;\n', '        address attackee;\n', '        uint attackerScore;\n', '        uint attackeeScore;\n', '        bytes32 attackId;\n', '        bool completed;\n', '        uint hodlSpellBlockNumber;\n', '        mapping (address => uint256) attackerWinnings;\n', '        mapping (address => uint256) attackeeWinnings;\n', '    }\n', '\n', '    // events\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '    event UserActiveStatusChanged(address user, bool isActive);\n', '    event Attack (\n', '        address indexed attacker,\n', '        address indexed attackee,\n', '        bytes32 attackId,\n', '        uint attackPrizePercent,\n', '        uint base,\n', '        uint hodlSpellBlockNumber\n', '    );\n', '    event AttackCompleted (\n', '        bytes32 indexed attackId,\n', '        address indexed winner,\n', '        uint attackeeActualScore\n', '    );\n', '\n', '    // vars\n', '    /**\n', '    *   mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '    */\n', '    mapping (address => mapping (address => uint256)) public tokens;\n', '    mapping (address => bool) public activeUsers;\n', '    address public cdtTokenAddress;\n', '    uint256 public minCDTToParticipate;\n', '    MarketDataStorage public marketDataOracle;\n', '    uint public maxAttackPrizePercent; // if attacker and attackee have the same score, whats the max % of their assets will be as prize\n', "    uint attackPricePrecentBase = 1000; // since EVM doesn't support floating numbers yet.\n", '    uint public maxOpenAttacks = 5;\n', '    mapping (bytes32 => AttackInfo) public attackIdToInfo;\n', '    mapping (address => mapping(address => bytes32)) public userToUserToAttackId;\n', '    mapping (address => uint) public cntUserAttacks; // keeps track of how many un-completed attacks user has\n', '\n', '\n', '    // modifiers\n', '    modifier activeUserOnly(address user) {\n', '        require(\n', '            isActiveUser(user),\n', '            "User not active"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(address _cdtTokenAddress,\n', '        uint256 _minCDTToParticipate,\n', '        address _marketDataOracleAddress,\n', '        uint _maxAttackPrizeRatio)\n', '    Pausable()\n', '    public {\n', '        cdtTokenAddress = _cdtTokenAddress;\n', '        minCDTToParticipate = _minCDTToParticipate;\n', '        marketDataOracle = MarketDataStorage(_marketDataOracleAddress);\n', '        setMaxAttackPrizePercent(_maxAttackPrizeRatio);\n', '    }\n', '\n', "    // don't allow default\n", '    function() public {\n', '        revert("Please do not send ETH without calling the deposit function. We will not do it automatically to validate your intent");\n', '    }\n', '\n', '    // user management\n', '    function isActiveUser(address user) view public returns (bool) {\n', '        return activeUsers[user];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  balances management\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // taken from https://etherscan.io/address/0x8d12a197cb00d4747a1fe03395095ce2a5cc6819#code\n', '    /**\n', '    *   disabled when contract is paused\n', '    */\n', '    function deposit() payable external whenNotPaused {\n', '        tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n', '        emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    /**\n', '    *   disabled when contract is paused\n', '    */\n', '    function depositToken(address token, uint amount) external whenNotPaused {\n', '        //remember to call StandardToken(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n', '        require(\n', '            token!=0,\n', '            "unrecognized token"\n', '        );\n', '        assert(StandardToken(token).transferFrom(msg.sender, this, amount));\n', '        tokens[token][msg.sender] =  tokens[token][msg.sender].add(amount);\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function withdraw(uint amount) external {\n', '        tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n', '        assert(msg.sender.call.value(amount)());\n', '        emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function withdrawToken(address token, uint amount) external {\n', '        require(\n', '            token!=0,\n', '            "unrecognized token"\n', '        );\n', '        tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '        assert(StandardToken(token).transfer(msg.sender, amount));\n', '        emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        _validateUserActive(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address token, address user) view public returns (uint) {\n', '        return tokens[token][user];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  combat functions\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '    function setMaxAttackPrizePercent(uint newAttackPrize) onlyOwner public {\n', '        require(\n', '            newAttackPrize < 5,\n', '            "max prize is 5 percent of funds"\n', '        );\n', '        maxAttackPrizePercent = newAttackPrize;\n', '    }\n', '\n', '    function setMaxOpenAttacks(uint newValue) onlyOwner public {\n', '        maxOpenAttacks = newValue;\n', '    }\n', '\n', '    function openAttacksCount(address user) view public returns (uint) {\n', '        return cntUserAttacks[user];\n', '    }\n', '\n', '    function isTokenSupported(address token_address) view public returns (bool) {\n', '        return marketDataOracle.isTokenSupported(token_address);\n', '    }\n', '\n', '    function getUserScore(address user)\n', '    view\n', '    public\n', '    whenNotPaused\n', '    returns (uint) {\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '        uint aggregated_score = 0;\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, uint volume, uint depth, uint marketcap) = marketDataOracle.getMarketDataByTokenIdx(i);\n', '            uint256 user_balance = balanceOf(token_address, user);\n', '\n', '            aggregated_score = aggregated_score + _calculateScore(user_balance, volume, depth, marketcap);\n', '        }\n', '\n', '        return aggregated_score;\n', '    }\n', '\n', '    function _calculateScore(uint256 balance, uint volume, uint depth, uint marketcap) pure internal returns (uint) {\n', '        return balance * volume * depth * marketcap;\n', '    }\n', '\n', '    function attack(address attackee)\n', '    external\n', '    activeUserOnly(msg.sender)\n', '    activeUserOnly(attackee)\n', '    {\n', '        require(\n', '            msg.sender != attackee,\n', '            "Can\'t attack yourself"\n', '        );\n', '        require(\n', '            userToUserToAttackId[msg.sender][attackee] == 0,\n', '            "Cannot attack while pending attack exists, please complete attack"\n', '        );\n', '        require(\n', '            openAttacksCount(msg.sender) < maxOpenAttacks,\n', '            "Too many open attacks for attacker"\n', '        );\n', '        require(\n', '            openAttacksCount(attackee) < maxOpenAttacks,\n', '            "Too many open attacks for attackee"\n', '        );\n', '\n', '        (uint attackPrizePercent, uint attackerScore, uint attackeeScore) = attackPrizeRatio(attackee);\n', '\n', '        AttackInfo memory attackInfo = AttackInfo(\n', '            msg.sender,\n', '            attackee,\n', '            attackerScore,\n', '            attackeeScore,\n', '            sha256(abi.encodePacked(msg.sender, attackee, block.blockhash(block.number-1))), // attack Id\n', '            false,\n', '            block.number // block after insertion of attack tx the complete function can be called\n', '        );\n', '        _registerAttack(attackInfo);\n', '\n', '        _calculateWinnings(attackIdToInfo[attackInfo.attackId], attackPrizePercent);\n', '\n', '        emit Attack(\n', '            attackInfo.attacker,\n', '            attackInfo.attackee,\n', '            attackInfo.attackId,\n', '            attackPrizePercent,\n', '            attackPricePrecentBase,\n', '            attackInfo.hodlSpellBlockNumber\n', '        );\n', '    }\n', '\n', '    /**\n', '    *   Returns the % of the attacker/ attackee funds are for winning/ loosing\n', '    *   we multiple the values by a base since solidity does not support\n', '    *   floating values.\n', '    */\n', '    function attackPrizeRatio(address attackee)\n', '    view\n', '    public\n', '    returns (uint attackPrizePercent, uint attackerScore, uint attackeeScore) {\n', '        uint _attackerScore = getUserScore(msg.sender);\n', '        require(\n', '            _attackerScore > 0,\n', '            "attacker score is 0"\n', '        );\n', '        uint _attackeeScore = getUserScore(attackee);\n', '        require(\n', '            _attackeeScore > 0,\n', '            "attackee score is 0"\n', '        );\n', '\n', '        uint howCloseAreThey = _attackeeScore.mul(attackPricePrecentBase).div(_attackerScore);\n', '\n', '        return (howCloseAreThey, _attackerScore, _attackeeScore);\n', '    }\n', '\n', '    function attackerPrizeByToken(bytes32 attackId, address token_address) view public returns (uint256) {\n', '        return attackIdToInfo[attackId].attackerWinnings[token_address];\n', '    }\n', '\n', '    function attackeePrizeByToken(bytes32 attackId, address token_address) view public returns (uint256) {\n', '        return attackIdToInfo[attackId].attackeeWinnings[token_address];\n', '    }\n', '\n', '    // anyone can call the complete attack function.\n', '    function completeAttack(bytes32 attackId) public {\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        (address winner, uint attackeeActualScore) = getWinner(attackId);\n', '\n', '        // distribuite winngs\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, bool status) = marketDataOracle.getSupportedTokenByIndex(i);\n', '\n', '            if (attackInfo.attacker == winner) {\n', '                uint winnings = attackInfo.attackerWinnings[token_address];\n', '\n', '                if (winnings > 0) {\n', '                    tokens[token_address][attackInfo.attackee] = tokens[token_address][attackInfo.attackee].sub(winnings);\n', '                    tokens[token_address][attackInfo.attacker] = tokens[token_address][attackInfo.attacker].add(winnings);\n', '                }\n', '            }\n', '            else {\n', '                uint loosings = attackInfo.attackeeWinnings[token_address];\n', '\n', '                if (loosings > 0) {\n', '                    tokens[token_address][attackInfo.attacker] = tokens[token_address][attackInfo.attacker].sub(loosings);\n', '                    tokens[token_address][attackInfo.attackee] = tokens[token_address][attackInfo.attackee].add(loosings);\n', '                }\n', '            }\n', '        }\n', '\n', '        // cleanup\n', '        _unregisterAttack(attackId);\n', '\n', '        emit AttackCompleted(\n', '            attackId,\n', '            winner,\n', '            attackeeActualScore\n', '        );\n', '    }\n', '\n', '    function getWinner(bytes32 attackId) public view returns(address winner, uint attackeeActualScore) {\n', '        require(\n', '            block.number >= attackInfo.hodlSpellBlockNumber,\n', '            "attack can not be completed at this block, please wait"\n', '        );\n', '\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        //  block.blockhash records only for the recent 256 blocks\n', '        //  https://solidity.readthedocs.io/en/v0.3.1/units-and-global-variables.html#block-and-transaction-properties\n', '        //  So... attacker has 256 blocks to call completeAttack\n', '        //  otherwise win goes automatically to the attackee\n', '        if (block.number - attackInfo.hodlSpellBlockNumber >= 256) {\n', '            return (attackInfo.attackee, attackInfo.attackeeScore);\n', '        }\n', '\n', '        bytes32 blockHash = block.blockhash(attackInfo.hodlSpellBlockNumber);\n', '        return _calculateWinnerBasedOnEntropy(attackInfo, blockHash);\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////\n', '    //\n', '    //  internal functions\n', '    //\n', '    ////////////////////////////////////////////////////////\n', '\n', '    // validates user active status\n', '    function _validateUserActive(address user) private {\n', '        // get CDT balance\n', '        uint256 cdt_balance = balanceOf(cdtTokenAddress, user);\n', '\n', '        bool new_active_state = cdt_balance >= minCDTToParticipate;\n', '        bool current_active_state = activeUsers[user]; // could be false if never set up\n', '\n', '        if (current_active_state != new_active_state) { // only emit on activity change\n', '            emit UserActiveStatusChanged(user, new_active_state);\n', '        }\n', '\n', '        activeUsers[user] = new_active_state;\n', '    }\n', '\n', '    function _registerAttack(AttackInfo attackInfo) internal {\n', '        userToUserToAttackId[attackInfo.attacker][attackInfo.attackee] = attackInfo.attackId;\n', '        userToUserToAttackId[attackInfo.attackee][attackInfo.attacker] = attackInfo.attackId;\n', '\n', '        attackIdToInfo[attackInfo.attackId] = attackInfo;\n', '\n', '        // update open attacks counter\n', '        cntUserAttacks[attackInfo.attacker] = cntUserAttacks[attackInfo.attacker].add(1);\n', '        cntUserAttacks[attackInfo.attackee] = cntUserAttacks[attackInfo.attackee].add(1);\n', '    }\n', '\n', '    function _unregisterAttack(bytes32 attackId) internal {\n', '        AttackInfo storage attackInfo = attackIdToInfo[attackId];\n', '\n', '        cntUserAttacks[attackInfo.attacker] = cntUserAttacks[attackInfo.attacker].sub(1);\n', '        cntUserAttacks[attackInfo.attackee] = cntUserAttacks[attackInfo.attackee].sub(1);\n', '\n', '        delete userToUserToAttackId[attackInfo.attacker][attackInfo.attackee];\n', '        delete userToUserToAttackId[attackInfo.attackee][attackInfo.attacker];\n', '\n', '        delete attackIdToInfo[attackId];\n', '    }\n', '\n', '    /**\n', '       if the attacker has a higher/ equal score to the attackee than the prize will be at max maxAttackPrizePercent\n', '       if the attacker has lower score than the prize can be higher than maxAttackPrizePercent since he takes a bigger risk\n', '   */\n', '    function _calculateWinnings(AttackInfo storage attackInfo, uint attackPrizePercent) internal {\n', '        // get all user balances and calc winnings from that\n', '        uint cnt_supported_tokens = marketDataOracle.numberOfSupportedTokens();\n', '\n', '        uint actualPrizeRation = attackPrizePercent\n', '        .mul(maxAttackPrizePercent);\n', '\n', '\n', '        for (uint i=0; i<cnt_supported_tokens; i++) {\n', '            (address token_address, bool status) = marketDataOracle.getSupportedTokenByIndex(i);\n', '\n', '            if (status) {\n', '                // attacker\n', '                uint256 _b1 = balanceOf(token_address, attackInfo.attacker);\n', '                if (_b1 > 0) {\n', '                    uint256 _w1 = _b1.mul(actualPrizeRation).div(attackPricePrecentBase * 100); // 100 since maxAttackPrizePercent has 100 basis\n', '                    attackInfo.attackeeWinnings[token_address] = _w1;\n', '                }\n', '\n', '                // attackee\n', '                uint256 _b2 = balanceOf(token_address, attackInfo.attackee);\n', '                if (_b2 > 0) {\n', '                    uint256 _w2 = _b2.mul(actualPrizeRation).div(attackPricePrecentBase * 100); // 100 since maxAttackPrizePercent has 100 basis\n', '                    attackInfo.attackerWinnings[token_address] = _w2;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    //\n', '    // winner logic:\n', '    //  1) get difference in scores between players times 2\n', '    //  2) get hodl spell block number (decided in the attack call), do hash % {result of step 1}\n', '    //  3) block hash mod 10 to decide direction\n', "    //  4) if result step 3 > 1 than we add result step 2 to attackee's score (80% chance for this to happen)\n", "    //  5) else reduce attacke's score by result of step 2\n", '    //\n', '    //\n', '    //\n', '    // Since the attacker decides if to attack or not we give the attackee a defending chance by\n', '    // adopting the random HODL spell.\n', '    // if the attacker has a higher score than attackee than the HODL spell will randomly add (most probably) to the\n', '    // attackee score. this might or might not be enought to beat the attacker.\n', '    //\n', '    // if the attacker has a lower score than the attackee than he takes a bigger chance in attacking and he will get a bigger reward.\n', '    //\n', '    //\n', '    // just like in crypto life, HODLing has its risks and rewards. Be carefull in your trading decisions!\n', '    function _calculateWinnerBasedOnEntropy(AttackInfo storage attackInfo, bytes32 entropy) view internal returns(address, uint) {\n', '        uint attackeeActualScore = attackInfo.attackeeScore;\n', '        uint modul = _absSubtraction(attackInfo.attackerScore, attackInfo.attackeeScore);\n', '        modul = modul.mul(2); // attacker score is now right in the middle of the range\n', '        uint hodlSpell = uint(entropy) % modul;\n', '        uint direction = uint(entropy) % 10;\n', '        uint directionThreshold = 1;\n', '\n', '        // direction is 80% chance positive (meaning adding the hodl spell)\n', '        // to the weakest player\n', '        if (attackInfo.attackerScore < attackInfo.attackeeScore) {\n', '            directionThreshold = 8;\n', '        }\n', '\n', '        // winner calculation\n', '        if (direction > directionThreshold) {\n', '            attackeeActualScore = attackeeActualScore.add(hodlSpell);\n', '        }\n', '        else {\n', '            attackeeActualScore = _safeSubtract(attackeeActualScore, hodlSpell);\n', '        }\n', '        if (attackInfo.attackerScore > attackeeActualScore) { return (attackInfo.attacker, attackeeActualScore); }\n', '        else { return (attackInfo.attackee, attackeeActualScore); }\n', '    }\n', '\n', '    // will subtract 2 uint and returns abs(result).\n', '    // example: a=2,b=3 returns 1\n', '    // example: a=3,b=2 returns 1\n', '    function _absSubtraction(uint a, uint b) pure internal returns (uint) {\n', '        if (b>a) {\n', '            return b-a;\n', '        }\n', '\n', '        return a-b;\n', '    }\n', '\n', '    // example: a=2,b=3 returns 0\n', '    // example: a=3,b=2 returns 1\n', '    function _safeSubtract(uint a, uint b) pure internal returns (uint) {\n', '        if (b > a) {\n', '            return 0;\n', '        }\n', '\n', '        return a-b;\n', '    }\n', '}']
