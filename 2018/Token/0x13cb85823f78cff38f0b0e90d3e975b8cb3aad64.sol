['pragma solidity 0.4.24;\n', '\n', '// File: contracts/Lockable.sol\n', '\n', '/**\n', ' * @title Lockable Token\n', ' * @author info@remiit.io\n', ' */\n', 'contract Lockable {\n', '    bool public tokenTransfer;\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev They can transfer even if tokenTranser flag is false.\n', '     */\n', '    mapping(address => bool) public unlockAddress;\n', '\n', '    /**\n', '     * @dev They cannot transfer even if tokenTransfer flag is true.\n', '     */\n', '    mapping(address => bool) public lockAddress;\n', '\n', '    event Locked(address lockAddress, bool status);\n', '    event Unlocked(address unlockedAddress, bool status);\n', '\n', '    /**\n', '     * @dev check whether can tranfer tokens or not.\n', '     */\n', '    modifier isTokenTransfer {\n', '        if(!tokenTransfer) {\n', '            require(unlockAddress[msg.sender]);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev check whether registered in lockAddress or not\n', '     */\n', '    modifier checkLock {\n', '        require(!lockAddress[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier isOwner\n', '    {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    constructor()\n', '    public\n', '    {\n', '        tokenTransfer = false;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev add or remove in lockAddress(blacklist)\n', '     */\n', '    function setLockAddress(address target, bool status)\n', '    external\n', '    isOwner\n', '    {\n', '        require(owner != target);\n', '        lockAddress[target] = status;\n', '        emit Locked(target, status);\n', '    }\n', '\n', '    /**\n', '     * @dev add or remove in unlockAddress(whitelist)\n', '     */\n', '    function setUnlockAddress(address target, bool status)\n', '    external\n', '    isOwner\n', '    {\n', '        unlockAddress[target] = status;\n', '        emit Unlocked(target, status);\n', '    }\n', '}\n', '\n', '// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/RemiTokenRopsten.sol\n', '\n', '// import "./ERC20.sol";\n', '\n', '// import "../util/SafeMath.sol";\n', '\n', '// import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol";\n', '\n', '\n', '/**\n', ' * @title REMI Token Contract.\n', ' * @author info@remiit.io\n', ' * @notice This contract is the updated version that fixes the unlocking bug.\n', ' * This source code is audited by external auditors.\n', ' */\n', '\n', '\n', '// contract RemiTokenRopsten is ERC20, Lockable {\n', '// contract RemiTokenRopsten is MintableToken, Lockable {\n', 'contract RemiToken is ERC20, Lockable {\n', '\n', '    string public constant name = "REMI Token";\n', '    string public constant symbol = "REMI";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /**\n', '     * @dev If this flag is true, admin can use enableTokenTranfer(), emergencyTransfer().\n', '     */\n', '    bool public adminMode;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) internal _balances;\n', '    mapping(address => mapping(address => uint256)) internal _approvals;\n', '    uint256 internal _supply;\n', '\n', '    event TokenBurned(address burnAddress, uint256 amountOfTokens);\n', '    event SetTokenTransfer(bool transfer);\n', '    event SetAdminMode(bool adminMode);\n', '    event EmergencyTransfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    modifier isAdminMode {\n', '        require(adminMode);\n', '        _;\n', '    }\n', '\n', '    constructor(uint256 initial_balance)\n', '    public\n', '    {\n', '        require(initial_balance != 0);\n', '        _supply = initial_balance;\n', '        _balances[msg.sender] = initial_balance;\n', '        emit Transfer(address(0), msg.sender, initial_balance);\n', '    }\n', '\n', '    function totalSupply()\n', '    public\n', '    view\n', '    returns (uint256) {\n', '        return _supply;\n', '    }\n', '\n', '    function balanceOf(address who)\n', '    public\n', '    view\n', '    returns (uint256) {\n', '        return _balances[who];\n', '    }\n', '\n', '    function transfer(address to, uint256 value)\n', '    public\n', '    isTokenTransfer\n', '    checkLock\n', '    returns (bool) {\n', '        require(to != address(0));\n', '        require(_balances[msg.sender] >= value);\n', '\n', '        _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender)\n', '    public\n', '    view\n', '    returns (uint256) {\n', '        return _approvals[owner][spender];\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '    public\n', '    isTokenTransfer\n', '    checkLock\n', '    returns (bool success) {\n', '        require(!lockAddress[from]);\n', '        require(_balances[from] >= value);\n', '        require(_approvals[from][msg.sender] >= value);\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        _approvals[from][msg.sender] = _approvals[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value)\n', '    public\n', '    checkLock\n', '    returns (bool) {\n', '        _approvals[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint256 _addedValue)\n', '    public\n', '    checkLock\n', '    returns (bool) {\n', '        _approvals[msg.sender][_spender] = (\n', '        _approvals[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, _approvals[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    public\n', '    checkLock\n', '    returns (bool) {\n', '        uint256 oldValue = _approvals[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            _approvals[msg.sender][_spender] = 0;\n', '        } else {\n', '            _approvals[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, _approvals[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Burn tokens can only use by owner\n', '     */\n', '    function burnTokens(uint256 tokensAmount)\n', '    public\n', '    isAdminMode\n', '    isOwner\n', '    {\n', '        require(_balances[msg.sender] >= tokensAmount);\n', '\n', '        _balances[msg.sender] = _balances[msg.sender].sub(tokensAmount);\n', '        _supply = _supply.sub(tokensAmount);\n', '        emit TokenBurned(msg.sender, tokensAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the tokenTransfer flag.\n', '     * If true, \n', '     * - unregistered lockAddress can transfer()\n', '     * - registered lockAddress can not transfer()\n', '     * If false, \n', '     * - registered unlockAddress & unregistered lockAddress \n', '     * - can transfer(), unregistered unlockAddress can not transfer()\n', '     */\n', '    function setTokenTransfer(bool _tokenTransfer)\n', '    external\n', '    isAdminMode\n', '    isOwner\n', '    {\n', '        tokenTransfer = _tokenTransfer;\n', '        emit SetTokenTransfer(tokenTransfer);\n', '    }\n', '\n', '    function setAdminMode(bool _adminMode)\n', '    public\n', '    isOwner\n', '    {\n', '        adminMode = _adminMode;\n', '        emit SetAdminMode(adminMode);\n', '    }\n', '\n', '    /**\n', '     * @dev In emergency situation, \n', "     * admin can use emergencyTransfer() for protecting user's token.\n", '     */\n', '    function emergencyTransfer(address emergencyAddress)\n', '    public\n', '    isAdminMode\n', '    isOwner\n', '    returns (bool success) {\n', '        require(emergencyAddress != owner);\n', '        _balances[owner] = _balances[owner].add(_balances[emergencyAddress]);\n', '\n', '        emit Transfer(emergencyAddress, owner, _balances[emergencyAddress]);\n', '        emit EmergencyTransfer(emergencyAddress, owner, _balances[emergencyAddress]);\n', '    \n', '        _balances[emergencyAddress] = 0;\n', '        return true;\n', '    }\n', '}']