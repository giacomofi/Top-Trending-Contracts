['pragma solidity ^0.4.21;\n', '\n', '    /**\n', '    * Math operations with safety checks\n', '    */\n', '    library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '    }\n', '\n', '\n', '    contract Owned {\n', '\n', '        /// @dev `owner` is the only address that can call a function with this\n', '        /// modifier\n', '        modifier onlyOwner() {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '\n', '        address public owner;\n', '        /// @notice The Constructor assigns the message sender to be `owner`\n', '        function Owned() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        address public newOwner;\n', '\n', '        /// @notice `owner` can step down and assign some other address to this role\n', '        /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '        ///  an unowned neutral vault, however that cannot be undone\n', '        function changeOwner(address _newOwner) onlyOwner public {\n', '            newOwner = _newOwner;\n', '        }\n', '\n', '\n', '        function acceptOwnership() public {\n', '            if (msg.sender == newOwner) {\n', '                owner = newOwner;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    contract ERC20Protocol {\n', '        /* This is a slight change to the ERC20 base standard.\n', '        function totalSupply() constant returns (uint supply);\n', '        is replaced with:\n', '        uint public totalSupply;\n', '        This automatically creates a getter function for the totalSupply.\n', '        This is moved to the base contract since public getter functions are not\n', '        currently recognised as an implementation of the matching abstract\n', '        function by the compiler.\n', '        */\n', '        /// total amount of tokens\n', '        uint public totalSupply;\n', '\n', '        /// @param _owner The address from which the balance will be retrieved\n', '        /// @return The balance\n', '        function balanceOf(address _owner) constant public returns (uint balance);\n', '\n', '        /// @notice send `_value` token to `_to` from `msg.sender`\n', '        /// @param _to The address of the recipient\n', '        /// @param _value The amount of token to be transferred\n', '        /// @return Whether the transfer was successful or not\n', '        function transfer(address _to, uint _value) public returns (bool success);\n', '\n', '        /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '        /// @param _from The address of the sender\n', '        /// @param _to The address of the recipient\n', '        /// @param _value The amount of token to be transferred\n', '        /// @return Whether the transfer was successful or not\n', '        function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\n', '        /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '        /// @param _spender The address of the account able to transfer the tokens\n', '        /// @param _value The amount of tokens to be approved for transfer\n', '        /// @return Whether the approval was successful or not\n', '        function approve(address _spender, uint _value) public returns (bool success);\n', '\n', '        /// @param _owner The address of the account owning tokens\n', '        /// @param _spender The address of the account able to transfer the tokens\n', '        /// @return Amount of remaining tokens allowed to spent\n', '        function allowance(address _owner, address _spender) constant public returns (uint remaining);\n', '\n', '        event Transfer(address indexed _from, address indexed _to, uint _value);\n', '        event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    }\n', '\n', '    contract StandardToken is ERC20Protocol {\n', '        using SafeMath for uint;\n', '\n', '        /**\n', '        * @dev Fix for the ERC20 short address attack.\n', '        */\n', '        modifier onlyPayloadSize(uint size) {\n', '            require(msg.data.length >= size + 4);\n', '            _;\n', '        }\n', '\n', '        function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '            //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '            //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '            //Replace the if with this one instead.\n', '            //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            if (balances[msg.sender] >= _value) {\n', '                balances[msg.sender] -= _value;\n', '                balances[_to] += _value;\n', '                emit Transfer(msg.sender, _to, _value);\n', '                return true;\n', '            } else { return false; }\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '            //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '            //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '                balances[_to] += _value;\n', '                balances[_from] -= _value;\n', '                allowed[_from][msg.sender] -= _value;\n', '                emit Transfer(_from, _to, _value);\n', '                return true;\n', '            } else { return false; }\n', '        }\n', '\n', '        function balanceOf(address _owner) constant public returns (uint balance) {\n', '            return balances[_owner];\n', '        }\n', '\n', '        function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '            // To change the approve amount you first have to reduce the addresses`\n', '            //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '            //  already 0 to mitigate the race condition described here:\n', '            //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '            assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '        }\n', '\n', '        mapping (address => uint) balances;\n', '        mapping (address => mapping (address => uint)) allowed;\n', '    }\n', '\n', '    contract OriginsTraceChainToken is StandardToken {\n', '        /// Constant token specific fields\n', '        string public constant name = "OriginsTraceChain";\n', '        string public constant symbol = "OTC";\n', '        uint public constant decimals = 18;\n', '\n', '        /// OriginsTraceChain total tokens supply\n', '        uint public constant MAX_TOTAL_TOKEN_AMOUNT = 300000000 ether;\n', '\n', '        /// Fields that are only changed in constructor\n', '        /// OriginsTraceChain contribution contract\n', '        address public minter;\n', '\n', '        /*\n', '        * MODIFIERS\n', '        */\n', '\n', '        modifier onlyMinter {\n', '            assert(msg.sender == minter);\n', '            _;\n', '        }\n', '\n', '        modifier maxTokenAmountNotReached (uint amount){\n', '            assert(totalSupply.add(amount) <= MAX_TOTAL_TOKEN_AMOUNT);\n', '            _;\n', '        }\n', '\n', '        /**\n', '        * CONSTRUCTOR\n', '        *\n', '        * @dev Initialize the OriginsTraceChain Token\n', '        * @param _minter The OriginsTraceChain Crowd Funding Contract\n', '        */\n', '        function OriginsTraceChainToken(address _minter) public {\n', '            minter = _minter;\n', '        }\n', '\n', '\n', '        /**\n', '        * EXTERNAL FUNCTION\n', '        *\n', '        * @dev Contribution contract instance mint token\n', '        * @param recipient The destination account owned mint tokens\n', '        * be sent to this address.\n', '        */\n', '        function mintToken(address recipient, uint _amount)\n', '            public\n', '            onlyMinter\n', '            maxTokenAmountNotReached(_amount)\n', '            returns (bool)\n', '        {\n', '            totalSupply = totalSupply.add(_amount);\n', '            balances[recipient] = balances[recipient].add(_amount);\n', '            return true;\n', '        }\n', '    }']
['pragma solidity ^0.4.21;\n', '\n', '    /**\n', '    * Math operations with safety checks\n', '    */\n', '    library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '    }\n', '\n', '\n', '    contract Owned {\n', '\n', '        /// @dev `owner` is the only address that can call a function with this\n', '        /// modifier\n', '        modifier onlyOwner() {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '\n', '        address public owner;\n', '        /// @notice The Constructor assigns the message sender to be `owner`\n', '        function Owned() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        address public newOwner;\n', '\n', '        /// @notice `owner` can step down and assign some other address to this role\n', '        /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '        ///  an unowned neutral vault, however that cannot be undone\n', '        function changeOwner(address _newOwner) onlyOwner public {\n', '            newOwner = _newOwner;\n', '        }\n', '\n', '\n', '        function acceptOwnership() public {\n', '            if (msg.sender == newOwner) {\n', '                owner = newOwner;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    contract ERC20Protocol {\n', '        /* This is a slight change to the ERC20 base standard.\n', '        function totalSupply() constant returns (uint supply);\n', '        is replaced with:\n', '        uint public totalSupply;\n', '        This automatically creates a getter function for the totalSupply.\n', '        This is moved to the base contract since public getter functions are not\n', '        currently recognised as an implementation of the matching abstract\n', '        function by the compiler.\n', '        */\n', '        /// total amount of tokens\n', '        uint public totalSupply;\n', '\n', '        /// @param _owner The address from which the balance will be retrieved\n', '        /// @return The balance\n', '        function balanceOf(address _owner) constant public returns (uint balance);\n', '\n', '        /// @notice send `_value` token to `_to` from `msg.sender`\n', '        /// @param _to The address of the recipient\n', '        /// @param _value The amount of token to be transferred\n', '        /// @return Whether the transfer was successful or not\n', '        function transfer(address _to, uint _value) public returns (bool success);\n', '\n', '        /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '        /// @param _from The address of the sender\n', '        /// @param _to The address of the recipient\n', '        /// @param _value The amount of token to be transferred\n', '        /// @return Whether the transfer was successful or not\n', '        function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\n', '        /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '        /// @param _spender The address of the account able to transfer the tokens\n', '        /// @param _value The amount of tokens to be approved for transfer\n', '        /// @return Whether the approval was successful or not\n', '        function approve(address _spender, uint _value) public returns (bool success);\n', '\n', '        /// @param _owner The address of the account owning tokens\n', '        /// @param _spender The address of the account able to transfer the tokens\n', '        /// @return Amount of remaining tokens allowed to spent\n', '        function allowance(address _owner, address _spender) constant public returns (uint remaining);\n', '\n', '        event Transfer(address indexed _from, address indexed _to, uint _value);\n', '        event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    }\n', '\n', '    contract StandardToken is ERC20Protocol {\n', '        using SafeMath for uint;\n', '\n', '        /**\n', '        * @dev Fix for the ERC20 short address attack.\n', '        */\n', '        modifier onlyPayloadSize(uint size) {\n', '            require(msg.data.length >= size + 4);\n', '            _;\n', '        }\n', '\n', '        function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', "            //Default assumes totalSupply can't be over max (2^256 - 1).\n", "            //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '            //Replace the if with this one instead.\n', '            //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            if (balances[msg.sender] >= _value) {\n', '                balances[msg.sender] -= _value;\n', '                balances[_to] += _value;\n', '                emit Transfer(msg.sender, _to, _value);\n', '                return true;\n', '            } else { return false; }\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '            //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '            //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '                balances[_to] += _value;\n', '                balances[_from] -= _value;\n', '                allowed[_from][msg.sender] -= _value;\n', '                emit Transfer(_from, _to, _value);\n', '                return true;\n', '            } else { return false; }\n', '        }\n', '\n', '        function balanceOf(address _owner) constant public returns (uint balance) {\n', '            return balances[_owner];\n', '        }\n', '\n', '        function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '            // To change the approve amount you first have to reduce the addresses`\n', '            //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '            //  already 0 to mitigate the race condition described here:\n', '            //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '            assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '        }\n', '\n', '        mapping (address => uint) balances;\n', '        mapping (address => mapping (address => uint)) allowed;\n', '    }\n', '\n', '    contract OriginsTraceChainToken is StandardToken {\n', '        /// Constant token specific fields\n', '        string public constant name = "OriginsTraceChain";\n', '        string public constant symbol = "OTC";\n', '        uint public constant decimals = 18;\n', '\n', '        /// OriginsTraceChain total tokens supply\n', '        uint public constant MAX_TOTAL_TOKEN_AMOUNT = 300000000 ether;\n', '\n', '        /// Fields that are only changed in constructor\n', '        /// OriginsTraceChain contribution contract\n', '        address public minter;\n', '\n', '        /*\n', '        * MODIFIERS\n', '        */\n', '\n', '        modifier onlyMinter {\n', '            assert(msg.sender == minter);\n', '            _;\n', '        }\n', '\n', '        modifier maxTokenAmountNotReached (uint amount){\n', '            assert(totalSupply.add(amount) <= MAX_TOTAL_TOKEN_AMOUNT);\n', '            _;\n', '        }\n', '\n', '        /**\n', '        * CONSTRUCTOR\n', '        *\n', '        * @dev Initialize the OriginsTraceChain Token\n', '        * @param _minter The OriginsTraceChain Crowd Funding Contract\n', '        */\n', '        function OriginsTraceChainToken(address _minter) public {\n', '            minter = _minter;\n', '        }\n', '\n', '\n', '        /**\n', '        * EXTERNAL FUNCTION\n', '        *\n', '        * @dev Contribution contract instance mint token\n', '        * @param recipient The destination account owned mint tokens\n', '        * be sent to this address.\n', '        */\n', '        function mintToken(address recipient, uint _amount)\n', '            public\n', '            onlyMinter\n', '            maxTokenAmountNotReached(_amount)\n', '            returns (bool)\n', '        {\n', '            totalSupply = totalSupply.add(_amount);\n', '            balances[recipient] = balances[recipient].add(_amount);\n', '            return true;\n', '        }\n', '    }']
