['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn’t hold\n', '    return c;\n', '  }\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(\n', '    ERC20Basic _token,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '\n', '  function safeApprove(\n', '    ERC20 _token,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.approve(_spender, _value));\n', '  }\n', '}\n', '/*****************************************************************\n', ' * Core contract of the Million Dollar Decentralized Application *\n', ' *****************************************************************/\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6b4a3aba5a986f4">[email&#160;protected]</a>π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this Ether.\n', ' * @notice Ether can still be sent to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', ' */\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  constructor() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by setting a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param _token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic _token) external onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    _token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    public\n', '    hasMintPermission\n', '    canMint\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() public onlyOwner canMint returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MDAPPToken\n', ' * @dev Token for the Million Dollar Decentralized Application (MDAPP).\n', ' * Once a holder uses it to claim pixels the appropriate tokens are burned (1 Token <=> 10x10 pixel).\n', ' * If one releases his pixels new tokens are generated and credited to ones balance. Therefore, supply will\n', ' * vary between 0 and 10,000 tokens.\n', ' * Tokens are transferable once minting has finished.\n', ' * @dev Owned by MDAPP.sol\n', ' */\n', 'contract MDAPPToken is MintableToken {\n', '  using SafeMath16 for uint16;\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "MillionDollarDapp";\n', '  string public constant symbol = "MDAPP";\n', '  uint8 public constant decimals = 0;\n', '\n', '  mapping (address => uint16) locked;\n', '\n', '  bool public forceTransferEnable = false;\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Events                          *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Emitted when owner force-allows transfers of tokens.\n', '  event AllowTransfer();\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                      Modifiers                        *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  modifier hasLocked(address _account, uint16 _value) {\n', '    require(_value <= locked[_account], "Not enough locked tokens available.");\n', '    _;\n', '  }\n', '\n', '  modifier hasUnlocked(address _account, uint16 _value) {\n', '    require(balanceOf(_account).sub(uint256(locked[_account])) >= _value, "Not enough unlocked tokens available.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether it can transfer or otherwise throws.\n', '   */\n', '  modifier canTransfer(address _sender, uint256 _value) {\n', '    require(_value <= transferableTokensOf(_sender), "Not enough unlocked tokens available.");\n', '    _;\n', '  }\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                Limited Transfer Logic                 *\n', '   *            Taken from openzeppelin 1.3.0              *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  function lockToken(address _account, uint16 _value) onlyOwner hasUnlocked(_account, _value) public {\n', '    locked[_account] = locked[_account].add(_value);\n', '  }\n', '\n', '  function unlockToken(address _account, uint16 _value) onlyOwner hasLocked(_account, _value) public {\n', '    locked[_account] = locked[_account].sub(_value);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks modifier and allows transfer if tokens are not locked.\n', '   * @param _to The address that will receive the tokens.\n', '   * @param _value The amount of tokens to be transferred.\n', '   */\n', '  function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Checks modifier and allows transfer if tokens are not locked.\n', '  * @param _from The address that will send the tokens.\n', '  * @param _to The address that will receive the tokens.\n', '  * @param _value The amount of tokens to be transferred.\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Allow the holder to transfer his tokens only if every token in\n', '   * existence has already been distributed / minting is finished.\n', '   * Tokens which are locked for a claimed space cannot be transferred.\n', '   */\n', '  function transferableTokensOf(address _holder) public view returns (uint16) {\n', '    if (!mintingFinished && !forceTransferEnable) return 0;\n', '\n', '    return uint16(balanceOf(_holder)).sub(locked[_holder]);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the number of pixel-locked tokens.\n', '   */\n', '  function lockedTokensOf(address _holder) public view returns (uint16) {\n', '    return locked[_holder];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the number of unlocked tokens usable for claiming pixels.\n', '   */\n', '  function unlockedTokensOf(address _holder) public view returns (uint256) {\n', '    return balanceOf(_holder).sub(uint256(locked[_holder]));\n', '  }\n', '\n', '  // Allow transfer of tokens even if minting is not yet finished.\n', '  function allowTransfer() onlyOwner public {\n', '    require(forceTransferEnable == false, &#39;Transfer already force-allowed.&#39;);\n', '\n', '    forceTransferEnable = true;\n', '    emit AllowTransfer();\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MDAPP\n', ' */\n', 'contract MDAPP is Ownable, HasNoEther, CanReclaimToken {\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '\n', '  // The tokens contract.\n', '  MDAPPToken public token;\n', '\n', '  // The sales contracts address. Only it is allowed to to call the public mint function.\n', '  address public sale;\n', '\n', '  // When are presale participants allowed to place ads?\n', '  uint256 public presaleAdStart;\n', '\n', '  // When are all token owners allowed to place ads?\n', '  uint256 public allAdStart;\n', '\n', '  // Quantity of tokens bought during presale.\n', '  mapping (address => uint16) presales;\n', '\n', '  // Indicates whether a 10x10px block is claimed or not.\n', '  bool[80][125] grid;\n', '\n', '  // Struct that represents an ad.\n', '  struct Ad {\n', '    address owner;\n', '    Rect rect;\n', '  }\n', '\n', '  // Struct describing an rectangle area.\n', '  struct Rect {\n', '    uint16 x;\n', '    uint16 y;\n', '    uint16 width;\n', '    uint16 height;\n', '  }\n', '\n', '  // Don&#39;t store ad details on blockchain. Use events as storage as they are significantly cheaper.\n', '  // ads are stored in an array, the id of an ad is its index in this array.\n', '  Ad[] ads;\n', '\n', '  // The following holds a list of currently active ads (without holes between the indexes)\n', '  uint256[] adIds;\n', '\n', '  // Holds the mapping from adID to its index in the above adIds array. If an ad gets released, we know which index to\n', '  // delete and being filled with the last element instead.\n', '  mapping (uint256 => uint256) adIdToIndex;\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Events                          *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  /*\n', '   * Event for claiming pixel blocks.\n', '   * @param id ID of the new ad\n', '   * @param owner Who owns the used tokens\n', '   * @param x Upper left corner x coordinate\n', '   * @param y Upper left corner y coordinate\n', '   * @param width Width of the claimed area\n', '   * @param height Height of the claimed area\n', '   */\n', '  event Claim(uint256 indexed id, address indexed owner, uint16 x, uint16 y, uint16 width, uint16 height);\n', '\n', '  /*\n', '   * Event for releasing pixel blocks.\n', '   * @param id ID the fading ad\n', '   * @param owner Who owns the claimed blocks\n', '   */\n', '  event Release(uint256 indexed id, address indexed owner);\n', '\n', '  /*\n', '   * Event for editing an ad.\n', '   * @param id ID of the ad\n', '   * @param owner Who owns the ad\n', '   * @param link A link\n', '   * @param title Title of the ad\n', '   * @param text Description of the ad\n', '   * @param NSFW Whether the ad is safe for work\n', '   * @param digest IPFS hash digest\n', '   * @param hashFunction IPFS hash function\n', '   * @param size IPFS length of digest\n', '   * @param storageEngine e.g. ipfs or swrm (swarm)\n', '   */\n', '  event EditAd(uint256 indexed id, address indexed owner, string link, string title, string text, string contact, bool NSFW, bytes32 indexed digest, bytes2 hashFunction, uint8 size, bytes4 storageEngine);\n', '\n', '  event ForceNSFW(uint256 indexed id);\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                      Modifiers                        *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  modifier coordsValid(uint16 _x, uint16 _y, uint16 _width, uint16 _height) {\n', '    require((_x + _width - 1) < 125, "Invalid coordinates.");\n', '    require((_y + _height - 1) < 80, "Invalid coordinates.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdOwner(uint256 _id) {\n', '    require(ads[_id].owner == msg.sender, "Access denied.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier enoughTokens(uint16 _width, uint16 _height) {\n', '    require(uint16(token.unlockedTokensOf(msg.sender)) >= _width.mul(_height), "Not enough unlocked tokens available.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier claimAllowed(uint16 _width, uint16 _height) {\n', '    require(_width > 0 &&_width <= 125 && _height > 0 && _height <= 80, "Invalid dimensions.");\n', '    require(now >= presaleAdStart, "Claim period not yet started.");\n', '\n', '    if (now < allAdStart) {\n', '      // Sender needs enough presale tokens to claim at this point.\n', '      uint16 tokens = _width.mul(_height);\n', '      require(presales[msg.sender] >= tokens, "Not enough unlocked presale tokens available.");\n', '\n', '      presales[msg.sender] = presales[msg.sender].sub(tokens);\n', '    }\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlySale() {\n', '    require(msg.sender == sale);\n', '    _;\n', '  }\n', '\n', '  modifier adExists(uint256 _id) {\n', '    uint256 index = adIdToIndex[_id];\n', '    require(adIds[index] == _id, "Ad does not exist.");\n', '\n', '    _;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                   Initialization                      *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  constructor(uint256 _presaleAdStart, uint256 _allAdStart, address _token) public {\n', '    require(_presaleAdStart >= now);\n', '    require(_allAdStart > _presaleAdStart);\n', '\n', '    presaleAdStart = _presaleAdStart;\n', '    allAdStart = _allAdStart;\n', '    token = MDAPPToken(_token);\n', '  }\n', '\n', '  function setMDAPPSale(address _mdappSale) onlyOwner external {\n', '    require(sale == address(0));\n', '    sale = _mdappSale;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Logic                           *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Proxy function to pass minting from sale contract to token contract.\n', '  function mint(address _beneficiary, uint256 _tokenAmount, bool isPresale) onlySale external {\n', '    if (isPresale) {\n', '      presales[_beneficiary] = presales[_beneficiary].add(uint16(_tokenAmount));\n', '    }\n', '    token.mint(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  // Proxy function to pass finishMinting() from sale contract to token contract.\n', '  function finishMinting() onlySale external {\n', '    token.finishMinting();\n', '  }\n', '\n', '\n', '  // Public function proxy to forward single parameters as a struct.\n', '  function claim(uint16 _x, uint16 _y, uint16 _width, uint16 _height)\n', '    claimAllowed(_width, _height)\n', '    coordsValid(_x, _y, _width, _height)\n', '    external returns (uint)\n', '  {\n', '    Rect memory rect = Rect(_x, _y, _width, _height);\n', '    return claimShortParams(rect);\n', '  }\n', '\n', '  // Claims pixels and requires to have the sender enough unlocked tokens.\n', '  // Has a modifier to take some of the "stack burden" from the proxy function.\n', '  function claimShortParams(Rect _rect)\n', '    enoughTokens(_rect.width, _rect.height)\n', '    internal returns (uint id)\n', '  {\n', '    token.lockToken(msg.sender, _rect.width.mul(_rect.height));\n', '\n', '    // Check affected pixelblocks.\n', '    for (uint16 i = 0; i < _rect.width; i++) {\n', '      for (uint16 j = 0; j < _rect.height; j++) {\n', '        uint16 x = _rect.x.add(i);\n', '        uint16 y = _rect.y.add(j);\n', '\n', '        if (grid[x][y]) {\n', '          revert("Already claimed.");\n', '        }\n', '\n', '        // Mark block as claimed.\n', '        grid[x][y] = true;\n', '      }\n', '    }\n', '\n', '    // Create placeholder ad.\n', '    id = createPlaceholderAd(_rect);\n', '\n', '    emit Claim(id, msg.sender, _rect.x, _rect.y, _rect.width, _rect.height);\n', '    return id;\n', '  }\n', '\n', '  // Delete an ad, unclaim pixelblocks and unlock tokens.\n', '  function release(uint256 _id) adExists(_id) onlyAdOwner(_id) external {\n', '    uint16 tokens = ads[_id].rect.width.mul(ads[_id].rect.height);\n', '\n', '    // Mark blocks as unclaimed.\n', '    for (uint16 i = 0; i < ads[_id].rect.width; i++) {\n', '      for (uint16 j = 0; j < ads[_id].rect.height; j++) {\n', '        uint16 x = ads[_id].rect.x.add(i);\n', '        uint16 y = ads[_id].rect.y.add(j);\n', '\n', '        // Mark block as unclaimed.\n', '        grid[x][y] = false;\n', '      }\n', '    }\n', '\n', '    // Delete ad\n', '    delete ads[_id];\n', '    // Reorganize index array and map\n', '    uint256 key = adIdToIndex[_id];\n', '    // Fill gap with last element of adIds\n', '    adIds[key] = adIds[adIds.length - 1];\n', '    // Update adIdToIndex\n', '    adIdToIndex[adIds[key]] = key;\n', '    // Decrease length of adIds array by 1\n', '    adIds.length--;\n', '\n', '    // Unlock tokens\n', '    if (now < allAdStart) {\n', '      // The ad must have locked presale tokens.\n', '      presales[msg.sender] = presales[msg.sender].add(tokens);\n', '    }\n', '    token.unlockToken(msg.sender, tokens);\n', '\n', '    emit Release(_id, msg.sender);\n', '  }\n', '\n', '  // The image must be an URL either of bzz, ipfs or http(s).\n', '  function editAd(uint _id, string _link, string _title, string _text, string _contact, bool _NSFW, bytes32 _digest, bytes2 _hashFunction, uint8 _size, bytes4 _storageEnginge) adExists(_id) onlyAdOwner(_id) public {\n', '    emit EditAd(_id, msg.sender, _link, _title, _text, _contact, _NSFW, _digest, _hashFunction, _size,  _storageEnginge);\n', '  }\n', '\n', '  // Allows contract owner to set the NSFW flag for a given ad.\n', '  function forceNSFW(uint256 _id) onlyOwner adExists(_id) external {\n', '    emit ForceNSFW(_id);\n', '  }\n', '\n', '  // Helper function for claim() to avoid a deep stack.\n', '  function createPlaceholderAd(Rect _rect) internal returns (uint id) {\n', '    Ad memory ad = Ad(msg.sender, _rect);\n', '    id = ads.push(ad) - 1;\n', '    uint256 key = adIds.push(id) - 1;\n', '    adIdToIndex[id] = key;\n', '    return id;\n', '  }\n', '\n', '  // Returns remaining balance of tokens purchased during presale period qualifying for earlier claims.\n', '  function presaleBalanceOf(address _holder) public view returns (uint16) {\n', '    return presales[_holder];\n', '  }\n', '\n', '  // Returns all currently active adIds.\n', '  function getAdIds() external view returns (uint256[]) {\n', '    return adIds;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Other                           *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Allow transfer of tokens even if minting is not yet finished.\n', '  function allowTransfer() onlyOwner external {\n', '    token.allowTransfer();\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath16 {\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn’t hold\n', '    return c;\n', '  }\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(\n', '    ERC20Basic _token,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '\n', '  function safeApprove(\n', '    ERC20 _token,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.approve(_spender, _value));\n', '  }\n', '}\n', '/*****************************************************************\n', ' * Core contract of the Million Dollar Decentralized Application *\n', ' *****************************************************************/\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this Ether.\n', ' * @notice Ether can still be sent to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', ' */\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  constructor() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by setting a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param _token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic _token) external onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    _token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    public\n', '    hasMintPermission\n', '    canMint\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() public onlyOwner canMint returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MDAPPToken\n', ' * @dev Token for the Million Dollar Decentralized Application (MDAPP).\n', ' * Once a holder uses it to claim pixels the appropriate tokens are burned (1 Token <=> 10x10 pixel).\n', ' * If one releases his pixels new tokens are generated and credited to ones balance. Therefore, supply will\n', ' * vary between 0 and 10,000 tokens.\n', ' * Tokens are transferable once minting has finished.\n', ' * @dev Owned by MDAPP.sol\n', ' */\n', 'contract MDAPPToken is MintableToken {\n', '  using SafeMath16 for uint16;\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "MillionDollarDapp";\n', '  string public constant symbol = "MDAPP";\n', '  uint8 public constant decimals = 0;\n', '\n', '  mapping (address => uint16) locked;\n', '\n', '  bool public forceTransferEnable = false;\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Events                          *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Emitted when owner force-allows transfers of tokens.\n', '  event AllowTransfer();\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                      Modifiers                        *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  modifier hasLocked(address _account, uint16 _value) {\n', '    require(_value <= locked[_account], "Not enough locked tokens available.");\n', '    _;\n', '  }\n', '\n', '  modifier hasUnlocked(address _account, uint16 _value) {\n', '    require(balanceOf(_account).sub(uint256(locked[_account])) >= _value, "Not enough unlocked tokens available.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether it can transfer or otherwise throws.\n', '   */\n', '  modifier canTransfer(address _sender, uint256 _value) {\n', '    require(_value <= transferableTokensOf(_sender), "Not enough unlocked tokens available.");\n', '    _;\n', '  }\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                Limited Transfer Logic                 *\n', '   *            Taken from openzeppelin 1.3.0              *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  function lockToken(address _account, uint16 _value) onlyOwner hasUnlocked(_account, _value) public {\n', '    locked[_account] = locked[_account].add(_value);\n', '  }\n', '\n', '  function unlockToken(address _account, uint16 _value) onlyOwner hasLocked(_account, _value) public {\n', '    locked[_account] = locked[_account].sub(_value);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks modifier and allows transfer if tokens are not locked.\n', '   * @param _to The address that will receive the tokens.\n', '   * @param _value The amount of tokens to be transferred.\n', '   */\n', '  function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Checks modifier and allows transfer if tokens are not locked.\n', '  * @param _from The address that will send the tokens.\n', '  * @param _to The address that will receive the tokens.\n', '  * @param _value The amount of tokens to be transferred.\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Allow the holder to transfer his tokens only if every token in\n', '   * existence has already been distributed / minting is finished.\n', '   * Tokens which are locked for a claimed space cannot be transferred.\n', '   */\n', '  function transferableTokensOf(address _holder) public view returns (uint16) {\n', '    if (!mintingFinished && !forceTransferEnable) return 0;\n', '\n', '    return uint16(balanceOf(_holder)).sub(locked[_holder]);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the number of pixel-locked tokens.\n', '   */\n', '  function lockedTokensOf(address _holder) public view returns (uint16) {\n', '    return locked[_holder];\n', '  }\n', '\n', '  /**\n', '   * @dev Get the number of unlocked tokens usable for claiming pixels.\n', '   */\n', '  function unlockedTokensOf(address _holder) public view returns (uint256) {\n', '    return balanceOf(_holder).sub(uint256(locked[_holder]));\n', '  }\n', '\n', '  // Allow transfer of tokens even if minting is not yet finished.\n', '  function allowTransfer() onlyOwner public {\n', "    require(forceTransferEnable == false, 'Transfer already force-allowed.');\n", '\n', '    forceTransferEnable = true;\n', '    emit AllowTransfer();\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MDAPP\n', ' */\n', 'contract MDAPP is Ownable, HasNoEther, CanReclaimToken {\n', '  using SafeMath for uint256;\n', '  using SafeMath16 for uint16;\n', '\n', '  // The tokens contract.\n', '  MDAPPToken public token;\n', '\n', '  // The sales contracts address. Only it is allowed to to call the public mint function.\n', '  address public sale;\n', '\n', '  // When are presale participants allowed to place ads?\n', '  uint256 public presaleAdStart;\n', '\n', '  // When are all token owners allowed to place ads?\n', '  uint256 public allAdStart;\n', '\n', '  // Quantity of tokens bought during presale.\n', '  mapping (address => uint16) presales;\n', '\n', '  // Indicates whether a 10x10px block is claimed or not.\n', '  bool[80][125] grid;\n', '\n', '  // Struct that represents an ad.\n', '  struct Ad {\n', '    address owner;\n', '    Rect rect;\n', '  }\n', '\n', '  // Struct describing an rectangle area.\n', '  struct Rect {\n', '    uint16 x;\n', '    uint16 y;\n', '    uint16 width;\n', '    uint16 height;\n', '  }\n', '\n', "  // Don't store ad details on blockchain. Use events as storage as they are significantly cheaper.\n", '  // ads are stored in an array, the id of an ad is its index in this array.\n', '  Ad[] ads;\n', '\n', '  // The following holds a list of currently active ads (without holes between the indexes)\n', '  uint256[] adIds;\n', '\n', '  // Holds the mapping from adID to its index in the above adIds array. If an ad gets released, we know which index to\n', '  // delete and being filled with the last element instead.\n', '  mapping (uint256 => uint256) adIdToIndex;\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Events                          *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  /*\n', '   * Event for claiming pixel blocks.\n', '   * @param id ID of the new ad\n', '   * @param owner Who owns the used tokens\n', '   * @param x Upper left corner x coordinate\n', '   * @param y Upper left corner y coordinate\n', '   * @param width Width of the claimed area\n', '   * @param height Height of the claimed area\n', '   */\n', '  event Claim(uint256 indexed id, address indexed owner, uint16 x, uint16 y, uint16 width, uint16 height);\n', '\n', '  /*\n', '   * Event for releasing pixel blocks.\n', '   * @param id ID the fading ad\n', '   * @param owner Who owns the claimed blocks\n', '   */\n', '  event Release(uint256 indexed id, address indexed owner);\n', '\n', '  /*\n', '   * Event for editing an ad.\n', '   * @param id ID of the ad\n', '   * @param owner Who owns the ad\n', '   * @param link A link\n', '   * @param title Title of the ad\n', '   * @param text Description of the ad\n', '   * @param NSFW Whether the ad is safe for work\n', '   * @param digest IPFS hash digest\n', '   * @param hashFunction IPFS hash function\n', '   * @param size IPFS length of digest\n', '   * @param storageEngine e.g. ipfs or swrm (swarm)\n', '   */\n', '  event EditAd(uint256 indexed id, address indexed owner, string link, string title, string text, string contact, bool NSFW, bytes32 indexed digest, bytes2 hashFunction, uint8 size, bytes4 storageEngine);\n', '\n', '  event ForceNSFW(uint256 indexed id);\n', '\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                      Modifiers                        *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  modifier coordsValid(uint16 _x, uint16 _y, uint16 _width, uint16 _height) {\n', '    require((_x + _width - 1) < 125, "Invalid coordinates.");\n', '    require((_y + _height - 1) < 80, "Invalid coordinates.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdOwner(uint256 _id) {\n', '    require(ads[_id].owner == msg.sender, "Access denied.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier enoughTokens(uint16 _width, uint16 _height) {\n', '    require(uint16(token.unlockedTokensOf(msg.sender)) >= _width.mul(_height), "Not enough unlocked tokens available.");\n', '\n', '    _;\n', '  }\n', '\n', '  modifier claimAllowed(uint16 _width, uint16 _height) {\n', '    require(_width > 0 &&_width <= 125 && _height > 0 && _height <= 80, "Invalid dimensions.");\n', '    require(now >= presaleAdStart, "Claim period not yet started.");\n', '\n', '    if (now < allAdStart) {\n', '      // Sender needs enough presale tokens to claim at this point.\n', '      uint16 tokens = _width.mul(_height);\n', '      require(presales[msg.sender] >= tokens, "Not enough unlocked presale tokens available.");\n', '\n', '      presales[msg.sender] = presales[msg.sender].sub(tokens);\n', '    }\n', '\n', '    _;\n', '  }\n', '\n', '  modifier onlySale() {\n', '    require(msg.sender == sale);\n', '    _;\n', '  }\n', '\n', '  modifier adExists(uint256 _id) {\n', '    uint256 index = adIdToIndex[_id];\n', '    require(adIds[index] == _id, "Ad does not exist.");\n', '\n', '    _;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                   Initialization                      *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  constructor(uint256 _presaleAdStart, uint256 _allAdStart, address _token) public {\n', '    require(_presaleAdStart >= now);\n', '    require(_allAdStart > _presaleAdStart);\n', '\n', '    presaleAdStart = _presaleAdStart;\n', '    allAdStart = _allAdStart;\n', '    token = MDAPPToken(_token);\n', '  }\n', '\n', '  function setMDAPPSale(address _mdappSale) onlyOwner external {\n', '    require(sale == address(0));\n', '    sale = _mdappSale;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Logic                           *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Proxy function to pass minting from sale contract to token contract.\n', '  function mint(address _beneficiary, uint256 _tokenAmount, bool isPresale) onlySale external {\n', '    if (isPresale) {\n', '      presales[_beneficiary] = presales[_beneficiary].add(uint16(_tokenAmount));\n', '    }\n', '    token.mint(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  // Proxy function to pass finishMinting() from sale contract to token contract.\n', '  function finishMinting() onlySale external {\n', '    token.finishMinting();\n', '  }\n', '\n', '\n', '  // Public function proxy to forward single parameters as a struct.\n', '  function claim(uint16 _x, uint16 _y, uint16 _width, uint16 _height)\n', '    claimAllowed(_width, _height)\n', '    coordsValid(_x, _y, _width, _height)\n', '    external returns (uint)\n', '  {\n', '    Rect memory rect = Rect(_x, _y, _width, _height);\n', '    return claimShortParams(rect);\n', '  }\n', '\n', '  // Claims pixels and requires to have the sender enough unlocked tokens.\n', '  // Has a modifier to take some of the "stack burden" from the proxy function.\n', '  function claimShortParams(Rect _rect)\n', '    enoughTokens(_rect.width, _rect.height)\n', '    internal returns (uint id)\n', '  {\n', '    token.lockToken(msg.sender, _rect.width.mul(_rect.height));\n', '\n', '    // Check affected pixelblocks.\n', '    for (uint16 i = 0; i < _rect.width; i++) {\n', '      for (uint16 j = 0; j < _rect.height; j++) {\n', '        uint16 x = _rect.x.add(i);\n', '        uint16 y = _rect.y.add(j);\n', '\n', '        if (grid[x][y]) {\n', '          revert("Already claimed.");\n', '        }\n', '\n', '        // Mark block as claimed.\n', '        grid[x][y] = true;\n', '      }\n', '    }\n', '\n', '    // Create placeholder ad.\n', '    id = createPlaceholderAd(_rect);\n', '\n', '    emit Claim(id, msg.sender, _rect.x, _rect.y, _rect.width, _rect.height);\n', '    return id;\n', '  }\n', '\n', '  // Delete an ad, unclaim pixelblocks and unlock tokens.\n', '  function release(uint256 _id) adExists(_id) onlyAdOwner(_id) external {\n', '    uint16 tokens = ads[_id].rect.width.mul(ads[_id].rect.height);\n', '\n', '    // Mark blocks as unclaimed.\n', '    for (uint16 i = 0; i < ads[_id].rect.width; i++) {\n', '      for (uint16 j = 0; j < ads[_id].rect.height; j++) {\n', '        uint16 x = ads[_id].rect.x.add(i);\n', '        uint16 y = ads[_id].rect.y.add(j);\n', '\n', '        // Mark block as unclaimed.\n', '        grid[x][y] = false;\n', '      }\n', '    }\n', '\n', '    // Delete ad\n', '    delete ads[_id];\n', '    // Reorganize index array and map\n', '    uint256 key = adIdToIndex[_id];\n', '    // Fill gap with last element of adIds\n', '    adIds[key] = adIds[adIds.length - 1];\n', '    // Update adIdToIndex\n', '    adIdToIndex[adIds[key]] = key;\n', '    // Decrease length of adIds array by 1\n', '    adIds.length--;\n', '\n', '    // Unlock tokens\n', '    if (now < allAdStart) {\n', '      // The ad must have locked presale tokens.\n', '      presales[msg.sender] = presales[msg.sender].add(tokens);\n', '    }\n', '    token.unlockToken(msg.sender, tokens);\n', '\n', '    emit Release(_id, msg.sender);\n', '  }\n', '\n', '  // The image must be an URL either of bzz, ipfs or http(s).\n', '  function editAd(uint _id, string _link, string _title, string _text, string _contact, bool _NSFW, bytes32 _digest, bytes2 _hashFunction, uint8 _size, bytes4 _storageEnginge) adExists(_id) onlyAdOwner(_id) public {\n', '    emit EditAd(_id, msg.sender, _link, _title, _text, _contact, _NSFW, _digest, _hashFunction, _size,  _storageEnginge);\n', '  }\n', '\n', '  // Allows contract owner to set the NSFW flag for a given ad.\n', '  function forceNSFW(uint256 _id) onlyOwner adExists(_id) external {\n', '    emit ForceNSFW(_id);\n', '  }\n', '\n', '  // Helper function for claim() to avoid a deep stack.\n', '  function createPlaceholderAd(Rect _rect) internal returns (uint id) {\n', '    Ad memory ad = Ad(msg.sender, _rect);\n', '    id = ads.push(ad) - 1;\n', '    uint256 key = adIds.push(id) - 1;\n', '    adIdToIndex[id] = key;\n', '    return id;\n', '  }\n', '\n', '  // Returns remaining balance of tokens purchased during presale period qualifying for earlier claims.\n', '  function presaleBalanceOf(address _holder) public view returns (uint16) {\n', '    return presales[_holder];\n', '  }\n', '\n', '  // Returns all currently active adIds.\n', '  function getAdIds() external view returns (uint256[]) {\n', '    return adIds;\n', '  }\n', '\n', '  /*********************************************************\n', '   *                                                       *\n', '   *                       Other                           *\n', '   *                                                       *\n', '   *********************************************************/\n', '\n', '  // Allow transfer of tokens even if minting is not yet finished.\n', '  function allowTransfer() onlyOwner external {\n', '    token.allowTransfer();\n', '  }\n', '}']
