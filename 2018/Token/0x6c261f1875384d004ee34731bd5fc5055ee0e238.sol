['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) balances;\n', '    uint256 totalSupply_;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '    function safeTransferFrom(\n', '        ERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '    internal\n', '    {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    function reclaimToken(ERC20Basic token) external onlyOwner {\n', '        uint256 balance = token.balanceOf(this);\n', '        token.safeTransfer(owner, balance);\n', '    }\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function burn(uint256 _value) public {\n', '        _burn(msg.sender, _value);\n', '    }\n', '    function _burn(address _who, uint256 _value) internal {\n', '        require(_value <= balances[_who]);\n', '\n', '\n', '        balances[_who] = balances[_who].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burn(_who, _value);\n', '        emit Transfer(_who, address(0), _value);\n', '    }\n', '}\n', '\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    function add(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = true;\n', '    }\n', '\n', '    function remove(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = false;\n', '    }\n', '\n', '    function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '    {\n', '        require(has(role, addr));\n', '    }\n', '\n', '    function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return role.bearer[addr];\n', '    }\n', '}\n', '\n', 'contract RBAC {\n', '    using Roles for Roles.Role;\n', '    mapping (string => Roles.Role) private roles;\n', '    event RoleAdded(address indexed operator, string role);\n', '    event RoleRemoved(address indexed operator, string role);\n', '\n', '    function checkRole(address _operator, string _role)\n', '    view\n', '    public\n', '    {\n', '        roles[_role].check(_operator);\n', '    }\n', '\n', '    function hasRole(address _operator, string _role)\n', '    view\n', '    public\n', '    returns (bool)\n', '    {\n', '        return roles[_role].has(_operator);\n', '    }\n', '\n', '    function addRole(address _operator, string _role)\n', '    internal\n', '    {\n', '        roles[_role].add(_operator);\n', '        emit RoleAdded(_operator, _role);\n', '    }\n', '\n', '    function removeRole(address _operator, string _role)\n', '    internal\n', '    {\n', '        roles[_role].remove(_operator);\n', '        emit RoleRemoved(_operator, _role);\n', '    }\n', '\n', '    modifier onlyRole(string _role)\n', '    {\n', '        checkRole(msg.sender, _role);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Whitelist is Ownable, RBAC {\n', '    string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '    modifier onlyIfWhitelisted(address _operator) {\n', '        checkRole(_operator, ROLE_WHITELISTED);\n', '        _;\n', '    }\n', '\n', '    function addAddressToWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '    {\n', '        addRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function whitelist(address _operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '    {\n', '        return hasRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function addAddressesToWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '    {\n', '        for (uint256 i = 0; i < _operators.length; i++) {\n', '            addAddressToWhitelist(_operators[i]);\n', '        }\n', '    }\n', '\n', '    function removeAddressFromWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '    {\n', '        removeRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function removeAddressesFromWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '    {\n', '        for (uint256 i = 0; i < _operators.length; i++) {\n', '            removeAddressFromWhitelist(_operators[i]);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DateKernel\n', '{\n', '    uint256 public unlockTime;\n', '    constructor(uint256 _time) public {\n', '        unlockTime = _time;\n', '    }\n', '\n', '    function determineDate() internal view\n', '    returns (uint256 v)\n', '    {\n', '        uint256 n = now;\n', '        uint256 ut = unlockTime;\n', '        uint256 mo = 30 * 1 days;\n', '        uint8 p = 10;\n', '        assembly {\n', '            if sgt(n, ut) {\n', '                if or(slt(sub(n, ut), mo), eq(sub(n, ut), mo)) {\n', '                    v := 1\n', '                }\n', '                if sgt(sub(n, ut), mo) {\n', '                    v := add(div(sub(n, ut), mo), 1)\n', '                }\n', '                if or(eq(v, p), sgt(v, p)) {\n', '                    v := p\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Distributable is StandardToken, Ownable, Whitelist, DateKernel {\n', '    using SafeMath for uint;\n', '    event Distributed(uint256 amount);\n', '    event MemberUpdated(address member, uint256 balance);\n', '    struct member {\n', '        uint256 lastWithdrawal;\n', '        uint256 tokensTotal;\n', '        uint256 tokensLeft;\n', '    }\n', '\n', '    mapping (address => member) public teams;\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) private returns (bool) {\n', '        require(_value <= balances[_from]);\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function updateMember(address _who, uint256 _last, uint256 _total, uint256 _left) internal returns (bool) {\n', '        teams[_who] = member(_last, _total, _left);\n', '        emit MemberUpdated(_who, _left);\n', '        return true;\n', '    }\n', '    \n', '    function airdrop(address[] dests, uint256[] values) public onlyOwner {\n', '        // This simple validation will catch most mistakes without consuming\n', '        // too much gas.\n', '        require(dests.length == values.length);\n', '\n', '        for (uint256 i = 0; i < dests.length; i++) {\n', '            transfer(dests[i], values[i]);\n', '        }\n', '    }\n', '\n', '    function distributeTokens(address[] _member, uint256[] _amount)\n', '    onlyOwner\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(_member.length == _amount.length);\n', '        for (uint256 i = 0; i < _member.length; i++) {\n', '            updateMember(_member[i], 0, _amount[i], _amount[i]);\n', '            addAddressToWhitelist(_member[i]);\n', '        }\n', '        emit Distributed(_member.length);\n', '        return true;\n', '    }\n', '\n', '    function rewardController(address _member)\n', '    internal\n', '    returns (uint256)\n', '    {\n', '        member storage mbr = teams[_member];\n', '        require(mbr.tokensLeft > 0, "You&#39;ve spent your share");\n', '        uint256 multiplier;\n', '        uint256 callback;\n', '        uint256 curDate = determineDate();\n', '        uint256 lastDate = mbr.lastWithdrawal;\n', '        if(curDate > lastDate) {\n', '            multiplier = curDate.sub(lastDate);\n', '        } else if(curDate == lastDate) {\n', '            revert("Its no time");\n', '        }\n', '        if(mbr.tokensTotal >= mbr.tokensLeft && mbr.tokensTotal > 0) {\n', '            if(curDate == 10) {\n', '                callback = mbr.tokensLeft;\n', '            } else {\n', '                callback = multiplier.mul((mbr.tokensTotal).div(10));\n', '            }\n', '        }\n', '        updateMember(\n', '            _member,\n', '            curDate,\n', '            mbr.tokensTotal,\n', '            mbr.tokensLeft.sub(callback)\n', '        );\n', '        return callback;\n', '    }\n', '\n', '    function getDistributedToken()\n', '    public\n', '    onlyIfWhitelisted(msg.sender)\n', '    returns(bool)\n', '    {\n', '        require(unlockTime > now);\n', '        uint256 amount = rewardController(msg.sender);\n', '        _transfer(this, msg.sender, amount);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract TutorNinjaToken is Distributable, BurnableToken, CanReclaimToken, Claimable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public INITIAL_SUPPLY = 33e6 * (10 ** uint256(decimals));\n', '\n', '    constructor()\n', '    public\n', '    DateKernel(1541030400)\n', '    {\n', '        name = "Tutor Ninja";\n', '        symbol = "NTOK";\n', '        decimals = 10;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\n', '    }\n', '\n', '    function() external {\n', '        revert("Does not accept ether");\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function claimOwnership() onlyPendingOwner public {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) balances;\n', '    uint256 totalSupply_;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns (bool)\n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '    function safeTransferFrom(\n', '        ERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '    internal\n', '    {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require(token.approve(spender, value));\n', '    }\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    function reclaimToken(ERC20Basic token) external onlyOwner {\n', '        uint256 balance = token.balanceOf(this);\n', '        token.safeTransfer(owner, balance);\n', '    }\n', '}\n', '\n', 'contract BurnableToken is BasicToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function burn(uint256 _value) public {\n', '        _burn(msg.sender, _value);\n', '    }\n', '    function _burn(address _who, uint256 _value) internal {\n', '        require(_value <= balances[_who]);\n', '\n', '\n', '        balances[_who] = balances[_who].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burn(_who, _value);\n', '        emit Transfer(_who, address(0), _value);\n', '    }\n', '}\n', '\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    function add(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = true;\n', '    }\n', '\n', '    function remove(Role storage role, address addr)\n', '    internal\n', '    {\n', '        role.bearer[addr] = false;\n', '    }\n', '\n', '    function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '    {\n', '        require(has(role, addr));\n', '    }\n', '\n', '    function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '    {\n', '        return role.bearer[addr];\n', '    }\n', '}\n', '\n', 'contract RBAC {\n', '    using Roles for Roles.Role;\n', '    mapping (string => Roles.Role) private roles;\n', '    event RoleAdded(address indexed operator, string role);\n', '    event RoleRemoved(address indexed operator, string role);\n', '\n', '    function checkRole(address _operator, string _role)\n', '    view\n', '    public\n', '    {\n', '        roles[_role].check(_operator);\n', '    }\n', '\n', '    function hasRole(address _operator, string _role)\n', '    view\n', '    public\n', '    returns (bool)\n', '    {\n', '        return roles[_role].has(_operator);\n', '    }\n', '\n', '    function addRole(address _operator, string _role)\n', '    internal\n', '    {\n', '        roles[_role].add(_operator);\n', '        emit RoleAdded(_operator, _role);\n', '    }\n', '\n', '    function removeRole(address _operator, string _role)\n', '    internal\n', '    {\n', '        roles[_role].remove(_operator);\n', '        emit RoleRemoved(_operator, _role);\n', '    }\n', '\n', '    modifier onlyRole(string _role)\n', '    {\n', '        checkRole(msg.sender, _role);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Whitelist is Ownable, RBAC {\n', '    string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '    modifier onlyIfWhitelisted(address _operator) {\n', '        checkRole(_operator, ROLE_WHITELISTED);\n', '        _;\n', '    }\n', '\n', '    function addAddressToWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '    {\n', '        addRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function whitelist(address _operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '    {\n', '        return hasRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function addAddressesToWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '    {\n', '        for (uint256 i = 0; i < _operators.length; i++) {\n', '            addAddressToWhitelist(_operators[i]);\n', '        }\n', '    }\n', '\n', '    function removeAddressFromWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '    {\n', '        removeRole(_operator, ROLE_WHITELISTED);\n', '    }\n', '\n', '    function removeAddressesFromWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '    {\n', '        for (uint256 i = 0; i < _operators.length; i++) {\n', '            removeAddressFromWhitelist(_operators[i]);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DateKernel\n', '{\n', '    uint256 public unlockTime;\n', '    constructor(uint256 _time) public {\n', '        unlockTime = _time;\n', '    }\n', '\n', '    function determineDate() internal view\n', '    returns (uint256 v)\n', '    {\n', '        uint256 n = now;\n', '        uint256 ut = unlockTime;\n', '        uint256 mo = 30 * 1 days;\n', '        uint8 p = 10;\n', '        assembly {\n', '            if sgt(n, ut) {\n', '                if or(slt(sub(n, ut), mo), eq(sub(n, ut), mo)) {\n', '                    v := 1\n', '                }\n', '                if sgt(sub(n, ut), mo) {\n', '                    v := add(div(sub(n, ut), mo), 1)\n', '                }\n', '                if or(eq(v, p), sgt(v, p)) {\n', '                    v := p\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Distributable is StandardToken, Ownable, Whitelist, DateKernel {\n', '    using SafeMath for uint;\n', '    event Distributed(uint256 amount);\n', '    event MemberUpdated(address member, uint256 balance);\n', '    struct member {\n', '        uint256 lastWithdrawal;\n', '        uint256 tokensTotal;\n', '        uint256 tokensLeft;\n', '    }\n', '\n', '    mapping (address => member) public teams;\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) private returns (bool) {\n', '        require(_value <= balances[_from]);\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function updateMember(address _who, uint256 _last, uint256 _total, uint256 _left) internal returns (bool) {\n', '        teams[_who] = member(_last, _total, _left);\n', '        emit MemberUpdated(_who, _left);\n', '        return true;\n', '    }\n', '    \n', '    function airdrop(address[] dests, uint256[] values) public onlyOwner {\n', '        // This simple validation will catch most mistakes without consuming\n', '        // too much gas.\n', '        require(dests.length == values.length);\n', '\n', '        for (uint256 i = 0; i < dests.length; i++) {\n', '            transfer(dests[i], values[i]);\n', '        }\n', '    }\n', '\n', '    function distributeTokens(address[] _member, uint256[] _amount)\n', '    onlyOwner\n', '    public\n', '    returns (bool)\n', '    {\n', '        require(_member.length == _amount.length);\n', '        for (uint256 i = 0; i < _member.length; i++) {\n', '            updateMember(_member[i], 0, _amount[i], _amount[i]);\n', '            addAddressToWhitelist(_member[i]);\n', '        }\n', '        emit Distributed(_member.length);\n', '        return true;\n', '    }\n', '\n', '    function rewardController(address _member)\n', '    internal\n', '    returns (uint256)\n', '    {\n', '        member storage mbr = teams[_member];\n', '        require(mbr.tokensLeft > 0, "You\'ve spent your share");\n', '        uint256 multiplier;\n', '        uint256 callback;\n', '        uint256 curDate = determineDate();\n', '        uint256 lastDate = mbr.lastWithdrawal;\n', '        if(curDate > lastDate) {\n', '            multiplier = curDate.sub(lastDate);\n', '        } else if(curDate == lastDate) {\n', '            revert("Its no time");\n', '        }\n', '        if(mbr.tokensTotal >= mbr.tokensLeft && mbr.tokensTotal > 0) {\n', '            if(curDate == 10) {\n', '                callback = mbr.tokensLeft;\n', '            } else {\n', '                callback = multiplier.mul((mbr.tokensTotal).div(10));\n', '            }\n', '        }\n', '        updateMember(\n', '            _member,\n', '            curDate,\n', '            mbr.tokensTotal,\n', '            mbr.tokensLeft.sub(callback)\n', '        );\n', '        return callback;\n', '    }\n', '\n', '    function getDistributedToken()\n', '    public\n', '    onlyIfWhitelisted(msg.sender)\n', '    returns(bool)\n', '    {\n', '        require(unlockTime > now);\n', '        uint256 amount = rewardController(msg.sender);\n', '        _transfer(this, msg.sender, amount);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract TutorNinjaToken is Distributable, BurnableToken, CanReclaimToken, Claimable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public INITIAL_SUPPLY = 33e6 * (10 ** uint256(decimals));\n', '\n', '    constructor()\n', '    public\n', '    DateKernel(1541030400)\n', '    {\n', '        name = "Tutor Ninja";\n', '        symbol = "NTOK";\n', '        decimals = 10;\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '        emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\n', '    }\n', '\n', '    function() external {\n', '        revert("Does not accept ether");\n', '    }\n', '}']
