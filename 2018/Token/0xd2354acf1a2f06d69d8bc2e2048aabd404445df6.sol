['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/MNYTiers.sol\n', '\n', 'contract MNYTiers is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  uint public offset = 10**8;\n', '  struct Tier {\n', '    uint mny;\n', '    uint futrx;\n', '    uint rate;\n', '  }\n', '  mapping(uint16 => Tier) public tiers;\n', '\n', '  constructor() public {\n', '  }\n', '\n', '  function addTiers(uint16 _startingTier, uint[] _mny, uint[] _futrx) public {\n', '    require(msg.sender == dev || msg.sender == admin || msg.sender == owner);\n', '    require(_mny.length == _futrx.length);\n', '    for (uint16 i = 0; i < _mny.length; i++) {\n', '      tiers[_startingTier + i] = Tier(_mny[i], _futrx[i], uint(_mny[i]).div(uint(_futrx[i]).div(offset)));\n', '    }\n', '  }\n', '\n', '  function getTier(uint16 tier) public view returns (uint mny, uint futrx, uint rate) {\n', '    Tier t = tiers[tier];\n', '    return (t.mny, t.futrx, t.rate);\n', '  }\n', '\n', '  address public dev = 0xa694a1fce7e6737209acb71bdec807c5aca26365;\n', '  function changeDev (address _receiver) public {\n', '    require(msg.sender == dev);\n', '    dev = _receiver;\n', '  }\n', '\n', '  address public admin = 0x1e9b5a68023ef905e2440ea232c097a0f3ee3c87;\n', '  function changeAdmin (address _receiver) public {\n', '    require(msg.sender == admin);\n', '    admin = _receiver;\n', '  }\n', '\n', '  function loadData() public {\n', '    require(msg.sender == dev || msg.sender == admin || msg.sender == owner);\n', '    tiers[1] = Tier(6.597 ether, 0.0369 ether, uint(6.597 ether).div(uint(0.0369 ether).div(offset)));\n', '    tiers[2] = Tier(9.5117 ether, 0.0531 ether, uint(9.5117 ether).div(uint(0.0531 ether).div(offset)));\n', '    tiers[3] = Tier(5.8799 ether, 0.0292 ether, uint(5.8799 ether).div(uint(0.0292 ether).div(offset)));\n', '    tiers[4] = Tier(7.7979 ether, 0.0338 ether, uint(7.7979 ether).div(uint(0.0338 ether).div(offset)));\n', '    tiers[5] = Tier(7.6839 ether, 0.0385 ether, uint(7.6839 ether).div(uint(0.0385 ether).div(offset)));\n', '    tiers[6] = Tier(6.9612 ether, 0.0215 ether, uint(6.9612 ether).div(uint(0.0215 ether).div(offset)));\n', '    tiers[7] = Tier(7.1697 ether, 0.0269 ether, uint(7.1697 ether).div(uint(0.0269 ether).div(offset)));\n', '    tiers[8] = Tier(6.2356 ether, 0.0192 ether, uint(6.2356 ether).div(uint(0.0192 ether).div(offset)));\n', '    tiers[9] = Tier(5.6619 ether, 0.0177 ether, uint(5.6619 ether).div(uint(0.0177 ether).div(offset)));\n', '    tiers[10] = Tier(6.1805 ether, 0.0231 ether, uint(6.1805 ether).div(uint(0.0231 ether).div(offset)));\n', '    tiers[11] = Tier(6.915 ether, 0.0262 ether, uint(6.915 ether).div(uint(0.0262 ether).div(offset)));\n', '    tiers[12] = Tier(8.7151 ether, 0.0323 ether, uint(8.7151 ether).div(uint(0.0323 ether).div(offset)));\n', '    tiers[13] = Tier(23.8751 ether, 0.1038 ether, uint(23.8751 ether).div(uint(0.1038 ether).div(offset)));\n', '    tiers[14] = Tier(7.0588 ether, 0.0262 ether, uint(7.0588 ether).div(uint(0.0262 ether).div(offset)));\n', '    tiers[15] = Tier(13.441 ether, 0.0585 ether, uint(13.441 ether).div(uint(0.0585 ether).div(offset)));\n', '    tiers[16] = Tier(6.7596 ether, 0.0254 ether, uint(6.7596 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[17] = Tier(9.3726 ether, 0.0346 ether, uint(9.3726 ether).div(uint(0.0346 ether).div(offset)));\n', '    tiers[18] = Tier(7.1789 ether, 0.0269 ether, uint(7.1789 ether).div(uint(0.0269 ether).div(offset)));\n', '    tiers[19] = Tier(5.8699 ether, 0.0215 ether, uint(5.8699 ether).div(uint(0.0215 ether).div(offset)));\n', '    tiers[20] = Tier(8.3413 ether, 0.0308 ether, uint(8.3413 ether).div(uint(0.0308 ether).div(offset)));\n', '    tiers[21] = Tier(6.8338 ether, 0.0254 ether, uint(6.8338 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[22] = Tier(6.1386 ether, 0.0231 ether, uint(6.1386 ether).div(uint(0.0231 ether).div(offset)));\n', '    tiers[23] = Tier(6.7469 ether, 0.0254 ether, uint(6.7469 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[24] = Tier(9.9626 ether, 0.0431 ether, uint(9.9626 ether).div(uint(0.0431 ether).div(offset)));\n', '    tiers[25] = Tier(18.046 ether, 0.0785 ether, uint(18.046 ether).div(uint(0.0785 ether).div(offset)));\n', '    tiers[26] = Tier(10.2918 ether, 0.0446 ether, uint(10.2918 ether).div(uint(0.0446 ether).div(offset)));\n', '    tiers[27] = Tier(56.3078 ether, 0.2454 ether, uint(56.3078 ether).div(uint(0.2454 ether).div(offset)));\n', '    tiers[28] = Tier(17.2519 ether, 0.0646 ether, uint(17.2519 ether).div(uint(0.0646 ether).div(offset)));\n', '    tiers[29] = Tier(12.1003 ether, 0.0531 ether, uint(12.1003 ether).div(uint(0.0531 ether).div(offset)));\n', '    tiers[30] = Tier(14.4506 ether, 0.0631 ether, uint(14.4506 ether).div(uint(0.0631 ether).div(offset)));\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    hasMintPermission\n', '    canMint\n', '    public\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/MNY.sol\n', '\n', 'contract MNY is StandardToken, MintableToken, BurnableToken {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "MNY by Monkey Capital";\n', '  string public constant symbol = "MNY";\n', '  uint8 public constant decimals = 18;\n', '  uint public constant SWAP_CAP = 21000000 * (10 ** uint256(decimals));\n', '  uint public cycleMintSupply = 0;\n', '  MNYTiers public tierContract;\n', '\n', '  event SwapStarted(uint256 endTime);\n', '  event MiningRestart(uint16 tier);\n', '\n', '  uint public offset = 10**8;\n', '  uint public decimalOffset = 10 ** uint256(decimals);\n', '  uint public baseRate = 1 ether;\n', '  mapping(address => uint) public exchangeRatios;\n', '  mapping(address => uint) public unPaidFees;\n', '  address[] public miningTokens;\n', '\n', '  //initial state\n', '  uint16 public currentTier = 1;\n', '  uint public mnyLeftInCurrent = 6.597 ether;\n', '  uint public miningTokenLeftInCurrent = 0.0369 ether;\n', '  uint public currentRate = mnyLeftInCurrent.div(miningTokenLeftInCurrent.div(offset));\n', '  bool public isMiningOpen = false;\n', '  bool public miningActive = false;\n', '  uint16 public lastTier = 2856;\n', '\n', '  constructor() public {\n', '    totalSupply_ = 0;\n', '    //only the contract itself can mint as the owner\n', '    owner = this;\n', '  }\n', '\n', '  modifier canMine() {\n', '    require(isMiningOpen);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == creator || msg.sender == dev || msg.sender == origDev);\n', '    _;\n', '  }\n', '\n', '  // first call Token(address).approve(mny address, amount) for MNY to transfer on your behalf.\n', '  function mine(address token, uint amount) canMine public {\n', '    require(token != 0 && amount > 0);\n', '    require(exchangeRatios[token] > 0 && cycleMintSupply < SWAP_CAP);\n', '    require(ERC20(token).transferFrom(msg.sender, this, amount));\n', '    _mine(token, amount);\n', '  }\n', '\n', '  function _mine(address _token, uint256 _inAmount) private {\n', '    if (!miningActive) {\n', '      miningActive = true;\n', '    }\n', '    uint _tokens = 0;\n', '    uint miningPower = exchangeRatios[_token].div(baseRate).mul(_inAmount);\n', '    unPaidFees[_token] += _inAmount.div(2);\n', '\n', '    while (miningPower > 0) {\n', '      if (miningPower >= miningTokenLeftInCurrent) {\n', '        miningPower -= miningTokenLeftInCurrent;\n', '        _tokens += mnyLeftInCurrent;\n', '        miningTokenLeftInCurrent = 0;\n', '        mnyLeftInCurrent = 0;\n', '      } else {\n', '        uint calculatedMny = currentRate.mul(miningPower).div(offset);\n', '        _tokens += calculatedMny;\n', '        mnyLeftInCurrent -= calculatedMny;\n', '        miningTokenLeftInCurrent -= miningPower;\n', '        miningPower = 0;\n', '      }\n', '\n', '      if (miningTokenLeftInCurrent == 0) {\n', '        if (currentTier == lastTier) {\n', '          _tokens = SWAP_CAP - cycleMintSupply;\n', '          if (miningPower > 0) {\n', '            uint refund = miningPower.div(exchangeRatios[_token].div(baseRate));\n', '            unPaidFees[_token] -= refund.div(2);\n', '            ERC20(_token).transfer(msg.sender, refund);\n', '          }\n', '          // Open swap\n', '          _startSwap();\n', '          break;\n', '        }\n', '        currentTier++;\n', '        (mnyLeftInCurrent, miningTokenLeftInCurrent, currentRate) = tierContract.getTier(currentTier);\n', '      }\n', '    }\n', '    cycleMintSupply += _tokens;\n', '    MintableToken(this).mint(msg.sender, _tokens);\n', '  }\n', '\n', '  // swap data\n', '  bool public swapOpen = false;\n', '  uint public swapEndTime;\n', '  uint[] public holdings;\n', '  mapping(address => uint) public swapRates;\n', '\n', '  function _startSwap() private {\n', '    swapEndTime = now + 30 days;\n', '    swapOpen = true;\n', '    isMiningOpen = false;\n', '    miningActive = false;\n', '    delete holdings;\n', '\n', '    //set swap rates\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint swapAmt = ERC20(_token).balanceOf(this) - unPaidFees[_token];\n', '      holdings.push(swapAmt);\n', '    }\n', '    for (uint16 j = 0; j < miningTokens.length; j++) {\n', '      address token = miningTokens[j];\n', '      swapRates[token] = holdings[j].div(SWAP_CAP.div(decimalOffset));\n', '    }\n', '    emit SwapStarted(swapEndTime);\n', '  }\n', '\n', '  function swap(uint amt) public {\n', '    require(swapOpen && cycleMintSupply > 0);\n', '    if (amt > cycleMintSupply) {\n', '      amt = cycleMintSupply;\n', '    }\n', '    cycleMintSupply -= amt;\n', '    // burn verifies msg.sender has balance\n', '    burn(amt);\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      ERC20(_token).transfer(msg.sender, amt.mul(swapRates[_token]).div(decimalOffset));\n', '    }\n', '  }\n', '\n', '  function restart() public {\n', '    require(swapOpen);\n', '    require(now > swapEndTime || cycleMintSupply == 0);\n', '    cycleMintSupply = 0;\n', '    swapOpen = false;\n', '    swapEndTime = 0;\n', '    isMiningOpen = true;\n', '\n', '    // 20% penalty for unswapped tokens\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint amtLeft = ERC20(_token).balanceOf(this) - unPaidFees[_token];\n', '      unPaidFees[_token] += amtLeft.div(5);\n', '    }\n', '\n', '    currentTier = 1;\n', '    mnyLeftInCurrent = 6.597 ether;\n', '    miningTokenLeftInCurrent = 0.0369 ether;\n', '    currentRate = mnyLeftInCurrent.div(miningTokenLeftInCurrent.div(offset));\n', '    emit MiningRestart(currentTier);\n', '  }\n', '\n', '  function setIsMiningOpen(bool isOpen) onlyAdmin public {\n', '    isMiningOpen = isOpen;\n', '  }\n', '\n', '  // base rate is 1 ether, so for 1 to 1 send in 1 ether (toWei)\n', '  function addMiningToken(address tokenAddr, uint ratio) onlyAdmin public {\n', '    exchangeRatios[tokenAddr] = ratio;\n', '    miningTokens.push(tokenAddr);\n', '    unPaidFees[tokenAddr] = 0;\n', '  }\n', '\n', '  // can only add/change tier contract in between mining cycles\n', '  function setMnyTiers(address _tiersAddr) onlyAdmin public {\n', '    require(!miningActive);\n', '    tierContract = MNYTiers(_tiersAddr);\n', '  }\n', '\n', '  // this allows us to use a different set of tiers\n', '  // can only be changed in between mining cycles by admin\n', '  function setLastTier(uint16 _lastTier) onlyAdmin public {\n', '    require(swapOpen);\n', '    lastTier = _lastTier;\n', '  }\n', '\n', '  // Addresses for fees.\n', '  address public foundation = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public creator = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public dev = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public origDev = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '\n', '  function payFees() public {\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint fees = unPaidFees[_token];\n', '      ERC20(_token).transfer(foundation, fees.div(5).mul(2));\n', '      ERC20(_token).transfer(dev, fees.div(5));\n', '      ERC20(_token).transfer(origDev, fees.div(5));\n', '      ERC20(_token).transfer(creator, fees.div(5));\n', '      unPaidFees[_token] = 0;\n', '    }\n', '  }\n', '\n', '  function changeFoundation (address _receiver) public {\n', '    require(msg.sender == foundation);\n', '    foundation = _receiver;\n', '  }\n', '\n', '  function changeCreator (address _receiver) public {\n', '    require(msg.sender == creator);\n', '    creator = _receiver;\n', '  }\n', '\n', '  function changeDev (address _receiver) public {\n', '    require(msg.sender == dev);\n', '    dev = _receiver;\n', '  }\n', '\n', '  function changeOrigDev (address _receiver) public {\n', '    require(msg.sender == origDev);\n', '    origDev = _receiver;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/MNYTiers.sol\n', '\n', 'contract MNYTiers is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  uint public offset = 10**8;\n', '  struct Tier {\n', '    uint mny;\n', '    uint futrx;\n', '    uint rate;\n', '  }\n', '  mapping(uint16 => Tier) public tiers;\n', '\n', '  constructor() public {\n', '  }\n', '\n', '  function addTiers(uint16 _startingTier, uint[] _mny, uint[] _futrx) public {\n', '    require(msg.sender == dev || msg.sender == admin || msg.sender == owner);\n', '    require(_mny.length == _futrx.length);\n', '    for (uint16 i = 0; i < _mny.length; i++) {\n', '      tiers[_startingTier + i] = Tier(_mny[i], _futrx[i], uint(_mny[i]).div(uint(_futrx[i]).div(offset)));\n', '    }\n', '  }\n', '\n', '  function getTier(uint16 tier) public view returns (uint mny, uint futrx, uint rate) {\n', '    Tier t = tiers[tier];\n', '    return (t.mny, t.futrx, t.rate);\n', '  }\n', '\n', '  address public dev = 0xa694a1fce7e6737209acb71bdec807c5aca26365;\n', '  function changeDev (address _receiver) public {\n', '    require(msg.sender == dev);\n', '    dev = _receiver;\n', '  }\n', '\n', '  address public admin = 0x1e9b5a68023ef905e2440ea232c097a0f3ee3c87;\n', '  function changeAdmin (address _receiver) public {\n', '    require(msg.sender == admin);\n', '    admin = _receiver;\n', '  }\n', '\n', '  function loadData() public {\n', '    require(msg.sender == dev || msg.sender == admin || msg.sender == owner);\n', '    tiers[1] = Tier(6.597 ether, 0.0369 ether, uint(6.597 ether).div(uint(0.0369 ether).div(offset)));\n', '    tiers[2] = Tier(9.5117 ether, 0.0531 ether, uint(9.5117 ether).div(uint(0.0531 ether).div(offset)));\n', '    tiers[3] = Tier(5.8799 ether, 0.0292 ether, uint(5.8799 ether).div(uint(0.0292 ether).div(offset)));\n', '    tiers[4] = Tier(7.7979 ether, 0.0338 ether, uint(7.7979 ether).div(uint(0.0338 ether).div(offset)));\n', '    tiers[5] = Tier(7.6839 ether, 0.0385 ether, uint(7.6839 ether).div(uint(0.0385 ether).div(offset)));\n', '    tiers[6] = Tier(6.9612 ether, 0.0215 ether, uint(6.9612 ether).div(uint(0.0215 ether).div(offset)));\n', '    tiers[7] = Tier(7.1697 ether, 0.0269 ether, uint(7.1697 ether).div(uint(0.0269 ether).div(offset)));\n', '    tiers[8] = Tier(6.2356 ether, 0.0192 ether, uint(6.2356 ether).div(uint(0.0192 ether).div(offset)));\n', '    tiers[9] = Tier(5.6619 ether, 0.0177 ether, uint(5.6619 ether).div(uint(0.0177 ether).div(offset)));\n', '    tiers[10] = Tier(6.1805 ether, 0.0231 ether, uint(6.1805 ether).div(uint(0.0231 ether).div(offset)));\n', '    tiers[11] = Tier(6.915 ether, 0.0262 ether, uint(6.915 ether).div(uint(0.0262 ether).div(offset)));\n', '    tiers[12] = Tier(8.7151 ether, 0.0323 ether, uint(8.7151 ether).div(uint(0.0323 ether).div(offset)));\n', '    tiers[13] = Tier(23.8751 ether, 0.1038 ether, uint(23.8751 ether).div(uint(0.1038 ether).div(offset)));\n', '    tiers[14] = Tier(7.0588 ether, 0.0262 ether, uint(7.0588 ether).div(uint(0.0262 ether).div(offset)));\n', '    tiers[15] = Tier(13.441 ether, 0.0585 ether, uint(13.441 ether).div(uint(0.0585 ether).div(offset)));\n', '    tiers[16] = Tier(6.7596 ether, 0.0254 ether, uint(6.7596 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[17] = Tier(9.3726 ether, 0.0346 ether, uint(9.3726 ether).div(uint(0.0346 ether).div(offset)));\n', '    tiers[18] = Tier(7.1789 ether, 0.0269 ether, uint(7.1789 ether).div(uint(0.0269 ether).div(offset)));\n', '    tiers[19] = Tier(5.8699 ether, 0.0215 ether, uint(5.8699 ether).div(uint(0.0215 ether).div(offset)));\n', '    tiers[20] = Tier(8.3413 ether, 0.0308 ether, uint(8.3413 ether).div(uint(0.0308 ether).div(offset)));\n', '    tiers[21] = Tier(6.8338 ether, 0.0254 ether, uint(6.8338 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[22] = Tier(6.1386 ether, 0.0231 ether, uint(6.1386 ether).div(uint(0.0231 ether).div(offset)));\n', '    tiers[23] = Tier(6.7469 ether, 0.0254 ether, uint(6.7469 ether).div(uint(0.0254 ether).div(offset)));\n', '    tiers[24] = Tier(9.9626 ether, 0.0431 ether, uint(9.9626 ether).div(uint(0.0431 ether).div(offset)));\n', '    tiers[25] = Tier(18.046 ether, 0.0785 ether, uint(18.046 ether).div(uint(0.0785 ether).div(offset)));\n', '    tiers[26] = Tier(10.2918 ether, 0.0446 ether, uint(10.2918 ether).div(uint(0.0446 ether).div(offset)));\n', '    tiers[27] = Tier(56.3078 ether, 0.2454 ether, uint(56.3078 ether).div(uint(0.2454 ether).div(offset)));\n', '    tiers[28] = Tier(17.2519 ether, 0.0646 ether, uint(17.2519 ether).div(uint(0.0646 ether).div(offset)));\n', '    tiers[29] = Tier(12.1003 ether, 0.0531 ether, uint(12.1003 ether).div(uint(0.0531 ether).div(offset)));\n', '    tiers[30] = Tier(14.4506 ether, 0.0631 ether, uint(14.4506 ether).div(uint(0.0631 ether).div(offset)));\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  modifier hasMintPermission() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _amount\n', '  )\n', '    hasMintPermission\n', '    canMint\n', '    public\n', '    returns (bool)\n', '  {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/MNY.sol\n', '\n', 'contract MNY is StandardToken, MintableToken, BurnableToken {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "MNY by Monkey Capital";\n', '  string public constant symbol = "MNY";\n', '  uint8 public constant decimals = 18;\n', '  uint public constant SWAP_CAP = 21000000 * (10 ** uint256(decimals));\n', '  uint public cycleMintSupply = 0;\n', '  MNYTiers public tierContract;\n', '\n', '  event SwapStarted(uint256 endTime);\n', '  event MiningRestart(uint16 tier);\n', '\n', '  uint public offset = 10**8;\n', '  uint public decimalOffset = 10 ** uint256(decimals);\n', '  uint public baseRate = 1 ether;\n', '  mapping(address => uint) public exchangeRatios;\n', '  mapping(address => uint) public unPaidFees;\n', '  address[] public miningTokens;\n', '\n', '  //initial state\n', '  uint16 public currentTier = 1;\n', '  uint public mnyLeftInCurrent = 6.597 ether;\n', '  uint public miningTokenLeftInCurrent = 0.0369 ether;\n', '  uint public currentRate = mnyLeftInCurrent.div(miningTokenLeftInCurrent.div(offset));\n', '  bool public isMiningOpen = false;\n', '  bool public miningActive = false;\n', '  uint16 public lastTier = 2856;\n', '\n', '  constructor() public {\n', '    totalSupply_ = 0;\n', '    //only the contract itself can mint as the owner\n', '    owner = this;\n', '  }\n', '\n', '  modifier canMine() {\n', '    require(isMiningOpen);\n', '    _;\n', '  }\n', '\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == creator || msg.sender == dev || msg.sender == origDev);\n', '    _;\n', '  }\n', '\n', '  // first call Token(address).approve(mny address, amount) for MNY to transfer on your behalf.\n', '  function mine(address token, uint amount) canMine public {\n', '    require(token != 0 && amount > 0);\n', '    require(exchangeRatios[token] > 0 && cycleMintSupply < SWAP_CAP);\n', '    require(ERC20(token).transferFrom(msg.sender, this, amount));\n', '    _mine(token, amount);\n', '  }\n', '\n', '  function _mine(address _token, uint256 _inAmount) private {\n', '    if (!miningActive) {\n', '      miningActive = true;\n', '    }\n', '    uint _tokens = 0;\n', '    uint miningPower = exchangeRatios[_token].div(baseRate).mul(_inAmount);\n', '    unPaidFees[_token] += _inAmount.div(2);\n', '\n', '    while (miningPower > 0) {\n', '      if (miningPower >= miningTokenLeftInCurrent) {\n', '        miningPower -= miningTokenLeftInCurrent;\n', '        _tokens += mnyLeftInCurrent;\n', '        miningTokenLeftInCurrent = 0;\n', '        mnyLeftInCurrent = 0;\n', '      } else {\n', '        uint calculatedMny = currentRate.mul(miningPower).div(offset);\n', '        _tokens += calculatedMny;\n', '        mnyLeftInCurrent -= calculatedMny;\n', '        miningTokenLeftInCurrent -= miningPower;\n', '        miningPower = 0;\n', '      }\n', '\n', '      if (miningTokenLeftInCurrent == 0) {\n', '        if (currentTier == lastTier) {\n', '          _tokens = SWAP_CAP - cycleMintSupply;\n', '          if (miningPower > 0) {\n', '            uint refund = miningPower.div(exchangeRatios[_token].div(baseRate));\n', '            unPaidFees[_token] -= refund.div(2);\n', '            ERC20(_token).transfer(msg.sender, refund);\n', '          }\n', '          // Open swap\n', '          _startSwap();\n', '          break;\n', '        }\n', '        currentTier++;\n', '        (mnyLeftInCurrent, miningTokenLeftInCurrent, currentRate) = tierContract.getTier(currentTier);\n', '      }\n', '    }\n', '    cycleMintSupply += _tokens;\n', '    MintableToken(this).mint(msg.sender, _tokens);\n', '  }\n', '\n', '  // swap data\n', '  bool public swapOpen = false;\n', '  uint public swapEndTime;\n', '  uint[] public holdings;\n', '  mapping(address => uint) public swapRates;\n', '\n', '  function _startSwap() private {\n', '    swapEndTime = now + 30 days;\n', '    swapOpen = true;\n', '    isMiningOpen = false;\n', '    miningActive = false;\n', '    delete holdings;\n', '\n', '    //set swap rates\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint swapAmt = ERC20(_token).balanceOf(this) - unPaidFees[_token];\n', '      holdings.push(swapAmt);\n', '    }\n', '    for (uint16 j = 0; j < miningTokens.length; j++) {\n', '      address token = miningTokens[j];\n', '      swapRates[token] = holdings[j].div(SWAP_CAP.div(decimalOffset));\n', '    }\n', '    emit SwapStarted(swapEndTime);\n', '  }\n', '\n', '  function swap(uint amt) public {\n', '    require(swapOpen && cycleMintSupply > 0);\n', '    if (amt > cycleMintSupply) {\n', '      amt = cycleMintSupply;\n', '    }\n', '    cycleMintSupply -= amt;\n', '    // burn verifies msg.sender has balance\n', '    burn(amt);\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      ERC20(_token).transfer(msg.sender, amt.mul(swapRates[_token]).div(decimalOffset));\n', '    }\n', '  }\n', '\n', '  function restart() public {\n', '    require(swapOpen);\n', '    require(now > swapEndTime || cycleMintSupply == 0);\n', '    cycleMintSupply = 0;\n', '    swapOpen = false;\n', '    swapEndTime = 0;\n', '    isMiningOpen = true;\n', '\n', '    // 20% penalty for unswapped tokens\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint amtLeft = ERC20(_token).balanceOf(this) - unPaidFees[_token];\n', '      unPaidFees[_token] += amtLeft.div(5);\n', '    }\n', '\n', '    currentTier = 1;\n', '    mnyLeftInCurrent = 6.597 ether;\n', '    miningTokenLeftInCurrent = 0.0369 ether;\n', '    currentRate = mnyLeftInCurrent.div(miningTokenLeftInCurrent.div(offset));\n', '    emit MiningRestart(currentTier);\n', '  }\n', '\n', '  function setIsMiningOpen(bool isOpen) onlyAdmin public {\n', '    isMiningOpen = isOpen;\n', '  }\n', '\n', '  // base rate is 1 ether, so for 1 to 1 send in 1 ether (toWei)\n', '  function addMiningToken(address tokenAddr, uint ratio) onlyAdmin public {\n', '    exchangeRatios[tokenAddr] = ratio;\n', '    miningTokens.push(tokenAddr);\n', '    unPaidFees[tokenAddr] = 0;\n', '  }\n', '\n', '  // can only add/change tier contract in between mining cycles\n', '  function setMnyTiers(address _tiersAddr) onlyAdmin public {\n', '    require(!miningActive);\n', '    tierContract = MNYTiers(_tiersAddr);\n', '  }\n', '\n', '  // this allows us to use a different set of tiers\n', '  // can only be changed in between mining cycles by admin\n', '  function setLastTier(uint16 _lastTier) onlyAdmin public {\n', '    require(swapOpen);\n', '    lastTier = _lastTier;\n', '  }\n', '\n', '  // Addresses for fees.\n', '  address public foundation = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public creator = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public dev = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '  address public origDev = 0xab78275600E01Da6Ab7b5a4db7917d987FdB1b6d;\n', '\n', '  function payFees() public {\n', '    for (uint16 i = 0; i < miningTokens.length; i++) {\n', '      address _token = miningTokens[i];\n', '      uint fees = unPaidFees[_token];\n', '      ERC20(_token).transfer(foundation, fees.div(5).mul(2));\n', '      ERC20(_token).transfer(dev, fees.div(5));\n', '      ERC20(_token).transfer(origDev, fees.div(5));\n', '      ERC20(_token).transfer(creator, fees.div(5));\n', '      unPaidFees[_token] = 0;\n', '    }\n', '  }\n', '\n', '  function changeFoundation (address _receiver) public {\n', '    require(msg.sender == foundation);\n', '    foundation = _receiver;\n', '  }\n', '\n', '  function changeCreator (address _receiver) public {\n', '    require(msg.sender == creator);\n', '    creator = _receiver;\n', '  }\n', '\n', '  function changeDev (address _receiver) public {\n', '    require(msg.sender == dev);\n', '    dev = _receiver;\n', '  }\n', '\n', '  function changeOrigDev (address _receiver) public {\n', '    require(msg.sender == origDev);\n', '    origDev = _receiver;\n', '  }\n', '}']
