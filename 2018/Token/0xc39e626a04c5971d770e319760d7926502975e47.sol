['pragma solidity ^0.4.24;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title Reference implementation of the ERC220 standard token.\n', ' */\n', 'contract StandardToken is Token {\n', ' \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', ' \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', ' \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', ' \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', ' \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', ' \n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract BurnableToken is StandardToken, Ownable {\n', '\n', '    event Burn(address indexed burner, uint256 amount);\n', '\n', '    /**\n', '    * @dev Anybody can burn a specific amount of their tokens.\n', '    * @param _amount The amount of token to be burned.\n', '    */\n', '    function burn(uint256 _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= balances[msg.sender]);\n', '        // no need to require _amount <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = SafeMath.sub(balances[burner],_amount);\n', '        totalSupply = SafeMath.sub(totalSupply,_amount);\n', '        emit Transfer(burner, address(0), _amount);\n', '        emit Burn(burner, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can burn a specific amount of tokens of other token holders.\n', '    * @param _from The address of token holder whose tokens to be burned.\n', '    * @param _amount The amount of token to be burned.\n', '    */\n', '    function burnFrom(address _from, uint256 _amount) onlyOwner public {\n', '        require(_from != address(0));\n', '        require(_amount > 0);\n', '        require(_amount <= balances[_from]);\n', '        balances[_from] = SafeMath.sub(balances[_from],_amount);\n', '        totalSupply = SafeMath.sub(totalSupply,_amount);\n', '        emit Transfer(_from, address(0), _amount);\n', '        emit Burn(_from, _amount);\n', '    }\n', '\n', '}\n', '\n', 'contract AxpirePausableToken is StandardToken, Pausable,BurnableToken {\n', '\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', ' \n', '}\n', '\n', 'contract AxpireToken is AxpirePausableToken {\n', ' using SafeMath for uint;\n', '    // metadata\n', '    string public constant name = "aXpire";\n', '    string public constant symbol = "AXPR";\n', '    uint256 public constant decimals = 18;\n', '    \n', '   \taddress private ethFundDeposit;       \n', '\taddress private escrowFundDeposit;\n', '\t\t    \t\n', '\tuint256 public icoTokenExchangeRate = 715; // 715 b66 tokens per 1 ETH\n', '\tuint256 public tokenCreationCap =  350 * (10**6) * 10**decimals;  \n', '\t\n', '\t//address public ;\n', '\t// crowdsale parameters\n', '    \tbool public tokenSaleActive;              // switched to true in operational state\n', '\tbool public haltIco;\n', '\tbool public dead = false;\n', '\n', ' \n', '    // events \n', '    event CreateToken(address indexed _to, uint256 _value);\n', '    event Transfer(address from, address to, uint256 value);\n', '    \n', '    // constructor\n', '    constructor (\t\t\n', '       \taddress _ethFundDeposit,\n', '       \taddress _escrowFundDeposit\n', '\t\t\n', '\t\t\n', '        \t) public {\n', '        \t\n', '\t\ttokenSaleActive = true;                   \n', '\t\thaltIco = true;\n', '\t\tpaused = true;\n', '\t\t\t\n', '\t\trequire(_ethFundDeposit != address(0));\n', '\t\trequire(_escrowFundDeposit != address(0));\n', '\t\t\n', '\t\tethFundDeposit = _ethFundDeposit;\n', '\t\tescrowFundDeposit=_escrowFundDeposit;\n', '\t\tbalances[escrowFundDeposit] = tokenCreationCap;\n', '\t\ttotalSupply = tokenCreationCap;\n', '\t\temit CreateToken(escrowFundDeposit, totalSupply);\n', '\t\t\n', '    }\n', '\t\n', '    /// @dev Accepts ether and creates new tge tokens.\n', '    function createTokens() payable external {\n', '      if (!tokenSaleActive) \n', '        revert();\n', '      if (haltIco) \n', '\trevert();\t  \n', '      if (msg.value == 0) \n', '        revert();\n', '        \n', '      uint256 tokens;\n', '      tokens = SafeMath.mul(msg.value, icoTokenExchangeRate); // check that we&#39;re not over totals\n', '      uint256 checkedSupply = SafeMath.add(totalSupply, tokens);\n', ' \n', '      // return money if something goes wrong\n', '      if (tokenCreationCap < checkedSupply) \n', '        revert();  // odd fractions won&#39;t be found\n', ' \n', '      totalSupply = checkedSupply;\n', '      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n', '      emit CreateToken(msg.sender, tokens);  // logs token creation\n', '    }  \n', '    \n', '    function setIcoTokenExchangeRate (uint _icoTokenExchangeRate) onlyOwner external {\t\t\n', '    \ticoTokenExchangeRate = _icoTokenExchangeRate;            \n', '    }        \n', '    \n', '    function setHaltIco(bool _haltIco) onlyOwner external {\n', '\thaltIco = _haltIco;            \n', '    }\t\n', '    \n', '     /// @dev Ends the funding period and sends the ETH home\n', '    function sendFundHome() onlyOwner external {  // move to operational\n', '      if (!ethFundDeposit.send(address(this).balance)) \n', '        revert();  // send the eth to tge International\n', '    } \n', '\t\n', '    function sendFundHomeAmt(uint _amt) onlyOwner external {\n', '      if (!ethFundDeposit.send(_amt*10**decimals)) \n', '        revert();  // send the eth to tge International\n', '    }    \n', '    \n', '      function toggleDead()\n', '          external\n', '          onlyOwner\n', '          returns (bool)\n', '        {\n', '          dead = !dead;\n', '      }\n', '     \n', '        function endIco() onlyOwner external { // end ICO\n', '          // ensure that sale is active. is set to false at the end. can only be performed once.\n', '              require(tokenSaleActive == true);\n', '               tokenSaleActive=false;\n', '        }  \n', '    \n', '      \n', '}']
['pragma solidity ^0.4.24;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * @title Reference implementation of the ERC220 standard token.\n', ' */\n', 'contract StandardToken is Token {\n', ' \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', ' \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', ' \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', ' \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(_value == 0 || allowed[msg.sender][_spender] == 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', ' \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', ' \n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract BurnableToken is StandardToken, Ownable {\n', '\n', '    event Burn(address indexed burner, uint256 amount);\n', '\n', '    /**\n', '    * @dev Anybody can burn a specific amount of their tokens.\n', '    * @param _amount The amount of token to be burned.\n', '    */\n', '    function burn(uint256 _amount) public {\n', '        require(_amount > 0);\n', '        require(_amount <= balances[msg.sender]);\n', '        // no need to require _amount <= totalSupply, since that would imply the\n', "        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '        address burner = msg.sender;\n', '        balances[burner] = SafeMath.sub(balances[burner],_amount);\n', '        totalSupply = SafeMath.sub(totalSupply,_amount);\n', '        emit Transfer(burner, address(0), _amount);\n', '        emit Burn(burner, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Owner can burn a specific amount of tokens of other token holders.\n', '    * @param _from The address of token holder whose tokens to be burned.\n', '    * @param _amount The amount of token to be burned.\n', '    */\n', '    function burnFrom(address _from, uint256 _amount) onlyOwner public {\n', '        require(_from != address(0));\n', '        require(_amount > 0);\n', '        require(_amount <= balances[_from]);\n', '        balances[_from] = SafeMath.sub(balances[_from],_amount);\n', '        totalSupply = SafeMath.sub(totalSupply,_amount);\n', '        emit Transfer(_from, address(0), _amount);\n', '        emit Burn(_from, _amount);\n', '    }\n', '\n', '}\n', '\n', 'contract AxpirePausableToken is StandardToken, Pausable,BurnableToken {\n', '\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', ' \n', '}\n', '\n', 'contract AxpireToken is AxpirePausableToken {\n', ' using SafeMath for uint;\n', '    // metadata\n', '    string public constant name = "aXpire";\n', '    string public constant symbol = "AXPR";\n', '    uint256 public constant decimals = 18;\n', '    \n', '   \taddress private ethFundDeposit;       \n', '\taddress private escrowFundDeposit;\n', '\t\t    \t\n', '\tuint256 public icoTokenExchangeRate = 715; // 715 b66 tokens per 1 ETH\n', '\tuint256 public tokenCreationCap =  350 * (10**6) * 10**decimals;  \n', '\t\n', '\t//address public ;\n', '\t// crowdsale parameters\n', '    \tbool public tokenSaleActive;              // switched to true in operational state\n', '\tbool public haltIco;\n', '\tbool public dead = false;\n', '\n', ' \n', '    // events \n', '    event CreateToken(address indexed _to, uint256 _value);\n', '    event Transfer(address from, address to, uint256 value);\n', '    \n', '    // constructor\n', '    constructor (\t\t\n', '       \taddress _ethFundDeposit,\n', '       \taddress _escrowFundDeposit\n', '\t\t\n', '\t\t\n', '        \t) public {\n', '        \t\n', '\t\ttokenSaleActive = true;                   \n', '\t\thaltIco = true;\n', '\t\tpaused = true;\n', '\t\t\t\n', '\t\trequire(_ethFundDeposit != address(0));\n', '\t\trequire(_escrowFundDeposit != address(0));\n', '\t\t\n', '\t\tethFundDeposit = _ethFundDeposit;\n', '\t\tescrowFundDeposit=_escrowFundDeposit;\n', '\t\tbalances[escrowFundDeposit] = tokenCreationCap;\n', '\t\ttotalSupply = tokenCreationCap;\n', '\t\temit CreateToken(escrowFundDeposit, totalSupply);\n', '\t\t\n', '    }\n', '\t\n', '    /// @dev Accepts ether and creates new tge tokens.\n', '    function createTokens() payable external {\n', '      if (!tokenSaleActive) \n', '        revert();\n', '      if (haltIco) \n', '\trevert();\t  \n', '      if (msg.value == 0) \n', '        revert();\n', '        \n', '      uint256 tokens;\n', "      tokens = SafeMath.mul(msg.value, icoTokenExchangeRate); // check that we're not over totals\n", '      uint256 checkedSupply = SafeMath.add(totalSupply, tokens);\n', ' \n', '      // return money if something goes wrong\n', '      if (tokenCreationCap < checkedSupply) \n', "        revert();  // odd fractions won't be found\n", ' \n', '      totalSupply = checkedSupply;\n', '      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n', '      emit CreateToken(msg.sender, tokens);  // logs token creation\n', '    }  \n', '    \n', '    function setIcoTokenExchangeRate (uint _icoTokenExchangeRate) onlyOwner external {\t\t\n', '    \ticoTokenExchangeRate = _icoTokenExchangeRate;            \n', '    }        \n', '    \n', '    function setHaltIco(bool _haltIco) onlyOwner external {\n', '\thaltIco = _haltIco;            \n', '    }\t\n', '    \n', '     /// @dev Ends the funding period and sends the ETH home\n', '    function sendFundHome() onlyOwner external {  // move to operational\n', '      if (!ethFundDeposit.send(address(this).balance)) \n', '        revert();  // send the eth to tge International\n', '    } \n', '\t\n', '    function sendFundHomeAmt(uint _amt) onlyOwner external {\n', '      if (!ethFundDeposit.send(_amt*10**decimals)) \n', '        revert();  // send the eth to tge International\n', '    }    \n', '    \n', '      function toggleDead()\n', '          external\n', '          onlyOwner\n', '          returns (bool)\n', '        {\n', '          dead = !dead;\n', '      }\n', '     \n', '        function endIco() onlyOwner external { // end ICO\n', '          // ensure that sale is active. is set to false at the end. can only be performed once.\n', '              require(tokenSaleActive == true);\n', '               tokenSaleActive=false;\n', '        }  \n', '    \n', '      \n', '}']
