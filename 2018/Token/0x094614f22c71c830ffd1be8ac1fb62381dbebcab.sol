['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    _owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(_owner);\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name  \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/// @dev A standard ERC20 token (with 18 decimals) contract with manager\n', ' /// @dev Tokens are initally minted in the contract address\n', 'contract standardToken is EIP20Interface, Ownable {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    uint8 public constant decimals = 18;  \n', '\n', '    string public name;                    \n', '    string public symbol;                \n', '    uint public totalSupply;\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value, "Insufficient balance");\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        uint allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }   \n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender. *\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint _addedValue) public returns(bool)\n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender. *\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns(bool)\n', '    {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue){\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '/// @dev A standard token that is linked to another pairToken.\n', '/// @dev The total supply of these two tokens should be the same.\n', '/// @dev Sending one token to any of these two contract address\n', '/// @dev using transfer method will result a receiving of 1:1 another token. \n', 'contract pairToken is standardToken {\n', '    using SafeMath for uint;\n', '\n', '    address public pairAddress;\n', '\n', '    bool public pairInitialized = false;\n', '\n', '    /// @dev Set the pair token contract, can only excute once\n', '    function initPair(address _pairAddress) public onlyOwner() {\n', '        require(!pairInitialized, "Pair already initialized");\n', '        pairAddress = _pairAddress;\n', '        pairInitialized = true;\n', '    }\n', '\n', '    /// @dev Override\n', '    /// @dev A special transfer function that, if the target is either this contract\n', '    /// @dev or the pair token contract, the token will be sent to this contract, and\n', '    /// @dev 1:1 pair tokens are sent to the sender.\n', '    /// @dev When the target address are other than the two paired token address,\n', '    /// @dev this function behaves exactly the same as in a standard ERC20 token.\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value, "Insufficient balance");\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        if (_to == pairAddress || _to == address(this)) {\n', '            balances[address(this)] = balances[address(this)].add(_value);\n', '            pairToken(pairAddress).pairTransfer(msg.sender, _value);\n', '            emit Exchange(msg.sender, address(this), _value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '        } else {\n', '            balances[_to] = balances[_to].add(_value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    } \n', '\n', '    /// @dev Function called by pair token to excute 1:1 exchange of the token.\n', '    function pairTransfer(address _to, uint _value) external returns (bool success) {\n', '        require(msg.sender == pairAddress, "Only token pairs can transfer");\n', '        balances[address(this)] = balances[address(this)].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        return true;\n', '    }\n', '\n', '    event Exchange(address indexed _from, address _tokenAddress, uint _value);\n', '}\n', '\n', '/// @dev A pair token that can be mint by sending ether into this contract.\n', '/// @dev The price of the token follows price = a*log(t)+b, where a and b are\n', '/// @dev two parameters to be set, and t is the current round depends on current\n', '/// @dev block height.\n', 'contract CryptojoyToken is pairToken {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "cryptojoy token";                    \n', '    string public symbol = "CJT";                \n', '    uint public totalSupply = 10**10 * 10**18; // 1 billion\n', '    uint public miningSupply; // minable part\n', '\n', '    uint constant MAGNITUDE = 10**6;\n', '    uint constant LOG1DOT5 = 405465; // log(1.5) under MAGNITUDE\n', '    uint constant THREE_SECOND= 15 * MAGNITUDE / 10; // 1.5 under MAGNITUDE\n', '    uint constant MINING_INTERVAL = 365; // number of windows that the price is fixed\n', '\n', '    uint public a; // paremeter a of the price fuction price = a*log(t)+b, 18 decimals\n', '    uint public b; // paremeter b of the price fuction price = a*log(t)+b, 18 decimals\n', '    uint public blockInterval; // number of blocks where the token price is fixed\n', '    uint public startBlockNumber; // The starting block that the token can be mint.\n', '\n', '    address public platform;\n', '    uint public lowerBoundaryETH; // Refuse incoming ETH lower than this value\n', '    uint public upperBoundaryETH; // Refuse incoming ETH higher than this value\n', '\n', '    uint public supplyPerInterval; // miningSupply / MINING_INTERVAL\n', '    uint public tokenMint = 0;\n', '\n', '    bool paraInitialized = false;\n', '\n', '    /// @param _beneficiary Address to send the remaining tokens\n', '    /// @param _miningSupply Amount of tokens of mining\n', '    constructor(\n', '        address _beneficiary, \n', '        uint _miningSupply)\n', '        public {\n', '        require(_miningSupply < totalSupply, "Insufficient total supply");\n', '        miningSupply = _miningSupply;\n', '        uint _amount = totalSupply.sub(_miningSupply);\n', '        balances[address(this)] = miningSupply;\n', '        balances[_beneficiary] = _amount;\n', '        supplyPerInterval = miningSupply / MINING_INTERVAL;\n', '    }\n', '\n', '\n', '    /// @dev sets boundaries for incoming tx\n', '    /// @dev from FoMo3Dlong\n', '    modifier isWithinLimits(uint _eth) {\n', '        require(_eth >= lowerBoundaryETH, "pocket lint: not a valid currency");\n', '        require(_eth <= upperBoundaryETH, "no vitalik, no");\n', '        _;\n', '    }\n', '\n', '    /// @dev Initialize the token mint parameters\n', '    /// @dev Can only be excuted once.\n', '    function initPara(\n', '        uint _a, \n', '        uint _b, \n', '        uint _blockInterval, \n', '        uint _startBlockNumber,\n', '        address _platform,\n', '        uint _lowerBoundaryETH,\n', '        uint _upperBoundaryETH) \n', '        public \n', '        onlyOwner {\n', '        require(!paraInitialized, "Parameters are already set");\n', '        require(_lowerBoundaryETH < _upperBoundaryETH, "Lower boundary is larger than upper boundary!");\n', '        a = _a;\n', '        b = _b;\n', '        blockInterval = _blockInterval;\n', '        startBlockNumber = _startBlockNumber;\n', '\n', '        platform = _platform;\n', '        lowerBoundaryETH = _lowerBoundaryETH;\n', '        upperBoundaryETH = _upperBoundaryETH;\n', '\n', '        paraInitialized = true;\n', '    }\n', '\n', '    function changeWithdraw(address _platform) public onlyOwner {\n', '        platform = _platform;\n', '    }\n', '\n', '    /// @dev Mint token based on the current token price.\n', '    /// @dev The token number is limited during each interval.\n', '    function buy() public isWithinLimits(msg.value) payable {\n', '        uint currentStage = getCurrentStage(); // from 1 to MINING_INTERVAL\n', '        require(tokenMint < currentStage.mul(supplyPerInterval), "No token avaiable");\n', '        uint currentPrice = calculatePrice(currentStage); // 18 decimal\n', '        uint amountToBuy = msg.value.mul(10**uint(decimals)).div(currentPrice);\n', '        \n', '        if(tokenMint.add(amountToBuy) > currentStage.mul(supplyPerInterval)) {\n', '            amountToBuy = currentStage.mul(supplyPerInterval).sub(tokenMint);\n', '            balances[address(this)] = balances[address(this)].sub(amountToBuy);\n', '            balances[msg.sender] = balances[msg.sender].add(amountToBuy);\n', '            tokenMint = tokenMint.add(amountToBuy);\n', '            uint refund = msg.value.sub(amountToBuy.mul(currentPrice).div(10**uint(decimals)));\n', '            msg.sender.transfer(refund);          \n', '            platform.transfer(msg.value.sub(refund)); \n', '        } else {\n', '            balances[address(this)] = balances[address(this)].sub(amountToBuy);\n', '            balances[msg.sender] = balances[msg.sender].add(amountToBuy);\n', '            tokenMint = tokenMint.add(amountToBuy);\n', '            platform.transfer(msg.value);\n', '        }\n', '        emit Buy(msg.sender, amountToBuy);\n', '    }\n', '\n', '    function() public payable {\n', '        buy();\n', '    }\n', '\n', '    /// @dev Shows the remaining token of the current token mint phase\n', '    function tokenRemain() public view returns (uint) {\n', '        uint currentStage = getCurrentStage();\n', '        return currentStage * supplyPerInterval - tokenMint;\n', '    }\n', '\n', '    /// @dev Get the current token mint phase between 1 and MINING_INTERVAL\n', '    function getCurrentStage() public view returns (uint) {\n', '        require(block.number >= startBlockNumber, "Not started yet");\n', '        uint currentStage = (block.number.sub(startBlockNumber)).div(blockInterval) + 1;\n', '        if (currentStage <= MINING_INTERVAL) {\n', '            return currentStage;\n', '        } else {\n', '            return MINING_INTERVAL;\n', '        }\n', '    }\n', '\n', '    /// @dev Return the price of one token during the nth stage\n', '    /// @param stage Current stage from 1 to 365\n', '    /// @return Price per token\n', '    function calculatePrice(uint stage) public view returns (uint) {\n', '        return a.mul(log(stage.mul(MAGNITUDE))).div(MAGNITUDE).add(b);\n', '    }\n', '\n', '    /// @dev Return the e based logarithm of x demonstrated by Vitalik\n', '    /// @param input The actual input (>=1) times MAGNITUDE\n', '    /// @return result The actual output times MAGNITUDE\n', '    function log(uint input) internal pure returns (uint) {\n', '        uint x = input;\n', '        require(x >= MAGNITUDE);\n', '        if (x == MAGNITUDE) {\n', '            return 0;\n', '        }\n', '        uint result = 0;\n', '        while (x >= THREE_SECOND) {\n', '            result += LOG1DOT5;\n', '            x = x * 2 / 3;\n', '        }\n', '        \n', '        x = x - MAGNITUDE;\n', '        uint y = x;\n', '        uint i = 1;\n', '        while (i < 10) {\n', '            result = result + (y / i);\n', '            i += 1;\n', '            y = y * x / MAGNITUDE;\n', '            result = result - (y / i);\n', '            i += 1;\n', '            y = y * x / MAGNITUDE;\n', '        }\n', '        \n', '        return result;\n', '    }\n', '\n', '    event Buy(address indexed _buyer, uint _value);\n', '}\n', '\n', 'contract CryptojoyStock is pairToken {\n', '\n', '\n', '    string public name = "cryptojoy stock";                    \n', '    string public symbol = "CJS";                \n', '    uint public totalSupply = 10**10 * 10**18;\n', '\n', '    constructor() public {\n', '        balances[address(this)] = totalSupply;\n', '    } \n', '\n', '}']