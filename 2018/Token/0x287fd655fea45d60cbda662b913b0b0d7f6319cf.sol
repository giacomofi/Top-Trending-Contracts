['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Erc20Token {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract AirDropContract is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    Erc20Token public tokenRewardContract;\n', '\n', '    uint256 public totalAirDropToken;\n', '\n', '    address public collectorAddress;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '    event Additional(uint amount);\n', '    event Burn(uint amount);\n', '    event CollectAirDropTokenBack(address collectorAddress,uint256 airDropTokenNum);\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    constructor(\n', '        address _tokenRewardContract,\n', '        address _collectorAddress\n', '    ) public {\n', '        totalAirDropToken = 2e7;\n', '        tokenRewardContract = Erc20Token(_tokenRewardContract);\n', '        collectorAddress = _collectorAddress;\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function() payable public {\n', '        require(collectorAddress != 0x0);\n', '        require(totalAirDropToken > 0);\n', '\n', '        uint256 ethAmount = msg.value.div(1e18);\n', '        uint256 amount = ethAmount.mul(23000);\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.sub(amount);\n', '        tokenRewardContract.transfer(msg.sender, amount.mul(1e18));\n', '\n', '        address wallet = collectorAddress;\n', '        uint256 weiAmount = msg.value;\n', '        wallet.transfer(weiAmount);\n', '\n', '        emit FundTransfer(msg.sender, amount, true);\n', '    }\n', '\n', '    /**\n', '     *  Add airdrop tokens\n', '     */\n', '    function additional(uint256 amount) public onlyOwner {\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.add(amount);\n', '        emit Additional(amount);\n', '    }\n', '\n', '    /**\n', '    *  burn airdrop tokens\n', '    */\n', '    function burn(uint256 amount) public onlyOwner {\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.sub(amount);\n', '        emit Burn(amount);\n', '    }\n', '\n', '\n', '    /**\n', '     *  The owner of the contract modifies the recovery address of the token\n', '     */\n', '    function modifyCollectorAddress(address newCollectorAddress) public onlyOwner returns (bool) {\n', '        collectorAddress = newCollectorAddress;\n', '    }\n', '\n', '    /**\n', '     *  Recovery of remaining tokens\n', '     */\n', '    function collectAirDropTokenBack(uint256 airDropTokenNum) public onlyOwner {\n', '        require(totalAirDropToken > 0);\n', '        require(collectorAddress != 0x0);\n', '\n', '        if (airDropTokenNum > 0) {\n', '            tokenRewardContract.transfer(collectorAddress, airDropTokenNum * 1e18);\n', '        } else {\n', '            tokenRewardContract.transfer(collectorAddress, totalAirDropToken * 1e18);\n', '            totalAirDropToken = 0;\n', '        }\n', '        emit CollectAirDropTokenBack(collectorAddress, airDropTokenNum);\n', '    }\n', '\n', '    /**\n', '     *  Recovery donated ether\n', '     */\n', '    function collectEtherBack() public onlyOwner {\n', '        uint256 b = address(this).balance;\n', '        require(b > 0);\n', '        require(collectorAddress != 0x0);\n', '\n', '        collectorAddress.transfer(b);\n', '    }\n', '\n', '    /**\n', '     *  Get the tokenAddress token balance of someone\n', '     */\n', '    function getTokenBalance(address tokenAddress, address who) view public returns (uint){\n', '        Erc20Token t = Erc20Token(tokenAddress);\n', '        return t.balanceOf(who);\n', '    }\n', '\n', '    /**\n', '     *  Recycle other ERC20 tokens\n', '     */\n', '    function collectOtherTokens(address tokenContract) onlyOwner public returns (bool) {\n', '        Erc20Token t = Erc20Token(tokenContract);\n', '\n', '        uint256 b = t.balanceOf(address(this));\n', '        return t.transfer(collectorAddress, b);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Erc20Token {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'contract AirDropContract is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    Erc20Token public tokenRewardContract;\n', '\n', '    uint256 public totalAirDropToken;\n', '\n', '    address public collectorAddress;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '    event Additional(uint amount);\n', '    event Burn(uint amount);\n', '    event CollectAirDropTokenBack(address collectorAddress,uint256 airDropTokenNum);\n', '\n', '    /**\n', '     * Constructor function\n', '     */\n', '    constructor(\n', '        address _tokenRewardContract,\n', '        address _collectorAddress\n', '    ) public {\n', '        totalAirDropToken = 2e7;\n', '        tokenRewardContract = Erc20Token(_tokenRewardContract);\n', '        collectorAddress = _collectorAddress;\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function() payable public {\n', '        require(collectorAddress != 0x0);\n', '        require(totalAirDropToken > 0);\n', '\n', '        uint256 ethAmount = msg.value.div(1e18);\n', '        uint256 amount = ethAmount.mul(23000);\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.sub(amount);\n', '        tokenRewardContract.transfer(msg.sender, amount.mul(1e18));\n', '\n', '        address wallet = collectorAddress;\n', '        uint256 weiAmount = msg.value;\n', '        wallet.transfer(weiAmount);\n', '\n', '        emit FundTransfer(msg.sender, amount, true);\n', '    }\n', '\n', '    /**\n', '     *  Add airdrop tokens\n', '     */\n', '    function additional(uint256 amount) public onlyOwner {\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.add(amount);\n', '        emit Additional(amount);\n', '    }\n', '\n', '    /**\n', '    *  burn airdrop tokens\n', '    */\n', '    function burn(uint256 amount) public onlyOwner {\n', '        require(amount > 0);\n', '\n', '        totalAirDropToken = totalAirDropToken.sub(amount);\n', '        emit Burn(amount);\n', '    }\n', '\n', '\n', '    /**\n', '     *  The owner of the contract modifies the recovery address of the token\n', '     */\n', '    function modifyCollectorAddress(address newCollectorAddress) public onlyOwner returns (bool) {\n', '        collectorAddress = newCollectorAddress;\n', '    }\n', '\n', '    /**\n', '     *  Recovery of remaining tokens\n', '     */\n', '    function collectAirDropTokenBack(uint256 airDropTokenNum) public onlyOwner {\n', '        require(totalAirDropToken > 0);\n', '        require(collectorAddress != 0x0);\n', '\n', '        if (airDropTokenNum > 0) {\n', '            tokenRewardContract.transfer(collectorAddress, airDropTokenNum * 1e18);\n', '        } else {\n', '            tokenRewardContract.transfer(collectorAddress, totalAirDropToken * 1e18);\n', '            totalAirDropToken = 0;\n', '        }\n', '        emit CollectAirDropTokenBack(collectorAddress, airDropTokenNum);\n', '    }\n', '\n', '    /**\n', '     *  Recovery donated ether\n', '     */\n', '    function collectEtherBack() public onlyOwner {\n', '        uint256 b = address(this).balance;\n', '        require(b > 0);\n', '        require(collectorAddress != 0x0);\n', '\n', '        collectorAddress.transfer(b);\n', '    }\n', '\n', '    /**\n', '     *  Get the tokenAddress token balance of someone\n', '     */\n', '    function getTokenBalance(address tokenAddress, address who) view public returns (uint){\n', '        Erc20Token t = Erc20Token(tokenAddress);\n', '        return t.balanceOf(who);\n', '    }\n', '\n', '    /**\n', '     *  Recycle other ERC20 tokens\n', '     */\n', '    function collectOtherTokens(address tokenContract) onlyOwner public returns (bool) {\n', '        Erc20Token t = Erc20Token(tokenContract);\n', '\n', '        uint256 b = t.balanceOf(address(this));\n', '        return t.transfer(collectorAddress, b);\n', '    }\n', '\n', '}']
