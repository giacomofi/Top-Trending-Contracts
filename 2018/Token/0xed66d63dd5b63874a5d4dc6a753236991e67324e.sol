['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' *  @title Smart City Token https://www.smartcitycoin.io\n', ' *  @dev ERC20 standard compliant / https://github.com/ethereum/EIPs/issues/20 /\n', ' *  @dev Amount not sold during Crowdsale is burned\n', ' */\n', '\n', 'contract SmartCityToken {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;  // address of Token Owner\n', '    address public crowdsale; // address of Crowdsale contract\n', '\n', '    string constant public standard = "ERC20"; // token standard\n', '    string constant public name = "Smart City"; // token name\n', '    string constant public symbol = "CITY"; // token symbol\n', '\n', '    uint256 constant public decimals = 5; // 1 CITY = 100000 tokens\n', '    uint256 public totalSupply = 252862966307692; // total token provision\n', '\n', '    uint256 constant public amountForSale = 164360928100000; // amount that might be sold during ICO - 65% of total token supply\n', '    uint256 constant public amountReserved = 88502038207692; // amount reserved for founders / loyalty / bounties / etc. - 35% of total token supply\n', '    uint256 constant public amountLocked = 61951426745384; // the amount of tokens Owner cannot spend within first 2 years after Crowdsale - 70% of the reserved amount\n', '\n', '    uint256 public startTime; // from this time on transfer and transferFrom functions are available to anyone except of token Owner\n', '    uint256 public unlockOwnerDate; // from this time on transfer and transferFrom functions are available to token Owner\n', '\n', '    mapping(address => uint256) public balances; // balances array\n', '    mapping(address => mapping(address => uint256)) public allowances; // allowances array\n', '\n', '    bool public burned; // indicates whether excess tokens have already been burned\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // Transfer event\n', '    event Approval(address indexed _owner, address indexed spender, uint256 value); // Approval event\n', '    event Burned(uint256 amount); // Burned event\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  @dev Contract initialization\n', '     *  @param _ownerAddress address Token owner address\n', '     *  @param _startTime uint256 Crowdsale end time\n', '     *\n', '     */\n', '    function SmartCityToken(address _ownerAddress, uint256 _startTime) public {\n', '        owner = _ownerAddress; // token Owner\n', '        startTime = _startTime; // token Start Time\n', '        unlockOwnerDate = startTime + 2 years;\n', '        balances[owner] = totalSupply; // all tokens are initially allocated to token owner\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers token for a specified address\n', '     * @param _to address The address to transfer to\n', '     * @param _value uint256 The amount to be transferred\n', '     */\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\n', '        require(now >= startTime);\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        if (msg.sender == owner && now < unlockOwnerDate)\n', '            require(balances[msg.sender].sub(_value) >= amountLocked);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value); // subtract requested amount from the sender address\n', '        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\n', '\n', '        Transfer(msg.sender, _to, _value); // trigger Transfer event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns(bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowances[_from][msg.sender]);\n', '\n', '        if (now < startTime)\n', '            require(_from == owner);\n', '\n', '        if (_from == owner && now < unlockOwnerDate)\n', '            require(balances[_from].sub(_value) >= amountLocked);\n', '\n', '        uint256 _allowance = allowances[_from][msg.sender];\n', '        balances[_from] = balances[_from].sub(_value); // subtract requested amount from the sender address\n', '        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\n', '        allowances[_from][msg.sender] = _allowance.sub(_value); // reduce sender allowance by transferred amount\n', '\n', '        Transfer(_from, _to, _value); // trigger Transfer event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _addr address The address to query the balance of.\n', '     * @return uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _addr) public view returns (uint256 balance) {\n', '        return balances[_addr];\n', '    }\n', '\n', '    /**\n', '     *  @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *  @param _spender address The address which will spend the funds\n', '     *  @param _value uint256 The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\n', '        return _approve(_spender, _value);\n', '    }\n', '\n', '    /**\n', '     *  @dev Workaround for vulnerability described here: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\n', '     */\n', '    function _approve(address _spender, uint256 _value) internal returns(bool success) {\n', '        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\n', '\n', '        allowances[msg.sender][_spender] = _value; // Set spender allowance\n', '\n', '        Approval(msg.sender, _spender, _value); // Trigger Approval event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Burns all the tokens which has not been sold during ICO\n', '     */\n', '    function burn() public {\n', '        if (!burned && now > startTime) {\n', '            uint256 diff = balances[owner].sub(amountReserved); // Get the amount of unsold tokens\n', '\n', '            balances[owner] = amountReserved;\n', '            totalSupply = totalSupply.sub(diff); // Reduce total provision number\n', '\n', '            burned = true;\n', '            Burned(diff); // Trigger Burned event\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  @dev Sets Corwdsale contract address & allowance\n', '     *  @param _crowdsaleAddress address The address of the Crowdsale contract\n', '     */\n', '    function setCrowdsale(address _crowdsaleAddress) public {\n', '        require(msg.sender == owner);\n', '        require(crowdsale == address(0));\n', '\n', '        crowdsale = _crowdsaleAddress;\n', '        assert(_approve(crowdsale, amountForSale));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '    /**\n', '    *            CITY 2.0 token by www.SmartCityCoin.io\n', '    * \n', '    *          .ossssss:                      `+sssss`      \n', '    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \n', '    *            /sssssssssssssssssssssssss+ssssso`        \n', '    *             -sssssssssssssssssssssssssssss+`         \n', '    *            .+sssssssss+:--....--:/ossssssss+.        \n', '    *          `/ssssssssssso`         .sssssssssss/`      \n', '    *         .ossssss+sssssss-       :sssss+:ossssso.     \n', '    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \n', '    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \n', '    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \n', '    *       osssss+        -sssssssssss+`                  \n', '    *       ssssss:         .ossssssss/                    \n', '    *       osssss/          `+ssssss-                     \n', '    *       /ssssso           :ssssss                      \n', '    *       .ssssss-          :ssssss                      \n', '    *        :ssssss-         :ssssss          `           \n', '    *         /ssssss/`       :ssssss        `/s+:`        \n', '    *          :sssssso:.     :ssssss      ./ssssss+`      \n', '    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \n', '    *             .+ssssssssssssssssssssssssssss+-         \n', '    *               `:+ssssssssssssssssssssss+:`           \n', '    *                  `.:+osssssssssssso+:.`              \n', '    *                        `/ssssss.`                    \n', '    *                         :ssssss                      \n', '    */']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' *  @title Smart City Token https://www.smartcitycoin.io\n', ' *  @dev ERC20 standard compliant / https://github.com/ethereum/EIPs/issues/20 /\n', ' *  @dev Amount not sold during Crowdsale is burned\n', ' */\n', '\n', 'contract SmartCityToken {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;  // address of Token Owner\n', '    address public crowdsale; // address of Crowdsale contract\n', '\n', '    string constant public standard = "ERC20"; // token standard\n', '    string constant public name = "Smart City"; // token name\n', '    string constant public symbol = "CITY"; // token symbol\n', '\n', '    uint256 constant public decimals = 5; // 1 CITY = 100000 tokens\n', '    uint256 public totalSupply = 252862966307692; // total token provision\n', '\n', '    uint256 constant public amountForSale = 164360928100000; // amount that might be sold during ICO - 65% of total token supply\n', '    uint256 constant public amountReserved = 88502038207692; // amount reserved for founders / loyalty / bounties / etc. - 35% of total token supply\n', '    uint256 constant public amountLocked = 61951426745384; // the amount of tokens Owner cannot spend within first 2 years after Crowdsale - 70% of the reserved amount\n', '\n', '    uint256 public startTime; // from this time on transfer and transferFrom functions are available to anyone except of token Owner\n', '    uint256 public unlockOwnerDate; // from this time on transfer and transferFrom functions are available to token Owner\n', '\n', '    mapping(address => uint256) public balances; // balances array\n', '    mapping(address => mapping(address => uint256)) public allowances; // allowances array\n', '\n', '    bool public burned; // indicates whether excess tokens have already been burned\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // Transfer event\n', '    event Approval(address indexed _owner, address indexed spender, uint256 value); // Approval event\n', '    event Burned(uint256 amount); // Burned event\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  @dev Contract initialization\n', '     *  @param _ownerAddress address Token owner address\n', '     *  @param _startTime uint256 Crowdsale end time\n', '     *\n', '     */\n', '    function SmartCityToken(address _ownerAddress, uint256 _startTime) public {\n', '        owner = _ownerAddress; // token Owner\n', '        startTime = _startTime; // token Start Time\n', '        unlockOwnerDate = startTime + 2 years;\n', '        balances[owner] = totalSupply; // all tokens are initially allocated to token owner\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers token for a specified address\n', '     * @param _to address The address to transfer to\n', '     * @param _value uint256 The amount to be transferred\n', '     */\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\n', '        require(now >= startTime);\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        if (msg.sender == owner && now < unlockOwnerDate)\n', '            require(balances[msg.sender].sub(_value) >= amountLocked);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value); // subtract requested amount from the sender address\n', '        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\n', '\n', '        Transfer(msg.sender, _to, _value); // trigger Transfer event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns(bool success) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowances[_from][msg.sender]);\n', '\n', '        if (now < startTime)\n', '            require(_from == owner);\n', '\n', '        if (_from == owner && now < unlockOwnerDate)\n', '            require(balances[_from].sub(_value) >= amountLocked);\n', '\n', '        uint256 _allowance = allowances[_from][msg.sender];\n', '        balances[_from] = balances[_from].sub(_value); // subtract requested amount from the sender address\n', '        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\n', '        allowances[_from][msg.sender] = _allowance.sub(_value); // reduce sender allowance by transferred amount\n', '\n', '        Transfer(_from, _to, _value); // trigger Transfer event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _addr address The address to query the balance of.\n', '     * @return uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _addr) public view returns (uint256 balance) {\n', '        return balances[_addr];\n', '    }\n', '\n', '    /**\n', '     *  @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     *  @param _spender address The address which will spend the funds\n', '     *  @param _value uint256 The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\n', '        return _approve(_spender, _value);\n', '    }\n', '\n', '    /**\n', '     *  @dev Workaround for vulnerability described here: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\n', '     */\n', '    function _approve(address _spender, uint256 _value) internal returns(bool success) {\n', '        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\n', '\n', '        allowances[msg.sender][_spender] = _value; // Set spender allowance\n', '\n', '        Approval(msg.sender, _spender, _value); // Trigger Approval event\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Burns all the tokens which has not been sold during ICO\n', '     */\n', '    function burn() public {\n', '        if (!burned && now > startTime) {\n', '            uint256 diff = balances[owner].sub(amountReserved); // Get the amount of unsold tokens\n', '\n', '            balances[owner] = amountReserved;\n', '            totalSupply = totalSupply.sub(diff); // Reduce total provision number\n', '\n', '            burned = true;\n', '            Burned(diff); // Trigger Burned event\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  @dev Sets Corwdsale contract address & allowance\n', '     *  @param _crowdsaleAddress address The address of the Crowdsale contract\n', '     */\n', '    function setCrowdsale(address _crowdsaleAddress) public {\n', '        require(msg.sender == owner);\n', '        require(crowdsale == address(0));\n', '\n', '        crowdsale = _crowdsaleAddress;\n', '        assert(_approve(crowdsale, amountForSale));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '    /**\n', '    *            CITY 2.0 token by www.SmartCityCoin.io\n', '    * \n', '    *          .ossssss:                      `+sssss`      \n', '    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \n', '    *            /sssssssssssssssssssssssss+ssssso`        \n', '    *             -sssssssssssssssssssssssssssss+`         \n', '    *            .+sssssssss+:--....--:/ossssssss+.        \n', '    *          `/ssssssssssso`         .sssssssssss/`      \n', '    *         .ossssss+sssssss-       :sssss+:ossssso.     \n', '    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \n', '    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \n', '    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \n', '    *       osssss+        -sssssssssss+`                  \n', '    *       ssssss:         .ossssssss/                    \n', '    *       osssss/          `+ssssss-                     \n', '    *       /ssssso           :ssssss                      \n', '    *       .ssssss-          :ssssss                      \n', '    *        :ssssss-         :ssssss          `           \n', '    *         /ssssss/`       :ssssss        `/s+:`        \n', '    *          :sssssso:.     :ssssss      ./ssssss+`      \n', '    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \n', '    *             .+ssssssssssssssssssssssssssss+-         \n', '    *               `:+ssssssssssssssssssssss+:`           \n', '    *                  `.:+osssssssssssso+:.`              \n', '    *                        `/ssssss.`                    \n', '    *                         :ssssss                      \n', '    */']
