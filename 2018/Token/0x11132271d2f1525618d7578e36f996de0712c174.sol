['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Token {\n', '\n', '    //uint256 public totalSupply;\n', '    function totalSupply() constant returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    \n', '    //function transfer(address to, uint value, bytes data) returns (bool ok);\n', '    \n', '    //function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ERC223Receiver {\n', '  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '    uint256 _totalSupply;\n', '    \n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        totalSupply = _totalSupply;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            last_seen[msg.sender] = now;\n', '            last_seen[_to] = now;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            last_seen[_from] = now;\n', '            last_seen[_to] = now;\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function lastSeen(address _owner) constant internal returns (uint256 balance) {\n', '        return last_seen[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        last_seen[msg.sender] = now;\n', '        last_seen[_spender] = now;\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    mapping (address => uint256) last_seen;\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  \n', '  function getOwner() view public returns (address){\n', '    return owner;\n', '  }\n', '  \n', '}\n', '\n', 'contract Standard223Receiver is ERC223Receiver {\n', '  Tkn tkn;\n', '\n', '  struct Tkn {\n', '    address addr;\n', '    address sender;\n', '    address origin;\n', '    uint256 value;\n', '    bytes data;\n', '    bytes4 sig;\n', '  }\n', '\n', '  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok) {\n', '    //if (!supportsToken(msg.sender)) return false;\n', '\n', '    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\n', '    tkn = Tkn(msg.sender, _sender, _origin, _value, _data, getSig(_data));\n', '    __isTokenFallback = true;\n', '    if (!address(this).delegatecall(_data)) return false;\n', '\n', '    // avoid doing an overwrite to .token, which would be more expensive\n', '    // makes accessing .tkn values outside tokenPayable functions unsafe\n', '    __isTokenFallback = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  function getSig(bytes _data) private returns (bytes4 sig) {\n', '    uint l = _data.length < 4 ? _data.length : 4;\n', '    for (uint i = 0; i < l; i++) {\n', '      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\n', '    }\n', '  }\n', '\n', '  bool __isTokenFallback;\n', '\n', '  modifier tokenPayable {\n', '    if (!__isTokenFallback) throw;\n', '    _;\n', '  }\n', '\n', '  //function supportsToken(address token) returns (bool);\n', '}\n', '\n', 'contract Standard223Token is StandardToken {\n', '  //function that is called when a user or another contract wants to transfer funds\n', '  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '    //filtering if the target is a contract with bytecode inside it\n', '    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\n', '    last_seen[msg.sender] = now;\n', '    last_seen[_to] = now;\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\n', '    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\n', '    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\n', '    last_seen[_from] = now;\n', '    last_seen[_to] = now;\n', '    return true;\n', '  }\n', '\n', '  //function transfer(address _to, uint _value) returns (bool success) {\n', '    //return transfer(_to, _value, new bytes(0));\n', '  //}\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    return transferFrom(_from, _to, _value, new bytes(0));\n', '    last_seen[_from] = now;\n', '    last_seen[_to] = now;\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\n', '    ERC223Receiver reciever = ERC223Receiver(_to);\n', '    return reciever.tokenFallback(msg.sender, _origin, _value, _data);\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) private returns (bool is_contract) {\n', '    // retrieve the size of the code on target address, this needs assembly\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    return length > 0;\n', '  }\n', '}\n', '\n', 'contract Ciphs is Standard223Receiver, Standard223Token, Ownable {\n', '\n', '  using SafeMath for uint256;\n', '  \n', '  string public constant name = "Ciphs";\n', '  string public constant symbol = "CIPHS";\n', '  uint8 public constant decimals = 18;\n', '\n', '  uint256 public rate = 10000000000000000000000;\n', '  bool propose = false;\n', '  uint256 prosposal_time = 0;\n', '  uint256 raisedAmount = 0;\n', '  uint256 public constant INITIAL_SUPPLY = 7000000e18;\n', '  uint256 public constant MAX_SUPPLY = 860000000000e18;\n', '  //uint256 public totalSupply;\n', '  address[] investors;\n', '  \n', '  uint256 up = 0;\n', '  uint256 down = 0;\n', '\n', '  mapping(address => uint256) votes;\n', '  mapping (address => mapping (address => uint256)) public trackable;\n', '  mapping (address => mapping (uint => uint256)) public trackable_record;\n', '  \n', '  mapping (address => uint256) public bannable;\n', '  mapping (address => uint256) internal support_ban;\n', '  mapping (address => uint256) internal against_ban;\n', '\n', '  //event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  //event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event BoughtTokens(address indexed to, uint256 value);\n', '  event Votes(address indexed owner, uint256 value);\n', '  event Burn(address indexed burner, uint256 value);\n', '  event Mint(uint256 value);\n', '  \n', '  function Ciphs() public {\n', '    _totalSupply = INITIAL_SUPPLY;\n', '    balances[msg.sender] = INITIAL_SUPPLY;\n', '  }\n', '\n', '  function initialize_proposal() public {\n', '\n', '    if(propose) throw;\n', '    propose = true;\n', '    prosposal_time = now;\n', '\n', '  }\n', '  \n', '  function is_proposal_supported() public returns (bool) {\n', '    if(!propose) throw;\n', '    if(down.mul(4) < up)\n', '    {\n', '        return false;\n', '    }else{\n', '        return true;\n', '    }\n', '  }\n', '\n', '  modifier canMint() {\n', '    if(propose && is_proposal_supported() && now > prosposal_time.add(7 * 1 days))\n', '    _;\n', '    else\n', '    throw;\n', '  }\n', '  \n', '  function distribute_token()\n', '  {\n', '       uint256 investors_num = investors.length;\n', '       uint256 amount = (1000000e18-1000)/investors_num;\n', '       for(var i = 0; i < investors_num; i++)\n', '       {\n', '           if(last_seen[investors[i]].add(90 * 1 days) > now)\n', '           {\n', '                balances[investors[i]] += amount;\n', '                last_seen[investors[i]] = now;\n', '            }\n', '       }\n', '    }\n', '\n', '\n', '  function mint() /*canMint*/ public returns (bool) {\n', '    \n', '    if(propose && now >= prosposal_time.add(7 * 1 days)){\n', '        uint256 _amount = 1000000e18;\n', '        _totalSupply = _totalSupply.add(_amount);\n', '        if(_totalSupply <= MAX_SUPPLY && is_proposal_supported())\n', '        {\n', '            balances[owner] = balances[owner].add(1000);\n', '            //Transfer(address(0), _to, _amount);\n', '            propose = false;\n', '            prosposal_time = 0;\n', '            up = 0;\n', '            down = 0;\n', '            distribute_token();\n', '            Mint(_amount);\n', '            return true;\n', '        }else{\n', '            propose = false;\n', '            prosposal_time = 0;\n', '            up = 0;\n', '            down = 0;\n', '            //return true;\n', '        }\n', '        \n', '    }\n', '    last_seen[msg.sender] = now;\n', '    //return false;\n', '  }\n', '\n', '  function support_proposal() public returns (bool) {\n', '    if(!propose || votes[msg.sender] == 1) throw;\n', '    //first check balance to be more than 100 Ciphs\n', '    if(balances[msg.sender] > 100e18)\n', '    {\n', '        //only vote once\n', '        votes[msg.sender] = 1;\n', '        up++;\n', '        mint();\n', '        Votes(msg.sender, 1);\n', '        return true;\n', '\n', '    }else\n', '    {\n', '        //no sufficient funds to carry out voting consensus\n', '        return false;\n', '    }\n', '  }\n', '\n', '  function against_proposal() public returns (bool) {\n', '    if(!propose || votes[msg.sender] == 1) throw;\n', '    //first check balance to be more than 100 Ciphs\n', '    if(balances[msg.sender] > 100e18)\n', '    {\n', '        //only vote once\n', '        votes[msg.sender] = 1;\n', '        down++;\n', '        mint();\n', '        Votes(msg.sender, 1);\n', '        return true;\n', '\n', '    }else\n', '    {\n', '        //no sufficient funds to carry out voting consensus\n', '        return false;\n', '    }\n', '  }\n', '  \n', '  function ban_account(address _bannable_address) internal{\n', '        if(balances[_bannable_address] > 0)\n', '        {\n', '          transferFrom(_bannable_address, owner, balances[_bannable_address]);\n', '        }\n', '        delete balances[_bannable_address];\n', '        \n', '        uint256 investors_num = investors.length;\n', '        for(var i = 0; i < investors_num; i++)\n', '        {\n', '            if(investors[i] == _bannable_address){\n', '                delete investors[i];\n', '            }\n', '        }\n', '      //delete investors[];\n', '  }\n', '  \n', '  function ban_check(address _bannable_address) internal\n', '  {\n', '    last_seen[msg.sender] = now;\n', '    //uint256 time_diff = now.sub(bannable[_bannable_address]); \n', '    if(now.sub(bannable[_bannable_address]) > 0.5 * 1 days)\n', '    {\n', '        if(against_ban[_bannable_address].mul(4) < support_ban[_bannable_address])\n', '        {\n', '            ban_account(_bannable_address);\n', '        }\n', '    }\n', '  }\n', '  \n', '  function initialize_bannable(address _bannable_address) public {\n', '    bannable[_bannable_address] = now;\n', '    last_seen[msg.sender] = now;\n', '  }\n', '  \n', '  function support_ban_of(address _bannable_address) public\n', '  {\n', '    require(bannable[_bannable_address] > 0);\n', '    support_ban[_bannable_address] = support_ban[_bannable_address].add(1);\n', '    ban_check(_bannable_address);\n', '  }\n', '  \n', '  function against_ban_of(address _bannable_address) public\n', '  {\n', '    require(bannable[_bannable_address] > 0);\n', '    against_ban[_bannable_address] = against_ban[_bannable_address].add(1);\n', '    ban_check(_bannable_address);\n', '  }\n', '\n', '  function track(address _trackable) public returns (bool) {\n', '    // "trackable added, vote like or dislike using the address registered with the trackable";\n', '    trackable[_trackable][msg.sender] = 1;\n', '    last_seen[msg.sender] = now;\n', '    return true;\n', '  }\n', '\n', '  function like_trackable(address _trackable) public returns (bool) {\n', '    last_seen[msg.sender] = now;\n', '    if(trackable[_trackable][msg.sender] != 1)\n', '    {\n', '        trackable[_trackable][msg.sender] = 1;\n', '        trackable_record[_trackable][1] = trackable_record[_trackable][1] + 1;\n', '        return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function dislike_trackable(address _trackable) public returns (bool) {\n', '    last_seen[msg.sender] = now;\n', '    if(trackable[_trackable][msg.sender] != 1)\n', '    {\n', '        trackable[_trackable][msg.sender] = 1;\n', '        trackable_record[_trackable][2] = trackable_record[_trackable][2] + 1;\n', '        return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function trackable_likes(address _trackable) public returns (uint256) {\n', '    uint256 num = 0;\n', '    //if(trackable[_trackable])\n', '    //{\n', '\n', '        num = trackable_record[_trackable][1];\n', '\n', '    //}\n', '    return num;\n', '  }\n', '\n', '  function trackable_dislikes(address _trackable) public returns (uint256) {\n', '    uint256 num = 0;\n', '    num = trackable_record[_trackable][2];\n', '    return num;\n', '  }\n', '    \n', '  function () public payable {\n', '\n', '    buyTokens();\n', '\n', '  }\n', '   \n', '  function buyTokens() public payable {\n', '      \n', '    //require(propose);\n', '    \n', '    uint256 weiAmount = msg.value;\n', '    uint256 tokens = weiAmount.mul(getRate());\n', '    \n', '    tokens = tokens.div(1 ether);\n', '    \n', '    BoughtTokens(msg.sender, tokens);\n', '\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    _totalSupply.sub(tokens);\n', '\n', '    raisedAmount = raisedAmount.add(msg.value);\n', '    \n', '    investors.push(msg.sender) -1;\n', '    \n', '    last_seen[msg.sender] = now;\n', '    //owner.transfer(msg.value);\n', '  }\n', '  \n', '  function getInvestors() view public returns (address[]){\n', '      return investors;\n', '  }\n', '\n', '  function setRate(uint256 _rate) public onlyOwner{\n', '      rate = _rate;\n', '  }\n', '  \n', '  function getRate() public constant returns (uint256){\n', '      \n', '      return rate;\n', '      \n', '  }\n', '\n', '  function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        Burn(msg.sender, _value);\n', '        last_seen[msg.sender] = now;\n', '  }\n', '  \n', '   function sendEtherToOwner() public onlyOwner {                       \n', '      owner.transfer(this.balance);\n', '  }\n', '\n', '  function destroy() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '}']