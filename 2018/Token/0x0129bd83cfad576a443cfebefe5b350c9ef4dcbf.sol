['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library Percent {\n', '  using SafeMath for uint256;\n', '  /**\n', '   * @dev Add percent to numerator variable with precision\n', '   */\n', '  function perc\n', '  (\n', '    uint256 initialValue,\n', '    uint256 percent\n', '  ) \n', '    internal \n', '    pure \n', '    returns(uint256 result) \n', '  { \n', '    return initialValue.div(100).mul(percent);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' * See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * Supports unlimited numbers of roles and addresses.\n', ' * See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' * for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' * to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address indexed operator, string role);\n', '  event RoleRemoved(address indexed operator, string role);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address _operator, string _role)\n', '    view\n', '    public\n', '  {\n', '    roles[_role].check(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address _operator, string _role)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[_role].has(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function addRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].add(_operator);\n', '    emit RoleAdded(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function removeRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].remove(_operator);\n', '    emit RoleRemoved(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string _role)\n', '  {\n', '    checkRole(msg.sender, _role);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\n', '        require(token.approve(spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title TokenVesting\n', ' * @dev A token holder contract that can release its token balance gradually like a\n', ' * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n', ' * owner.\n', ' */\n', 'contract TokenVesting is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // Token release event, emits once owner releasing his tokens \n', '  event Released(uint256 amount);\n', '\n', '  // Token revoke event\n', '  event Revoked();\n', '\n', '  // beneficiary of tokens after they are released\n', '  address public beneficiary;\n', '\n', '  // start\n', '  uint256 public start;\n', '\n', '  /**\n', '   * Variables for setup vesting and release periods\n', '   */\n', '  uint256 public duration = 23667695;\n', '  uint256 public firstStage = 7889229;\n', '  uint256 public secondStage = 15778458;\n', '  \n', '\n', '  bool public revocable;\n', '\n', '  mapping (address => uint256) public released;\n', '  mapping (address => bool) public revoked;\n', '\n', '  /**\n', '   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n', '   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n', '   * of the balance will have vested.\n', '   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n', '   * @param _start the time (as Unix time) at which point vesting starts \n', '   * @param _revocable whether the vesting is revocable or not\n', '   */\n', '  constructor(\n', '    address _beneficiary,\n', '    uint256 _start,\n', '    bool _revocable\n', '  )\n', '    public\n', '  {\n', '    require(_beneficiary != address(0));\n', '    beneficiary = _beneficiary;\n', '    revocable = _revocable;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers vested tokens to beneficiary.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function release(ERC20 token) public {\n', '    uint256 unreleased = releasableAmount(token);\n', '\n', '    require(unreleased > 0);\n', '\n', '    released[token] = released[token].add(unreleased);\n', '\n', '    token.transfer(beneficiary, unreleased);\n', '\n', '    emit Released(unreleased);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the owner to revoke the vesting. Tokens already vested\n', '   * remain in the contract, the rest are returned to the owner.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function revoke(ERC20 token) public onlyOwner {\n', '    require(revocable);\n', '    require(!revoked[token]);\n', '\n', '    uint256 balance = token.balanceOf(this);\n', '\n', '    uint256 unreleased = releasableAmount(token);\n', '    uint256 refund = balance.sub(unreleased);\n', '\n', '    revoked[token] = true;\n', '\n', '    token.transfer(owner, refund);\n', '\n', '    emit Revoked();\n', '  }\n', '\n', '  /**\n', "   * @dev Calculates the amount that has already vested but hasn't been released yet.\n", '   * @param token ERC20 token which is being vested\n', '   */\n', '  function releasableAmount(ERC20 token) public view returns (uint256) {\n', '    return vestedAmount(token).sub(released[token]);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the amount that has already vested.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function vestedAmount(ERC20 token) public view returns (uint256) {\n', '    uint256 currentBalance = token.balanceOf(this);\n', '    uint256 totalBalance = currentBalance.add(released[token]);\n', '\n', '    if (block.timestamp >= start.add(duration) || revoked[token]) {\n', '      return totalBalance;\n', '    } \n', '\n', '    if(block.timestamp >= start.add(firstStage) && block.timestamp <= start.add(secondStage)){\n', '      return totalBalance.div(3);\n', '    }\n', '\n', '    if(block.timestamp >= start.add(secondStage) && block.timestamp <= start.add(duration)){\n', '      return totalBalance.div(3).mul(2);\n', '    }\n', '\n', '    return 0;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', '   * @dev Throws if operator is not whitelisted.\n', '   * @param _operator address\n', '   */\n', '  modifier onlyIfWhitelisted(address _operator) {\n', '    checkRole(_operator, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address _operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      addAddressToWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      removeAddressFromWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', '\n', 'contract TokenDestructible is Ownable {\n', '\n', '  constructor() public payable { }\n', '\n', '  /**\n', '   * @notice Terminate contract and refund to owner\n', '   * @notice The called token contracts could try to re-enter this contract. Only\n', '   supply token contracts you trust.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', '\n', 'contract Token is PausableToken, TokenDestructible {\n', '  /**\n', '   * Variables that define basic token features\n', '   */ \n', '  uint256 public decimals;\n', '  string public name;\n', '  string public symbol;\n', '  uint256 releasedAmount = 0;\n', '\n', '  constructor(uint256 _totalSupply, uint256 _decimals, string _name, string _symbol) public {\n', '    require(_totalSupply > 0);\n', '    require(_decimals > 0);\n', '\n', '    totalSupply_ = _totalSupply;\n', '    decimals = _decimals;\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    balances[msg.sender] = _totalSupply;\n', '\n', '    // transfer all supply to the owner\n', '    emit Transfer(address(0), msg.sender, _totalSupply);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Allocation\n', ' * Allocation is a base contract for managing a token sale,\n', ' * allowing investors to purchase tokens with ether.\n', ' */\n', 'contract Allocation is Whitelist {\n', '  using SafeMath for uint256;\n', '  using Percent for uint256;\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '\n', '  event Finalized();\n', '\n', '  /**\n', '   * Event for creation of token vesting contract\n', '   * @param beneficiary who will receive tokens \n', '   * @param start time of vesting start\n', '   * @param revocable specifies if vesting contract has abitility to revoke\n', '   */\n', '  event TimeVestingCreation\n', '  (\n', '    address beneficiary,\n', '    uint256 start,\n', '    uint256 duration,\n', '    bool revocable\n', '  );\n', '\n', '  struct PartInfo {\n', '    uint256 percent;\n', '    bool lockup;\n', '    uint256 amount;\n', '  }\n', '\n', '  mapping (address => bool) public owners;\n', '  mapping (address => uint256) public contributors;            \n', '  mapping (address => TokenVesting) public vesting;\n', '  mapping (uint256 => PartInfo) public pieChart;\n', '  mapping (address => bool) public isInvestor;\n', '  \n', '  address[] public investors;\n', '\n', '  /**\n', '   * Variables for bonus program\n', '   * ============================\n', '   * Variables values are test!!!\n', '   */\n', '  uint256 private SMALLEST_SUM; // 971911700000000000\n', '  uint256 private SMALLER_SUM;  // 291573500000000000000\n', '  uint256 private MEDIUM_SUM;   // 485955800000000000000\n', '  uint256 private BIGGER_SUM;   // 971911700000000000000\n', '  uint256 private BIGGEST_SUM;  // 1943823500000000000000\n', '\n', '  // Vesting period\n', '  uint256 public duration = 23667695;\n', '\n', '  // Flag of Finalized sale event\n', '  bool public isFinalized = false;\n', '\n', '  // Wei raides accumulator\n', '  uint256 public weiRaised = 0;\n', '\n', '  //\n', '  Token public token;\n', '  //\n', '  address public wallet;\n', '  uint256 public rate;  \n', '  uint256 public softCap;\n', '  uint256 public hardCap;\n', '\n', '  /**\n', '   * @param _rate Number of token units a buyer gets per wei\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   * @param _softCap Soft cap\n', '   * @param _hardCap Hard cap\n', '   * @param _smallestSum Sum after which investor receives 5% of bonus tokens to vesting contract\n', '   * @param _smallerSum Sum after which investor receives 10% of bonus tokens to vesting contract\n', '   * @param _mediumSum Sum after which investor receives 15% of bonus tokens to vesting contract\n', '   * @param _biggerSum Sum after which investor receives 20% of bonus tokens to vesting contract\n', '   * @param _biggestSum Sum after which investor receives 30% of bonus tokens to vesting contract\n', '   */\n', '  constructor(\n', '    uint256 _rate, \n', '    address _wallet, \n', '    Token _token,\n', '    uint256 _softCap,\n', '    uint256 _hardCap,\n', '    uint256 _smallestSum,\n', '    uint256 _smallerSum,\n', '    uint256 _mediumSum,\n', '    uint256 _biggerSum,\n', '    uint256 _biggestSum\n', '  ) \n', '    public \n', '  {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    require(_hardCap > 0);\n', '    require(_softCap > 0);\n', '    require(_hardCap > _softCap);\n', '\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    token = _token;\n', '    hardCap = _hardCap;\n', '    softCap = _softCap;\n', '\n', '    SMALLEST_SUM = _smallestSum;\n', '    SMALLER_SUM = _smallerSum;\n', '    MEDIUM_SUM = _mediumSum;\n', '    BIGGER_SUM = _biggerSum;\n', '    BIGGEST_SUM = _biggestSum;\n', '\n', '    owners[msg.sender] = true;\n', '\n', '    /**\n', '    * Pie chart \n', '    *\n', '    * early cotributors => 1\n', '    * management team => 2\n', '    * advisors => 3\n', '    * partners => 4\n', '    * community => 5\n', '    * company => 6\n', '    * liquidity => 7\n', '    * sale => 8\n', '    */\n', '    pieChart[1] = PartInfo(10, true, token.totalSupply().mul(10).div(100));\n', '    pieChart[2] = PartInfo(15, true, token.totalSupply().mul(15).div(100));\n', '    pieChart[3] = PartInfo(5, true, token.totalSupply().mul(5).div(100));\n', '    pieChart[4] = PartInfo(5, false, token.totalSupply().mul(5).div(100));\n', '    pieChart[5] = PartInfo(8, false, token.totalSupply().mul(8).div(100));\n', '    pieChart[6] = PartInfo(17, false, token.totalSupply().mul(17).div(100));\n', '    pieChart[7] = PartInfo(10, false, token.totalSupply().mul(10).div(100));\n', '    pieChart[8] = PartInfo(30, false, token.totalSupply().mul(30).div(100));\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Allocation external interface\n', '  // -----------------------------------------\n', '  /**\n', '   * Function for buying tokens\n', '   */\n', '  function() \n', '    external \n', '    payable \n', '  {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   *  Check if value respects sale minimal contribution sum\n', '   */\n', '  modifier respectContribution() {\n', '    require(\n', '      msg.value >= SMALLEST_SUM,\n', '      "Minimum contribution is $50,000"\n', '    );\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Check if sale is still open\n', '   */\n', '  modifier onlyWhileOpen {\n', '    require(!isFinalized, "Sale is closed");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Check if sender is owner\n', '   */\n', '  modifier onlyOwner {\n', '    require(isOwner(msg.sender) == true, "User is not in Owners");\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * Add new owner\n', '   * @param _owner Address of owner which should be added\n', '   */\n', '  function addOwner(address _owner) public onlyOwner {\n', '    require(owners[_owner] == false);\n', '    owners[_owner] = true;\n', '  }\n', '\n', '  /**\n', '   * Delete an onwer\n', '   * @param _owner Address of owner which should be deleted\n', '   */\n', '  function deleteOwner(address _owner) public onlyOwner {\n', '    require(owners[_owner] == true);\n', '    owners[_owner] = false;\n', '  }\n', '\n', '  /**\n', '   * Check if sender is owner\n', '   * @param _address Address of owner which should be checked\n', '   */\n', '  function isOwner(address _address) public view returns(bool res) {\n', '    return owners[_address];\n', '  }\n', '  \n', '  /**\n', '   * Allocate tokens to provided investors\n', '   */\n', '  function allocateTokens(address[] _investors) public onlyOwner {\n', '    require(_investors.length <= 50);\n', '    \n', '    for (uint i = 0; i < _investors.length; i++) {\n', '      allocateTokensInternal(_investors[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Allocate tokens to a single investor\n', '   * @param _contributor Address of the investor\n', '   */\n', '  function allocateTokensForContributor(address _contributor) public onlyOwner {\n', '    allocateTokensInternal(_contributor);\n', '  }\n', '\n', '  /*\n', '   * Allocates tokens to single investor\n', '   * @param _contributor Investor address\n', '   */\n', '  function allocateTokensInternal(address _contributor) internal {\n', '    uint256 weiAmount = contributors[_contributor];\n', '\n', '    if (weiAmount > 0) {\n', '      uint256 tokens = _getTokenAmount(weiAmount);\n', '      uint256 bonusTokens = _getBonusTokens(weiAmount);\n', '\n', '      pieChart[8].amount = pieChart[8].amount.sub(tokens);\n', '      pieChart[1].amount = pieChart[1].amount.sub(bonusTokens);\n', '\n', '      contributors[_contributor] = 0;\n', '\n', '      token.transfer(_contributor, tokens);\n', '      createTimeBasedVesting(_contributor, bonusTokens);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * Send funds from any part of pieChart\n', '   * @param _to Investors address\n', '   * @param _type Part of pieChart\n', '   * @param _amount Amount of tokens\n', '   */\n', '  function sendFunds(address _to, uint256 _type, uint256 _amount) public onlyOwner {\n', '    require(\n', '      pieChart[_type].amount >= _amount &&\n', '      _type >= 1 &&\n', '      _type <= 8\n', '    );\n', '\n', '    if (pieChart[_type].lockup == true) {\n', '      createTimeBasedVesting(_to, _amount);\n', '    } else {\n', '      token.transfer(_to, _amount);\n', '    }\n', '    \n', '    pieChart[_type].amount -= _amount;\n', '  }\n', '\n', '  /**\n', '   * Investment receiver\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable {\n', '    uint256 weiAmount = msg.value;\n', '\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created without bonuses\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '\n', '    // update \n', '    contributors[_beneficiary] += weiAmount;\n', '\n', '    if(!isInvestor[_beneficiary]){\n', '      investors.push(_beneficiary);\n', '      isInvestor[_beneficiary] = true;\n', '    }\n', '    \n', '    _forwardFunds();\n', '\n', '    emit TokenPurchase(\n', '      msg.sender,\n', '      _beneficiary,\n', '      weiAmount,\n', '      tokens\n', '    );\n', '  }\n', '\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '  /**\n', '   * Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase\n', '  (\n', '    address _beneficiary,\n', '    uint256 _weiAmount\n', '  )\n', '    onlyIfWhitelisted(_beneficiary)\n', '    respectContribution\n', '    onlyWhileOpen\n', '    view\n', '    internal\n', '  {\n', '    require(weiRaised.add(_weiAmount) <= hardCap);\n', '    require(_beneficiary != address(0));\n', '  }\n', '\n', '  /**\n', '   * Create vesting contract\n', '   * @param _beneficiary address of person who will get all tokens as vesting ends\n', '   * @param _tokens amount of vested tokens\n', '   */\n', '  function createTimeBasedVesting\n', '  (\n', '    address _beneficiary,\n', '    uint256 _tokens\n', '  )\n', '    internal\n', '  {\n', '    uint256 _start = block.timestamp;\n', '\n', '    TokenVesting tokenVesting;\n', '\n', '    if (vesting[_beneficiary] == address(0)) {\n', '      tokenVesting = new TokenVesting(_beneficiary, _start, false);\n', '      vesting[_beneficiary] = tokenVesting;\n', '    } else {\n', '      tokenVesting = vesting[_beneficiary];\n', '    }\n', '\n', '    token.transfer(address(tokenVesting), _tokens);\n', '\n', '    emit TimeVestingCreation(_beneficiary, _start, duration, false);\n', '  }\n', '\n', '\n', '  /**\n', '   *  checks if sale is closed\n', '   */\n', '  function hasClosed() public view returns (bool) {\n', '    return isFinalized;\n', '  }\n', '\n', '  /** \n', '   * Release tokens from vesting contract\n', '   */\n', '  function releaseVestedTokens() public {\n', '    address beneficiary = msg.sender;\n', '    require(vesting[beneficiary] != address(0));\n', '\n', '    TokenVesting tokenVesting = vesting[beneficiary];\n', '    tokenVesting.release(token);\n', '  }\n', '\n', '  /**\n', '   * Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getBonusTokens\n', '  (\n', '    uint256 _weiAmount\n', '  )\n', '    internal\n', '    view\n', '    returns (uint256 purchasedAmount)\n', '  {\n', '    purchasedAmount = _weiAmount;\n', '\n', '    if (_weiAmount >= SMALLEST_SUM && _weiAmount < SMALLER_SUM) {\n', '      purchasedAmount = _weiAmount.perc(5);\n', '    }\n', '\n', '    if (_weiAmount >= SMALLER_SUM && _weiAmount < MEDIUM_SUM) {\n', '      purchasedAmount = _weiAmount.perc(10);\n', '    }\n', '\n', '    if (_weiAmount >= MEDIUM_SUM && _weiAmount < BIGGER_SUM) {\n', '      purchasedAmount = _weiAmount.perc(15);\n', '    }\n', '\n', '    if (_weiAmount >= BIGGER_SUM && _weiAmount < BIGGEST_SUM) {\n', '      purchasedAmount = _weiAmount.perc(20);\n', '    }\n', '\n', '    if (_weiAmount >= BIGGEST_SUM) {\n', '      purchasedAmount = _weiAmount.perc(30);\n', '    }\n', '\n', '    return purchasedAmount.mul(rate);\n', '  }\n', '\n', '  function _getTokenAmount\n', '  (\n', '    uint256 _weiAmount\n', '  )\n', '    internal\n', '    view\n', '    returns (uint256 purchasedAmount)\n', '  {\n', '    return _weiAmount.mul(rate);\n', '  }\n', '\n', '  /**\n', '   * Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '\n', '  /**\n', '   * Must be called after sale ends, to do some extra finalization\n', "   * work. Calls the contract's finalization function.\n", '   */\n', '  function finalize() public onlyOwner {\n', '    require(!hasClosed());\n', '    finalization();\n', '    isFinalized = true;\n', '    emit Finalized();\n', '  } \n', '\n', '\n', '  /**\n', '   * Can be overridden to add finalization logic. The overriding function\n', '   * should call super.finalization() to ensure the chain of finalization is\n', '   * executed entirely.\n', '   */\n', '  function finalization() pure internal {}\n', '\n', '}']