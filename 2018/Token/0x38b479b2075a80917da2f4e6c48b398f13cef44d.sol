['pragma solidity ^0.4.21;\n', '\n', 'contract KittyRace {\n', '    struct Race {\n', '        uint32 blockJoinedFirstRacer;\n', '        uint32 blockJoinedLastRacer;\n', '        Racer[] racers;\n', '    }\n', '\n', '    struct Racer {\n', '        address kittyOwner;\n', '        uint256 kittyId;\n', '    }\n', '\n', '    event RegisterEvent(\n', '        uint32 raceId,\n', '        address kittyAddress,\n', '        uint256 kittyId,\n', '        uint256 position\n', '    );\n', '\n', '    event RaceEvent(\n', '        uint32 raceId,\n', '        uint256 numRacers,\n', '        uint256 winnerKittyId\n', '    );\n', '\n', '    event PayoutEvent(\n', '        uint32 raceId,\n', '        address winnerKittyAddress,\n', '        uint256 winnerAmount,\n', '        bool winnerTxError,\n', '        address processingAddress,\n', '        uint256 processingAmount,\n', '        bool processingTxError\n', '    );\n', '\n', '    // Contract owner\n', '    address public owner;\n', '\n', '    // KittyCore contract reference\n', '    address public kittyCoreAddress;\n', '    KittyCoreI kittyCore;\n', '\n', '    // Pause button\n', '    bool gameOn = true;\n', '\n', '    // Precise payment value required to registerForRace(). This can be\n', '    // updated by the owner role as the gas or fiat prices adjust.\n', '    uint256 public entryFee = 0.005 ether;\n', '    uint256 public processingFee = 0.0005 ether; // paid from each entry fee to whoever successfully calls race() function\n', '    uint8 public registrationPeriod = 25; // number of blocks after race creation others can join\n', '    uint8 public maxRacers = 10; // maximum number of racers allowed for single race\n', '\n', '    uint32 public raceId = 0;\n', '    mapping (uint256 => Race) public races;\n', '    mapping (uint256 => bool) public activeRacers;\n', '    mapping (uint256 => bool) public completedRaces;\n', '\n', '    // Slight advantage for Kitties with the following genes\n', '    uint256[][] geneMasks = [\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000000b00000), uint256(2) ], // jaguar (D) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000016000000), uint256(1) ], // jaguar (R1) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000000900000), uint256(2) ], // luckystripe (D) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000012000000), uint256(1) ], // luckystripe (R1) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000019000000000000000), uint256(2) ], // wingtips (D) - eyes\n', '        [ uint256(0x0000000000000000000000000000000000000000000000320000000000000000), uint256(1) ], // wingtips (R1) - eyes\n', '        [ uint256(0x0000000000000000000000000000000000000000000500000000000000000000), uint256(2) ], // mauveover (D) - colorbody\n', '        [ uint256(0x000000000000000000000000000000000000000000a000000000000000000000), uint256(1) ], // mauveover (R1) - colorbody\n', '        [ uint256(0x00000000000000000000000000000000000000c0000000000000000000000000), uint256(2) ], // coffee (D) - color\n', '        [ uint256(0x0000000000000000000000000000000000001800000000000000000000000000), uint256(1) ]  // coffee (R1) - color\n', '    ];\n', '\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    function KittyRace(address _kittyCoreAddress) public {\n', '        owner = msg.sender;\n', '        kittyCoreAddress = _kittyCoreAddress;\n', '        kittyCore = KittyCoreI(kittyCoreAddress);\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        // Contract cannot be killed after midnight, April 1, 2018 (Pacific)\n', '        require(now < 1522566000);\n', '\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function setEntryFee(uint256 _entryFee) public onlyOwner { entryFee = _entryFee; }\n', '    function setProcessingFee(uint256 _processingFee) public onlyOwner { processingFee = _processingFee; }\n', '    function setRegistrationPeriod(uint8 _registrationPeriod) public onlyOwner { registrationPeriod = _registrationPeriod; }\n', '    function setMaxRacers(uint8 _maxRacers) public onlyOwner { maxRacers = _maxRacers; }\n', '    function setGameOn(bool _gameOn) public onlyOwner { gameOn = _gameOn; }\n', '\n', '    function setKittyCoreAddress(address _kittyCoreAddress)\n', '        public\n', '        onlyOwner\n', '    {\n', '        kittyCoreAddress = _kittyCoreAddress;\n', '        kittyCore = KittyCoreI(kittyCoreAddress);\n', '    }\n', '\n', '    function getRace(uint32 _raceId)\n', '        public\n', '        view\n', '        returns (uint256 blockJoinedFirstRacer, uint256 blockJoinedLastRacer, uint256 numRacers)\n', '    {\n', '        return (races[_raceId].blockJoinedFirstRacer, races[_raceId].blockJoinedLastRacer, races[_raceId].racers.length);\n', '    }\n', '\n', '    function getRacer(uint32 _raceId, uint256 _racerIndex)\n', '        public\n', '        view\n', '        returns (address kittyOwner, uint256 kittyId)\n', '    {\n', '        Racer storage racer = races[_raceId].racers[_racerIndex];\n', '        return (racer.kittyOwner, racer.kittyId);\n', '    }\n', '\n', '    function registerForRace(uint256 _kittyId)\n', '        external\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        require(gameOn);\n', '\n', '        // Confirm precise entry fee was provided\n', '        require(msg.value == entryFee);\n', '\n', '        // Confirm sender owns the Kitty\n', '        require(msg.sender == kittyCore.ownerOf(_kittyId));\n', '\n', '        // Confirm Kitty is not currently in another race\n', '        require(activeRacers[_kittyId] != true);\n', '\n', '        Race storage race = races[raceId];\n', '\n', '        // Create new race if current race is completed or full\n', '        if (completedRaces[raceId] || race.racers.length >= maxRacers) {\n', '            raceId += 1;\n', '            race = races[raceId];\n', '        }\n', '\n', '        // Separated from statement above to function for first racer of first race\n', '        if (race.racers.length == 0) {\n', '            race.blockJoinedFirstRacer = uint32(block.number);\n', '        }\n', '        race.blockJoinedLastRacer = uint32(block.number);\n', '\n', '        Racer memory racer = Racer({\n', '            kittyOwner: msg.sender,\n', '            kittyId: _kittyId\n', '        });\n', '\n', '        race.racers.push(racer);\n', '\n', '        activeRacers[_kittyId] = true;\n', '\n', '        emit RegisterEvent(\n', '            raceId,\n', '            racer.kittyOwner,\n', '            racer.kittyId,\n', '            race.racers.length - 1 // Race position\n', '        );\n', '\n', '        return raceId;\n', '    }\n', '\n', '    function race(uint32 _raceId)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        uint256 numRacers = races[_raceId].racers.length;\n', '\n', '        // Is race full, if not, have racers had enough time to join?\n', '        require(numRacers >= maxRacers || block.number > races[_raceId].blockJoinedFirstRacer + registrationPeriod);\n', '\n', '        // Enough unique block hashes to provide random roll for each racer?\n', '        require(block.number > races[_raceId].blockJoinedLastRacer + numRacers);\n', '\n', '        Racer memory racer;\n', '        Racer memory winner = races[_raceId].racers[0];\n', '        uint8 raceScore;\n', '        uint8 highScore = 0;\n', '\n', '        // Calc finishing order\n', '        for(uint i = 0; i < numRacers; i++) {\n', '            racer = races[_raceId].racers[i];\n', '            // Genetic skill score\n', '            raceScore = getKittySkillScore(racer.kittyId);\n', '            // Random chance score\n', '            raceScore += uint8(block.blockhash(races[_raceId].blockJoinedLastRacer + numRacers - i)) % 20;\n', '            // First and second entry incentives\n', '            if (i == 0) { raceScore += 2; } // First to join\n', '            if (i == 1) { raceScore += 1; } // Second to join\n', '\n', '            if (raceScore > highScore) {\n', '                winner = racer;\n', '                highScore = raceScore;\n', '            }\n', '\n', '            delete activeRacers[racer.kittyId];\n', '        }\n', '\n', '        emit RaceEvent(\n', '            _raceId,\n', '            numRacers,\n', '            winner.kittyId\n', '        );\n', '\n', '        emit PayoutEvent(\n', '            _raceId,\n', '            winner.kittyOwner,\n', '            (entryFee * numRacers) - (processingFee * numRacers),\n', '            !winner.kittyOwner.send((entryFee * numRacers) - (processingFee * numRacers)),\n', '            msg.sender,\n', '            processingFee * numRacers,\n', '            !msg.sender.send(processingFee * numRacers)\n', '        );\n', '\n', '        completedRaces[_raceId] = true;\n', '        delete races[_raceId];\n', '\n', '        return winner.kittyId;\n', '    }\n', '\n', '    function getKittySkillScore(uint256 _kittyId)\n', '        private\n', '        view\n', '        returns (uint8)\n', '    {\n', '        uint256 genes;\n', '        ( , , , , , , , , , genes) = kittyCore.getKitty(_kittyId);\n', '\n', '        uint8 skillScore;\n', '        for(uint8 i = 0; i < geneMasks.length; i++) {\n', '            if (genes & geneMasks[i][0] == geneMasks[i][0]) {\n', '                skillScore += uint8(geneMasks[i][1]);\n', '            }\n', '        }\n', '\n', '        return skillScore;\n', '    }\n', '}\n', '\n', '// Barebones interface to CryptoKitties contract\n', 'contract KittyCoreI {\n', '    function getKitty(uint _id) public returns (\n', '        bool isGestating,\n', '        bool isReady,\n', '        uint256 cooldownIndex,\n', '        uint256 nextActionAt,\n', '        uint256 siringWithId,\n', '        uint256 birthTime,\n', '        uint256 matronId,\n', '        uint256 sireId,\n', '        uint256 generation,\n', '        uint256 genes\n', '    );\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract KittyRace {\n', '    struct Race {\n', '        uint32 blockJoinedFirstRacer;\n', '        uint32 blockJoinedLastRacer;\n', '        Racer[] racers;\n', '    }\n', '\n', '    struct Racer {\n', '        address kittyOwner;\n', '        uint256 kittyId;\n', '    }\n', '\n', '    event RegisterEvent(\n', '        uint32 raceId,\n', '        address kittyAddress,\n', '        uint256 kittyId,\n', '        uint256 position\n', '    );\n', '\n', '    event RaceEvent(\n', '        uint32 raceId,\n', '        uint256 numRacers,\n', '        uint256 winnerKittyId\n', '    );\n', '\n', '    event PayoutEvent(\n', '        uint32 raceId,\n', '        address winnerKittyAddress,\n', '        uint256 winnerAmount,\n', '        bool winnerTxError,\n', '        address processingAddress,\n', '        uint256 processingAmount,\n', '        bool processingTxError\n', '    );\n', '\n', '    // Contract owner\n', '    address public owner;\n', '\n', '    // KittyCore contract reference\n', '    address public kittyCoreAddress;\n', '    KittyCoreI kittyCore;\n', '\n', '    // Pause button\n', '    bool gameOn = true;\n', '\n', '    // Precise payment value required to registerForRace(). This can be\n', '    // updated by the owner role as the gas or fiat prices adjust.\n', '    uint256 public entryFee = 0.005 ether;\n', '    uint256 public processingFee = 0.0005 ether; // paid from each entry fee to whoever successfully calls race() function\n', '    uint8 public registrationPeriod = 25; // number of blocks after race creation others can join\n', '    uint8 public maxRacers = 10; // maximum number of racers allowed for single race\n', '\n', '    uint32 public raceId = 0;\n', '    mapping (uint256 => Race) public races;\n', '    mapping (uint256 => bool) public activeRacers;\n', '    mapping (uint256 => bool) public completedRaces;\n', '\n', '    // Slight advantage for Kitties with the following genes\n', '    uint256[][] geneMasks = [\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000000b00000), uint256(2) ], // jaguar (D) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000016000000), uint256(1) ], // jaguar (R1) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000000900000), uint256(2) ], // luckystripe (D) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000000000000012000000), uint256(1) ], // luckystripe (R1) - pattern\n', '        [ uint256(0x0000000000000000000000000000000000000000000000019000000000000000), uint256(2) ], // wingtips (D) - eyes\n', '        [ uint256(0x0000000000000000000000000000000000000000000000320000000000000000), uint256(1) ], // wingtips (R1) - eyes\n', '        [ uint256(0x0000000000000000000000000000000000000000000500000000000000000000), uint256(2) ], // mauveover (D) - colorbody\n', '        [ uint256(0x000000000000000000000000000000000000000000a000000000000000000000), uint256(1) ], // mauveover (R1) - colorbody\n', '        [ uint256(0x00000000000000000000000000000000000000c0000000000000000000000000), uint256(2) ], // coffee (D) - color\n', '        [ uint256(0x0000000000000000000000000000000000001800000000000000000000000000), uint256(1) ]  // coffee (R1) - color\n', '    ];\n', '\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    function KittyRace(address _kittyCoreAddress) public {\n', '        owner = msg.sender;\n', '        kittyCoreAddress = _kittyCoreAddress;\n', '        kittyCore = KittyCoreI(kittyCoreAddress);\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        // Contract cannot be killed after midnight, April 1, 2018 (Pacific)\n', '        require(now < 1522566000);\n', '\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function setEntryFee(uint256 _entryFee) public onlyOwner { entryFee = _entryFee; }\n', '    function setProcessingFee(uint256 _processingFee) public onlyOwner { processingFee = _processingFee; }\n', '    function setRegistrationPeriod(uint8 _registrationPeriod) public onlyOwner { registrationPeriod = _registrationPeriod; }\n', '    function setMaxRacers(uint8 _maxRacers) public onlyOwner { maxRacers = _maxRacers; }\n', '    function setGameOn(bool _gameOn) public onlyOwner { gameOn = _gameOn; }\n', '\n', '    function setKittyCoreAddress(address _kittyCoreAddress)\n', '        public\n', '        onlyOwner\n', '    {\n', '        kittyCoreAddress = _kittyCoreAddress;\n', '        kittyCore = KittyCoreI(kittyCoreAddress);\n', '    }\n', '\n', '    function getRace(uint32 _raceId)\n', '        public\n', '        view\n', '        returns (uint256 blockJoinedFirstRacer, uint256 blockJoinedLastRacer, uint256 numRacers)\n', '    {\n', '        return (races[_raceId].blockJoinedFirstRacer, races[_raceId].blockJoinedLastRacer, races[_raceId].racers.length);\n', '    }\n', '\n', '    function getRacer(uint32 _raceId, uint256 _racerIndex)\n', '        public\n', '        view\n', '        returns (address kittyOwner, uint256 kittyId)\n', '    {\n', '        Racer storage racer = races[_raceId].racers[_racerIndex];\n', '        return (racer.kittyOwner, racer.kittyId);\n', '    }\n', '\n', '    function registerForRace(uint256 _kittyId)\n', '        external\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        require(gameOn);\n', '\n', '        // Confirm precise entry fee was provided\n', '        require(msg.value == entryFee);\n', '\n', '        // Confirm sender owns the Kitty\n', '        require(msg.sender == kittyCore.ownerOf(_kittyId));\n', '\n', '        // Confirm Kitty is not currently in another race\n', '        require(activeRacers[_kittyId] != true);\n', '\n', '        Race storage race = races[raceId];\n', '\n', '        // Create new race if current race is completed or full\n', '        if (completedRaces[raceId] || race.racers.length >= maxRacers) {\n', '            raceId += 1;\n', '            race = races[raceId];\n', '        }\n', '\n', '        // Separated from statement above to function for first racer of first race\n', '        if (race.racers.length == 0) {\n', '            race.blockJoinedFirstRacer = uint32(block.number);\n', '        }\n', '        race.blockJoinedLastRacer = uint32(block.number);\n', '\n', '        Racer memory racer = Racer({\n', '            kittyOwner: msg.sender,\n', '            kittyId: _kittyId\n', '        });\n', '\n', '        race.racers.push(racer);\n', '\n', '        activeRacers[_kittyId] = true;\n', '\n', '        emit RegisterEvent(\n', '            raceId,\n', '            racer.kittyOwner,\n', '            racer.kittyId,\n', '            race.racers.length - 1 // Race position\n', '        );\n', '\n', '        return raceId;\n', '    }\n', '\n', '    function race(uint32 _raceId)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        uint256 numRacers = races[_raceId].racers.length;\n', '\n', '        // Is race full, if not, have racers had enough time to join?\n', '        require(numRacers >= maxRacers || block.number > races[_raceId].blockJoinedFirstRacer + registrationPeriod);\n', '\n', '        // Enough unique block hashes to provide random roll for each racer?\n', '        require(block.number > races[_raceId].blockJoinedLastRacer + numRacers);\n', '\n', '        Racer memory racer;\n', '        Racer memory winner = races[_raceId].racers[0];\n', '        uint8 raceScore;\n', '        uint8 highScore = 0;\n', '\n', '        // Calc finishing order\n', '        for(uint i = 0; i < numRacers; i++) {\n', '            racer = races[_raceId].racers[i];\n', '            // Genetic skill score\n', '            raceScore = getKittySkillScore(racer.kittyId);\n', '            // Random chance score\n', '            raceScore += uint8(block.blockhash(races[_raceId].blockJoinedLastRacer + numRacers - i)) % 20;\n', '            // First and second entry incentives\n', '            if (i == 0) { raceScore += 2; } // First to join\n', '            if (i == 1) { raceScore += 1; } // Second to join\n', '\n', '            if (raceScore > highScore) {\n', '                winner = racer;\n', '                highScore = raceScore;\n', '            }\n', '\n', '            delete activeRacers[racer.kittyId];\n', '        }\n', '\n', '        emit RaceEvent(\n', '            _raceId,\n', '            numRacers,\n', '            winner.kittyId\n', '        );\n', '\n', '        emit PayoutEvent(\n', '            _raceId,\n', '            winner.kittyOwner,\n', '            (entryFee * numRacers) - (processingFee * numRacers),\n', '            !winner.kittyOwner.send((entryFee * numRacers) - (processingFee * numRacers)),\n', '            msg.sender,\n', '            processingFee * numRacers,\n', '            !msg.sender.send(processingFee * numRacers)\n', '        );\n', '\n', '        completedRaces[_raceId] = true;\n', '        delete races[_raceId];\n', '\n', '        return winner.kittyId;\n', '    }\n', '\n', '    function getKittySkillScore(uint256 _kittyId)\n', '        private\n', '        view\n', '        returns (uint8)\n', '    {\n', '        uint256 genes;\n', '        ( , , , , , , , , , genes) = kittyCore.getKitty(_kittyId);\n', '\n', '        uint8 skillScore;\n', '        for(uint8 i = 0; i < geneMasks.length; i++) {\n', '            if (genes & geneMasks[i][0] == geneMasks[i][0]) {\n', '                skillScore += uint8(geneMasks[i][1]);\n', '            }\n', '        }\n', '\n', '        return skillScore;\n', '    }\n', '}\n', '\n', '// Barebones interface to CryptoKitties contract\n', 'contract KittyCoreI {\n', '    function getKitty(uint _id) public returns (\n', '        bool isGestating,\n', '        bool isReady,\n', '        uint256 cooldownIndex,\n', '        uint256 nextActionAt,\n', '        uint256 siringWithId,\n', '        uint256 birthTime,\n', '        uint256 matronId,\n', '        uint256 sireId,\n', '        uint256 generation,\n', '        uint256 genes\n', '    );\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '}']
