['pragma solidity ^0.4.19;\n', '//\n', '/* CONTRACT */\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '// END_OF_contract_SafeMath\n', '//_________________________________________________________\n', '//\n', '/* INTERFACES */\n', '//\n', 'interface tokenRecipient {\n', '\t\n', '\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \n', '}   \n', '//________________________________________________________\n', '//\n', '    interface ICO {\n', '\n', '        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount);\n', '        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\n', '        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\n', '        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\n', '\n', '        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\n', '        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\n', '\n', '        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\n', '        function getMinBal() public returns(uint minBalForAccnts_ );\n', '        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\n', '    }\n', '//_______________________________________________________ \n', '//\n', '    interface Exchg{\n', '        \n', '        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\n', '        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\n', '        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\n', '        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \n', '\n', '        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \n', '\n', '        function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\n', '    }\n', '//_________________________________________________________\n', '\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\n', '/* CONTRACT */\n', '//\n', '    contract TokenERC20Interface {\n', '\n', '        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\n', '        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\n', '        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\n', '        function transfer(address to, uint tokens) public returns (bool success);\n', '        function approve(address spender, uint tokens) public returns (bool success);\n', '        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\n', '        event Transfer(address indexed _from, address indexed to, uint tokens);\n', '        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '//END_OF_contract_ERC20Interface \n', '//_________________________________________________________________\n', '/* CONTRACT */\n', '/**\n', '* COPYRIGHT Macroansy \n', '* http://www.macroansy.org\n', '*/\n', 'contract TokenMacroansy is TokenERC20Interface, SafeMath { \n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    //\n', '    address internal owner; \n', '    address private  beneficiaryFunds;\n', '    //\n', '    uint256 public totalSupply;\n', '    uint256 internal totalSupplyStart;\n', '    //\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping( address => bool) internal frozenAccount;\n', '    //\n', '    mapping(address => uint) private msgSndr;\n', '    //\n', '    address tkn_addr; address ico_addr; address exchg_addr;\n', '    //\n', '    uint256 internal allowedIndividualShare;\n', '    uint256 internal allowedPublicShare;\n', '//\n', '    //uint256 internal allowedFounderShare;\n', '    //uint256 internal allowedPOOLShare;\n', '    //uint256 internal allowedVCShare;\n', '    //uint256 internal allowedColdReserve;\n', '//_________________________________________________________\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event Burn(address indexed from, uint amount);\n', '    event UnBurn(address indexed from, uint amount);\n', '    event FundOrPaymentTransfer(address beneficiary, uint amount); \n', '    event FrozenFunds(address target, bool frozen);\n', '    event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\n', '//_________________________________________________________\n', '//\n', '//CONSTRUCTOR\n', '    /* Initializes contract with initial supply tokens to the creator of the contract \n', '    */\n', '    function TokenMacroansy()  public {\n', '        \n', '        owner = msg.sender;\n', '        beneficiaryFunds = owner;\n', '        //totalSupplyStart = initialSupply * 10** uint256(decimals);  \n', '        totalSupplyStart = 3999 * 10** uint256(decimals);     \n', '        totalSupply = totalSupplyStart; \n', '        //\n', '        balanceOf[msg.sender] = totalSupplyStart;    \n', '        Transfer(address(0), msg.sender, totalSupplyStart);\n', '        //                 \n', '        name = "TokenMacroansy";  \n', '        symbol = "$BEE";\n', '        //  \n', '        allowedIndividualShare = uint(1)*totalSupplyStart/100; \n', '        allowedPublicShare = uint(20)* totalSupplyStart/100;     \n', '        //\n', '        //allowedFounderShare = uint(20)*totalSupplyStart/100; \n', '        //allowedPOOLShare = uint(9)* totalSupplyStart/100; \n', '        //allowedColdReserve = uint(41)* totalSupplyStart/100;\n', '        //allowedVCShare =  uint(10)* totalSupplyStart/100;  \n', '    } \n', '//_________________________________________________________\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    } \n', '    function wadmin_transferOr(address _Or) public onlyOwner {\n', '        owner = _Or;\n', '    }          \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `totalSupply` for this Token contract\n', '     */\n', '    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\n', '        return totalSupply ;   \n', '    }  \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `tokenOwner` balances for this contract\n', '     * @param tokenOwner the token owners address\n', '     */\n', '    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\n', '        return balanceOf[tokenOwner];\n', '    } \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the allowance given by `tokenOwner` to the `spender`\n', '     * @param tokenOwner the token owner address allocating allowance\n', '     * @param spender the allowance spenders address\n', '     */\n', '    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\n', '        return allowance[tokenOwner][spender];\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function wadmin_setContrAddr(address icoAddr, address exchAddr ) public onlyOwner returns(bool success){\n', '       tkn_addr = this; ico_addr = icoAddr; exchg_addr = exchAddr;\n', '       return true;\n', '    }          \n', '    //\n', '    function _getTknAddr() internal  returns(address tkn_ma_addr){  return(tkn_addr); }\n', '    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \n', '    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \n', '    // _getTknAddr(); _getIcoAddr(); _getExchgAddr();  \n', '    //  address tkn_addr; address ico_addr; address exchg_addr;\n', '//_________________________________________________________\n', '//\n', '    /* Internal transfer, only can be called by this contract */\n', '    //\n', '    function _transfer(address _from, address _to, uint _value) internal  {\n', '        require (_to != 0x0);                                       \n', '        require(!frozenAccount[_from]);                             \n', '        require(!frozenAccount[_to]);                               \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;                       \n', '        require (balanceOf[_from] >= _valueA);                       \n', '        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \n', '        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \n', '        Transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \n', '    }\n', '//________________________________________________________\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * @notice Allows to Send Coins to other accounts\n', '     * @param _to The address of the recipient of coins\n', '     * @param _value The amount of coins to send\n', '     */\n', '     function transfer(address _to, uint256 _value) public returns(bool success) {\n', '\n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\n', '        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\n', '        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        //\n', '        uint valtmp = _value;    \n', '        uint _valueTemp = valtmp; \n', '        valtmp = 0;                 \n', '        _transfer(msg.sender, _to, _valueTemp);\n', '        _valueTemp = 0;\n', '        return true;      \n', '    }  \n', '//_________________________________________________________\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * @notice sender can set an allowance for another contract, \n', '     * @notice and the other contract interface function receiveApproval \n', '     * @notice can call this funtion for token as payment and add further coding for service.\n', '     * @notice please also refer to function approveAndCall\n', '     * @notice Send `_value` tokens to `_to` on behalf of `_from`\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient of coins\n', '     * @param _value The amount coins to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;\n', '        require(_valueA <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\n', '        _transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * @notice Allows `_spender` to spend no more than `_value` coins from your account\n', '     * @param _spender The address authorized to spend\n', '     * @param _value The max amount of coins allocated to spender\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        \n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\n', '        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\n', '        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        //\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        allowance[msg.sender][_spender] = _valueA;\n', '        Approval(msg.sender, _spender, _valueA);\n', '         _valueA =0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` coins in from your account\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount of coins the spender can spend\n', '     * @param _extraData some extra information to send to the spender contracts\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        if (approve(_spender, _valueA)) {           \n', '            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \n', '        }\n', '        _valueA = 0; \n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    /**\n', '    * @notice `freeze` Prevent | Allow` `target` from sending & receiving tokens\n', '    * @param target Address to be frozen\n', '    * @param freeze either to freeze it or not\n', '    */\n', '    function wadmin_freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\n', '        frozenAccount[target] = freeze;      \n', '        FrozenFunds(target, freeze);\n', '        return true;\n', '    }\n', '//________________________________________________________\n', '//\n', '    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\n', '          \n', '          uint tkA = amount;\n', '          uint tkAtemp = tkA;\n', '          tkA = 0;\n', '                   _transfer(_from, _to, tkAtemp); \n', '          tkAtemp = 0;\n', '          return true;\n', '    }      \n', '//_________________________________________________________\n', '//\n', '    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\n', '              \n', '          uint pA = payment; \n', '          uint paymentTemp = pA;\n', '          pA = 0;\n', '                  paymentBenfcry.transfer(paymentTemp); \n', '          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \n', '          paymentTemp = 0; \n', '          \n', '          return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\n', '              \n', '    // payment req to ico\n', '          uint Pm = payment;\n', '          uint PmTemp = Pm;\n', '          Pm = 0;  \n', '          ICO ico = ICO(_getIcoAddr());       \n', '          // paytype 1 for redeempayment and 2 for sell payment\n', '          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\n', '          require(pymActSucs ==  true);\n', '          PmTemp = 0;\n', '          \n', '          return true;\n', '    }\n', '\n', '//_________________________________________________________\n', '    /* @notice Allows to Buy ICO tokens directly from this contract by sending ether\n', '    */\n', '    function buyCoinsAtICO() payable public returns(bool success) { \n', '\n', '        msgSndr[msg.sender] = msg.value;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        require(  msg.value > 0 );\n', '        \n', '        // buy exe at ico\n', '        bool icosuccess;  uint tknsBuyAppr;        \n', '        (icosuccess, tknsBuyAppr) = ico.buy( msg.value, msg.sender, false);        \n', '                require( icosuccess == true );\n', '        \n', '        // tkn transfer\n', '        bool sucsTrTk =  _safeTransferTkn( owner, msg.sender, tknsBuyAppr);\n', '        require(sucsTrTk == true);\n', '\n', '        msgSndr[msg.sender] = 0;\n', '\n', '        return (true) ;\n', '    }     \n', '//_____________________________________________________________\n', '//\n', '    /* @notice Allows anyone to preview a Buy of ICO tokens before an actual buy\n', '    */\n', '\n', '    function buyCoinsPreview(uint myProposedPaymentInWEI) public view returns(bool success, uint tokensYouCanBuy, uint yourSafeMinBalReqdInWEI) { \n', '        \n', '        uint payment = myProposedPaymentInWEI;\n', '       \n', '        msgSndr[msg.sender] = payment;  \n', '        success = false;\n', '        \n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        tokensYouCanBuy = 0;\n', '        bool icosuccess;            \n', '        (icosuccess, tokensYouCanBuy) = ico.buy( payment, msg.sender, true);        \n', '\n', '        msgSndr[msg.sender] = 0;\n', '\n', '        return ( icosuccess, tokensYouCanBuy, ico.getMinBal()) ;\n', '    }\n', '//_____________________________________________________________\n', '     /**\n', '     *  @notice Allows Token owners to Redeem Tokens to this Contract for its value promised\n', '     */\n', '    function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) {\n', '\n', '    uint amount = amountOfCoinsToRedeem;\n', '\n', '    msgSndr[msg.sender] = amount;  \n', '      bool isPreview = false;\n', '\n', '      ICO ico = ICO(_getIcoAddr());\n', '\n', '      // redeem exe at ico\n', '      bool icosuccess ; uint redeemPaymentValue;\n', '      (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\n', '      require( icosuccess == true);  \n', '\n', '      require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) );\n', '\n', '      bool sucsTrTk = false; bool pymActSucs = false;\n', '      if(isPreview == false) {\n', '\n', '        // transfer tkns\n', '        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\n', '        require(sucsTrTk == true);        \n', '\n', '        // payment req to ico  1 for redeempayment and 2 for sell payment         \n', '      msgSndr[msg.sender] = redeemPaymentValue;\n', '        pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1);\n', '        require(pymActSucs ==  true);\n', '      } \n', '\n', '    msgSndr[msg.sender] = 0;  \n', '\n', '      return (true);        \n', '    } \n', '//_________________________________________________________\n', '    /**\n', '     *  @notice Allows Token owners to Sell Tokens directly to this Contract\n', '     *\n', '     */    \n', '     function sellCoinsToICO( uint256 amountOfCoinsToSell ) public returns (bool success ) {\n', '\n', '      uint amount = amountOfCoinsToSell;\n', '\n', '      msgSndr[msg.sender] = amount;  \n', '        bool isPreview = false;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        // sell exe at ico\n', '        bool icosuccess; uint sellPaymentValue; \n', '        ( icosuccess ,  sellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\n', '        require( icosuccess == true );\n', '\n', '        require( _getIcoAddr().balance >= safeAdd(ico.getMinBal() , sellPaymentValue) );\n', '\n', '        bool sucsTrTk = false; bool pymActSucs = false;\n', '        if(isPreview == false){\n', '\n', '          // token transfer\n', '          sucsTrTk =  _safeTransferTkn( msg.sender, owner,  amount);\n', '          require(sucsTrTk == true);\n', '\n', '          // payment request to ico  1 for redeempayment and 2 for sell payment\n', '        msgSndr[msg.sender] = sellPaymentValue;\n', '          pymActSucs = _safePaymentActionAtIco( sellPaymentValue, msg.sender, 2);\n', '          require(pymActSucs ==  true);\n', '        }\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return ( true);                \n', '    }\n', '//________________________________________________________\n', '    /**\n', '    * @notice a sellers allowed limits in holding ico tokens is checked\n', '    */\n', '    //\n', '    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \n', '\n', '      uint amountTkns = amountOfCoinsSellerCanSell; \n', '      success = false;\n', '      ICO ico = ICO( _getIcoAddr() );\n', '      uint seriesCapFactor = ico.getSCF();\n', '\n', '      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\n', '        success = true;\n', '      }\n', '      return success;\n', '    }\n', '    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\n', '//_________________________________________________________    \n', '//\n', '    /**\n', '    * @notice a buyers allowed limits in holding ico tokens is checked \n', '    */\n', '    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\n', '\n', '    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\n', '        success = false;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        uint seriesCapFactor = ico.getSCF();\n', '\n', '        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\n', '          success = true;\n', '        } \n', '        return success;        \n', '    }\n', '//_________________________________________________________\n', '//\n', '    /**\n', '    * @notice a buyers allowed limits in holding ico tokens along with financial capacity to buy is checked\n', '    */\n', '    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\n', '       \n', '       success = false;\n', '\n', '      // buyer limits\n', '       bool sucs1 = false; \n', '       sucs1 = _chkBuyerLmts( buyer, amountTkns);\n', '\n', '      // buyer funds\n', '       ICO ico = ICO( _getIcoAddr() );\n', '       bool sucs2 = false;\n', '       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\n', '       if( sucs1 == true && sucs2 == true)  success = true;   \n', '\n', '       return success;\n', '    }\n', '//_________________________________________________________\n', '//\n', '     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\n', '     \n', '      // seller limits check\n', '        bool successSlrl; \n', '        (successSlrl) = _chkSellerLmts( seller, amountTkns); \n', '\n', '      // buyer limits check\n', '        bool successByrlAFinl;\n', '        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\n', '        \n', '        require( successSlrl == true && successByrlAFinl == true);\n', '\n', '        return true;\n', '    }\n', '//___________________________________________________________________\n', '    /**\n', '    * @notice allows a seller to formally register his sell offer at ExchangeMacroansy\n', '    */\n', '      function sellBkgAtExchg( uint amountOfCoinsOffer, uint priceOfOneCoinInWEI) public returns(bool success){\n', '\n', '        uint amntTkns = amountOfCoinsOffer ;\n', '        uint tknPrice = priceOfOneCoinInWEI;\n', '      \n', '        // seller limits\n', '        bool successSlrl;\n', '        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \n', '        require(successSlrl == true);\n', '\n', '      msgSndr[msg.sender] = amntTkns;  \n', '\n', '      // bkg registration at exchange\n', '\n', '        Exchg em = Exchg(_getExchgAddr());\n', '\n', '        bool  emsuccess; \n', '        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\n', '        require(emsuccess == true );\n', '            \n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return true;         \n', '    }\n', '//_________________________________________________________ \n', '//    \n', '    /**\n', '    * @notice function for booking and locking for a buy with respect to a sale offer registered\n', '    * @notice after booking then proceed for payment using func buyCoinsAtExchg \n', '    * @notice payment booking value and actual payment value should be exact\n', '    */  \n', '      function buyBkgAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \n', '        \n', '        uint amountTkns = sellersCoinAmountOffer;\n', '        uint priceOfr = sellersPriceOfOneCoinInWEI;\n', '        uint payment = myProposedPaymentInWEI;         \n', '    \n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // seller buyer limits check\n', '        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\n', '        require(sucsLmt == true);\n', '\n', '        // booking at exchange\n', '     \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool emBkgsuccess;\n', '        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\n', '            require( emBkgsuccess == true );\n', '\n', '      msgSndr[msg.sender] = 0;  \n', '\n', '        return true;        \n', '    }\n', '//________________________________________________________\n', '\n', '    /**\n', '    * @notice for buyingCoins at ExchangeMacroansy \n', '    * @notice please first book the buy through function_buy_Exchg_booking\n', '    */\n', '   // function buyCoinsAtExchg( address seller, uint amountTkns, uint priceOfr) payable public returns(bool success) {\n', '\n', '    function buyCoinsAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI) payable public returns(bool success) {\n', '       \n', '        uint amountTkns = sellersCoinAmountOffer;\n', '        uint priceOfr = sellersPriceOfOneCoinInWEI;\t       \n', '        require( msg.value > 0 && msg.value <= safeMul(amountTkns, priceOfr ) );\n', '\n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // calc tokens that can be bought  \n', '  \n', '        uint tknsBuyAppr = safeDiv(msg.value , priceOfr);\n', '\n', '        // check buyer booking at exchange\n', '  \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '        \n', '        bool sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \n', '        require(sucsBkgChk == true);\n', '\n', '       // update seller reg and buyer booking at exchange\n', '\n', '      msgSndr[msg.sender] = tknsBuyAppr;  \n', ' \n', '        bool emUpdateSuccess;\n', '        (emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \n', '        require( emUpdateSuccess == true );\n', '        \n', '       // token transfer in this token contract\n', '\n', '        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\n', '        require(sucsTrTkn == true);\n', '\n', '        // payment to seller        \n', '        bool sucsTrPaymnt;\n', '        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\n', '        require(sucsTrPaymnt == true );\n', '       //  \n', '        BuyAtMacroansyExchg(msg.sender, seller, tknsBuyAppr, msg.value); //event\n', '\n', '      msgSndr[msg.sender] = 0; \n', '        \n', '        return true;\n', '    } \n', '//___________________________________________________________\n', '\n', '   /**\n', '     * @notice Fall Back Function, not to receive ether directly and/or accidentally\n', '     *\n', '     */\n', '    function () public payable {\n', '        if(msg.sender != owner) revert();\n', '    }\n', '//_________________________________________________________\n', '\n', '    /*\n', '    * @notice Burning tokens ie removing tokens from the formal total supply\n', '    */\n', '    function wadmin_burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \n', '\n', '        msgSndr[msg.sender] = value;\n', '         ICO ico = ICO( _getIcoAddr() );\n', '            if( unburn == false) {\n', '\n', '                balanceOf[owner] = safeSub( balanceOf[owner] , value);\n', '                totalSupply = safeSub( totalSupply, value);\n', '                Burn(owner, value);\n', '\n', '            }\n', '            if( unburn == true) {\n', '\n', '                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\n', '                totalSupply = safeAdd( totalSupply , value);\n', '                UnBurn(owner, value);\n', '\n', '            }\n', '        \n', '        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\n', '        require( icosuccess == true);             \n', '        \n', '        return true;                     \n', '    }\n', '//_________________________________________________________\n', '    /*\n', '    * @notice Withdraw Payments to beneficiary \n', '    * @param withdrawAmount the amount withdrawn in wei\n', '    */\n', '    function wadmin_withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\n', '      \n', '        success = _withdraw(withdrawAmount);          \n', '        return success;      \n', '    }   \n', '//_________________________________________________________\n', '     /*internal function can called by this contract only\n', '     */\n', '    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\n', '\n', '        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \n', '        require(sucsTrPaymnt == true);         \n', '        return true;     \n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     *  @notice Allows to receive coins from Contract Share approved by contract\n', '     *  @notice to receive the share, it has to be already approved by the contract\n', '     *  @notice the share Id will be provided by contract while payments are made through other channels like paypal\n', '     *  @param amountOfCoinsToReceive the allocated allowance of coins to be transferred to you   \n', '     *  @param  ShrID  1 is FounderShare, 2 is POOLShare, 3 is ColdReserveShare, 4 is VCShare, 5 is PublicShare, 6 is RdmSellPool\n', '     */ \n', '    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \n', '\n', '      msgSndr[msg.sender] = amountOfCoinsToReceive;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        bool  icosuccess;  \n', '        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \n', '        require (icosuccess == true);\n', '\n', '        bool sucsTrTk;\n', '        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\n', '        require(sucsTrTk == true);\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return  true;\n', '    }\n', '//_______________________________________________________\n', '//  called by other contracts\n', '    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\n', '        \n', '        (success, value) = _sendMsgSndr(caller, origin);        \n', '         return(success, value);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \n', '       \n', '        require(caller == _getIcoAddr() || caller == _getExchgAddr()); \n', '          //require(origin == tx.origin);          \n', '        return(true, msgSndr[origin]);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function a_viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_){\n', '\n', '      if(show == true){\n', '\n', '          Exchg em = Exchg(_getExchgAddr()); \n', '         \n', '        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \n', '\n', '        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_);\n', '      }\n', '    }\n', '//_________________________________________________________\n', '//\n', '\tfunction a_viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\n', '\n', '\t    if(show == true){\n', '\t      ICO ico = ICO( _getIcoAddr() );\n', '\n', '\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\n', '\n', '\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\n', '\t    }\n', '\t}\n', '//_______________________________________________________\n', '//\n', '\t\t\t/*\n', '\t\t\tbool private isEndOk;\n', '\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\n', '\n', '\t\t\t\t\t\tisEndOk == isEndNow;\n', '\t\t\t\t}\n', '\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\n', '\n', '\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\n', '\t\t\t\t}\n', '\t\t\t*/\n', '//_______________________________________________________\n', '}\n', '// END_OF_CONTRACT']
['pragma solidity ^0.4.19;\n', '//\n', '/* CONTRACT */\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '// END_OF_contract_SafeMath\n', '//_________________________________________________________\n', '//\n', '/* INTERFACES */\n', '//\n', 'interface tokenRecipient {\n', '\t\n', '\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \n', '}   \n', '//________________________________________________________\n', '//\n', '    interface ICO {\n', '\n', '        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount);\n', '        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\n', '        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\n', '        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\n', '\n', '        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\n', '        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\n', '\n', '        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\n', '        function getMinBal() public returns(uint minBalForAccnts_ );\n', '        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\n', '    }\n', '//_______________________________________________________ \n', '//\n', '    interface Exchg{\n', '        \n', '        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\n', '        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\n', '        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\n', '        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \n', '\n', '        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \n', '\n', '        function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\n', '    }\n', '//_________________________________________________________\n', '\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\n', '/* CONTRACT */\n', '//\n', '    contract TokenERC20Interface {\n', '\n', '        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\n', '        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\n', '        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\n', '        function transfer(address to, uint tokens) public returns (bool success);\n', '        function approve(address spender, uint tokens) public returns (bool success);\n', '        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\n', '        event Transfer(address indexed _from, address indexed to, uint tokens);\n', '        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '//END_OF_contract_ERC20Interface \n', '//_________________________________________________________________\n', '/* CONTRACT */\n', '/**\n', '* COPYRIGHT Macroansy \n', '* http://www.macroansy.org\n', '*/\n', 'contract TokenMacroansy is TokenERC20Interface, SafeMath { \n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    //\n', '    address internal owner; \n', '    address private  beneficiaryFunds;\n', '    //\n', '    uint256 public totalSupply;\n', '    uint256 internal totalSupplyStart;\n', '    //\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping( address => bool) internal frozenAccount;\n', '    //\n', '    mapping(address => uint) private msgSndr;\n', '    //\n', '    address tkn_addr; address ico_addr; address exchg_addr;\n', '    //\n', '    uint256 internal allowedIndividualShare;\n', '    uint256 internal allowedPublicShare;\n', '//\n', '    //uint256 internal allowedFounderShare;\n', '    //uint256 internal allowedPOOLShare;\n', '    //uint256 internal allowedVCShare;\n', '    //uint256 internal allowedColdReserve;\n', '//_________________________________________________________\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event Burn(address indexed from, uint amount);\n', '    event UnBurn(address indexed from, uint amount);\n', '    event FundOrPaymentTransfer(address beneficiary, uint amount); \n', '    event FrozenFunds(address target, bool frozen);\n', '    event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\n', '//_________________________________________________________\n', '//\n', '//CONSTRUCTOR\n', '    /* Initializes contract with initial supply tokens to the creator of the contract \n', '    */\n', '    function TokenMacroansy()  public {\n', '        \n', '        owner = msg.sender;\n', '        beneficiaryFunds = owner;\n', '        //totalSupplyStart = initialSupply * 10** uint256(decimals);  \n', '        totalSupplyStart = 3999 * 10** uint256(decimals);     \n', '        totalSupply = totalSupplyStart; \n', '        //\n', '        balanceOf[msg.sender] = totalSupplyStart;    \n', '        Transfer(address(0), msg.sender, totalSupplyStart);\n', '        //                 \n', '        name = "TokenMacroansy";  \n', '        symbol = "$BEE";\n', '        //  \n', '        allowedIndividualShare = uint(1)*totalSupplyStart/100; \n', '        allowedPublicShare = uint(20)* totalSupplyStart/100;     \n', '        //\n', '        //allowedFounderShare = uint(20)*totalSupplyStart/100; \n', '        //allowedPOOLShare = uint(9)* totalSupplyStart/100; \n', '        //allowedColdReserve = uint(41)* totalSupplyStart/100;\n', '        //allowedVCShare =  uint(10)* totalSupplyStart/100;  \n', '    } \n', '//_________________________________________________________\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    } \n', '    function wadmin_transferOr(address _Or) public onlyOwner {\n', '        owner = _Or;\n', '    }          \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `totalSupply` for this Token contract\n', '     */\n', '    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\n', '        return totalSupply ;   \n', '    }  \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `tokenOwner` balances for this contract\n', '     * @param tokenOwner the token owners address\n', '     */\n', '    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\n', '        return balanceOf[tokenOwner];\n', '    } \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the allowance given by `tokenOwner` to the `spender`\n', '     * @param tokenOwner the token owner address allocating allowance\n', '     * @param spender the allowance spenders address\n', '     */\n', '    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\n', '        return allowance[tokenOwner][spender];\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function wadmin_setContrAddr(address icoAddr, address exchAddr ) public onlyOwner returns(bool success){\n', '       tkn_addr = this; ico_addr = icoAddr; exchg_addr = exchAddr;\n', '       return true;\n', '    }          \n', '    //\n', '    function _getTknAddr() internal  returns(address tkn_ma_addr){  return(tkn_addr); }\n', '    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \n', '    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \n', '    // _getTknAddr(); _getIcoAddr(); _getExchgAddr();  \n', '    //  address tkn_addr; address ico_addr; address exchg_addr;\n', '//_________________________________________________________\n', '//\n', '    /* Internal transfer, only can be called by this contract */\n', '    //\n', '    function _transfer(address _from, address _to, uint _value) internal  {\n', '        require (_to != 0x0);                                       \n', '        require(!frozenAccount[_from]);                             \n', '        require(!frozenAccount[_to]);                               \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;                       \n', '        require (balanceOf[_from] >= _valueA);                       \n', '        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \n', '        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \n', '        Transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \n', '    }\n', '//________________________________________________________\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * @notice Allows to Send Coins to other accounts\n', '     * @param _to The address of the recipient of coins\n', '     * @param _value The amount of coins to send\n', '     */\n', '     function transfer(address _to, uint256 _value) public returns(bool success) {\n', '\n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\n', '        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\n', '        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        //\n', '        uint valtmp = _value;    \n', '        uint _valueTemp = valtmp; \n', '        valtmp = 0;                 \n', '        _transfer(msg.sender, _to, _valueTemp);\n', '        _valueTemp = 0;\n', '        return true;      \n', '    }  \n', '//_________________________________________________________\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * @notice sender can set an allowance for another contract, \n', '     * @notice and the other contract interface function receiveApproval \n', '     * @notice can call this funtion for token as payment and add further coding for service.\n', '     * @notice please also refer to function approveAndCall\n', '     * @notice Send `_value` tokens to `_to` on behalf of `_from`\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient of coins\n', '     * @param _value The amount coins to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;\n', '        require(_valueA <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\n', '        _transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * @notice Allows `_spender` to spend no more than `_value` coins from your account\n', '     * @param _spender The address authorized to spend\n', '     * @param _value The max amount of coins allocated to spender\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        \n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\n', '        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\n', '        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        //\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        allowance[msg.sender][_spender] = _valueA;\n', '        Approval(msg.sender, _spender, _valueA);\n', '         _valueA =0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` coins in from your account\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount of coins the spender can spend\n', '     * @param _extraData some extra information to send to the spender contracts\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        if (approve(_spender, _valueA)) {           \n', '            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \n', '        }\n', '        _valueA = 0; \n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    /**\n', '    * @notice `freeze` Prevent | Allow` `target` from sending & receiving tokens\n', '    * @param target Address to be frozen\n', '    * @param freeze either to freeze it or not\n', '    */\n', '    function wadmin_freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\n', '        frozenAccount[target] = freeze;      \n', '        FrozenFunds(target, freeze);\n', '        return true;\n', '    }\n', '//________________________________________________________\n', '//\n', '    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\n', '          \n', '          uint tkA = amount;\n', '          uint tkAtemp = tkA;\n', '          tkA = 0;\n', '                   _transfer(_from, _to, tkAtemp); \n', '          tkAtemp = 0;\n', '          return true;\n', '    }      \n', '//_________________________________________________________\n', '//\n', '    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\n', '              \n', '          uint pA = payment; \n', '          uint paymentTemp = pA;\n', '          pA = 0;\n', '                  paymentBenfcry.transfer(paymentTemp); \n', '          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \n', '          paymentTemp = 0; \n', '          \n', '          return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\n', '              \n', '    // payment req to ico\n', '          uint Pm = payment;\n', '          uint PmTemp = Pm;\n', '          Pm = 0;  \n', '          ICO ico = ICO(_getIcoAddr());       \n', '          // paytype 1 for redeempayment and 2 for sell payment\n', '          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\n', '          require(pymActSucs ==  true);\n', '          PmTemp = 0;\n', '          \n', '          return true;\n', '    }\n', '\n', '//_________________________________________________________\n', '    /* @notice Allows to Buy ICO tokens directly from this contract by sending ether\n', '    */\n', '    function buyCoinsAtICO() payable public returns(bool success) { \n', '\n', '        msgSndr[msg.sender] = msg.value;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        require(  msg.value > 0 );\n', '        \n', '        // buy exe at ico\n', '        bool icosuccess;  uint tknsBuyAppr;        \n', '        (icosuccess, tknsBuyAppr) = ico.buy( msg.value, msg.sender, false);        \n', '                require( icosuccess == true );\n', '        \n', '        // tkn transfer\n', '        bool sucsTrTk =  _safeTransferTkn( owner, msg.sender, tknsBuyAppr);\n', '        require(sucsTrTk == true);\n', '\n', '        msgSndr[msg.sender] = 0;\n', '\n', '        return (true) ;\n', '    }     \n', '//_____________________________________________________________\n', '//\n', '    /* @notice Allows anyone to preview a Buy of ICO tokens before an actual buy\n', '    */\n', '\n', '    function buyCoinsPreview(uint myProposedPaymentInWEI) public view returns(bool success, uint tokensYouCanBuy, uint yourSafeMinBalReqdInWEI) { \n', '        \n', '        uint payment = myProposedPaymentInWEI;\n', '       \n', '        msgSndr[msg.sender] = payment;  \n', '        success = false;\n', '        \n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        tokensYouCanBuy = 0;\n', '        bool icosuccess;            \n', '        (icosuccess, tokensYouCanBuy) = ico.buy( payment, msg.sender, true);        \n', '\n', '        msgSndr[msg.sender] = 0;\n', '\n', '        return ( icosuccess, tokensYouCanBuy, ico.getMinBal()) ;\n', '    }\n', '//_____________________________________________________________\n', '     /**\n', '     *  @notice Allows Token owners to Redeem Tokens to this Contract for its value promised\n', '     */\n', '    function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) {\n', '\n', '    uint amount = amountOfCoinsToRedeem;\n', '\n', '    msgSndr[msg.sender] = amount;  \n', '      bool isPreview = false;\n', '\n', '      ICO ico = ICO(_getIcoAddr());\n', '\n', '      // redeem exe at ico\n', '      bool icosuccess ; uint redeemPaymentValue;\n', '      (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\n', '      require( icosuccess == true);  \n', '\n', '      require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) );\n', '\n', '      bool sucsTrTk = false; bool pymActSucs = false;\n', '      if(isPreview == false) {\n', '\n', '        // transfer tkns\n', '        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\n', '        require(sucsTrTk == true);        \n', '\n', '        // payment req to ico  1 for redeempayment and 2 for sell payment         \n', '      msgSndr[msg.sender] = redeemPaymentValue;\n', '        pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1);\n', '        require(pymActSucs ==  true);\n', '      } \n', '\n', '    msgSndr[msg.sender] = 0;  \n', '\n', '      return (true);        \n', '    } \n', '//_________________________________________________________\n', '    /**\n', '     *  @notice Allows Token owners to Sell Tokens directly to this Contract\n', '     *\n', '     */    \n', '     function sellCoinsToICO( uint256 amountOfCoinsToSell ) public returns (bool success ) {\n', '\n', '      uint amount = amountOfCoinsToSell;\n', '\n', '      msgSndr[msg.sender] = amount;  \n', '        bool isPreview = false;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        // sell exe at ico\n', '        bool icosuccess; uint sellPaymentValue; \n', '        ( icosuccess ,  sellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\n', '        require( icosuccess == true );\n', '\n', '        require( _getIcoAddr().balance >= safeAdd(ico.getMinBal() , sellPaymentValue) );\n', '\n', '        bool sucsTrTk = false; bool pymActSucs = false;\n', '        if(isPreview == false){\n', '\n', '          // token transfer\n', '          sucsTrTk =  _safeTransferTkn( msg.sender, owner,  amount);\n', '          require(sucsTrTk == true);\n', '\n', '          // payment request to ico  1 for redeempayment and 2 for sell payment\n', '        msgSndr[msg.sender] = sellPaymentValue;\n', '          pymActSucs = _safePaymentActionAtIco( sellPaymentValue, msg.sender, 2);\n', '          require(pymActSucs ==  true);\n', '        }\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return ( true);                \n', '    }\n', '//________________________________________________________\n', '    /**\n', '    * @notice a sellers allowed limits in holding ico tokens is checked\n', '    */\n', '    //\n', '    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \n', '\n', '      uint amountTkns = amountOfCoinsSellerCanSell; \n', '      success = false;\n', '      ICO ico = ICO( _getIcoAddr() );\n', '      uint seriesCapFactor = ico.getSCF();\n', '\n', '      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\n', '        success = true;\n', '      }\n', '      return success;\n', '    }\n', '    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\n', '//_________________________________________________________    \n', '//\n', '    /**\n', '    * @notice a buyers allowed limits in holding ico tokens is checked \n', '    */\n', '    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\n', '\n', '    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\n', '        success = false;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        uint seriesCapFactor = ico.getSCF();\n', '\n', '        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\n', '          success = true;\n', '        } \n', '        return success;        \n', '    }\n', '//_________________________________________________________\n', '//\n', '    /**\n', '    * @notice a buyers allowed limits in holding ico tokens along with financial capacity to buy is checked\n', '    */\n', '    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\n', '       \n', '       success = false;\n', '\n', '      // buyer limits\n', '       bool sucs1 = false; \n', '       sucs1 = _chkBuyerLmts( buyer, amountTkns);\n', '\n', '      // buyer funds\n', '       ICO ico = ICO( _getIcoAddr() );\n', '       bool sucs2 = false;\n', '       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\n', '       if( sucs1 == true && sucs2 == true)  success = true;   \n', '\n', '       return success;\n', '    }\n', '//_________________________________________________________\n', '//\n', '     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\n', '     \n', '      // seller limits check\n', '        bool successSlrl; \n', '        (successSlrl) = _chkSellerLmts( seller, amountTkns); \n', '\n', '      // buyer limits check\n', '        bool successByrlAFinl;\n', '        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\n', '        \n', '        require( successSlrl == true && successByrlAFinl == true);\n', '\n', '        return true;\n', '    }\n', '//___________________________________________________________________\n', '    /**\n', '    * @notice allows a seller to formally register his sell offer at ExchangeMacroansy\n', '    */\n', '      function sellBkgAtExchg( uint amountOfCoinsOffer, uint priceOfOneCoinInWEI) public returns(bool success){\n', '\n', '        uint amntTkns = amountOfCoinsOffer ;\n', '        uint tknPrice = priceOfOneCoinInWEI;\n', '      \n', '        // seller limits\n', '        bool successSlrl;\n', '        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \n', '        require(successSlrl == true);\n', '\n', '      msgSndr[msg.sender] = amntTkns;  \n', '\n', '      // bkg registration at exchange\n', '\n', '        Exchg em = Exchg(_getExchgAddr());\n', '\n', '        bool  emsuccess; \n', '        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\n', '        require(emsuccess == true );\n', '            \n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return true;         \n', '    }\n', '//_________________________________________________________ \n', '//    \n', '    /**\n', '    * @notice function for booking and locking for a buy with respect to a sale offer registered\n', '    * @notice after booking then proceed for payment using func buyCoinsAtExchg \n', '    * @notice payment booking value and actual payment value should be exact\n', '    */  \n', '      function buyBkgAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \n', '        \n', '        uint amountTkns = sellersCoinAmountOffer;\n', '        uint priceOfr = sellersPriceOfOneCoinInWEI;\n', '        uint payment = myProposedPaymentInWEI;         \n', '    \n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // seller buyer limits check\n', '        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\n', '        require(sucsLmt == true);\n', '\n', '        // booking at exchange\n', '     \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool emBkgsuccess;\n', '        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\n', '            require( emBkgsuccess == true );\n', '\n', '      msgSndr[msg.sender] = 0;  \n', '\n', '        return true;        \n', '    }\n', '//________________________________________________________\n', '\n', '    /**\n', '    * @notice for buyingCoins at ExchangeMacroansy \n', '    * @notice please first book the buy through function_buy_Exchg_booking\n', '    */\n', '   // function buyCoinsAtExchg( address seller, uint amountTkns, uint priceOfr) payable public returns(bool success) {\n', '\n', '    function buyCoinsAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI) payable public returns(bool success) {\n', '       \n', '        uint amountTkns = sellersCoinAmountOffer;\n', '        uint priceOfr = sellersPriceOfOneCoinInWEI;\t       \n', '        require( msg.value > 0 && msg.value <= safeMul(amountTkns, priceOfr ) );\n', '\n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // calc tokens that can be bought  \n', '  \n', '        uint tknsBuyAppr = safeDiv(msg.value , priceOfr);\n', '\n', '        // check buyer booking at exchange\n', '  \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '        \n', '        bool sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \n', '        require(sucsBkgChk == true);\n', '\n', '       // update seller reg and buyer booking at exchange\n', '\n', '      msgSndr[msg.sender] = tknsBuyAppr;  \n', ' \n', '        bool emUpdateSuccess;\n', '        (emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \n', '        require( emUpdateSuccess == true );\n', '        \n', '       // token transfer in this token contract\n', '\n', '        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\n', '        require(sucsTrTkn == true);\n', '\n', '        // payment to seller        \n', '        bool sucsTrPaymnt;\n', '        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\n', '        require(sucsTrPaymnt == true );\n', '       //  \n', '        BuyAtMacroansyExchg(msg.sender, seller, tknsBuyAppr, msg.value); //event\n', '\n', '      msgSndr[msg.sender] = 0; \n', '        \n', '        return true;\n', '    } \n', '//___________________________________________________________\n', '\n', '   /**\n', '     * @notice Fall Back Function, not to receive ether directly and/or accidentally\n', '     *\n', '     */\n', '    function () public payable {\n', '        if(msg.sender != owner) revert();\n', '    }\n', '//_________________________________________________________\n', '\n', '    /*\n', '    * @notice Burning tokens ie removing tokens from the formal total supply\n', '    */\n', '    function wadmin_burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \n', '\n', '        msgSndr[msg.sender] = value;\n', '         ICO ico = ICO( _getIcoAddr() );\n', '            if( unburn == false) {\n', '\n', '                balanceOf[owner] = safeSub( balanceOf[owner] , value);\n', '                totalSupply = safeSub( totalSupply, value);\n', '                Burn(owner, value);\n', '\n', '            }\n', '            if( unburn == true) {\n', '\n', '                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\n', '                totalSupply = safeAdd( totalSupply , value);\n', '                UnBurn(owner, value);\n', '\n', '            }\n', '        \n', '        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\n', '        require( icosuccess == true);             \n', '        \n', '        return true;                     \n', '    }\n', '//_________________________________________________________\n', '    /*\n', '    * @notice Withdraw Payments to beneficiary \n', '    * @param withdrawAmount the amount withdrawn in wei\n', '    */\n', '    function wadmin_withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\n', '      \n', '        success = _withdraw(withdrawAmount);          \n', '        return success;      \n', '    }   \n', '//_________________________________________________________\n', '     /*internal function can called by this contract only\n', '     */\n', '    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\n', '\n', '        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \n', '        require(sucsTrPaymnt == true);         \n', '        return true;     \n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     *  @notice Allows to receive coins from Contract Share approved by contract\n', '     *  @notice to receive the share, it has to be already approved by the contract\n', '     *  @notice the share Id will be provided by contract while payments are made through other channels like paypal\n', '     *  @param amountOfCoinsToReceive the allocated allowance of coins to be transferred to you   \n', '     *  @param  ShrID  1 is FounderShare, 2 is POOLShare, 3 is ColdReserveShare, 4 is VCShare, 5 is PublicShare, 6 is RdmSellPool\n', '     */ \n', '    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \n', '\n', '      msgSndr[msg.sender] = amountOfCoinsToReceive;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        bool  icosuccess;  \n', '        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \n', '        require (icosuccess == true);\n', '\n', '        bool sucsTrTk;\n', '        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\n', '        require(sucsTrTk == true);\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return  true;\n', '    }\n', '//_______________________________________________________\n', '//  called by other contracts\n', '    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\n', '        \n', '        (success, value) = _sendMsgSndr(caller, origin);        \n', '         return(success, value);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \n', '       \n', '        require(caller == _getIcoAddr() || caller == _getExchgAddr()); \n', '          //require(origin == tx.origin);          \n', '        return(true, msgSndr[origin]);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function a_viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_){\n', '\n', '      if(show == true){\n', '\n', '          Exchg em = Exchg(_getExchgAddr()); \n', '         \n', '        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \n', '\n', '        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_);\n', '      }\n', '    }\n', '//_________________________________________________________\n', '//\n', '\tfunction a_viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\n', '\n', '\t    if(show == true){\n', '\t      ICO ico = ICO( _getIcoAddr() );\n', '\n', '\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\n', '\n', '\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\n', '\t    }\n', '\t}\n', '//_______________________________________________________\n', '//\n', '\t\t\t/*\n', '\t\t\tbool private isEndOk;\n', '\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\n', '\n', '\t\t\t\t\t\tisEndOk == isEndNow;\n', '\t\t\t\t}\n', '\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\n', '\n', '\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\n', '\t\t\t\t}\n', '\t\t\t*/\n', '//_______________________________________________________\n', '}\n', '// END_OF_CONTRACT']
