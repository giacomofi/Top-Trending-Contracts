['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// krypteum public sale contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  // Events ---------------------------\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  // Modifier -------------------------\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  // Functions ------------------------\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != owner);\n', '    require(_newOwner != address(0x0));\n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '  // Events ---------------------------\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '  // Functions ------------------------\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address _owner) public constant returns (uint balance);\n', '  function transfer(address _to, uint _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  function approve(address _spender, uint _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Coin Standard #20\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Coin is ERC20Interface, Owned {\n', '  \n', '  using SafeMath for uint;\n', '\n', '  uint public coinsIssuedTotal = 0;\n', '  mapping(address => uint) public balances;\n', '  mapping(address => mapping (address => uint)) public allowed;\n', '\n', '  // Functions ------------------------\n', '\n', '  /* Total coin supply */\n', '\n', '  function totalSupply() public constant returns (uint) {\n', '    return coinsIssuedTotal;\n', '  }\n', '\n', '  /* Get the account balance for an address */\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /* Transfer the balance from owner&#39;s account to another account */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    // amount sent cannot exceed balance\n', '    require(balances[msg.sender] >= _amount);\n', '\n', '    // update balances\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Allow _spender to withdraw from your account up to _amount */\n', '\n', '  function approve(address _spender, uint _amount) public returns (bool success) {\n', '    // approval amount cannot exceed the balance\n', '    require (balances[msg.sender] >= _amount);\n', '      \n', '    // update allowed amount\n', '    allowed[msg.sender][_spender] = _amount;\n', '    \n', '    // log event\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Spender of coins transfers coins from the owner&#39;s balance */\n', '  /* Must be pre-approved by owner */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    // balance checks\n', '    require(balances[_from] >= _amount);\n', '    require(allowed[_from][msg.sender] >= _amount);\n', '\n', '    // update balances and allowed amount\n', '    balances[_from] = balances[_from].sub(_amount);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Returns the amount of coins approved by the owner */\n', '  /* that can be transferred by spender */\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract krypteum is ERC20Coin {\n', '\n', '  /* Basic coin data */\n', '\n', '  string public constant name = "krypteum";\n', '  string public constant symbol = "KTM";\n', '  uint8  public constant decimals = 2;\n', '\n', '  /* Wallet and Admin addresses - initially set to owner at deployment */\n', '\n', '  address public wallet;\n', '  address public administrator;\n', '\n', '  /* ICO dates */\n', '\n', '  uint public constant DATE_ICO_START = 1518480000; // 13-Feb-2018 00:00 GMT\n', '  uint public constant DATE_ICO_END   = 1522713540; // 2-Apr-2018 23:59 GMT\n', '\n', '  /* ICO coins per ETH */\n', '  uint public constant COIN_COST_ICO_TIER_1 = 110 finney; // 0.11 ETH\n', '  uint public constant COIN_COST_ICO_TIER_2 = 120 finney; // 0.12 ETH\n', '  uint public constant COIN_COST_ICO_TIER_3 = 130 finney; // 0.13 ETH\n', '\n', '  /* ICO and other coin supply parameters */\n', '\n', '  uint public constant COIN_SUPPLY_ICO_TIER_1 = 50000; // 50K coins\n', '  uint public constant COIN_SUPPLY_ICO_TIER_2 = 25000; // 25K coins\n', '  uint public constant COIN_SUPPLY_ICO_TIER_3 = 25000; // 25K coins\n', '  uint public constant COIN_SUPPLY_ICO_TOTAL =         // 100K coins\n', '    COIN_SUPPLY_ICO_TIER_1 + COIN_SUPPLY_ICO_TIER_2 + COIN_SUPPLY_ICO_TIER_3;\n', '\n', '  uint public constant COIN_SUPPLY_MARKETING_TOTAL =   200000; // 200K coins\n', '\n', '  /* Other ICO parameters */\n', '\n', '  uint public constant COOLDOWN_PERIOD =  24 hours;\n', '\n', '  /* Crowdsale variables */\n', '\n', '  uint public icoEtherReceived = 0; // Ether actually received by the contract\n', '  uint public coinsIssuedMkt = 0;\n', '  uint public coinsIssuedIco  = 0;\n', '  uint[] public numberOfCoinsAvailableInIcoTier;\n', '  uint[] public costOfACoinInWeiForTier;\n', '\n', '  /* Keep track of Ether contributed and coins received during Crowdsale */\n', '\n', '  mapping(address => uint) public icoEtherContributed;\n', '  mapping(address => uint) public icoCoinsReceived;\n', '\n', '  /* Keep track of participants who\n', '  /* - have reclaimed their contributions in case of failed Crowdsale */\n', '  /* - are locked */\n', '\n', '  mapping(address => bool) public locked;\n', '\n', '  // Events ---------------------------\n', '\n', '  event WalletUpdated(address _newWallet);\n', '  event AdministratorUpdated(address _newAdministrator);\n', '  event CoinsMinted(address indexed _owner, uint _coins, uint _balance);\n', '  event CoinsIssued(address indexed _owner, uint _coins, uint _balance, uint _etherContributed);\n', '  event LockRemoved(address indexed _participant);\n', '\n', '  // Basic Functions ------------------\n', '\n', '  /* Initialize (owner is set to msg.sender by Owned.Owned() */\n', '\n', '  function krypteum() public {\n', '    wallet = owner;\n', '    administrator = owner;\n', '\n', '    numberOfCoinsAvailableInIcoTier.length = 3;\n', '    numberOfCoinsAvailableInIcoTier[0] = COIN_SUPPLY_ICO_TIER_1;\n', '    numberOfCoinsAvailableInIcoTier[1] = COIN_SUPPLY_ICO_TIER_2;\n', '    numberOfCoinsAvailableInIcoTier[2] = COIN_SUPPLY_ICO_TIER_3;\n', '\n', '    costOfACoinInWeiForTier.length = 3;\n', '    costOfACoinInWeiForTier[0] = COIN_COST_ICO_TIER_1;\n', '    costOfACoinInWeiForTier[1] = COIN_COST_ICO_TIER_2;\n', '    costOfACoinInWeiForTier[2] = COIN_COST_ICO_TIER_3;\n', '  }\n', '\n', '  /* Fallback */\n', '\n', '  function () public payable {\n', '    buyCoins();\n', '  }\n', '\n', '  // Information functions ------------\n', '\n', '  /* What time is it? */\n', '\n', '  function atNow() public constant returns (uint) {\n', '    return now;\n', '  }\n', '\n', '    /* Are coins transferable? */\n', '\n', '  function isTransferable() public constant returns (bool transferable) {\n', '      return atNow() >= DATE_ICO_END + COOLDOWN_PERIOD;\n', '  }\n', '\n', '  // Lock functions -------------------\n', '\n', '  /* Manage locked */\n', '\n', '  function removeLock(address _participant) public {\n', '    require(msg.sender == administrator || msg.sender == owner);\n', '\n', '    locked[_participant] = false;\n', '    LockRemoved(_participant);\n', '  }\n', '\n', '  function removeLockMultiple(address[] _participants) public {\n', '    require(msg.sender == administrator || msg.sender == owner);\n', '\n', '    for (uint i = 0; i < _participants.length; i++) {\n', '      locked[_participants[i]] = false;\n', '      LockRemoved(_participants[i]);\n', '    }\n', '  }\n', '\n', '  // Owner Functions ------------------\n', '\n', '  /* Change the crowdsale wallet address */\n', '\n', '  function setWallet(address _wallet) public onlyOwner {\n', '    require(_wallet != address(0x0));\n', '    wallet = _wallet;\n', '    WalletUpdated(wallet);\n', '  }\n', '\n', '  /* Change the administrator address */\n', '\n', '  function setAdministrator(address _admin) public onlyOwner {\n', '    require(_admin != address(0x0));\n', '    administrator = _admin;\n', '    AdministratorUpdated(administrator);\n', '  }\n', '\n', '  /* Granting / minting of marketing coins by owner */\n', '\n', '  function grantCoins(address _participant, uint _coins) public onlyOwner {\n', '    // check amount\n', '    require(_coins <= COIN_SUPPLY_MARKETING_TOTAL.sub(coinsIssuedMkt));\n', '\n', '    // update balances\n', '    balances[_participant] = balances[_participant].add(_coins);\n', '    coinsIssuedMkt = coinsIssuedMkt.add(_coins);\n', '    coinsIssuedTotal = coinsIssuedTotal.add(_coins);\n', '\n', '    // locked\n', '    locked[_participant] = true;\n', '\n', '    // log the minting\n', '    Transfer(0x0, _participant, _coins);\n', '    CoinsMinted(_participant, _coins, balances[_participant]);\n', '  }\n', '\n', '  /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '  function transferAnyERC20Token(address tokenAddress, uint amount) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  }\n', '\n', '  // Private functions ----------------\n', '\n', '  /* Accept ETH during crowdsale (called by default function) */\n', '\n', '  function buyCoins() private {\n', '    uint ts = atNow();\n', '    uint coins = 0;\n', '    uint change = 0;\n', '\n', '    // check dates for ICO\n', '    require(DATE_ICO_START < ts && ts < DATE_ICO_END);\n', '\n', '    (coins, change) = calculateCoinsPerWeiAndUpdateAvailableIcoCoins(msg.value);\n', '\n', '    // ICO coins are available to be sold.\n', '    require(coins > 0);\n', '\n', '    // ICO coin volume cap\n', '    require(coinsIssuedIco.add(coins).add(sumOfAvailableIcoCoins()) == COIN_SUPPLY_ICO_TOTAL);\n', '\n', '    // change is not given back unless we&#39;re selling the last available ICO coins.\n', '    require(change == 0 || coinsIssuedIco.add(coins) == COIN_SUPPLY_ICO_TOTAL);\n', '\n', '    // register coins\n', '    balances[msg.sender] = balances[msg.sender].add(coins);\n', '    icoCoinsReceived[msg.sender] = icoCoinsReceived[msg.sender].add(coins);\n', '    coinsIssuedIco = coinsIssuedIco.add(coins);\n', '    coinsIssuedTotal = coinsIssuedTotal.add(coins);\n', '\n', '    // register Ether\n', '    icoEtherReceived = icoEtherReceived.add(msg.value).sub(change);\n', '    icoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value).sub(change);\n', '\n', '    // locked\n', '    locked[msg.sender] = true;\n', '\n', '    // log coin issuance\n', '    Transfer(0x0, msg.sender, coins);\n', '    CoinsIssued(msg.sender, coins, balances[msg.sender], msg.value.sub(change));\n', '\n', '    // return a change if not enough ICO coins left\n', '    if (change > 0)\n', '       msg.sender.transfer(change);\n', '\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function sumOfAvailableIcoCoins() internal constant returns (uint totalAvailableIcoCoins) {\n', '    totalAvailableIcoCoins = 0;\n', '    for (uint8 i = 0; i < numberOfCoinsAvailableInIcoTier.length; i++) {\n', '      totalAvailableIcoCoins = totalAvailableIcoCoins.add(numberOfCoinsAvailableInIcoTier[i]);\n', '    }\n', '  }\n', '\n', '  function calculateCoinsPerWeiAndUpdateAvailableIcoCoins(uint value) internal returns (uint coins, uint change) {\n', '    coins = 0;\n', '    change = value;\n', '\n', '    for (uint8 i = 0; i < numberOfCoinsAvailableInIcoTier.length; i++) {\n', '      uint costOfAvailableCoinsInCurrentTier = numberOfCoinsAvailableInIcoTier[i].mul(costOfACoinInWeiForTier[i]);\n', '\n', '      if (change <= costOfAvailableCoinsInCurrentTier) {\n', '        uint coinsInCurrentTierToBuy = change.div(costOfACoinInWeiForTier[i]);\n', '        coins = coins.add(coinsInCurrentTierToBuy);\n', '        numberOfCoinsAvailableInIcoTier[i] = numberOfCoinsAvailableInIcoTier[i].sub(coinsInCurrentTierToBuy);\n', '        change = 0;\n', '        break;\n', '      }\n', '\n', '      coins = coins.add(numberOfCoinsAvailableInIcoTier[i]);\n', '      change = change.sub(costOfAvailableCoinsInCurrentTier);\n', '      numberOfCoinsAvailableInIcoTier[i] = 0;\n', '    }\n', '  }\n', '\n', '  // ERC20 functions ------------------\n', '\n', '  /* Override "transfer" (ERC20) */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    require(isTransferable());\n', '    require(locked[msg.sender] == false);\n', '    require(locked[_to] == false);\n', '\n', '    return super.transfer(_to, _amount);\n', '  }\n', '\n', '  /* Override "transferFrom" (ERC20) */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    require(isTransferable());\n', '    require(locked[_from] == false);\n', '    require(locked[_to] == false);\n', '\n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', '  // External functions ---------------\n', '\n', '  /* Multiple coin transfers from one address to save gas */\n', '  /* (longer _amounts array not accepted = sanity check) */\n', '\n', '  function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '    require(isTransferable());\n', '    require(locked[msg.sender] == false);\n', '    require(_addresses.length == _amounts.length);\n', '\n', '    for (uint i = 0; i < _addresses.length; i++) {\n', '      if (locked[_addresses[i]] == false)\n', '         super.transfer(_addresses[i], _amounts[i]);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// krypteum public sale contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  // Events ---------------------------\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  // Modifier -------------------------\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  // Functions ------------------------\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != owner);\n', '    require(_newOwner != address(0x0));\n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '  // Events ---------------------------\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '  // Functions ------------------------\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function balanceOf(address _owner) public constant returns (uint balance);\n', '  function transfer(address _to, uint _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '  function approve(address _spender, uint _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Coin Standard #20\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Coin is ERC20Interface, Owned {\n', '  \n', '  using SafeMath for uint;\n', '\n', '  uint public coinsIssuedTotal = 0;\n', '  mapping(address => uint) public balances;\n', '  mapping(address => mapping (address => uint)) public allowed;\n', '\n', '  // Functions ------------------------\n', '\n', '  /* Total coin supply */\n', '\n', '  function totalSupply() public constant returns (uint) {\n', '    return coinsIssuedTotal;\n', '  }\n', '\n', '  /* Get the account balance for an address */\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', "  /* Transfer the balance from owner's account to another account */\n", '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    // amount sent cannot exceed balance\n', '    require(balances[msg.sender] >= _amount);\n', '\n', '    // update balances\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Allow _spender to withdraw from your account up to _amount */\n', '\n', '  function approve(address _spender, uint _amount) public returns (bool success) {\n', '    // approval amount cannot exceed the balance\n', '    require (balances[msg.sender] >= _amount);\n', '      \n', '    // update allowed amount\n', '    allowed[msg.sender][_spender] = _amount;\n', '    \n', '    // log event\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', "  /* Spender of coins transfers coins from the owner's balance */\n", '  /* Must be pre-approved by owner */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    // balance checks\n', '    require(balances[_from] >= _amount);\n', '    require(allowed[_from][msg.sender] >= _amount);\n', '\n', '    // update balances and allowed amount\n', '    balances[_from] = balances[_from].sub(_amount);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Returns the amount of coins approved by the owner */\n', '  /* that can be transferred by spender */\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract krypteum is ERC20Coin {\n', '\n', '  /* Basic coin data */\n', '\n', '  string public constant name = "krypteum";\n', '  string public constant symbol = "KTM";\n', '  uint8  public constant decimals = 2;\n', '\n', '  /* Wallet and Admin addresses - initially set to owner at deployment */\n', '\n', '  address public wallet;\n', '  address public administrator;\n', '\n', '  /* ICO dates */\n', '\n', '  uint public constant DATE_ICO_START = 1518480000; // 13-Feb-2018 00:00 GMT\n', '  uint public constant DATE_ICO_END   = 1522713540; // 2-Apr-2018 23:59 GMT\n', '\n', '  /* ICO coins per ETH */\n', '  uint public constant COIN_COST_ICO_TIER_1 = 110 finney; // 0.11 ETH\n', '  uint public constant COIN_COST_ICO_TIER_2 = 120 finney; // 0.12 ETH\n', '  uint public constant COIN_COST_ICO_TIER_3 = 130 finney; // 0.13 ETH\n', '\n', '  /* ICO and other coin supply parameters */\n', '\n', '  uint public constant COIN_SUPPLY_ICO_TIER_1 = 50000; // 50K coins\n', '  uint public constant COIN_SUPPLY_ICO_TIER_2 = 25000; // 25K coins\n', '  uint public constant COIN_SUPPLY_ICO_TIER_3 = 25000; // 25K coins\n', '  uint public constant COIN_SUPPLY_ICO_TOTAL =         // 100K coins\n', '    COIN_SUPPLY_ICO_TIER_1 + COIN_SUPPLY_ICO_TIER_2 + COIN_SUPPLY_ICO_TIER_3;\n', '\n', '  uint public constant COIN_SUPPLY_MARKETING_TOTAL =   200000; // 200K coins\n', '\n', '  /* Other ICO parameters */\n', '\n', '  uint public constant COOLDOWN_PERIOD =  24 hours;\n', '\n', '  /* Crowdsale variables */\n', '\n', '  uint public icoEtherReceived = 0; // Ether actually received by the contract\n', '  uint public coinsIssuedMkt = 0;\n', '  uint public coinsIssuedIco  = 0;\n', '  uint[] public numberOfCoinsAvailableInIcoTier;\n', '  uint[] public costOfACoinInWeiForTier;\n', '\n', '  /* Keep track of Ether contributed and coins received during Crowdsale */\n', '\n', '  mapping(address => uint) public icoEtherContributed;\n', '  mapping(address => uint) public icoCoinsReceived;\n', '\n', '  /* Keep track of participants who\n', '  /* - have reclaimed their contributions in case of failed Crowdsale */\n', '  /* - are locked */\n', '\n', '  mapping(address => bool) public locked;\n', '\n', '  // Events ---------------------------\n', '\n', '  event WalletUpdated(address _newWallet);\n', '  event AdministratorUpdated(address _newAdministrator);\n', '  event CoinsMinted(address indexed _owner, uint _coins, uint _balance);\n', '  event CoinsIssued(address indexed _owner, uint _coins, uint _balance, uint _etherContributed);\n', '  event LockRemoved(address indexed _participant);\n', '\n', '  // Basic Functions ------------------\n', '\n', '  /* Initialize (owner is set to msg.sender by Owned.Owned() */\n', '\n', '  function krypteum() public {\n', '    wallet = owner;\n', '    administrator = owner;\n', '\n', '    numberOfCoinsAvailableInIcoTier.length = 3;\n', '    numberOfCoinsAvailableInIcoTier[0] = COIN_SUPPLY_ICO_TIER_1;\n', '    numberOfCoinsAvailableInIcoTier[1] = COIN_SUPPLY_ICO_TIER_2;\n', '    numberOfCoinsAvailableInIcoTier[2] = COIN_SUPPLY_ICO_TIER_3;\n', '\n', '    costOfACoinInWeiForTier.length = 3;\n', '    costOfACoinInWeiForTier[0] = COIN_COST_ICO_TIER_1;\n', '    costOfACoinInWeiForTier[1] = COIN_COST_ICO_TIER_2;\n', '    costOfACoinInWeiForTier[2] = COIN_COST_ICO_TIER_3;\n', '  }\n', '\n', '  /* Fallback */\n', '\n', '  function () public payable {\n', '    buyCoins();\n', '  }\n', '\n', '  // Information functions ------------\n', '\n', '  /* What time is it? */\n', '\n', '  function atNow() public constant returns (uint) {\n', '    return now;\n', '  }\n', '\n', '    /* Are coins transferable? */\n', '\n', '  function isTransferable() public constant returns (bool transferable) {\n', '      return atNow() >= DATE_ICO_END + COOLDOWN_PERIOD;\n', '  }\n', '\n', '  // Lock functions -------------------\n', '\n', '  /* Manage locked */\n', '\n', '  function removeLock(address _participant) public {\n', '    require(msg.sender == administrator || msg.sender == owner);\n', '\n', '    locked[_participant] = false;\n', '    LockRemoved(_participant);\n', '  }\n', '\n', '  function removeLockMultiple(address[] _participants) public {\n', '    require(msg.sender == administrator || msg.sender == owner);\n', '\n', '    for (uint i = 0; i < _participants.length; i++) {\n', '      locked[_participants[i]] = false;\n', '      LockRemoved(_participants[i]);\n', '    }\n', '  }\n', '\n', '  // Owner Functions ------------------\n', '\n', '  /* Change the crowdsale wallet address */\n', '\n', '  function setWallet(address _wallet) public onlyOwner {\n', '    require(_wallet != address(0x0));\n', '    wallet = _wallet;\n', '    WalletUpdated(wallet);\n', '  }\n', '\n', '  /* Change the administrator address */\n', '\n', '  function setAdministrator(address _admin) public onlyOwner {\n', '    require(_admin != address(0x0));\n', '    administrator = _admin;\n', '    AdministratorUpdated(administrator);\n', '  }\n', '\n', '  /* Granting / minting of marketing coins by owner */\n', '\n', '  function grantCoins(address _participant, uint _coins) public onlyOwner {\n', '    // check amount\n', '    require(_coins <= COIN_SUPPLY_MARKETING_TOTAL.sub(coinsIssuedMkt));\n', '\n', '    // update balances\n', '    balances[_participant] = balances[_participant].add(_coins);\n', '    coinsIssuedMkt = coinsIssuedMkt.add(_coins);\n', '    coinsIssuedTotal = coinsIssuedTotal.add(_coins);\n', '\n', '    // locked\n', '    locked[_participant] = true;\n', '\n', '    // log the minting\n', '    Transfer(0x0, _participant, _coins);\n', '    CoinsMinted(_participant, _coins, balances[_participant]);\n', '  }\n', '\n', '  /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '  function transferAnyERC20Token(address tokenAddress, uint amount) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  }\n', '\n', '  // Private functions ----------------\n', '\n', '  /* Accept ETH during crowdsale (called by default function) */\n', '\n', '  function buyCoins() private {\n', '    uint ts = atNow();\n', '    uint coins = 0;\n', '    uint change = 0;\n', '\n', '    // check dates for ICO\n', '    require(DATE_ICO_START < ts && ts < DATE_ICO_END);\n', '\n', '    (coins, change) = calculateCoinsPerWeiAndUpdateAvailableIcoCoins(msg.value);\n', '\n', '    // ICO coins are available to be sold.\n', '    require(coins > 0);\n', '\n', '    // ICO coin volume cap\n', '    require(coinsIssuedIco.add(coins).add(sumOfAvailableIcoCoins()) == COIN_SUPPLY_ICO_TOTAL);\n', '\n', "    // change is not given back unless we're selling the last available ICO coins.\n", '    require(change == 0 || coinsIssuedIco.add(coins) == COIN_SUPPLY_ICO_TOTAL);\n', '\n', '    // register coins\n', '    balances[msg.sender] = balances[msg.sender].add(coins);\n', '    icoCoinsReceived[msg.sender] = icoCoinsReceived[msg.sender].add(coins);\n', '    coinsIssuedIco = coinsIssuedIco.add(coins);\n', '    coinsIssuedTotal = coinsIssuedTotal.add(coins);\n', '\n', '    // register Ether\n', '    icoEtherReceived = icoEtherReceived.add(msg.value).sub(change);\n', '    icoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value).sub(change);\n', '\n', '    // locked\n', '    locked[msg.sender] = true;\n', '\n', '    // log coin issuance\n', '    Transfer(0x0, msg.sender, coins);\n', '    CoinsIssued(msg.sender, coins, balances[msg.sender], msg.value.sub(change));\n', '\n', '    // return a change if not enough ICO coins left\n', '    if (change > 0)\n', '       msg.sender.transfer(change);\n', '\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function sumOfAvailableIcoCoins() internal constant returns (uint totalAvailableIcoCoins) {\n', '    totalAvailableIcoCoins = 0;\n', '    for (uint8 i = 0; i < numberOfCoinsAvailableInIcoTier.length; i++) {\n', '      totalAvailableIcoCoins = totalAvailableIcoCoins.add(numberOfCoinsAvailableInIcoTier[i]);\n', '    }\n', '  }\n', '\n', '  function calculateCoinsPerWeiAndUpdateAvailableIcoCoins(uint value) internal returns (uint coins, uint change) {\n', '    coins = 0;\n', '    change = value;\n', '\n', '    for (uint8 i = 0; i < numberOfCoinsAvailableInIcoTier.length; i++) {\n', '      uint costOfAvailableCoinsInCurrentTier = numberOfCoinsAvailableInIcoTier[i].mul(costOfACoinInWeiForTier[i]);\n', '\n', '      if (change <= costOfAvailableCoinsInCurrentTier) {\n', '        uint coinsInCurrentTierToBuy = change.div(costOfACoinInWeiForTier[i]);\n', '        coins = coins.add(coinsInCurrentTierToBuy);\n', '        numberOfCoinsAvailableInIcoTier[i] = numberOfCoinsAvailableInIcoTier[i].sub(coinsInCurrentTierToBuy);\n', '        change = 0;\n', '        break;\n', '      }\n', '\n', '      coins = coins.add(numberOfCoinsAvailableInIcoTier[i]);\n', '      change = change.sub(costOfAvailableCoinsInCurrentTier);\n', '      numberOfCoinsAvailableInIcoTier[i] = 0;\n', '    }\n', '  }\n', '\n', '  // ERC20 functions ------------------\n', '\n', '  /* Override "transfer" (ERC20) */\n', '\n', '  function transfer(address _to, uint _amount) public returns (bool success) {\n', '    require(isTransferable());\n', '    require(locked[msg.sender] == false);\n', '    require(locked[_to] == false);\n', '\n', '    return super.transfer(_to, _amount);\n', '  }\n', '\n', '  /* Override "transferFrom" (ERC20) */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '    require(isTransferable());\n', '    require(locked[_from] == false);\n', '    require(locked[_to] == false);\n', '\n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', '  // External functions ---------------\n', '\n', '  /* Multiple coin transfers from one address to save gas */\n', '  /* (longer _amounts array not accepted = sanity check) */\n', '\n', '  function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '    require(isTransferable());\n', '    require(locked[msg.sender] == false);\n', '    require(_addresses.length == _amounts.length);\n', '\n', '    for (uint i = 0; i < _addresses.length; i++) {\n', '      if (locked[_addresses[i]] == false)\n', '         super.transfer(_addresses[i], _amounts[i]);\n', '    }\n', '  }\n', '}']
