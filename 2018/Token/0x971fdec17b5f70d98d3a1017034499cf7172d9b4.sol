['pragma solidity ^0.4.4;\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '}\n', '\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '\n', '        emit Transfer(msg.sender, to, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '\n', '        emit Transfer(from, to, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '\n', '        emit Approval(msg.sender, spender, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);                         // Check if the sender has enough\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);    // Subtract from the sender\n', '        totalSupply = safeSub(totalSupply,_value);                       // Updates totalSupply\n', '\n', '        emit Burn(msg.sender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balances[_from] >= _value);                                        // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);                             // Check allowance\n', '        balances[_from] = safeSub(balances[_from],_value);                         // Subtract from the targeted balance\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);   // Subtract from the sender&#39;s allowance\n', '        totalSupply = safeSub(totalSupply,_value);                                 // Update totalSupply\n', '        emit    Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract CryptonCoin is StandardToken {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    string public version = &#39;H1.0&#39;;\n', '    address public fundsWallet;\n', '    address public contractAddress;\n', '\n', '    uint256 public preIcoSupply;\n', '    uint256 public preIcoTotalSupply;\n', '\n', '    uint256 public IcoSupply;\n', '    uint256 public IcoTotalSupply;\n', '\n', '    uint256 public maxSupply;\n', '    uint256 public totalSupply;\n', '\n', '    uint256 public unitsOneEthCanBuy;\n', '    uint256 public totalEthInWei;\n', '\n', '    bool public ico_finish;\n', '    bool public token_was_created;\n', '\n', '    uint256 public preIcoFinishTimestamp;\n', '    uint256 public fundingEndTime;\n', '    uint256 public finalTokensIssueTime;\n', '\n', '    function CryptonCoin() public {\n', '        fundsWallet = msg.sender;\n', '\n', '        name = "CRYPTON";\n', '        symbol = "CRN";\n', '        decimals = 18;\n', '\n', '        balances[fundsWallet] = 0;\n', '        totalSupply       = 0;\n', '        preIcoTotalSupply = 14400000000000000000000000;\n', '        IcoTotalSupply    = 36000000000000000000000000;\n', '        maxSupply         = 72000000000000000000000000;\n', '        unitsOneEthCanBuy = 377;\n', '\n', '        preIcoFinishTimestamp = 1524785992; // Thu Apr 26 23:39:52 UTC 2018\n', '        fundingEndTime        = 1528587592; // Sat Jun  9 23:39:52 UTC 2018\n', '        finalTokensIssueTime  = 1577921992; // Wed Jan  1 23:39:52 UTC 2020\n', '\n', '        contractAddress = address(this);\n', '    }\n', '\n', '    function() public payable {\n', '        require(!ico_finish);\n', '        require(block.timestamp < fundingEndTime);\n', '        require(msg.value != 0);\n', '\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256  amount = 0;\n', '        uint256 tokenPrice = unitsOneEthCanBuy;\n', '\n', '        if (block.timestamp < preIcoFinishTimestamp) {\n', '            require(msg.value * tokenPrice * 13 / 10 <= (preIcoTotalSupply - preIcoSupply));\n', '\n', '            tokenPrice = safeMul(tokenPrice,13);\n', '            tokenPrice = safeDiv(tokenPrice,10);\n', '\n', '            amount = safeMul(msg.value,tokenPrice);\n', '            preIcoSupply = safeAdd(preIcoSupply,amount);\n', '\n', '            balances[msg.sender] = safeAdd(balances[msg.sender],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '\n', '            emit Transfer(contractAddress, msg.sender, amount);\n', '        } else {\n', '            require(msg.value * tokenPrice <= (IcoTotalSupply - IcoSupply));\n', '\n', '            amount = safeMul(msg.value,tokenPrice);\n', '            IcoSupply = safeAdd(IcoSupply,amount);\n', '            balances[msg.sender] = safeAdd(balances[msg.sender],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '\n', '            emit Transfer(contractAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function withdraw() public {\n', '            require(msg.sender == fundsWallet);\n', '            fundsWallet.transfer(contractAddress.balance);\n', '\n', '    }\n', '\n', '    function createTokensForCrypton() public returns (bool success) {\n', '        require(ico_finish);\n', '        require(!token_was_created);\n', '\n', '        if (block.timestamp > finalTokensIssueTime) {\n', '            uint256 amount = safeAdd(preIcoSupply, IcoSupply);\n', '            amount = safeMul(amount,3);\n', '            amount = safeDiv(amount,10);\n', '\n', '            balances[fundsWallet] = safeAdd(balances[fundsWallet],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '            emit Transfer(contractAddress, fundsWallet, amount);\n', '            token_was_created = true;\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function stopIco() public returns (bool success) {\n', '        if (block.timestamp > fundingEndTime) {\n', '            ico_finish = true;\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function setTokenPrice(uint256 _value) public returns (bool success) {\n', '        require(msg.sender == fundsWallet);\n', '        require(_value < 1500);\n', '        unitsOneEthCanBuy = _value;\n', '        return true;\n', '    }\n', '}\n', '//Based on the source from hashnode.com\n', '//CREATED BY MICHAŁ MICHALSKI @YSZTY with CRYPTON.VC']
['pragma solidity ^0.4.4;\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    /// @return total amount of tokens\n', '    function totalSupply() public constant returns (uint256 supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '}\n', '\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '\n', '        emit Transfer(msg.sender, to, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '\n', '        emit Transfer(from, to, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '\n', '        emit Approval(msg.sender, spender, tokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);                         // Check if the sender has enough\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);    // Subtract from the sender\n', '        totalSupply = safeSub(totalSupply,_value);                       // Updates totalSupply\n', '\n', '        emit Burn(msg.sender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balances[_from] >= _value);                                        // Check if the targeted balance is enough\n', '        require(_value <= allowed[_from][msg.sender]);                             // Check allowance\n', '        balances[_from] = safeSub(balances[_from],_value);                         // Subtract from the targeted balance\n', "        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);   // Subtract from the sender's allowance\n", '        totalSupply = safeSub(totalSupply,_value);                                 // Update totalSupply\n', '        emit    Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract CryptonCoin is StandardToken {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', "    string public version = 'H1.0';\n", '    address public fundsWallet;\n', '    address public contractAddress;\n', '\n', '    uint256 public preIcoSupply;\n', '    uint256 public preIcoTotalSupply;\n', '\n', '    uint256 public IcoSupply;\n', '    uint256 public IcoTotalSupply;\n', '\n', '    uint256 public maxSupply;\n', '    uint256 public totalSupply;\n', '\n', '    uint256 public unitsOneEthCanBuy;\n', '    uint256 public totalEthInWei;\n', '\n', '    bool public ico_finish;\n', '    bool public token_was_created;\n', '\n', '    uint256 public preIcoFinishTimestamp;\n', '    uint256 public fundingEndTime;\n', '    uint256 public finalTokensIssueTime;\n', '\n', '    function CryptonCoin() public {\n', '        fundsWallet = msg.sender;\n', '\n', '        name = "CRYPTON";\n', '        symbol = "CRN";\n', '        decimals = 18;\n', '\n', '        balances[fundsWallet] = 0;\n', '        totalSupply       = 0;\n', '        preIcoTotalSupply = 14400000000000000000000000;\n', '        IcoTotalSupply    = 36000000000000000000000000;\n', '        maxSupply         = 72000000000000000000000000;\n', '        unitsOneEthCanBuy = 377;\n', '\n', '        preIcoFinishTimestamp = 1524785992; // Thu Apr 26 23:39:52 UTC 2018\n', '        fundingEndTime        = 1528587592; // Sat Jun  9 23:39:52 UTC 2018\n', '        finalTokensIssueTime  = 1577921992; // Wed Jan  1 23:39:52 UTC 2020\n', '\n', '        contractAddress = address(this);\n', '    }\n', '\n', '    function() public payable {\n', '        require(!ico_finish);\n', '        require(block.timestamp < fundingEndTime);\n', '        require(msg.value != 0);\n', '\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256  amount = 0;\n', '        uint256 tokenPrice = unitsOneEthCanBuy;\n', '\n', '        if (block.timestamp < preIcoFinishTimestamp) {\n', '            require(msg.value * tokenPrice * 13 / 10 <= (preIcoTotalSupply - preIcoSupply));\n', '\n', '            tokenPrice = safeMul(tokenPrice,13);\n', '            tokenPrice = safeDiv(tokenPrice,10);\n', '\n', '            amount = safeMul(msg.value,tokenPrice);\n', '            preIcoSupply = safeAdd(preIcoSupply,amount);\n', '\n', '            balances[msg.sender] = safeAdd(balances[msg.sender],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '\n', '            emit Transfer(contractAddress, msg.sender, amount);\n', '        } else {\n', '            require(msg.value * tokenPrice <= (IcoTotalSupply - IcoSupply));\n', '\n', '            amount = safeMul(msg.value,tokenPrice);\n', '            IcoSupply = safeAdd(IcoSupply,amount);\n', '            balances[msg.sender] = safeAdd(balances[msg.sender],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '\n', '            emit Transfer(contractAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function withdraw() public {\n', '            require(msg.sender == fundsWallet);\n', '            fundsWallet.transfer(contractAddress.balance);\n', '\n', '    }\n', '\n', '    function createTokensForCrypton() public returns (bool success) {\n', '        require(ico_finish);\n', '        require(!token_was_created);\n', '\n', '        if (block.timestamp > finalTokensIssueTime) {\n', '            uint256 amount = safeAdd(preIcoSupply, IcoSupply);\n', '            amount = safeMul(amount,3);\n', '            amount = safeDiv(amount,10);\n', '\n', '            balances[fundsWallet] = safeAdd(balances[fundsWallet],amount);\n', '            totalSupply = safeAdd(totalSupply,amount);\n', '            emit Transfer(contractAddress, fundsWallet, amount);\n', '            token_was_created = true;\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function stopIco() public returns (bool success) {\n', '        if (block.timestamp > fundingEndTime) {\n', '            ico_finish = true;\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function setTokenPrice(uint256 _value) public returns (bool success) {\n', '        require(msg.sender == fundsWallet);\n', '        require(_value < 1500);\n', '        unitsOneEthCanBuy = _value;\n', '        return true;\n', '    }\n', '}\n', '//Based on the source from hashnode.com\n', '//CREATED BY MICHAŁ MICHALSKI @YSZTY with CRYPTON.VC']
