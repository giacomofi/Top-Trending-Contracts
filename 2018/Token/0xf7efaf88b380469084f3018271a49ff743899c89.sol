['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title SGDS ERC20 token\n', ' *\n', ' * @dev SGDS are stable coin from SEITEE Pte Ltd use only to compare\n', ' *  1 - 1 with SGD Dollar\n', ' *  it for use only internal in NATEE Service and other service from Seitee in future;\n', ' *  This stable coin are unlimit but can user a lot of crypto to buy it with exchange late FROM Seitee Only\n', ' *  SGDS are control by SEITEE Pte,Ltd. Please understand before purchase it\n', ' */\n', '\n', 'library SafeMath256 {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if(a==0 || b==0)\n', '        return 0;  \n', '    uint256 c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b>0);\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '   require( b<= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '\n', '// Only Owner modifier it support a lot owner but finally should have 1 owner\n', 'contract Ownable {\n', '\n', '  mapping (address=>bool) owners;\n', '  address owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  event AddOwner(address newOwner);\n', '  event RemoveOwner(address owner);\n', '\n', '   constructor() public {\n', '    owner = msg.sender;\n', '    owners[msg.sender] = true;\n', '  }\n', '\n', '  function isContract(address _addr) internal view returns(bool){\n', '     uint256 length;\n', '     assembly{\n', '      length := extcodesize(_addr)\n', '     }\n', '     if(length > 0){\n', '       return true;\n', '    }\n', '    else {\n', '      return false;\n', '    }\n', '\n', '  }\n', '\n', ' // For Single Owner\n', '  modifier onlyOwner(){\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner{\n', '    require(isContract(newOwner) == false); \n', '    emit OwnershipTransferred(owner,newOwner);\n', '    owner = newOwner;\n', '\n', '  }\n', '\n', '  //For multiple Owner\n', '  modifier onlyOwners(){\n', '    require(owners[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  function addOwner(address newOwner) public onlyOwners{\n', '    require(owners[newOwner] == false);\n', '    require(newOwner != msg.sender);\n', '\n', '    owners[newOwner] = true;\n', '    emit AddOwner(newOwner);\n', '  }\n', '\n', '  function removeOwner(address _owner) public onlyOwners{\n', "    require(_owner != msg.sender);  // can't remove your self\n", '    owners[_owner] = false;\n', '    emit RemoveOwner(_owner);\n', '  }\n', '\n', '  function isOwner(address _owner) public view returns(bool){\n', '    return owners[_owner];\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '       event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '       event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '\n', '       function totalSupply() public view returns (uint256);\n', '       function balanceOf(address tokenOwner) public view returns (uint256 balance);\n', '       function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n', '\n', '       function transfer(address to, uint256 tokens) public returns (bool success);\n', '       \n', '       function approve(address spender, uint256 tokens) public returns (bool success);\n', '       function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '  \n', '\n', '}\n', '\n', '\n', 'contract StandarERC20 is ERC20{\n', '  using SafeMath256 for uint256; \n', '     \n', '     mapping (address => uint256) balance;\n', '     mapping (address => mapping (address=>uint256)) allowed;\n', '\n', '\n', '     uint256  totalSupply_; \n', '     \n', '      event Transfer(address indexed from,address indexed to,uint256 value);\n', '      event Approval(address indexed owner,address indexed spender,uint256 value);\n', '\n', '\n', '    function totalSupply() public view returns (uint256){\n', '      return totalSupply_;\n', '    }\n', '\n', '     function balanceOf(address _walletAddress) public view returns (uint256){\n', '        return balance[_walletAddress]; \n', '     }\n', '\n', '\n', '     function allowance(address _owner, address _spender) public view returns (uint256){\n', '          return allowed[_owner][_spender];\n', '        }\n', '\n', '     function transfer(address _to, uint256 _value) public returns (bool){\n', '        require(_value <= balance[msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balance[msg.sender] = balance[msg.sender].sub(_value);\n', '        balance[_to] = balance[_to].add(_value);\n', '        emit Transfer(msg.sender,_to,_value);\n', '        \n', '        return true;\n', '\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value)\n', '            public returns (bool){\n', '            allowed[msg.sender][_spender] = _value;\n', '\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '            }\n', '\n', '      function transferFrom(address _from, address _to, uint256 _value)\n', '            public returns (bool){\n', '               require(_value <= balance[_from]);\n', '               require(_value <= allowed[_from][msg.sender]); \n', '               require(_to != address(0));\n', '\n', '              balance[_from] = balance[_from].sub(_value);\n', '              balance[_to] = balance[_to].add(_value);\n', '              allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '              emit Transfer(_from, _to, _value);\n', '              return true;\n', '      }\n', '\n', '\n', '     \n', '}\n', '\n', '\n', 'contract SGDS is StandarERC20, Ownable {\n', '  using SafeMath256 for uint256;\n', '  string public name = "SEITEE SGD";\n', '  string public symbol = "SGDS"; \n', '  uint256 public decimals = 2;\n', '  uint256 public totalUsed;\n', '  uint256 public totalPurchange;\n', '  uint256 public transFee = 100; // default transection fee = 1.00 SGDS\n', '  uint256 public version = 10000;\n', '  \n', '  \n', '  struct PurchaseData{\n', '    string fromCoin;   // Name OF Coin or Token BTC,LITE,ETH,ETC or other\n', '    uint256 value;     // Value from that coin  18 dacimon\n', '    uint256 exchangeRate; // 1: xxxxx   18 decimon\n', '    string tranHash;  // Tran hash from that token \n', '  }\n', '\n', '  event PurchaseSGDS(address indexed addr,uint256 value,uint256 refID);\n', '  event UsedSGDS(address indexed addr,uint256 value);\n', '  event SetControlToken(address indexed addr, bool outControl);\n', '  event FeeTransfer(address indexed addr,uint256 _value);\n', '  event TransferWallet(address indexed from,address indexed to,address indexed execute_);\n', '\n', "  mapping(address => bool) userControl;   // if true mean can't not control this address\n", '  mapping(uint256 => uint256) purchaseID;\n', '\n', '  PurchaseData[]  purDatas;\n', '\n', '  constructor() public {\n', '    totalSupply_ = 0;\n', '    totalUsed = 0;\n', '    totalPurchange = 0;\n', '  }\n', '\n', '// It can only purchase direct from SETITEE ONLY\n', '  function purchaseSGDS(address addr, uint256 value,uint256 refID,string fromCoin,uint256 coinValue,uint256 rate,string txHash)  external onlyOwners{\n', '    balance[addr] += value;\n', '    totalSupply_ += value;\n', '    totalPurchange += value;\n', '    \n', '    uint256 id = purDatas.push(PurchaseData(fromCoin,coinValue,rate,txHash));\n', '    purchaseID[refID] = id;\n', '\n', '    emit PurchaseSGDS(addr,value,refID);\n', '    emit Transfer(address(this),addr,value);\n', '  }\n', '\n', '  function getPurchaseData(uint256 refID) view public returns(string fromCoin,uint256 value,uint256 exchangeRate,string txHash) {\n', '    require(purchaseID[refID] > 0);\n', '    uint256  pId = purchaseID[refID] - 1;\n', '    PurchaseData memory pData = purDatas[pId];\n', '\n', '    fromCoin = pData.fromCoin;\n', '    value = pData.value;\n', '    exchangeRate = pData.exchangeRate;\n', '    txHash = pData.tranHash;\n', '\n', '  }\n', '\n', '// This will cal only in website then it will no gas fee for user that buy and use in my system.\n', '// SETITEE will pay for that\n', '  function useSGDS(address useAddr,uint256 value) onlyOwners external returns(bool)  {\n', '    require(userControl[useAddr] == false); // if true user want to  make it by your self\n', '    require(balance[useAddr] >= value);\n', '\n', '    balance[useAddr] -= value;\n', '    totalSupply_ -= value;\n', '    totalUsed += value;\n', '\n', '    emit UsedSGDS(useAddr,value);\n', '    emit Transfer(useAddr,address(0),value);\n', '\n', '    return true;\n', '  }\n', '\n', '// This for use seitee transfer . Seitee will pay for gas\n', '  function intTransfer(address _from, address _to, uint256 _value) external onlyOwners returns(bool){\n', '    require(userControl[_from] == false);  // Company can do if they still allow compay to do it\n', '    require(balance[_from] >= _value);\n', '    require(_to != address(0));\n', '        \n', '    balance[_from] -= _value; \n', '    balance[_to] += _value;\n', '    \n', '    emit Transfer(_from,_to,_value);\n', '    return true;\n', '  }\n', '\n', '  // For transfer all SGDS Token to new Wallet Address. Want to pay 1 SGDS for fee.\n', '  \n', '  function transferWallet(address _from,address _to) external onlyOwners{\n', '        require(userControl[_from] == false);\n', '        require(balance[_from] > transFee);  //Fee 1 SGDS\n', '        uint256  value = balance[_from];\n', '\n', '        balance[_from] = balance[_from].sub(value);\n', '        balance[_to] = balance[_to].add(value - transFee); // sub with FEE\n', '\n', '        emit TransferWallet(_from,_to,msg.sender);\n', '        emit Transfer(_from,_to,value - transFee);\n', '        emit FeeTransfer(_to,transFee);\n', '  }\n', '\n', '// Address Owner can set permision by him self. Set to true will stop company control his/her wallet\n', '  function setUserControl(bool _control) public {\n', '    userControl[msg.sender] = _control;\n', '    emit SetControlToken(msg.sender,_control);\n', '  }\n', '\n', '  function getUserControl(address _addr) external view returns(bool){\n', '    return userControl[_addr];\n', '  }\n', '  \n', '  function setTransFee(uint256 _fee) onlyOwners public{\n', '    transFee = _fee;\n', '  }\n', '}']