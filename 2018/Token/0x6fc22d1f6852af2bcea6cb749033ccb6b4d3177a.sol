['pragma solidity ^0.4.24;\n', '\n', 'contract owned {\n', '    address public owner;\n', '}\n', '\n', 'contract TokenERC20 {\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '}\n', '\n', 'contract BitSTDShares is owned, TokenERC20 {\n', '\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '}\n', '\n', 'contract BitSTDData {\n', '    // Used to control data migration\n', '    bool public data_migration_control = true;\n', '    address public owner;\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    // An array of all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    // The allowed address zhi value wei value is true\n', '    mapping (address => bool) public owners;\n', '    // Freeze address\n', '    mapping (address => bool) public frozenAccount;\n', '    BitSTDShares private bit;\n', '\n', '    constructor(address contractAddress) public {\n', '        bit = BitSTDShares(contractAddress);\n', '        owner = msg.sender;\n', '        name = bit.name();\n', '        symbol = bit.symbol();\n', '        decimals = bit.decimals();\n', '        sellPrice = bit.sellPrice();\n', '        buyPrice = bit.buyPrice();\n', '        totalSupply = bit.totalSupply();\n', '        balanceOf[msg.sender] = totalSupply;\n', '    }\n', '\n', '    modifier qualification {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Move the super administrator\n', '    function transferAuthority(address newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setBalanceOfAddr(address addr, uint256 value) qualification public {\n', '        balanceOf[addr] = value;\n', '    }\n', '\n', '    function setAllowance(address authorizer, address sender, uint256 value) qualification public {\n', '        allowance[authorizer][sender] = value;\n', '    }\n', '\n', '\n', '    function setFrozenAccount(address addr, bool value) qualification public {\n', '        frozenAccount[addr] = value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 value) qualification public {\n', '        totalSupply = value;\n', '    }\n', '\n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n', '        require(msg.sender == owner);\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '    }\n', '\n', '    // Old contract data\n', '    function getOldBalanceOf(address addr) constant  public returns(uint256) {\n', '       return bit.balanceOf(addr);\n', '    }\n', '   \n', '    \n', '    function getOldAllowance(address authorizer, address sender) constant  public returns(uint256) {\n', '        return bit.allowance(authorizer, sender);\n', '    }\n', '\n', '    function getOldFrozenAccount(address addr) constant public returns(bool) {\n', '        return bit.frozenAccount(addr);\n', '    }\n', '   \n', '}\n', '\n', '\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract BitSTDLogic {\n', '    address public owner;\n', '    // data layer\n', '\tBitSTDData private data;\n', '\n', '    constructor(address dataAddress) {\n', '        data = BitSTDData(dataAddress);\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    // Transfer logical layer authority\n', '    function transferAuthority(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '\tmodifier onlyOwner(){\n', '\t\trequire(msg.sender == owner);\n', '        _;\n', '\t}\n', '\t\n', '\t// Transfer data layer authority\n', '    function transferDataAuthority(address newOwner) onlyOwner public {\n', '        data.transferAuthority(newOwner);\n', '    }\n', '    function setData(address dataAddress)onlyOwner public {\n', '        data = BitSTDData(dataAddress);\n', '    }\n', '\n', '    // Old contract data\n', '    function getOldBalanceOf(address addr) constant public returns (uint256) {\n', '        return data.getOldBalanceOf(addr);\n', '    }\n', '\n', '\t/**\n', '\t * Internal transfers can only be invoked through this contract\n', '\t*/\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        uint256 f_value = balanceOf(_from);\n', '        uint256 t_value = balanceOf(_to);\n', '        // Prevents transmission to 0x0 address.Call to Burn ()\n', '        require(_to != 0x0);\n', '        // Check that the sender is adequate\n', '        require(f_value >= _value);\n', '        // Check the overflow\n', '        require(t_value + _value > t_value);\n', '        // Save it as a future assertion\n', '        uint previousBalances = f_value + t_value;\n', '        // Minus from the sender\n', '        setBalanceOf(_from, f_value - _value);\n', '        // Add to receiver\n', '        setBalanceOf(_to, t_value + _value);\n', '\n', '        // Assertions are used to use static analysis to detect errors in code.They should not fail\n', '        assert(balanceOf(_from) + balanceOf(_to) == previousBalances);\n', '\n', '    }\n', '    // data migration\n', '    function migration(address sender, address receiver) onlyOwner public returns (bool) {\n', '        require(sender != receiver);\n', '        bool result= false;\n', '        // Start data migration\n', '        // uint256 t_value = balanceOf(receiver);\n', '        uint256 _value = data.getOldBalanceOf(receiver);\n', '        //Transfer balance\n', '        if (data.balanceOf(receiver) == 0) {\n', '            if (_value > 0) {\n', '                _transfer(sender, receiver, _value);\n', '                result = true;\n', '            }\n', '        }\n', '        //Frozen account migration\n', '        if (data.getOldFrozenAccount(receiver)== true) {\n', '            if (data.frozenAccount(receiver)!= true) {\n', '                data.setFrozenAccount(receiver, true);\n', '            }\n', '        }\n', '        //End data migration\n', '        return result;\n', '    }\n', '\n', '    // Check the contract token\n', '    function balanceOf(address addr) constant public returns (uint256) {\n', '        return data.balanceOf(addr);\n', '    }\n', '\n', '    function name() constant public returns (string) {\n', '  \t   return data.name();\n', '  \t}\n', '\n', '  \tfunction symbol() constant public returns(string) {\n', '  \t   return data.symbol();\n', '  \t}\n', '\n', '  \tfunction decimals() constant public returns(uint8) {\n', '  \t   return data.decimals();\n', '  \t}\n', '\n', '  \tfunction totalSupply() constant public returns(uint256) {\n', '  \t   return data.totalSupply();\n', '  \t}\n', '\n', '  \tfunction allowance(address authorizer, address sender) constant public returns(uint256) {\n', '  \t   return data.allowance(authorizer, sender);\n', '  \t}\n', '\n', '  \tfunction sellPrice() constant public returns (uint256) {\n', '  \t   return data.sellPrice();\n', '  \t}\n', '\n', '  \tfunction buyPrice() constant public returns (uint256) {\n', '  \t   return data.buyPrice();\n', '  \t}\n', '\n', '  \tfunction frozenAccount(address addr) constant public returns(bool) {\n', '  \t   return data.frozenAccount(addr);\n', '  \t}\n', '\n', '    //Modify the contract\n', '    function setBalanceOf(address addr, uint256 value) onlyOwner public {\n', '        data.setBalanceOfAddr(addr, value);\n', '    }\n', '\n', '    /**\n', '     * Pass the token\n', '     * send a value token to your account\n', '    */\n', '    function transfer(address sender, address _to, uint256 _value) onlyOwner public returns (bool) {\n', '        _transfer(sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *Passing tokens from other addresses\n', '      *\n', '      * sends the value token to "to", representing "from"\n', '      *\n', '      * @param _from sender&#39;s address\n', '      * @param _to recipient&#39;s address\n', '      * @param _value number sent\n', '     */\n', '    function transferFrom(address _from, address sender, address _to, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 a_value = data.allowance(_from, sender);\n', '        require(_value <=_value ); // Check allowance\n', '        data.setAllowance(_from, sender, a_value - _value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '     /**\n', '* set allowances for other addresses\n', '*\n', '* allow the "spender" to spend only the "value" card in your name\n', '*\n', '* @param _spender authorized address\n', '* @param _value they can spend the most money\n', '     */\n', '    function approve(address _spender, address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        data.setAllowance(sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Grant and notify other addresses\n', '       *\n', '       * allow "spender" to only mark "value" in your name and then write the contract on it.\n', '       *\n', '       * @param _spender authorized address\n', '       * @param _value they can spend the most money\n', '       * @param _extraData sends some additional information to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, address sender, address _contract, uint256 _value, bytes _extraData) onlyOwner public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, sender, _value)) {\n', '            spender.receiveApproval(sender, _value, _contract, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '     /**\n', '     * Destroy the tokens,\n', '       *\n', '       * delete "value" tokens from the system\n', '       *\n', '       * param _value the amount of money to burn\n', '     */\n', '    function burn(address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 f_value = balanceOf(sender);\n', '        require(f_value >= _value);                 // Check that the sender is adequate\n', '        setBalanceOf(sender, f_value - _value);    // Minus from the sender\n', '        data.addTotalSupply(totalSupply() - _value);                      // Renewal aggregate supply\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other accounts\n', '       *\n', '       * delete "value" tokens from "from" in the system.\n', '       *\n', '       * @param _from the address of the sender\n', '       * param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 f_value = balanceOf(sender);\n', '        uint256 a_value = data.allowance(_from, sender);\n', '        require(f_value >= _value);                             // Check that the target balance is adequate\n', '        require(_value <= a_value);                             // Check the allowance\n', '        setBalanceOf(_from, f_value - _value);                // Subtract from the goal balance\n', '        data.setAllowance(_from, sender, f_value - _value);  // Minus the sender&#39;s allowance\n', '        data.addTotalSupply(totalSupply() - _value);         // update totalSupply\n', '\n', '        return true;\n', '    }\n', '\n', '    //@ notifies you to create the mintedAmount token and send it to the target\n', '      // @param target address receiving token\n', '      // @param mintedAmount will receive the number of tokens\n', '    function mintToken(address target, address _contract, uint256 mintedAmount) onlyOwner public {\n', '        uint256 f_value = balanceOf(target);\n', '        setBalanceOf(target, f_value + mintedAmount);\n', '        data.addTotalSupply(totalSupply() + mintedAmount);\n', '\n', '    }\n', '\n', '    //Notice freezes the account to prevent "target" from sending and receiving tokens\n', '      // @param target address is frozen\n', '      // @param freezes or does not freeze\n', '    function freezeAccount(address target, bool freeze) onlyOwner public returns (bool) {\n', '        data.setFrozenAccount(target, freeze);\n', '        return true;\n', '\n', '    }\n', '\n', '    // Notice of purchase of tokens by sending ether\n', '    function buy(address _contract, address sender, uint256 value) payable public {\n', '        require(false);\n', '        uint amount = value / data.buyPrice();        // Calculate the purchase amount\n', '        _transfer(_contract, sender, amount);              // makes the transfers\n', '    }\n', '    // @notice to sell the amount token\n', '    // @param amount\n', '    function sell(address _contract, address sender, uint256 amount) public {\n', '        require(false);\n', '        require(address(_contract).balance >= amount * data.sellPrice());      // Check if there is enough ether in the contract\n', '        _transfer(sender, _contract, amount);              // makes the transfers\n', '        sender.transfer(amount * data.sellPrice());          // Shipping ether to the seller.This is important to avoid recursive attacks\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract BitSTDView {\n', '\n', '\tBitSTDLogic private logic;\n', '\taddress public owner;\n', '\n', '    // This creates a public event on the blockchain that notifies the customer\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // This tells the customer how much money is being burned\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '\t//start Query data interface\n', '    function balanceOf(address add)constant  public returns (uint256) {\n', '\t    return logic.balanceOf(add);\n', '\t}\n', '\n', '\tfunction name() constant  public returns (string) {\n', '\t    return logic.name();\n', '\t}\n', '\n', '\tfunction symbol() constant  public returns (string) {\n', '\t    return logic.symbol();\n', '\t}\n', '\n', '\tfunction decimals() constant  public returns (uint8) {\n', '\t    return logic.decimals();\n', '\t}\n', '\n', '\tfunction totalSupply() constant  public returns (uint256) {\n', '\t    return logic.totalSupply();\n', '\t}\n', '\n', '\tfunction allowance(address authorizer, address sender) constant  public returns (uint256) {\n', '\t    return logic.allowance(authorizer, sender);\n', '\t}\n', '\n', '\tfunction sellPrice() constant  public returns (uint256) {\n', '\t    return logic.sellPrice();\n', '\t}\n', '\n', '\tfunction buyPrice() constant  public returns (uint256) {\n', '\t    return logic.buyPrice();\n', '\t}\n', '\n', '\tfunction frozenAccount(address addr) constant  public returns (bool) {\n', '\t    return logic.frozenAccount(addr);\n', '\t}\n', '\n', '\t//End Query data interface\n', '\n', '\t//initialize\n', '    constructor(address logicAddressr) public {\n', '        logic=BitSTDLogic(logicAddressr);\n', '        owner=msg.sender;\n', '    }\n', '\n', '    //start Authority and control\n', '    modifier onlyOwner(){\n', '\t\trequire(msg.sender == owner);\n', '        _;\n', '\t}\n', '\n', '\t//Update the address of the data and logic layer\n', '    function setBitSTD(address dataAddress,address logicAddressr) onlyOwner public{\n', '        logic=BitSTDLogic(logicAddressr);\n', '        logic.setData(dataAddress);\n', '    }\n', '\n', '    //Hand over the logical layer authority\n', '    function transferLogicAuthority(address newOwner) onlyOwner public{\n', '        logic.transferAuthority(newOwner);\n', '    }\n', '\n', '    //Hand over the data layer authority\n', '    function transferDataAuthority(address newOwner) onlyOwner public{\n', '        logic.transferDataAuthority(newOwner);\n', '    }\n', '\n', '    //Hand over the view layer authority\n', '    function transferAuthority(address newOwner) onlyOwner public{\n', '        owner=newOwner;\n', '    }\n', '    //End Authority and control\n', '\n', '    //data migration\n', '    function migration(address addr) public {\n', '        if (logic.migration(msg.sender, addr) == true) {\n', '            emit Transfer(msg.sender, addr,logic.getOldBalanceOf(addr));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '\tfunction transfer(address _to, uint256 _value) public {\n', '\t    if (logic.transfer(msg.sender, _to, _value) == true) {\n', '\t        emit Transfer(msg.sender, _to, _value);\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t    if (logic.transferFrom(_from, msg.sender, _to, _value) == true) {\n', '\t        emit Transfer(_from, _to, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t    return logic.approve( _spender, msg.sender,  _value);\n', '\t}\n', '\n', '\t/**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '\t    return logic.approveAndCall(_spender, msg.sender, this, _value, _extraData);\n', '\t}\n', '\n', '\t/**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t    if (logic.burn(msg.sender, _value) == true) {\n', '\t        emit Burn(msg.sender, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t    if (logic.burnFrom( _from, msg.sender, _value) == true) {\n', '\t        emit Burn(_from, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '\t    logic.mintToken(target, this,  mintedAmount);\n', '\t    emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner public {\n', '\t    if (logic.freezeAccount(target,  freeze) == true) {\n', '\t        emit FrozenFunds(target, freeze);\n', '\t    }\n', '\t}\n', '\n', '\t//The next two are buying and selling tokens\n', '\tfunction buy() payable public {\n', '\t    logic.buy(this, msg.sender, msg.value);\n', '\t}\n', '\n', '\tfunction sell(uint256 amount) public {\n', '\t    logic.sell(this,msg.sender, amount);\n', '\t}\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract owned {\n', '    address public owner;\n', '}\n', '\n', 'contract TokenERC20 {\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '}\n', '\n', 'contract BitSTDShares is owned, TokenERC20 {\n', '\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '}\n', '\n', 'contract BitSTDData {\n', '    // Used to control data migration\n', '    bool public data_migration_control = true;\n', '    address public owner;\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    // An array of all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    // The allowed address zhi value wei value is true\n', '    mapping (address => bool) public owners;\n', '    // Freeze address\n', '    mapping (address => bool) public frozenAccount;\n', '    BitSTDShares private bit;\n', '\n', '    constructor(address contractAddress) public {\n', '        bit = BitSTDShares(contractAddress);\n', '        owner = msg.sender;\n', '        name = bit.name();\n', '        symbol = bit.symbol();\n', '        decimals = bit.decimals();\n', '        sellPrice = bit.sellPrice();\n', '        buyPrice = bit.buyPrice();\n', '        totalSupply = bit.totalSupply();\n', '        balanceOf[msg.sender] = totalSupply;\n', '    }\n', '\n', '    modifier qualification {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Move the super administrator\n', '    function transferAuthority(address newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setBalanceOfAddr(address addr, uint256 value) qualification public {\n', '        balanceOf[addr] = value;\n', '    }\n', '\n', '    function setAllowance(address authorizer, address sender, uint256 value) qualification public {\n', '        allowance[authorizer][sender] = value;\n', '    }\n', '\n', '\n', '    function setFrozenAccount(address addr, bool value) qualification public {\n', '        frozenAccount[addr] = value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 value) qualification public {\n', '        totalSupply = value;\n', '    }\n', '\n', '    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n', '        require(msg.sender == owner);\n', '        sellPrice = newSellPrice;\n', '        buyPrice = newBuyPrice;\n', '    }\n', '\n', '    // Old contract data\n', '    function getOldBalanceOf(address addr) constant  public returns(uint256) {\n', '       return bit.balanceOf(addr);\n', '    }\n', '   \n', '    \n', '    function getOldAllowance(address authorizer, address sender) constant  public returns(uint256) {\n', '        return bit.allowance(authorizer, sender);\n', '    }\n', '\n', '    function getOldFrozenAccount(address addr) constant public returns(bool) {\n', '        return bit.frozenAccount(addr);\n', '    }\n', '   \n', '}\n', '\n', '\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract BitSTDLogic {\n', '    address public owner;\n', '    // data layer\n', '\tBitSTDData private data;\n', '\n', '    constructor(address dataAddress) {\n', '        data = BitSTDData(dataAddress);\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    // Transfer logical layer authority\n', '    function transferAuthority(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '\tmodifier onlyOwner(){\n', '\t\trequire(msg.sender == owner);\n', '        _;\n', '\t}\n', '\t\n', '\t// Transfer data layer authority\n', '    function transferDataAuthority(address newOwner) onlyOwner public {\n', '        data.transferAuthority(newOwner);\n', '    }\n', '    function setData(address dataAddress)onlyOwner public {\n', '        data = BitSTDData(dataAddress);\n', '    }\n', '\n', '    // Old contract data\n', '    function getOldBalanceOf(address addr) constant public returns (uint256) {\n', '        return data.getOldBalanceOf(addr);\n', '    }\n', '\n', '\t/**\n', '\t * Internal transfers can only be invoked through this contract\n', '\t*/\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        uint256 f_value = balanceOf(_from);\n', '        uint256 t_value = balanceOf(_to);\n', '        // Prevents transmission to 0x0 address.Call to Burn ()\n', '        require(_to != 0x0);\n', '        // Check that the sender is adequate\n', '        require(f_value >= _value);\n', '        // Check the overflow\n', '        require(t_value + _value > t_value);\n', '        // Save it as a future assertion\n', '        uint previousBalances = f_value + t_value;\n', '        // Minus from the sender\n', '        setBalanceOf(_from, f_value - _value);\n', '        // Add to receiver\n', '        setBalanceOf(_to, t_value + _value);\n', '\n', '        // Assertions are used to use static analysis to detect errors in code.They should not fail\n', '        assert(balanceOf(_from) + balanceOf(_to) == previousBalances);\n', '\n', '    }\n', '    // data migration\n', '    function migration(address sender, address receiver) onlyOwner public returns (bool) {\n', '        require(sender != receiver);\n', '        bool result= false;\n', '        // Start data migration\n', '        // uint256 t_value = balanceOf(receiver);\n', '        uint256 _value = data.getOldBalanceOf(receiver);\n', '        //Transfer balance\n', '        if (data.balanceOf(receiver) == 0) {\n', '            if (_value > 0) {\n', '                _transfer(sender, receiver, _value);\n', '                result = true;\n', '            }\n', '        }\n', '        //Frozen account migration\n', '        if (data.getOldFrozenAccount(receiver)== true) {\n', '            if (data.frozenAccount(receiver)!= true) {\n', '                data.setFrozenAccount(receiver, true);\n', '            }\n', '        }\n', '        //End data migration\n', '        return result;\n', '    }\n', '\n', '    // Check the contract token\n', '    function balanceOf(address addr) constant public returns (uint256) {\n', '        return data.balanceOf(addr);\n', '    }\n', '\n', '    function name() constant public returns (string) {\n', '  \t   return data.name();\n', '  \t}\n', '\n', '  \tfunction symbol() constant public returns(string) {\n', '  \t   return data.symbol();\n', '  \t}\n', '\n', '  \tfunction decimals() constant public returns(uint8) {\n', '  \t   return data.decimals();\n', '  \t}\n', '\n', '  \tfunction totalSupply() constant public returns(uint256) {\n', '  \t   return data.totalSupply();\n', '  \t}\n', '\n', '  \tfunction allowance(address authorizer, address sender) constant public returns(uint256) {\n', '  \t   return data.allowance(authorizer, sender);\n', '  \t}\n', '\n', '  \tfunction sellPrice() constant public returns (uint256) {\n', '  \t   return data.sellPrice();\n', '  \t}\n', '\n', '  \tfunction buyPrice() constant public returns (uint256) {\n', '  \t   return data.buyPrice();\n', '  \t}\n', '\n', '  \tfunction frozenAccount(address addr) constant public returns(bool) {\n', '  \t   return data.frozenAccount(addr);\n', '  \t}\n', '\n', '    //Modify the contract\n', '    function setBalanceOf(address addr, uint256 value) onlyOwner public {\n', '        data.setBalanceOfAddr(addr, value);\n', '    }\n', '\n', '    /**\n', '     * Pass the token\n', '     * send a value token to your account\n', '    */\n', '    function transfer(address sender, address _to, uint256 _value) onlyOwner public returns (bool) {\n', '        _transfer(sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *Passing tokens from other addresses\n', '      *\n', '      * sends the value token to "to", representing "from"\n', '      *\n', "      * @param _from sender's address\n", "      * @param _to recipient's address\n", '      * @param _value number sent\n', '     */\n', '    function transferFrom(address _from, address sender, address _to, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 a_value = data.allowance(_from, sender);\n', '        require(_value <=_value ); // Check allowance\n', '        data.setAllowance(_from, sender, a_value - _value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '     /**\n', '* set allowances for other addresses\n', '*\n', '* allow the "spender" to spend only the "value" card in your name\n', '*\n', '* @param _spender authorized address\n', '* @param _value they can spend the most money\n', '     */\n', '    function approve(address _spender, address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        data.setAllowance(sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Grant and notify other addresses\n', '       *\n', '       * allow "spender" to only mark "value" in your name and then write the contract on it.\n', '       *\n', '       * @param _spender authorized address\n', '       * @param _value they can spend the most money\n', '       * @param _extraData sends some additional information to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, address sender, address _contract, uint256 _value, bytes _extraData) onlyOwner public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, sender, _value)) {\n', '            spender.receiveApproval(sender, _value, _contract, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '     /**\n', '     * Destroy the tokens,\n', '       *\n', '       * delete "value" tokens from the system\n', '       *\n', '       * param _value the amount of money to burn\n', '     */\n', '    function burn(address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 f_value = balanceOf(sender);\n', '        require(f_value >= _value);                 // Check that the sender is adequate\n', '        setBalanceOf(sender, f_value - _value);    // Minus from the sender\n', '        data.addTotalSupply(totalSupply() - _value);                      // Renewal aggregate supply\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other accounts\n', '       *\n', '       * delete "value" tokens from "from" in the system.\n', '       *\n', '       * @param _from the address of the sender\n', '       * param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, address sender, uint256 _value) onlyOwner public returns (bool success) {\n', '        uint256 f_value = balanceOf(sender);\n', '        uint256 a_value = data.allowance(_from, sender);\n', '        require(f_value >= _value);                             // Check that the target balance is adequate\n', '        require(_value <= a_value);                             // Check the allowance\n', '        setBalanceOf(_from, f_value - _value);                // Subtract from the goal balance\n', "        data.setAllowance(_from, sender, f_value - _value);  // Minus the sender's allowance\n", '        data.addTotalSupply(totalSupply() - _value);         // update totalSupply\n', '\n', '        return true;\n', '    }\n', '\n', '    //@ notifies you to create the mintedAmount token and send it to the target\n', '      // @param target address receiving token\n', '      // @param mintedAmount will receive the number of tokens\n', '    function mintToken(address target, address _contract, uint256 mintedAmount) onlyOwner public {\n', '        uint256 f_value = balanceOf(target);\n', '        setBalanceOf(target, f_value + mintedAmount);\n', '        data.addTotalSupply(totalSupply() + mintedAmount);\n', '\n', '    }\n', '\n', '    //Notice freezes the account to prevent "target" from sending and receiving tokens\n', '      // @param target address is frozen\n', '      // @param freezes or does not freeze\n', '    function freezeAccount(address target, bool freeze) onlyOwner public returns (bool) {\n', '        data.setFrozenAccount(target, freeze);\n', '        return true;\n', '\n', '    }\n', '\n', '    // Notice of purchase of tokens by sending ether\n', '    function buy(address _contract, address sender, uint256 value) payable public {\n', '        require(false);\n', '        uint amount = value / data.buyPrice();        // Calculate the purchase amount\n', '        _transfer(_contract, sender, amount);              // makes the transfers\n', '    }\n', '    // @notice to sell the amount token\n', '    // @param amount\n', '    function sell(address _contract, address sender, uint256 amount) public {\n', '        require(false);\n', '        require(address(_contract).balance >= amount * data.sellPrice());      // Check if there is enough ether in the contract\n', '        _transfer(sender, _contract, amount);              // makes the transfers\n', '        sender.transfer(amount * data.sellPrice());          // Shipping ether to the seller.This is important to avoid recursive attacks\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract BitSTDView {\n', '\n', '\tBitSTDLogic private logic;\n', '\taddress public owner;\n', '\n', '    // This creates a public event on the blockchain that notifies the customer\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // This tells the customer how much money is being burned\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '\t//start Query data interface\n', '    function balanceOf(address add)constant  public returns (uint256) {\n', '\t    return logic.balanceOf(add);\n', '\t}\n', '\n', '\tfunction name() constant  public returns (string) {\n', '\t    return logic.name();\n', '\t}\n', '\n', '\tfunction symbol() constant  public returns (string) {\n', '\t    return logic.symbol();\n', '\t}\n', '\n', '\tfunction decimals() constant  public returns (uint8) {\n', '\t    return logic.decimals();\n', '\t}\n', '\n', '\tfunction totalSupply() constant  public returns (uint256) {\n', '\t    return logic.totalSupply();\n', '\t}\n', '\n', '\tfunction allowance(address authorizer, address sender) constant  public returns (uint256) {\n', '\t    return logic.allowance(authorizer, sender);\n', '\t}\n', '\n', '\tfunction sellPrice() constant  public returns (uint256) {\n', '\t    return logic.sellPrice();\n', '\t}\n', '\n', '\tfunction buyPrice() constant  public returns (uint256) {\n', '\t    return logic.buyPrice();\n', '\t}\n', '\n', '\tfunction frozenAccount(address addr) constant  public returns (bool) {\n', '\t    return logic.frozenAccount(addr);\n', '\t}\n', '\n', '\t//End Query data interface\n', '\n', '\t//initialize\n', '    constructor(address logicAddressr) public {\n', '        logic=BitSTDLogic(logicAddressr);\n', '        owner=msg.sender;\n', '    }\n', '\n', '    //start Authority and control\n', '    modifier onlyOwner(){\n', '\t\trequire(msg.sender == owner);\n', '        _;\n', '\t}\n', '\n', '\t//Update the address of the data and logic layer\n', '    function setBitSTD(address dataAddress,address logicAddressr) onlyOwner public{\n', '        logic=BitSTDLogic(logicAddressr);\n', '        logic.setData(dataAddress);\n', '    }\n', '\n', '    //Hand over the logical layer authority\n', '    function transferLogicAuthority(address newOwner) onlyOwner public{\n', '        logic.transferAuthority(newOwner);\n', '    }\n', '\n', '    //Hand over the data layer authority\n', '    function transferDataAuthority(address newOwner) onlyOwner public{\n', '        logic.transferDataAuthority(newOwner);\n', '    }\n', '\n', '    //Hand over the view layer authority\n', '    function transferAuthority(address newOwner) onlyOwner public{\n', '        owner=newOwner;\n', '    }\n', '    //End Authority and control\n', '\n', '    //data migration\n', '    function migration(address addr) public {\n', '        if (logic.migration(msg.sender, addr) == true) {\n', '            emit Transfer(msg.sender, addr,logic.getOldBalanceOf(addr));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '\tfunction transfer(address _to, uint256 _value) public {\n', '\t    if (logic.transfer(msg.sender, _to, _value) == true) {\n', '\t        emit Transfer(msg.sender, _to, _value);\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '\t    if (logic.transferFrom(_from, msg.sender, _to, _value) == true) {\n', '\t        emit Transfer(_from, _to, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\n', '\t    return logic.approve( _spender, msg.sender,  _value);\n', '\t}\n', '\n', '\t/**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '\t    return logic.approveAndCall(_spender, msg.sender, this, _value, _extraData);\n', '\t}\n', '\n', '\t/**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '\tfunction burn(uint256 _value) public returns (bool success) {\n', '\t    if (logic.burn(msg.sender, _value) == true) {\n', '\t        emit Burn(msg.sender, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '\tfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '\t    if (logic.burnFrom( _from, msg.sender, _value) == true) {\n', '\t        emit Burn(_from, _value);\n', '\t        return true;\n', '\t    }\n', '\t}\n', '\n', '\t/// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '\tfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\n', '\t    logic.mintToken(target, this,  mintedAmount);\n', '\t    emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '\t}\n', '\n', '\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '\tfunction freezeAccount(address target, bool freeze) onlyOwner public {\n', '\t    if (logic.freezeAccount(target,  freeze) == true) {\n', '\t        emit FrozenFunds(target, freeze);\n', '\t    }\n', '\t}\n', '\n', '\t//The next two are buying and selling tokens\n', '\tfunction buy() payable public {\n', '\t    logic.buy(this, msg.sender, msg.value);\n', '\t}\n', '\n', '\tfunction sell(uint256 amount) public {\n', '\t    logic.sell(this,msg.sender, amount);\n', '\t}\n', '}']
