['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface with DNN features.\n', '/// @author Dondrey Taylor - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d4b0bbbab0a6b1ad94b0babafab9b1b0bdb5">[email&#160;protected]</a>>\n', 'contract DNNToken is StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Used to indicate which allocation we issue tokens from //\n', '    ////////////////////////////////////////////////////////////\n', '    enum DNNSupplyAllocations {\n', '        EarlyBackerSupplyAllocation,\n', '        PRETDESupplyAllocation,\n', '        TDESupplyAllocation,\n', '        BountySupplyAllocation,\n', '        WriterAccountSupplyAllocation,\n', '        AdvisorySupplyAllocation,\n', '        PlatformSupplyAllocation\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////\n', '    // Smart-Contract with permission to allocate tokens from supplies //\n', '    /////////////////////////////////////////////////////////////////////\n', '    address public allocatorAddress;\n', '    address public crowdfundContract;\n', '\n', '    /////////////////////\n', '    // Token Meta Data //\n', '    /////////////////////\n', '    string constant public name = "DNN";\n', '    string constant public symbol = "DNN";\n', '    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\n', '\n', '    /////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN //\n', '    /////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    /////////////////////////\n', '    // Address of Platform //\n', '    /////////////////////////\n', '    address public platform;\n', '\n', '    /////////////////////////////////////////////\n', '    // Token Distributions (% of total supply) //\n', '    /////////////////////////////////////////////\n', '    uint256 public earlyBackerSupply; // 10%\n', '    uint256 public PRETDESupply; // 10%\n', '    uint256 public TDESupply; // 40%\n', '    uint256 public bountySupply; // 1%\n', '    uint256 public writerAccountSupply; // 4%\n', '    uint256 public advisorySupply; // 14%\n', '    uint256 public cofoundersSupply; // 10%\n', '    uint256 public platformSupply; // 11%\n', '\n', '    uint256 public earlyBackerSupplyRemaining; // 10%\n', '    uint256 public PRETDESupplyRemaining; // 10%\n', '    uint256 public TDESupplyRemaining; // 40%\n', '    uint256 public bountySupplyRemaining; // 1%\n', '    uint256 public writerAccountSupplyRemaining; // 4%\n', '    uint256 public advisorySupplyRemaining; // 14%\n', '    uint256 public cofoundersSupplyRemaining; // 10%\n', '    uint256 public platformSupplyRemaining; // 11%\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    uint256 public cofoundersSupplyVestingTranches = 10;\n', '    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\n', '    uint256 public cofoundersSupplyVestingStartDate; // Epoch\n', '    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\n', '\n', '    //////////////////////////////////////////////\n', '    // Prevents tokens from being transferrable //\n', '    //////////////////////////////////////////////\n', '    bool public tokensLocked = true;\n', '\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    // Event triggered when tokens are transferred from one address to another //\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Checks if tokens can be issued to founder at this time //\n', '    ////////////////////////////////////////////////////////////\n', '    modifier CofoundersTokensVested()\n', '    {\n', '        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\n', '        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\n', '\n', '        // Get current tranche based on the amount of time that has passed since vesting start date\n', '        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\n', '\n', '        // Amount of tranches that have been issued so far\n', '        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\n', '\n', '        // Amount of tranches that cofounders are entitled to\n', '        uint256 maxTranches = cofoundersSupplyVestingTranches;\n', '\n', '        // Make sure that we still have unvested tokens and that\n', '        // the tokens for the current tranche have not been issued.\n', '        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\n', '\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////\n', '    // Checks if tokens are unlocked //\n', '    ///////////////////////////////////\n', '    modifier TokensUnlocked()\n', '    {\n', '        require (tokensLocked == false);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // Checks if tokens are locked //\n', '    /////////////////////////////////\n', '    modifier TokensLocked()\n', '    {\n', '       require (tokensLocked == true);\n', '       _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders()\n', '    {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA()\n', '    {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB()\n', '    {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////\n', '    // Checks if Allocator is performing the action //\n', '    //////////////////////////////////////////////////\n', '    modifier onlyAllocator()\n', '    {\n', '        require (msg.sender == allocatorAddress);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract is performing the action //\n', '    ///////////////////////////////////////////////////////////\n', '    modifier onlyCrowdfundContract()\n', '    {\n', '        require (msg.sender == crowdfundContract);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\n', '    {\n', '        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is manage platform holding  //\n', '    //  @param newAddress Address of new issuance contract.              //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function changePlatform(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        platform = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\n', '    //  @param newAddress Address of new issuance contract.                                                              //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeCrowdfundContract(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        crowdfundContract = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\n', '    //  @param newAddress Address of new issuance contract.                                                    //\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeAllocator(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        allocatorAddress = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // Transfers tokens from senders address to another address //\n', '    //////////////////////////////////////////////////////////////\n', '    function transfer(address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(msg.sender, _to, _value);\n', '          return BasicToken.transfer(_to, _value);\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////\n', '    // Transfers tokens from one address to another address //\n', '    //////////////////////////////////////////////////////////\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(_from, _to, _value);\n', '          return StandardToken.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\n', '    //  @param beneficiary Address of receiver.                                                  //\n', '    //  @param tokenCount Number of tokens to issue.                                             //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    function issueCofoundersTokensIfPossible()\n', '        onlyCofounders\n', '        CofoundersTokensVested\n', '        returns (bool)\n', '    {\n', '        // Compute total amount of vested tokens to issue\n', '        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\n', '\n', '        // Make sure that there are cofounder tokens left\n', '        if (tokenCount > cofoundersSupplyRemaining) {\n', '           return false;\n', '        }\n', '\n', '        // Decrease cofounders supply\n', '        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\n', '\n', '        // Update how many tokens have been distributed to cofounders\n', '        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\n', '\n', '        // Split tokens between both founders\n', '        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\n', '        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\n', '\n', '        // Update that a tranche has been issued\n', '        cofoundersSupplyVestingTranchesIssued += 1;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    //////////////////\n', '    // Issue tokens //\n', '    //////////////////\n', '    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\n', '      onlyAllocatorOrCrowdfundContractOrPlatform\n', '      returns (bool)\n', '    {\n', '        // We&#39;ll use the following to determine whether the allocator, platform,\n', '        // or the crowdfunding contract can allocate specified supply\n', '        bool canAllocatorPerform = msg.sender == allocatorAddress;\n', '        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\n', '        bool canPlatformPerform = msg.sender == platform;\n', '\n', '        // Early Backers\n', '        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\n', '            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // PRE-TDE\n', '        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\n', '\n', '              // Check to see if we have enough tokens to satisfy this purchase\n', '              // using just the pre-tde.\n', '              if (PRETDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease pre-tde supply\n', '                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\n', '              }\n', '\n', '              // Check to see if we can satisfy this using pre-tde and tde supply combined\n', '              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease tde supply\n', '                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\n', '\n', '                    // Decrease pre-tde supply by its&#39; remaining tokens\n', '                    PRETDESupplyRemaining = 0;\n', '              }\n', '\n', '              // Otherwise, we can&#39;t satisfy this sale because we don&#39;t have enough tokens.\n', '              else {\n', '                  return false;\n', '              }\n', '        }\n', '\n', '        // TDE\n', '        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\n', '            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Bounty\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\n', '            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Writer Accounts\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\n', '            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Advisory\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\n', '            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\n', '        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\n', '            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        else {\n', '            return false;\n', '        }\n', '\n', '        // Transfer tokens\n', '        Transfer(address(this), beneficiary, tokenCount);\n', '\n', '        // Credit tokens to the address specified\n', '        balances[beneficiary] = balances[beneficiary].add(tokenCount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from TDE to Platform //\n', '    /////////////////////////////////////////////////\n', '    function sendUnsoldTDETokensToPlatform()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '        // Make sure we have tokens to send from TDE\n', '        if (TDESupplyRemaining > 0) {\n', '\n', '            // Add remaining tde tokens to platform remaining tokens\n', '            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\n', '\n', '            // Clear remaining tde token count\n', '            TDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from pre-TDE to Platform //\n', '    /////////////////////////////////////////////////////\n', '    function sendUnsoldPRETDETokensToTDE()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '          // Make sure we have tokens to send from pre-TDE\n', '          if (PRETDESupplyRemaining > 0) {\n', '\n', '              // Add remaining pre-tde tokens to tde remaining tokens\n', '              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\n', '\n', '              // Clear remaining pre-tde token count\n', '              PRETDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////\n', '    // @des Allows tokens to be transferrable. Returns lock state //\n', '    ////////////////////////////////////////////////////////////////\n', '    function unlockTokens()\n', '        external\n', '        onlyCrowdfundContract\n', '    {\n', '        // Make sure tokens are currently locked before proceeding to unlock them\n', '        require(tokensLocked == true);\n', '\n', '        tokensLocked = false;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Contract constructor function sets initial token balances.  //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function DNNToken()\n', '    {\n', '          // Start date\n', '          uint256 vestingStartDate = 1526072145;\n', '\n', '          // Set cofounder addresses\n', '          cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '          cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '          // Sets platform address\n', '          platform = address(this);\n', '\n', '          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\n', '          // 1 DNN = 10^18 atto-DNN\n', '          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\n', '\n', '          // Set Token Distributions (% of total supply)\n', '          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\n', '          PRETDESupply = totalSupply.mul(10).div(100); // 10%\n', '          TDESupply = totalSupply.mul(40).div(100); // 40%\n', '          bountySupply = totalSupply.mul(1).div(100); // 1%\n', '          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\n', '          advisorySupply = totalSupply.mul(14).div(100); // 14%\n', '          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\n', '          platformSupply = totalSupply.mul(11).div(100); // 11%\n', '\n', '          // Set each remaining token count equal to its&#39; respective supply\n', '          earlyBackerSupplyRemaining = earlyBackerSupply;\n', '          PRETDESupplyRemaining = PRETDESupply;\n', '          TDESupplyRemaining = TDESupply;\n', '          bountySupplyRemaining = bountySupply;\n', '          writerAccountSupplyRemaining = writerAccountSupply;\n', '          advisorySupplyRemaining = advisorySupply;\n', '          cofoundersSupplyRemaining = cofoundersSupply;\n', '          platformSupplyRemaining = platformSupply;\n', '\n', '          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\n', '          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface with DNN features.\n', '/// @author Dondrey Taylor - <dondrey@dnn.media>\n', 'contract DNNToken is StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Used to indicate which allocation we issue tokens from //\n', '    ////////////////////////////////////////////////////////////\n', '    enum DNNSupplyAllocations {\n', '        EarlyBackerSupplyAllocation,\n', '        PRETDESupplyAllocation,\n', '        TDESupplyAllocation,\n', '        BountySupplyAllocation,\n', '        WriterAccountSupplyAllocation,\n', '        AdvisorySupplyAllocation,\n', '        PlatformSupplyAllocation\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////\n', '    // Smart-Contract with permission to allocate tokens from supplies //\n', '    /////////////////////////////////////////////////////////////////////\n', '    address public allocatorAddress;\n', '    address public crowdfundContract;\n', '\n', '    /////////////////////\n', '    // Token Meta Data //\n', '    /////////////////////\n', '    string constant public name = "DNN";\n', '    string constant public symbol = "DNN";\n', '    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\n', '\n', '    /////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN //\n', '    /////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    /////////////////////////\n', '    // Address of Platform //\n', '    /////////////////////////\n', '    address public platform;\n', '\n', '    /////////////////////////////////////////////\n', '    // Token Distributions (% of total supply) //\n', '    /////////////////////////////////////////////\n', '    uint256 public earlyBackerSupply; // 10%\n', '    uint256 public PRETDESupply; // 10%\n', '    uint256 public TDESupply; // 40%\n', '    uint256 public bountySupply; // 1%\n', '    uint256 public writerAccountSupply; // 4%\n', '    uint256 public advisorySupply; // 14%\n', '    uint256 public cofoundersSupply; // 10%\n', '    uint256 public platformSupply; // 11%\n', '\n', '    uint256 public earlyBackerSupplyRemaining; // 10%\n', '    uint256 public PRETDESupplyRemaining; // 10%\n', '    uint256 public TDESupplyRemaining; // 40%\n', '    uint256 public bountySupplyRemaining; // 1%\n', '    uint256 public writerAccountSupplyRemaining; // 4%\n', '    uint256 public advisorySupplyRemaining; // 14%\n', '    uint256 public cofoundersSupplyRemaining; // 10%\n', '    uint256 public platformSupplyRemaining; // 11%\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    uint256 public cofoundersSupplyVestingTranches = 10;\n', '    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\n', '    uint256 public cofoundersSupplyVestingStartDate; // Epoch\n', '    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\n', '\n', '    //////////////////////////////////////////////\n', '    // Prevents tokens from being transferrable //\n', '    //////////////////////////////////////////////\n', '    bool public tokensLocked = true;\n', '\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    // Event triggered when tokens are transferred from one address to another //\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Checks if tokens can be issued to founder at this time //\n', '    ////////////////////////////////////////////////////////////\n', '    modifier CofoundersTokensVested()\n', '    {\n', '        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\n', '        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\n', '\n', '        // Get current tranche based on the amount of time that has passed since vesting start date\n', '        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\n', '\n', '        // Amount of tranches that have been issued so far\n', '        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\n', '\n', '        // Amount of tranches that cofounders are entitled to\n', '        uint256 maxTranches = cofoundersSupplyVestingTranches;\n', '\n', '        // Make sure that we still have unvested tokens and that\n', '        // the tokens for the current tranche have not been issued.\n', '        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\n', '\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////\n', '    // Checks if tokens are unlocked //\n', '    ///////////////////////////////////\n', '    modifier TokensUnlocked()\n', '    {\n', '        require (tokensLocked == false);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // Checks if tokens are locked //\n', '    /////////////////////////////////\n', '    modifier TokensLocked()\n', '    {\n', '       require (tokensLocked == true);\n', '       _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders()\n', '    {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA()\n', '    {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB()\n', '    {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////\n', '    // Checks if Allocator is performing the action //\n', '    //////////////////////////////////////////////////\n', '    modifier onlyAllocator()\n', '    {\n', '        require (msg.sender == allocatorAddress);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract is performing the action //\n', '    ///////////////////////////////////////////////////////////\n', '    modifier onlyCrowdfundContract()\n', '    {\n', '        require (msg.sender == crowdfundContract);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\n', '    {\n', '        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is manage platform holding  //\n', '    //  @param newAddress Address of new issuance contract.              //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function changePlatform(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        platform = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\n', '    //  @param newAddress Address of new issuance contract.                                                              //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeCrowdfundContract(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        crowdfundContract = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\n', '    //  @param newAddress Address of new issuance contract.                                                    //\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeAllocator(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        allocatorAddress = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // Transfers tokens from senders address to another address //\n', '    //////////////////////////////////////////////////////////////\n', '    function transfer(address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(msg.sender, _to, _value);\n', '          return BasicToken.transfer(_to, _value);\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////\n', '    // Transfers tokens from one address to another address //\n', '    //////////////////////////////////////////////////////////\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(_from, _to, _value);\n', '          return StandardToken.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\n', '    //  @param beneficiary Address of receiver.                                                  //\n', '    //  @param tokenCount Number of tokens to issue.                                             //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    function issueCofoundersTokensIfPossible()\n', '        onlyCofounders\n', '        CofoundersTokensVested\n', '        returns (bool)\n', '    {\n', '        // Compute total amount of vested tokens to issue\n', '        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\n', '\n', '        // Make sure that there are cofounder tokens left\n', '        if (tokenCount > cofoundersSupplyRemaining) {\n', '           return false;\n', '        }\n', '\n', '        // Decrease cofounders supply\n', '        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\n', '\n', '        // Update how many tokens have been distributed to cofounders\n', '        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\n', '\n', '        // Split tokens between both founders\n', '        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\n', '        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\n', '\n', '        // Update that a tranche has been issued\n', '        cofoundersSupplyVestingTranchesIssued += 1;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    //////////////////\n', '    // Issue tokens //\n', '    //////////////////\n', '    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\n', '      onlyAllocatorOrCrowdfundContractOrPlatform\n', '      returns (bool)\n', '    {\n', "        // We'll use the following to determine whether the allocator, platform,\n", '        // or the crowdfunding contract can allocate specified supply\n', '        bool canAllocatorPerform = msg.sender == allocatorAddress;\n', '        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\n', '        bool canPlatformPerform = msg.sender == platform;\n', '\n', '        // Early Backers\n', '        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\n', '            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // PRE-TDE\n', '        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\n', '\n', '              // Check to see if we have enough tokens to satisfy this purchase\n', '              // using just the pre-tde.\n', '              if (PRETDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease pre-tde supply\n', '                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\n', '              }\n', '\n', '              // Check to see if we can satisfy this using pre-tde and tde supply combined\n', '              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease tde supply\n', '                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\n', '\n', "                    // Decrease pre-tde supply by its' remaining tokens\n", '                    PRETDESupplyRemaining = 0;\n', '              }\n', '\n', "              // Otherwise, we can't satisfy this sale because we don't have enough tokens.\n", '              else {\n', '                  return false;\n', '              }\n', '        }\n', '\n', '        // TDE\n', '        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\n', '            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Bounty\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\n', '            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Writer Accounts\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\n', '            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Advisory\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\n', '            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\n', '        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\n', '            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        else {\n', '            return false;\n', '        }\n', '\n', '        // Transfer tokens\n', '        Transfer(address(this), beneficiary, tokenCount);\n', '\n', '        // Credit tokens to the address specified\n', '        balances[beneficiary] = balances[beneficiary].add(tokenCount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from TDE to Platform //\n', '    /////////////////////////////////////////////////\n', '    function sendUnsoldTDETokensToPlatform()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '        // Make sure we have tokens to send from TDE\n', '        if (TDESupplyRemaining > 0) {\n', '\n', '            // Add remaining tde tokens to platform remaining tokens\n', '            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\n', '\n', '            // Clear remaining tde token count\n', '            TDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from pre-TDE to Platform //\n', '    /////////////////////////////////////////////////////\n', '    function sendUnsoldPRETDETokensToTDE()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '          // Make sure we have tokens to send from pre-TDE\n', '          if (PRETDESupplyRemaining > 0) {\n', '\n', '              // Add remaining pre-tde tokens to tde remaining tokens\n', '              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\n', '\n', '              // Clear remaining pre-tde token count\n', '              PRETDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////\n', '    // @des Allows tokens to be transferrable. Returns lock state //\n', '    ////////////////////////////////////////////////////////////////\n', '    function unlockTokens()\n', '        external\n', '        onlyCrowdfundContract\n', '    {\n', '        // Make sure tokens are currently locked before proceeding to unlock them\n', '        require(tokensLocked == true);\n', '\n', '        tokensLocked = false;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Contract constructor function sets initial token balances.  //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function DNNToken()\n', '    {\n', '          // Start date\n', '          uint256 vestingStartDate = 1526072145;\n', '\n', '          // Set cofounder addresses\n', '          cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '          cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '          // Sets platform address\n', '          platform = address(this);\n', '\n', '          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\n', '          // 1 DNN = 10^18 atto-DNN\n', '          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\n', '\n', '          // Set Token Distributions (% of total supply)\n', '          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\n', '          PRETDESupply = totalSupply.mul(10).div(100); // 10%\n', '          TDESupply = totalSupply.mul(40).div(100); // 40%\n', '          bountySupply = totalSupply.mul(1).div(100); // 1%\n', '          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\n', '          advisorySupply = totalSupply.mul(14).div(100); // 14%\n', '          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\n', '          platformSupply = totalSupply.mul(11).div(100); // 11%\n', '\n', "          // Set each remaining token count equal to its' respective supply\n", '          earlyBackerSupplyRemaining = earlyBackerSupply;\n', '          PRETDESupplyRemaining = PRETDESupply;\n', '          TDESupplyRemaining = TDESupply;\n', '          bountySupplyRemaining = bountySupply;\n', '          writerAccountSupplyRemaining = writerAccountSupply;\n', '          advisorySupplyRemaining = advisorySupply;\n', '          cofoundersSupplyRemaining = cofoundersSupply;\n', '          platformSupplyRemaining = platformSupply;\n', '\n', '          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\n', '          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\n', '    }\n', '}']
