['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', '**/\n', 'library SafeMathLib{\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', '**/\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = 0x4e70812b550687692e18F53445C601458228aFfD;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @dev Contract used to deploy COIN V2 and allow users to swap V1 for V2.\n', '**/\n', 'contract TokenSwap {\n', '    \n', '    // Address of the old Coinvest COIN token.\n', '    address public constant OLD_TOKEN = 0x4306ce4a5d8b21ee158cb8396a4f6866f14d6ac8;\n', '    \n', '    // Address of the new COINVEST COIN V2 token (to be launched on construction).\n', '    CoinvestToken public newToken;\n', '\n', '    constructor() \n', '      public \n', '    {\n', '        newToken = new CoinvestToken();\n', '    }\n', '\n', '    /**\n', '     * @dev Only function. ERC223 transfer from old token to this contract calls this.\n', '     * @param _from The address that has transferred this contract tokens.\n', '     * @param _value The amount of tokens that have been transferred.\n', '     * @param _data The extra data sent with transfer (should be nothing).\n', '    **/\n', '    function tokenFallback(address _from, uint _value, bytes _data) \n', '      external\n', '    {\n', '        require(msg.sender == OLD_TOKEN);          // Ensure caller is old token contract.\n', '        require(newToken.transfer(_from, _value)); // Transfer new tokens to sender.\n', '    }\n', '    \n', '}\n', '    \n', '/**\n', ' * @dev Abstract contract for approveAndCall.\n', '**/\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '/**\n', ' * @title Coinvest COIN Token\n', ' * @dev ERC20 contract utilizing ERC865-ish structure (3esmit&#39;s implementation with alterations).\n', ' * @dev to allow users to pay Ethereum fees in tokens.\n', '**/\n', 'contract CoinvestToken is Ownable {\n', '    using SafeMathLib for uint256;\n', '    \n', '    string public constant symbol = "COIN";\n', '    string public constant name = "Coinvest COIN V2 Token";\n', '    \n', '    uint8 public constant decimals = 18;\n', '    uint256 private _totalSupply = 107142857 * (10 ** 18);\n', '    \n', '    // Function sigs to be used within contract for signature recovery.\n', '    bytes4 internal constant transferSig = 0xa9059cbb;\n', '    bytes4 internal constant approveSig = 0x095ea7b3;\n', '    bytes4 internal constant increaseApprovalSig = 0xd73dd623;\n', '    bytes4 internal constant decreaseApprovalSig = 0x66188463;\n', '    bytes4 internal constant approveAndCallSig = 0xcae9ca51;\n', '    bytes4 internal constant revokeSignatureSig = 0xe40d89e5;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    \n', '    // Keeps track of the last nonce sent from user. Used for delegated functions.\n', '    mapping (address => uint256) nonces;\n', '    \n', '    // Mapping of past used hashes: true if already used.\n', '    mapping (address => mapping (bytes => bool)) invalidSignatures;\n', '\n', '    // Mapping of finalized ERC865 standard sigs => our function sigs for future-proofing\n', '    mapping (bytes4 => bytes4) public standardSigs;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed from, address indexed spender, uint tokens);\n', '    event SignatureRedeemed(bytes _sig, address indexed from);\n', '    \n', '    /**\n', '     * @dev Set owner and beginning balance.\n', '    **/\n', '    constructor()\n', '      public\n', '    {\n', '        balances[msg.sender] = _totalSupply;\n', '    }\n', '    \n', '    /**\n', '     * @dev This code allows us to redirect pre-signed calls with different function selectors to our own.\n', '    **/\n', '    function () \n', '      public\n', '    {\n', '        bytes memory calldata = msg.data;\n', '        bytes4 new_selector = standardSigs[msg.sig];\n', '        require(new_selector != 0);\n', '        \n', '        assembly {\n', '           mstore(add(0x20, calldata), new_selector)\n', '        }\n', '        \n', '        require(address(this).delegatecall(calldata));\n', '        \n', '        assembly {\n', '            if iszero(eq(returndatasize, 0x20)) { revert(0, 0) }\n', '            returndatacopy(0, 0, returndatasize)\n', '            return(0, returndatasize)\n', '        }\n', '    }\n', '\n', '/** ******************************** ERC20 ********************************* **/\n', '\n', '    /**\n', '     * @dev Transfers coins from one address to another.\n', '     * @param _to The recipient of the transfer amount.\n', '     * @param _amount The amount of tokens to transfer.\n', '    **/\n', '    function transfer(address _to, uint256 _amount) \n', '      public\n', '    returns (bool success)\n', '    {\n', '        require(_transfer(msg.sender, _to, _amount));\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev An allowed address can transfer tokens from another&#39;s address.\n', '     * @param _from The owner of the tokens to be transferred.\n', '     * @param _to The address to which the tokens will be transferred.\n', '     * @param _amount The amount of tokens to be transferred.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '      public\n', '    returns (bool success)\n', '    {\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\n', '\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        require(_transfer(_from, _to, _amount));\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Approves a wallet to transfer tokens on one&#39;s behalf.\n', '     * @param _spender The wallet approved to spend tokens.\n', '     * @param _amount The amount of tokens approved to spend.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) \n', '      public\n', '    returns (bool success)\n', '    {\n', '        require(_approve(msg.sender, _spender, _amount));\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Increases the allowed amount for spender from msg.sender.\n', '     * @param _spender The address to increase allowed amount for.\n', '     * @param _amount The amount of tokens to increase allowed amount by.\n', '    **/\n', '    function increaseApproval(address _spender, uint256 _amount) \n', '      public\n', '    returns (bool success)\n', '    {\n', '        require(_increaseApproval(msg.sender, _spender, _amount));\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Decreases the allowed amount for spender from msg.sender.\n', '     * @param _spender The address to decrease allowed amount for.\n', '     * @param _amount The amount of tokens to decrease allowed amount by.\n', '    **/\n', '    function decreaseApproval(address _spender, uint256 _amount) \n', '      public\n', '    returns (bool success)\n', '    {\n', '        require(_decreaseApproval(msg.sender, _spender, _amount));\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Used to approve an address and call a function on it in the same transaction.\n', '     * @dev _spender The address to be approved to spend COIN.\n', '     * @dev _amount The amount of COIN to be approved to spend.\n', '     * @dev _data The data to send to the called contract.\n', '    **/\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _data) \n', '      public\n', '    returns (bool success) \n', '    {\n', '        require(_approve(msg.sender, _spender, _amount));\n', '        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n', '        return true;\n', '    }\n', '\n', '/** ****************************** Internal ******************************** **/\n', '    \n', '    /**\n', '     * @dev Internal transfer for all functions that transfer.\n', '     * @param _from The address that is transferring coins.\n', '     * @param _to The receiving address of the coins.\n', '     * @param _amount The amount of coins being transferred.\n', '    **/\n', '    function _transfer(address _from, address _to, uint256 _amount)\n', '      internal\n', '    returns (bool success)\n', '    {\n', '        require (_to != address(0));\n', '        require(balances[_from] >= _amount);\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        \n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal approve for all functions that require an approve.\n', '     * @param _owner The owner who is allowing spender to use their balance.\n', '     * @param _spender The wallet approved to spend tokens.\n', '     * @param _amount The amount of tokens approved to spend.\n', '    **/\n', '    function _approve(address _owner, address _spender, uint256 _amount) \n', '      internal\n', '    returns (bool success)\n', '    {\n', '        allowed[_owner][_spender] = _amount;\n', '        emit Approval(_owner, _spender, _amount);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Increases the allowed by "_amount" for "_spender" from "owner"\n', '     * @param _owner The address that tokens may be transferred from.\n', '     * @param _spender The address that may transfer these tokens.\n', '     * @param _amount The amount of tokens to transfer.\n', '    **/\n', '    function _increaseApproval(address _owner, address _spender, uint256 _amount)\n', '      internal\n', '    returns (bool success)\n', '    {\n', '        allowed[_owner][_spender] = allowed[_owner][_spender].add(_amount);\n', '        emit Approval(_owner, _spender, allowed[_owner][_spender]);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Decreases the allowed by "_amount" for "_spender" from "_owner"\n', '     * @param _owner The owner of the tokens to decrease allowed for.\n', '     * @param _spender The spender whose allowed will decrease.\n', '     * @param _amount The amount of tokens to decrease allowed by.\n', '    **/\n', '    function _decreaseApproval(address _owner, address _spender, uint256 _amount)\n', '      internal\n', '    returns (bool success)\n', '    {\n', '        if (allowed[_owner][_spender] <= _amount) allowed[_owner][_spender] = 0;\n', '        else allowed[_owner][_spender] = allowed[_owner][_spender].sub(_amount);\n', '        \n', '        emit Approval(_owner, _spender, allowed[_owner][_spender]);\n', '        return true;\n', '    }\n', '    \n', '/** ************************ Delegated Functions *************************** **/\n', '\n', '    /**\n', '     * @dev Called by delegate with a signed hash of the transaction data to allow a user\n', '     * @dev to transfer tokens without paying gas in Ether (they pay in COIN instead).\n', '     * @param _signature Signed hash of data for this transfer.\n', '     * @param _to The address to transfer COIN to.\n', '     * @param _value The amount of COIN to transfer.\n', '     * @param _gasPrice Price (IN COIN) that will be paid per unit of gas by user to "delegate".\n', '     * @param _nonce Nonce of the user&#39;s new transaction.\n', '    **/\n', '    function transferPreSigned(\n', '        bytes _signature,\n', '        address _to, \n', '        uint256 _value, \n', '        uint256 _gasPrice, \n', '        uint256 _nonce) \n', '      public\n', '      validPayload(292)\n', '    returns (bool) \n', '    {\n', '        // Log starting gas left of transaction for later gas price calculations.\n', '        uint256 gas = gasleft();\n', '        \n', '        // Recover signer address from signature; ensure address is valid.\n', '        address from = recoverPreSigned(_signature, transferSig, _to, _value, "", _gasPrice, _nonce);\n', '        require(from != address(0));\n', '        \n', '        // Require the hash has not been used, declare it used, increment nonce.\n', '        require(!invalidSignatures[from][_signature]);\n', '        invalidSignatures[from][_signature] = true;\n', '        nonces[from]++;\n', '        \n', '        // Internal transfer.\n', '        require(_transfer(from, _to, _value));\n', '\n', '        // If the delegate is charging, pay them for gas in COIN.\n', '        if (_gasPrice > 0) {\n', '            \n', '            // 35000 because of base fee of 21000 and ~14000 for the fee transfer.\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Called by a delegate with signed hash to approve a transaction for user.\n', '     * @dev All variables equivalent to transfer except _to:\n', '     * @param _to The address that will be approved to transfer COIN from user&#39;s wallet.\n', '    **/\n', '    function approvePreSigned(\n', '        bytes _signature,\n', '        address _to, \n', '        uint256 _value, \n', '        uint256 _gasPrice, \n', '        uint256 _nonce) \n', '      public\n', '      validPayload(292)\n', '    returns (bool) \n', '    {\n', '        uint256 gas = gasleft();\n', '        address from = recoverPreSigned(_signature, approveSig, _to, _value, "", _gasPrice, _nonce);\n', '        require(from != address(0));\n', '        require(!invalidSignatures[from][_signature]);\n', '        \n', '        invalidSignatures[from][_signature] = true;\n', '        nonces[from]++;\n', '        \n', '        require(_approve(from, _to, _value));\n', '\n', '        if (_gasPrice > 0) {\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Used to increase the amount allowed for "_to" to spend from "from"\n', '     * @dev A bare approve allows potentially nasty race conditions when using a delegate.\n', '    **/\n', '    function increaseApprovalPreSigned(\n', '        bytes _signature,\n', '        address _to, \n', '        uint256 _value, \n', '        uint256 _gasPrice, \n', '        uint256 _nonce)\n', '      public\n', '      validPayload(292)\n', '    returns (bool) \n', '    {\n', '        uint256 gas = gasleft();\n', '        address from = recoverPreSigned(_signature, increaseApprovalSig, _to, _value, "", _gasPrice, _nonce);\n', '        require(from != address(0));\n', '        require(!invalidSignatures[from][_signature]);\n', '        \n', '        invalidSignatures[from][_signature] = true;\n', '        nonces[from]++;\n', '        \n', '        require(_increaseApproval(from, _to, _value));\n', '\n', '        if (_gasPrice > 0) {\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Added for the same reason as increaseApproval. Decreases to 0 if "_value" is greater than allowed.\n', '    **/\n', '    function decreaseApprovalPreSigned(\n', '        bytes _signature,\n', '        address _to, \n', '        uint256 _value, \n', '        uint256 _gasPrice, \n', '        uint256 _nonce) \n', '      public\n', '      validPayload(292)\n', '    returns (bool) \n', '    {\n', '        uint256 gas = gasleft();\n', '        address from = recoverPreSigned(_signature, decreaseApprovalSig, _to, _value, "", _gasPrice, _nonce);\n', '        require(from != address(0));\n', '        require(!invalidSignatures[from][_signature]);\n', '        \n', '        invalidSignatures[from][_signature] = true;\n', '        nonces[from]++;\n', '        \n', '        require(_decreaseApproval(from, _to, _value));\n', '\n', '        if (_gasPrice > 0) {\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev approveAndCallPreSigned allows a user to approve a contract and call a function on it\n', '     * @dev in the same transaction. As with the other presigneds, a delegate calls this with signed data from user.\n', '     * @dev This function is the big reason we&#39;re using gas price and calculating gas use.\n', '     * @dev Using this with the investment contract can result in varying gas costs.\n', '     * @param _extraData The data to send to the contract.\n', '    **/\n', '    function approveAndCallPreSigned(\n', '        bytes _signature,\n', '        address _to, \n', '        uint256 _value,\n', '        bytes _extraData,\n', '        uint256 _gasPrice, \n', '        uint256 _nonce) \n', '      public\n', '      validPayload(356)\n', '    returns (bool) \n', '    {\n', '        uint256 gas = gasleft();\n', '        address from = recoverPreSigned(_signature, approveAndCallSig, _to, _value, _extraData, _gasPrice, _nonce);\n', '        require(from != address(0));\n', '        require(!invalidSignatures[from][_signature]);\n', '        \n', '        invalidSignatures[from][_signature] = true;\n', '        nonces[from]++;\n', '        \n', '        require(_approve(from, _to, _value));\n', '        ApproveAndCallFallBack(_to).receiveApproval(from, _value, address(this), _extraData);\n', '\n', '        if (_gasPrice > 0) {\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '\n', '/** *************************** Revoke PreSigned ************************** **/\n', '    \n', '    /**\n', '     * @dev Revoke signature without going through a delegate.\n', '     * @param _sigToRevoke The signature that you no longer want to be used.\n', '    **/\n', '    function revokeSignature(bytes _sigToRevoke)\n', '      public\n', '    returns (bool)\n', '    {\n', '        invalidSignatures[msg.sender][_sigToRevoke] = true;\n', '        \n', '        emit SignatureRedeemed(_sigToRevoke, msg.sender);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Revoke signature through a delegate.\n', '     * @param _signature The signature allowing this revocation.\n', '     * @param _sigToRevoke The signature that you would like revoked.\n', '     * @param _gasPrice The amount of token wei to be paid for each uint of gas.\n', '    **/\n', '    function revokeSignaturePreSigned(\n', '        bytes _signature,\n', '        bytes _sigToRevoke,\n', '        uint256 _gasPrice)\n', '      public\n', '      validPayload(356)\n', '    returns (bool)\n', '    {\n', '        uint256 gas = gasleft();\n', '        address from = recoverRevokeHash(_signature, _sigToRevoke, _gasPrice);\n', '        require(!invalidSignatures[from][_signature]);\n', '        invalidSignatures[from][_signature] = true;\n', '        \n', '        invalidSignatures[from][_sigToRevoke] = true;\n', '        \n', '        if (_gasPrice > 0) {\n', '            gas = 35000 + gas.sub(gasleft());\n', '            require(_transfer(from, msg.sender, _gasPrice.mul(gas)));\n', '        }\n', '        \n', '        emit SignatureRedeemed(_signature, from);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Get hash for a revocation.\n', '     * @param _sigToRevoke The signature to be revoked.\n', '     * @param _gasPrice The amount to be paid to delegate for sending this tx.\n', '    **/\n', '    function getRevokeHash(bytes _sigToRevoke, uint256 _gasPrice)\n', '      public\n', '      pure\n', '    returns (bytes32 txHash)\n', '    {\n', '        return keccak256(revokeSignatureSig, _sigToRevoke, _gasPrice);\n', '    }\n', '\n', '    /**\n', '     * @dev Recover the address from a revocation signature.\n', '     * @param _sigToRevoke The signature to be revoked.\n', '     * @param _signature The signature allowing this revocation.\n', '     * @param _gasPrice The amount of token wei to be paid for each unit of gas.\n', '    **/\n', '    function recoverRevokeHash(bytes _signature, bytes _sigToRevoke, uint256 _gasPrice)\n', '      public\n', '      pure\n', '    returns (address from)\n', '    {\n', '        return ecrecoverFromSig(getSignHash(getRevokeHash(_sigToRevoke, _gasPrice)), _signature);\n', '    }\n', '    \n', '/** ************************** PreSigned Constants ************************ **/\n', '\n', '    /**\n', '     * @dev Used in frontend and contract to get hashed data of any given pre-signed transaction.\n', '     * @param _to The address to transfer COIN to.\n', '     * @param _value The amount of COIN to be transferred.\n', '     * @param _extraData Extra data of tx if needed. Transfers and approves will leave this null.\n', '     * @param _function Function signature of the pre-signed function being used.\n', '     * @param _gasPrice The agreed-upon amount of COIN to be paid per unit of gas.\n', '     * @param _nonce The user&#39;s nonce of the new transaction.\n', '    **/\n', '    function getPreSignedHash(\n', '        bytes4 _function,\n', '        address _to, \n', '        uint256 _value,\n', '        bytes _extraData,\n', '        uint256 _gasPrice,\n', '        uint256 _nonce)\n', '      public\n', '      view\n', '    returns (bytes32 txHash) \n', '    {\n', '        return keccak256(address(this), _function, _to, _value, _extraData, _gasPrice, _nonce);\n', '    }\n', '    \n', '    /**\n', '     * @dev Recover an address from a signed pre-signed hash.\n', '     * @param _sig The signed hash.\n', '     * @param _function The function signature for function being called.\n', '     * @param _to The address to transfer/approve/transferFrom/etc. tokens to.\n', '     * @param _value The amont of tokens to transfer/approve/etc.\n', '     * @param _extraData The extra data included in the transaction, if any.\n', '     * @param _gasPrice The amount of token wei to be paid to the delegate for each unit of gas.\n', '     * @param _nonce The user&#39;s nonce for this transaction.\n', '    **/\n', '    function recoverPreSigned(\n', '        bytes _sig,\n', '        bytes4 _function,\n', '        address _to,\n', '        uint256 _value,\n', '        bytes _extraData,\n', '        uint256 _gasPrice,\n', '        uint256 _nonce) \n', '      public\n', '      view\n', '    returns (address recovered)\n', '    {\n', '        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);\n', '    }\n', '    \n', '    /**\n', '     * @dev Add signature prefix to hash for recovery &#224; la ERC191.\n', '     * @param _hash The hashed transaction to add signature prefix to.\n', '    **/\n', '    function getSignHash(bytes32 _hash)\n', '      public\n', '      pure\n', '    returns (bytes32 signHash)\n', '    {\n', '        return keccak256("\\x19Ethereum Signed Message:\\n32", _hash);\n', '    }\n', '\n', '    /**\n', '     * @dev Helps to reduce stack depth problems for delegations. Thank you to Bokky for this!\n', '     * @param hash The hash of signed data for the transaction.\n', '     * @param sig Contains r, s, and v for recovery of address from the hash.\n', '    **/\n', '    function ecrecoverFromSig(bytes32 hash, bytes sig) \n', '      public \n', '      pure \n', '    returns (address recoveredAddress) \n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        if (sig.length != 65) return address(0);\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            // Here we are loading the last 32 bytes. We exploit the fact that &#39;mload&#39; will pad with zeroes if we overread.\n', '            // There is no &#39;mload8&#39; to do this, but that would be nicer.\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\n', '        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\n', '        /**\n', '         * @notice This used to be if (v < 27) { v += 27 } but that allowed delegates to duplicate signatures.\n', '         *         Any delegate that accepts signatures must now ensure that v == 0.\n', '        **/\n', '        v += 27;\n', '        if (v != 27 && v != 28) return address(0);\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Frontend queries to find the next nonce of the user so they can find the new nonce to send.\n', '     * @param _owner Address that will be sending the COIN.\n', '    **/\n', '    function getNonce(address _owner)\n', '      external\n', '      view\n', '    returns (uint256 nonce)\n', '    {\n', '        return nonces[_owner];\n', '    }\n', '    \n', '/** ****************************** Constants ******************************* **/\n', '    \n', '    /**\n', '     * @dev Return total supply of token.\n', '    **/\n', '    function totalSupply() \n', '      external\n', '      view \n', '     returns (uint256)\n', '    {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Return balance of a certain address.\n', '     * @param _owner The address whose balance we want to check.\n', '    **/\n', '    function balanceOf(address _owner)\n', '      external\n', '      view \n', '    returns (uint256) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    /**\n', '     * @dev Allowed amount for a user to spend of another&#39;s tokens.\n', '     * @param _owner The owner of the tokens approved to spend.\n', '     * @param _spender The address of the user allowed to spend the tokens.\n', '    **/\n', '    function allowance(address _owner, address _spender) \n', '      external\n', '      view \n', '    returns (uint256) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '/** ****************************** onlyOwner ******************************* **/\n', '    \n', '    /**\n', '     * @dev Allow the owner to take ERC20 tokens off of this contract if they are accidentally sent.\n', '    **/\n', '    function token_escape(address _tokenContract)\n', '      external\n', '      onlyOwner\n', '    {\n', '        CoinvestToken lostToken = CoinvestToken(_tokenContract);\n', '        \n', '        uint256 stuckTokens = lostToken.balanceOf(address(this));\n', '        lostToken.transfer(owner, stuckTokens);\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner may set the standard sig to redirect to one of our pre-signed functions.\n', '     * @dev Added in order to prepare for the ERC865 standard function names to be different from ours.\n', '     * @param _standardSig The function signature of the finalized standard function.\n', '     * @param _ourSig The function signature of our implemented function.\n', '    **/\n', '    function updateStandard(bytes4 _standardSig, bytes4 _ourSig)\n', '      external\n', '      onlyOwner\n', '    returns (bool success)\n', '    {\n', '        // These 6 are the signatures of our pre-signed functions. Don&#39;t want the owner messin&#39; around.\n', '        require(_ourSig == 0x1296830d || _ourSig == 0x617b390b || _ourSig == 0xadb8249e ||\n', '            _ourSig == 0x8be52783 || _ourSig == 0xc8d4b389 || _ourSig == 0xe391a7c4);\n', '        standardSigs[_standardSig] = _ourSig;\n', '        return true;\n', '    }\n', '    \n', '/** ***************************** Modifiers ******************************** **/\n', '    \n', '    modifier validPayload(uint _size) {\n', '        uint payload_size;\n', '        assembly {\n', '            payload_size := calldatasize\n', '        }\n', '        require(payload_size >= _size);\n', '        _;\n', '    }\n', '    \n', '}']