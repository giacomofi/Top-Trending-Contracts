['pragma solidity ^0.4.21;\n', '\n', '/***********************/\n', '/* Trustedhealth Token */\n', '/***********************/\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/************************/\n', '/* STANDARD ERC20 TOKEN */\n', '/************************/\n', '\n', 'contract ERC20Token {\n', '\n', '    /** Functions needed to be implemented by ERC20 standard **/\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance);\n', '    function transfer(address _to, uint256 _amount) public returns (bool _success);\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success);\n', '    function approve(address _spender, uint256 _amount) public returns (bool _success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '}\n', '\n', '\n', '/**************************************/\n', '/* TRUSTEDHEALTH TOKEN IMPLEMENTATION */\n', '/**************************************/\n', '\n', 'contract TrustedhealthToken is ERC20Token, owned {\n', '    using SafeMath for uint256;\n', '\n', '    /* Public variables */\n', '    string public name = "Trustedhealth";\n', '    string public symbol = "TDH";\n', '    uint8 public decimals = 18;\n', '    bool public tokenFrozen;\n', '\n', '    /* Private variables */\n', '    uint256 supply;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '    mapping (address => bool) allowedToMint;\n', '\n', '    /* Events */\n', '    event TokenFrozen(bool _frozen, string _reason);\n', '    event Mint(address indexed _to, uint256 _value);\n', '\n', '    /**\n', '    * Constructor function\n', '    *\n', '    * Initializes contract.\n', '    **/\n', '    function TrustedhealthToken() public {\n', '        tokenFrozen = false;\n', '    }\n', '\n', '    /**\n', '    * Internal transfer function.\n', '    **/\n', '    function _transfer(address _from, address _to, uint256 _amount) private {\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    /**\n', '    * Transfer token\n', '    *\n', '    * Send &#39;_amount&#39; tokens to &#39;_to&#39; from your address.\n', '    *\n', '    * @param _to Address of recipient.\n', '    * @param _amount Amount to send.\n', '    * @return Whether the transfer was successful or not.\n', '    **/\n', '    function transfer(address _to, uint256 _amount) public returns (bool _success) {\n', '        require(!tokenFrozen);\n', '        _transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Set allowance\n', '    *\n', '    * Allows &#39;_spender&#39; to spend &#39;_amount&#39; tokens from your address\n', '    *\n', '    * @param _spender Address of spender.\n', '    * @param _amount Max amount allowed to spend.\n', '    * @return Whether the approve was successful or not.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) public returns (bool _success) {\n', '        allowances[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *Transfer token from\n', '    *\n', '    * Send &#39;_amount&#39; token from address &#39;_from&#39; to address &#39;_to&#39;\n', '    *\n', '    * @param _from Address of sender.\n', '    * @param _to Address of recipient.\n', '    * @param _amount Amount of token to send.\n', '    * @return Whether the transfer was successful or not.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success) {\n', '        require(_amount <= allowances[_from][msg.sender]);\n', '        require(!tokenFrozen);\n', '        _transfer(_from, _to, _amount);\n', '        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Mint Tokens\n', '    *\n', '    * Adds _amount of tokens to _atAddress\n', '    *\n', '    * @param _atAddress Adds tokens to address\n', '    * @param _amount Amount of tokens to add\n', '    **/\n', '    function mintTokens(address _atAddress, uint256 _amount) public {\n', '        require(allowedToMint[msg.sender]);\n', '        require(balances[_atAddress].add(_amount) > balances[_atAddress]);\n', '        require((supply.add(_amount)) <= 201225419354262000000000000);\n', '        supply = supply.add(_amount);\n', '        balances[_atAddress] = balances[_atAddress].add(_amount);\n', '        emit Mint(_atAddress, _amount);\n', '        emit Transfer(0x0, _atAddress, _amount);\n', '    }\n', '\n', '    /**\n', '    * Change freeze\n', '    *\n', '    * Changes status of frozen because of &#39;_reason&#39;\n', '    *\n', '    * @param _reason Reason for freezing or unfreezing token\n', '    **/\n', '    function changeFreezeTransaction(string _reason) public onlyOwner {\n', '        tokenFrozen = !tokenFrozen;\n', '        emit TokenFrozen(tokenFrozen, _reason);\n', '    }\n', '\n', '    /**\n', '    * Change mint address\n', '    *\n', '    *  Changes the address to mint\n', '    *\n', '    * @param _addressToMint Address of new minter\n', '    **/\n', '    function changeAllowanceToMint(address _addressToMint) public onlyOwner {\n', '        allowedToMint[_addressToMint] = !allowedToMint[_addressToMint];\n', '    }\n', '\n', '    /**\n', '    * Get allowance\n', '    *\n', '    * @return Return amount allowed to spend from &#39;_owner&#39; by &#39;_spender&#39;\n', '    **/\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * Total amount of token\n', '    *\n', '    * @return Total amount of token\n', '    **/\n', '    function totalSupply() public constant returns (uint256 _totalSupply) {\n', '        return supply;\n', '    }\n', '\n', '    /**\n', '    * Balance of address\n', '    *\n', '    * Check balance of &#39;_owner&#39;\n', '    *\n', '    * @param _owner Address\n', '    * @return Amount of token in possession\n', '    **/\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * Address allowed to mint\n', '    *\n', '    * Checks if &#39;_address&#39; is allowed to mint\n', '    *\n', '    * @param _address Address\n', '    * @return Allowance to mint\n', '    **/\n', '    function isAllowedToMint(address _address) public constant returns (bool _allowed) {\n', '        return allowedToMint[_address];\n', '    }\n', '\n', '    /** Revert if someone sends ether to this contract **/\n', '    function () public {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '    * This part is here only for testing and will not be included into final version\n', '    **/\n', '    /**\n', '    function killContract() onlyOwner{\n', '    selfdestruct(msg.sender);\n', '    }\n', '    **/\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/***********************/\n', '/* Trustedhealth Token */\n', '/***********************/\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/************************/\n', '/* STANDARD ERC20 TOKEN */\n', '/************************/\n', '\n', 'contract ERC20Token {\n', '\n', '    /** Functions needed to be implemented by ERC20 standard **/\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance);\n', '    function transfer(address _to, uint256 _amount) public returns (bool _success);\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success);\n', '    function approve(address _spender, uint256 _amount) public returns (bool _success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n', '}\n', '\n', '\n', '/**************************************/\n', '/* TRUSTEDHEALTH TOKEN IMPLEMENTATION */\n', '/**************************************/\n', '\n', 'contract TrustedhealthToken is ERC20Token, owned {\n', '    using SafeMath for uint256;\n', '\n', '    /* Public variables */\n', '    string public name = "Trustedhealth";\n', '    string public symbol = "TDH";\n', '    uint8 public decimals = 18;\n', '    bool public tokenFrozen;\n', '\n', '    /* Private variables */\n', '    uint256 supply;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '    mapping (address => bool) allowedToMint;\n', '\n', '    /* Events */\n', '    event TokenFrozen(bool _frozen, string _reason);\n', '    event Mint(address indexed _to, uint256 _value);\n', '\n', '    /**\n', '    * Constructor function\n', '    *\n', '    * Initializes contract.\n', '    **/\n', '    function TrustedhealthToken() public {\n', '        tokenFrozen = false;\n', '    }\n', '\n', '    /**\n', '    * Internal transfer function.\n', '    **/\n', '    function _transfer(address _from, address _to, uint256 _amount) private {\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    /**\n', '    * Transfer token\n', '    *\n', "    * Send '_amount' tokens to '_to' from your address.\n", '    *\n', '    * @param _to Address of recipient.\n', '    * @param _amount Amount to send.\n', '    * @return Whether the transfer was successful or not.\n', '    **/\n', '    function transfer(address _to, uint256 _amount) public returns (bool _success) {\n', '        require(!tokenFrozen);\n', '        _transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Set allowance\n', '    *\n', "    * Allows '_spender' to spend '_amount' tokens from your address\n", '    *\n', '    * @param _spender Address of spender.\n', '    * @param _amount Max amount allowed to spend.\n', '    * @return Whether the approve was successful or not.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) public returns (bool _success) {\n', '        allowances[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *Transfer token from\n', '    *\n', "    * Send '_amount' token from address '_from' to address '_to'\n", '    *\n', '    * @param _from Address of sender.\n', '    * @param _to Address of recipient.\n', '    * @param _amount Amount of token to send.\n', '    * @return Whether the transfer was successful or not.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success) {\n', '        require(_amount <= allowances[_from][msg.sender]);\n', '        require(!tokenFrozen);\n', '        _transfer(_from, _to, _amount);\n', '        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Mint Tokens\n', '    *\n', '    * Adds _amount of tokens to _atAddress\n', '    *\n', '    * @param _atAddress Adds tokens to address\n', '    * @param _amount Amount of tokens to add\n', '    **/\n', '    function mintTokens(address _atAddress, uint256 _amount) public {\n', '        require(allowedToMint[msg.sender]);\n', '        require(balances[_atAddress].add(_amount) > balances[_atAddress]);\n', '        require((supply.add(_amount)) <= 201225419354262000000000000);\n', '        supply = supply.add(_amount);\n', '        balances[_atAddress] = balances[_atAddress].add(_amount);\n', '        emit Mint(_atAddress, _amount);\n', '        emit Transfer(0x0, _atAddress, _amount);\n', '    }\n', '\n', '    /**\n', '    * Change freeze\n', '    *\n', "    * Changes status of frozen because of '_reason'\n", '    *\n', '    * @param _reason Reason for freezing or unfreezing token\n', '    **/\n', '    function changeFreezeTransaction(string _reason) public onlyOwner {\n', '        tokenFrozen = !tokenFrozen;\n', '        emit TokenFrozen(tokenFrozen, _reason);\n', '    }\n', '\n', '    /**\n', '    * Change mint address\n', '    *\n', '    *  Changes the address to mint\n', '    *\n', '    * @param _addressToMint Address of new minter\n', '    **/\n', '    function changeAllowanceToMint(address _addressToMint) public onlyOwner {\n', '        allowedToMint[_addressToMint] = !allowedToMint[_addressToMint];\n', '    }\n', '\n', '    /**\n', '    * Get allowance\n', '    *\n', "    * @return Return amount allowed to spend from '_owner' by '_spender'\n", '    **/\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * Total amount of token\n', '    *\n', '    * @return Total amount of token\n', '    **/\n', '    function totalSupply() public constant returns (uint256 _totalSupply) {\n', '        return supply;\n', '    }\n', '\n', '    /**\n', '    * Balance of address\n', '    *\n', "    * Check balance of '_owner'\n", '    *\n', '    * @param _owner Address\n', '    * @return Amount of token in possession\n', '    **/\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * Address allowed to mint\n', '    *\n', "    * Checks if '_address' is allowed to mint\n", '    *\n', '    * @param _address Address\n', '    * @return Allowance to mint\n', '    **/\n', '    function isAllowedToMint(address _address) public constant returns (bool _allowed) {\n', '        return allowedToMint[_address];\n', '    }\n', '\n', '    /** Revert if someone sends ether to this contract **/\n', '    function () public {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '    * This part is here only for testing and will not be included into final version\n', '    **/\n', '    /**\n', '    function killContract() onlyOwner{\n', '    selfdestruct(msg.sender);\n', '    }\n', '    **/\n', '}']
