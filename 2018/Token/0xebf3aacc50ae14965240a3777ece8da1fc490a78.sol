['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract ExToke is ERC20Interface, Owned, SafeMath {\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    address public oldAddress;\n', '    address public tokenAdmin;\n', '    uint public _totalSupply;\n', '    uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We&#39;ll store the total ETH raised via our ICO here.  \n', '    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', '    address public fundsWallet;           \n', '    uint256 public crowdSaleSupply;\n', '    uint256 public tokenSwapSupply;\n', '    uint256 public dividendSupply;\n', '    \n', '    uint256 public scaling;\n', '    uint256 public scaledRemainder;\n', '    \n', '    uint256 public finishTime = 1548057600;\n', '    uint256 public startTime = 1540814400;\n', '    \n', '    uint256[] public releaseDates = \n', '        [1575201600, 1577880000, 1580558400, 1583064000, 1585742400, 1588334400,\n', '        1591012800, 1593604800, 1596283200, 1598961600, 1601553600, 1604232000,\n', '        1606824000, 1609502400, 1612180800, 1614600000, 1617278400, 1619870400,\n', '        1622548800, 1625140800, 1627819200, 1630497600, 1633089600, 1635768000];\n', '    \n', '    uint256 public nextRelease;\n', '\n', '    mapping(address => uint256) public scaledDividendBalanceOf;\n', '\n', '    uint256 public scaledDividendPerToken;\n', '\n', '    mapping(address => uint256) public scaledDividendCreditedTo;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    function ExToke() public {\n', '        symbol = "XTE";\n', '        name = "ExToke";\n', '        decimals = 18;\n', '        tokenAdmin = 0xEd86f5216BCAFDd85E5875d35463Aca60925bF16;\n', '        oldAddress = 0x28925299Ee1EDd8Fd68316eAA64b651456694f0f;\n', '    \t_totalSupply = 7000000000000000000000000000;\n', '    \tcrowdSaleSupply = 500000000000000000000000000;\n', '    \ttokenSwapSupply = 2911526439961880000000000000;\n', '    \tdividendSupply = 2400000000000000000000000000;\n', '    \tunitsOneEthCanBuy = 100000;\n', '        balances[this] = 5811526439961880000000000000;\n', '        balances[0x6baba6fb9d2cb2f109a41de2c9ab0f7a1b5744ce] = 1188473560038120000000000000;\n', '        \n', '        nextRelease = 0;\n', '        \n', '        scaledRemainder = 0;\n', '        scaling = uint256(10) ** 8;\n', '        \n', '    \tfundsWallet = tokenAdmin;\n', '        Transfer(this, 0x6baba6fb9d2cb2f109a41de2c9ab0f7a1b5744ce, 1188473560038120000000000000);\n', '\n', '    }\n', '    \n', '    \n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        update(msg.sender);\n', '        update(to);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        update(from);\n', '        update(to);\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '    \n', '    function update(address account) internal {\n', '        if(nextRelease < 24 && block.timestamp > releaseDates[nextRelease]){\n', '            releaseDivTokens();\n', '        }\n', '        uint256 owed =\n', '            scaledDividendPerToken - scaledDividendCreditedTo[account];\n', '        scaledDividendBalanceOf[account] += balances[account] * owed;\n', '        scaledDividendCreditedTo[account] = scaledDividendPerToken;\n', '        \n', '        \n', '    }\n', '    \n', '    function () public payable {\n', '        if(startTime < block.timestamp && finishTime >= block.timestamp && crowdSaleSupply >= msg.value * unitsOneEthCanBuy){\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        require(balances[this] >= amount);\n', '\n', '        balances[this] = balances[this] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '        \n', '        crowdSaleSupply -= msg.value * unitsOneEthCanBuy;\n', '\n', '        Transfer(this, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        tokenAdmin.transfer(msg.value);\n', '        }\n', '        else if(finishTime < block.timestamp){\n', '            balances[this] = balances[this] - amount;\n', '            balances[tokenAdmin] += crowdSaleSupply;\n', '            tokenAdmin.transfer(msg.value);\n', '            Transfer(this, tokenAdmin, amount);\n', '            crowdSaleSupply = 0;\n', '        }\n', '        \n', '        \n', '    }\n', '    \n', '    function releaseDivTokens() public returns (bool success){\n', '        require(block.timestamp > releaseDates[nextRelease]);\n', '        uint256 releaseAmount = 100000000 * (uint256(10) ** decimals);\n', '        dividendSupply -= releaseAmount;\n', '        uint256 available = (releaseAmount * scaling) + scaledRemainder;\n', '        scaledDividendPerToken += available / _totalSupply;\n', '        scaledRemainder = available % _totalSupply;\n', '        nextRelease += 1;\n', '        return true;\n', '    }\n', '    \n', '    function withdraw() public returns (bool success){\n', '        require(block.timestamp > releaseDates[0]);\n', '        update(msg.sender);\n', '        uint256 amount = scaledDividendBalanceOf[msg.sender] / scaling;\n', '        scaledDividendBalanceOf[msg.sender] %= scaling;  // retain the remainder\n', '        balances[msg.sender] += amount;\n', '        balances[this] -= amount;\n', '        emit Transfer(this, msg.sender, amount);\n', '        return true;\n', '    }\n', '    \n', '    function swap(uint256 sendAmount) returns (bool success){\n', '        require(tokenSwapSupply >= sendAmount * 3);\n', '        if(ERC20Interface(oldAddress).transferFrom(msg.sender, tokenAdmin, sendAmount)){\n', '            balances[msg.sender] += sendAmount * 3;\n', '            balances[this] -= sendAmount * 3;\n', '            tokenSwapSupply -= sendAmount * 3;\n', '        }\n', '        emit Transfer(this, msg.sender, sendAmount * 3);\n', '        return true;\n', '    }\n', '    \n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract ExToke is ERC20Interface, Owned, SafeMath {\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    address public oldAddress;\n', '    address public tokenAdmin;\n', '    uint public _totalSupply;\n', "    uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.  \n", '    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', '    address public fundsWallet;           \n', '    uint256 public crowdSaleSupply;\n', '    uint256 public tokenSwapSupply;\n', '    uint256 public dividendSupply;\n', '    \n', '    uint256 public scaling;\n', '    uint256 public scaledRemainder;\n', '    \n', '    uint256 public finishTime = 1548057600;\n', '    uint256 public startTime = 1540814400;\n', '    \n', '    uint256[] public releaseDates = \n', '        [1575201600, 1577880000, 1580558400, 1583064000, 1585742400, 1588334400,\n', '        1591012800, 1593604800, 1596283200, 1598961600, 1601553600, 1604232000,\n', '        1606824000, 1609502400, 1612180800, 1614600000, 1617278400, 1619870400,\n', '        1622548800, 1625140800, 1627819200, 1630497600, 1633089600, 1635768000];\n', '    \n', '    uint256 public nextRelease;\n', '\n', '    mapping(address => uint256) public scaledDividendBalanceOf;\n', '\n', '    uint256 public scaledDividendPerToken;\n', '\n', '    mapping(address => uint256) public scaledDividendCreditedTo;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    function ExToke() public {\n', '        symbol = "XTE";\n', '        name = "ExToke";\n', '        decimals = 18;\n', '        tokenAdmin = 0xEd86f5216BCAFDd85E5875d35463Aca60925bF16;\n', '        oldAddress = 0x28925299Ee1EDd8Fd68316eAA64b651456694f0f;\n', '    \t_totalSupply = 7000000000000000000000000000;\n', '    \tcrowdSaleSupply = 500000000000000000000000000;\n', '    \ttokenSwapSupply = 2911526439961880000000000000;\n', '    \tdividendSupply = 2400000000000000000000000000;\n', '    \tunitsOneEthCanBuy = 100000;\n', '        balances[this] = 5811526439961880000000000000;\n', '        balances[0x6baba6fb9d2cb2f109a41de2c9ab0f7a1b5744ce] = 1188473560038120000000000000;\n', '        \n', '        nextRelease = 0;\n', '        \n', '        scaledRemainder = 0;\n', '        scaling = uint256(10) ** 8;\n', '        \n', '    \tfundsWallet = tokenAdmin;\n', '        Transfer(this, 0x6baba6fb9d2cb2f109a41de2c9ab0f7a1b5744ce, 1188473560038120000000000000);\n', '\n', '    }\n', '    \n', '    \n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        update(msg.sender);\n', '        update(to);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        update(from);\n', '        update(to);\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '    \n', '    function update(address account) internal {\n', '        if(nextRelease < 24 && block.timestamp > releaseDates[nextRelease]){\n', '            releaseDivTokens();\n', '        }\n', '        uint256 owed =\n', '            scaledDividendPerToken - scaledDividendCreditedTo[account];\n', '        scaledDividendBalanceOf[account] += balances[account] * owed;\n', '        scaledDividendCreditedTo[account] = scaledDividendPerToken;\n', '        \n', '        \n', '    }\n', '    \n', '    function () public payable {\n', '        if(startTime < block.timestamp && finishTime >= block.timestamp && crowdSaleSupply >= msg.value * unitsOneEthCanBuy){\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        require(balances[this] >= amount);\n', '\n', '        balances[this] = balances[this] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '        \n', '        crowdSaleSupply -= msg.value * unitsOneEthCanBuy;\n', '\n', '        Transfer(this, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        tokenAdmin.transfer(msg.value);\n', '        }\n', '        else if(finishTime < block.timestamp){\n', '            balances[this] = balances[this] - amount;\n', '            balances[tokenAdmin] += crowdSaleSupply;\n', '            tokenAdmin.transfer(msg.value);\n', '            Transfer(this, tokenAdmin, amount);\n', '            crowdSaleSupply = 0;\n', '        }\n', '        \n', '        \n', '    }\n', '    \n', '    function releaseDivTokens() public returns (bool success){\n', '        require(block.timestamp > releaseDates[nextRelease]);\n', '        uint256 releaseAmount = 100000000 * (uint256(10) ** decimals);\n', '        dividendSupply -= releaseAmount;\n', '        uint256 available = (releaseAmount * scaling) + scaledRemainder;\n', '        scaledDividendPerToken += available / _totalSupply;\n', '        scaledRemainder = available % _totalSupply;\n', '        nextRelease += 1;\n', '        return true;\n', '    }\n', '    \n', '    function withdraw() public returns (bool success){\n', '        require(block.timestamp > releaseDates[0]);\n', '        update(msg.sender);\n', '        uint256 amount = scaledDividendBalanceOf[msg.sender] / scaling;\n', '        scaledDividendBalanceOf[msg.sender] %= scaling;  // retain the remainder\n', '        balances[msg.sender] += amount;\n', '        balances[this] -= amount;\n', '        emit Transfer(this, msg.sender, amount);\n', '        return true;\n', '    }\n', '    \n', '    function swap(uint256 sendAmount) returns (bool success){\n', '        require(tokenSwapSupply >= sendAmount * 3);\n', '        if(ERC20Interface(oldAddress).transferFrom(msg.sender, tokenAdmin, sendAmount)){\n', '            balances[msg.sender] += sendAmount * 3;\n', '            balances[this] -= sendAmount * 3;\n', '            tokenSwapSupply -= sendAmount * 3;\n', '        }\n', '        emit Transfer(this, msg.sender, sendAmount * 3);\n', '        return true;\n', '    }\n', '    \n', '\n', '\n', '}']
