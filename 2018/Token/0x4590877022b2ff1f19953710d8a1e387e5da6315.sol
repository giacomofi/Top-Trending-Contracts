['pragma solidity ^0.4.24;\n', '\n', '// ERC20 token contract\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '}\n', '\n', 'contract MeerkatToken is ERC20Interface {\n', '    address public owner;\n', '    string public symbol;\n', '    string public name;\n', '    uint8 public decimals;\n', '    uint public initSupply;\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        symbol = "MCT";\n', '        name = "Meerkat Token";\n', '        decimals = 18;\n', '        initSupply = 10000000000 * 10**uint(decimals);\n', '        balances[owner] = initSupply;\n', '        \n', '        emit Transfer(address(0), owner, initSupply);\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return initSupply - balances[address(0)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        uint previousBalances = balances[msg.sender] + balances[_to];\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        \n', '        emit Transfer(msg.sender, _to, _value);\n', '        assert(balances[msg.sender] + balances[_to] == previousBalances);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// ERC20 token contract\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '}\n', '\n', 'contract MeerkatToken is ERC20Interface {\n', '    address public owner;\n', '    string public symbol;\n', '    string public name;\n', '    uint8 public decimals;\n', '    uint public initSupply;\n', '\n', '    mapping(address => uint) balances;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        symbol = "MCT";\n', '        name = "Meerkat Token";\n', '        decimals = 18;\n', '        initSupply = 10000000000 * 10**uint(decimals);\n', '        balances[owner] = initSupply;\n', '        \n', '        emit Transfer(address(0), owner, initSupply);\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return initSupply - balances[address(0)];\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        uint previousBalances = balances[msg.sender] + balances[_to];\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        \n', '        emit Transfer(msg.sender, _to, _value);\n', '        assert(balances[msg.sender] + balances[_to] == previousBalances);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '}']
