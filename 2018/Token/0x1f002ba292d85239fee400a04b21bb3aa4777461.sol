['pragma solidity ^0.4.11;\n', '\n', '/*\n', '--------------------------------------------------------------------------------\n', '\n', 'ERC20: https://github.com/ethereum/EIPs/issues/20\n', 'ERC223: https://github.com/ethereum/EIPs/issues/223\n', '\n', 'MIT Licence\n', '--------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '* Contract that is working with ERC223 tokens\n', '*/\n', '\n', 'contract ContractReceiver {\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '    /* Fix for Mist warning */\n', '    _from;\n', '    _value;\n', '    _data;\n', '  }\n', '}\n', '\n', '\n', 'contract FLTTToken {\n', '    /* Contract Constants */\n', '    string public constant _name = "FLTTcoin";\n', '    string public constant _symbol = "FLTT";\n', '    uint8 public constant _decimals = 8;\n', '\n', '    /* The supply is initially 100,000,000MGO to the precision of 8 decimals */\n', '    uint256 public constant _initialSupply = 49800000000000000;\n', '\n', '    /* Contract Variables */\n', '    address public owner;\n', '    uint256 public _currentSupply;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping (address => uint256)) public allowed;\n', '\n', '    /* Constructor initializes the owner&#39;s balance and the supply  */\n', '    function FLTTToken() {\n', '        owner = msg.sender;\n', '        _currentSupply = _initialSupply;\n', '        balances[owner] = _initialSupply;\n', '    }\n', '\n', '    /* ERC20 Events */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* ERC223 Events */\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '\n', '    /* Non-ERC Events */\n', '    event Burn(address indexed from, uint256 amount, uint256 currentSupply, bytes data);\n', '\n', '    /* ERC20 Functions */\n', '    /* Return current supply in smallest denomination (1MGO = 100000000) */\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        return _initialSupply;\n', '    }\n', '\n', '    /* Returns the balance of a particular account */\n', '    function balanceOf(address _address) constant returns (uint256 balance) {\n', '        return balances[_address];\n', '    }\n', '\n', '    /* Transfer the balance from the sender&#39;s address to the address _to */\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            bytes memory empty;\n', '            if(isContract(_to)) {\n', '                return transferToContract(_to, _value, empty);\n', '            } else {\n', '                return transferToAddress(_to, _value, empty);\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Withdraws to address _to form the address _from up to the amount _value */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value\n', '            && allowed[_from][msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Allows _spender to withdraw the _allowance amount form sender */\n', '    function approve(address _spender, uint256 _allowance) returns (bool success) {\n', '        if (_allowance <= _currentSupply) {\n', '            allowed[msg.sender][_spender] = _allowance;\n', '            Approval(msg.sender, _spender, _allowance);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Checks how much _spender can withdraw from _owner */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* ERC223 Functions */\n', '    /* Get the contract constant _name */\n', '    function name() constant returns (string name) {\n', '        return _name;\n', '    }\n', '\n', '    /* Get the contract constant _symbol */\n', '    function symbol() constant returns (string symbol) {\n', '        return _symbol;\n', '    }\n', '\n', '    /* Get the contract constant _decimals */\n', '    function decimals() constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', '    /* Transfer the balance from the sender&#39;s address to the address _to with data _data */\n', '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            if(isContract(_to)) {\n', '                return transferToContract(_to, _value, _data);\n', '            } else {\n', '                return transferToAddress(_to, _value, _data);\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Transfer function when _to represents a regular address */\n', '    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /* Transfer function when _to represents a contract address, with the caveat\n', '    that the contract needs to implement the tokenFallback function in order to receive tokens */\n', '    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /* Infers if whether _address is a contract based on the presence of bytecode */\n', '    function isContract(address _address) internal returns (bool is_contract) {\n', '        uint length;\n', '        if (_address == 0) return false;\n', '        assembly {\n', '            length := extcodesize(_address)\n', '        }\n', '        if(length > 0) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Non-ERC Functions */\n', '    /* Remove the specified amount of the tokens from the supply permanently */\n', '    function burn(uint256 _value, bytes _data) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            _currentSupply -= _value;\n', '            Burn(msg.sender, _value, _currentSupply, _data);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Returns the total amount of tokens in supply */\n', '    function currentSupply() constant returns (uint256 currentSupply) {\n', '        return _currentSupply;\n', '    }\n', '\n', '    /* Returns the total amount of tokens ever burned */\n', '    function amountBurned() constant returns (uint256 amountBurned) {\n', '        return _initialSupply - _currentSupply;\n', '    }\n', '\n', '    /* Stops any attempt to send Ether to this contract */\n', '    function () {\n', '        throw;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '--------------------------------------------------------------------------------\n', '\n', 'ERC20: https://github.com/ethereum/EIPs/issues/20\n', 'ERC223: https://github.com/ethereum/EIPs/issues/223\n', '\n', 'MIT Licence\n', '--------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '* Contract that is working with ERC223 tokens\n', '*/\n', '\n', 'contract ContractReceiver {\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '    /* Fix for Mist warning */\n', '    _from;\n', '    _value;\n', '    _data;\n', '  }\n', '}\n', '\n', '\n', 'contract FLTTToken {\n', '    /* Contract Constants */\n', '    string public constant _name = "FLTTcoin";\n', '    string public constant _symbol = "FLTT";\n', '    uint8 public constant _decimals = 8;\n', '\n', '    /* The supply is initially 100,000,000MGO to the precision of 8 decimals */\n', '    uint256 public constant _initialSupply = 49800000000000000;\n', '\n', '    /* Contract Variables */\n', '    address public owner;\n', '    uint256 public _currentSupply;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping (address => uint256)) public allowed;\n', '\n', "    /* Constructor initializes the owner's balance and the supply  */\n", '    function FLTTToken() {\n', '        owner = msg.sender;\n', '        _currentSupply = _initialSupply;\n', '        balances[owner] = _initialSupply;\n', '    }\n', '\n', '    /* ERC20 Events */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* ERC223 Events */\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '\n', '    /* Non-ERC Events */\n', '    event Burn(address indexed from, uint256 amount, uint256 currentSupply, bytes data);\n', '\n', '    /* ERC20 Functions */\n', '    /* Return current supply in smallest denomination (1MGO = 100000000) */\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        return _initialSupply;\n', '    }\n', '\n', '    /* Returns the balance of a particular account */\n', '    function balanceOf(address _address) constant returns (uint256 balance) {\n', '        return balances[_address];\n', '    }\n', '\n', "    /* Transfer the balance from the sender's address to the address _to */\n", '    function transfer(address _to, uint _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            bytes memory empty;\n', '            if(isContract(_to)) {\n', '                return transferToContract(_to, _value, empty);\n', '            } else {\n', '                return transferToAddress(_to, _value, empty);\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Withdraws to address _to form the address _from up to the amount _value */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value\n', '            && allowed[_from][msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Allows _spender to withdraw the _allowance amount form sender */\n', '    function approve(address _spender, uint256 _allowance) returns (bool success) {\n', '        if (_allowance <= _currentSupply) {\n', '            allowed[msg.sender][_spender] = _allowance;\n', '            Approval(msg.sender, _spender, _allowance);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Checks how much _spender can withdraw from _owner */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* ERC223 Functions */\n', '    /* Get the contract constant _name */\n', '    function name() constant returns (string name) {\n', '        return _name;\n', '    }\n', '\n', '    /* Get the contract constant _symbol */\n', '    function symbol() constant returns (string symbol) {\n', '        return _symbol;\n', '    }\n', '\n', '    /* Get the contract constant _decimals */\n', '    function decimals() constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', "    /* Transfer the balance from the sender's address to the address _to with data _data */\n", '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '            if(isContract(_to)) {\n', '                return transferToContract(_to, _value, _data);\n', '            } else {\n', '                return transferToAddress(_to, _value, _data);\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Transfer function when _to represents a regular address */\n', '    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /* Transfer function when _to represents a contract address, with the caveat\n', '    that the contract needs to implement the tokenFallback function in order to receive tokens */\n', '    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    /* Infers if whether _address is a contract based on the presence of bytecode */\n', '    function isContract(address _address) internal returns (bool is_contract) {\n', '        uint length;\n', '        if (_address == 0) return false;\n', '        assembly {\n', '            length := extcodesize(_address)\n', '        }\n', '        if(length > 0) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Non-ERC Functions */\n', '    /* Remove the specified amount of the tokens from the supply permanently */\n', '    function burn(uint256 _value, bytes _data) returns (bool success) {\n', '        if (balances[msg.sender] >= _value\n', '            && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            _currentSupply -= _value;\n', '            Burn(msg.sender, _value, _currentSupply, _data);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* Returns the total amount of tokens in supply */\n', '    function currentSupply() constant returns (uint256 currentSupply) {\n', '        return _currentSupply;\n', '    }\n', '\n', '    /* Returns the total amount of tokens ever burned */\n', '    function amountBurned() constant returns (uint256 amountBurned) {\n', '        return _initialSupply - _currentSupply;\n', '    }\n', '\n', '    /* Stops any attempt to send Ether to this contract */\n', '    function () {\n', '        throw;\n', '    }\n', '}']
