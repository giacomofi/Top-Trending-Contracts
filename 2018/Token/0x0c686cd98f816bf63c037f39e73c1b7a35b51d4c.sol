['pragma solidity ^0.4.18;\n', '// -------------------------------------------------\n', '// ethPoker.io EPX token - ERC20 token smart contract\n', '// contact admin@ethpoker.io for queries\n', '// Revision 20b\n', '// Full test suite 20r passed\n', '// -------------------------------------------------\n', '// ERC Token Standard #20 interface:\n', '// https://github.com/ethereum/EIPs/issues/20\n', '// EPX contract sources:\n', '// https://github.com/EthPokerIO/ethpokerIO\n', '// ------------------------------------------------\n', '// 2018 improvements:\n', '// - added transferAnyERC20Token function to capture airdropped tokens\n', '// - added revert() rejection of any Eth sent to the token address itself\n', '// - additional gas optimisation performed (round 3)\n', '// -------------------------------------------------\n', '// Security reviews passed - cycle 20r\n', '// Functional reviews passed - cycle 20r\n', '// Final code revision and regression test cycle passed - cycle 20r\n', '// -------------------------------------------------\n', '\n', 'contract owned {\n', '  address public owner;\n', '\n', '  function owned() internal {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', 'contract safeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    safeAssert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    safeAssert(b > 0);\n', '    uint256 c = a / b;\n', '    safeAssert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    safeAssert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    safeAssert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function safeAssert(bool assertion) internal pure {\n', '    if (!assertion) revert();\n', '  }\n', '}\n', '\n', 'contract ERC20Interface is owned, safeMath {\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n', '  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  event Buy(address indexed _sender, uint256 _eth, uint256 _EPX);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract EPXToken is ERC20Interface {\n', '  // token setup variables\n', '  string  public constant name                  = "EthPoker.io EPX";\n', '  string  public constant standard              = "EPX";\n', '  string  public constant symbol                = "EPX";\n', '  uint8   public constant decimals              = 4;                               // 4 decimals for practicality\n', '  uint256 private constant totalSupply          = 2800000000000;                   // 280 000 000 (total supply of EPX tokens is 280,000,000) + 4 decimal points (2800000000000)\n', '\n', '  // token mappings\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  // ERC20 standard token possible events, matched to ICO and preSale contracts\n', '  event Buy(address indexed _sender, uint256 _eth, uint256 _EPX);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  // ERC20 token balanceOf query function\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  // token balance normalised for display (4 decimals removed)\n', '  function EPXtokenSupply() public pure returns (uint256 totalEPXtokenCount) {\n', '    return safeDiv(totalSupply,10000); // div by 1,000 for display normalisation (4 decimals)\n', '  }\n', '\n', '  // ERC20 token transfer function with additional safety\n', '  function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '    require(!(_to == 0x0));\n', '    if ((balances[msg.sender] >= _amount)\n', '    && (_amount > 0)\n', '    && ((safeAdd(balances[_to],_amount) > balances[_to]))) {\n', '      balances[msg.sender] = safeSub(balances[msg.sender], _amount);\n', '      balances[_to] = safeAdd(balances[_to], _amount);\n', '      Transfer(msg.sender, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // ERC20 token transferFrom function with additional safety\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _amount) public returns (bool success) {\n', '    require(!(_to == 0x0));\n', '    if ((balances[_from] >= _amount)\n', '    && (allowed[_from][msg.sender] >= _amount)\n', '    && (_amount > 0)\n', '    && (safeAdd(balances[_to],_amount) > balances[_to])) {\n', '      balances[_from] = safeSub(balances[_from], _amount);\n', '      allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);\n', '      balances[_to] = safeAdd(balances[_to], _amount);\n', '      Transfer(_from, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // ERC20 allow _spender to withdraw, multiple times, up to the _value amount\n', '  function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '    //Fix for known double-spend https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#\n', '    //Input must either set allow amount to 0, or have 0 already set, to workaround issue\n', '    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  // ERC20 return allowance for given owner spender pair\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  // ERC20 Updated increase approval process (to prevent double-spend attack but remove need to zero allowance before setting)\n', '  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender],_addedValue);\n', '\n', '    // report new approval amount\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // ERC20 Updated decrease approval process (to prevent double-spend attack but remove need to zero allowance before setting)\n', '  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = safeSub(oldValue,_subtractedValue);\n', '    }\n', '\n', '    // report new approval amount\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  // ERC20 Standard default function to assign initial supply variables and send balance to creator for distribution to EPX presale and ICO contract\n', '  function EPXToken() public onlyOwner {\n', '    balances[msg.sender] = totalSupply;\n', '  }\n', '\n', '  // Reject sent ETH\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  // Contract owner able to transfer any airdropped or ERC20 tokens that are sent to the token contract address (mistakenly or as part of airdrop campaign)\n', '  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '    return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '  }\n', '}']