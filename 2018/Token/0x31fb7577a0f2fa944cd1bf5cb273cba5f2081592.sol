['pragma solidity ^0.4.18;\n', '\n', 'contract RedEnvelope {\n', '\n', '    struct EnvelopeType {\n', '        uint256 maxNumber;\n', '        uint256 feeRate;\n', '    }\n', '    \n', '    struct Envelope {\n', '        address maker;\n', '        address arbiter;\n', '        uint256 envelopeTypeId;\n', '        uint256 minValue;\n', '        uint256 remainingValue;\n', '        uint256 remainingNumber;\n', '        uint256 willExpireAfter;\n', '        bool random;\n', '        mapping(address => bool) tooks;\n', '    }\n', '\n', '    struct Settings {\n', '        address arbiter;\n', '        uint256 minValue;\n', '    }\n', '\n', '    event Made (\n', '        address indexed maker,\n', '        address indexed arbiter,\n', '        uint256 indexed envelopeId,\n', '        uint256 envelopeTypeId,\n', '        uint256 minValue,\n', '        uint256 total,\n', '        uint256 quantity,\n', '        uint256 willExpireAfter,\n', '        uint256 minedAt,\n', '        uint256 random\n', '    );\n', '\n', '    event Took (\n', '        address indexed taker,\n', '        uint256 indexed envelopeId,\n', '        uint256 value,\n', '        uint256 minedAt\n', '    );\n', '\n', '    event Redeemed(\n', '        address indexed maker,\n', '        uint256 indexed envelopeId,\n', '        uint256 value,\n', '        uint256 minedAt\n', '    );\n', '\n', '    Settings public settings;\n', '    address public owner;\n', '    uint256 public balanceOfEnvelopes;\n', '    \n', '    mapping (address => uint256) public envelopeCounts;\n', '    mapping (uint256 => EnvelopeType) public envelopeTypes;\n', '    mapping (uint256 => Envelope) public envelopes;\n', '\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function random() view private returns (uint256) {\n', '        // factor = ceil(2 ^ 256 / 100)\n', '        uint256 factor = 1157920892373161954235709850086879078532699846656405640394575840079131296399;\n', '        bytes32 blockHash = block.blockhash(block.number - 1);\n', '        return uint256(uint256(blockHash) / factor);\n', '    }\n', '\n', '    function RedEnvelope() public {\n', '        settings = Settings(\n', '            msg.sender,\n', '            2000000000000000 // minValue = 0.002 ETH\n', '        );\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setSettings(address _arbiter, uint256 _minValue) onlyOwner public {\n', '        settings.arbiter = _arbiter;\n', '        settings.minValue = _minValue;\n', '    }\n', '    \n', '    function setOwner(address _owner) onlyOwner public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function () payable public {}\n', '\n', '    /*\n', '     * uint256 _envelopeTypeId\n', '     * uint256[2] _data\n', '     *  [0] - maxNumber\n', '     *  [1] - feeRate\n', '     */\n', '    function setEnvelopeType(uint256 _envelopeTypeId, uint256[2] _data) onlyOwner public {\n', '        envelopeTypes[_envelopeTypeId].maxNumber = _data[0];\n', '        envelopeTypes[_envelopeTypeId].feeRate = _data[1];\n', '    }\n', '\n', '    /*\n', '     * uint256 _envelopeId\n', '     * uint256[3] _data\n', '     *  [0] - envelopeTypeId\n', '     *  [1] - quantity;\n', '     *  [2] - willExpireIn;\n', '     *  [3] - random\n', '     */\n', '    function make(uint256 _envelopeId, uint256[4] _data) payable external {\n', '        uint256 count = envelopeCounts[msg.sender] + 1;\n', '        if (uint256(keccak256(msg.sender, count)) != _envelopeId) { // 错误的envelopeId\n', '            revert();\n', '        }\n', '        EnvelopeType memory envelopeType = envelopeTypes[_data[0]];\n', '        if (envelopeType.maxNumber < _data[1]) { // quantity过大\n', '            revert();\n', '        }\n', '        uint256 total = ( msg.value * 1000 ) / ( envelopeType.feeRate + 1000 );\n', '        if (total / _data[1] < settings.minValue) { // value过小\n', '            revert();\n', '        }\n', '        Envelope memory envelope = Envelope(\n', '            msg.sender,                     // maker\n', '            settings.arbiter,               // arbiter\n', '            _data[0],                       // envelopeTypeId\n', '            settings.minValue,              // minValue\n', '            total,                          // remainingValue\n', '            _data[1],                       // remainingNumber\n', '            block.timestamp + _data[2],     // willExpireAfter\n', '            _data[3] > 0                    // random\n', '        );\n', '        \n', '        envelopes[_envelopeId] = envelope;\n', '        balanceOfEnvelopes += total;\n', '        envelopeCounts[msg.sender] = count;\n', '\n', '        Made(\n', '            envelope.maker,\n', '            envelope.arbiter,\n', '            _envelopeId,\n', '            envelope.envelopeTypeId,\n', '            envelope.minValue,\n', '            envelope.remainingValue,\n', '            envelope.remainingNumber,\n', '            envelope.willExpireAfter,\n', '            block.timestamp,\n', '            envelope.random ? 1 : 0\n', '        );\n', '    }\n', '\n', '    /*\n', '     * uint256 _envelopeId\n', '     * uint256[4] _data\n', '     *  [0] - willExpireAfter\n', '     *  [1] - v\n', '     *  [2] - r\n', '     *  [3] - s\n', '     */\n', '    function take(uint256 _envelopeId, uint256[4] _data) external {\n', '        // 验证红包\n', '        Envelope storage envelope = envelopes[_envelopeId];\n', '        if (envelope.willExpireAfter < block.timestamp) { // 红包过期\n', '            revert();\n', '        }\n', '        if (envelope.remainingNumber == 0) { // 抢完了\n', '            revert();\n', '        }\n', '        if (envelope.tooks[msg.sender]) { // 抢过了\n', '            revert();\n', '        }\n', '        // 验证arbiter的签名\n', '        if (_data[0] < block.timestamp) { // 签名过期\n', '            revert();\n', '        }\n', '        if (envelope.arbiter != ecrecover(keccak256(_envelopeId, _data[0], msg.sender), uint8(_data[1]), bytes32(_data[2]), bytes32(_data[3]))) { // 签名错误\n', '            revert();\n', '        }\n', '        \n', '        uint256 value = 0;\n', '        if (!envelope.random) {\n', '            value = envelope.remainingValue / envelope.remainingNumber;\n', '        } else {\n', '            if (envelope.remainingNumber == 1) {\n', '                value = envelope.remainingValue;\n', '            } else {\n', '                uint256 maxValue = envelope.remainingValue - (envelope.remainingNumber - 1) * envelope.minValue;\n', '                uint256 avgValue = envelope.remainingValue / envelope.remainingNumber * 2;\n', '                value = avgValue < maxValue ? avgValue * random() / 100 : maxValue * random() / 100;\n', '                value = value < envelope.minValue ? envelope.minValue : value;\n', '            }\n', '        }\n', '\n', '        envelope.remainingValue -= value;\n', '        envelope.remainingNumber -= 1;\n', '        envelope.tooks[msg.sender] = true;\n', '        balanceOfEnvelopes -= value;\n', '        msg.sender.transfer(value);\n', '\n', '        Took(\n', '            msg.sender,\n', '            _envelopeId,\n', '            value,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /*\n', '     * uint256 _envelopeId\n', '     */\n', '    function redeem(uint256 _envelopeId) external {\n', '        Envelope storage envelope = envelopes[_envelopeId];\n', '        if (envelope.willExpireAfter >= block.timestamp) { // 尚未失效\n', '            revert();\n', '        }\n', '        if (envelope.remainingValue == 0) { // 没钱\n', '            revert();\n', '        }\n', '        if (envelope.maker != msg.sender) { // 不是maker\n', '            revert();\n', '        }\n', '\n', '        uint256 value = envelope.remainingValue;\n', '        envelope.remainingValue = 0;\n', '        envelope.remainingNumber = 0;\n', '        balanceOfEnvelopes -= value;\n', '        msg.sender.transfer(value);\n', '\n', '        Redeemed(\n', '            msg.sender,\n', '            _envelopeId,\n', '            value,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function getPaid(uint256 amount) onlyOwner external {\n', '        uint256 maxAmount = this.balance - balanceOfEnvelopes;\n', '        msg.sender.transfer(amount < maxAmount ? amount : maxAmount);\n', '    }\n', '\n', '    function sayGoodBye() onlyOwner external {\n', '        selfdestruct(msg.sender);\n', '    }\n', '}']