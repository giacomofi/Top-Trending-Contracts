['pragma solidity 0.4.24;\n', 'contract Owned {\n', '    /* Variables */\n', '    address public owner = msg.sender;\n', '    /* Constructor */\n', '    constructor(address _owner) public {\n', '        if ( _owner == 0x00 ) {\n', '            _owner = msg.sender;\n', '        }\n', '        owner = _owner;\n', '    }\n', '    /* Externals */\n', '    function replaceOwner(address _owner) external returns(bool) {\n', '        require( isOwner() );\n', '        owner = _owner;\n', '        return true;\n', '    }\n', '    /* Internals */\n', '    function isOwner() internal view returns(bool) {\n', '        return owner == msg.sender;\n', '    }\n', '    /* Modifiers */\n', '    modifier forOwner {\n', '        require( isOwner() );\n', '        _;\n', '    }\n', '}\n', 'library SafeMath {\n', '    /* Internals */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a + b;\n', '        assert( c >= a );\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a - b;\n', '        assert( c <= a );\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a * b;\n', '        assert( c == 0 || c / a == b );\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a / b;\n', '    }\n', '    function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a ** b;\n', '        assert( c % a == 0 );\n', '        return a ** b;\n', '    }\n', '}\n', 'contract TokenDB is Owned {\n', '    /* Declarations */\n', '    using SafeMath for uint256;\n', '    /* Structures */\n', '    struct balances_s {\n', '        uint256 amount;\n', '        bool valid;\n', '    }\n', '    /* Variables */\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => balances_s) public balances;\n', '    address public tokenAddress;\n', '    address public oldDBAddress;\n', '    /* Constructor */\n', '    constructor(address _owner, address _tokenAddress, address _icoAddress, address _oldDBAddress) Owned(_owner) public {\n', '        if ( _oldDBAddress == 0x00  && _icoAddress != 0x00 ) {\n', '            balances[_icoAddress].amount = 44e16;\n', '        }\n', '        oldDBAddress = _oldDBAddress;\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '    /* Externals */\n', '    function changeTokenAddress(address _tokenAddress) external forOwner {\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '    function transfer(address _from, address _to, uint256 _amount) external forToken returns(bool _success) {\n', '        uint256 _senderBalance = _getBalance(_from);\n', '        uint256 _receiverBalance = _getBalance(_to);\n', '        balances[_from].amount = _senderBalance.sub(_amount);\n', '        balances[_to].amount = _receiverBalance.add(_amount);\n', '        return true;\n', '    }\n', '    function bulkTransfer(address _from, address[] _to, uint256[] _amount) external forToken returns(bool _success) {\n', '        uint256 _senderBalance = _getBalance(_from);\n', '        uint256 _receiverBalance;\n', '        uint256 i;\n', '        for ( i=0 ; i<_to.length ; i++ ) {\n', '            _receiverBalance = _getBalance(_to[i]);\n', '            _senderBalance = _senderBalance.sub(_amount[i]);\n', '            balances[_to[i]].amount = _receiverBalance.add(_amount[i]);\n', '        }\n', '        balances[_from].amount = _senderBalance;\n', '        return true;\n', '    }\n', '    function setAllowance(address _owner, address _spender, uint256 _amount) external forToken returns(bool _success) {\n', '        allowance[_owner][_spender] = _amount;\n', '        return true;\n', '    }\n', '    /* Constants */\n', '    function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {\n', '        return ( true, allowance[_owner][_spender] );\n', '    }\n', '    function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {\n', '        return ( true, _getBalance(_owner) );\n', '    }\n', '    /* Internals */\n', '    function _getBalance(address _owner) internal returns(uint256 _balance) {\n', '        if ( ( ! balances[_owner].valid ) && oldDBAddress != 0x00 ) {\n', '            bool _subResult;\n', '            ( _subResult, _balance ) = TokenDB(oldDBAddress).balanceOf(_owner);\n', '            balances[_owner].amount = _balance;\n', '            balances[_owner].valid = true;\n', '        }\n', '        return balances[_owner].amount;\n', '    }\n', '    /* Modifiers */\n', '    modifier forToken {\n', '        require( msg.sender == tokenAddress );\n', '        _;\n', '    }\n', '}']