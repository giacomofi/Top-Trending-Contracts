['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract ERC20 {\n', '  // We want to be able to recover & donate any tokens sent to the contract.\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', 'contract theCyberInterface {\n', '  // The utility contract can call the following methods of theCyber.\n', '  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public;\n', '  function proclaimInactive(uint8 _memberId) public;\n', '  function heartbeat() public;\n', '  function revokeMembership(uint8 _memberId) public;\n', '  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId);\n', '  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress);\n', '  function maxMembers() public pure returns(uint16);\n', '  function inactivityTimeout() public pure returns(uint64);\n', '  function donationAddress() public pure returns(address);\n', '}\n', '\n', '\n', 'contract theCyberMemberUtilities {\n', '  // This contract provides a set of helper functions that members of theCyber\n', '  // may call in order to perform more advanced operations. In order to interact\n', '  // with theCyber, the contract must first be assigned as a member.\n', '\n', '  event MembershipStatusSet(bool isMember, uint8 memberId);\n', '  event FundsDonated(uint256 value);\n', '  event TokensDonated(address tokenContractAddress, uint256 value);\n', '\n', '  // Set the address and interface of theCyber.\n', '  address private constant THECYBERADDRESS_ = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;\n', '  theCyberInterface theCyber = theCyberInterface(THECYBERADDRESS_);\n', '\n', '  // Set up variables for checking the contract&#39;s membership status.\n', '  bool private isMember_;\n', '  uint8 private memberId_;\n', '\n', '  // The max members, inactivity timeout, and the donation address are pulled\n', '  // from theCyber inside the constructor function.\n', '  uint16 private maxMembers_;\n', '  uint64 private inactivityTimeout_;\n', '  address private donationAddress_;\n', '\n', '  // Batch operations on all members utilize incrementing member ids.\n', '  uint8 private nextInactiveMemberIndex_;\n', '  uint8 private nextRevokedMemberIndex_;\n', '\n', '  // Methods of the utility contract can only be called by a valid member.\n', '  modifier membersOnly() {\n', '    // Only allow transactions originating from a valid member address.\n', '    bool member;\n', '    (member,) = theCyber.getMembershipStatus(msg.sender);\n', '    require(member);\n', '    _;\n', '  }\n', '\n', '  // In the constructor function, set up the max members, the inactivity\n', '  // timeout, and the donation address.\n', '  function theCyberMemberUtilities() public {\n', '    // Set the maximum number of members.\n', '    maxMembers_ = theCyber.maxMembers();\n', '\n', '    // Set the inactivity timeout.\n', '    inactivityTimeout_ = theCyber.inactivityTimeout();\n', '\n', '    // Set the donation address.\n', '    donationAddress_ = theCyber.donationAddress();\n', '\n', '    // Set the initial membership status to false.\n', '    isMember_ = false;\n', '\n', '    // Start the inactive member index at 0.\n', '    nextInactiveMemberIndex_ = 0;\n', '\n', '    // Start the revoked member index at 0.\n', '    nextRevokedMemberIndex_ = 0;\n', '  }\n', '\n', '  // Set the member id of the utility contract prior to calling batch methods.\n', '  function setMembershipStatus() public membersOnly {\n', '    // Set the membership status and member id of the utility contract.\n', '    (isMember_,memberId_) = theCyber.getMembershipStatus(this);\n', '\n', '    // Log the membership status of the utility contract.\n', '    MembershipStatusSet(isMember_, memberId_);\n', '  }\n', '\n', '  // The utility contract must be able to heartbeat if it is marked as inactive.\n', '  function heartbeat() public membersOnly {\n', '    // Heartbeat the utility contract.\n', '    theCyber.heartbeat();\n', '  }\n', '\n', '  // Revoke a membership and immediately assign the membership to a new member.\n', '  function revokeAndSetNewMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\n', '    // Revoke the membership (provided it has been inactive for long enough).\n', '    theCyber.revokeMembership(_memberId);\n', '\n', '    // Assign a new member to the membership (provided the new member is valid).\n', '    theCyber.newMember(_memberId, _memberName, _memberAddress);\n', '  }\n', '\n', '  // Mark all members (except this contract & msg.sender) as inactive.\n', '  function proclaimAllInactive() public membersOnly returns (bool complete) {\n', '    // The utility contract must be a member (and therefore have a member id).\n', '    require(isMember_);\n', '\n', '    // Get the memberId of the calling member.\n', '    uint8 callingMemberId;\n', '    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Initialize variables for checking the status of each membership.\n', '    uint64 inactiveSince;\n', '    address memberAddress;\n', '    \n', '    // Pick up where the function last left off in assigning new members.\n', '    uint8 i = nextInactiveMemberIndex_;\n', '\n', '    // make sure that the loop triggers at least once.\n', '    require(msg.gas > 175000);\n', '\n', '    // Loop through members as long as sufficient gas remains.\n', '    while (msg.gas > 170000) {\n', '      // Make sure that the target membership is owned and active.\n', '      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\n', '      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince == 0)) {\n', '        // Mark the member as inactive.\n', '        theCyber.proclaimInactive(i);\n', '      }\n', '      // Increment the index to point to the next member id.\n', '      i++;\n', '\n', '      // exit once the index overflows.\n', '      if (i == 0) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Set the index where the function left off.\n', '    nextInactiveMemberIndex_ = i;\n', '    return (i == 0);\n', '  }\n', '\n', '  // Allow members to circumvent the safety measure against self-inactivation.\n', '  function inactivateSelf() public membersOnly {\n', '    // Get the memberId of the calling member.\n', '    uint8 memberId;\n', '    (,memberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Inactivate the membership (provided it is not already marked inactive).\n', '    theCyber.proclaimInactive(memberId);\n', '  }\n', '\n', '  // Revoke all memberships (except those of the utility contract & msg.sender)\n', '  // that have been inactive for longer than the inactivity timeout.\n', '  function revokeAllVulnerable() public membersOnly returns (bool complete) {\n', '    // The utility contract must be a member (and therefore have a member id).\n', '    require(isMember_);\n', '\n', '    // Get the memberId of the calling member.\n', '    uint8 callingMemberId;\n', '    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Initialize variables for checking the status of each membership.\n', '    uint64 inactiveSince;\n', '    address memberAddress;\n', '    \n', '    // Pick up where the function last left off in assigning new members.\n', '    uint8 i = nextRevokedMemberIndex_;\n', '\n', '    // make sure that the loop triggers at least once.\n', '    require(msg.gas > 175000);\n', '\n', '    // Loop through members as long as sufficient gas remains.\n', '    while (msg.gas > 175000) {\n', '      // Make sure that the target membership is owned and inactive long enough.\n', '      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\n', '      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince != 0) && (now >= inactiveSince + inactivityTimeout_)) {\n', '        // Revoke the member.\n', '        theCyber.revokeMembership(i);\n', '      }\n', '      // Increment the index to point to the next member id.\n', '      i++;\n', '\n', '      // exit once the index overflows.\n', '      if (i == 0) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Set the index where the function left off.\n', '    nextRevokedMemberIndex_ = i;\n', '    return (i == 0);\n', '  }\n', '\n', '  // Allow members to circumvent the safety measure against self-revokation.\n', '  function revokeSelf() public membersOnly {\n', '    // Get the memberId of the calling member.\n', '    uint8 memberId;\n', '    (,memberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Revoke the membership (provided it has been inactive for long enough).\n', '    theCyber.revokeMembership(memberId);\n', '  }\n', '\n', '  // The contract is not payable by design, but could end up with a balance as\n', '  // a recipient of a selfdestruct / coinbase of a mined block.\n', '  function donateFunds() public membersOnly {\n', '    // Log the donation of any funds that have made their way into the contract.\n', '    FundsDonated(this.balance);\n', '\n', '    // Send all available funds to the donation address.\n', '    donationAddress_.transfer(this.balance);\n', '  }\n', '\n', '  // We also want to be able to access any tokens that are sent to the contract.\n', '  function donateTokens(address _tokenContractAddress) public membersOnly {\n', '    // Make sure that we didn&#39;t pass in the current contract address by mistake.\n', '    require(_tokenContractAddress != address(this));\n', '\n', '    // Log the donation of any tokens that have been sent into the contract.\n', '    TokensDonated(_tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\n', '\n', '    // Send all available tokens at the given contract to the donation address.\n', '    ERC20(_tokenContractAddress).transfer(donationAddress_, ERC20(_tokenContractAddress).balanceOf(this));\n', '  }\n', '\n', '  // The donation address for lost ether / ERC20 tokens should match theCyber&#39;s.\n', '  function donationAddress() public view returns(address) {\n', '    return donationAddress_;\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract ERC20 {\n', '  // We want to be able to recover & donate any tokens sent to the contract.\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', 'contract theCyberInterface {\n', '  // The utility contract can call the following methods of theCyber.\n', '  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public;\n', '  function proclaimInactive(uint8 _memberId) public;\n', '  function heartbeat() public;\n', '  function revokeMembership(uint8 _memberId) public;\n', '  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId);\n', '  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress);\n', '  function maxMembers() public pure returns(uint16);\n', '  function inactivityTimeout() public pure returns(uint64);\n', '  function donationAddress() public pure returns(address);\n', '}\n', '\n', '\n', 'contract theCyberMemberUtilities {\n', '  // This contract provides a set of helper functions that members of theCyber\n', '  // may call in order to perform more advanced operations. In order to interact\n', '  // with theCyber, the contract must first be assigned as a member.\n', '\n', '  event MembershipStatusSet(bool isMember, uint8 memberId);\n', '  event FundsDonated(uint256 value);\n', '  event TokensDonated(address tokenContractAddress, uint256 value);\n', '\n', '  // Set the address and interface of theCyber.\n', '  address private constant THECYBERADDRESS_ = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;\n', '  theCyberInterface theCyber = theCyberInterface(THECYBERADDRESS_);\n', '\n', "  // Set up variables for checking the contract's membership status.\n", '  bool private isMember_;\n', '  uint8 private memberId_;\n', '\n', '  // The max members, inactivity timeout, and the donation address are pulled\n', '  // from theCyber inside the constructor function.\n', '  uint16 private maxMembers_;\n', '  uint64 private inactivityTimeout_;\n', '  address private donationAddress_;\n', '\n', '  // Batch operations on all members utilize incrementing member ids.\n', '  uint8 private nextInactiveMemberIndex_;\n', '  uint8 private nextRevokedMemberIndex_;\n', '\n', '  // Methods of the utility contract can only be called by a valid member.\n', '  modifier membersOnly() {\n', '    // Only allow transactions originating from a valid member address.\n', '    bool member;\n', '    (member,) = theCyber.getMembershipStatus(msg.sender);\n', '    require(member);\n', '    _;\n', '  }\n', '\n', '  // In the constructor function, set up the max members, the inactivity\n', '  // timeout, and the donation address.\n', '  function theCyberMemberUtilities() public {\n', '    // Set the maximum number of members.\n', '    maxMembers_ = theCyber.maxMembers();\n', '\n', '    // Set the inactivity timeout.\n', '    inactivityTimeout_ = theCyber.inactivityTimeout();\n', '\n', '    // Set the donation address.\n', '    donationAddress_ = theCyber.donationAddress();\n', '\n', '    // Set the initial membership status to false.\n', '    isMember_ = false;\n', '\n', '    // Start the inactive member index at 0.\n', '    nextInactiveMemberIndex_ = 0;\n', '\n', '    // Start the revoked member index at 0.\n', '    nextRevokedMemberIndex_ = 0;\n', '  }\n', '\n', '  // Set the member id of the utility contract prior to calling batch methods.\n', '  function setMembershipStatus() public membersOnly {\n', '    // Set the membership status and member id of the utility contract.\n', '    (isMember_,memberId_) = theCyber.getMembershipStatus(this);\n', '\n', '    // Log the membership status of the utility contract.\n', '    MembershipStatusSet(isMember_, memberId_);\n', '  }\n', '\n', '  // The utility contract must be able to heartbeat if it is marked as inactive.\n', '  function heartbeat() public membersOnly {\n', '    // Heartbeat the utility contract.\n', '    theCyber.heartbeat();\n', '  }\n', '\n', '  // Revoke a membership and immediately assign the membership to a new member.\n', '  function revokeAndSetNewMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\n', '    // Revoke the membership (provided it has been inactive for long enough).\n', '    theCyber.revokeMembership(_memberId);\n', '\n', '    // Assign a new member to the membership (provided the new member is valid).\n', '    theCyber.newMember(_memberId, _memberName, _memberAddress);\n', '  }\n', '\n', '  // Mark all members (except this contract & msg.sender) as inactive.\n', '  function proclaimAllInactive() public membersOnly returns (bool complete) {\n', '    // The utility contract must be a member (and therefore have a member id).\n', '    require(isMember_);\n', '\n', '    // Get the memberId of the calling member.\n', '    uint8 callingMemberId;\n', '    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Initialize variables for checking the status of each membership.\n', '    uint64 inactiveSince;\n', '    address memberAddress;\n', '    \n', '    // Pick up where the function last left off in assigning new members.\n', '    uint8 i = nextInactiveMemberIndex_;\n', '\n', '    // make sure that the loop triggers at least once.\n', '    require(msg.gas > 175000);\n', '\n', '    // Loop through members as long as sufficient gas remains.\n', '    while (msg.gas > 170000) {\n', '      // Make sure that the target membership is owned and active.\n', '      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\n', '      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince == 0)) {\n', '        // Mark the member as inactive.\n', '        theCyber.proclaimInactive(i);\n', '      }\n', '      // Increment the index to point to the next member id.\n', '      i++;\n', '\n', '      // exit once the index overflows.\n', '      if (i == 0) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Set the index where the function left off.\n', '    nextInactiveMemberIndex_ = i;\n', '    return (i == 0);\n', '  }\n', '\n', '  // Allow members to circumvent the safety measure against self-inactivation.\n', '  function inactivateSelf() public membersOnly {\n', '    // Get the memberId of the calling member.\n', '    uint8 memberId;\n', '    (,memberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Inactivate the membership (provided it is not already marked inactive).\n', '    theCyber.proclaimInactive(memberId);\n', '  }\n', '\n', '  // Revoke all memberships (except those of the utility contract & msg.sender)\n', '  // that have been inactive for longer than the inactivity timeout.\n', '  function revokeAllVulnerable() public membersOnly returns (bool complete) {\n', '    // The utility contract must be a member (and therefore have a member id).\n', '    require(isMember_);\n', '\n', '    // Get the memberId of the calling member.\n', '    uint8 callingMemberId;\n', '    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Initialize variables for checking the status of each membership.\n', '    uint64 inactiveSince;\n', '    address memberAddress;\n', '    \n', '    // Pick up where the function last left off in assigning new members.\n', '    uint8 i = nextRevokedMemberIndex_;\n', '\n', '    // make sure that the loop triggers at least once.\n', '    require(msg.gas > 175000);\n', '\n', '    // Loop through members as long as sufficient gas remains.\n', '    while (msg.gas > 175000) {\n', '      // Make sure that the target membership is owned and inactive long enough.\n', '      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\n', '      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince != 0) && (now >= inactiveSince + inactivityTimeout_)) {\n', '        // Revoke the member.\n', '        theCyber.revokeMembership(i);\n', '      }\n', '      // Increment the index to point to the next member id.\n', '      i++;\n', '\n', '      // exit once the index overflows.\n', '      if (i == 0) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Set the index where the function left off.\n', '    nextRevokedMemberIndex_ = i;\n', '    return (i == 0);\n', '  }\n', '\n', '  // Allow members to circumvent the safety measure against self-revokation.\n', '  function revokeSelf() public membersOnly {\n', '    // Get the memberId of the calling member.\n', '    uint8 memberId;\n', '    (,memberId) = theCyber.getMembershipStatus(msg.sender);\n', '\n', '    // Revoke the membership (provided it has been inactive for long enough).\n', '    theCyber.revokeMembership(memberId);\n', '  }\n', '\n', '  // The contract is not payable by design, but could end up with a balance as\n', '  // a recipient of a selfdestruct / coinbase of a mined block.\n', '  function donateFunds() public membersOnly {\n', '    // Log the donation of any funds that have made their way into the contract.\n', '    FundsDonated(this.balance);\n', '\n', '    // Send all available funds to the donation address.\n', '    donationAddress_.transfer(this.balance);\n', '  }\n', '\n', '  // We also want to be able to access any tokens that are sent to the contract.\n', '  function donateTokens(address _tokenContractAddress) public membersOnly {\n', "    // Make sure that we didn't pass in the current contract address by mistake.\n", '    require(_tokenContractAddress != address(this));\n', '\n', '    // Log the donation of any tokens that have been sent into the contract.\n', '    TokensDonated(_tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\n', '\n', '    // Send all available tokens at the given contract to the donation address.\n', '    ERC20(_tokenContractAddress).transfer(donationAddress_, ERC20(_tokenContractAddress).balanceOf(this));\n', '  }\n', '\n', "  // The donation address for lost ether / ERC20 tokens should match theCyber's.\n", '  function donationAddress() public view returns(address) {\n', '    return donationAddress_;\n', '  }\n', '}']
