['pragma solidity ^0.4.25;\n', '\n', '\n', '/**\n', '* @title Contract that will work with ERC223 tokens.\n', '*/\n', '\n', 'contract ERC223ReceivingContract {\n', '  /**\n', '   * @dev Standard ERC223 function that will handle incoming token transfers.\n', '   *\n', '   * @param _from  Token sender address.\n', '   * @param _value Amount of tokens.\n', '   * @param _data  Transaction metadata.\n', '   */\n', '  function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', '    // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC223\n', ' * @dev Simpler version of ERC223\n', ' * See https://github.com/ethereum/EIPs/issues/223\n', ' * Recommended implementation of ERC 223: https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/ERC223_Token.sol\n', ' */\n', 'contract ERC223Burnable is BurnableToken {\n', '\n', '  //Extended transfer event\n', '  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '\n', '  /**\n', '    * @dev Transfer token for a specified address, ERC223\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '  */\n', '  // Standard function transfer similar to ERC20 transfer with no _data .\n', '  // Added due to backwards compatibility reasons .\n', '  function transfer(address _to, uint _value) public returns (bool) {\n', '\n', '    //standard function transfer similar to ERC20 transfer with no _data\n', '    //added due to backwards compatibility reasons\n', '    bytes memory empty;\n', '    if (isContract(_to)) {\n', '      return transferToContract(_to, _value, empty);\n', '    } else {\n', '      return transferToAddress(_to, _value, empty);\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address, ERC223\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  * @param _data User data.\n', '  */\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '\n', '    if (isContract(_to)) {\n', '      return transferToContract(_to, _value, _data);\n', '    } else {\n', '      return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint length;\n', '    assembly {\n', '    //retrieve the size of the code on target address, this needs assembly\n', '      length := extcodesize(_addr)\n', '    }\n', '    return (length > 0);\n', '  }\n', '\n', '  //function that is called when transaction target is an address\n', '  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function transferToContract(address _to, uint _value, bytes _data) private returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '    receiver.tokenFallback(msg.sender, _value, _data);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract UniGoldToken is ERC223Burnable {\n', '  address public minter;\n', '  string public name = "UniGoldCoin";\n', '  string public symbol = "UGCÐ¡";\n', '  uint8 public decimals = 4;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  /**\n', '   * @dev constructor sets the &#39;minter&#39;\n', '   * account.\n', '   */\n', '  constructor(address _minter) public {\n', '    minter = _minter;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the minter.\n', '   */\n', '  modifier onlyMinter() {\n', '    require(msg.sender == minter);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '\n', '/**\n', '* @title Contract that will work with ERC223 tokens.\n', '*/\n', '\n', 'contract ERC223ReceivingContract {\n', '  /**\n', '   * @dev Standard ERC223 function that will handle incoming token transfers.\n', '   *\n', '   * @param _from  Token sender address.\n', '   * @param _value Amount of tokens.\n', '   * @param _data  Transaction metadata.\n', '   */\n', '  function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC223\n', ' * @dev Simpler version of ERC223\n', ' * See https://github.com/ethereum/EIPs/issues/223\n', ' * Recommended implementation of ERC 223: https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/ERC223_Token.sol\n', ' */\n', 'contract ERC223Burnable is BurnableToken {\n', '\n', '  //Extended transfer event\n', '  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '\n', '  /**\n', '    * @dev Transfer token for a specified address, ERC223\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '  */\n', '  // Standard function transfer similar to ERC20 transfer with no _data .\n', '  // Added due to backwards compatibility reasons .\n', '  function transfer(address _to, uint _value) public returns (bool) {\n', '\n', '    //standard function transfer similar to ERC20 transfer with no _data\n', '    //added due to backwards compatibility reasons\n', '    bytes memory empty;\n', '    if (isContract(_to)) {\n', '      return transferToContract(_to, _value, empty);\n', '    } else {\n', '      return transferToAddress(_to, _value, empty);\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address, ERC223\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  * @param _data User data.\n', '  */\n', '  // Function that is called when a user or another contract wants to transfer funds .\n', '  function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '\n', '    if (isContract(_to)) {\n', '      return transferToContract(_to, _value, _data);\n', '    } else {\n', '      return transferToAddress(_to, _value, _data);\n', '    }\n', '  }\n', '\n', '  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint length;\n', '    assembly {\n', '    //retrieve the size of the code on target address, this needs assembly\n', '      length := extcodesize(_addr)\n', '    }\n', '    return (length > 0);\n', '  }\n', '\n', '  //function that is called when transaction target is an address\n', '  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  //function that is called when transaction target is a contract\n', '  function transferToContract(address _to, uint _value, bytes _data) private returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n', '    balances[_to] = balanceOf(_to).add(_value);\n', '    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '    receiver.tokenFallback(msg.sender, _value, _data);\n', '    emit Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', 'contract UniGoldToken is ERC223Burnable {\n', '  address public minter;\n', '  string public name = "UniGoldCoin";\n', '  string public symbol = "UGCÐ¡";\n', '  uint8 public decimals = 4;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  /**\n', "   * @dev constructor sets the 'minter'\n", '   * account.\n', '   */\n', '  constructor(address _minter) public {\n', '    minter = _minter;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the minter.\n', '   */\n', '  modifier onlyMinter() {\n', '    require(msg.sender == minter);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) public onlyMinter returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '}']
