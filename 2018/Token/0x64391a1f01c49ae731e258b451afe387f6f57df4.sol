['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// source : https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '\n', 'contract DCoin is ERC20Interface {\n', '  using SafeMath for uint;\n', '\n', '  // State variables\n', '  string public name = "D&#39;Coin";\n', '  string public symbol = &#39;DCO&#39;;\n', '  uint public decimals = 6;\n', '  address public owner;\n', '  uint public maxCoinCap = 200000000 * (10 ** 6);\n', '  uint public totalSupply;\n', '  bool public emergencyFreeze;\n', '  \n', '  // mappings\n', '  mapping (address => uint) balances;\n', '  mapping (address => mapping (address => uint) ) allowed;\n', '  mapping (address => bool) frozen;\n', '\n', '  // events\n', '  event Mint(address indexed _to, uint indexed _mintedAmount);\n', '  \n', '\n', '  // constructor\n', '  function DCoin () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  // events\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  event Burn(address indexed from, uint256 amount);\n', '  event Freezed(address targetAddress, bool frozen);\n', '  event EmerygencyFreezed(bool emergencyFreezeStatus);\n', '  \n', '\n', '\n', '  // Modifiers\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '     _;\n', '  }\n', '\n', '  modifier unfreezed(address _account) { \n', '    require(!frozen[_account]);\n', '    _;  \n', '  }\n', '  \n', '  modifier noEmergencyFreeze() { \n', '    require(!emergencyFreeze);\n', '    _; \n', '  }\n', '  \n', '\n', '\n', '  // functions\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Transfer Token\n', '  // ------------------------------------------------------------------------\n', '  function transfer(address _to, uint _value) unfreezed(_to) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require(_to != 0x0);\n', '    require(balances[msg.sender] >= _value); \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Mint Token (Uncapped Minting)\n', '  // ------------------------------------------------------------------------\n', '  function mintToken (address _targetAddress, uint256 _mintedAmount) unfreezed(_targetAddress) noEmergencyFreeze() public onlyOwner returns(bool res) {\n', '    require(_targetAddress != 0x0); // use burn instead\n', '    require(_mintedAmount != 0);\n', '    require (totalSupply.add(_mintedAmount) <= maxCoinCap);\n', '    balances[_targetAddress] = balances[_targetAddress].add(_mintedAmount);\n', '    totalSupply = totalSupply.add(_mintedAmount);\n', '    emit Mint(_targetAddress, _mintedAmount);\n', '    emit Transfer(address(0), _targetAddress, _mintedAmount);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Approve others to spend on your behalf\n', '  // ------------------------------------------------------------------------\n', '  /* \n', '    While changing approval, the allowed must be changed to 0 than then to updated value\n', '    The smart contract doesn&#39;t enforces this due to backward competibility but requires frontend to do the validations\n', '   */\n', '  function approve(address _spender, uint _value) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Approve and call : If approve returns true, it calls receiveApproval method of contract\n', '  // ------------------------------------------------------------------------\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)\n', '    {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Transferred approved amount from other&#39;s account\n', '  // ------------------------------------------------------------------------\n', '  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require (_value <= balances[_from]);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Burn (Destroy tokens)\n', '  // ------------------------------------------------------------------------\n', '  function burn(uint256 _value) unfreezed(msg.sender) public returns (bool success) {\n', '    require(balances[msg.sender] >= _value);\n', '    balances[msg.sender] -= _value;\n', '    totalSupply -= _value;\n', '    emit Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  //               ONLYOWNER METHODS                             \n', '  // ------------------------------------------------------------------------\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Transfer Ownership\n', '  // ------------------------------------------------------------------------\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    owner = _newOwner;\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Freeze account - onlyOwner\n', '  // ------------------------------------------------------------------------\n', '  function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {\n', '    require(_target != 0x0);\n', '    frozen[_target] = _freeze;\n', '    emit Freezed(_target, _freeze);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Emerygency freeze - onlyOwner\n', '  // ------------------------------------------------------------------------\n', '  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {\n', '    emergencyFreeze = _freeze;\n', '    emit EmerygencyFreezed(_freeze);\n', '    return true;\n', '  }\n', '  \n', '\n', '  // ------------------------------------------------------------------------\n', '  //               CONSTANT METHODS\n', '  // ------------------------------------------------------------------------\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Check Allowance : Constant\n', '  // ------------------------------------------------------------------------\n', '  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_tokenOwner][_spender];\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Check Balance : Constant\n', '  // ------------------------------------------------------------------------\n', '  function balanceOf(address _tokenOwner) public constant returns (uint balance) {\n', '    return balances[_tokenOwner];\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Total supply : Constant\n', '  // ------------------------------------------------------------------------\n', '  function totalSupply() public constant returns (uint) {\n', '    return totalSupply;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Get Freeze Status : Constant\n', '  // ------------------------------------------------------------------------\n', '  function isFreezed(address _targetAddress) public constant returns (bool) {\n', '    return frozen[_targetAddress]; \n', '  }\n', '\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Prevents contract from accepting ETH\n', '  // ------------------------------------------------------------------------\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Owner can transfer out any accidentally sent ERC20 tokens\n', '  // ------------------------------------------------------------------------\n', '  function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(_tokenAddress).transfer(owner, _value);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// source : https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', '\n', 'contract DCoin is ERC20Interface {\n', '  using SafeMath for uint;\n', '\n', '  // State variables\n', '  string public name = "D\'Coin";\n', "  string public symbol = 'DCO';\n", '  uint public decimals = 6;\n', '  address public owner;\n', '  uint public maxCoinCap = 200000000 * (10 ** 6);\n', '  uint public totalSupply;\n', '  bool public emergencyFreeze;\n', '  \n', '  // mappings\n', '  mapping (address => uint) balances;\n', '  mapping (address => mapping (address => uint) ) allowed;\n', '  mapping (address => bool) frozen;\n', '\n', '  // events\n', '  event Mint(address indexed _to, uint indexed _mintedAmount);\n', '  \n', '\n', '  // constructor\n', '  function DCoin () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  // events\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  event Burn(address indexed from, uint256 amount);\n', '  event Freezed(address targetAddress, bool frozen);\n', '  event EmerygencyFreezed(bool emergencyFreezeStatus);\n', '  \n', '\n', '\n', '  // Modifiers\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '     _;\n', '  }\n', '\n', '  modifier unfreezed(address _account) { \n', '    require(!frozen[_account]);\n', '    _;  \n', '  }\n', '  \n', '  modifier noEmergencyFreeze() { \n', '    require(!emergencyFreeze);\n', '    _; \n', '  }\n', '  \n', '\n', '\n', '  // functions\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Transfer Token\n', '  // ------------------------------------------------------------------------\n', '  function transfer(address _to, uint _value) unfreezed(_to) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require(_to != 0x0);\n', '    require(balances[msg.sender] >= _value); \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Mint Token (Uncapped Minting)\n', '  // ------------------------------------------------------------------------\n', '  function mintToken (address _targetAddress, uint256 _mintedAmount) unfreezed(_targetAddress) noEmergencyFreeze() public onlyOwner returns(bool res) {\n', '    require(_targetAddress != 0x0); // use burn instead\n', '    require(_mintedAmount != 0);\n', '    require (totalSupply.add(_mintedAmount) <= maxCoinCap);\n', '    balances[_targetAddress] = balances[_targetAddress].add(_mintedAmount);\n', '    totalSupply = totalSupply.add(_mintedAmount);\n', '    emit Mint(_targetAddress, _mintedAmount);\n', '    emit Transfer(address(0), _targetAddress, _mintedAmount);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Approve others to spend on your behalf\n', '  // ------------------------------------------------------------------------\n', '  /* \n', '    While changing approval, the allowed must be changed to 0 than then to updated value\n', "    The smart contract doesn't enforces this due to backward competibility but requires frontend to do the validations\n", '   */\n', '  function approve(address _spender, uint _value) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Approve and call : If approve returns true, it calls receiveApproval method of contract\n', '  // ------------------------------------------------------------------------\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)\n', '    {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '  // ------------------------------------------------------------------------\n', "  // Transferred approved amount from other's account\n", '  // ------------------------------------------------------------------------\n', '  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require (_value <= balances[_from]);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Burn (Destroy tokens)\n', '  // ------------------------------------------------------------------------\n', '  function burn(uint256 _value) unfreezed(msg.sender) public returns (bool success) {\n', '    require(balances[msg.sender] >= _value);\n', '    balances[msg.sender] -= _value;\n', '    totalSupply -= _value;\n', '    emit Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  //               ONLYOWNER METHODS                             \n', '  // ------------------------------------------------------------------------\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Transfer Ownership\n', '  // ------------------------------------------------------------------------\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    owner = _newOwner;\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Freeze account - onlyOwner\n', '  // ------------------------------------------------------------------------\n', '  function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {\n', '    require(_target != 0x0);\n', '    frozen[_target] = _freeze;\n', '    emit Freezed(_target, _freeze);\n', '    return true;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Emerygency freeze - onlyOwner\n', '  // ------------------------------------------------------------------------\n', '  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {\n', '    emergencyFreeze = _freeze;\n', '    emit EmerygencyFreezed(_freeze);\n', '    return true;\n', '  }\n', '  \n', '\n', '  // ------------------------------------------------------------------------\n', '  //               CONSTANT METHODS\n', '  // ------------------------------------------------------------------------\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Check Allowance : Constant\n', '  // ------------------------------------------------------------------------\n', '  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_tokenOwner][_spender];\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Check Balance : Constant\n', '  // ------------------------------------------------------------------------\n', '  function balanceOf(address _tokenOwner) public constant returns (uint balance) {\n', '    return balances[_tokenOwner];\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Total supply : Constant\n', '  // ------------------------------------------------------------------------\n', '  function totalSupply() public constant returns (uint) {\n', '    return totalSupply;\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Get Freeze Status : Constant\n', '  // ------------------------------------------------------------------------\n', '  function isFreezed(address _targetAddress) public constant returns (bool) {\n', '    return frozen[_targetAddress]; \n', '  }\n', '\n', '\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Prevents contract from accepting ETH\n', '  // ------------------------------------------------------------------------\n', '  function () public payable {\n', '    revert();\n', '  }\n', '\n', '  // ------------------------------------------------------------------------\n', '  // Owner can transfer out any accidentally sent ERC20 tokens\n', '  // ------------------------------------------------------------------------\n', '  function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {\n', '      return ERC20Interface(_tokenAddress).transfer(owner, _value);\n', '  }\n', '}']
