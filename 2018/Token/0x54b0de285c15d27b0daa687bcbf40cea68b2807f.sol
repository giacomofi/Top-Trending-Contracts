['pragma solidity ^0.4.21;\n', '\n', 'interface VaultInterface {\n', '\n', '    event Deposited(address indexed user, address token, uint amount);\n', '    event Withdrawn(address indexed user, address token, uint amount);\n', '\n', '    event Approved(address indexed user, address indexed spender);\n', '    event Unapproved(address indexed user, address indexed spender);\n', '\n', '    event AddedSpender(address indexed spender);\n', '    event RemovedSpender(address indexed spender);\n', '\n', '    function deposit(address token, uint amount) external payable;\n', '    function withdraw(address token, uint amount) external;\n', '    function transfer(address token, address from, address to, uint amount) external;\n', '    function approve(address spender) external;\n', '    function unapprove(address spender) external;\n', '    function isApproved(address user, address spender) external view returns (bool);\n', '    function addSpender(address spender) external;\n', '    function removeSpender(address spender) external;\n', '    function latestSpender() external view returns (address);\n', '    function isSpender(address spender) external view returns (bool);\n', '    function tokenFallback(address from, uint value, bytes data) public;\n', '    function balanceOf(address token, address user) public view returns (uint);\n', '\n', '}\n', '\n', 'interface ERC820 {\n', '\n', '    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return owner == _address;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '\n', '}\n', '\n', 'interface ERC777 {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function totalSupply() public constant returns (uint256);\n', '    function granularity() public constant returns (uint256);\n', '    function balanceOf(address owner) public constant returns (uint256);\n', '\n', '    function send(address to, uint256 amount) public;\n', '    function send(address to, uint256 amount, bytes userData) public;\n', '\n', '    function authorizeOperator(address operator) public;\n', '    function revokeOperator(address operator) public;\n', '    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n', '    function operatorSend(address from, address to, uint256 amount, bytes userData, bytes operatorData) public;\n', '\n', '}\n', '\n', 'contract Vault is Ownable, VaultInterface {\n', '\n', '    using SafeMath for *;\n', '\n', '    address constant public ETH = 0x0;\n', '\n', '    mapping (address => bool) public isERC777;\n', '\n', '    // user => spender => approved\n', '    mapping (address => mapping (address => bool)) private approved;\n', '    mapping (address => mapping (address => uint)) private balances;\n', '    mapping (address => uint) private accounted;\n', '    mapping (address => bool) private spenders;\n', '\n', '    address private latest;\n', '\n', '    modifier onlySpender {\n', '        require(spenders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyApproved(address user) {\n', '        require(approved[user][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function Vault(ERC820 registry) public {\n', '        // required by ERC777 standard.\n', '        registry.setInterfaceImplementer(address(this), keccak256("ERC777TokensRecipient"), address(this));\n', '    }\n', '\n', '    /// @dev Deposits a specific token.\n', '    /// @param token Address of the token to deposit.\n', '    /// @param amount Amount of tokens to deposit.\n', '    function deposit(address token, uint amount) external payable {\n', '        require(token == ETH || msg.value == 0);\n', '\n', '        uint value = amount;\n', '        if (token == ETH) {\n', '            value = msg.value;\n', '        } else {\n', '            require(ERC20(token).transferFrom(msg.sender, address(this), value));\n', '        }\n', '\n', '        depositFor(msg.sender, token, value);\n', '    }\n', '\n', '    /// @dev Withdraws a specific token.\n', '    /// @param token Address of the token to withdraw.\n', '    /// @param amount Amount of tokens to withdraw.\n', '    function withdraw(address token, uint amount) external {\n', '        require(balanceOf(token, msg.sender) >= amount);\n', '\n', '        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\n', '        accounted[token] = accounted[token].sub(amount);\n', '\n', '        withdrawTo(msg.sender, token, amount);\n', '\n', '        emit Withdrawn(msg.sender, token, amount);\n', '    }\n', '\n', '    /// @dev Approves an spender to trade balances of the sender.\n', '    /// @param spender Address of the spender to approve.\n', '    function approve(address spender) external {\n', '        require(spenders[spender]);\n', '        approved[msg.sender][spender] = true;\n', '        emit Approved(msg.sender, spender);\n', '    }\n', '\n', '    /// @dev Unapproves an spender to trade balances of the sender.\n', '    /// @param spender Address of the spender to unapprove.\n', '    function unapprove(address spender) external {\n', '        approved[msg.sender][spender] = false;\n', '        emit Unapproved(msg.sender, spender);\n', '    }\n', '\n', '    /// @dev Adds a spender.\n', '    /// @param spender Address of the spender.\n', '    function addSpender(address spender) external onlyOwner {\n', '        require(spender != 0x0);\n', '        spenders[spender] = true;\n', '        latest = spender;\n', '        emit AddedSpender(spender);\n', '    }\n', '\n', '    /// @dev Removes a spender.\n', '    /// @param spender Address of the spender.\n', '    function removeSpender(address spender) external onlyOwner {\n', '        spenders[spender] = false;\n', '        emit RemovedSpender(spender);\n', '    }\n', '\n', '    /// @dev Transfers balances of a token between users.\n', '    /// @param token Address of the token to transfer.\n', '    /// @param from Address of the user to transfer tokens from.\n', '    /// @param to Address of the user to transfer tokens to.\n', '    /// @param amount Amount of tokens to transfer.\n', '    function transfer(address token, address from, address to, uint amount) external onlySpender onlyApproved(from) {\n', '        // We do not check the balance here, as SafeMath will revert if sub / add fail. Due to over/underflows.\n', '        require(amount > 0);\n', '        balances[token][from] = balances[token][from].sub(amount);\n', '        balances[token][to] = balances[token][to].add(amount);\n', '    }\n', '\n', '    /// @dev Returns if an spender has been approved by a user.\n', '    /// @param user Address of the user.\n', '    /// @param spender Address of the spender.\n', '    /// @return Boolean whether spender has been approved.\n', '    function isApproved(address user, address spender) external view returns (bool) {\n', '        return approved[user][spender];\n', '    }\n', '\n', '    /// @dev Returns if an address has been approved as a spender.\n', '    /// @param spender Address of the spender.\n', '    /// @return Boolean whether spender has been approved.\n', '    function isSpender(address spender) external view returns (bool) {\n', '        return spenders[spender];\n', '    }\n', '\n', '    function latestSpender() external view returns (address) {\n', '        return latest;\n', '    }\n', '\n', '    function tokenFallback(address from, uint value, bytes) public {\n', '        depositFor(from, msg.sender, value);\n', '    }\n', '\n', '    function tokensReceived(address, address from, address, uint amount, bytes, bytes) public {\n', '        if (!isERC777[msg.sender]) {\n', '            isERC777[msg.sender] = true;\n', '        }\n', '\n', '        depositFor(from, msg.sender, amount);\n', '    }\n', '\n', '    /// @dev Marks a token as an ERC777 token.\n', '    /// @param token Address of the token.\n', '    function setERC777(address token) public onlyOwner {\n', '        isERC777[token] = true;\n', '    }\n', '\n', '    /// @dev Unmarks a token as an ERC777 token.\n', '    /// @param token Address of the token.\n', '    function unsetERC777(address token) public onlyOwner {\n', '        isERC777[token] = false;\n', '    }\n', '\n', '    /// @dev Allows owner to withdraw tokens accidentally sent to the contract.\n', '    /// @param token Address of the token to withdraw.\n', '    function withdrawOverflow(address token) public onlyOwner {\n', '        withdrawTo(msg.sender, token, overflow(token));\n', '    }\n', '\n', '    /// @dev Returns the balance of a user for a specified token.\n', '    /// @param token Address of the token.\n', '    /// @param user Address of the user.\n', '    /// @return Balance for the user.\n', '    function balanceOf(address token, address user) public view returns (uint) {\n', '        return balances[token][user];\n', '    }\n', '\n', '    /// @dev Calculates how many tokens were accidentally sent to the contract.\n', '    /// @param token Address of the token to calculate for.\n', '    /// @return Amount of tokens not accounted for.\n', '    function overflow(address token) internal view returns (uint) {\n', '        if (token == ETH) {\n', '            return address(this).balance.sub(accounted[token]);\n', '        }\n', '\n', '        return ERC20(token).balanceOf(this).sub(accounted[token]);\n', '    }\n', '\n', '    /// @dev Accounts for token deposits.\n', '    /// @param user Address of the user who deposited.\n', '    /// @param token Address of the token deposited.\n', '    /// @param amount Amount of tokens deposited.\n', '    function depositFor(address user, address token, uint amount) private {\n', '        balances[token][user] = balances[token][user].add(amount);\n', '        accounted[token] = accounted[token].add(amount);\n', '        emit Deposited(user, token, amount);\n', '    }\n', '\n', '    /// @dev Withdraws tokens to user.\n', '    /// @param user Address of the target user.\n', '    /// @param token Address of the token.\n', '    /// @param amount Amount of tokens.\n', '    function withdrawTo(address user, address token, uint amount) private {\n', '        if (token == ETH) {\n', '            user.transfer(amount);\n', '            return;\n', '        }\n', '\n', '        if (isERC777[token]) {\n', '            ERC777(token).send(user, amount);\n', '            return;\n', '        }\n', '\n', '        require(ERC20(token).transfer(user, amount));\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'interface VaultInterface {\n', '\n', '    event Deposited(address indexed user, address token, uint amount);\n', '    event Withdrawn(address indexed user, address token, uint amount);\n', '\n', '    event Approved(address indexed user, address indexed spender);\n', '    event Unapproved(address indexed user, address indexed spender);\n', '\n', '    event AddedSpender(address indexed spender);\n', '    event RemovedSpender(address indexed spender);\n', '\n', '    function deposit(address token, uint amount) external payable;\n', '    function withdraw(address token, uint amount) external;\n', '    function transfer(address token, address from, address to, uint amount) external;\n', '    function approve(address spender) external;\n', '    function unapprove(address spender) external;\n', '    function isApproved(address user, address spender) external view returns (bool);\n', '    function addSpender(address spender) external;\n', '    function removeSpender(address spender) external;\n', '    function latestSpender() external view returns (address);\n', '    function isSpender(address spender) external view returns (bool);\n', '    function tokenFallback(address from, uint value, bytes data) public;\n', '    function balanceOf(address token, address user) public view returns (uint);\n', '\n', '}\n', '\n', 'interface ERC820 {\n', '\n', '    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return owner == _address;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '\n', '}\n', '\n', 'interface ERC777 {\n', '    function name() public constant returns (string);\n', '    function symbol() public constant returns (string);\n', '    function totalSupply() public constant returns (uint256);\n', '    function granularity() public constant returns (uint256);\n', '    function balanceOf(address owner) public constant returns (uint256);\n', '\n', '    function send(address to, uint256 amount) public;\n', '    function send(address to, uint256 amount, bytes userData) public;\n', '\n', '    function authorizeOperator(address operator) public;\n', '    function revokeOperator(address operator) public;\n', '    function isOperatorFor(address operator, address tokenHolder) public constant returns (bool);\n', '    function operatorSend(address from, address to, uint256 amount, bytes userData, bytes operatorData) public;\n', '\n', '}\n', '\n', 'contract Vault is Ownable, VaultInterface {\n', '\n', '    using SafeMath for *;\n', '\n', '    address constant public ETH = 0x0;\n', '\n', '    mapping (address => bool) public isERC777;\n', '\n', '    // user => spender => approved\n', '    mapping (address => mapping (address => bool)) private approved;\n', '    mapping (address => mapping (address => uint)) private balances;\n', '    mapping (address => uint) private accounted;\n', '    mapping (address => bool) private spenders;\n', '\n', '    address private latest;\n', '\n', '    modifier onlySpender {\n', '        require(spenders[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyApproved(address user) {\n', '        require(approved[user][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function Vault(ERC820 registry) public {\n', '        // required by ERC777 standard.\n', '        registry.setInterfaceImplementer(address(this), keccak256("ERC777TokensRecipient"), address(this));\n', '    }\n', '\n', '    /// @dev Deposits a specific token.\n', '    /// @param token Address of the token to deposit.\n', '    /// @param amount Amount of tokens to deposit.\n', '    function deposit(address token, uint amount) external payable {\n', '        require(token == ETH || msg.value == 0);\n', '\n', '        uint value = amount;\n', '        if (token == ETH) {\n', '            value = msg.value;\n', '        } else {\n', '            require(ERC20(token).transferFrom(msg.sender, address(this), value));\n', '        }\n', '\n', '        depositFor(msg.sender, token, value);\n', '    }\n', '\n', '    /// @dev Withdraws a specific token.\n', '    /// @param token Address of the token to withdraw.\n', '    /// @param amount Amount of tokens to withdraw.\n', '    function withdraw(address token, uint amount) external {\n', '        require(balanceOf(token, msg.sender) >= amount);\n', '\n', '        balances[token][msg.sender] = balances[token][msg.sender].sub(amount);\n', '        accounted[token] = accounted[token].sub(amount);\n', '\n', '        withdrawTo(msg.sender, token, amount);\n', '\n', '        emit Withdrawn(msg.sender, token, amount);\n', '    }\n', '\n', '    /// @dev Approves an spender to trade balances of the sender.\n', '    /// @param spender Address of the spender to approve.\n', '    function approve(address spender) external {\n', '        require(spenders[spender]);\n', '        approved[msg.sender][spender] = true;\n', '        emit Approved(msg.sender, spender);\n', '    }\n', '\n', '    /// @dev Unapproves an spender to trade balances of the sender.\n', '    /// @param spender Address of the spender to unapprove.\n', '    function unapprove(address spender) external {\n', '        approved[msg.sender][spender] = false;\n', '        emit Unapproved(msg.sender, spender);\n', '    }\n', '\n', '    /// @dev Adds a spender.\n', '    /// @param spender Address of the spender.\n', '    function addSpender(address spender) external onlyOwner {\n', '        require(spender != 0x0);\n', '        spenders[spender] = true;\n', '        latest = spender;\n', '        emit AddedSpender(spender);\n', '    }\n', '\n', '    /// @dev Removes a spender.\n', '    /// @param spender Address of the spender.\n', '    function removeSpender(address spender) external onlyOwner {\n', '        spenders[spender] = false;\n', '        emit RemovedSpender(spender);\n', '    }\n', '\n', '    /// @dev Transfers balances of a token between users.\n', '    /// @param token Address of the token to transfer.\n', '    /// @param from Address of the user to transfer tokens from.\n', '    /// @param to Address of the user to transfer tokens to.\n', '    /// @param amount Amount of tokens to transfer.\n', '    function transfer(address token, address from, address to, uint amount) external onlySpender onlyApproved(from) {\n', '        // We do not check the balance here, as SafeMath will revert if sub / add fail. Due to over/underflows.\n', '        require(amount > 0);\n', '        balances[token][from] = balances[token][from].sub(amount);\n', '        balances[token][to] = balances[token][to].add(amount);\n', '    }\n', '\n', '    /// @dev Returns if an spender has been approved by a user.\n', '    /// @param user Address of the user.\n', '    /// @param spender Address of the spender.\n', '    /// @return Boolean whether spender has been approved.\n', '    function isApproved(address user, address spender) external view returns (bool) {\n', '        return approved[user][spender];\n', '    }\n', '\n', '    /// @dev Returns if an address has been approved as a spender.\n', '    /// @param spender Address of the spender.\n', '    /// @return Boolean whether spender has been approved.\n', '    function isSpender(address spender) external view returns (bool) {\n', '        return spenders[spender];\n', '    }\n', '\n', '    function latestSpender() external view returns (address) {\n', '        return latest;\n', '    }\n', '\n', '    function tokenFallback(address from, uint value, bytes) public {\n', '        depositFor(from, msg.sender, value);\n', '    }\n', '\n', '    function tokensReceived(address, address from, address, uint amount, bytes, bytes) public {\n', '        if (!isERC777[msg.sender]) {\n', '            isERC777[msg.sender] = true;\n', '        }\n', '\n', '        depositFor(from, msg.sender, amount);\n', '    }\n', '\n', '    /// @dev Marks a token as an ERC777 token.\n', '    /// @param token Address of the token.\n', '    function setERC777(address token) public onlyOwner {\n', '        isERC777[token] = true;\n', '    }\n', '\n', '    /// @dev Unmarks a token as an ERC777 token.\n', '    /// @param token Address of the token.\n', '    function unsetERC777(address token) public onlyOwner {\n', '        isERC777[token] = false;\n', '    }\n', '\n', '    /// @dev Allows owner to withdraw tokens accidentally sent to the contract.\n', '    /// @param token Address of the token to withdraw.\n', '    function withdrawOverflow(address token) public onlyOwner {\n', '        withdrawTo(msg.sender, token, overflow(token));\n', '    }\n', '\n', '    /// @dev Returns the balance of a user for a specified token.\n', '    /// @param token Address of the token.\n', '    /// @param user Address of the user.\n', '    /// @return Balance for the user.\n', '    function balanceOf(address token, address user) public view returns (uint) {\n', '        return balances[token][user];\n', '    }\n', '\n', '    /// @dev Calculates how many tokens were accidentally sent to the contract.\n', '    /// @param token Address of the token to calculate for.\n', '    /// @return Amount of tokens not accounted for.\n', '    function overflow(address token) internal view returns (uint) {\n', '        if (token == ETH) {\n', '            return address(this).balance.sub(accounted[token]);\n', '        }\n', '\n', '        return ERC20(token).balanceOf(this).sub(accounted[token]);\n', '    }\n', '\n', '    /// @dev Accounts for token deposits.\n', '    /// @param user Address of the user who deposited.\n', '    /// @param token Address of the token deposited.\n', '    /// @param amount Amount of tokens deposited.\n', '    function depositFor(address user, address token, uint amount) private {\n', '        balances[token][user] = balances[token][user].add(amount);\n', '        accounted[token] = accounted[token].add(amount);\n', '        emit Deposited(user, token, amount);\n', '    }\n', '\n', '    /// @dev Withdraws tokens to user.\n', '    /// @param user Address of the target user.\n', '    /// @param token Address of the token.\n', '    /// @param amount Amount of tokens.\n', '    function withdrawTo(address user, address token, uint amount) private {\n', '        if (token == ETH) {\n', '            user.transfer(amount);\n', '            return;\n', '        }\n', '\n', '        if (isERC777[token]) {\n', '            ERC777(token).send(user, amount);\n', '            return;\n', '        }\n', '\n', '        require(ERC20(token).transfer(user, amount));\n', '    }\n', '}']
