['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract ERC20 is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  mapping (address => uint256) private _balances;\n', '\n', '  mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '  uint256 private _totalSupply;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param owner The address to query the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param owner address The address which owns the funds.\n', '   * @param spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address owner,\n', '    address spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return _allowed[owner][spender];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  */\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    _transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param spender The address which will spend the funds.\n', '   * @param value The amount of tokens to be spent.\n', '   */\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param from address The address which you want to send tokens from\n', '   * @param to address The address which you want to transfer to\n', '   * @param value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(value <= _allowed[from][msg.sender]);\n', '\n', '    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '    _transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed_[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param spender The address which will spend the funds.\n', '   * @param addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseAllowance(\n', '    address spender,\n', '    uint256 addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].add(addedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed_[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param spender The address which will spend the funds.\n', '   * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseAllowance(\n', '    address spender,\n', '    uint256 subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].sub(subtractedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified addresses\n', '  * @param from The address to transfer from.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  */\n', '  function _transfer(address from, address to, uint256 value) internal {\n', '    require(value <= _balances[from]);\n', '    require(to != address(0));\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(from, to, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that mints an amount of the token and assigns it to\n', '   * an account. This encapsulates the modification of balances such that the\n', '   * proper events are emitted.\n', '   * @param account The account that will receive the created tokens.\n', '   * @param value The amount that will be created.\n', '   */\n', '  function _mint(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    _totalSupply = _totalSupply.add(value);\n', '    _balances[account] = _balances[account].add(value);\n', '    emit Transfer(address(0), account, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that burns an amount of the token of a given\n', '   * account.\n', '   * @param account The account whose tokens will be burnt.\n', '   * @param value The amount that will be burnt.\n', '   */\n', '  function _burn(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    require(value <= _balances[account]);\n', '\n', '    _totalSupply = _totalSupply.sub(value);\n', '    _balances[account] = _balances[account].sub(value);\n', '    emit Transfer(account, address(0), value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that burns an amount of the token of a given\n', "   * account, deducting from the sender's allowance for said account. Uses the\n", '   * internal burn function.\n', '   * @param account The account whose tokens will be burnt.\n', '   * @param value The amount that will be burnt.\n', '   */\n', '  function _burnFrom(address account, uint256 value) internal {\n', '    require(value <= _allowed[account][msg.sender]);\n', '\n', '    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n', '    // this function needs to emit an event with the updated approval.\n', '    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n', '      value);\n', '    _burn(account, value);\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n', '\n', '/**\n', ' * @title ERC20Detailed token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '\n', '  constructor(string name, string symbol, uint8 decimals) public {\n', '    _name = name;\n', '    _symbol = symbol;\n', '    _decimals = decimals;\n', '  }\n', '\n', '  /**\n', '   * @return the name of the token.\n', '   */\n', '  function name() public view returns(string) {\n', '    return _name;\n', '  }\n', '\n', '  /**\n', '   * @return the symbol of the token.\n', '   */\n', '  function symbol() public view returns(string) {\n', '    return _symbol;\n', '  }\n', '\n', '  /**\n', '   * @return the number of decimals of the token.\n', '   */\n', '  function decimals() public view returns(uint8) {\n', '    return _decimals;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an account access to this role\n', '   */\n', '  function add(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(!has(role, account));\n', '\n', '    role.bearer[account] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an account's access to this role\n", '   */\n', '  function remove(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(has(role, account));\n', '\n', '    role.bearer[account] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an account has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address account)\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    require(account != address(0));\n', '    return role.bearer[account];\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/roles/MinterRole.sol\n', '\n', 'contract MinterRole {\n', '  using Roles for Roles.Role;\n', '\n', '  event MinterAdded(address indexed account);\n', '  event MinterRemoved(address indexed account);\n', '\n', '  Roles.Role private minters;\n', '\n', '  constructor() internal {\n', '    _addMinter(msg.sender);\n', '  }\n', '\n', '  modifier onlyMinter() {\n', '    require(isMinter(msg.sender));\n', '    _;\n', '  }\n', '\n', '  function isMinter(address account) public view returns (bool) {\n', '    return minters.has(account);\n', '  }\n', '\n', '  function addMinter(address account) public onlyMinter {\n', '    _addMinter(account);\n', '  }\n', '\n', '  function renounceMinter() public {\n', '    _removeMinter(msg.sender);\n', '  }\n', '\n', '  function _addMinter(address account) internal {\n', '    minters.add(account);\n', '    emit MinterAdded(account);\n', '  }\n', '\n', '  function _removeMinter(address account) internal {\n', '    minters.remove(account);\n', '    emit MinterRemoved(account);\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\n', '\n', '/**\n', ' * @title ERC20Mintable\n', ' * @dev ERC20 minting logic\n', ' */\n', 'contract ERC20Mintable is ERC20, MinterRole {\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param to The address that will receive the minted tokens.\n', '   * @param value The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(\n', '    address to,\n', '    uint256 value\n', '  )\n', '    public\n', '    onlyMinter\n', '    returns (bool)\n', '  {\n', '    _mint(to, value);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/KDO.sol\n', '\n', 'contract KDO is Ownable, ERC20Detailed, ERC20Mintable {\n', '  struct Ticket {\n', '    // Type of the ticket\n', '    string tType;\n', '\n', '    // Creation date and expiration date\n', '    uint createdAt;\n', '    uint expireAt;\n', '\n', '    address contractor;\n', '\n', '    // The ticket has published a review\n', '    bool hasReviewed;\n', '  }\n', '\n', '  // A contractor is someone that will be credited by tickets (clients)\n', '  struct Contractor {\n', '    // Its reviews\n', '    mapping (uint => uint) reviews;\n', '\n', '    // Total of tickets\n', '    uint256 nbCredittedTickets;\n', '\n', '    // Total of debitted tokens\n', '    uint256 debittedBalance;\n', '  }\n', '\n', '  // Commission regarding the review average, the index is about the rating value\n', '  // the value is the commission in %\n', '  uint8[5] public commissions;\n', '\n', '  mapping (address => Ticket) public tickets;\n', '\n', '  // A contractor is a person who can consume ticketTypes and be credited for\n', '  mapping (address => Contractor) public contractors;\n', '\n', '  event CreditEvt(address ticket, address contractor, string tType, uint256 date);\n', '  event DebitEvt(address contractor, uint256 amount, uint256 commission, uint256 date);\n', '  event ReviewEvt(address reviewer, address contractor, uint rate, uint256 date);\n', '  event CommissionsChangeEvt(uint8[5] commissions, uint256 date);\n', '\n', '  mapping (uint256 => string) public ticketTypes;\n', '\n', '  // Minimum base value for tickets 150000 Gwei\n', '  uint256 constant public MIN_TICKET_BASE_VALUE = 150000000000000;\n', '\n', '  // Min and Max commission in %\n', '  uint256 constant public MIN_COMMISSION = 8;\n', '  uint256 constant public MAX_COMMISSION = 30;\n', '\n', '  // Value to transfer to tickets when allocated\n', '  uint256 public ticketBaseValue;\n', '\n', '  // .0% of 10e18 (1 = 0.1%, 10 = 1%)\n', '  uint256 public ticketCostBase;\n', '\n', '  address private _businessOwner;\n', '\n', '  constructor(uint8[5] _commissions, address __businessOwner)\n', '    ERC20Detailed("KDO Coin", "KDO", 0)\n', '    public\n', '  {\n', '    ticketBaseValue = MIN_TICKET_BASE_VALUE;\n', '    ticketCostBase = 3;\n', '\n', '    updateCommissions(_commissions);\n', '\n', '    _businessOwner = __businessOwner;\n', '  }\n', '\n', '  // Only listed tickets\n', '  modifier onlyExistingTicketAmount(uint256 _amount) {\n', "    require(bytes(ticketTypes[_amount]).length > 0, '{error: UNKNOWN_TICKET}');\n", '    _;\n', '  }\n', '\n', '  // Update the ticket base cost for following market value in case of crash or\n', '  // pump\n', '  // @param _value new ticket base cost\n', '  function updateTicketCostBase(uint256 _value) public\n', '    onlyOwner()\n', '  {\n', '    require(_value > 0 && _value <= 500, \'{error: BAD_VALUE, message: "Should be > 0 and <= 500"}\');\n', '    ticketCostBase = _value;\n', '  }\n', '\n', '  // Update the ticket base value\n', '  // a ticket value is the amount of ether allowed to the ticket in order to\n', '  // be used\n', '  // @param _value is the base value change, in wei\n', '  function updateTicketBaseValue(uint256 _value) public\n', '    onlyOwner()\n', '  {\n', '    // Cant put a value below the minimal value\n', '    require(_value >= MIN_TICKET_BASE_VALUE, \'{error: BAD_VALUE, message: "Value too low"}\');\n', '    ticketBaseValue = _value;\n', '  }\n', '\n', '  // Update the commissions\n', '  // @param _c are the new commissions\n', '  function updateCommissions(uint8[5] _c) public\n', '    onlyOwner()\n', '  {\n', '    for (uint i = 0; i <= 4; i++) {\n', '        require(_c[i] <= MAX_COMMISSION && _c[i] >= MIN_COMMISSION, \'{error: BAD_VALUE, message: "A commission it too low or too high"}\');\n', '    }\n', '    commissions = _c;\n', '    emit CommissionsChangeEvt(_c, now);\n', '  }\n', '\n', '  // Add a new ticket type\n', '  // Can update an old ticket type, for instance :\n', '  // ticketTypes[99] = "bronze"\n', '  // addTicketType(99, "wood")\n', '  // ticketTypes[99] = "wood"\n', '  // ticket 99 has been updated from "bronze" to "wood"\n', '  // @param _amount is the ticket amount to update\n', '  // @param _key is the key to attribute to the amount\n', '  function addTicketType(uint256 _amount, string _key) public\n', '    onlyOwner()\n', '  {\n', '    ticketTypes[_amount] = _key;\n', '  }\n', '\n', '  // Create a ticket using KDO tokens\n', '  // @param _to ticket to create\n', '  // @param _KDOAmount amount to allocate to the ticket\n', '  function allocateNewTicketWithKDO(address _to, uint256 _KDOAmount)\n', '    public\n', '    payable\n', '    onlyExistingTicketAmount(_KDOAmount)\n', '    returns (bool success)\n', '  {\n', '      require(msg.value >= ticketBaseValue, \'{error: BAD_VALUE, message: "Value too low"}\');\n', '\n', '      _to.transfer(ticketBaseValue);\n', '\n', '      super.transfer(_to, _KDOAmount);\n', '\n', '      _createTicket(_to, _KDOAmount);\n', '\n', '      return true;\n', '  }\n', '\n', '  // Allocates a ticket to an address and create tokens (accordingly to the value of the allocated ticket)\n', '  // @param _to ticket to create\n', '  // @param _amount amount to allocate to the ticket\n', '  function allocateNewTicket(address _to, uint256 _amount)\n', '    public\n', '    payable\n', '    onlyExistingTicketAmount(_amount)\n', '    returns (bool success)\n', '  {\n', '    uint256 costInWei = costOfTicket(_amount);\n', '    require(msg.value == costInWei, \'{error: BAD_VALUE, message: "Value should be equal to the cost of the ticket"}\');\n', '\n', '    // Give minimal WEI value to a ticket\n', '    _to.transfer(ticketBaseValue);\n', '\n', '    // Price of the ticket transfered to the business owner address\n', '    _businessOwner.transfer(costInWei - ticketBaseValue);\n', '\n', '    super.mint(_to, _amount);\n', '\n', '    _createTicket(_to, _amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  // Checks if an address can handle the ticket type\n', '  // @param _ticketAddr tocket to check\n', '  function isTicketValid(address _ticketAddr)\n', '    public\n', '    view\n', '    returns (bool valid)\n', '  {\n', '    if (tickets[_ticketAddr].contractor == 0x0 && now < tickets[_ticketAddr].expireAt) {\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  // A ticket credit the contractor balance\n', '  // It triggers Consume event for logs\n', '  // @param _contractor contractor to credit\n', '  // @param _amount amount that will be creditted\n', '  function creditContractor(address _contractor, uint256 amount)\n', '    public\n', '    onlyExistingTicketAmount(amount)\n', '    returns (bool success)\n', '  {\n', "    require(isTicketValid(msg.sender), '{error: INVALID_TICKET}');\n", '\n', '    super.transfer(_contractor, amount);\n', '\n', '    contractors[_contractor].nbCredittedTickets += 1;\n', '\n', '    tickets[msg.sender].contractor = _contractor;\n', '\n', '    emit CreditEvt(msg.sender, _contractor, tickets[msg.sender].tType, now);\n', '\n', '    return true;\n', '  }\n', '\n', "  // Publish a review and rate the ticket's contractor (only consumed tickets can\n", '  // perform this action)\n', '  // @param _reviewRate rating of the review\n', '  function publishReview(uint _reviewRate) public {\n', "    // Only ticket that hasn't published any review and that has been consumed\n", "    require(!tickets[msg.sender].hasReviewed && tickets[msg.sender].contractor != 0x0, '{error: INVALID_TICKET}');\n", '\n', '    // Only between 0 and 5\n', '    require(_reviewRate >= 0 && _reviewRate <= 5, \'{error: INVALID_RATE, message: "A rate should be between 0 and 5 included"}\');\n', '\n', '    // Add the review to the contractor of the ticket\n', '    contractors[tickets[msg.sender].contractor].reviews[_reviewRate] += 1;\n', '\n', '    tickets[msg.sender].hasReviewed = true;\n', '\n', '    emit ReviewEvt(msg.sender, tickets[msg.sender].contractor, _reviewRate, now);\n', '  }\n', '\n', '  // Calculate the average rating of a contractor\n', '  // @param _address contractor address\n', '  function reviewAverageOfContractor(address _address) public view returns (uint avg) {\n', '    // Percentage threshold\n', '    uint decreaseThreshold = 60;\n', '\n', '    // Apply a penalty of -1 for reviews = 0\n', '    int totReviews = int(contractors[_address].reviews[0]) * -1;\n', '\n', '    uint nbReviews = contractors[_address].reviews[0];\n', '\n', '    for (uint i = 1; i <= 5; i++) {\n', '      totReviews += int(contractors[_address].reviews[i] * i);\n', '      nbReviews += contractors[_address].reviews[i];\n', '    }\n', '\n', '    if (nbReviews == 0) {\n', '      return 250;\n', '    }\n', '\n', '    // Too much penalties leads to 0, then force it to be 0, the average\n', "    // can't be negative\n", '    if (totReviews < 0) {\n', '      totReviews = 0;\n', '    }\n', '\n', '    uint percReviewsTickets = (nbReviews * 100 / contractors[_address].nbCredittedTickets);\n', '\n', '    avg = (uint(totReviews) * 100) / nbReviews;\n', '\n', '    if (percReviewsTickets >= decreaseThreshold) {\n', '      return avg;\n', '    }\n', '\n', '    // A rate < 60% on the number of reviews will decrease the rating average of\n', '    // the difference between the threshold and the % of reviews\n', '    // for instance a percent reviews of 50% will decrease the rating average\n', '    // of 10% (60% - 50%)\n', '    // This is to avoid abuse of the system, without this mecanism a contractor\n', '    // could stay with a average of 500 (the max) regardless of the number\n', '    // of ticket he used.\n', '    uint decreasePercent = decreaseThreshold - percReviewsTickets;\n', '\n', '    return avg - (avg / decreasePercent);\n', '  }\n', '\n', '  // Returns the commission for the contractor\n', '  // @param _address contractor address\n', '  function commissionForContractor(address _address) public view returns (uint8 c) {\n', '    return commissionForReviewAverageOf(reviewAverageOfContractor(_address));\n', '  }\n', '\n', '  // Returns the info of a ticket\n', '  // @param _address ticket address\n', '  function infoOfTicket(address _address) public view returns (uint256 balance, string tType, bool isValid, uint createdAt, uint expireAt, address contractor, bool hasReviewed) {\n', '    return (super.balanceOf(_address), tickets[_address].tType, isTicketValid(_address), tickets[_address].createdAt, tickets[_address].expireAt, tickets[_address].contractor, tickets[_address].hasReviewed);\n', '  }\n', '\n', '  // Returns the contractor info\n', '  // @param _address contractor address\n', '  function infoOfContractor(address _address) public view returns(uint256 balance, uint256 debittedBalance, uint256 nbReviews, uint256 nbCredittedTickets, uint256 avg) {\n', '    for (uint i = 0; i <= 5; i++) {\n', '      nbReviews += contractors[_address].reviews[i];\n', '    }\n', '\n', '    return (super.balanceOf(_address), contractors[_address].debittedBalance, nbReviews, contractors[_address].nbCredittedTickets, reviewAverageOfContractor(_address));\n', '  }\n', '\n', '  // Transfers contractors tokens to the owner\n', '  // It triggers Debit event\n', '  // @param _amount amount to debit\n', '  function debit(uint256 _amount) public {\n', '    super.transfer(super.owner(), _amount);\n', '\n', '    emit DebitEvt(msg.sender, _amount, commissionForContractor(msg.sender), now);\n', '  }\n', '\n', '  // Returns the cost of a ticket regarding its amount\n', '  // Returned value is represented in Wei\n', '  // @param _amount amount of the ticket\n', '  function costOfTicket(uint256 _amount) public view returns(uint256 cost) {\n', '    return (_amount * (ticketCostBase * 1000000000000000)) + ticketBaseValue;\n', '  }\n', '\n', '  // Calculate the commission regarding the rating (review average)\n', '  // Example with a commissions = [30, 30, 30, 25, 20]\n', '  // [0,3[ = 30% (DefaultCommission)\n', '  // [3,4[ = 25%\n', '  // [4,5[ = 20%\n', '  // A rating average of 3.8 = 25% of commission\n', '  // @param _avg commission average\n', '  function commissionForReviewAverageOf(uint _avg) public view returns (uint8 c) {\n', '    if (_avg >= 500) {\n', '      return commissions[4];\n', '    }\n', '\n', '    for (uint i = 0; i < 5; i++) {\n', '      if (_avg <= i * 100 || _avg < (i + 1) * 100) {\n', '        return commissions[i];\n', '      }\n', '    }\n', '\n', '    // Default commission when there is something wrong\n', '    return commissions[0];\n', '  }\n', '\n', '  function _createTicket(address _address, uint256 _amount) private {\n', '    tickets[_address] = Ticket({\n', '      tType: ticketTypes[_amount],\n', '      createdAt: now,\n', '      expireAt: now + 2 * 365 days,\n', '      contractor: 0x0,\n', '      hasReviewed: false\n', '    });\n', '  }\n', '}']