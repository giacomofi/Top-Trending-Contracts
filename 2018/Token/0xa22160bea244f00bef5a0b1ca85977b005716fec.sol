['pragma solidity ^0.4.21;\n', '\n', '// File: deploy/contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error.\n', ' * Note, the div and mul methods were removed as they are not currently needed\n', ' */\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: deploy/contracts/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: deploy/contracts/Stampable.sol\n', '\n', 'contract Stampable is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    // A struct that represents a particular token balance\n', '    struct TokenBalance {\n', '        uint256 amount;\n', '        uint index;\n', '    }\n', '\n', '    // A struct that represents a particular address balance\n', '    struct AddressBalance {\n', '        mapping (uint256 => TokenBalance) tokens;\n', '        uint256[] tokenIndex;\n', '    }\n', '\n', '    // A mapping of address to balances\n', '    mapping (address => AddressBalance) balances;\n', '\n', '    // The total number of tokens owned per address\n', '    mapping (address => uint256) ownershipCount;\n', '\n', '    // Whitelist for addresses allowed to stamp tokens\n', '    mapping (address => bool) public stampingWhitelist;\n', '\n', '    /**\n', '    * Modifier for only whitelisted addresses\n', '    */\n', '    modifier onlyStampingWhitelisted() {\n', '        require(stampingWhitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    // Event for token stamping\n', '    event TokenStamp (address indexed from, uint256 tokenStamped, uint256 stamp, uint256 amt);\n', '\n', '    /**\n', '    * @dev Function to stamp a token in the msg.sender&#39;s wallet\n', '    * @param _tokenToStamp uint256 The tokenId of theirs to stamp (0 for unstamped tokens)\n', '    * @param _stamp uint256 The new stamp to apply\n', '    * @param _amt uint256 The quantity of tokens to stamp\n', '    */\n', '    function stampToken (uint256 _tokenToStamp, uint256 _stamp, uint256 _amt)\n', '        onlyStampingWhitelisted\n', '        public returns (bool) {\n', '        require(_amt <= balances[msg.sender].tokens[_tokenToStamp].amount);\n', '\n', '        // Subtract balance of 0th token ID _amt value.\n', '        removeToken(msg.sender, _tokenToStamp, _amt);\n', '\n', '        // "Stamp" the token\n', '        addToken(msg.sender, _stamp, _amt);\n', '\n', '        // Emit the stamping event\n', '        emit TokenStamp(msg.sender, _tokenToStamp, _stamp, _amt);\n', '\n', '        return true;\n', '    }\n', '\n', '    function addToken(address _owner, uint256 _token, uint256 _amount) internal {\n', '        // If they don&#39;t yet have any, assign this token an index\n', '        if (balances[_owner].tokens[_token].amount == 0) {\n', '            balances[_owner].tokens[_token].index = balances[_owner].tokenIndex.push(_token) - 1;\n', '        }\n', '\n', '        // Increase their balance of said token\n', '        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.add(_amount);\n', '\n', '        // Increase their ownership count\n', '        ownershipCount[_owner] = ownershipCount[_owner].add(_amount);\n', '    }\n', '\n', '    function removeToken(address _owner, uint256 _token, uint256 _amount) internal {\n', '        // Decrease their ownership count\n', '        ownershipCount[_owner] = ownershipCount[_owner].sub(_amount);\n', '\n', '        // Decrease their balance of the token\n', '        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.sub(_amount);\n', '\n', '        // If they don&#39;t have any left, remove it\n', '        if (balances[_owner].tokens[_token].amount == 0) {\n', '            uint index = balances[_owner].tokens[_token].index;\n', '            uint256 lastCoin = balances[_owner].tokenIndex[balances[_owner].tokenIndex.length - 1];\n', '            balances[_owner].tokenIndex[index] = lastCoin;\n', '            balances[_owner].tokens[lastCoin].index = index;\n', '            balances[_owner].tokenIndex.length--;\n', '            // Make sure the user&#39;s token is removed\n', '            delete balances[_owner].tokens[_token];\n', '        }\n', '    }\n', '}\n', '\n', '// File: deploy/contracts/FanCoin.sol\n', '\n', 'contract FanCoin is Stampable {\n', '    using SafeMath for uint256;\n', '\n', '    // The owner of this token\n', '    address public owner;\n', '\n', '    // Keeps track of allowances for particular address. - ERC20 Method\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event TokenTransfer (address indexed from, address indexed to, uint256 tokenId, uint256 value);\n', '    event MintTransfer  (address indexed from, address indexed to, uint256 originalTokenId, uint256 tokenId, uint256 value);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * The constructor for the FanCoin token\n', '    */\n', '    function FanCoin() public {\n', '        owner = 0x7DDf115B8eEf3058944A3373025FB507efFAD012;\n', '        name = "FanChain";\n', '        symbol = "FANZ";\n', '        decimals = 4;\n', '\n', '        // Total supply is one billion tokens\n', '        totalSupply = 6e8 * uint256(10) ** decimals;\n', '\n', '        // Add the owner to the stamping whitelist\n', '        stampingWhitelist[owner] = true;\n', '\n', '        // Initially give all of the tokens to the owner\n', '        addToken(owner, 0, totalSupply);\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Retrieves the balance of a specified address\n', '    * @param _owner address The address to query the balance of.\n', '    * @return A uint256 representing the amount owned by the _owner\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownershipCount[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev Retrieves the balance of a specified address for a specific token\n', '    * @param _owner address The address to query the balance of\n', '    * @param _tokenId uint256 The token being queried\n', '    * @return A uint256 representing the amount owned by the _owner\n', '    */\n', '    function balanceOfToken(address _owner, uint256 _tokenId) public view returns (uint256 balance) {\n', '        return balances[_owner].tokens[_tokenId].amount;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns all of the tokens owned by a particular address\n', '    * @param _owner address The address to query\n', '    * @return A uint256 array representing the tokens owned\n', '    */\n', '    function tokensOwned(address _owner) public view returns (uint256[] tokens) {\n', '        return balances[_owner].tokenIndex;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Transfers tokens to a specific address\n', '    * @param _to address The address to transfer tokens to\n', '    * @param _value unit256 The amount to be transferred\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= totalSupply);\n', '        require(_value <= ownershipCount[msg.sender]);\n', '\n', '        // Cast the value as the ERC20 standard uses uint256\n', '        uint256 _tokensToTransfer = uint256(_value);\n', '\n', '        // Do the transfer\n', '        require(transferAny(msg.sender, _to, _tokensToTransfer));\n', '\n', '        // Notify that a transfer has occurred\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer a specific kind of token to another address\n', '    * @param _to address The address to transfer to\n', '    * @param _tokenId address The type of token to transfer\n', '    * @param _value uint256 The number of tokens to transfer\n', '    */\n', '    function transferToken(address _to, uint256 _tokenId, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender].tokens[_tokenId].amount);\n', '\n', '        // Do the transfer\n', '        internalTransfer(msg.sender, _to, _tokenId, _value);\n', '\n', '        // Notify that a transfer happened\n', '        emit TokenTransfer(msg.sender, _to, _tokenId, _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer a list of token kinds and values to another address\n', '    * @param _to address The address to transfer to\n', '    * @param _tokenIds uint256[] The list of tokens to transfer\n', '    * @param _values uint256[] The list of amounts to transfer\n', '    */\n', '    function transferTokens(address _to, uint256[] _tokenIds, uint256[] _values) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_tokenIds.length == _values.length);\n', '        require(_tokenIds.length < 100); // Arbitrary limit\n', '\n', '        // Do verification first\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            require(_values[i] > 0);\n', '            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\n', '        }\n', '\n', '        // Transfer every type of token specified\n', '        for (i = 0; i < _tokenIds.length; i++) {\n', '            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\n', '            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\n', '            emit Transfer(msg.sender, _to, _values[i]);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers the given number of tokens regardless of how they are stamped\n', '    * @param _from address The address to transfer from\n', '    * @param _to address The address to transfer to\n', '    * @param _value uint256 The number of tokens to send\n', '    */\n', '    function transferAny(address _from, address _to, uint256 _value) private returns (bool) {\n', '        // Iterate through all of the tokens owned, and transfer either the\n', '        // current balance of that token, or the remaining total amount to be\n', '        // transferred (`_value`), whichever is smaller. Because tokens are completely removed\n', '        // as their balances reach 0, we just run the loop until we have transferred all\n', '        // of the tokens we need to\n', '        uint256 _tokensToTransfer = _value;\n', '        while (_tokensToTransfer > 0) {\n', '            uint256 tokenId = balances[_from].tokenIndex[0];\n', '            uint256 tokenBalance = balances[_from].tokens[tokenId].amount;\n', '\n', '            if (tokenBalance >= _tokensToTransfer) {\n', '                require(internalTransfer(_from, _to, tokenId, _tokensToTransfer));\n', '                _tokensToTransfer = 0;\n', '            } else {\n', '                _tokensToTransfer = _tokensToTransfer - tokenBalance;\n', '                require(internalTransfer(_from, _to, tokenId, tokenBalance));\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Internal function for transferring a specific type of token\n', '    */\n', '    function internalTransfer(address _from, address _to, uint256 _tokenId, uint256 _value) private returns (bool) {\n', '        // Decrease the amount being sent first\n', '        removeToken(_from, _tokenId, _value);\n', '\n', '        // Increase receivers token balances\n', '        addToken(_to, _tokenId, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Transfer on behalf of another address\n', '    * @param _from address The address to send tokens from\n', '    * @param _to address The address to send tokens to\n', '    * @param _value uint256 The amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= ownershipCount[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Get the uint256 version of value\n', '        uint256 _castValue = uint256(_value);\n', '\n', '        // Decrease the spending limit\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        // Actually perform the transfer\n', '        require(transferAny(_from, _to, _castValue));\n', '\n', '        // Notify that a transfer has occurred\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer and stamp tokens from a mint in one step\n', '    * @param _to address To send the tokens to\n', '    * @param _tokenToStamp uint256 The token to stamp (0 is unstamped tokens)\n', '    * @param _stamp uint256 The new stamp to apply\n', '    * @param _amount uint256 The number of tokens to stamp and transfer\n', '    */\n', '    function mintTransfer(address _to, uint256 _tokenToStamp, uint256 _stamp, uint256 _amount) public\n', '        onlyStampingWhitelisted returns (bool) {\n', '        require(_to != address(0));\n', '        require(_amount <= balances[msg.sender].tokens[_tokenToStamp].amount);\n', '\n', '        // Decrease the amount being sent first\n', '        removeToken(msg.sender, _tokenToStamp, _amount);\n', '\n', '        // Increase receivers token balances\n', '        addToken(_to, _stamp, _amount);\n', '\n', '        emit MintTransfer(msg.sender, _to, _tokenToStamp, _stamp, _amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Add an address to the whitelist\n', '     * @param _addr address The address to add\n', '     */\n', '    function addToWhitelist(address _addr) public\n', '        onlyOwner {\n', '        stampingWhitelist[_addr] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove an address from the whitelist\n', '     * @param _addr address The address to remove\n', '     */\n', '    function removeFromWhitelist(address _addr) public\n', '        onlyOwner {\n', '        stampingWhitelist[_addr] = false;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Approve sent address to spend the specified amount of tokens on\n', '    * behalf of msg.sender\n', '    *\n', '    * See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * for any potential security concerns\n', '    *\n', '    * @param _spender address The address that will spend funds\n', '    * @param _value uint256 The number of tokens they are allowed to spend\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Returns the amount a spender is allowed to spend for a particular\n', '    * address\n', '    * @param _owner address The address which owns the funds\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return uint256 The number of tokens still available for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Increases the number of tokens a spender is allowed to spend for\n', '    * `msg.sender`\n', '    * @param _spender address The address of the spender\n', '    * @param _addedValue uint256 The amount to increase the spenders approval by\n', '    */\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Decreases the number of tokens a spender is allowed to spend for\n', '    * `msg.sender`\n', '    * @param _spender address The address of the spender\n', '    * @param _subtractedValue uint256 The amount to decrease the spenders approval by\n', '    */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n', '        uint _value = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > _value) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = _value.sub(_subtractedValue);\n', '        }\n', '\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: deploy/contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error.\n', ' * Note, the div and mul methods were removed as they are not currently needed\n', ' */\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: deploy/contracts/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: deploy/contracts/Stampable.sol\n', '\n', 'contract Stampable is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    // A struct that represents a particular token balance\n', '    struct TokenBalance {\n', '        uint256 amount;\n', '        uint index;\n', '    }\n', '\n', '    // A struct that represents a particular address balance\n', '    struct AddressBalance {\n', '        mapping (uint256 => TokenBalance) tokens;\n', '        uint256[] tokenIndex;\n', '    }\n', '\n', '    // A mapping of address to balances\n', '    mapping (address => AddressBalance) balances;\n', '\n', '    // The total number of tokens owned per address\n', '    mapping (address => uint256) ownershipCount;\n', '\n', '    // Whitelist for addresses allowed to stamp tokens\n', '    mapping (address => bool) public stampingWhitelist;\n', '\n', '    /**\n', '    * Modifier for only whitelisted addresses\n', '    */\n', '    modifier onlyStampingWhitelisted() {\n', '        require(stampingWhitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    // Event for token stamping\n', '    event TokenStamp (address indexed from, uint256 tokenStamped, uint256 stamp, uint256 amt);\n', '\n', '    /**\n', "    * @dev Function to stamp a token in the msg.sender's wallet\n", '    * @param _tokenToStamp uint256 The tokenId of theirs to stamp (0 for unstamped tokens)\n', '    * @param _stamp uint256 The new stamp to apply\n', '    * @param _amt uint256 The quantity of tokens to stamp\n', '    */\n', '    function stampToken (uint256 _tokenToStamp, uint256 _stamp, uint256 _amt)\n', '        onlyStampingWhitelisted\n', '        public returns (bool) {\n', '        require(_amt <= balances[msg.sender].tokens[_tokenToStamp].amount);\n', '\n', '        // Subtract balance of 0th token ID _amt value.\n', '        removeToken(msg.sender, _tokenToStamp, _amt);\n', '\n', '        // "Stamp" the token\n', '        addToken(msg.sender, _stamp, _amt);\n', '\n', '        // Emit the stamping event\n', '        emit TokenStamp(msg.sender, _tokenToStamp, _stamp, _amt);\n', '\n', '        return true;\n', '    }\n', '\n', '    function addToken(address _owner, uint256 _token, uint256 _amount) internal {\n', "        // If they don't yet have any, assign this token an index\n", '        if (balances[_owner].tokens[_token].amount == 0) {\n', '            balances[_owner].tokens[_token].index = balances[_owner].tokenIndex.push(_token) - 1;\n', '        }\n', '\n', '        // Increase their balance of said token\n', '        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.add(_amount);\n', '\n', '        // Increase their ownership count\n', '        ownershipCount[_owner] = ownershipCount[_owner].add(_amount);\n', '    }\n', '\n', '    function removeToken(address _owner, uint256 _token, uint256 _amount) internal {\n', '        // Decrease their ownership count\n', '        ownershipCount[_owner] = ownershipCount[_owner].sub(_amount);\n', '\n', '        // Decrease their balance of the token\n', '        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.sub(_amount);\n', '\n', "        // If they don't have any left, remove it\n", '        if (balances[_owner].tokens[_token].amount == 0) {\n', '            uint index = balances[_owner].tokens[_token].index;\n', '            uint256 lastCoin = balances[_owner].tokenIndex[balances[_owner].tokenIndex.length - 1];\n', '            balances[_owner].tokenIndex[index] = lastCoin;\n', '            balances[_owner].tokens[lastCoin].index = index;\n', '            balances[_owner].tokenIndex.length--;\n', "            // Make sure the user's token is removed\n", '            delete balances[_owner].tokens[_token];\n', '        }\n', '    }\n', '}\n', '\n', '// File: deploy/contracts/FanCoin.sol\n', '\n', 'contract FanCoin is Stampable {\n', '    using SafeMath for uint256;\n', '\n', '    // The owner of this token\n', '    address public owner;\n', '\n', '    // Keeps track of allowances for particular address. - ERC20 Method\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    event TokenTransfer (address indexed from, address indexed to, uint256 tokenId, uint256 value);\n', '    event MintTransfer  (address indexed from, address indexed to, uint256 originalTokenId, uint256 tokenId, uint256 value);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * The constructor for the FanCoin token\n', '    */\n', '    function FanCoin() public {\n', '        owner = 0x7DDf115B8eEf3058944A3373025FB507efFAD012;\n', '        name = "FanChain";\n', '        symbol = "FANZ";\n', '        decimals = 4;\n', '\n', '        // Total supply is one billion tokens\n', '        totalSupply = 6e8 * uint256(10) ** decimals;\n', '\n', '        // Add the owner to the stamping whitelist\n', '        stampingWhitelist[owner] = true;\n', '\n', '        // Initially give all of the tokens to the owner\n', '        addToken(owner, 0, totalSupply);\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Retrieves the balance of a specified address\n', '    * @param _owner address The address to query the balance of.\n', '    * @return A uint256 representing the amount owned by the _owner\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return ownershipCount[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev Retrieves the balance of a specified address for a specific token\n', '    * @param _owner address The address to query the balance of\n', '    * @param _tokenId uint256 The token being queried\n', '    * @return A uint256 representing the amount owned by the _owner\n', '    */\n', '    function balanceOfToken(address _owner, uint256 _tokenId) public view returns (uint256 balance) {\n', '        return balances[_owner].tokens[_tokenId].amount;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns all of the tokens owned by a particular address\n', '    * @param _owner address The address to query\n', '    * @return A uint256 array representing the tokens owned\n', '    */\n', '    function tokensOwned(address _owner) public view returns (uint256[] tokens) {\n', '        return balances[_owner].tokenIndex;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Transfers tokens to a specific address\n', '    * @param _to address The address to transfer tokens to\n', '    * @param _value unit256 The amount to be transferred\n', '    */\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= totalSupply);\n', '        require(_value <= ownershipCount[msg.sender]);\n', '\n', '        // Cast the value as the ERC20 standard uses uint256\n', '        uint256 _tokensToTransfer = uint256(_value);\n', '\n', '        // Do the transfer\n', '        require(transferAny(msg.sender, _to, _tokensToTransfer));\n', '\n', '        // Notify that a transfer has occurred\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer a specific kind of token to another address\n', '    * @param _to address The address to transfer to\n', '    * @param _tokenId address The type of token to transfer\n', '    * @param _value uint256 The number of tokens to transfer\n', '    */\n', '    function transferToken(address _to, uint256 _tokenId, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender].tokens[_tokenId].amount);\n', '\n', '        // Do the transfer\n', '        internalTransfer(msg.sender, _to, _tokenId, _value);\n', '\n', '        // Notify that a transfer happened\n', '        emit TokenTransfer(msg.sender, _to, _tokenId, _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer a list of token kinds and values to another address\n', '    * @param _to address The address to transfer to\n', '    * @param _tokenIds uint256[] The list of tokens to transfer\n', '    * @param _values uint256[] The list of amounts to transfer\n', '    */\n', '    function transferTokens(address _to, uint256[] _tokenIds, uint256[] _values) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_tokenIds.length == _values.length);\n', '        require(_tokenIds.length < 100); // Arbitrary limit\n', '\n', '        // Do verification first\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            require(_values[i] > 0);\n', '            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\n', '        }\n', '\n', '        // Transfer every type of token specified\n', '        for (i = 0; i < _tokenIds.length; i++) {\n', '            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\n', '            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\n', '            emit Transfer(msg.sender, _to, _values[i]);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers the given number of tokens regardless of how they are stamped\n', '    * @param _from address The address to transfer from\n', '    * @param _to address The address to transfer to\n', '    * @param _value uint256 The number of tokens to send\n', '    */\n', '    function transferAny(address _from, address _to, uint256 _value) private returns (bool) {\n', '        // Iterate through all of the tokens owned, and transfer either the\n', '        // current balance of that token, or the remaining total amount to be\n', '        // transferred (`_value`), whichever is smaller. Because tokens are completely removed\n', '        // as their balances reach 0, we just run the loop until we have transferred all\n', '        // of the tokens we need to\n', '        uint256 _tokensToTransfer = _value;\n', '        while (_tokensToTransfer > 0) {\n', '            uint256 tokenId = balances[_from].tokenIndex[0];\n', '            uint256 tokenBalance = balances[_from].tokens[tokenId].amount;\n', '\n', '            if (tokenBalance >= _tokensToTransfer) {\n', '                require(internalTransfer(_from, _to, tokenId, _tokensToTransfer));\n', '                _tokensToTransfer = 0;\n', '            } else {\n', '                _tokensToTransfer = _tokensToTransfer - tokenBalance;\n', '                require(internalTransfer(_from, _to, tokenId, tokenBalance));\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Internal function for transferring a specific type of token\n', '    */\n', '    function internalTransfer(address _from, address _to, uint256 _tokenId, uint256 _value) private returns (bool) {\n', '        // Decrease the amount being sent first\n', '        removeToken(_from, _tokenId, _value);\n', '\n', '        // Increase receivers token balances\n', '        addToken(_to, _tokenId, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Transfer on behalf of another address\n', '    * @param _from address The address to send tokens from\n', '    * @param _to address The address to send tokens to\n', '    * @param _value uint256 The amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= ownershipCount[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        // Get the uint256 version of value\n', '        uint256 _castValue = uint256(_value);\n', '\n', '        // Decrease the spending limit\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        // Actually perform the transfer\n', '        require(transferAny(_from, _to, _castValue));\n', '\n', '        // Notify that a transfer has occurred\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer and stamp tokens from a mint in one step\n', '    * @param _to address To send the tokens to\n', '    * @param _tokenToStamp uint256 The token to stamp (0 is unstamped tokens)\n', '    * @param _stamp uint256 The new stamp to apply\n', '    * @param _amount uint256 The number of tokens to stamp and transfer\n', '    */\n', '    function mintTransfer(address _to, uint256 _tokenToStamp, uint256 _stamp, uint256 _amount) public\n', '        onlyStampingWhitelisted returns (bool) {\n', '        require(_to != address(0));\n', '        require(_amount <= balances[msg.sender].tokens[_tokenToStamp].amount);\n', '\n', '        // Decrease the amount being sent first\n', '        removeToken(msg.sender, _tokenToStamp, _amount);\n', '\n', '        // Increase receivers token balances\n', '        addToken(_to, _stamp, _amount);\n', '\n', '        emit MintTransfer(msg.sender, _to, _tokenToStamp, _stamp, _amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Add an address to the whitelist\n', '     * @param _addr address The address to add\n', '     */\n', '    function addToWhitelist(address _addr) public\n', '        onlyOwner {\n', '        stampingWhitelist[_addr] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove an address from the whitelist\n', '     * @param _addr address The address to remove\n', '     */\n', '    function removeFromWhitelist(address _addr) public\n', '        onlyOwner {\n', '        stampingWhitelist[_addr] = false;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Approve sent address to spend the specified amount of tokens on\n', '    * behalf of msg.sender\n', '    *\n', '    * See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * for any potential security concerns\n', '    *\n', '    * @param _spender address The address that will spend funds\n', '    * @param _value uint256 The number of tokens they are allowed to spend\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Returns the amount a spender is allowed to spend for a particular\n', '    * address\n', '    * @param _owner address The address which owns the funds\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return uint256 The number of tokens still available for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Increases the number of tokens a spender is allowed to spend for\n', '    * `msg.sender`\n', '    * @param _spender address The address of the spender\n', '    * @param _addedValue uint256 The amount to increase the spenders approval by\n', '    */\n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /** ERC 20\n', '    * @dev Decreases the number of tokens a spender is allowed to spend for\n', '    * `msg.sender`\n', '    * @param _spender address The address of the spender\n', '    * @param _subtractedValue uint256 The amount to decrease the spenders approval by\n', '    */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n', '        uint _value = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > _value) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = _value.sub(_subtractedValue);\n', '        }\n', '\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}']
