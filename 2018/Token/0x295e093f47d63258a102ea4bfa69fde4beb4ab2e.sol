['pragma solidity ^0.4.24;\n', '\n', 'contract SafeMath {\n', '\n', '  function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    uint256 z = x + y;\n', '    assert((z >= x) && (z >= y));\n', '    return z;\n', '  }\n', '\n', '  function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    assert(x >= y);\n', '    uint256 z = x - y;\n', '    return z;\n', '  }\n', '\n', '  function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    uint256 z = x * y;\n', '    assert((x == 0)||(z/x == y));\n', '    return z;\n', '  }\n', '}\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public  constant returns (uint);\n', '  function allowance(address owner, address spender) public  constant returns (uint);\n', '  function transfer(address to, uint value) public  returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public  returns (bool ok);\n', '  function approve(address spender, uint value) public  returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', 'contract StandardToken is ERC20, SafeMath {\n', '  /**\n', '  * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4) ;\n', '    _;\n', '  }\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) public  onlyPayloadSize(2 * 32)  returns (bool success){\n', '    balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public  onlyPayloadSize(3 * 32) returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSubtract(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSubtract(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public  constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public  returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public  constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public  onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '  modifier whenNotPaused() {\n', '    require (!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused {\n', '    require (paused) ;\n', '    _;\n', '  }\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    emit Pause();\n', '    return true;\n', '  }\n', '\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    emit Unpause();\n', '    return true;\n', '  }\n', '}\n', 'contract IcoToken is SafeMath, StandardToken, Pausable {\n', '  string public name;\n', '  string public symbol;\n', '  uint256 public decimals;\n', '  string public version;\n', '  address public icoContract;\n', '\n', '  constructor(\n', '    string _name,\n', '    string _symbol,\n', '    uint256 _decimals,\n', '    string _version\n', '  ) public\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '    version = _version;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public  whenNotPaused returns (bool success) {\n', '    return super.transfer(_to,_value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public  whenNotPaused returns (bool success) {\n', '    return super.approve(_spender,_value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public  constant returns (uint balance) {\n', '    return super.balanceOf(_owner);\n', '  }\n', '\n', '  function setIcoContract(address _icoContract) public onlyOwner {\n', '    if (_icoContract != address(0)) {\n', '      icoContract = _icoContract;\n', '    }\n', '  }\n', '\n', '  function sell(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {\n', '      assert(_value > 0);\n', '      require(msg.sender == icoContract);\n', '\n', '      balances[_recipient] += _value;\n', '      totalSupply += _value;\n', '\n', '      emit Transfer(0x0, owner, _value);\n', '      emit Transfer(owner, _recipient, _value);\n', '      return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract SafeMath {\n', '\n', '  function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    uint256 z = x + y;\n', '    assert((z >= x) && (z >= y));\n', '    return z;\n', '  }\n', '\n', '  function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    assert(x >= y);\n', '    uint256 z = x - y;\n', '    return z;\n', '  }\n', '\n', '  function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '    uint256 z = x * y;\n', '    assert((x == 0)||(z/x == y));\n', '    return z;\n', '  }\n', '}\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public  constant returns (uint);\n', '  function allowance(address owner, address spender) public  constant returns (uint);\n', '  function transfer(address to, uint value) public  returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public  returns (bool ok);\n', '  function approve(address spender, uint value) public  returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', 'contract StandardToken is ERC20, SafeMath {\n', '  /**\n', '  * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4) ;\n', '    _;\n', '  }\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) public  onlyPayloadSize(2 * 32)  returns (bool success){\n', '    balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public  onlyPayloadSize(3 * 32) returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSubtract(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSubtract(_allowance, _value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) public  constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public  returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public  constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public  onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '  modifier whenNotPaused() {\n', '    require (!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused {\n', '    require (paused) ;\n', '    _;\n', '  }\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    emit Pause();\n', '    return true;\n', '  }\n', '\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    emit Unpause();\n', '    return true;\n', '  }\n', '}\n', 'contract IcoToken is SafeMath, StandardToken, Pausable {\n', '  string public name;\n', '  string public symbol;\n', '  uint256 public decimals;\n', '  string public version;\n', '  address public icoContract;\n', '\n', '  constructor(\n', '    string _name,\n', '    string _symbol,\n', '    uint256 _decimals,\n', '    string _version\n', '  ) public\n', '  {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '    version = _version;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public  whenNotPaused returns (bool success) {\n', '    return super.transfer(_to,_value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public  whenNotPaused returns (bool success) {\n', '    return super.approve(_spender,_value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public  constant returns (uint balance) {\n', '    return super.balanceOf(_owner);\n', '  }\n', '\n', '  function setIcoContract(address _icoContract) public onlyOwner {\n', '    if (_icoContract != address(0)) {\n', '      icoContract = _icoContract;\n', '    }\n', '  }\n', '\n', '  function sell(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {\n', '      assert(_value > 0);\n', '      require(msg.sender == icoContract);\n', '\n', '      balances[_recipient] += _value;\n', '      totalSupply += _value;\n', '\n', '      emit Transfer(0x0, owner, _value);\n', '      emit Transfer(owner, _recipient, _value);\n', '      return true;\n', '  }\n', '\n', '}']
