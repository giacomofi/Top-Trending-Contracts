['pragma solidity ^0.4.16;\n', 'contract owned {\n', '    address public owner;\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract BillionRewardsToken is owned {\n', '    string public constant name = "BillionRewardsToken";\n', '    string public constant symbol = "BILREW";\n', '    uint public constant decimals = 8;\n', '    uint constant ONETOKEN = 10 ** uint(decimals);\n', '    uint constant MILLION = 1000000; \n', '    uint public totalSupply;\n', '    uint public Devs_Supply;\n', '    uint public Bounty_Supply;\n', '    bool public Dev_TokenReleased = false;                     \n', '    uint public Token_ExchangeValue;                             \n', '    bool public Accept_Payment;\n', '    bool public Token_Unlocked;\n', '    uint public Eth_Collected;\n', '    uint public Sold_Token;\n', '    uint public Burnt_Token;\n', '    address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28;\n', '    constructor() public {\n', '        Accept_Payment = true;\n', '        Token_Unlocked = true;\n', '        Token_ExchangeValue = 1999995 * ONETOKEN;\n', '        totalSupply = 550000 * MILLION * ONETOKEN;                        \n', '        Devs_Supply = 10000 * MILLION * ONETOKEN;                       \n', '        Bounty_Supply = 40000 * MILLION * ONETOKEN;               \n', '        totalSupply -= Devs_Supply + Bounty_Supply; \n', '        balanceOf[msg.sender] = totalSupply;                            \n', '    }\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public selfdrop_cap;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    \n', '    modifier notLocked{\n', '        require(Token_Unlocked == true || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier buyingToken{\n', '        require(Accept_Payment == true);\n', '        require(msg.sender != owner);\n', '        require(selfdrop_cap[msg.sender] + msg.value <= .1 ether);\n', '        _;\n', '    }\n', '    function unlockDevSupply() onlyOwner public {\n', '        require(now > 1640995200);                              \n', '        require(Dev_TokenReleased == false);       \n', '        balanceOf[owner] += Devs_Supply;\n', '        totalSupply += Devs_Supply;          \n', '        emit Transfer(0, this, Devs_Supply);\n', '        emit Transfer(this, owner, Devs_Supply);\n', '        Devs_Supply = 0;                                         \n', '        Dev_TokenReleased = true; \n', '    }\n', '    function send_bounty_token(address target, uint256 reward) onlyOwner public {\n', '        require(Bounty_Supply >= reward);\n', '        balanceOf[target] += reward;\n', '        totalSupply += reward;\n', '        emit Transfer(0, this, reward);\n', '        emit Transfer(this, target, reward);\n', '        Bounty_Supply -= reward;\n', '    }\n', '    function mint(address target, uint256 token) onlyOwner public {\n', '        balanceOf[target] += token;\n', '        totalSupply += token;\n', '        emit Transfer(0, this, token);\n', '        emit Transfer(this, target, token);\n', '    }\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] -= _value;            \n', '        totalSupply -= _value;\n', '        Burnt_Token += _value;\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    function _transferBilrew(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transfer(address _to, uint256 _value) notLocked public {\n', '        _transferBilrew(msg.sender, _to, _value);\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               \n', '        require (balanceOf[_from] >= _value); \n', '        require (balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '    function() payable buyingToken public {\n', '        require(msg.value > 0 ether);\n', '        require(msg.value <= .1 ether);\n', '        uint sendToken = (msg.value / .01 ether) * Token_ExchangeValue;\n', '        selfdrop_cap[msg.sender] += msg.value;\n', '        _transfer(owner, msg.sender, sendToken);\n', '        uint returnBonus = computeReturnBonus(msg.value);\n', '        if(returnBonus != 0)\n', '        {\n', '            msg.sender.transfer(returnBonus);\n', '        }\n', '        etherWallet.transfer(this.balance);\n', '        Eth_Collected += msg.value - returnBonus;\n', '        Sold_Token += sendToken;          \n', '    }\n', '    function computeReturnBonus(uint256 amount) internal constant returns (uint256) {\n', '        uint256 bonus = 0;\n', '        if(amount >= .01 ether && amount < .025 ether)\n', '        {\n', '            bonus = (amount * 10) / 100;\n', '        }\n', '        else if(amount >= .025 ether && amount < .05 ether)\n', '        {\n', '            bonus = (amount * 25) / 100;\n', '        }\n', '        else  if(amount >= .05 ether && amount < .1 ether)\n', '        {\n', '            bonus = (amount * 50) / 100;\n', '        }\n', '        else if (amount >= .1 ether)\n', '        {\n', '            bonus = (amount * 70) / 100;\n', '        }\n', '        return bonus;\n', '    }\n', '    function withdrawEther() onlyOwner public{\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function setAcceptPayment(bool status) onlyOwner public {\n', '        Accept_Payment = status;\n', '    }\n', '    function setTokenTransfer(bool status) onlyOwner public {\n', '        Token_Unlocked = status;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.16;\n', 'contract owned {\n', '    address public owner;\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract BillionRewardsToken is owned {\n', '    string public constant name = "BillionRewardsToken";\n', '    string public constant symbol = "BILREW";\n', '    uint public constant decimals = 8;\n', '    uint constant ONETOKEN = 10 ** uint(decimals);\n', '    uint constant MILLION = 1000000; \n', '    uint public totalSupply;\n', '    uint public Devs_Supply;\n', '    uint public Bounty_Supply;\n', '    bool public Dev_TokenReleased = false;                     \n', '    uint public Token_ExchangeValue;                             \n', '    bool public Accept_Payment;\n', '    bool public Token_Unlocked;\n', '    uint public Eth_Collected;\n', '    uint public Sold_Token;\n', '    uint public Burnt_Token;\n', '    address public etherWallet = 0xacEF4B8808a78BF70dbC39B8A2274d8BbfF2dB28;\n', '    constructor() public {\n', '        Accept_Payment = true;\n', '        Token_Unlocked = true;\n', '        Token_ExchangeValue = 1999995 * ONETOKEN;\n', '        totalSupply = 550000 * MILLION * ONETOKEN;                        \n', '        Devs_Supply = 10000 * MILLION * ONETOKEN;                       \n', '        Bounty_Supply = 40000 * MILLION * ONETOKEN;               \n', '        totalSupply -= Devs_Supply + Bounty_Supply; \n', '        balanceOf[msg.sender] = totalSupply;                            \n', '    }\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public selfdrop_cap;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    \n', '    modifier notLocked{\n', '        require(Token_Unlocked == true || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier buyingToken{\n', '        require(Accept_Payment == true);\n', '        require(msg.sender != owner);\n', '        require(selfdrop_cap[msg.sender] + msg.value <= .1 ether);\n', '        _;\n', '    }\n', '    function unlockDevSupply() onlyOwner public {\n', '        require(now > 1640995200);                              \n', '        require(Dev_TokenReleased == false);       \n', '        balanceOf[owner] += Devs_Supply;\n', '        totalSupply += Devs_Supply;          \n', '        emit Transfer(0, this, Devs_Supply);\n', '        emit Transfer(this, owner, Devs_Supply);\n', '        Devs_Supply = 0;                                         \n', '        Dev_TokenReleased = true; \n', '    }\n', '    function send_bounty_token(address target, uint256 reward) onlyOwner public {\n', '        require(Bounty_Supply >= reward);\n', '        balanceOf[target] += reward;\n', '        totalSupply += reward;\n', '        emit Transfer(0, this, reward);\n', '        emit Transfer(this, target, reward);\n', '        Bounty_Supply -= reward;\n', '    }\n', '    function mint(address target, uint256 token) onlyOwner public {\n', '        balanceOf[target] += token;\n', '        totalSupply += token;\n', '        emit Transfer(0, this, token);\n', '        emit Transfer(this, target, token);\n', '    }\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] -= _value;            \n', '        totalSupply -= _value;\n', '        Burnt_Token += _value;\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    function _transferBilrew(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function transfer(address _to, uint256 _value) notLocked public {\n', '        _transferBilrew(msg.sender, _to, _value);\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               \n', '        require (balanceOf[_from] >= _value); \n', '        require (balanceOf[_to] + _value >= balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '    function() payable buyingToken public {\n', '        require(msg.value > 0 ether);\n', '        require(msg.value <= .1 ether);\n', '        uint sendToken = (msg.value / .01 ether) * Token_ExchangeValue;\n', '        selfdrop_cap[msg.sender] += msg.value;\n', '        _transfer(owner, msg.sender, sendToken);\n', '        uint returnBonus = computeReturnBonus(msg.value);\n', '        if(returnBonus != 0)\n', '        {\n', '            msg.sender.transfer(returnBonus);\n', '        }\n', '        etherWallet.transfer(this.balance);\n', '        Eth_Collected += msg.value - returnBonus;\n', '        Sold_Token += sendToken;          \n', '    }\n', '    function computeReturnBonus(uint256 amount) internal constant returns (uint256) {\n', '        uint256 bonus = 0;\n', '        if(amount >= .01 ether && amount < .025 ether)\n', '        {\n', '            bonus = (amount * 10) / 100;\n', '        }\n', '        else if(amount >= .025 ether && amount < .05 ether)\n', '        {\n', '            bonus = (amount * 25) / 100;\n', '        }\n', '        else  if(amount >= .05 ether && amount < .1 ether)\n', '        {\n', '            bonus = (amount * 50) / 100;\n', '        }\n', '        else if (amount >= .1 ether)\n', '        {\n', '            bonus = (amount * 70) / 100;\n', '        }\n', '        return bonus;\n', '    }\n', '    function withdrawEther() onlyOwner public{\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function setAcceptPayment(bool status) onlyOwner public {\n', '        Accept_Payment = status;\n', '    }\n', '    function setTokenTransfer(bool status) onlyOwner public {\n', '        Token_Unlocked = status;\n', '    }\n', '    \n', '}']
