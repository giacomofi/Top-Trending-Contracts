['pragma solidity ^0.4.10;\n', '\n', 'contract ERC20Interface {\n', '    uint public totalSupply;\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Administrable {\n', '    address admin;\n', '    bool public inMaintenance;\n', '    \n', '    function Administrable() {\n', '        admin = msg.sender;\n', '        inMaintenance = true;\n', '    }\n', '    \n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '    \n', '    modifier checkMaintenance() {\n', '        require(!inMaintenance);\n', '        _;\n', '    }\n', '    \n', '    function setMaintenance(bool inMaintenance_) onlyAdmin {\n', '        inMaintenance = inMaintenance_;\n', '    }\n', '    \n', '    function kill() onlyAdmin {\n', '        selfdestruct(admin);\n', '    }\n', '}\n', '\n', 'contract ApisMelliferaToken is ERC20Interface, Administrable {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    string public constant name = "Apis Mellifera Token";\n', '    string public constant symbol = "APIS";\n', '    uint8 public constant decimals = 18;\n', '    \n', '    function balanceOf(address _owner) constant returns (uint256) { \n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        // mitigates the ERC20 short address attack\n', '        if(msg.data.length < (2 * 32) + 4) { \n', '            throw;\n', '        }\n', '\n', '        if (_value == 0) { \n', '            return false;\n', '        }\n', '\n', '        uint256 fromBalance = balances[msg.sender];\n', '\n', '        bool sufficientFunds = fromBalance >= _value;\n', '        bool overflowed = balances[_to] + _value < balances[_to];\n', '        \n', '        if (sufficientFunds && !overflowed) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            \n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false; \n', '            \n', '        }\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        // mitigates the ERC20 short address attack\n', '        if(msg.data.length < (3 * 32) + 4) { \n', '            throw;\n', '        }\n', '\n', '        if (_value == 0) {\n', '            return false;\n', '        }\n', '        \n', '        uint256 fromBalance = balances[_from];\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '\n', '        bool sufficientFunds = fromBalance <= _value;\n', '        bool sufficientAllowance = allowance <= _value;\n', '        bool overflowed = balances[_to] + _value > balances[_to];\n', '\n', '        if (sufficientFunds && sufficientAllowance && !overflowed) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            \n', '            allowed[_from][msg.sender] -= _value;\n', '            \n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        // mitigates the ERC20 spend/approval race condition\n', '        if (_value != 0 && allowed[msg.sender][_spender] != 0) {\n', '            return false;\n', '        }\n', '        \n', '        allowed[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function withdraw(uint amount) onlyAdmin {\n', '        admin.transfer(amount);\n', '    }\n', '\n', '    function mint(uint amount) onlyAdmin {\n', '        totalSupply += amount;\n', '        balances[msg.sender] += amount;\n', '        Transfer(address(this), msg.sender, amount);\n', '    }\n', '\n', '    function() payable checkMaintenance {\n', '        if (msg.value == 0) {\n', '            return;\n', '        }\n', '        uint tokens = msg.value * 1000;\n', '        totalSupply += tokens;\n', '        balances[msg.sender] += tokens;\n', '        Transfer(address(this), msg.sender, tokens);\n', '    }\n', '}']