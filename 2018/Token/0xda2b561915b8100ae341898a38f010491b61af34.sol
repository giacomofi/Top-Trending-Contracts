['pragma solidity ^0.4.19;\n', '\n', 'interface FsTKAuthority {\n', '  function isAuthorized(address sender, address _contract, bytes data) external view returns (bool);\n', '  function validate() external pure returns (bool);\n', '}\n', '\n', 'interface ServiceProvider {\n', '  function serviceFallback(address from, uint256 value, bytes data, uint256 gas) external;\n', '}\n', '\n', 'interface TokenReceiver {\n', '  function tokenFallback(address from, uint256 value, bytes data) external;\n', '}\n', '\n', 'interface ERC20 {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function balanceOf(address owner) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface FsTKToken {\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '  event CancelSubscription(address indexed from, address indexed to);\n', '  event Subscribe(address indexed from, address indexed to, uint256 startTime, uint256 interval, uint256 amount);\n', '\n', '  function transfer(address to, uint value, bytes data) external returns (bool);\n', '\n', '  function buyService(ServiceProvider service, uint256 value, bytes data) external;\n', '  function transfer(uint256[] data) external;\n', '  function approve(address spender, uint256 expectedValue, uint256 newValue) external;\n', '  function increaseAllowance(address spender, uint256 value) external;\n', '  function decreaseAllowance(address spender, uint256 value) external;\n', '  function decreaseAllowanceOrEmtpy(address spender, uint256 value) external;\n', '}\n', '\n', 'library AddressExtension {\n', '\n', '  function isValid(address _address) internal pure returns (bool) {\n', '    return 0 != _address;\n', '  }\n', '\n', '  function isAccount(address _address) internal view returns (bool result) {\n', '    assembly {\n', '      result := iszero(extcodesize(_address))\n', '    }\n', '  }\n', '\n', '  function toBytes(address _address) internal pure returns (bytes b) {\n', '   assembly {\n', '      let m := mload(0x40)\n', '      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n', '      mstore(0x40, add(m, 52))\n', '      b := m\n', '    }\n', '  }\n', '}\n', '\n', 'library Math {\n', '  struct Fraction {\n', '    uint256 numerator;\n', '    uint256 denominator;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a * b;\n', '    require((a == 0) || (r / a == b));\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a - b) <= a);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a + b) >= a);\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x <= y ? x : y;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x >= y ? x : y;\n', '  }\n', '\n', '  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // fast path\n', '    if (value == 0 || m == 0) {\n', '      return 0;\n', '    }\n', '\n', '    r = value * m;\n', '    // if mul not overflow\n', '    if (r / value == m) {\n', '      r /= d;\n', '    } else {\n', '      // else div first\n', '      r = mul(value / d, m);\n', '    }\n', '  }\n', '\n', '  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.denominator, f.numerator);\n', '  }\n', '}\n', '\n', 'contract FsTKAllocation {\n', '  // vested 10% total supply of FST for core team members for 4 years\n', '  uint256 public constant VESTED_AMOUNT = 5500000 * (10 ** 18);  \n', '  uint256 public constant VESTED_AMOUNT_TOTAL = VESTED_AMOUNT * 6;\n', '  uint256 public constant RELEASE_EPOCH = 1642032000;\n', '  ERC20 public token;\n', '\n', '  function initialize() public {\n', '    require(address(token) == 0);\n', '    token = ERC20(msg.sender);\n', '  }\n', '\n', '  function () external {\n', '    require(\n', '      token.transfer(0x808b0730252DAA3a12CadC72f42E46E92a5e1bC8, VESTED_AMOUNT) &&                                true && true && true && true && true &&                  token.transfer(0xdA01fAFaF5E49e9467f99f5969cab499a5759cC6, VESTED_AMOUNT) &&\n', '      token.transfer(0xddab6c29090E6111A490527614Ceac583D02C8De, VESTED_AMOUNT) &&                         true && true && true && true && true && true &&                 token.transfer(0x5E6C9EC32b088c9FA1Fc0FEFa38A9B4De4169316, VESTED_AMOUNT) &&\n', '      true&&                                                                                            true &&                                                                                               true&&\n', '      true&&                                                                                          true &&                                                                                                 true&&\n', '      true&&                                                                                       true &&                                                                                                    true&&\n', '      true&&                                                                                     true &&                                                                                                      true&&\n', '      true&&                                                                                   true &&                                                                                                        true&&\n', '      true&&                                                                                  true &&                                                                                                         true&&\n', '      true&&                                                                                 true &&                                                                                                          true&&\n', '      true&&                                                                                 true &&                                                                                                          true&&\n', '      true&&                                                                                true &&                                                                                                           true&&\n', '      true&&                                                                                true &&                                                                                                           true&&\n', '      true&&                                                                                true &&                                                                                                           true&&\n', '      true&&                                                                                 true &&                                                                                                          true&&\n', '      true&&                                                                                  true &&                                                                                                         true&&\n', '      true&&                                                                                   true &&                                                                                                        true&&\n', '      token.transfer(0xFFB5d7C71e8680D0e9482e107F019a2b25D225B5,VESTED_AMOUNT)&&                true &&                                                                                                       true&&\n', '      token.transfer(0x91cE537b1a8118Aa20Ef7F3093697a7437a5Dc4B,VESTED_AMOUNT)&&                  true &&                                                                                                     true&&\n', '      true&&                                                                                         true &&                                                                                                  true&&\n', '      true&&                                                                                            block.timestamp >= RELEASE_EPOCH && true &&                                                           true&&\n', '      true&&                                                                                                   true && true && true && true && true &&                                                        true&&\n', '      true&&                                                                                                                                     true &&                                                      true&&\n', '      true&&                                                                                                                                       true &&                                                    true&&\n', '      true&&                                                                                                                                          true &&                                                 true&&\n', '      true&&                                                                                                                                            true &&                                               true&&\n', '      true&&                                                                                                                                             true &&                                              true&&\n', '      true&&                                                                                                                                              true &&                                             true&&\n', '      true&&                                                                                                                                               true &&                                            true&&\n', '      true&&                                                                                                                                                true &&                                           true&&\n', '      true&&                                                                                                                                                true &&                                           true&&\n', '      true&&                                                                                                                                                true &&                                           true&&\n', '      true&&                                                                                                                                               true &&                                            true&&\n', '      true&&                                                                                                                                              true &&                                             true&&\n', '      true&&                                                                                                                                             true &&                                              true&&\n', '      true&&                                                                                                                                           true &&                                                true&&\n', '      true&&                                                                                                                                         true &&                                                  true&&\n', '      true&&                                                                                                                                       true &&                                                    true&&\n', '      true&&                                                                                             true && true && true && true && true && true &&                                                      true&&\n', '      true&&                                                                                          true && true && true && true && true && true &&                                                          true\n', '    );\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Authorizable {\n', '  using AddressExtension for address;\n', '\n', '  event FsTKAuthorityChanged(address indexed _address);\n', '\n', '  modifier onlyFsTKAuthorized {\n', '    require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n', '    _;\n', '  }\n', '\n', '  FsTKAuthority internal fstkAuthority;\n', '\n', '  function Authorizable(FsTKAuthority _fstkAuthority) internal {\n', '    require(_fstkAuthority.validate());\n', '    FsTKAuthorityChanged(fstkAuthority = _fstkAuthority);\n', '  }\n', '\n', '  function changeFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n', '    require(_fstkAuthority.validate());\n', '    FsTKAuthorityChanged(fstkAuthority = _fstkAuthority);\n', '  }\n', '}\n', '\n', 'contract AbstractToken is ERC20, FsTKToken {\n', '  using AddressExtension for address;\n', '  using Math for uint256;\n', '\n', '  struct Subscription {\n', '    uint256 amount;\n', '    uint256 startTime;\n', '    uint256 interval;\n', '    uint256 epoch;\n', '    uint256 collectTime;\n', '  }\n', '\n', '  struct Account {\n', '    uint256 balance;\n', '    mapping (address => uint256) allowances;\n', '    mapping (address => Subscription) subscriptions;\n', '  }\n', '\n', '  modifier liquid {\n', '    require(isLiquid);\n', '     _;\n', '  }\n', '\n', '  bool public isLiquid = true;\n', '  bool public erc20ApproveChecking;\n', '  mapping(address => Account) internal accounts;\n', '\n', '  // *************************\n', '  // * ERC 20\n', '  // *************************\n', '\n', '  function balanceOf(address owner) external view returns (uint256) {\n', '    return accounts[owner].balance;\n', '  }\n', '\n', '  function allowance(address owner, address spender) external view returns (uint256) {\n', '    return accounts[owner].allowances[spender];\n', '  }\n', '\n', '  function transfer(address to, uint256 value) external liquid returns (bool) {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    require(value <= senderAccount.balance);\n', '\n', '    senderAccount.balance -= value;\n', '    accounts[to].balance += value;\n', '\n', '    Transfer(msg.sender, to, value);\n', '    Transfer(msg.sender, to, value, new bytes(0));\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) external liquid returns (bool) {\n', '    Account storage fromAccount = accounts[from];\n', '    require(value <= fromAccount.balance && value <= fromAccount.allowances[msg.sender]);\n', '\n', '    fromAccount.balance -= value;\n', '    fromAccount.allowances[msg.sender] -= value;\n', '    accounts[to].balance += value;\n', '\n', '    Transfer(from, to, value);\n', '    Transfer(from, to, value, new bytes(0));\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint256 value) external returns (bool) {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    if (erc20ApproveChecking) {\n', '      require((value == 0) || (senderAccount.allowances[spender] == 0));\n', '    }\n', '    senderAccount.allowances[spender] = value;\n', '\n', '    Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  // *************************\n', '  // * FsTK Token\n', '  // *************************\n', '\n', '  function transfer(address to, uint256 value, bytes data) external liquid returns (bool) {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    require(value <= senderAccount.balance);\n', '\n', '    senderAccount.balance -= value;\n', '    accounts[to].balance += value;\n', '\n', '    Transfer(msg.sender, to, value);\n', '    Transfer(msg.sender, to, value, data);\n', '\n', '    if (!to.isAccount()) {\n', '      TokenReceiver(to).tokenFallback(msg.sender, value, data);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function buyService(ServiceProvider service, uint256 value, bytes data) external liquid {\n', '    uint256 gas = msg.gas;\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 currentValue = senderAccount.allowances[service];\n', '    senderAccount.allowances[service] = currentValue.add(value);\n', '    service.serviceFallback(msg.sender, value, data, gas);\n', '    senderAccount.allowances[service] = currentValue;\n', '  }\n', '\n', '  function transfer(uint256[] data) external liquid {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    for (uint256 i = 0; i < data.length; i++) {\n', '      address receiver = address(data[i] >> 96);\n', '      uint256 value = data[i] & 0xffffffffffffffffffffffff;\n', '      require(value <= senderAccount.balance);\n', '\n', '      senderAccount.balance -= value;\n', '      accounts[receiver].balance += value;\n', '\n', '      Transfer(msg.sender, receiver, value);\n', '      Transfer(msg.sender, receiver, value, new bytes(0));\n', '    }\n', '  }\n', '\n', '  function subscriptionOf(address owner, address collector) external view returns (Subscription) {\n', '    return accounts[owner].subscriptions[collector];\n', '  }\n', '\n', '  function subscribe(address collector, uint256 startTime, uint256 interval, uint256 amount) external {\n', '    accounts[msg.sender].subscriptions[collector] = Subscription({\n', '      startTime: startTime,\n', '      interval: interval,\n', '      amount: amount,\n', '      epoch: 0,\n', '      collectTime: 0\n', '    });\n', '    Subscribe(msg.sender, collector, startTime, interval, amount);\n', '  }\n', '\n', '  function cancelSubscription(address collector) external {\n', '    delete accounts[msg.sender].subscriptions[collector];\n', '    CancelSubscription(msg.sender, collector);\n', '  }\n', '\n', '  function collect(address from) external {\n', '    Account storage fromAccount = accounts[from];\n', '    Subscription storage info = fromAccount.subscriptions[msg.sender];\n', '    uint256 epoch = (block.timestamp.sub(info.startTime)) / info.interval + 1;\n', '    require(info.amount > 0 && epoch > info.epoch);\n', '    uint256 totalAmount = (epoch - info.epoch).mul(info.amount);\n', '    if (totalAmount > fromAccount.balance) {\n', '      delete fromAccount.subscriptions[msg.sender];\n', '      CancelSubscription(from, msg.sender);\n', '    } else {\n', '      info.collectTime = block.timestamp;\n', '      fromAccount.balance -= totalAmount;\n', '      accounts[msg.sender].balance += totalAmount;\n', '\n', '      Transfer(from, msg.sender, totalAmount);\n', '      Transfer(from, msg.sender, totalAmount, new bytes(0));\n', '    }\n', '  }\n', '\n', '  function collect(address[] froms) external {\n', '    for (uint256 i = 0; i < froms.length; i++) {\n', '      address from = froms[i];\n', '      Account storage fromAccount = accounts[from];\n', '      Subscription storage info = fromAccount.subscriptions[msg.sender];\n', '      uint256 epoch = (block.timestamp.sub(info.startTime)) / info.interval + 1;\n', '      require(info.amount > 0 && epoch > info.epoch);\n', '      uint256 totalAmount = (epoch - info.epoch).mul(info.amount);\n', '      if (totalAmount > fromAccount.balance) {\n', '        delete fromAccount.subscriptions[msg.sender];\n', '        CancelSubscription(from, msg.sender);\n', '      } else {\n', '        info.collectTime = block.timestamp;\n', '        fromAccount.balance -= totalAmount;\n', '        accounts[msg.sender].balance += totalAmount;\n', '  \n', '        Transfer(from, msg.sender, totalAmount);\n', '        Transfer(from, msg.sender, totalAmount, new bytes(0));\n', '      }\n', '    }\n', '  }\n', '\n', '  function approve(address spender, uint256 expectedValue, uint256 newValue) external {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    require(senderAccount.allowances[spender] == expectedValue);\n', '\n', '    senderAccount.allowances[spender] = newValue;\n', '\n', '    Approval(msg.sender, spender, newValue);\n', '  }\n', '\n', '  function increaseAllowance(address spender, uint256 value) external {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 newValue = senderAccount.allowances[spender].add(value);\n', '    senderAccount.allowances[spender] = newValue;\n', '\n', '    Approval(msg.sender, spender, newValue);\n', '  }\n', '\n', '  function decreaseAllowance(address spender, uint256 value) external {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 newValue = senderAccount.allowances[spender].sub(value);\n', '    senderAccount.allowances[spender] = newValue;\n', '\n', '    Approval(msg.sender, spender, newValue);\n', '  }\n', '\n', '  function decreaseAllowanceOrEmtpy(address spender, uint256 value) external {\n', '    Account storage senderAccount = accounts[msg.sender];\n', '    uint256 currentValue = senderAccount.allowances[spender];\n', '    uint256 newValue;\n', '    if (value < currentValue) {\n', '      newValue = currentValue - value;\n', '    }\n', '    senderAccount.allowances[spender] = newValue;\n', '\n', '    Approval(msg.sender, spender, newValue);\n', '  }\n', '\n', '  function setLiquid(bool _isLiquid) public {\n', '    isLiquid = _isLiquid;\n', '  }\n', '\n', '  function setERC20ApproveChecking(bool _erc20ApproveChecking) public {\n', '    erc20ApproveChecking = _erc20ApproveChecking;\n', '  }\n', '}\n', '\n', 'contract FunderSmartToken is AbstractToken, Authorizable {\n', '  string public constant name = "Funder Smart Token";\n', '  string public constant symbol = "FST";\n', '  uint256 public constant totalSupply = 330000000 * (10 ** 18);\n', '  uint8 public constant decimals = 18;\n', '\n', '  function FunderSmartToken(FsTKAuthority _fstkAuthority, address fstkWallet, FsTKAllocation allocation) Authorizable(_fstkAuthority) public {\n', '    // vested 10% total supply of FST for core team members for 4 years\n', '    uint256 vestedAmount = allocation.VESTED_AMOUNT_TOTAL();\n', '    accounts[allocation].balance = vestedAmount;\n', '    allocation.initialize();     \n', '    Transfer(address(0), allocation, vestedAmount);\n', '    Transfer(address(0), allocation, vestedAmount, new bytes(0));\n', '\n', '    uint256 releaseAmount = totalSupply - vestedAmount;\n', '    accounts[fstkWallet].balance = releaseAmount;\n', '    Transfer(address(0), fstkWallet, releaseAmount);\n', '    Transfer(address(0), fstkWallet, releaseAmount, new bytes(0));\n', '  }\n', '\n', '  function setLiquid(bool _isLiquid) public onlyFsTKAuthorized {\n', '    AbstractToken.setLiquid(_isLiquid);\n', '  }\n', '\n', '  function setERC20ApproveChecking(bool _erc20ApproveChecking) public onlyFsTKAuthorized {\n', '    AbstractToken.setERC20ApproveChecking(_erc20ApproveChecking);\n', '  }\n', '\n', '  function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\n', '    erc20.transfer(to, value);\n', '  }\n', '}']