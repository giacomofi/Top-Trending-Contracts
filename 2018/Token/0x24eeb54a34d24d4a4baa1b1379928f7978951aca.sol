['pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'GPYX' token contract\n", '//\n', '// Deployed to : 0x6610F23DfC2a3DD959460c8EC04260629F55D28D\n', '// Symbol      : GPYX\n', '// Name        : PyrexCoin Platform service token\n', '// Total supply: 10000000\n', '// Decimals    : 18\n', '//\n', '// Enjoy.\n', '//\n', '// (c) by ILIK. \n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'interface tokenRecipient {function receiveApproval (address _from, uint256 _value, address _token, bytes _extradata) external;}\n', 'contract owned {\n', '    address public owner;\n', '    \n', '    constructor()public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '        \n', '    }\n', '    function transferOwnership (address newOwner)public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '}\n', 'contract GPYX is owned{\n', ' string public Name;\n', ' string public Symbol;\n', ' uint8 public decimals = 18;  \n', ' uint256 public totalSupply;\n', ' mapping (address => uint256) public balanceOf;\n', ' mapping(address => mapping(address=> uint256)) public allowance;\n', ' mapping(address => bool) public frozenAccount;\n', ' \n', ' \n', ' event Transfer ( address indexed from, address indexed to, uint256 value);\n', ' event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', ' event Burn(address indexed from, uint256 value);\n', ' event FrozenFunds(address target, bool frozen);\n', ' \n', '    constructor (\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '        ) public {\n', '            totalSupply = initialSupply*10**uint256(decimals);\n', '            balanceOf[msg.sender] = totalSupply;\n', '            Name = tokenName;\n', '            Symbol = tokenSymbol;\n', '            \n', '        }\n', '        function _transfer(address _from, address _to, uint _value) internal{\n', '            require(_to != 0x0);\n', '            require(balanceOf[_from] >=_value);\n', '            require(balanceOf[_to] +_value >= balanceOf[_to]);\n', '            require(!frozenAccount[msg.sender]);\n', '            \n', '            uint previousBalances = balanceOf[_from ] + balanceOf[_to];\n', '            \n', '            balanceOf[_from] -= _value;\n', '            balanceOf[_to] += _value;\n', '            emit Transfer (_from, _to, _value);\n', '            assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '            \n', '        }\n', '        function transfer(address _to, uint256 _value) public returns (bool success) {\n', '            _transfer(msg.sender, _to, _value);\n', '            return true;\n', '            \n', '        }\n', '        \n', '        function trasferFrom (address _from, address _to, uint256 _value) public returns(bool success)\n', '        {\n', '            \n', '            require(_value <=allowance[_from][msg.sender]);\n', '            allowance[_from][msg.sender] -=_value;\n', '            _transfer(_from,_to, _value);\n', '            return true;\n', '            \n', '        }\n', '        function approve (address _spender, uint256 _value) onlyOwner public\n', '        returns (bool success){\n', '            allowance[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '            \n', '        }\n', '        \n', '        function approveAndCall(address _spender, uint256 _value, bytes _extradata) public returns (bool success){\n', '            tokenRecipient spender = tokenRecipient(_spender);\n', '            \n', '            if(approve(_spender,_value)){\n', '                spender.receiveApproval(msg.sender, _value, this, _extradata);\n', '                return true;\n', '            }\n', '            \n', '        }\n', '        function burn (uint256 _value) onlyOwner public returns (bool success){\n', '            require(balanceOf[msg.sender] >= _value);\n', '            balanceOf[msg.sender] -= _value;\n', '            totalSupply -= _value;\n', '            emit Burn(msg.sender, _value);\n', '            return true;\n', '        }\n', '        function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success){\n', '            \n', '            require(balanceOf[_from] >= _value);\n', '\t\t\t\n', '\trequire(_value <= allowance[_from][msg.sender]);\n', '            \n', '            balanceOf[_from] -= _value;\n', '            totalSupply -= _value;\n', '            emit Burn(msg.sender, _value);\n', '            \n', '            return true;\n', '        }\n', '        \n', '        function freezeAccount (address target, bool freeze)public onlyOwner {\n', '            frozenAccount[target] = freeze;\n', '            emit FrozenFunds (target, freeze);\n', '            \n', '            \n', '        }\n', '        \n', '}']