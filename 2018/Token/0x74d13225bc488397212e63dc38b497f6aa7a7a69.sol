['pragma solidity ^0.4.18;\n', '\n', 'contract CoinStacks {\n', '\n', '  // Contract owner\n', '  address private admin;\n', '\n', '  // Game parameters\n', '  uint256 private constant BOTTOM_LAYER_BET = 0.005 ether;\n', '  uint16 private constant INITIAL_UNLOCKED_COLUMNS = 10;\n', '  uint256 private maintenanceFeePercent;\n', '  uint private  NUM_COINS_TO_HIT_JACKPOT = 30; // every 30th coin placed win a prize\n', '  uint private MIN_AVG_HEIGHT = 5;\n', '  uint256 private constant JACKPOT_PRIZE = 2 * BOTTOM_LAYER_BET;\n', '\n', '  // Coin stack data representation\n', '  //\n', '  // coordinates are represented by a uint32\n', '  // where the first 16 bits represents the _x value as a 16-bit unsigned int\n', '  // where the second 16 bits represents the _y value as a 16-bit unsigned int\n', '  // For example 0x0010000B corresponse to (_x,_y) = (0x10,0xB) = (16,11)\n', '  // Decoding from _coord to (_x,_y):\n', '  // _x = _coord >> 16\n', '  // _y = _coord & 0xFFFF\n', '  // Encoding (_x,_y) to _coord:\n', '  // _coord = (_x << 16) | _y\n', '\n', '  mapping(uint32 => address) public coordinatesToAddresses;\n', '  uint32[] public coinCoordinates;\n', '\n', '  // Prize\n', '  uint256 public reserveForJackpot;\n', '\n', '  // withdrawable address balance\n', '  mapping(address => uint256) public balances;\n', '\n', '  // Event\n', '  event coinPlacedEvent (\n', '    uint32 _coord,\n', '    address indexed _coinOwner\n', '  );\n', '\n', '  function CoinStacks() public {\n', '    admin = msg.sender;\n', '    maintenanceFeePercent = 1; // Default fee is 1%\n', '    reserveForJackpot = 0;\n', '\n', '    // Set the first coin at the leftmost of the bottom row (0,0)\n', '    coordinatesToAddresses[uint32(0)] = admin;\n', '    coinCoordinates.push(uint32(0));\n', '    coinPlacedEvent(uint32(0),admin);\n', '  }\n', '\n', '  function isThereACoinAtCoordinates(uint16 _x, uint16 _y) public view returns (bool){\n', '    return coordinatesToAddresses[(uint32(_x) << 16) | uint16(_y)] != 0;\n', '  }\n', '\n', '  function getNumCoins() external view returns (uint){\n', '    return coinCoordinates.length;\n', '  }\n', '\n', '  function getAllCoins() external view returns (uint32[]){\n', '    return coinCoordinates;\n', '  }\n', '\n', '  function placeCoin(uint16 _x, uint16 _y) external payable{\n', '    // check no coin has been placed at (_x,_y)\n', '    require(!isThereACoinAtCoordinates(_x,_y));\n', '    // check the coin below has been placed\n', '    require(_y==0 || isThereACoinAtCoordinates(_x,_y-1));\n', '    // cannot place to locked column\n', '    require(_x<INITIAL_UNLOCKED_COLUMNS || coinCoordinates.length >= MIN_AVG_HEIGHT * _x);\n', '\n', '    uint256 betAmount = BOTTOM_LAYER_BET * (uint256(1) << _y); // * pow(2,_y)\n', '\n', '    // check if the user has enough balance to place the current coin\n', '    require(balances[msg.sender] + msg.value >= betAmount);\n', '\n', '    // Add the transaction amount to the user&#39;s balance\n', '    // and deduct current coin cost from user&#39;s balance\n', '    balances[msg.sender] += (msg.value - betAmount);\n', '\n', '    uint32 coinCoord = (uint32(_x) << 16) | uint16(_y);\n', '\n', '    coinCoordinates.push(coinCoord);\n', '    coordinatesToAddresses[coinCoord] = msg.sender;\n', '\n', '    if(_y==0) { // placing a coin in the bottom layer\n', '      if(reserveForJackpot < JACKPOT_PRIZE) { // goes to jackpot reserve\n', '        reserveForJackpot += BOTTOM_LAYER_BET;\n', '      } else { // otherwise goes to admin\n', '        balances[admin]+= BOTTOM_LAYER_BET;\n', '      }\n', '    } else { // reward the owner of the coin below, minus maintenance fee\n', '      uint256 adminFee = betAmount * maintenanceFeePercent /100;\n', '      balances[coordinatesToAddresses[(uint32(_x) << 16) | _y-1]] +=\n', '        (betAmount - adminFee);\n', '      balances[admin] += adminFee;\n', '    }\n', '\n', '    // hitting jackpot: send jackpot prize if this is every 30 th coin\n', '    if(coinCoordinates.length % NUM_COINS_TO_HIT_JACKPOT == 0){\n', '      balances[msg.sender] += reserveForJackpot;\n', '      reserveForJackpot = 0;\n', '    }\n', '\n', '    //trigger the event\n', '    coinPlacedEvent(coinCoord,msg.sender);\n', '  }\n', '\n', '  // Withdrawing balance\n', '  function withdrawBalance(uint256 _amountToWithdraw) external{\n', '    require(_amountToWithdraw != 0);\n', '    require(balances[msg.sender] >= _amountToWithdraw);\n', '    // Subtract the withdrawn amount from the user&#39;s balance\n', '    balances[msg.sender] -= _amountToWithdraw;\n', '\n', '    msg.sender.transfer(_amountToWithdraw);\n', '  }\n', '\n', '  //transfer ownership of the contract\n', '  function transferOwnership(address _newOwner) external {\n', '    require (msg.sender == admin);\n', '    admin = _newOwner;\n', '  }\n', '\n', '  //change maintenance fee\n', '  function setFeePercent(uint256 _newPercent) external {\n', '    require (msg.sender == admin);\n', '    if(_newPercent<=2) // Fee will never exceed 2%\n', '      maintenanceFeePercent = _newPercent;\n', '  }\n', '\n', '  //fallback function for handling unexpected payment\n', '  function() external payable{\n', '    //if any ether is sent to the address, credit the admin balance\n', '    balances[admin] += msg.value;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract CoinStacks {\n', '\n', '  // Contract owner\n', '  address private admin;\n', '\n', '  // Game parameters\n', '  uint256 private constant BOTTOM_LAYER_BET = 0.005 ether;\n', '  uint16 private constant INITIAL_UNLOCKED_COLUMNS = 10;\n', '  uint256 private maintenanceFeePercent;\n', '  uint private  NUM_COINS_TO_HIT_JACKPOT = 30; // every 30th coin placed win a prize\n', '  uint private MIN_AVG_HEIGHT = 5;\n', '  uint256 private constant JACKPOT_PRIZE = 2 * BOTTOM_LAYER_BET;\n', '\n', '  // Coin stack data representation\n', '  //\n', '  // coordinates are represented by a uint32\n', '  // where the first 16 bits represents the _x value as a 16-bit unsigned int\n', '  // where the second 16 bits represents the _y value as a 16-bit unsigned int\n', '  // For example 0x0010000B corresponse to (_x,_y) = (0x10,0xB) = (16,11)\n', '  // Decoding from _coord to (_x,_y):\n', '  // _x = _coord >> 16\n', '  // _y = _coord & 0xFFFF\n', '  // Encoding (_x,_y) to _coord:\n', '  // _coord = (_x << 16) | _y\n', '\n', '  mapping(uint32 => address) public coordinatesToAddresses;\n', '  uint32[] public coinCoordinates;\n', '\n', '  // Prize\n', '  uint256 public reserveForJackpot;\n', '\n', '  // withdrawable address balance\n', '  mapping(address => uint256) public balances;\n', '\n', '  // Event\n', '  event coinPlacedEvent (\n', '    uint32 _coord,\n', '    address indexed _coinOwner\n', '  );\n', '\n', '  function CoinStacks() public {\n', '    admin = msg.sender;\n', '    maintenanceFeePercent = 1; // Default fee is 1%\n', '    reserveForJackpot = 0;\n', '\n', '    // Set the first coin at the leftmost of the bottom row (0,0)\n', '    coordinatesToAddresses[uint32(0)] = admin;\n', '    coinCoordinates.push(uint32(0));\n', '    coinPlacedEvent(uint32(0),admin);\n', '  }\n', '\n', '  function isThereACoinAtCoordinates(uint16 _x, uint16 _y) public view returns (bool){\n', '    return coordinatesToAddresses[(uint32(_x) << 16) | uint16(_y)] != 0;\n', '  }\n', '\n', '  function getNumCoins() external view returns (uint){\n', '    return coinCoordinates.length;\n', '  }\n', '\n', '  function getAllCoins() external view returns (uint32[]){\n', '    return coinCoordinates;\n', '  }\n', '\n', '  function placeCoin(uint16 _x, uint16 _y) external payable{\n', '    // check no coin has been placed at (_x,_y)\n', '    require(!isThereACoinAtCoordinates(_x,_y));\n', '    // check the coin below has been placed\n', '    require(_y==0 || isThereACoinAtCoordinates(_x,_y-1));\n', '    // cannot place to locked column\n', '    require(_x<INITIAL_UNLOCKED_COLUMNS || coinCoordinates.length >= MIN_AVG_HEIGHT * _x);\n', '\n', '    uint256 betAmount = BOTTOM_LAYER_BET * (uint256(1) << _y); // * pow(2,_y)\n', '\n', '    // check if the user has enough balance to place the current coin\n', '    require(balances[msg.sender] + msg.value >= betAmount);\n', '\n', "    // Add the transaction amount to the user's balance\n", "    // and deduct current coin cost from user's balance\n", '    balances[msg.sender] += (msg.value - betAmount);\n', '\n', '    uint32 coinCoord = (uint32(_x) << 16) | uint16(_y);\n', '\n', '    coinCoordinates.push(coinCoord);\n', '    coordinatesToAddresses[coinCoord] = msg.sender;\n', '\n', '    if(_y==0) { // placing a coin in the bottom layer\n', '      if(reserveForJackpot < JACKPOT_PRIZE) { // goes to jackpot reserve\n', '        reserveForJackpot += BOTTOM_LAYER_BET;\n', '      } else { // otherwise goes to admin\n', '        balances[admin]+= BOTTOM_LAYER_BET;\n', '      }\n', '    } else { // reward the owner of the coin below, minus maintenance fee\n', '      uint256 adminFee = betAmount * maintenanceFeePercent /100;\n', '      balances[coordinatesToAddresses[(uint32(_x) << 16) | _y-1]] +=\n', '        (betAmount - adminFee);\n', '      balances[admin] += adminFee;\n', '    }\n', '\n', '    // hitting jackpot: send jackpot prize if this is every 30 th coin\n', '    if(coinCoordinates.length % NUM_COINS_TO_HIT_JACKPOT == 0){\n', '      balances[msg.sender] += reserveForJackpot;\n', '      reserveForJackpot = 0;\n', '    }\n', '\n', '    //trigger the event\n', '    coinPlacedEvent(coinCoord,msg.sender);\n', '  }\n', '\n', '  // Withdrawing balance\n', '  function withdrawBalance(uint256 _amountToWithdraw) external{\n', '    require(_amountToWithdraw != 0);\n', '    require(balances[msg.sender] >= _amountToWithdraw);\n', "    // Subtract the withdrawn amount from the user's balance\n", '    balances[msg.sender] -= _amountToWithdraw;\n', '\n', '    msg.sender.transfer(_amountToWithdraw);\n', '  }\n', '\n', '  //transfer ownership of the contract\n', '  function transferOwnership(address _newOwner) external {\n', '    require (msg.sender == admin);\n', '    admin = _newOwner;\n', '  }\n', '\n', '  //change maintenance fee\n', '  function setFeePercent(uint256 _newPercent) external {\n', '    require (msg.sender == admin);\n', '    if(_newPercent<=2) // Fee will never exceed 2%\n', '      maintenanceFeePercent = _newPercent;\n', '  }\n', '\n', '  //fallback function for handling unexpected payment\n', '  function() external payable{\n', '    //if any ether is sent to the address, credit the admin balance\n', '    balances[admin] += msg.value;\n', '  }\n', '}']
