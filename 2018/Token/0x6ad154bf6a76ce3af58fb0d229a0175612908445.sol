['contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract Lockable is Owned {\n', '\n', '    uint256 public lockedUntilBlock;\n', '\n', '    event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '    modifier lockAffected {\n', '        require(block.number > lockedUntilBlock);\n', '        _;\n', '    }\n', '\n', '    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '\n', '\n', '    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '  function totalSupply() public constant returns (uint256 _totalSupply);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract InsurePalTokenInterface {\n', '    function mint(address _to, uint256 _amount) public;\n', '}\n', '\n', 'contract tokenRecipientInterface {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract KycContract is Owned {\n', '    \n', '    mapping (address => bool) verifiedAddresses;\n', '    \n', '    function isAddressVerified(address _address) public view returns (bool) {\n', '        return verifiedAddresses[_address];\n', '    }\n', '    \n', '    function addAddress(address _newAddress) public onlyOwner {\n', '        require(!verifiedAddresses[_newAddress]);\n', '        \n', '        verifiedAddresses[_newAddress] = true;\n', '    }\n', '    \n', '    function removeAddress(address _oldAddress) public onlyOwner {\n', '        require(verifiedAddresses[_oldAddress]);\n', '        \n', '        verifiedAddresses[_oldAddress] = false;\n', '    }\n', '    \n', '    function batchAddAddresses(address[] _addresses) public onlyOwner {\n', '        for (uint cnt = 0; cnt < _addresses.length; cnt++) {\n', '            assert(!verifiedAddresses[_addresses[cnt]]);\n', '            verifiedAddresses[_addresses[cnt]] = true;\n', '        }\n', '    }\n', '    \n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '    \n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']