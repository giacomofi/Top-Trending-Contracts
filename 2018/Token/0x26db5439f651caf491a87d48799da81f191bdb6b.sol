['pragma solidity 0.4.19;\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'pragma solidity ^0.4.18;\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * CashBetCoin ERC20 token\n', ' * Based on the OpenZeppelin Standard Token\n', ' * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\n', ' */\n', '\n', 'contract MigrationSource {\n', '  function vacate(address _addr) public returns (uint256 o_balance,\n', '                                                 uint256 o_lock_value,\n', '                                                 uint256 o_lock_endTime,\n', '                                                 bytes32 o_operatorId,\n', '                                                 bytes32 o_playerId);\n', '}\n', '\n', 'contract CashBetCoin is MigrationSource, ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "CashBetCoin";\n', '  string public constant symbol = "CBC";\n', '  uint8 public constant decimals = 8;\n', '  uint internal totalSupply_;\n', '\n', '  address public owner;\n', '\n', '  mapping(bytes32 => bool) public operators;\n', '  mapping(address => User) public users;\n', '  mapping(address => mapping(bytes32 => bool)) public employees;\n', '  \n', '  MigrationSource public migrateFrom;\n', '  address public migrateTo;\n', '\n', '  struct User {\n', '    uint256 balance;\n', '    uint256 lock_value;\n', '    uint256 lock_endTime;\n', '    bytes32 operatorId;\n', '    bytes32 playerId;\n', '      \n', '    mapping(address => uint256) authorized;\n', '  }\n', '\n', '  modifier only_owner(){\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier only_employees(address _user){\n', '    require(employees[msg.sender][users[_user].operatorId]);\n', '    _;\n', '  }\n', '\n', '  // PlayerId may only be set if operatorId is set too.\n', '  modifier playerid_iff_operatorid(bytes32 _opId, bytes32 _playerId){\n', '    require(_opId != bytes32(0) || _playerId == bytes32(0));\n', '    _;\n', '  }\n', '\n', '  // Value argument must be less than unlocked balance.\n', '  modifier value_less_than_unlocked_balance(address _user, uint256 _value){\n', '    User storage user = users[_user];\n', '    require(user.lock_endTime < block.timestamp ||\n', '            _value <= user.balance - user.lock_value);\n', '    require(_value <= user.balance);\n', '    _;\n', '  }\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event LockIncrease(address indexed user, uint256 amount, uint256 time);\n', '  event LockDecrease(address indexed user, address employee,  uint256 amount, uint256 time);\n', '\n', '  event Associate(address indexed user, address agent, bytes32 indexed operatorId, bytes32 playerId);\n', '  \n', '  event Burn(address indexed owner, uint256 value);\n', '\n', '  event OptIn(address indexed owner, uint256 value);\n', '  event Vacate(address indexed owner, uint256 value);\n', '\n', '  event Employee(address indexed empl, bytes32 indexed operatorId, bool allowed);\n', '  event Operator(bytes32 indexed operatorId, bool allowed);\n', '\n', '  function CashBetCoin(uint _totalSupply) public {\n', '    totalSupply_ = _totalSupply;\n', '    owner = msg.sender;\n', '    User storage user = users[owner];\n', '    user.balance = totalSupply_;\n', '    user.lock_value = 0;\n', '    user.lock_endTime = 0;\n', '    user.operatorId = bytes32(0);\n', '    user.playerId = bytes32(0);\n', '    Transfer(0, owner, _totalSupply);\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256){\n', '    return totalSupply_;\n', '  }\n', '\n', '  function balanceOf(address _addr) public view returns (uint256 balance) {\n', '    return users[_addr].balance;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '    user.balance = user.balance.sub(_value);\n', '    users[_to].balance = users[_to].balance.add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public value_less_than_unlocked_balance(_from, _value) returns (bool success) {\n', '    User storage user = users[_from];\n', '    user.balance = user.balance.sub(_value);\n', '    users[_to].balance = users[_to].balance.add(_value);\n', '    user.authorized[msg.sender] = user.authorized[msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool success){\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (users[msg.sender].authorized[_spender] == 0));\n', '    users[msg.sender].authorized[_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _user, address _spender) public view returns (uint256){\n', '    return users[_user].authorized[_spender];\n', '  }\n', '\n', '  // Returns the number of locked tokens at the specified address.\n', '  //\n', '  function lockedValueOf(address _addr) public view returns (uint256 value) {\n', '    User storage user = users[_addr];\n', '    // Is the lock expired?\n', '    if (user.lock_endTime < block.timestamp) {\n', '      // Lock is expired, no locked value.\n', '      return 0;\n', '    } else {\n', '      return user.lock_value;\n', '    }\n', '  }\n', '\n', '  // Returns the unix time that the current token lock will expire.\n', '  //\n', '  function lockedEndTimeOf(address _addr) public view returns (uint256 time) {\n', '    return users[_addr].lock_endTime;\n', '  }\n', '\n', '  // Lock the specified number of tokens until the specified unix\n', '  // time.  The locked value and expiration time are both absolute (if\n', '  // the account already had some locked tokens the count will be\n', '  // increased to this value.)  If the user already has locked tokens\n', '  // the locked token count and expiration time may not be smaller\n', '  // than the previous values.\n', '  //\n', '  function increaseLock(uint256 _value, uint256 _time) public returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '\n', '    // Is there a lock in effect?\n', '    if (block.timestamp < user.lock_endTime) {\n', '      // Lock in effect, ensure nothing gets smaller.\n', '      require(_value >= user.lock_value);\n', '      require(_time >= user.lock_endTime);\n', '      // Ensure something has increased.\n', '      require(_value > user.lock_value || _time > user.lock_endTime);\n', '    }\n', '\n', '    // Things we always require.\n', '    require(_value <= user.balance);\n', '    require(_time > block.timestamp);\n', '\n', '    user.lock_value = _value;\n', '    user.lock_endTime = _time;\n', '    LockIncrease(msg.sender, _value, _time);\n', '    return true;\n', '  }\n', '\n', '  // Employees of CashBet may decrease the locked token value and/or\n', '  // decrease the locked token expiration date.  These values may not\n', '  // ever be increased by an employee.\n', '  //\n', '  function decreaseLock(uint256 _value, uint256 _time, address _user) public only_employees(_user) returns (bool success) {\n', '    User storage user = users[_user];\n', '\n', '    // We don&#39;t modify expired locks (they are already 0)\n', '    require(user.lock_endTime > block.timestamp);\n', '    // Ensure nothing gets bigger.\n', '    require(_value <= user.lock_value);\n', '    require(_time <= user.lock_endTime);\n', '    // Ensure something has decreased.\n', '    require(_value < user.lock_value || _time < user.lock_endTime);\n', '\n', '    user.lock_value = _value;\n', '    user.lock_endTime = _time;\n', '    LockDecrease(_user, msg.sender, _value, _time);\n', '    return true;\n', '  }\n', '\n', '  function associate(bytes32 _opId, bytes32 _playerId) public playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '\n', '    // Players can associate their playerId once while the token is\n', '    // locked.  They can&#39;t change this association until the lock\n', '    // expires ...\n', '    require(user.lock_value == 0 ||\n', '            user.lock_endTime < block.timestamp ||\n', '            user.playerId == 0);\n', '\n', '    // OperatorId argument must be empty or in the approved operators set.\n', '    require(_opId == bytes32(0) || operators[_opId]);\n', '\n', '    user.operatorId = _opId;\n', '    user.playerId = _playerId;\n', '    Associate(msg.sender, msg.sender, _opId, _playerId);\n', '    return true;\n', '  }\n', '\n', '  function associationOf(address _addr) public view returns (bytes32 opId, bytes32 playerId) {\n', '    return (users[_addr].operatorId, users[_addr].playerId);\n', '  }\n', '\n', '  function setAssociation(address _user, bytes32 _opId, bytes32 _playerId) public only_employees(_user) playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\n', '    User storage user = users[_user];\n', '\n', '    // Employees may only set opId to empty or something they are an\n', '    // employee of.\n', '    require(_opId == bytes32(0) || employees[msg.sender][_opId]);\n', '    \n', '    user.operatorId = _opId;\n', '    user.playerId = _playerId;\n', '    Associate(_user, msg.sender, _opId, _playerId);\n', '    return true;\n', '  }\n', '  \n', '  function setEmployee(address _addr, bytes32 _opId, bool _allowed) public only_owner {\n', '    employees[_addr][_opId] = _allowed;\n', '    Employee(_addr, _opId, _allowed);\n', '  }\n', '\n', '  function setOperator(bytes32 _opId, bool _allowed) public only_owner {\n', '    operators[_opId] = _allowed;\n', '    Operator(_opId, _allowed);\n', '  }\n', '\n', '  function setOwner(address _addr) public only_owner {\n', '    owner = _addr;\n', '  }\n', '\n', '  function burnTokens(uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '    user.balance = user.balance.sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  // Sets the contract address that this contract will migrate\n', '  // from when the optIn() interface is used.\n', '  //\n', '  function setMigrateFrom(address _addr) public only_owner {\n', '    require(migrateFrom == MigrationSource(0));\n', '    migrateFrom = MigrationSource(_addr);\n', '  }\n', '\n', '  // Sets the contract address that is allowed to call vacate on this\n', '  // contract.\n', '  //\n', '  function setMigrateTo(address _addr) public only_owner {\n', '    migrateTo = _addr;\n', '  }\n', '\n', '  // Called by a token holding address, this method migrates the\n', '  // tokens from an older version of the contract to this version.\n', '  // The migrated tokens are merged with any existing tokens in this\n', '  // version of the contract, resulting in the locked token count\n', '  // being set to the sum of locked tokens in the old and new\n', '  // contracts and the lock expiration being set the longest lock\n', '  // duration for this address in either contract.  The playerId is\n', '  // transferred unless it was already set in the new contract.\n', '  //\n', '  // NOTE - allowances (approve) are *not* transferred.  If you gave\n', '  // another address an allowance in the old contract you need to\n', '  // re-approve it in the new contract.\n', '  //\n', '  function optIn() public returns (bool success) {\n', '    require(migrateFrom != MigrationSource(0));\n', '    User storage user = users[msg.sender];\n', '    uint256 balance;\n', '    uint256 lock_value;\n', '    uint256 lock_endTime;\n', '    bytes32 opId;\n', '    bytes32 playerId;\n', '    (balance, lock_value, lock_endTime, opId, playerId) =\n', '        migrateFrom.vacate(msg.sender);\n', '\n', '    OptIn(msg.sender, balance);\n', '    \n', '    user.balance = user.balance.add(balance);\n', '\n', '    bool lockTimeIncreased = false;\n', '    user.lock_value = user.lock_value.add(lock_value);\n', '    if (user.lock_endTime < lock_endTime) {\n', '      user.lock_endTime = lock_endTime;\n', '      lockTimeIncreased = true;\n', '    }\n', '    if (lock_value > 0 || lockTimeIncreased) {\n', '      LockIncrease(msg.sender, user.lock_value, user.lock_endTime);\n', '    }\n', '\n', '    if (user.operatorId == bytes32(0) && opId != bytes32(0)) {\n', '      user.operatorId = opId;\n', '      user.playerId = playerId;\n', '      Associate(msg.sender, msg.sender, opId, playerId);\n', '    }\n', '\n', '    totalSupply_ = totalSupply_.add(balance);\n', '\n', '    return true;\n', '  }\n', '\n', '  // The vacate method is called by a newer version of the CashBetCoin\n', '  // contract to extract the token state for an address and migrate it\n', '  // to the new contract.\n', '  //\n', '  function vacate(address _addr) public returns (uint256 o_balance,\n', '                                                 uint256 o_lock_value,\n', '                                                 uint256 o_lock_endTime,\n', '                                                 bytes32 o_opId,\n', '                                                 bytes32 o_playerId) {\n', '    require(msg.sender == migrateTo);\n', '    User storage user = users[_addr];\n', '    require(user.balance > 0);\n', '\n', '    o_balance = user.balance;\n', '    o_lock_value = user.lock_value;\n', '    o_lock_endTime = user.lock_endTime;\n', '    o_opId = user.operatorId;\n', '    o_playerId = user.playerId;\n', '\n', '    totalSupply_ = totalSupply_.sub(user.balance);\n', '\n', '    user.balance = 0;\n', '    user.lock_value = 0;\n', '    user.lock_endTime = 0;\n', '    user.operatorId = bytes32(0);\n', '    user.playerId = bytes32(0);\n', '\n', '    Vacate(_addr, o_balance);\n', '  }\n', '\n', '  // Don&#39;t accept ETH.\n', '  function () public payable {\n', '    revert();\n', '  }\n', '}']
['pragma solidity 0.4.19;\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'pragma solidity ^0.4.18;\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * CashBetCoin ERC20 token\n', ' * Based on the OpenZeppelin Standard Token\n', ' * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\n', ' */\n', '\n', 'contract MigrationSource {\n', '  function vacate(address _addr) public returns (uint256 o_balance,\n', '                                                 uint256 o_lock_value,\n', '                                                 uint256 o_lock_endTime,\n', '                                                 bytes32 o_operatorId,\n', '                                                 bytes32 o_playerId);\n', '}\n', '\n', 'contract CashBetCoin is MigrationSource, ERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "CashBetCoin";\n', '  string public constant symbol = "CBC";\n', '  uint8 public constant decimals = 8;\n', '  uint internal totalSupply_;\n', '\n', '  address public owner;\n', '\n', '  mapping(bytes32 => bool) public operators;\n', '  mapping(address => User) public users;\n', '  mapping(address => mapping(bytes32 => bool)) public employees;\n', '  \n', '  MigrationSource public migrateFrom;\n', '  address public migrateTo;\n', '\n', '  struct User {\n', '    uint256 balance;\n', '    uint256 lock_value;\n', '    uint256 lock_endTime;\n', '    bytes32 operatorId;\n', '    bytes32 playerId;\n', '      \n', '    mapping(address => uint256) authorized;\n', '  }\n', '\n', '  modifier only_owner(){\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier only_employees(address _user){\n', '    require(employees[msg.sender][users[_user].operatorId]);\n', '    _;\n', '  }\n', '\n', '  // PlayerId may only be set if operatorId is set too.\n', '  modifier playerid_iff_operatorid(bytes32 _opId, bytes32 _playerId){\n', '    require(_opId != bytes32(0) || _playerId == bytes32(0));\n', '    _;\n', '  }\n', '\n', '  // Value argument must be less than unlocked balance.\n', '  modifier value_less_than_unlocked_balance(address _user, uint256 _value){\n', '    User storage user = users[_user];\n', '    require(user.lock_endTime < block.timestamp ||\n', '            _value <= user.balance - user.lock_value);\n', '    require(_value <= user.balance);\n', '    _;\n', '  }\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event LockIncrease(address indexed user, uint256 amount, uint256 time);\n', '  event LockDecrease(address indexed user, address employee,  uint256 amount, uint256 time);\n', '\n', '  event Associate(address indexed user, address agent, bytes32 indexed operatorId, bytes32 playerId);\n', '  \n', '  event Burn(address indexed owner, uint256 value);\n', '\n', '  event OptIn(address indexed owner, uint256 value);\n', '  event Vacate(address indexed owner, uint256 value);\n', '\n', '  event Employee(address indexed empl, bytes32 indexed operatorId, bool allowed);\n', '  event Operator(bytes32 indexed operatorId, bool allowed);\n', '\n', '  function CashBetCoin(uint _totalSupply) public {\n', '    totalSupply_ = _totalSupply;\n', '    owner = msg.sender;\n', '    User storage user = users[owner];\n', '    user.balance = totalSupply_;\n', '    user.lock_value = 0;\n', '    user.lock_endTime = 0;\n', '    user.operatorId = bytes32(0);\n', '    user.playerId = bytes32(0);\n', '    Transfer(0, owner, _totalSupply);\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256){\n', '    return totalSupply_;\n', '  }\n', '\n', '  function balanceOf(address _addr) public view returns (uint256 balance) {\n', '    return users[_addr].balance;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '    user.balance = user.balance.sub(_value);\n', '    users[_to].balance = users[_to].balance.add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public value_less_than_unlocked_balance(_from, _value) returns (bool success) {\n', '    User storage user = users[_from];\n', '    user.balance = user.balance.sub(_value);\n', '    users[_to].balance = users[_to].balance.add(_value);\n', '    user.authorized[msg.sender] = user.authorized[msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool success){\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (users[msg.sender].authorized[_spender] == 0));\n', '    users[msg.sender].authorized[_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _user, address _spender) public view returns (uint256){\n', '    return users[_user].authorized[_spender];\n', '  }\n', '\n', '  // Returns the number of locked tokens at the specified address.\n', '  //\n', '  function lockedValueOf(address _addr) public view returns (uint256 value) {\n', '    User storage user = users[_addr];\n', '    // Is the lock expired?\n', '    if (user.lock_endTime < block.timestamp) {\n', '      // Lock is expired, no locked value.\n', '      return 0;\n', '    } else {\n', '      return user.lock_value;\n', '    }\n', '  }\n', '\n', '  // Returns the unix time that the current token lock will expire.\n', '  //\n', '  function lockedEndTimeOf(address _addr) public view returns (uint256 time) {\n', '    return users[_addr].lock_endTime;\n', '  }\n', '\n', '  // Lock the specified number of tokens until the specified unix\n', '  // time.  The locked value and expiration time are both absolute (if\n', '  // the account already had some locked tokens the count will be\n', '  // increased to this value.)  If the user already has locked tokens\n', '  // the locked token count and expiration time may not be smaller\n', '  // than the previous values.\n', '  //\n', '  function increaseLock(uint256 _value, uint256 _time) public returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '\n', '    // Is there a lock in effect?\n', '    if (block.timestamp < user.lock_endTime) {\n', '      // Lock in effect, ensure nothing gets smaller.\n', '      require(_value >= user.lock_value);\n', '      require(_time >= user.lock_endTime);\n', '      // Ensure something has increased.\n', '      require(_value > user.lock_value || _time > user.lock_endTime);\n', '    }\n', '\n', '    // Things we always require.\n', '    require(_value <= user.balance);\n', '    require(_time > block.timestamp);\n', '\n', '    user.lock_value = _value;\n', '    user.lock_endTime = _time;\n', '    LockIncrease(msg.sender, _value, _time);\n', '    return true;\n', '  }\n', '\n', '  // Employees of CashBet may decrease the locked token value and/or\n', '  // decrease the locked token expiration date.  These values may not\n', '  // ever be increased by an employee.\n', '  //\n', '  function decreaseLock(uint256 _value, uint256 _time, address _user) public only_employees(_user) returns (bool success) {\n', '    User storage user = users[_user];\n', '\n', "    // We don't modify expired locks (they are already 0)\n", '    require(user.lock_endTime > block.timestamp);\n', '    // Ensure nothing gets bigger.\n', '    require(_value <= user.lock_value);\n', '    require(_time <= user.lock_endTime);\n', '    // Ensure something has decreased.\n', '    require(_value < user.lock_value || _time < user.lock_endTime);\n', '\n', '    user.lock_value = _value;\n', '    user.lock_endTime = _time;\n', '    LockDecrease(_user, msg.sender, _value, _time);\n', '    return true;\n', '  }\n', '\n', '  function associate(bytes32 _opId, bytes32 _playerId) public playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '\n', '    // Players can associate their playerId once while the token is\n', "    // locked.  They can't change this association until the lock\n", '    // expires ...\n', '    require(user.lock_value == 0 ||\n', '            user.lock_endTime < block.timestamp ||\n', '            user.playerId == 0);\n', '\n', '    // OperatorId argument must be empty or in the approved operators set.\n', '    require(_opId == bytes32(0) || operators[_opId]);\n', '\n', '    user.operatorId = _opId;\n', '    user.playerId = _playerId;\n', '    Associate(msg.sender, msg.sender, _opId, _playerId);\n', '    return true;\n', '  }\n', '\n', '  function associationOf(address _addr) public view returns (bytes32 opId, bytes32 playerId) {\n', '    return (users[_addr].operatorId, users[_addr].playerId);\n', '  }\n', '\n', '  function setAssociation(address _user, bytes32 _opId, bytes32 _playerId) public only_employees(_user) playerid_iff_operatorid(_opId, _playerId) returns (bool success) {\n', '    User storage user = users[_user];\n', '\n', '    // Employees may only set opId to empty or something they are an\n', '    // employee of.\n', '    require(_opId == bytes32(0) || employees[msg.sender][_opId]);\n', '    \n', '    user.operatorId = _opId;\n', '    user.playerId = _playerId;\n', '    Associate(_user, msg.sender, _opId, _playerId);\n', '    return true;\n', '  }\n', '  \n', '  function setEmployee(address _addr, bytes32 _opId, bool _allowed) public only_owner {\n', '    employees[_addr][_opId] = _allowed;\n', '    Employee(_addr, _opId, _allowed);\n', '  }\n', '\n', '  function setOperator(bytes32 _opId, bool _allowed) public only_owner {\n', '    operators[_opId] = _allowed;\n', '    Operator(_opId, _allowed);\n', '  }\n', '\n', '  function setOwner(address _addr) public only_owner {\n', '    owner = _addr;\n', '  }\n', '\n', '  function burnTokens(uint256 _value) public value_less_than_unlocked_balance(msg.sender, _value) returns (bool success) {\n', '    User storage user = users[msg.sender];\n', '    user.balance = user.balance.sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  // Sets the contract address that this contract will migrate\n', '  // from when the optIn() interface is used.\n', '  //\n', '  function setMigrateFrom(address _addr) public only_owner {\n', '    require(migrateFrom == MigrationSource(0));\n', '    migrateFrom = MigrationSource(_addr);\n', '  }\n', '\n', '  // Sets the contract address that is allowed to call vacate on this\n', '  // contract.\n', '  //\n', '  function setMigrateTo(address _addr) public only_owner {\n', '    migrateTo = _addr;\n', '  }\n', '\n', '  // Called by a token holding address, this method migrates the\n', '  // tokens from an older version of the contract to this version.\n', '  // The migrated tokens are merged with any existing tokens in this\n', '  // version of the contract, resulting in the locked token count\n', '  // being set to the sum of locked tokens in the old and new\n', '  // contracts and the lock expiration being set the longest lock\n', '  // duration for this address in either contract.  The playerId is\n', '  // transferred unless it was already set in the new contract.\n', '  //\n', '  // NOTE - allowances (approve) are *not* transferred.  If you gave\n', '  // another address an allowance in the old contract you need to\n', '  // re-approve it in the new contract.\n', '  //\n', '  function optIn() public returns (bool success) {\n', '    require(migrateFrom != MigrationSource(0));\n', '    User storage user = users[msg.sender];\n', '    uint256 balance;\n', '    uint256 lock_value;\n', '    uint256 lock_endTime;\n', '    bytes32 opId;\n', '    bytes32 playerId;\n', '    (balance, lock_value, lock_endTime, opId, playerId) =\n', '        migrateFrom.vacate(msg.sender);\n', '\n', '    OptIn(msg.sender, balance);\n', '    \n', '    user.balance = user.balance.add(balance);\n', '\n', '    bool lockTimeIncreased = false;\n', '    user.lock_value = user.lock_value.add(lock_value);\n', '    if (user.lock_endTime < lock_endTime) {\n', '      user.lock_endTime = lock_endTime;\n', '      lockTimeIncreased = true;\n', '    }\n', '    if (lock_value > 0 || lockTimeIncreased) {\n', '      LockIncrease(msg.sender, user.lock_value, user.lock_endTime);\n', '    }\n', '\n', '    if (user.operatorId == bytes32(0) && opId != bytes32(0)) {\n', '      user.operatorId = opId;\n', '      user.playerId = playerId;\n', '      Associate(msg.sender, msg.sender, opId, playerId);\n', '    }\n', '\n', '    totalSupply_ = totalSupply_.add(balance);\n', '\n', '    return true;\n', '  }\n', '\n', '  // The vacate method is called by a newer version of the CashBetCoin\n', '  // contract to extract the token state for an address and migrate it\n', '  // to the new contract.\n', '  //\n', '  function vacate(address _addr) public returns (uint256 o_balance,\n', '                                                 uint256 o_lock_value,\n', '                                                 uint256 o_lock_endTime,\n', '                                                 bytes32 o_opId,\n', '                                                 bytes32 o_playerId) {\n', '    require(msg.sender == migrateTo);\n', '    User storage user = users[_addr];\n', '    require(user.balance > 0);\n', '\n', '    o_balance = user.balance;\n', '    o_lock_value = user.lock_value;\n', '    o_lock_endTime = user.lock_endTime;\n', '    o_opId = user.operatorId;\n', '    o_playerId = user.playerId;\n', '\n', '    totalSupply_ = totalSupply_.sub(user.balance);\n', '\n', '    user.balance = 0;\n', '    user.lock_value = 0;\n', '    user.lock_endTime = 0;\n', '    user.operatorId = bytes32(0);\n', '    user.playerId = bytes32(0);\n', '\n', '    Vacate(_addr, o_balance);\n', '  }\n', '\n', "  // Don't accept ETH.\n", '  function () public payable {\n', '    revert();\n', '  }\n', '}']
