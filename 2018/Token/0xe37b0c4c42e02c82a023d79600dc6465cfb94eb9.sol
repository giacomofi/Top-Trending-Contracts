['pragma solidity ^0.4.18;\n', '\n', 'contract Hexagon {\n', '  /* Main information */\n', '  string public constant name = "Hexagon";\n', '  string public constant symbol = "HXG";\n', '  uint8 public constant decimals = 4;\n', '  uint8 public constant burnPerTransaction = 2;\n', '  uint256 public constant initialSupply = 420000000000000;\n', '  uint256 public currentSupply = initialSupply;\n', '\n', '  /* Create array with balances */\n', '  mapping (address => uint256) public balanceOf;\n', '  /* Create array with allowance */\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '  /* Constructor */\n', '  function Hexagon() public {\n', '    /* Give creator all initial supply of tokens */\n', '    balanceOf[msg.sender] = initialSupply;\n', '  }\n', '\n', '  /* PUBLIC */\n', '  /* Send tokens */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    _transfer(msg.sender, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /* Burn tokens */\n', '  function burn(uint256 _value) public returns (bool success) {\n', '    /* Check if the sender has enough */\n', '    require(balanceOf[msg.sender] >= _value);\n', '    /* Subtract from the sender */\n', '    balanceOf[msg.sender] -= _value;\n', '    /* Send to the black hole */\n', '    balanceOf[0x0] += _value;\n', '    /* Update current supply */\n', '    currentSupply -= _value;\n', '    /* Notify network */\n', '    Burn(msg.sender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /* Allow someone to spend on your behalf */\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    /* Check if the sender has already  */\n', '    require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '    /* Add to allowance  */\n', '    allowance[msg.sender][_spender] = _value;\n', '    /* Notify network */\n', '    Approval(msg.sender, _spender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /* Transfer tokens from allowance */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    /* Prevent transfer of not allowed tokens */\n', '    require(allowance[_from][msg.sender] >= _value);\n', '    /* Remove tokens from allowance */\n', '    allowance[_from][msg.sender] -= _value;\n', '\n', '    _transfer(_from, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /* INTERNAL */\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '    /* Prevent transfer to 0x0 address. Use burn() instead  */\n', '    require (_to != 0x0);\n', '    /* Check if the sender has enough */\n', '    require (balanceOf[_from] >= _value + burnPerTransaction);\n', '    /* Check for overflows */\n', '    require (balanceOf[_to] + _value > balanceOf[_to]);\n', '    /* Subtract from the sender */\n', '    balanceOf[_from] -= _value + burnPerTransaction;\n', '    /* Add the same to the recipient */\n', '    balanceOf[_to] += _value;\n', '    /* Apply transaction fee */\n', '    balanceOf[0x0] += burnPerTransaction;\n', '    /* Update current supply */\n', '    currentSupply -= burnPerTransaction;\n', '    /* Notify network */\n', '    Burn(_from, burnPerTransaction);\n', '    /* Notify network */\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /* Events */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Burn(address indexed from, uint256 value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']