['pragma solidity ^0.4.23;\n', '\n', '// File: contracts\\utils\\AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\utils\\Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\utils\\TrustedContractControl.sol\n', '\n', 'contract TrustedContractControl is Ownable{\n', '  using AddressUtils for address;\n', '\n', '  mapping (address => bool) public trustedContractList;\n', '\n', '  modifier onlyTrustedContract(address _contractAddress) {\n', '    require(trustedContractList[_contractAddress]);\n', '    _;\n', '  }\n', '\n', '  event AddTrustedContract(address contractAddress);\n', '  event RemoveTrustedContract(address contractAddress);\n', '\n', '\n', '  function addTrustedContracts(address[] _contractAddress) onlyOwner public {\n', '    for(uint i=0; i<_contractAddress.length; i++) {\n', '      require(addTrustedContract(_contractAddress[i]));\n', '    }\n', '  }\n', '\n', '\n', '  // need to add GirlSummon, GirlRecycle contract into the trusted list.\n', '  function addTrustedContract(address _contractAddress) onlyOwner public returns (bool){\n', '    require(!trustedContractList[_contractAddress]);\n', '    require(_contractAddress.isContract());\n', '    trustedContractList[_contractAddress] = true;\n', '    emit AddTrustedContract(_contractAddress);\n', '    return true;\n', '  }\n', '\n', '  function removeTrustedContract(address _contractAddress) onlyOwner public {\n', '    require(trustedContractList[_contractAddress]);\n', '    trustedContractList[_contractAddress] = false;\n', '    emit RemoveTrustedContract(_contractAddress);\n', '  }\n', '}\n', '\n', '// File: contracts\\utils\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts\\utils\\Serialize.sol\n', '\n', 'contract Serialize {\n', '    using SafeMath for uint256;\n', '    function addAddress(uint _offst, bytes memory _output, address _input) internal pure returns(uint _offset) {\n', '      assembly {\n', '        mstore(add(_output, _offst), _input)\n', '      }\n', '      return _offst.sub(20);\n', '    }\n', '\n', '    function addUint(uint _offst, bytes memory _output, uint _input) internal pure returns (uint _offset) {\n', '      assembly {\n', '        mstore(add(_output, _offst), _input)\n', '      }\n', '      return _offst.sub(32);\n', '    }\n', '\n', '    function addUint8(uint _offst, bytes memory _output, uint _input) internal pure returns (uint _offset) {\n', '      assembly {\n', '        mstore(add(_output, _offst), _input)\n', '      }\n', '      return _offst.sub(1);\n', '    }\n', '\n', '    function addUint16(uint _offst, bytes memory _output, uint _input) internal pure returns (uint _offset) {\n', '      assembly {\n', '        mstore(add(_output, _offst), _input)\n', '      }\n', '      return _offst.sub(2);\n', '    }\n', '\n', '    function addUint64(uint _offst, bytes memory _output, uint _input) internal pure returns (uint _offset) {\n', '      assembly {\n', '        mstore(add(_output, _offst), _input)\n', '      }\n', '      return _offst.sub(8);\n', '    }\n', '\n', '    function getAddress(uint _offst, bytes memory _input) internal pure returns (address _output, uint _offset) {\n', '      assembly {\n', '        _output := mload(add(_input, _offst))\n', '      }\n', '      return (_output, _offst.sub(20));\n', '    }\n', '\n', '    function getUint(uint _offst, bytes memory _input) internal pure returns (uint _output, uint _offset) {\n', '      assembly {\n', '          _output := mload(add(_input, _offst))\n', '      }\n', '      return (_output, _offst.sub(32));\n', '    }\n', '\n', '    function getUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output, uint _offset) {\n', '      assembly {\n', '        _output := mload(add(_input, _offst))\n', '      }\n', '      return (_output, _offst.sub(1));\n', '    }\n', '\n', '    function getUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output, uint _offset) {\n', '      assembly {\n', '        _output := mload(add(_input, _offst))\n', '      }\n', '      return (_output, _offst.sub(2));\n', '    }\n', '\n', '    function getUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output, uint _offset) {\n', '      assembly {\n', '        _output := mload(add(_input, _offst))\n', '      }\n', '      return (_output, _offst.sub(8));\n', '    }\n', '}\n', '\n', '// File: contracts\\utils\\Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts\\ERC721\\ERC721Basic.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', '// File: contracts\\ERC721\\ERC721Receiver.sol\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '// File: contracts\\ERC721\\ERC721BasicToken.sol\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic, Pausable {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '   * @dev Guarantees msg.sender is owner of the given token\n', '   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '   */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '   * @param _tokenId uint256 ID of the token to validate\n', '   */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param _owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the owner of the specified token ID\n', '   * @param _tokenId uint256 ID of the token to query the owner of\n', '   * @return owner address currently marked as the owner of the given token ID\n', '   */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the specified token exists\n', '   * @param _tokenId uint256 ID of the token to query the existance of\n', '   * @return whether the token exists\n', '   */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Approves another address to transfer the given token ID\n', '   * @dev The zero address indicates there is no approved address.\n', '   * @dev There can only be one approved address per token at a given time.\n', '   * @dev Can only be called by the token owner or an approved operator.\n', '   * @param _to address to be approved for the given token ID\n', '   * @param _tokenId uint256 ID of the token to be approved\n', '   */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets or unsets the approval of a given operator\n', '   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '   * @param _to operator address to set the approval\n', '   * @param _approved representing the status of the approval to be set\n', '   */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    emit ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given token ID to another address\n', '   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  function transferBatch(address _from, address _to, uint[] _tokenIds) public {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    for(uint i=0; i<_tokenIds.length; i++) {\n', '      require(isApprovedOrOwner(msg.sender, _tokenIds[i]));\n', '      clearApproval(_from,  _tokenIds[i]);\n', '      removeTokenFrom(_from, _tokenIds[i]);\n', '      addTokenTo(_to, _tokenIds[i]);\n', '\n', '      emit Transfer(_from, _to, _tokenIds[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    // solium-disable-next-line arg-overflow\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes data to send along with a safe transfer check\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    transferFrom(_from, _to, _tokenId);\n', '    // solium-disable-next-line arg-overflow\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to The address that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to clear current approval of a given token ID\n', '   * @dev Reverts if the given address is not indeed the owner of the token\n', '   * @param _owner owner of the token\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      emit Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal whenNotPaused {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal whenNotPaused{\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to invoke `onERC721Received` on a target address\n', '   * @dev The call is not executed if the target address is not a contract\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _to target address that will receive the tokens\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes optional data to send along with the call\n', '   * @return whether the call correctly returned the expected magic value\n', '   */\n', '  function checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    returns (bool)\n', '  {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '// File: contracts\\ERC721\\GirlBasicToken.sol\n', '\n', '// add atomic swap feature in the token contract.\n', 'contract GirlBasicToken is ERC721BasicToken, Serialize {\n', '\n', '  event CreateGirl(address owner, uint256 tokenID, uint256 genes, uint64 birthTime, uint64 cooldownEndTime, uint16 starLevel);\n', '  event CoolDown(uint256 tokenId, uint64 cooldownEndTime);\n', '  event GirlUpgrade(uint256 tokenId, uint64 starLevel);\n', '\n', '  struct Girl{\n', '    /**\n', '    少女基因,生成以后不会改变\n', '    **/\n', '    uint genes;\n', '\n', '    /*\n', '    出生时间 少女创建时候的时间戳\n', '    */\n', '    uint64 birthTime;\n', '\n', '    /*\n', '    冷却结束时间\n', '    */\n', '    uint64 cooldownEndTime;\n', '    /*\n', '    star level\n', '    */\n', '    uint16 starLevel;\n', '  }\n', '\n', '  Girl[] girls;\n', '\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return girls.length;\n', '  }\n', '\n', '  function getGirlGene(uint _index) public view returns (uint) {\n', '    return girls[_index].genes;\n', '  }\n', '\n', '  function getGirlBirthTime(uint _index) public view returns (uint64) {\n', '    return girls[_index].birthTime;\n', '  }\n', '\n', '  function getGirlCoolDownEndTime(uint _index) public view returns (uint64) {\n', '    return girls[_index].cooldownEndTime;\n', '  }\n', '\n', '  function getGirlStarLevel(uint _index) public view returns (uint16) {\n', '    return girls[_index].starLevel;\n', '  }\n', '\n', '  function isNotCoolDown(uint _girlId) public view returns(bool) {\n', '    return uint64(now) > girls[_girlId].cooldownEndTime;\n', '  }\n', '\n', '  function _createGirl(\n', '      uint _genes,\n', '      address _owner,\n', '      uint16 _starLevel\n', '  ) internal returns (uint){\n', '      Girl memory _girl = Girl({\n', '          genes:_genes,\n', '          birthTime:uint64(now),\n', '          cooldownEndTime:0,\n', '          starLevel:_starLevel\n', '      });\n', '      uint256 girlId = girls.push(_girl) - 1;\n', '      _mint(_owner, girlId);\n', '      emit CreateGirl(_owner, girlId, _genes, _girl.birthTime, _girl.cooldownEndTime, _girl.starLevel);\n', '      return girlId;\n', '  }\n', '\n', '  function _setCoolDownTime(uint _tokenId, uint _coolDownTime) internal {\n', '    girls[_tokenId].cooldownEndTime = uint64(now.add(_coolDownTime));\n', '    emit CoolDown(_tokenId, girls[_tokenId].cooldownEndTime);\n', '  }\n', '\n', '  function _LevelUp(uint _tokenId) internal {\n', '    require(girls[_tokenId].starLevel < 65535);\n', '    girls[_tokenId].starLevel = girls[_tokenId].starLevel + 1;\n', '    emit GirlUpgrade(_tokenId, girls[_tokenId].starLevel);\n', '  }\n', '\n', '  // ---------------\n', '  // this is atomic swap for girl to be set cross chain.\n', '  // ---------------\n', '  uint8 constant public GIRLBUFFERSIZE = 50;  // buffer size need to serialize girl data; used for cross chain sync\n', '\n', '  struct HashLockContract {\n', '    address sender;\n', '    address receiver;\n', '    uint tokenId;\n', '    bytes32 hashlock;\n', '    uint timelock;\n', '    bytes32 secret;\n', '    States state;\n', '    bytes extraData;\n', '  }\n', '\n', '  enum States {\n', '    INVALID,\n', '    OPEN,\n', '    CLOSED,\n', '    REFUNDED\n', '  }\n', '\n', '  mapping (bytes32 => HashLockContract) private contracts;\n', '\n', '  modifier contractExists(bytes32 _contractId) {\n', '    require(_contractExists(_contractId));\n', '    _;\n', '  }\n', '\n', '  modifier hashlockMatches(bytes32 _contractId, bytes32 _secret) {\n', '    require(contracts[_contractId].hashlock == keccak256(_secret));\n', '    _;\n', '  }\n', '\n', '  modifier closable(bytes32 _contractId) {\n', '    require(contracts[_contractId].state == States.OPEN);\n', '    require(contracts[_contractId].timelock > now);\n', '    _;\n', '  }\n', '\n', '  modifier refundable(bytes32 _contractId) {\n', '    require(contracts[_contractId].state == States.OPEN);\n', '    require(contracts[_contractId].timelock <= now);\n', '    _;\n', '  }\n', '\n', '  event NewHashLockContract (\n', '    bytes32 indexed contractId,\n', '    address indexed sender,\n', '    address indexed receiver,\n', '    uint tokenId,\n', '    bytes32 hashlock,\n', '    uint timelock,\n', '    bytes extraData\n', '  );\n', '\n', '  event SwapClosed(bytes32 indexed contractId);\n', '  event SwapRefunded(bytes32 indexed contractId);\n', '\n', '  function open (\n', '    address _receiver,\n', '    bytes32 _hashlock,\n', '    uint _duration,\n', '    uint _tokenId\n', '  ) public\n', '    onlyOwnerOf(_tokenId)\n', '    returns (bytes32 contractId)\n', '  {\n', '    uint _timelock = now.add(_duration);\n', '\n', '    // compute girl data;\n', '    bytes memory _extraData = new bytes(GIRLBUFFERSIZE);\n', '    uint offset = GIRLBUFFERSIZE;\n', '\n', '    offset = addUint16(offset, _extraData, girls[_tokenId].starLevel);\n', '    offset = addUint64(offset, _extraData, girls[_tokenId].cooldownEndTime);\n', '    offset = addUint64(offset, _extraData, girls[_tokenId].birthTime);\n', '    offset = addUint(offset, _extraData, girls[_tokenId].genes);\n', '\n', '    contractId = keccak256 (\n', '      msg.sender,\n', '      _receiver,\n', '      _tokenId,\n', '      _hashlock,\n', '      _timelock,\n', '      _extraData\n', '    );\n', '\n', '    // the new contract must not exist\n', '    require(!_contractExists(contractId));\n', '\n', '    // temporary change the ownership to this contract address.\n', '    // the ownership will be change to user when close is called.\n', '    clearApproval(msg.sender, _tokenId);\n', '    removeTokenFrom(msg.sender, _tokenId);\n', '    addTokenTo(address(this), _tokenId);\n', '\n', '\n', '    contracts[contractId] = HashLockContract(\n', '      msg.sender,\n', '      _receiver,\n', '      _tokenId,\n', '      _hashlock,\n', '      _timelock,\n', '      0x0,\n', '      States.OPEN,\n', '      _extraData\n', '    );\n', '\n', '    emit NewHashLockContract(contractId, msg.sender, _receiver, _tokenId, _hashlock, _timelock, _extraData);\n', '  }\n', '\n', '  function close(bytes32 _contractId, bytes32 _secret)\n', '    public\n', '    contractExists(_contractId)\n', '    hashlockMatches(_contractId, _secret)\n', '    closable(_contractId)\n', '    returns (bool)\n', '  {\n', '    HashLockContract storage c = contracts[_contractId];\n', '    c.secret = _secret;\n', '    c.state = States.CLOSED;\n', '\n', '    // transfer token ownership from this contract address to receiver.\n', '    // clearApproval(address(this), c.tokenId);\n', '    removeTokenFrom(address(this), c.tokenId);\n', '    addTokenTo(c.receiver, c.tokenId);\n', '\n', '    emit SwapClosed(_contractId);\n', '    return true;\n', '  }\n', '\n', '  function refund(bytes32 _contractId)\n', '    public\n', '    contractExists(_contractId)\n', '    refundable(_contractId)\n', '    returns (bool)\n', '  {\n', '    HashLockContract storage c = contracts[_contractId];\n', '    c.state = States.REFUNDED;\n', '\n', '    // transfer token ownership from this contract address to receiver.\n', '    // clearApproval(address(this), c.tokenId);\n', '    removeTokenFrom(address(this), c.tokenId);\n', '    addTokenTo(c.sender, c.tokenId);\n', '\n', '\n', '    emit SwapRefunded(_contractId);\n', '    return true;\n', '  }\n', '\n', '  function _contractExists(bytes32 _contractId) internal view returns (bool exists) {\n', '    exists = (contracts[_contractId].sender != address(0));\n', '  }\n', '\n', '  function checkContract(bytes32 _contractId)\n', '    public\n', '    view\n', '    contractExists(_contractId)\n', '    returns (\n', '      address sender,\n', '      address receiver,\n', '      uint amount,\n', '      bytes32 hashlock,\n', '      uint timelock,\n', '      bytes32 secret,\n', '      bytes extraData\n', '    )\n', '  {\n', '    HashLockContract memory c = contracts[_contractId];\n', '    return (\n', '      c.sender,\n', '      c.receiver,\n', '      c.tokenId,\n', '      c.hashlock,\n', '      c.timelock,\n', '      c.secret,\n', '      c.extraData\n', '    );\n', '  }\n', '\n', '\n', '}\n', '\n', '// File: contracts\\ERC721\\GirlOps.sol\n', '\n', 'contract GirlOps is GirlBasicToken, TrustedContractControl {\n', '\n', '  string public name = "Cryptogirl";\n', '  string public symbol = "CG";\n', '  \n', '  function createGirl(uint _genes, address _owner, uint16 _starLevel)\n', '      onlyTrustedContract(msg.sender) public returns (uint) {\n', '      require (_starLevel > 0);\n', '      return _createGirl(_genes, _owner, _starLevel);\n', '  }\n', '\n', '  function createPromotionGirl(uint[] _genes, address _owner, uint16 _starLevel) onlyOwner public {\n', '  \trequire (_starLevel > 0);\n', '    for (uint i=0; i<_genes.length; i++) {\n', '      _createGirl(_genes[i], _owner, _starLevel);\n', '    }\n', '  }\n', '\n', '  function burnGirl(address _owner, uint _tokenId) onlyTrustedContract(msg.sender) public {\n', '      _burn(_owner, _tokenId);\n', '  }\n', '\n', '  function setCoolDownTime(uint _tokenId, uint _coolDownTime)\n', '      onlyTrustedContract(msg.sender) public {\n', '      _setCoolDownTime(_tokenId, _coolDownTime);\n', '  }\n', '\n', '  function levelUp(uint _tokenId)\n', '      onlyTrustedContract(msg.sender) public {\n', '      _LevelUp(_tokenId);\n', '  }\n', '\n', '  function safeTransferFromWithData(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  ) public {\n', '      safeTransferFrom(_from,_to,_tokenId,_data);\n', '  }\n', '\n', '\n', '}\n', '\n', '// File: contracts\\equipments\\ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts\\equipments\\BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\equipments\\ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts\\equipments\\StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\equipments\\AtomicSwappableToken.sol\n', '\n', 'contract AtomicSwappableToken is StandardToken {\n', '  struct HashLockContract {\n', '    address sender;\n', '    address receiver;\n', '    uint amount;\n', '    bytes32 hashlock;\n', '    uint timelock;\n', '    bytes32 secret;\n', '    States state;\n', '  }\n', '\n', '  enum States {\n', '    INVALID,\n', '    OPEN,\n', '    CLOSED,\n', '    REFUNDED\n', '  }\n', '\n', '  mapping (bytes32 => HashLockContract) private contracts;\n', '\n', '  modifier futureTimelock(uint _time) {\n', '    // only requirement is the timelock time is after the last blocktime (now).\n', '    // probably want something a bit further in the future then this.\n', '    // but this is still a useful sanity check:\n', '    require(_time > now);\n', '    _;\n', '}\n', '\n', '  modifier contractExists(bytes32 _contractId) {\n', '    require(_contractExists(_contractId));\n', '    _;\n', '  }\n', '\n', '  modifier hashlockMatches(bytes32 _contractId, bytes32 _secret) {\n', '    require(contracts[_contractId].hashlock == keccak256(_secret));\n', '    _;\n', '  }\n', '\n', '  modifier closable(bytes32 _contractId) {\n', '    require(contracts[_contractId].state == States.OPEN);\n', '    require(contracts[_contractId].timelock > now);\n', '    _;\n', '  }\n', '\n', '  modifier refundable(bytes32 _contractId) {\n', '    require(contracts[_contractId].state == States.OPEN);\n', '    require(contracts[_contractId].timelock <= now);\n', '    _;\n', '  }\n', '\n', '  event NewHashLockContract (\n', '    bytes32 indexed contractId,\n', '    address indexed sender,\n', '    address indexed receiver,\n', '    uint amount,\n', '    bytes32 hashlock,\n', '    uint timelock\n', '  );\n', '\n', '  event SwapClosed(bytes32 indexed contractId);\n', '  event SwapRefunded(bytes32 indexed contractId);\n', '\n', '\n', '  function open (\n', '    address _receiver,\n', '    bytes32 _hashlock,\n', '    uint _timelock,\n', '    uint _amount\n', '  ) public\n', '    futureTimelock(_timelock)\n', '    returns (bytes32 contractId)\n', '  {\n', '    contractId = keccak256 (\n', '      msg.sender,\n', '      _receiver,\n', '      _amount,\n', '      _hashlock,\n', '      _timelock\n', '    );\n', '\n', '    // the new contract must not exist\n', '    require(!_contractExists(contractId));\n', '\n', '    // transfer token to this contract\n', '    require(transfer(address(this), _amount));\n', '\n', '    contracts[contractId] = HashLockContract(\n', '      msg.sender,\n', '      _receiver,\n', '      _amount,\n', '      _hashlock,\n', '      _timelock,\n', '      0x0,\n', '      States.OPEN\n', '    );\n', '\n', '    emit NewHashLockContract(contractId, msg.sender, _receiver, _amount, _hashlock, _timelock);\n', '  }\n', '\n', '  function close(bytes32 _contractId, bytes32 _secret)\n', '    public\n', '    contractExists(_contractId)\n', '    hashlockMatches(_contractId, _secret)\n', '    closable(_contractId)\n', '    returns (bool)\n', '  {\n', '    HashLockContract storage c = contracts[_contractId];\n', '    c.secret = _secret;\n', '    c.state = States.CLOSED;\n', '    require(this.transfer(c.receiver, c.amount));\n', '    emit SwapClosed(_contractId);\n', '    return true;\n', '  }\n', '\n', '  function refund(bytes32 _contractId)\n', '    public\n', '    contractExists(_contractId)\n', '    refundable(_contractId)\n', '    returns (bool)\n', '  {\n', '    HashLockContract storage c = contracts[_contractId];\n', '    c.state = States.REFUNDED;\n', '    require(this.transfer(c.sender, c.amount));\n', '    emit SwapRefunded(_contractId);\n', '    return true;\n', '  }\n', '\n', '  function _contractExists(bytes32 _contractId) internal view returns (bool exists) {\n', '    exists = (contracts[_contractId].sender != address(0));\n', '  }\n', '\n', '  function checkContract(bytes32 _contractId)\n', '    public\n', '    view\n', '    contractExists(_contractId)\n', '    returns (\n', '      address sender,\n', '      address receiver,\n', '      uint amount,\n', '      bytes32 hashlock,\n', '      uint timelock,\n', '      bytes32 secret\n', '    )\n', '  {\n', '    HashLockContract memory c = contracts[_contractId];\n', '    return (\n', '      c.sender,\n', '      c.receiver,\n', '      c.amount,\n', '      c.hashlock,\n', '      c.timelock,\n', '      c.secret\n', '    );\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\equipments\\TokenReceiver.sol\n', '\n', 'contract TokenReceiver {\n', '  function receiveApproval(address from, uint amount, address tokenAddress, bytes data) public;\n', '}\n', '\n', '// File: contracts\\equipments\\BaseEquipment.sol\n', '\n', 'contract BaseEquipment is Ownable, AtomicSwappableToken {\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  //cap==0 means no limits\n', '  uint256 public cap;\n', '\n', '  /**\n', '      properties = [\n', '          0, //validationDuration\n', '          1, //location\n', '          2, //applicableType\n', '      ];\n', '  **/\n', '  uint[] public properties;\n', '\n', '\n', '  address public controller;\n', '\n', '  modifier onlyController { require(msg.sender == controller); _; }\n', '\n', '  function setController(address _newController) public onlyOwner {\n', '    controller = _newController;\n', '  }\n', '\n', '  constructor(uint256 _cap, uint[] _properties) public {\n', '    cap = _cap;\n', '    properties = _properties;\n', '  }\n', '\n', '  function setProperty(uint256[] _properties) public onlyOwner {\n', '    properties = _properties;\n', '  }\n', '\n', '\n', '  function _mint(address _to, uint _amount) internal {\n', '    require(cap==0 || totalSupply_.add(_amount) <= cap);\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '  }\n', '\n', '\n', '  function mint(address _to, uint256 _amount) onlyController public returns (bool) {\n', '    _mint(_to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '  function mintFromOwner(address _to, uint256 _amount) onlyOwner public returns (bool) {\n', '    _mint(_to, _amount);\n', '    return true;\n', '  }\n', '\n', '\n', '  function approveAndCall(address _spender, uint _amount, bytes _data) public {\n', '    if(approve(_spender, _amount)) {\n', '      TokenReceiver(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n', '    }\n', '  }\n', '\n', '\n', '  function checkCap(uint256 _amount) public view returns (bool) {\n', '  \treturn (cap==0 || totalSupply_.add(_amount) <= cap);\n', '  }\n', '\n', '\n', '\n', '\n', '}\n', '\n', '// File: contracts\\equipments\\PrizePool.sol\n', '\n', 'contract PrizePool is Ownable {\n', '\n', '  event SendPrized(address equipementAddress, address to);\n', '\n', '  address[] public magicBoxes;\n', '  mapping(address => bool) public magicBoxList;\n', '\n', '  address[] public equipments;\n', '  GirlOps public girlOps;\n', '\n', '  event SendEquipment(address to, address prizeAddress, uint time);\n', '  event EquipmentOutOfStock(address eqAddress);\n', '\n', '  modifier onlyMagicBox() {\n', '    require(magicBoxList[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  constructor(address _girlOpsAddress) public {\n', '    girlOps = GirlOps(_girlOpsAddress);\n', '  }\n', '\n', '  function sendPrize(address _to, uint _index) public onlyMagicBox returns (bool) {\n', '    //新确定方案，如果开箱开到某个道具没有了，直接选下一个\n', '    //递归调用，全部箱子如果都遍历完了全都脱销，则失败\n', '    //现在这样会开出箱子中没有的东西， 按理来讲应该开出箱子的下一个物品。\n', '    address prizeAddress = equipments[_index];\n', '    BaseEquipment baseEquipment = BaseEquipment(prizeAddress);\n', '    if(baseEquipment.checkCap(1 ether)) {\n', '      baseEquipment.mint(_to, 1 ether);\n', '      emit SendEquipment(_to, prizeAddress, now);\n', '      return true;\n', '    } else {\n', '      emit EquipmentOutOfStock(prizeAddress);\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function mintGirl(address to, uint gene, uint16 _level) public onlyMagicBox returns (bool) {\n', '    girlOps.createGirl(gene, to, _level);\n', '    return true;\n', '  }\n', '\n', '  function setEquipments(address[] _equipments) public onlyOwner {\n', '    equipments = _equipments;\n', '  }\n', '\n', '\n', '  function addMagicBox(address addr) public onlyOwner returns (bool) {\n', '    if (!magicBoxList[addr]) {\n', '      magicBoxList[addr] = true;\n', '      magicBoxes.push(addr);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function addMagicBoxes(address[] addrs) public onlyOwner returns (bool) {\n', '    for (uint i=0; i<addrs.length; i++) {\n', '      require(addMagicBox(addrs[i]));\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function removeMagicBox(address addr) public onlyOwner returns (bool) {\n', '    require(magicBoxList[addr]);\n', '    for (uint i=0; i<magicBoxes.length - 1; i++) {\n', '      if (magicBoxes[i] == addr) {\n', '        magicBoxes[i] = magicBoxes[magicBoxes.length -1];\n', '        break;\n', '      }\n', '    }\n', '    magicBoxes.length -= 1;\n', '    magicBoxList[addr] = false;\n', '    return true;\n', '  }\n', '\n', '}']