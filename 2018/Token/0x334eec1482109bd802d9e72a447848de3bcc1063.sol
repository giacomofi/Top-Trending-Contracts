['pragma solidity ^0.4.17;\n', '\n', 'contract AirDropToken {\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '\n', '    string _name;\n', '    string _symbol;\n', '    uint8 _decimals;\n', '\n', '    uint256 _totalSupply;\n', '\n', '    bytes32 _rootHash;\n', '\n', '    mapping (address => uint256) _balances;\n', '    mapping (address => mapping(address => uint256)) _allowed;\n', '\n', '    mapping (uint256 => uint256) _redeemed;\n', '\n', '    function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '        _rootHash = rootHash;\n', '\n', '        if (premine > 0) {\n', '            _balances[msg.sender] = premine;\n', '            _totalSupply = premine;\n', '            Transfer(0, msg.sender, premine);\n', '        }\n', '    }\n', '\n', '    function name() public constant returns (string name) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public constant returns (string symbol) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256 totalSupply) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '         return _balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return _allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint256 amount) public returns (bool success) {\n', '        if (_balances[msg.sender] < amount) { return false; }\n', '\n', '        _balances[msg.sender] -= amount;\n', '        _balances[to] += amount;\n', '\n', '        Transfer(msg.sender, to, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n', '\n', '        if (_allowed[from][msg.sender] < amount || _balances[from] < amount) {\n', '            return false;\n', '        }\n', '\n', '        _balances[from] -= amount;\n', '        _allowed[from][msg.sender] -= amount;\n', '        _balances[to] += amount;\n', '\n', '        Transfer(from, to, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool success) {\n', '        _allowed[msg.sender][spender] = amount;\n', '\n', '        Approval(msg.sender, spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function redeemed(uint256 index) public constant returns (bool redeemed) {\n', '        uint256 redeemedBlock = _redeemed[index / 256];\n', '        uint256 redeemedMask = (uint256(1) << uint256(index % 256));\n', '        return ((redeemedBlock & redeemedMask) != 0);\n', '    }\n', '\n', '    function redeemPackage(uint256 index, address recipient, uint256 amount, bytes32[] merkleProof) public {\n', '\n', '        // Make sure this package has not already been claimed (and claim it)\n', '        uint256 redeemedBlock = _redeemed[index / 256];\n', '        uint256 redeemedMask = (uint256(1) << uint256(index % 256));\n', '        require((redeemedBlock & redeemedMask) == 0);\n', '        _redeemed[index / 256] = redeemedBlock | redeemedMask;\n', '\n', '        // Compute the merkle root\n', '        bytes32 node = keccak256(index, recipient, amount);\n', '        uint256 path = index;\n', '        for (uint16 i = 0; i < merkleProof.length; i++) {\n', '            if ((path & 0x01) == 1) {\n', '                node = keccak256(merkleProof[i], node);\n', '            } else {\n', '                node = keccak256(node, merkleProof[i]);\n', '            }\n', '            path /= 2;\n', '        }\n', '\n', '        // Check the merkle proof\n', '        require(node == _rootHash);\n', '\n', '        // Redeem!\n', '        _balances[recipient] += amount;\n', '        _totalSupply += amount;\n', '\n', '        Transfer(0, recipient, amount);\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', 'contract AirDropToken {\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '\n', '    string _name;\n', '    string _symbol;\n', '    uint8 _decimals;\n', '\n', '    uint256 _totalSupply;\n', '\n', '    bytes32 _rootHash;\n', '\n', '    mapping (address => uint256) _balances;\n', '    mapping (address => mapping(address => uint256)) _allowed;\n', '\n', '    mapping (uint256 => uint256) _redeemed;\n', '\n', '    function AirDropToken(string name, string symbol, uint8 decimals, bytes32 rootHash, uint256 premine) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '        _rootHash = rootHash;\n', '\n', '        if (premine > 0) {\n', '            _balances[msg.sender] = premine;\n', '            _totalSupply = premine;\n', '            Transfer(0, msg.sender, premine);\n', '        }\n', '    }\n', '\n', '    function name() public constant returns (string name) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public constant returns (string symbol) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256 totalSupply) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n', '         return _balances[tokenOwner];\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n', '        return _allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function transfer(address to, uint256 amount) public returns (bool success) {\n', '        if (_balances[msg.sender] < amount) { return false; }\n', '\n', '        _balances[msg.sender] -= amount;\n', '        _balances[to] += amount;\n', '\n', '        Transfer(msg.sender, to, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) public returns (bool success) {\n', '\n', '        if (_allowed[from][msg.sender] < amount || _balances[from] < amount) {\n', '            return false;\n', '        }\n', '\n', '        _balances[from] -= amount;\n', '        _allowed[from][msg.sender] -= amount;\n', '        _balances[to] += amount;\n', '\n', '        Transfer(from, to, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool success) {\n', '        _allowed[msg.sender][spender] = amount;\n', '\n', '        Approval(msg.sender, spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function redeemed(uint256 index) public constant returns (bool redeemed) {\n', '        uint256 redeemedBlock = _redeemed[index / 256];\n', '        uint256 redeemedMask = (uint256(1) << uint256(index % 256));\n', '        return ((redeemedBlock & redeemedMask) != 0);\n', '    }\n', '\n', '    function redeemPackage(uint256 index, address recipient, uint256 amount, bytes32[] merkleProof) public {\n', '\n', '        // Make sure this package has not already been claimed (and claim it)\n', '        uint256 redeemedBlock = _redeemed[index / 256];\n', '        uint256 redeemedMask = (uint256(1) << uint256(index % 256));\n', '        require((redeemedBlock & redeemedMask) == 0);\n', '        _redeemed[index / 256] = redeemedBlock | redeemedMask;\n', '\n', '        // Compute the merkle root\n', '        bytes32 node = keccak256(index, recipient, amount);\n', '        uint256 path = index;\n', '        for (uint16 i = 0; i < merkleProof.length; i++) {\n', '            if ((path & 0x01) == 1) {\n', '                node = keccak256(merkleProof[i], node);\n', '            } else {\n', '                node = keccak256(node, merkleProof[i]);\n', '            }\n', '            path /= 2;\n', '        }\n', '\n', '        // Check the merkle proof\n', '        require(node == _rootHash);\n', '\n', '        // Redeem!\n', '        _balances[recipient] += amount;\n', '        _totalSupply += amount;\n', '\n', '        Transfer(0, recipient, amount);\n', '    }\n', '}']
