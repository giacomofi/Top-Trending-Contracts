['pragma solidity ^0.4.13;\n', '\n', '\n', '\n', '\n', 'interface ERC20Interface {\n', 'function totalSupply() external view returns (uint256);\n', '\n', '\n', '\n', '\n', 'function balanceOf(address who) external view returns (uint256);\n', '\n', '\n', '\n', '\n', 'function allowance(address owner, address spender)\n', 'external view returns (uint256);\n', '\n', '\n', '\n', '\n', 'function transfer(address to, uint256 value) external returns (bool);\n', '\n', '\n', '\n', '\n', 'function approve(address spender, uint256 value)\n', 'external returns (bool);\n', '\n', '\n', '\n', '\n', 'function transferFrom(address from, address to, uint256 value)\n', 'external returns (bool);\n', '\n', '\n', '\n', '\n', 'event Transfer(\n', 'address indexed from,\n', 'address indexed to,\n', 'uint256 value\n', ');\n', '\n', '\n', '\n', '\n', 'event Approval(\n', 'address indexed owner,\n', 'address indexed spender,\n', 'uint256 value\n', ');\n', '}\n', '\n', '\n', '\n', '\n', 'contract OpsCoin is ERC20Interface {\n', '\n', '\n', '\n', '\n', '/**\n', '@notice Â© Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n', '*/\n', '\n', '\n', '\n', '\n', 'using SafeMath for uint256;\n', '\n', '\n', '\n', '\n', 'string public symbol;\n', 'string public name;\n', 'address public owner;\n', 'uint256 public totalSupply;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'mapping (address => uint256) private balances;\n', 'mapping (address => mapping (address => uint256)) private allowed;\n', 'mapping (address => mapping (address => uint)) private timeLock;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'constructor() {\n', 'symbol = "OPS";\n', 'name = "EY OpsCoin";\n', 'totalSupply = 1000000;\n', 'owner = msg.sender;\n', 'balances[owner] = totalSupply;\n', 'emit Transfer(address(0), owner, totalSupply);\n', '}\n', '\n', '\n', '\n', '\n', '//only owner \xa0modifier\n', 'modifier onlyOwner () {\n', 'require(msg.sender == owner);\n', '_;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'self destruct added by westlad\n', '*/\n', 'function close() public onlyOwner {\n', 'selfdestruct(owner);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Gets the balance of the specified address.\n', '* @param _address The address to query the balance of.\n', '* @return An uint256 representing the amount owned by the passed address.\n', '*/\n', 'function balanceOf(address _address) public view returns (uint256) {\n', 'return balances[_address];\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '* @param _owner address The address which owns the funds.\n', '* @param _spender address The address which will spend the funds.\n', '* @return A uint256 specifying the amount of tokens still available for the spender.\n', '*/\n', 'function allowance(address _owner, address _spender) public view returns (uint256)\n', '{\n', 'return allowed[_owner][_spender];\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Total number of tokens in existence\n', '*/\n', 'function totalSupply() public view returns (uint256) {\n', 'return totalSupply;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Internal function that mints an amount of the token and assigns it to\n', '* an account. This encapsulates the modification of balances such that the\n', '* proper events are emitted.\n', '* @param _account The account that will receive the created tokens.\n', '* @param _amount The amount that will be created.\n', '*/\n', 'function mint(address _account, uint256 _amount) public {\n', 'require(_account != 0);\n', 'require(_amount > 0);\n', 'totalSupply = totalSupply.add(_amount);\n', 'balances[_account] = balances[_account].add(_amount);\n', 'emit Transfer(address(0), _account, _amount);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Internal function that burns an amount of the token of a given\n', '* account.\n', '* @param _account The account whose tokens will be burnt.\n', '* @param _amount The amount that will be burnt.\n', '*/\n', 'function burn(address _account, uint256 _amount) public {\n', 'require(_account != 0);\n', 'require(_amount <= balances[_account]);\n', '\n', '\n', '\n', '\n', 'totalSupply = totalSupply.sub(_amount);\n', 'balances[_account] = balances[_account].sub(_amount);\n', 'emit Transfer(_account, address(0), _amount);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Internal function that burns an amount of the token of a given\n', "* account, deducting from the sender's allowance for said account. Uses the\n", '* internal burn function.\n', '* @param _account The account whose tokens will be burnt.\n', '* @param _amount The amount that will be burnt.\n', '*/\n', 'function burnFrom(address _account, uint256 _amount) public {\n', 'require(_amount <= allowed[_account][msg.sender]);\n', '\n', '\n', '\n', '\n', 'allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n', 'emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n', 'burn(_account, _amount);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Transfer token for a specified address\n', '* @param _to The address to transfer to.\n', '* @param _value The amount to be transferred.\n', '*/\n', 'function transfer(address _to, uint256 _value) public returns (bool) {\n', 'require(_value <= balances[msg.sender]);\n', 'require(_to != address(0));\n', '\n', '\n', '\n', '\n', 'balances[msg.sender] = balances[msg.sender].sub(_value);\n', 'balances[_to] = balances[_to].add(_value);\n', 'emit Transfer(msg.sender, _to, _value);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '* Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '* @param _spender The address which will spend the funds.\n', '* @param _value The amount of tokens to be spent.\n', '*/\n', 'function approve(address _spender, uint256 _value) public returns (bool) {\n', 'require(_spender != address(0));\n', '\n', '\n', '\n', '\n', 'allowed[msg.sender][_spender] = _value;\n', 'emit Approval(msg.sender, _spender, _value);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Approve the passed address to spend the specified amount of tokens after a specfied amount of time on behalf of msg.sender.\n', '* Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '* @param _spender The address which will spend the funds.\n', '* @param _value The amount of tokens to be spent.\n', '* @param _timeLockTill The time until when this amount cannot be withdrawn\n', '*/\n', 'function approveAt(address _spender, uint256 _value, uint _timeLockTill) public returns (bool) {\n', 'require(_spender != address(0));\n', '\n', '\n', '\n', '\n', 'allowed[msg.sender][_spender] = _value;\n', 'timeLock[msg.sender][_spender] = _timeLockTill;\n', 'emit Approval(msg.sender, _spender, _value);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Transfer tokens from one address to another\n', '* @param _from address The address which you want to send tokens from\n', '* @param _to address The address which you want to transfer to\n', '* @param _value uint256 the amount of tokens to be transferred\n', '*/\n', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n', '{\n', 'require(_value <= balances[_from]);\n', 'require(_value <= allowed[_from][msg.sender]);\n', 'require(_to != address(0));\n', '\n', '\n', '\n', '\n', 'balances[_from] = balances[_from].sub(_value);\n', 'balances[_to] = balances[_to].add(_value);\n', 'allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', 'emit Transfer(_from, _to, _value);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Transfer tokens from one address to another\n', '* @param _from address The address which you want to send tokens from\n', '* @param _to address The address which you want to transfer to\n', '* @param _value uint256 the amount of tokens to be transferred\n', '*/\n', 'function transferFromAt(address _from, address _to, uint256 _value) public returns (bool)\n', '{\n', 'require(_value <= balances[_from]);\n', 'require(_value <= allowed[_from][msg.sender]);\n', 'require(_to != address(0));\n', 'require(block.timestamp > timeLock[_from][msg.sender]);\n', '\n', '\n', '\n', '\n', 'balances[_from] = balances[_from].sub(_value);\n', 'balances[_to] = balances[_to].add(_value);\n', 'allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', 'emit Transfer(_from, _to, _value);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Increase the amount of tokens that an owner allowed to a spender.\n', '* approve should be called when allowed_[_spender] == 0. To increment\n', '* allowed value is better to use this function to avoid 2 calls (and wait until\n', '* the first transaction is mined)\n', '* From MonolithDAO Token.sol\n', '* @param _spender The address which will spend the funds.\n', '* @param _addedValue The amount of tokens to increase the allowance by.\n', '*/\n', 'function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool)\n', '{\n', 'require(_spender != address(0));\n', '\n', '\n', '\n', '\n', 'allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n', 'emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '* approve should be called when allowed_[_spender] == 0. To decrement\n', '* allowed value is better to use this function to avoid 2 calls (and wait until\n', '* the first transaction is mined)\n', '* From MonolithDAO Token.sol\n', '* @param _spender The address which will spend the funds.\n', '* @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '*/\n', 'function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool)\n', '{\n', 'require(_spender != address(0));\n', '\n', '\n', '\n', '\n', 'allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].sub(_subtractedValue));\n', 'emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', 'return true;\n', '}\n', '\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract Verifier{\n', 'function verifyTx(\n', 'uint[2],\n', 'uint[2],\n', 'uint[2][2],\n', 'uint[2],\n', 'uint[2],\n', 'uint[2],\n', 'uint[2],\n', 'uint[2],\n', 'address\n', ') public pure returns (bool){}\n', '\n', '\n', '\n', '\n', '/**\n', '@notice Â© Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n', '*/\n', 'function getInputBits(uint, address) public view returns(bytes8){}\n', '}\n', '\n', '\n', '\n', '\n', 'contract OpsCoinShield{\n', '\n', '\n', '\n', '\n', '/**\n', '@notice Â© Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n', '\n', '\n', '\n', '\n', 'Contract to enable the management of ZKSnark-hidden coin transactions.\n', '*/\n', '\n', '\n', '\n', '\n', 'address public owner;\n', 'bytes8[merkleWidth] ns; //store spent token nullifiers\n', 'uint constant merkleWidth = 256;\n', 'uint constant merkleDepth = 9;\n', 'uint constant lastRow = merkleDepth-1;\n', 'uint private balance = 0;\n', 'bytes8[merkleWidth] private zs; //array holding the commitments. \xa0Basically the bottom row of the merkle tree\n', 'uint private zCount; //remember the number of commitments we hold\n', 'uint private nCount; //remember the number of commitments we spent\n', "bytes8[] private roots; //holds each root we've calculated so that we can pull the one relevant to the prover\n", 'uint private currentRootIndex; //holds the index for the current root so that the\n', '//prover can provide it later and this contract can look up the relevant root\n', 'Verifier private mv; //the verification smart contract that the mint function uses\n', 'Verifier private sv; //the verification smart contract that the transfer function uses\n', 'OpsCoin private ops; //the OpsCoin ERC20-like token contract\n', 'struct Proof { //recast this as a struct because otherwise, as a set of local variable, it takes too much stack space\n', 'uint[2] a;\n', 'uint[2] a_p;\n', 'uint[2][2] b;\n', 'uint[2] b_p;\n', 'uint[2] c;\n', 'uint[2] c_p;\n', 'uint[2] h;\n', 'uint[2] k;\n', '}\n', '//Proof proof; //not used - proof is now set per address\n', 'mapping(address => Proof) private proofs;\n', '\n', '\n', '\n', '\n', 'constructor(address mintVerifier, address transferVerifier, address opsCoin) public {\n', '// TODO - you can get a way with a single, generic verifier.\n', 'owner = msg.sender;\n', 'mv = Verifier(mintVerifier);\n', 'sv = Verifier(transferVerifier);\n', 'ops = OpsCoin(opsCoin);\n', '}\n', '\n', '\n', '\n', '\n', '//only owner \xa0modifier\n', 'modifier onlyOwner () {\n', 'require(msg.sender == owner);\n', '_;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'self destruct added by westlad\n', '*/\n', 'function close() public onlyOwner {\n', 'selfdestruct(owner);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'function getMintVerifier() public view returns(address){\n', 'return address(mv);\n', '}\n', '\n', '\n', '\n', '\n', 'function getTransferVerifier() public view returns(address){\n', 'return address(sv);\n', '}\n', '\n', '\n', '\n', '\n', 'function getOpsCoin() public view returns(address){\n', 'return address(ops);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'The mint function accepts opscoin and creates the same amount as a commitment.\n', '*/\n', 'function mint(uint amount) public {\n', '//first, verify the proof\n', '\n', '\n', '\n', '\n', 'bool result = mv.verifyTx(\n', 'proofs[msg.sender].a,\n', 'proofs[msg.sender].a_p,\n', 'proofs[msg.sender].b,\n', 'proofs[msg.sender].b_p,\n', 'proofs[msg.sender].c,\n', 'proofs[msg.sender].c_p,\n', 'proofs[msg.sender].h,\n', 'proofs[msg.sender].k,\n', 'msg.sender);\n', '\n', '\n', '\n', '\n', 'require(result); //the proof must check out\n', '//transfer OPS from the sender to this contract\n', 'ops.transferFrom(msg.sender, address(this), amount);\n', '//save the commitments\n', 'bytes8 z = mv.getInputBits(64, msg.sender);//recover the input params from MintVerifier\n', 'zs[zCount++] = z; //add the token\n', "require(uint(mv.getInputBits(0, msg.sender))==amount); //check we've been correctly paid\n", "bytes8 root = merkle(0,0); //work out the Merkle root as it's now different\n", 'currentRootIndex = roots.push(root)-1; //and save it to the list\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'The transfer function transfers a commitment to a new owner\n', '*/\n', 'function transfer() public {\n', '//verification contract\n', 'bool result = sv.verifyTx(\n', 'proofs[msg.sender].a,\n', 'proofs[msg.sender].a_p,\n', 'proofs[msg.sender].b,\n', 'proofs[msg.sender].b_p,\n', 'proofs[msg.sender].c,\n', 'proofs[msg.sender].c_p,\n', 'proofs[msg.sender].h,\n', 'proofs[msg.sender].k,\n', 'msg.sender);\n', 'require(result); //the proof must verify. The spice must flow.\n', '\n', '\n', '\n', '\n', 'bytes8 nc = sv.getInputBits(0, msg.sender);\n', 'bytes8 nd = sv.getInputBits(64, msg.sender);\n', 'bytes8 ze = sv.getInputBits(128, msg.sender);\n', 'bytes8 zf = sv.getInputBits(192, msg.sender);\n', 'for (uint i=0; i<nCount; i++) { //check this is an unspent coin\n', 'require(ns[i]!=nc && ns[i]!=nd);\n', '}\n', 'ns[nCount++] = nc; //remember we spent it\n', 'ns[nCount++] = nd; //remember we spent it\n', "zs[zCount++] = ze; //add Bob's commitment to the list of commitments\n", "zs[zCount++] = zf; //add Alice's commitment to the list of commitment\n", "bytes8 root = merkle(0,0); //work out the Merkle root as it's now different\n", 'currentRootIndex = roots.push(root)-1; //and save it to the list\n', '}\n', '\n', '\n', '\n', '\n', 'function burn(address payTo) public {\n', '//first, verify the proof\n', 'bool result = mv.verifyTx(\n', 'proofs[msg.sender].a,\n', 'proofs[msg.sender].a_p,\n', 'proofs[msg.sender].b,\n', 'proofs[msg.sender].b_p,\n', 'proofs[msg.sender].c,\n', 'proofs[msg.sender].c_p,\n', 'proofs[msg.sender].h,\n', 'proofs[msg.sender].k,\n', 'msg.sender);\n', '\n', '\n', '\n', '\n', 'require(result); //the proof must check out ok\n', '//transfer OPS from this contract to the nominated address\n', 'bytes8 C = mv.getInputBits(0, msg.sender);//recover the coin value\n', 'uint256 value = uint256(C); //convert the coin value to a uint\n', 'ops.transfer(payTo, value); //and pay the man\n', 'bytes8 Nc = mv.getInputBits(64, msg.sender); //recover the nullifier\n', 'ns[nCount++] = Nc; //add the nullifier to the list of nullifiers\n', "bytes8 root = merkle(0,0); //work out the Merkle root as it's now different\n", 'currentRootIndex = roots.push(root)-1; //and save it to the list\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'This function is only needed because mint and transfer otherwise use too many\n', 'local variables for the limited stack space, rather than pass a proof as\n', 'parameters to these functions (more logical)\n', '*/\n', 'function setProofParams(\n', 'uint[2] a,\n', 'uint[2] a_p,\n', 'uint[2][2] b,\n', 'uint[2] b_p,\n', 'uint[2] c,\n', 'uint[2] c_p,\n', 'uint[2] h,\n', 'uint[2] k)\n', 'public {\n', '//TODO there must be a shorter way to do this:\n', 'proofs[msg.sender].a[0] = a[0];\n', 'proofs[msg.sender].a[1] = a[1];\n', 'proofs[msg.sender].a_p[0] = a_p[0];\n', 'proofs[msg.sender].a_p[1] = a_p[1];\n', 'proofs[msg.sender].b[0][0] = b[0][0];\n', 'proofs[msg.sender].b[0][1] = b[0][1];\n', 'proofs[msg.sender].b[1][0] = b[1][0];\n', 'proofs[msg.sender].b[1][1] = b[1][1];\n', 'proofs[msg.sender].b_p[0] = b_p[0];\n', 'proofs[msg.sender].b_p[1] = b_p[1];\n', 'proofs[msg.sender].c[0] = c[0];\n', 'proofs[msg.sender].c[1] = c[1];\n', 'proofs[msg.sender].c_p[0] = c_p[0];\n', 'proofs[msg.sender].c_p[1] = c_p[1];\n', 'proofs[msg.sender].h[0] = h[0];\n', 'proofs[msg.sender].h[1] = h[1];\n', 'proofs[msg.sender].k[0] = k[0];\n', 'proofs[msg.sender].k[1] = k[1];\n', '}\n', '\n', '\n', '\n', '\n', 'function getTokens() public view returns(bytes8[merkleWidth], uint root) {\n', '//need the commitments to compute a proof and also an index to look up the current\n', '//root.\n', 'return (zs,currentRootIndex);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', 'Function to return the root that was current at rootIndex\n', '*/\n', 'function getRoot(uint rootIndex) view public returns(bytes8) {\n', 'return roots[rootIndex];\n', '}\n', '\n', '\n', '\n', '\n', 'function computeMerkle() public view returns (bytes8){//for backwards compat\n', 'return merkle(0,0);\n', '}\n', '\n', '\n', '\n', '\n', 'function merkle(uint r, uint t) public view returns (bytes8) {\n', '//This is a recursive approach, which seems efficient but we do end up\n', '//calculating the whole tree from scratch each time. \xa0Need to look at storing\n', '//intermediate values and seeing if that will make it cheaper.\n', 'if (r==lastRow) {\n', 'return zs[t];\n', '} else {\n', 'return bytes8(sha256(merkle(r+1,2*t)^merkle(r+1,2*t+1))<<192);\n', '}\n', '}\n', '}\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Multiplies two numbers, reverts on overflow.\n', '*/\n', 'function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "// benefit is lost if 'b' is also tested.\n", '// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', 'if (a == 0) {\n', 'return 0;\n', '}\n', '\n', '\n', '\n', '\n', 'uint256 c = a * b;\n', 'require(c / a == b);\n', '\n', '\n', '\n', '\n', 'return c;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '*/\n', 'function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b > 0); // Solidity only automatically asserts when dividing by 0\n', 'uint256 c = a / b;\n', "// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '\n', '\n', '\n', 'return c;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '*/\n', 'function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b <= a);\n', 'uint256 c = a - b;\n', '\n', '\n', '\n', '\n', 'return c;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Adds two numbers, reverts on overflow.\n', '*/\n', 'function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'uint256 c = a + b;\n', 'require(c >= a);\n', '\n', '\n', '\n', '\n', 'return c;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', '* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '* reverts when dividing by zero.\n', '*/\n', 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', 'require(b != 0);\n', 'return a % b;\n', '}\n', '}']