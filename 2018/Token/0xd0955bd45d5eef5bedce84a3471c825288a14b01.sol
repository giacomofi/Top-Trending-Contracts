['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '     /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else{\n', '            uint256 z = x;\n', '            for (uint256 i = 1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', 'interface shareProfit {\n', '    function increaseProfit() external payable returns(bool);\n', '}\n', '\n', 'contract RTB1 is shareProfit{\n', '    using SafeMath for uint256;\n', '\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 300;\n', '    uint256 public totalSold = 0;\n', '    uint256 public price = 1 ether;\n', '    string public name = "Retro Block Token 1";\n', '    string public symbol = "RTB1";\n', '    address public owner;\n', '    address public finance;\n', '    \n', '    mapping (address=>uint256) received;\n', '    uint256 profit;\n', '    address public jackpot;\n', '    mapping (address=>uint256) changeProfit;\n', '\n', '    mapping (address=>uint256) balances;\n', '    mapping (address=>mapping (address=>uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit);\n', '    event Withdraw(address indexed _addr, uint256 _value);\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only owner");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '        finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0;\n', '        jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC;\n', '        balances[this] = 300;\n', '    }\n', '\n', '    function() public payable {\n', '        if(msg.value > 0){\n', '            profit = msg.value.div(totalSupply).add(profit);\n', '            emit AddProfit(msg.sender, msg.value, profit);\n', '        }\n', '    }\n', '    \n', '    function increaseProfit() external payable returns(bool){\n', '        if(msg.value > 0){\n', '            profit = msg.value.div(totalSupply).add(profit);\n', '            emit AddProfit(msg.sender, msg.value, profit);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function totalSupply() external view returns (uint256){\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(_value > 0 && allowed[msg.sender][_spender] == 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        allowed[_from][msg.sender] -= _value;\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) external returns (bool) {\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '        require(_to != address(0), "Receiver address cannot be null");\n', '        require(_value > 0 && _value <= balances[_from]);\n', '        uint256 newToVal = balances[_to] + _value;\n', '        assert(newToVal >= balances[_to]);\n', '        uint256 newFromVal = balances[_from] - _value;\n', '        balances[_from] =  newFromVal;\n', '        balances[_to] = newToVal;\n', '        uint256 temp = _value.mul(profit);\n', '        changeProfit[_from] = changeProfit[_from].add(temp);\n', '        received[_to] = received[_to].add(temp);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function buy(uint256 _amount) external onlyHuman payable{\n', '        require(_amount > 0);\n', '        uint256 _money = _amount.mul(price);\n', '        require(msg.value == _money);\n', '        require(balances[this] >= _amount);\n', '        require((totalSupply - totalSold) >= _amount, "Sold out");\n', '        finance.transfer(_money.mul(80).div(100));\n', '        _transfer(this, msg.sender, _amount);\n', '        jackpot.transfer(_money.mul(20).div(100));\n', '        totalSold += _amount;\n', '    }\n', '\n', '    function withdraw() external {\n', '        uint256 value = getProfit(msg.sender);\n', '        require(value > 0, "No cash available");\n', '        emit Withdraw(msg.sender, value);\n', '        received[msg.sender] = received[msg.sender].add(value);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function getProfit(address _addr) public view returns(uint256){\n', '        return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]);\n', '    }\n', '    \n', '    function setJackpot(address _addr) public onlyOwner{\n', '        jackpot = _addr;\n', '    }\n', '    \n', '    function setFinance(address _addr) public onlyOwner{\n', '        finance = _addr;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '     /**\n', '     * @dev x to the power of y \n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else{\n', '            uint256 z = x;\n', '            for (uint256 i = 1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}\n', '\n', 'interface shareProfit {\n', '    function increaseProfit() external payable returns(bool);\n', '}\n', '\n', 'contract RTB1 is shareProfit{\n', '    using SafeMath for uint256;\n', '\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 300;\n', '    uint256 public totalSold = 0;\n', '    uint256 public price = 1 ether;\n', '    string public name = "Retro Block Token 1";\n', '    string public symbol = "RTB1";\n', '    address public owner;\n', '    address public finance;\n', '    \n', '    mapping (address=>uint256) received;\n', '    uint256 profit;\n', '    address public jackpot;\n', '    mapping (address=>uint256) changeProfit;\n', '\n', '    mapping (address=>uint256) balances;\n', '    mapping (address=>mapping (address=>uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit);\n', '    event Withdraw(address indexed _addr, uint256 _value);\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only owner");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '        \n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry humans only");\n', '        _;\n', '    }\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '        finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0;\n', '        jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC;\n', '        balances[this] = 300;\n', '    }\n', '\n', '    function() public payable {\n', '        if(msg.value > 0){\n', '            profit = msg.value.div(totalSupply).add(profit);\n', '            emit AddProfit(msg.sender, msg.value, profit);\n', '        }\n', '    }\n', '    \n', '    function increaseProfit() external payable returns(bool){\n', '        if(msg.value > 0){\n', '            profit = msg.value.div(totalSupply).add(profit);\n', '            emit AddProfit(msg.sender, msg.value, profit);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function totalSupply() external view returns (uint256){\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(_value > 0 && allowed[msg.sender][_spender] == 0);\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        allowed[_from][msg.sender] -= _value;\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) external returns (bool) {\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '        require(_to != address(0), "Receiver address cannot be null");\n', '        require(_value > 0 && _value <= balances[_from]);\n', '        uint256 newToVal = balances[_to] + _value;\n', '        assert(newToVal >= balances[_to]);\n', '        uint256 newFromVal = balances[_from] - _value;\n', '        balances[_from] =  newFromVal;\n', '        balances[_to] = newToVal;\n', '        uint256 temp = _value.mul(profit);\n', '        changeProfit[_from] = changeProfit[_from].add(temp);\n', '        received[_to] = received[_to].add(temp);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function buy(uint256 _amount) external onlyHuman payable{\n', '        require(_amount > 0);\n', '        uint256 _money = _amount.mul(price);\n', '        require(msg.value == _money);\n', '        require(balances[this] >= _amount);\n', '        require((totalSupply - totalSold) >= _amount, "Sold out");\n', '        finance.transfer(_money.mul(80).div(100));\n', '        _transfer(this, msg.sender, _amount);\n', '        jackpot.transfer(_money.mul(20).div(100));\n', '        totalSold += _amount;\n', '    }\n', '\n', '    function withdraw() external {\n', '        uint256 value = getProfit(msg.sender);\n', '        require(value > 0, "No cash available");\n', '        emit Withdraw(msg.sender, value);\n', '        received[msg.sender] = received[msg.sender].add(value);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    function getProfit(address _addr) public view returns(uint256){\n', '        return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]);\n', '    }\n', '    \n', '    function setJackpot(address _addr) public onlyOwner{\n', '        jackpot = _addr;\n', '    }\n', '    \n', '    function setFinance(address _addr) public onlyOwner{\n', '        finance = _addr;\n', '    }\n', '}']
