['pragma solidity ^0.4.19;\n', '\n', 'contract CrowdsaleLimit {\n', '  using SafeMath for uint256;\n', '\n', '  // the UNIX timestamp start date of the crowdsale\n', '  uint public startsAt;\n', '  // the UNIX timestamp end date of the crowdsale\n', '  uint public endsAt;\n', '  // setting the max token \n', '  uint public TOKEN_MAX;\n', '  // seting the wei value for one token in presale stage\n', '  uint public PRESALE_TOKEN_IN_WEI = 9 finney;\n', '  // total eth fund in presale stage\n', '  uint public presale_eth_fund= 0;\n', '  \n', '  // seting the wei value for one token in crowdsale stage\n', '  uint public CROWDSALE_TOKEN_IN_WEI = 10 finney;  \n', '  \n', '  // seting the max fund of presale with eth\n', '  uint public PRESALE_ETH_IN_WEI_FUND_MAX = 0 ether; \n', '  // seting the min fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MIN = 100 ether;\n', '  // seting the max fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MAX = 1000 ether;\n', '  // seting the min acceptable invest with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = 100 finney;   //0.1 ether\n', '  // seting the gasprice to limit big buyer, default to disable\n', '  uint public CROWDSALE_GASPRICE_IN_WEI_MAX = 0;\n', ' \n', '  // total eth fund\n', '  uint public crowdsale_eth_fund= 0;\n', '  // total eth refund\n', '  uint public crowdsale_eth_refund = 0;\n', '   \n', '  // setting team list and set percentage of tokens\n', '  mapping(address => uint) public team_addresses_token_percentage;\n', '  mapping(uint => address) public team_addresses_idx;\n', '  uint public team_address_count= 0;\n', '  uint public team_token_percentage_total= 0;\n', '  uint public team_token_percentage_max= 0;\n', '    \n', '  event EndsAtChanged(uint newEndsAt);\n', '  event AddTeamAddress(address addr, uint release_time, uint token_percentage);\n', '  event Refund(address investor, uint weiAmount);\n', '    \n', '  // limitation of buying tokens\n', '  modifier allowCrowdsaleAmountLimit(){\t\n', '\tif (msg.value == 0) revert();\n', '\tif (msg.value < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert();\n', '\tif((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert();\n', '\tif((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert();\n', '\t_;\n', '  }  \n', '   \n', '  function CrowdsaleLimit(uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max) {\n', '\trequire(_start != 0);\n', '\trequire(_end != 0);\n', '\trequire(_start < _end);\n', '\t\n', '\tif( (_presale_token_in_wei == 0) ||\n', '\t    (_crowdsale_token_in_wei == 0) ||\n', '\t\t(_crowdsale_eth_inwei_fund_min == 0) ||\n', '\t\t(_crowdsale_eth_inwei_fund_max == 0) ||\n', '\t\t(_crowdsale_eth_inwei_accepted_min == 0) ||\n', '\t\t(_team_token_percentage_max >= 100))  //example 20%=20\n', '\t\trevert();\n', '\t\t\n', '\tstartsAt = _start;\n', '    endsAt = _end;\n', '\t\n', '\tTOKEN_MAX = _token_max;\n', '\t\t\n', '\tPRESALE_TOKEN_IN_WEI = _presale_token_in_wei;\n', '\t\n', '\tCROWDSALE_TOKEN_IN_WEI = _crowdsale_token_in_wei;\t\n', '\tPRESALE_ETH_IN_WEI_FUND_MAX = _presale_eth_inwei_fund_max;\n', '\tCROWDSALE_ETH_IN_WEI_FUND_MIN = _crowdsale_eth_inwei_fund_min;\n', '\tCROWDSALE_ETH_IN_WEI_FUND_MAX = _crowdsale_eth_inwei_fund_max;\n', '\tCROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = _crowdsale_eth_inwei_accepted_min;\n', '\tCROWDSALE_GASPRICE_IN_WEI_MAX = _crowdsale_gasprice_inwei_max;\n', '\t\n', '\tteam_token_percentage_max= _team_token_percentage_max;\n', '  }\n', '    \n', '  // caculate amount of token in presale stage\n', '  function calculateTokenPresale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(PRESALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // caculate amount of token in crowdsale stage\n', '  function calculateTokenCrowsale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // check if the goal is reached\n', '  function isMinimumGoalReached() public constant returns (bool) {\n', '    return crowdsale_eth_fund >= CROWDSALE_ETH_IN_WEI_FUND_MIN;\n', '  }\n', '  \n', '  // add new team percentage of tokens\n', '  function addTeamAddressInternal(address addr, uint release_time, uint token_percentage) internal {\n', '\tif((team_token_percentage_total.add(token_percentage)) > team_token_percentage_max) revert();\n', '\tif((team_token_percentage_total.add(token_percentage)) > 100) revert();\n', '\tif(team_addresses_token_percentage[addr] != 0) revert();\n', '\t\n', '\tteam_addresses_token_percentage[addr]= token_percentage;\n', '\tteam_addresses_idx[team_address_count]= addr;\n', '\tteam_address_count++;\n', '\t\n', '\tteam_token_percentage_total = team_token_percentage_total.add(token_percentage);\n', '\n', '\tAddTeamAddress(addr, release_time, token_percentage);\n', '  }\n', '   \n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > endsAt;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is CrowdsaleLimit, Haltable {\n', '  using SafeMath for uint256;\n', '\n', '  CrowdsaleToken public token;\n', '  \n', '  /* tokens will be transfered from this address */\n', '  address public multisigWallet;\n', '    \n', '  /** How much ETH each address has invested to this crowdsale */\n', '  mapping (address => uint256) public investedAmountOf;\n', '\n', '  /** How much tokens this crowdsale has credited for each investor address */\n', '  mapping (address => uint256) public tokenAmountOf;\n', '  \n', '  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n', '  mapping (address => bool) public presaleWhitelist;\n', '  \n', '  bool public whitelist_enable= true;\n', '  \n', '  /* the number of tokens already sold through this contract*/\n', '  uint public tokensSold = 0;\n', '  \n', '  /* How many distinct addresses have invested */\n', '  uint public investorCount = 0;\n', '  \n', '  /* How much wei we have returned back to the contract after a failed crowdfund. */\n', '  uint public loadedRefund = 0;\n', '  \n', '  /* Has this crowdsale been finalized */\n', '  bool public finalized;\n', '  \n', '  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n', '    \n', '  // A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '  \n', '  // Address early participation whitelist status changed\n', '  event Whitelisted(address addr, bool status);\n', '  \n', '  event createTeamTokenEvent(address addr, uint tokens);\n', '  \n', '  event Finalized();\n', '  \n', '  /** Modified allowing execution only if the crowdsale is currently running.  */\n', '  modifier inState(State state) {\n', '    if(getState() != state) revert();\n', '    _;\n', '  }\n', '\n', '  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max, bool _whitelist_enable) \n', '           CrowdsaleLimit(_start, _end, _token_max, _presale_token_in_wei, _crowdsale_token_in_wei, _presale_eth_inwei_fund_max, _crowdsale_eth_inwei_fund_min, _crowdsale_eth_inwei_fund_max, _crowdsale_eth_inwei_accepted_min, _crowdsale_gasprice_inwei_max, _team_token_percentage_max)\n', '  {\n', '    require(_token != 0x0);\n', '    require(_multisigWallet != 0x0);\n', '\t\n', '\ttoken = CrowdsaleToken(_token);\t\n', '\tmultisigWallet = _multisigWallet;\n', '\t\n', '\twhitelist_enable= _whitelist_enable;\n', '  }\n', '  \n', '  /* Crowdfund state machine management. */\n', '  function getState() public constant returns (State) {\n', '    if(finalized) return State.Finalized;\n', '    else if (now < startsAt) return State.PreFunding;\n', '    else if (now <= endsAt && !isMinimumGoalReached()) return State.Funding;\n', '    else if (isMinimumGoalReached()) return State.Success;\n', '    else if (!isMinimumGoalReached() && crowdsale_eth_fund > 0 && loadedRefund >= crowdsale_eth_fund) return State.Refunding;\n', '    else return State.Failure;\n', '  }\n', '   \n', '  /**\n', '   * Allow addresses to do early participation.\n', '   *\n', '   * TODO: Fix spelling error in the name\n', '   */\n', '  function setPresaleWhitelist(address addr, bool status) onlyOwner inState(State.PreFunding) {\n', '\trequire(whitelist_enable==true);\n', '\n', '    presaleWhitelist[addr] = status;\n', '    Whitelisted(addr, status);\n', '  }\n', '  \n', '  //add new team percentage of tokens and lock their release time\n', '  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) external {\n', '\tsuper.addTeamAddressInternal(addr, release_time, token_percentage);\n', '\ttoken.addLockAddress(addr, release_time);  //not use delegatecall\n', '  }\n', '  \n', '  //generate team tokens in accordance with percentage of total issue tokens, not preallocate\n', '  function createTeamTokenByPercentage() onlyOwner internal {\n', '\t//uint total= token.totalSupply();\n', '\tuint total= tokensSold;\n', '\t\n', '\t//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);\n', '\tuint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);\n', '\t\n', '\tfor(uint i=0; i<team_address_count; i++) {\n', '\t\taddress addr= team_addresses_idx[i];\n', '\t\tif(addr==0x0) continue;\n', '\t\t\n', '\t\tuint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);\n', '\t\ttoken.mint(addr, ntoken);\t\t\n', '\t\tcreateTeamTokenEvent(addr, ntoken);\n', '\t}\n', '  }\n', '  \n', '  // fallback function can be used to buy tokens\n', '  function () stopInEmergency allowCrowdsaleAmountLimit payable {\n', '\trequire(msg.sender != 0x0);\n', '    buyTokensCrowdsale(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {\n', '\tuint256 weiAmount = msg.value;\n', '\tuint256 tokenAmount= 0;\n', '\t\n', '\tif(getState() == State.PreFunding) {\n', '\t\tif(whitelist_enable==true) {\n', '\t\t\tif(!presaleWhitelist[receiver]) {\n', '\t\t\t\trevert();\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif((PRESALE_ETH_IN_WEI_FUND_MAX > 0) && ((presale_eth_fund.add(weiAmount)) > PRESALE_ETH_IN_WEI_FUND_MAX)) revert();\t\t\n', '\t\t\n', '\t\ttokenAmount = calculateTokenPresale(weiAmount, token.decimals());\n', '\t\tpresale_eth_fund = presale_eth_fund.add(weiAmount);\n', '\t}\n', '\telse if((getState() == State.Funding) || (getState() == State.Success)) {\n', '\t\ttokenAmount = calculateTokenCrowsale(weiAmount, token.decimals());\n', '\t\t\n', '    } else {\n', '      // Unwanted state\n', '      revert();\n', '    }\n', '\t\n', '\tif(tokenAmount == 0) {\n', '\t\trevert();\n', '\t}\t\n', '\t\n', '\tif(investedAmountOf[receiver] == 0) {\n', '       investorCount++;\n', '    }\n', '    \n', '\t// Update investor\n', '    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '\t\n', '    // Update totals\n', '\tcrowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);\n', '\ttokensSold = tokensSold.add(tokenAmount);\n', '\t\n', '\tif((TOKEN_MAX > 0) && (tokensSold > TOKEN_MAX)) revert();\n', '\n', '    token.mint(receiver, tokenAmount);\n', '\n', '    if(!multisigWallet.send(weiAmount)) revert();\n', '\t\n', '\t// Tell us invest was success\n', '    Invested(receiver, weiAmount, tokenAmount);\n', '  }\n', ' \n', '  /**\n', '   * Allow load refunds back on the contract for the refunding.\n', '   *\n', '   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n', '   */\n', '  function loadRefund() public payable inState(State.Failure) {\n', '    if(msg.value == 0) revert();\n', '    loadedRefund = loadedRefund.add(msg.value);\n', '  }\n', '  \n', '  /**\n', '   * Investors can claim refund.\n', '   *\n', '   * Note that any refunds from proxy buyers should be handled separately,\n', '   * and not through this contract.\n', '   */\n', '  function refund() public inState(State.Refunding) {\n', '    uint256 weiValue = investedAmountOf[msg.sender];\n', '    if (weiValue == 0) revert();\n', '    investedAmountOf[msg.sender] = 0;\n', '    crowdsale_eth_refund = crowdsale_eth_refund.add(weiValue);\n', '    Refund(msg.sender, weiValue);\n', '    if (!msg.sender.send(weiValue)) revert();\n', '  }\n', '  \n', '  function setEndsAt(uint time) onlyOwner {\n', '    if(now > time) {\n', '      revert();\n', '    }\n', '\n', '    endsAt = time;\n', '    EndsAtChanged(endsAt);\n', '  }\n', '  \n', '  // should be called after crowdsale ends, to do\n', '  // some extra finalization work\n', '  function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '    \n', '\tif(finalized) {\n', '      revert();\n', '    }\n', '\n', '\tcreateTeamTokenByPercentage();\n', '    token.finishMinting();\t\n', '        \n', '    finalized = true;\n', '\tFinalized();\n', '  }\n', '  \n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  bool public mintingFinished = false;\n', '  \n', '  /** List of agents that are allowed to create new tokens */\n', '  mapping (address => bool) public mintAgents;\n', '\n', '  event MintingAgentChanged(address addr, bool state  );\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  modifier onlyMintAgent() {\n', '    // Only crowdsale contracts are allowed to mint new tokens\n', '    if(!mintAgents[msg.sender]) {\n', '        revert();\n', '    }\n', '    _;\n', '  }\n', '  \n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * Owner can allow a crowdsale contract to mint new tokens.\n', '   */\n', '  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n', '    mintAgents[addr] = state;\n', '    MintingAgentChanged(addr, state);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will recieve the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyMintAgent canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '\t\n', '\tTransfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyMintAgent public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract ReleasableToken is ERC20, Ownable {\n', '\n', '  /* The finalizer contract that allows unlift the transfer limits on this token */\n', '  address public releaseAgent;\n', '\n', '  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n', '  bool public released = false;\n', '\n', '  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n', '  mapping (address => bool) public transferAgents;\n', '  \n', '  //dtco : time lock with specific address\n', '  mapping(address => uint) public lock_addresses;\n', '  \n', '  event AddLockAddress(address addr, uint lock_time);  \n', '\n', '  /**\n', '   * Limit token transfer until the crowdsale is over.\n', '   *\n', '   */\n', '  modifier canTransfer(address _sender) {\n', '\n', '    if(!released) {\n', '        if(!transferAgents[_sender]) {\n', '            revert();\n', '        }\n', '    }\n', '\telse {\n', '\t\t//check time lock with team\n', '\t\tif(now < lock_addresses[_sender]) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '    _;\n', '  }\n', '  \n', '  function ReleasableToken() {\n', '\treleaseAgent = msg.sender;\n', '  }\n', '  \n', '  //lock new team release time\n', '  function addLockAddressInternal(address addr, uint lock_time) inReleaseState(false) internal {\n', '\tif(addr == 0x0) revert();\n', '\tlock_addresses[addr]= lock_time;\n', '\tAddLockAddress(addr, lock_time);\n', '  }\n', '  \n', '  \n', '  /**\n', '   * Set the contract that can call release and make the token transferable.\n', '   *\n', '   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n', '   */\n', '  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n', '\n', '    // We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\n', '    releaseAgent = addr;\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n', '   */\n', '  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n', '    transferAgents[addr] = state;\n', '  }\n', '  \n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyReleaseAgent() {\n', '    if(msg.sender != releaseAgent) {\n', '        revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * One way function to release the tokens to the wild.\n', '   *\n', '   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    released = true;\n', '  }\n', '\n', '  /** The function can be called only before or after the tokens have been releasesd */\n', '  modifier inReleaseState(bool releaseState) {\n', '    if(releaseState != released) {\n', '        revert();\n', '    }\n', '    _;\n', '  }  \n', '\n', '  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n', '    // Call StandardToken.transfer()\n', '   return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n', '    // Call StandardToken.transferForm()\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', 'contract CrowdsaleToken is ReleasableToken, MintableToken {\n', '\n', '  string public name;\n', '\n', '  string public symbol;\n', '\n', '  uint public decimals;\n', '    \n', '  /**\n', '   * Construct the token.\n', '   *\n', '   * @param _name Token name\n', '   * @param _symbol Token symbol - should be all caps\n', '   * @param _initialSupply How many tokens we start with\n', '   * @param _decimals Number of decimal places\n', '   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n', '   */\n', '  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) {\n', '\n', '    owner = msg.sender;\n', '\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    totalSupply_ = _initialSupply;\n', '\n', '    decimals = _decimals;\n', '\n', '    balances[owner] = totalSupply_;\n', '\n', '    if(totalSupply_ > 0) {\n', '      Mint(owner, totalSupply_);\n', '    }\n', '\n', '    // No more new supply allowed after the token creation\n', '    if(!_mintable) {\n', '      mintingFinished = true;\n', '      if(totalSupply_ == 0) {\n', '        revert(); // Cannot create a token without supply and no minting\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * When token is released to be transferable, enforce no new tokens can be created.\n', '   */\n', '   \n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    mintingFinished = true;\n', '    super.releaseTokenTransfer();\n', '  }\n', '  \n', '  //lock team address by crowdsale\n', '  function addLockAddress(address addr, uint lock_time) onlyMintAgent inReleaseState(false) public {\n', '\tsuper.addLockAddressInternal(addr, lock_time);\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract CrowdsaleLimit {\n', '  using SafeMath for uint256;\n', '\n', '  // the UNIX timestamp start date of the crowdsale\n', '  uint public startsAt;\n', '  // the UNIX timestamp end date of the crowdsale\n', '  uint public endsAt;\n', '  // setting the max token \n', '  uint public TOKEN_MAX;\n', '  // seting the wei value for one token in presale stage\n', '  uint public PRESALE_TOKEN_IN_WEI = 9 finney;\n', '  // total eth fund in presale stage\n', '  uint public presale_eth_fund= 0;\n', '  \n', '  // seting the wei value for one token in crowdsale stage\n', '  uint public CROWDSALE_TOKEN_IN_WEI = 10 finney;  \n', '  \n', '  // seting the max fund of presale with eth\n', '  uint public PRESALE_ETH_IN_WEI_FUND_MAX = 0 ether; \n', '  // seting the min fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MIN = 100 ether;\n', '  // seting the max fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MAX = 1000 ether;\n', '  // seting the min acceptable invest with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = 100 finney;   //0.1 ether\n', '  // seting the gasprice to limit big buyer, default to disable\n', '  uint public CROWDSALE_GASPRICE_IN_WEI_MAX = 0;\n', ' \n', '  // total eth fund\n', '  uint public crowdsale_eth_fund= 0;\n', '  // total eth refund\n', '  uint public crowdsale_eth_refund = 0;\n', '   \n', '  // setting team list and set percentage of tokens\n', '  mapping(address => uint) public team_addresses_token_percentage;\n', '  mapping(uint => address) public team_addresses_idx;\n', '  uint public team_address_count= 0;\n', '  uint public team_token_percentage_total= 0;\n', '  uint public team_token_percentage_max= 0;\n', '    \n', '  event EndsAtChanged(uint newEndsAt);\n', '  event AddTeamAddress(address addr, uint release_time, uint token_percentage);\n', '  event Refund(address investor, uint weiAmount);\n', '    \n', '  // limitation of buying tokens\n', '  modifier allowCrowdsaleAmountLimit(){\t\n', '\tif (msg.value == 0) revert();\n', '\tif (msg.value < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert();\n', '\tif((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert();\n', '\tif((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert();\n', '\t_;\n', '  }  \n', '   \n', '  function CrowdsaleLimit(uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max) {\n', '\trequire(_start != 0);\n', '\trequire(_end != 0);\n', '\trequire(_start < _end);\n', '\t\n', '\tif( (_presale_token_in_wei == 0) ||\n', '\t    (_crowdsale_token_in_wei == 0) ||\n', '\t\t(_crowdsale_eth_inwei_fund_min == 0) ||\n', '\t\t(_crowdsale_eth_inwei_fund_max == 0) ||\n', '\t\t(_crowdsale_eth_inwei_accepted_min == 0) ||\n', '\t\t(_team_token_percentage_max >= 100))  //example 20%=20\n', '\t\trevert();\n', '\t\t\n', '\tstartsAt = _start;\n', '    endsAt = _end;\n', '\t\n', '\tTOKEN_MAX = _token_max;\n', '\t\t\n', '\tPRESALE_TOKEN_IN_WEI = _presale_token_in_wei;\n', '\t\n', '\tCROWDSALE_TOKEN_IN_WEI = _crowdsale_token_in_wei;\t\n', '\tPRESALE_ETH_IN_WEI_FUND_MAX = _presale_eth_inwei_fund_max;\n', '\tCROWDSALE_ETH_IN_WEI_FUND_MIN = _crowdsale_eth_inwei_fund_min;\n', '\tCROWDSALE_ETH_IN_WEI_FUND_MAX = _crowdsale_eth_inwei_fund_max;\n', '\tCROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = _crowdsale_eth_inwei_accepted_min;\n', '\tCROWDSALE_GASPRICE_IN_WEI_MAX = _crowdsale_gasprice_inwei_max;\n', '\t\n', '\tteam_token_percentage_max= _team_token_percentage_max;\n', '  }\n', '    \n', '  // caculate amount of token in presale stage\n', '  function calculateTokenPresale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(PRESALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // caculate amount of token in crowdsale stage\n', '  function calculateTokenCrowsale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // check if the goal is reached\n', '  function isMinimumGoalReached() public constant returns (bool) {\n', '    return crowdsale_eth_fund >= CROWDSALE_ETH_IN_WEI_FUND_MIN;\n', '  }\n', '  \n', '  // add new team percentage of tokens\n', '  function addTeamAddressInternal(address addr, uint release_time, uint token_percentage) internal {\n', '\tif((team_token_percentage_total.add(token_percentage)) > team_token_percentage_max) revert();\n', '\tif((team_token_percentage_total.add(token_percentage)) > 100) revert();\n', '\tif(team_addresses_token_percentage[addr] != 0) revert();\n', '\t\n', '\tteam_addresses_token_percentage[addr]= token_percentage;\n', '\tteam_addresses_idx[team_address_count]= addr;\n', '\tteam_address_count++;\n', '\t\n', '\tteam_token_percentage_total = team_token_percentage_total.add(token_percentage);\n', '\n', '\tAddTeamAddress(addr, release_time, token_percentage);\n', '  }\n', '   \n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > endsAt;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is CrowdsaleLimit, Haltable {\n', '  using SafeMath for uint256;\n', '\n', '  CrowdsaleToken public token;\n', '  \n', '  /* tokens will be transfered from this address */\n', '  address public multisigWallet;\n', '    \n', '  /** How much ETH each address has invested to this crowdsale */\n', '  mapping (address => uint256) public investedAmountOf;\n', '\n', '  /** How much tokens this crowdsale has credited for each investor address */\n', '  mapping (address => uint256) public tokenAmountOf;\n', '  \n', '  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\n', '  mapping (address => bool) public presaleWhitelist;\n', '  \n', '  bool public whitelist_enable= true;\n', '  \n', '  /* the number of tokens already sold through this contract*/\n', '  uint public tokensSold = 0;\n', '  \n', '  /* How many distinct addresses have invested */\n', '  uint public investorCount = 0;\n', '  \n', '  /* How much wei we have returned back to the contract after a failed crowdfund. */\n', '  uint public loadedRefund = 0;\n', '  \n', '  /* Has this crowdsale been finalized */\n', '  bool public finalized;\n', '  \n', '  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n', '    \n', '  // A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '  \n', '  // Address early participation whitelist status changed\n', '  event Whitelisted(address addr, bool status);\n', '  \n', '  event createTeamTokenEvent(address addr, uint tokens);\n', '  \n', '  event Finalized();\n', '  \n', '  /** Modified allowing execution only if the crowdsale is currently running.  */\n', '  modifier inState(State state) {\n', '    if(getState() != state) revert();\n', '    _;\n', '  }\n', '\n', '  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max, bool _whitelist_enable) \n', '           CrowdsaleLimit(_start, _end, _token_max, _presale_token_in_wei, _crowdsale_token_in_wei, _presale_eth_inwei_fund_max, _crowdsale_eth_inwei_fund_min, _crowdsale_eth_inwei_fund_max, _crowdsale_eth_inwei_accepted_min, _crowdsale_gasprice_inwei_max, _team_token_percentage_max)\n', '  {\n', '    require(_token != 0x0);\n', '    require(_multisigWallet != 0x0);\n', '\t\n', '\ttoken = CrowdsaleToken(_token);\t\n', '\tmultisigWallet = _multisigWallet;\n', '\t\n', '\twhitelist_enable= _whitelist_enable;\n', '  }\n', '  \n', '  /* Crowdfund state machine management. */\n', '  function getState() public constant returns (State) {\n', '    if(finalized) return State.Finalized;\n', '    else if (now < startsAt) return State.PreFunding;\n', '    else if (now <= endsAt && !isMinimumGoalReached()) return State.Funding;\n', '    else if (isMinimumGoalReached()) return State.Success;\n', '    else if (!isMinimumGoalReached() && crowdsale_eth_fund > 0 && loadedRefund >= crowdsale_eth_fund) return State.Refunding;\n', '    else return State.Failure;\n', '  }\n', '   \n', '  /**\n', '   * Allow addresses to do early participation.\n', '   *\n', '   * TODO: Fix spelling error in the name\n', '   */\n', '  function setPresaleWhitelist(address addr, bool status) onlyOwner inState(State.PreFunding) {\n', '\trequire(whitelist_enable==true);\n', '\n', '    presaleWhitelist[addr] = status;\n', '    Whitelisted(addr, status);\n', '  }\n', '  \n', '  //add new team percentage of tokens and lock their release time\n', '  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) external {\n', '\tsuper.addTeamAddressInternal(addr, release_time, token_percentage);\n', '\ttoken.addLockAddress(addr, release_time);  //not use delegatecall\n', '  }\n', '  \n', '  //generate team tokens in accordance with percentage of total issue tokens, not preallocate\n', '  function createTeamTokenByPercentage() onlyOwner internal {\n', '\t//uint total= token.totalSupply();\n', '\tuint total= tokensSold;\n', '\t\n', '\t//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);\n', '\tuint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);\n', '\t\n', '\tfor(uint i=0; i<team_address_count; i++) {\n', '\t\taddress addr= team_addresses_idx[i];\n', '\t\tif(addr==0x0) continue;\n', '\t\t\n', '\t\tuint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);\n', '\t\ttoken.mint(addr, ntoken);\t\t\n', '\t\tcreateTeamTokenEvent(addr, ntoken);\n', '\t}\n', '  }\n', '  \n', '  // fallback function can be used to buy tokens\n', '  function () stopInEmergency allowCrowdsaleAmountLimit payable {\n', '\trequire(msg.sender != 0x0);\n', '    buyTokensCrowdsale(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {\n', '\tuint256 weiAmount = msg.value;\n', '\tuint256 tokenAmount= 0;\n', '\t\n', '\tif(getState() == State.PreFunding) {\n', '\t\tif(whitelist_enable==true) {\n', '\t\t\tif(!presaleWhitelist[receiver]) {\n', '\t\t\t\trevert();\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif((PRESALE_ETH_IN_WEI_FUND_MAX > 0) && ((presale_eth_fund.add(weiAmount)) > PRESALE_ETH_IN_WEI_FUND_MAX)) revert();\t\t\n', '\t\t\n', '\t\ttokenAmount = calculateTokenPresale(weiAmount, token.decimals());\n', '\t\tpresale_eth_fund = presale_eth_fund.add(weiAmount);\n', '\t}\n', '\telse if((getState() == State.Funding) || (getState() == State.Success)) {\n', '\t\ttokenAmount = calculateTokenCrowsale(weiAmount, token.decimals());\n', '\t\t\n', '    } else {\n', '      // Unwanted state\n', '      revert();\n', '    }\n', '\t\n', '\tif(tokenAmount == 0) {\n', '\t\trevert();\n', '\t}\t\n', '\t\n', '\tif(investedAmountOf[receiver] == 0) {\n', '       investorCount++;\n', '    }\n', '    \n', '\t// Update investor\n', '    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '\t\n', '    // Update totals\n', '\tcrowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);\n', '\ttokensSold = tokensSold.add(tokenAmount);\n', '\t\n', '\tif((TOKEN_MAX > 0) && (tokensSold > TOKEN_MAX)) revert();\n', '\n', '    token.mint(receiver, tokenAmount);\n', '\n', '    if(!multisigWallet.send(weiAmount)) revert();\n', '\t\n', '\t// Tell us invest was success\n', '    Invested(receiver, weiAmount, tokenAmount);\n', '  }\n', ' \n', '  /**\n', '   * Allow load refunds back on the contract for the refunding.\n', '   *\n', '   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n', '   */\n', '  function loadRefund() public payable inState(State.Failure) {\n', '    if(msg.value == 0) revert();\n', '    loadedRefund = loadedRefund.add(msg.value);\n', '  }\n', '  \n', '  /**\n', '   * Investors can claim refund.\n', '   *\n', '   * Note that any refunds from proxy buyers should be handled separately,\n', '   * and not through this contract.\n', '   */\n', '  function refund() public inState(State.Refunding) {\n', '    uint256 weiValue = investedAmountOf[msg.sender];\n', '    if (weiValue == 0) revert();\n', '    investedAmountOf[msg.sender] = 0;\n', '    crowdsale_eth_refund = crowdsale_eth_refund.add(weiValue);\n', '    Refund(msg.sender, weiValue);\n', '    if (!msg.sender.send(weiValue)) revert();\n', '  }\n', '  \n', '  function setEndsAt(uint time) onlyOwner {\n', '    if(now > time) {\n', '      revert();\n', '    }\n', '\n', '    endsAt = time;\n', '    EndsAtChanged(endsAt);\n', '  }\n', '  \n', '  // should be called after crowdsale ends, to do\n', '  // some extra finalization work\n', '  function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '    \n', '\tif(finalized) {\n', '      revert();\n', '    }\n', '\n', '\tcreateTeamTokenByPercentage();\n', '    token.finishMinting();\t\n', '        \n', '    finalized = true;\n', '\tFinalized();\n', '  }\n', '  \n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  bool public mintingFinished = false;\n', '  \n', '  /** List of agents that are allowed to create new tokens */\n', '  mapping (address => bool) public mintAgents;\n', '\n', '  event MintingAgentChanged(address addr, bool state  );\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  modifier onlyMintAgent() {\n', '    // Only crowdsale contracts are allowed to mint new tokens\n', '    if(!mintAgents[msg.sender]) {\n', '        revert();\n', '    }\n', '    _;\n', '  }\n', '  \n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '  \n', '  /**\n', '   * Owner can allow a crowdsale contract to mint new tokens.\n', '   */\n', '  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n', '    mintAgents[addr] = state;\n', '    MintingAgentChanged(addr, state);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will recieve the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyMintAgent canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '\t\n', '\tTransfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyMintAgent public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract ReleasableToken is ERC20, Ownable {\n', '\n', '  /* The finalizer contract that allows unlift the transfer limits on this token */\n', '  address public releaseAgent;\n', '\n', '  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n', '  bool public released = false;\n', '\n', '  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n', '  mapping (address => bool) public transferAgents;\n', '  \n', '  //dtco : time lock with specific address\n', '  mapping(address => uint) public lock_addresses;\n', '  \n', '  event AddLockAddress(address addr, uint lock_time);  \n', '\n', '  /**\n', '   * Limit token transfer until the crowdsale is over.\n', '   *\n', '   */\n', '  modifier canTransfer(address _sender) {\n', '\n', '    if(!released) {\n', '        if(!transferAgents[_sender]) {\n', '            revert();\n', '        }\n', '    }\n', '\telse {\n', '\t\t//check time lock with team\n', '\t\tif(now < lock_addresses[_sender]) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', '    _;\n', '  }\n', '  \n', '  function ReleasableToken() {\n', '\treleaseAgent = msg.sender;\n', '  }\n', '  \n', '  //lock new team release time\n', '  function addLockAddressInternal(address addr, uint lock_time) inReleaseState(false) internal {\n', '\tif(addr == 0x0) revert();\n', '\tlock_addresses[addr]= lock_time;\n', '\tAddLockAddress(addr, lock_time);\n', '  }\n', '  \n', '  \n', '  /**\n', '   * Set the contract that can call release and make the token transferable.\n', '   *\n', '   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n', '   */\n', '  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n', '\n', "    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n", '    releaseAgent = addr;\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n', '   */\n', '  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n', '    transferAgents[addr] = state;\n', '  }\n', '  \n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyReleaseAgent() {\n', '    if(msg.sender != releaseAgent) {\n', '        revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * One way function to release the tokens to the wild.\n', '   *\n', '   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    released = true;\n', '  }\n', '\n', '  /** The function can be called only before or after the tokens have been releasesd */\n', '  modifier inReleaseState(bool releaseState) {\n', '    if(releaseState != released) {\n', '        revert();\n', '    }\n', '    _;\n', '  }  \n', '\n', '  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n', '    // Call StandardToken.transfer()\n', '   return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n', '    // Call StandardToken.transferForm()\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', 'contract CrowdsaleToken is ReleasableToken, MintableToken {\n', '\n', '  string public name;\n', '\n', '  string public symbol;\n', '\n', '  uint public decimals;\n', '    \n', '  /**\n', '   * Construct the token.\n', '   *\n', '   * @param _name Token name\n', '   * @param _symbol Token symbol - should be all caps\n', '   * @param _initialSupply How many tokens we start with\n', '   * @param _decimals Number of decimal places\n', '   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n', '   */\n', '  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) {\n', '\n', '    owner = msg.sender;\n', '\n', '    name = _name;\n', '    symbol = _symbol;\n', '\n', '    totalSupply_ = _initialSupply;\n', '\n', '    decimals = _decimals;\n', '\n', '    balances[owner] = totalSupply_;\n', '\n', '    if(totalSupply_ > 0) {\n', '      Mint(owner, totalSupply_);\n', '    }\n', '\n', '    // No more new supply allowed after the token creation\n', '    if(!_mintable) {\n', '      mintingFinished = true;\n', '      if(totalSupply_ == 0) {\n', '        revert(); // Cannot create a token without supply and no minting\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * When token is released to be transferable, enforce no new tokens can be created.\n', '   */\n', '   \n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    mintingFinished = true;\n', '    super.releaseTokenTransfer();\n', '  }\n', '  \n', '  //lock team address by crowdsale\n', '  function addLockAddress(address addr, uint lock_time) onlyMintAgent inReleaseState(false) public {\n', '\tsuper.addLockAddressInternal(addr, lock_time);\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
