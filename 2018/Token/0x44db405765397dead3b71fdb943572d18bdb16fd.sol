['pragma solidity ^0.4.16;\n', '\n', 'interface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    event SelfMessage(address backer1, address backer2);\n', '    \n', '    modifier isOwner {\n', '        emit SelfMessage(msg.sender, owner);\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract GAMTToken is owned{\n', '    string public constant name = "ga-me.io token";\n', '    string public constant symbol = "GAMT";\n', '    uint8 public constant decimals = 18;  // 18 是建议的默认值\n', '    uint256 public totalSupply;\n', '    uint256 amountRaised = 0;\n', '    bool public crowdSale = false;\n', '\n', '    mapping (address => uint256) public balanceOf;  // \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    mapping (address => bool) public airDropAccount;\n', '    event FreezeAccount(address target, bool frozen);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event CrowdSaleTransfer(address backer, uint256 crowdNum,  uint256 amount, bool indexed isContribution);\n', '    \n', '\n', '    constructor() public {\n', '        totalSupply = 1000000000 * 10 ** uint256(decimals);\n', '        balanceOf[msg.sender] = totalSupply;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(!frozenAccount[msg.sender]);\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function () payable public{\n', '        require(crowdSale);\n', '        uint256 amountETH = msg.value;\n', '        uint256 count = amountETH / 10 ** uint256(15);\n', '        uint256 tokenNum = 0;\n', '        if (0 == amountETH){\n', '            require(!airDropAccount[msg.sender]);\n', '            tokenNum  = 200* 10 ** uint256(decimals);\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '\n', '            airDropAccount[msg.sender] = true;\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else if (0 <amountETH && amountETH <5 * 10 **uint256(16)) {\n', '            //0~0.05\n', '            tokenNum  = 1000*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else if (5 * 10 **uint256(16) <=amountETH && amountETH < 5 * 10 **uint256(17)) {\n', '            //0.05~0.05\n', '            tokenNum  = 1250*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else {\n', '            //0.5~\n', '            tokenNum  = 1500*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        }\n', '    }\n', '\n', '    function drawEther() isOwner public {\n', '            if (owner.send(amountRaised)) {\n', '                amountRaised = 0;\n', '            }\n', '    }\n', '\n', '    function onOffCrowdSale(bool onOff) isOwner public {\n', '        crowdSale = onOff;\n', '        if(false == crowdSale){\n', '            uint256 restToken = balanceOf[this];\n', '            if (restToken > 0){\n', '                _transfer(address(this), owner, restToken);\n', '            } else {\n', '            }\n', '        }\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze) isOwner public{\n', '        frozenAccount[target] = freeze;\n', '        emit FreezeAccount(target, freeze);\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'interface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    event SelfMessage(address backer1, address backer2);\n', '    \n', '    modifier isOwner {\n', '        emit SelfMessage(msg.sender, owner);\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract GAMTToken is owned{\n', '    string public constant name = "ga-me.io token";\n', '    string public constant symbol = "GAMT";\n', '    uint8 public constant decimals = 18;  // 18 是建议的默认值\n', '    uint256 public totalSupply;\n', '    uint256 amountRaised = 0;\n', '    bool public crowdSale = false;\n', '\n', '    mapping (address => uint256) public balanceOf;  // \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    mapping (address => bool) public airDropAccount;\n', '    event FreezeAccount(address target, bool frozen);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event CrowdSaleTransfer(address backer, uint256 crowdNum,  uint256 amount, bool indexed isContribution);\n', '    \n', '\n', '    constructor() public {\n', '        totalSupply = 1000000000 * 10 ** uint256(decimals);\n', '        balanceOf[msg.sender] = totalSupply;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(!frozenAccount[msg.sender]);\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function () payable public{\n', '        require(crowdSale);\n', '        uint256 amountETH = msg.value;\n', '        uint256 count = amountETH / 10 ** uint256(15);\n', '        uint256 tokenNum = 0;\n', '        if (0 == amountETH){\n', '            require(!airDropAccount[msg.sender]);\n', '            tokenNum  = 200* 10 ** uint256(decimals);\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '\n', '            airDropAccount[msg.sender] = true;\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else if (0 <amountETH && amountETH <5 * 10 **uint256(16)) {\n', '            //0~0.05\n', '            tokenNum  = 1000*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else if (5 * 10 **uint256(16) <=amountETH && amountETH < 5 * 10 **uint256(17)) {\n', '            //0.05~0.05\n', '            tokenNum  = 1250*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        } else {\n', '            //0.5~\n', '            tokenNum  = 1500*count*10 ** uint256(decimals);\n', '            amountRaised += amountETH;\n', '            _transfer(address(this), msg.sender, tokenNum);\n', '            emit CrowdSaleTransfer(msg.sender, amountETH, tokenNum, true);\n', '        }\n', '    }\n', '\n', '    function drawEther() isOwner public {\n', '            if (owner.send(amountRaised)) {\n', '                amountRaised = 0;\n', '            }\n', '    }\n', '\n', '    function onOffCrowdSale(bool onOff) isOwner public {\n', '        crowdSale = onOff;\n', '        if(false == crowdSale){\n', '            uint256 restToken = balanceOf[this];\n', '            if (restToken > 0){\n', '                _transfer(address(this), owner, restToken);\n', '            } else {\n', '            }\n', '        }\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze) isOwner public{\n', '        frozenAccount[target] = freeze;\n', '        emit FreezeAccount(target, freeze);\n', '    }\n', '}']
