['pragma solidity ^0.4.2;\n', '\n', 'contract Evocoin{\n', '\n', '  string public constant name = "Evocoin transit";\n', '  string public constant symbol = "EVCTS";\n', '  uint8 public constant decimals = 5;\n', '  uint public constant totalSupply = 7500000000*10**5;\n', '  uint userIndex = 0;\n', '  address public constant owner = 0x34A4933de38bF3830C7848aBb182d553F5a5D523;\n', '  \n', '  struct user{\n', '    address _adress;\n', '    uint _value;\n', '  }\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '  mapping (address => uint) balances;\n', '  mapping (uint => user) users;\n', '    \n', '  function Evocoin() public {\n', '    balances[owner] = totalSupply;\n', '    Transfer(address(this), owner, totalSupply);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public {\n', '    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '    require(_to != address(0x0));\n', '    \n', '    balances[_to] +=_value;\n', '    balances[_from] -= _value;\n', '    allowed[_from][msg.sender] -= _value;\n', '    \n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public {\n', '    require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '    require(_to != address(0x0));\n', '    \n', '    balances[msg.sender] -= _value;\n', '    balances[_to] += _value;\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  \n', '  function buyout() public { \n', '    require(msg.sender!=owner);\n', '    require(balances[msg.sender] > 0);\n', '    \n', '    uint _value = balances[msg.sender];\n', '    balances[msg.sender] = 0;\n', '    balances[owner] += _value;\n', '    \n', '    users[userIndex]._adress = msg.sender;\n', '    users[userIndex]._value = _value;\n', '    ++userIndex;\n', '    \n', '    Transfer(msg.sender, owner, _value);\n', '  }\n', '  \n', '  function getTransferedUser(uint _id) public view returns(address, uint){\n', '    return (users[_id]._adress, users[_id]._value);\n', '  }\n', '  \n', '  function isTransferedUser(address _adress) public view returns(bool){\n', '    uint i;\n', '    for(i=0; i<userIndex; i++){\n', '        if (users[i]._adress == _adress)\n', '            return true;\n', '    }\n', '    return false;\n', '  }\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}']
['pragma solidity ^0.4.2;\n', '\n', 'contract Evocoin{\n', '\n', '  string public constant name = "Evocoin transit";\n', '  string public constant symbol = "EVCTS";\n', '  uint8 public constant decimals = 5;\n', '  uint public constant totalSupply = 7500000000*10**5;\n', '  uint userIndex = 0;\n', '  address public constant owner = 0x34A4933de38bF3830C7848aBb182d553F5a5D523;\n', '  \n', '  struct user{\n', '    address _adress;\n', '    uint _value;\n', '  }\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '  mapping (address => uint) balances;\n', '  mapping (uint => user) users;\n', '    \n', '  function Evocoin() public {\n', '    balances[owner] = totalSupply;\n', '    Transfer(address(this), owner, totalSupply);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public {\n', '    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '    require(_to != address(0x0));\n', '    \n', '    balances[_to] +=_value;\n', '    balances[_from] -= _value;\n', '    allowed[_from][msg.sender] -= _value;\n', '    \n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function transfer(address _to, uint _value) public {\n', '    require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '    require(_to != address(0x0));\n', '    \n', '    balances[msg.sender] -= _value;\n', '    balances[_to] += _value;\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '  \n', '  function buyout() public { \n', '    require(msg.sender!=owner);\n', '    require(balances[msg.sender] > 0);\n', '    \n', '    uint _value = balances[msg.sender];\n', '    balances[msg.sender] = 0;\n', '    balances[owner] += _value;\n', '    \n', '    users[userIndex]._adress = msg.sender;\n', '    users[userIndex]._value = _value;\n', '    ++userIndex;\n', '    \n', '    Transfer(msg.sender, owner, _value);\n', '  }\n', '  \n', '  function getTransferedUser(uint _id) public view returns(address, uint){\n', '    return (users[_id]._adress, users[_id]._value);\n', '  }\n', '  \n', '  function isTransferedUser(address _adress) public view returns(bool){\n', '    uint i;\n', '    for(i=0; i<userIndex; i++){\n', '        if (users[i]._adress == _adress)\n', '            return true;\n', '    }\n', '    return false;\n', '  }\n', '  \n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}']
