['pragma solidity ^0.4.21;\n', '\n', '/// @title SafeMath contract - Math operations with safety checks.\n', '/// @author OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'contract SafeMath {\n', '    function mulsm(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function divsm(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function subsm(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function addsm(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function powsm(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a ** b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '\n', '    event NewOwner(address old, address current);\n', '    event NewPotentialOwner(address old, address potential);\n', '\n', '    address public owner = msg.sender;\n', '    address public potentialOwner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPotentialOwner {\n', '        require(msg.sender == potentialOwner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _new) public onlyOwner {\n', '        emit NewPotentialOwner(owner, _new);\n', '        potentialOwner = _new;\n', '    }\n', '\n', '    function confirmOwnership() public onlyPotentialOwner {\n', '        emit NewOwner(owner, potentialOwner);\n', '        owner = potentialOwner;\n', '        potentialOwner = 0;\n', '    }\n', '}\n', '\n', 'contract Managed is Owned {\n', '\n', '    event NewManager(address owner, address manager);\n', '\n', '    mapping (address => bool) public manager;\n', '\n', '    modifier onlyManager() {\n', '        require(manager[msg.sender] == true || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setManager(address _manager) public onlyOwner {\n', '        emit NewManager(owner, _manager);\n', '        manager[_manager] = true;\n', '    }\n', '\n', '    function superManager(address _manager) internal {\n', '        emit NewManager(owner, _manager);\n', '        manager[_manager] = true;\n', '    }\n', '\n', '    function delManager(address _manager) public onlyOwner {\n', '        emit NewManager(owner, _manager);\n', '        manager[_manager] = false;\n', '    }\n', '}\n', '\n', '/// @title Abstract Token, ERC20 token interface\n', 'contract ERC20 {\n', '\n', '    function name() constant public returns (string);\n', '    function symbol() constant public returns (string);\n', '    function decimals() constant public returns (uint8);\n', '    function totalSupply() constant public returns (uint256);\n', '    function balanceOf(address owner) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// Full complete implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', 'contract StandardToken is SafeMath, ERC20  {\n', '\n', '    string  public name;\n', '    string  public symbol;\n', '    uint8   public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    function name() public view returns (string) {\n', '        return name;\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    function symbol() public view returns (string) {\n', '        return symbol;\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    function decimals() public view returns (uint8) {\n', '        return decimals;\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev Transfers sender&#39;s tokens to a given address. Returns success.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(this)); //prevent direct send to contract\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '/**\n', '   @title ERC827 interface, an extension of ERC20 token standard\n', '\n', '   Interface of a ERC827 token, following the ERC20 standard with extra\n', '   methods to transfer value and data and execute calls in transfers and\n', '   approvals.\n', ' */\n', 'contract ERC827 {\n', '\n', '  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n', '  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n', '  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n', '\n', '}\n', '\n', '/**\n', '   @title ERC827, an extension of ERC20 token standard\n', '\n', '   Implementation the ERC827, following the ERC20 standard with extra\n', '   methods to transfer value and data and execute calls in transfers and\n', '   approvals.\n', '   Uses OpenZeppelin StandardToken.\n', ' */\n', 'contract ERC827Token is ERC827, StandardToken {\n', '\n', '  /**\n', '     @dev Addition to ERC20 token methods. It allows to\n', '     approve the transfer of value and execute a call with the sent data.\n', '\n', '     Beware that changing an allowance with this method brings the risk that\n', '     someone may use both the old and the new allowance by unfortunate\n', '     transaction ordering. One possible solution to mitigate this race condition\n', '     is to first reduce the spender&#39;s allowance to 0 and set the desired value\n', '     afterwards:\n', '     https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\n', '     @param _spender The address that will spend the funds.\n', '     @param _value The amount of tokens to be spent.\n', '     @param _data ABI-encoded contract call to call `_to` address.\n', '\n', '     @return true if the call function was executed successfully\n', '   */\n', '  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n', '    require(_spender != address(this));\n', '\n', '    super.approve(_spender, _value);\n', '\n', '    require(_spender.call(_data));\n', '\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n', '    require(_to != address(this));\n', '\n', '    super.transfer(_to, _value);\n', '\n', '    require(_to.call(_data));\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n', '    require(_to != address(this));\n', '\n', '    super.transferFrom(_from, _to, _value);\n', '\n', '    require(_to.call(_data));\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract MintableToken is ERC827Token {\n', '\n', '        uint256 constant maxSupply = 1e30; // max amount of tokens 1 trillion\n', '        bool internal mintable = true;\n', '\n', '        modifier isMintable() {\n', '            require(mintable);\n', '            _;\n', '        }\n', '\n', '        function stopMint() internal {\n', '            mintable = false;\n', '        }\n', '\n', '        // triggered when the total supply is increased\n', '        event Issuance(uint256 _amount);\n', '        // triggered when the total supply is decreased\n', '        event Destruction(uint256 _amount);\n', '\n', '        /**\n', '            @dev increases the token supply and sends the new tokens to an account\n', '            can only be called by the contract owner\n', '            @param _to         account to receive the new amount\n', '            @param _amount     amount to increase the supply by\n', '        */\n', '        function issue(address _to, uint256 _amount) internal {\n', '            assert(totalSupply + _amount <= maxSupply); // prevent overflows\n', '            totalSupply +=  _amount;\n', '            balances[_to] += _amount;\n', '            emit Issuance(_amount);\n', '            emit Transfer(this, _to, _amount);\n', '        }\n', '\n', '        /**\n', '            @dev removes tokens from an account and decreases the token supply\n', '            can only be called by the contract owner\n', '            (if robbers detected, if will be consensus about token amount)\n', '\n', '            @param _from       account to remove the amount from\n', '            @param _amount     amount to decrease the supply by\n', '        */\n', '        /* function destroy(address _from, uint256 _amount) public onlyOwner {\n', '            balances[_from] -= _amount;\n', '            _totalSupply -= _amount;\n', '            Transfer(_from, this, _amount);\n', '            Destruction(_amount);\n', '        } */\n', '}\n', '\n', 'contract PaymentManager is MintableToken, Owned {\n', '\n', '    uint256 public receivedWais;\n', '    uint256 internal _price;\n', '    bool internal paused = false;\n', '\n', '    modifier isSuspended() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '   function setPrice(uint256 _value) public onlyOwner returns (bool) {\n', '        _price = _value;\n', '        return true;\n', '    }\n', '\n', '    function watchPrice() public view returns (uint256 price) {\n', '        return _price;\n', '    }\n', '\n', '    function rateSystem(address _to, uint256 _value) internal returns (bool) {\n', '        uint256 _amount;\n', '        if(_value >= (1 ether / 1000) && _value <= 1 ether) {\n', '            _amount = _value * _price;\n', '        } else\n', '        if(_value >= 1 ether) {\n', '             _amount = divsm(powsm(_value, 2), 1 ether) * _price;\n', '        }\n', '        issue(_to, _amount);\n', '        if(paused == false) {\n', '            if(totalSupply > 1 * 10e9 * 1 * 1 ether) paused = true; // if more then 10 billions stop sell\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /** @dev transfer ethereum from contract */\n', '    function transferEther(address _to, uint256 _value) public onlyOwner {\n', '        _to.transfer(_value);\n', '    }\n', '}\n', '\n', 'contract InvestBox is PaymentManager, Managed {\n', '\n', '    // triggered when the amount of reaward are changed\n', '    event BonusChanged(uint256 _amount);\n', '    // triggered when making invest\n', '    event Invested(address _from, uint256 _value);\n', '    // triggered when invest closed or updated\n', '    event InvestClosed(address _who, uint256 _value);\n', '    // triggered when counted\n', '    event Counted(address _sender, uint256 _intervals);\n', '\n', '    uint256 constant _day = 24 * 60 * 60 * 1 seconds;\n', '\n', '    bytes5 internal _td = bytes5("day");\n', '    bytes5 internal _tw = bytes5("week");\n', '    bytes5 internal _tm = bytes5("month");\n', '    bytes5 internal _ty = bytes5("year");\n', '\n', '    uint256 internal _creation;\n', '    uint256 internal _1sty;\n', '    uint256 internal _2ndy;\n', '\n', '    uint256 internal min_invest;\n', '    uint256 internal max_invest;\n', '\n', '    struct invest {\n', '        bool exists;\n', '        uint256 balance;\n', '        uint256 created; // creation time\n', '        uint256 closed;  // closing time\n', '    }\n', '\n', '    mapping (address => mapping (bytes5 => invest)) public investInfo;\n', '\n', '    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    /** @dev return in interface string encoded to bytes (max len 5 bytes) */\n', '    function stringToBytes5(string _data) public pure returns (bytes5) {\n', '        return bytes5(stringToBytes32(_data));\n', '    }\n', '\n', '    struct intervalBytecodes {\n', '        string day;\n', '        string week;\n', '        string month;\n', '        string year;\n', '    }\n', '\n', '    intervalBytecodes public IntervalBytecodes;\n', '\n', '    /** @dev setter min max params for investition */\n', '    function setMinMaxInvestValue(uint256 _min, uint256 _max) public onlyOwner {\n', '        min_invest = _min * 10 ** uint256(decimals);\n', '        max_invest = _max * 10 ** uint256(decimals);\n', '    }\n', '\n', '    /** @dev number of complete cycles d/m/w/y */\n', '    function countPeriod(address _investor, bytes5 _t) internal view returns (uint256) {\n', '        uint256 _period;\n', '        uint256 _now = now; // blocking timestamp\n', '        if (_t == _td) _period = 1 * _day;\n', '        if (_t == _tw) _period = 7 * _day;\n', '        if (_t == _tm) _period = 31 * _day;\n', '        if (_t == _ty) _period = 365 * _day;\n', '        invest storage inv = investInfo[_investor][_t];\n', '        if (_now - inv.created < _period) return 0;\n', '        return (_now - inv.created)/_period; // get full days\n', '    }\n', '\n', '    /** @dev loop &#39;for&#39; wrapper, where 100,000%, 10^3 decimal */\n', '    function loopFor(uint256 _condition, uint256 _data, uint256 _bonus) internal pure returns (uint256 r) {\n', '        assembly {\n', '            for { let i := 0 } lt(i, _condition) { i := add(i, 1) } {\n', '              let m := mul(_data, _bonus)\n', '              let d := div(m, 100000)\n', '              _data := add(_data, d)\n', '            }\n', '            r := _data\n', '        }\n', '    }\n', '\n', '    /** @dev invest box controller */\n', '    function rewardController(address _investor, bytes5 _type) internal view returns (uint256) {\n', '\n', '        uint256 _period;\n', '        uint256 _balance;\n', '        uint256 _created;\n', '\n', '        invest storage inv = investInfo[msg.sender][_type];\n', '\n', '        _period = countPeriod(_investor, _type);\n', '        _balance = inv.balance;\n', '        _created = inv.created;\n', '\n', '        uint256 full_steps;\n', '        uint256 last_step;\n', '        uint256 _d;\n', '\n', '        if(_type == _td) _d = 365;\n', '        if(_type == _tw) _d = 54;\n', '        if(_type == _tm) _d = 12;\n', '        if(_type == _ty) _d = 1;\n', '\n', '        full_steps = _period/_d;\n', '        last_step = _period - (full_steps * _d);\n', '\n', '        for(uint256 i=0; i<full_steps; i++) { // not executed if zero\n', '            _balance = compaundIntrest(_d, _type, _balance, _created);\n', '            _created += 1 years;\n', '        }\n', '\n', '        if(last_step > 0) _balance = compaundIntrest(last_step, _type, _balance, _created);\n', '\n', '        return _balance;\n', '    }\n', '\n', '    /**\n', '        @dev Compaund Intrest realization, return balance + Intrest\n', '        @param _period - time interval dependent from invest time\n', '    */\n', '    function compaundIntrest(uint256 _period, bytes5 _type, uint256 _balance, uint256 _created) internal view returns (uint256) {\n', '        uint256 full_steps;\n', '        uint256 last_step;\n', '        uint256 _d = 100; // safe divider\n', '        uint256 _bonus = bonusSystem(_type, _created);\n', '\n', '        if (_period>_d) {\n', '            full_steps = _period/_d;\n', '            last_step = _period - (full_steps * _d);\n', '            for(uint256 i=0; i<full_steps; i++) {\n', '                _balance = loopFor(_d, _balance, _bonus);\n', '            }\n', '            if(last_step > 0) _balance = loopFor(last_step, _balance, _bonus);\n', '        } else\n', '        if (_period<=_d) {\n', '            _balance = loopFor(_period, _balance, _bonus);\n', '        }\n', '        return _balance;\n', '    }\n', '\n', '    /** @dev Bonus program */\n', '    function bonusSystem(bytes5 _t, uint256 _now) internal view returns (uint256) {\n', '        uint256 _b;\n', '        if (_t == _td) {\n', '            if (_now < _1sty) {\n', '                _b = 600; // 0.6 %/day  // 100.6 % by day => 887.69 % by year\n', '            } else\n', '            if (_now >= _1sty && _now < _2ndy) {\n', '                _b = 300; // 0.3 %/day\n', '            } else\n', '            if (_now >= _2ndy) {\n', '                _b = 30; // 0.03 %/day\n', '            }\n', '        }\n', '        if (_t == _tw) {\n', '            if (_now < _1sty) {\n', '                _b = 5370; // 0.75 %/day => 5.37 % by week => 1529.13 % by year\n', '            } else\n', '            if (_now >= _1sty && _now < _2ndy) {\n', '                _b = 2650; // 0.375 %/day\n', '            } else\n', '            if (_now >= _2ndy) {\n', '                _b = 270; // 0.038 %/day\n', '            }\n', '        }\n', '        if (_t == _tm) {\n', '            if (_now < _1sty) {\n', '                _b = 30000; // 0.85 %/day // 130 % by month => 2196.36 % by year\n', '            } else\n', '            if (_now >= _1sty && _now < _2ndy) {\n', '\n', '                _b = 14050; // 0.425 %/day\n', '            } else\n', '            if (_now >= _2ndy) {\n', '                _b = 1340; // 0.043 %/day\n', '            }\n', '        }\n', '        if (_t == _ty) {\n', '            if (_now < _1sty) {\n', '                _b = 3678000; // 1 %/day // 3678.34 * 1000 = 3678340 = 3678% by year\n', '            } else\n', '            if (_now >= _1sty && _now < _2ndy) {\n', '                _b = 517470; // 0.5 %/day\n', '            } else\n', '            if (_now >= _2ndy) {\n', '                _b = 20020; // 0.05 %/day\n', '            }\n', '        }\n', '        return _b;\n', '    }\n', '\n', '    /** @dev make invest */\n', '    function makeInvest(uint256 _value, bytes5 _interval) internal isMintable {\n', '        require(min_invest <= _value && _value <= max_invest); // min max condition\n', '        assert(balances[msg.sender] >= _value && balances[this] + _value > balances[this]);\n', '        balances[msg.sender] -= _value;\n', '        balances[this] += _value;\n', '        invest storage inv = investInfo[msg.sender][_interval];\n', '        if (inv.exists == false) { // if invest no exists\n', '            inv.balance = _value;\n', '            inv.created = now;\n', '            inv.closed = 0;\n', '            emit Transfer(msg.sender, this, _value);\n', '        } else\n', '        if (inv.exists == true) {\n', '            uint256 rew = rewardController(msg.sender, _interval);\n', '            inv.balance = _value + rew;\n', '            inv.closed = 0;\n', '            emit Transfer(0x0, this, rew); // fix rise total supply\n', '        }\n', '        inv.exists = true;\n', '        emit Invested(msg.sender, _value);\n', '        if(totalSupply > maxSupply) stopMint(); // stop invest\n', '    }\n', '\n', '    function makeDailyInvest(uint256 _value) public {\n', '        makeInvest(_value * 10 ** uint256(decimals), _td);\n', '    }\n', '\n', '    function makeWeeklyInvest(uint256 _value) public {\n', '        makeInvest(_value * 10 ** uint256(decimals), _tw);\n', '    }\n', '\n', '    function makeMonthlyInvest(uint256 _value) public {\n', '        makeInvest(_value * 10 ** uint256(decimals), _tm);\n', '    }\n', '\n', '    function makeAnnualInvest(uint256 _value) public {\n', '        makeInvest(_value * 10 ** uint256(decimals), _ty);\n', '    }\n', '\n', '    /** @dev close invest */\n', '    function closeInvest(bytes5 _interval) internal {\n', '        uint256 _intrest;\n', '        address _to = msg.sender;\n', '        uint256 _period = countPeriod(_to, _interval);\n', '        invest storage inv = investInfo[_to][_interval];\n', '        uint256 _value = inv.balance;\n', '        if (_period == 0) {\n', '            balances[this] -= _value;\n', '            balances[_to] += _value;\n', '            emit Transfer(this, _to, _value); // tx of begining balance\n', '            emit InvestClosed(_to, _value);\n', '        } else\n', '        if (_period > 0) {\n', '            // Destruction init\n', '            balances[this] -= _value;\n', '            totalSupply -= _value;\n', '            emit Transfer(this, 0x0, _value);\n', '            emit Destruction(_value);\n', '            // Issue init\n', '            _intrest = rewardController(_to, _interval);\n', '            if(manager[msg.sender]) {\n', '                _intrest = mulsm(divsm(_intrest, 100), 105); // addition 5% bonus for manager\n', '            }\n', '            issue(_to, _intrest); // tx of %\n', '            emit InvestClosed(_to, _intrest);\n', '        }\n', '        inv.exists = false; // invest inv clear\n', '        inv.balance = 0;\n', '        inv.closed = now;\n', '    }\n', '\n', '    function closeDailyInvest() public {\n', '        closeInvest(_td);\n', '    }\n', '\n', '    function closeWeeklyInvest() public {\n', '        closeInvest(_tw);\n', '    }\n', '\n', '    function closeMonthlyInvest() public {\n', '        closeInvest(_tm);\n', '    }\n', '\n', '    function closeAnnualInvest() public {\n', '        closeInvest(_ty);\n', '    }\n', '\n', '    /** @dev safe closing invest, checking for complete by date. */\n', '    function isFullInvest(address _ms, bytes5 _t) internal returns (uint256) {\n', '        uint256 res = countPeriod(_ms, _t);\n', '        emit Counted(msg.sender, res);\n', '        return res;\n', '    }\n', '\n', '    function countDays() public returns (uint256) {\n', '        return isFullInvest(msg.sender, _td);\n', '    }\n', '\n', '    function countWeeks() public returns (uint256) {\n', '        return isFullInvest(msg.sender, _tw);\n', '    }\n', '\n', '    function countMonths() public returns (uint256) {\n', '        return isFullInvest(msg.sender, _tm);\n', '    }\n', '\n', '    function countYears() public returns (uint256) {\n', '        return isFullInvest(msg.sender, _ty);\n', '    }\n', '}\n', '\n', 'contract EthereumRisen is InvestBox {\n', '\n', '    // devs addresess, pay for code\n', '    address public devWallet = address(0x00FBB38c017843DFa86a97c31fECaCFF0a092F6F);\n', '    uint256 constant public devReward = 100000 * 1e18; // 100K\n', '\n', '    // fondation for pay by promotion this project\n', '    address public bountyWallet = address(0x00Ed07D0170B1c5F3EeDe1fC7261719e04b15ecD);\n', '    uint256 constant public bountyReward = 50000 * 1e18; // 50K\n', '\n', '    // will be send for first 10k rischest wallets, if it is enough to pay the commission\n', '    address public airdropWallet = address(0x000DdB5A903d15b2F7f7300f672d2EB9bF882143);\n', '    uint256 constant public airdropReward = 99900 * 1e18; // 99.9K\n', '\n', '    bool internal _airdrop_status = false;\n', '    uint256 internal _paySize;\n', '\n', '    /** init airdrop program if cap will reach сost price */\n', '    function startAirdrop() public onlyOwner {\n', '        if(address(this).balance < 5 ether && _airdrop_status == true) revert();\n', '        issue(airdropWallet, airdropReward);\n', '        _paySize = 999 * 1e16; // 9.99 tokens\n', '        _airdrop_status = true;\n', '    }\n', '\n', '    /**\n', '        @dev notify owners about their balances was in promo action.\n', '        @param _holders addresses of the owners to be notified ["address_1", "address_2", ..]\n', '     */\n', '    function airdropper(address [] _holders, uint256 _pay_size) public onlyManager {\n', '        if(_pay_size == 0) _pay_size = _paySize; // if empty set default\n', '        if(_pay_size < 1 * 1e18) revert(); // limit no less then 1 token\n', '        uint256 count = _holders.length;\n', '        require(count <= 200);\n', '        assert(_pay_size * count <= balanceOf(msg.sender));\n', '        for (uint256 i = 0; i < count; i++) {\n', '            transfer(_holders [i], _pay_size);\n', '        }\n', '    }\n', '\n', '    function EthereumRisen() public {\n', '\n', '        name = "Ethereum Risen";\n', '        symbol = "ETR";\n', '        decimals = 18;\n', '        totalSupply = 0;\n', '        _creation = now;\n', '        _1sty = now + 365 * 1 days;\n', '        _2ndy = now + 2 * 365 * 1 days;\n', '\n', '        PaymentManager.setPrice(10000);\n', '        Managed.setManager(bountyWallet);\n', '        InvestBox.IntervalBytecodes = intervalBytecodes(\n', '            "0x6461790000",\n', '            "0x7765656b00",\n', '            "0x6d6f6e7468",\n', '            "0x7965617200"\n', '        );\n', '        InvestBox.setMinMaxInvestValue(1000,100000000);\n', '        issue(bountyWallet, bountyReward);\n', '        issue(devWallet, devReward);\n', '    }\n', '\n', '    function() public payable isSuspended {\n', '        require(msg.value >= (1 ether / 100));\n', '        if(msg.value >= 5 ether) superManager(msg.sender); // you can make airdrop from this contract\n', '        rateSystem(msg.sender, msg.value);\n', '        receivedWais = addsm(receivedWais, msg.value); // count ether which was spent to contract\n', '    }\n', '}']