['pragma solidity ^0.4.19;\n', '//\n', '/* CONTRACT */\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '// END_OF_contract_SafeMath\n', '//_________________________________________________________\n', '//\n', '/* INTERFACES */\n', '//\n', 'interface tokenRecipient {\n', '\t\n', '\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \n', '}   \n', '//________________________________________________________\n', '//\n', '    interface ICO {\n', '\n', '        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount, uint retPayment);\n', '        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\n', '        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\n', '        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\n', '\n', '        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\n', '        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\n', '\n', '        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\n', '        function getMinBal() public returns(uint minBalForAccnts_ );\n', '        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\n', '    }\n', '//_________________________________________________________\n', '//\n', '    interface Exchg{\n', '        \n', '        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\n', '        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\n', '        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\n', '        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \n', '\n', '        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \n', '\n', '  \t    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\n', '\n', '    }\n', '//_________________________________________________________\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\n', '/* CONTRACT */\n', '//\n', '    contract TokenERC20Interface {\n', '\n', '        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\n', '        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\n', '        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\n', '        function transfer(address to, uint tokens) public returns (bool success);\n', '        function approve(address spender, uint tokens) public returns (bool success);\n', '        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\n', '        event Transfer(address indexed _from, address indexed to, uint tokens);\n', '        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '//END_OF_contract_ERC20Interface \n', '//_________________________________________________________________\n', '/* CONTRACT */\n', '/**\n', '* COPYRIGHT Macroansy \n', '* http://www.macroansy.org\n', '*/\n', 'contract TokenMacroansyPower is TokenERC20Interface, SafeMath { \n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 3;\n', '    //\n', '    address internal owner; \n', '    address private  beneficiaryFunds;\n', '    //\n', '    uint256 public totalSupply;\n', '    uint256 internal totalSupplyStart;\n', '    //\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping( address => bool) internal frozenAccount;\n', '    //\n', '    mapping(address => uint) private msgSndr;\n', '    //\n', '    address internal tkn_addr; address internal ico_addr; address internal exchg_addr;\n', '    address internal cs_addr;  \n', '    //\n', '    uint256 internal allowedIndividualShare;\n', '    uint256 internal allowedPublicShare;\n', '    //\n', '    bool public crowdSaleOpen;\n', '//_________________________________________________________\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn);\n', '    event FundOrPaymentTransfer(address beneficiary, uint amount); \n', '    // event FrozenFunds(address target, bool frozen);\n', '    //event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\n', '//_________________________________________________________\n', '//\n', '//CONSTRUCTOR\n', '    /* Initializes contract with initial supply tokens to the creator of the contract \n', '    */\n', '    function TokenMacroansyPower()  public {\n', '        \n', '        owner = msg.sender;\n', '        beneficiaryFunds = owner; \n', '        totalSupplyStart = 270000000 * 10** uint256(decimals);     \n', '        totalSupply = totalSupplyStart; \n', '        //\n', '        balanceOf[msg.sender] = totalSupplyStart;    \n', '        Transfer(address(0), msg.sender, totalSupplyStart);\n', '        //                 \n', '        name = "TokenMacroansyPower";  \n', '        symbol = "$BEEPower";\n', '        //  \n', '        allowedIndividualShare = uint(1)*totalSupplyStart/100; \n', '        allowedPublicShare = uint(20)* totalSupplyStart/100;     \n', '        //\n', '        crowdSaleOpen = false;\n', '    } \n', '//_________________________________________________________\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    } \n', '    function transferOr(address _Or) public onlyOwner {\n', '        owner = _Or;\n', '    }          \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `totalSupply` for this Token contract\n', '     */\n', '    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\n', '        return totalSupply ;   \n', '    }  \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `tokenOwner` balances for this contract\n', '     * @param tokenOwner the token owners address\n', '     */\n', '    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\n', '        return balanceOf[tokenOwner];\n', '    } \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the allowance given by `tokenOwner` to the `spender`\n', '     * @param tokenOwner the token owner address allocating allowance\n', '     * @param spender the allowance spenders address\n', '     */\n', '    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\n', '        return allowance[tokenOwner][spender];\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function setContrAddrAndCrwSale(bool setAddress,  address icoAddr, address exchAddr, address csAddr, bool setCrowdSale, bool crowdSaleOpen_ ) public onlyOwner returns(bool success){\n', '\n', '       if(setAddress == true){\n', '       \t\tico_addr = icoAddr; exchg_addr = exchAddr; cs_addr = csAddr;       \t\t\n', '       }\n', '       //\n', '       if( setCrowdSale == true )crowdSaleOpen = crowdSaleOpen_;\n', '       \n', '       return true;   \n', '    }          \n', '    //\n', '    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \n', '    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \n', '    function _getCsAddr() internal returns(address cs_ma_addr){ return(cs_addr); } \n', '//_________________________________________________________\n', '//\n', '    /* Internal transfer, only can be called by this contract */\n', '    //\n', '    function _transfer(address _from, address _to, uint _value) internal  {\n', '        require (_to != 0x0);                                       \n', '        require(!frozenAccount[_from]);                             \n', '        require(!frozenAccount[_to]);                               \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;                       \n', '        require (balanceOf[_from] >= _valueA);                       \n', '        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \n', '        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \n', '        Transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \n', '    }\n', '//________________________________________________________\n', '    /**\n', '     * Transfer tokens\n', '     */\n', '     function transfer(address _to, uint256 _value) public returns(bool success) {\n', '\n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        if(msg.sender != owner){\n', '\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);    \n', '\t        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\n', '\t        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        }\n', '        //\n', '        uint valtmp = _value;    \n', '        uint _valueTemp = valtmp; \n', '        valtmp = 0;                 \n', '        _transfer(msg.sender, _to, _valueTemp);\n', '        _valueTemp = 0;\n', '        return true;      \n', '    }  \n', '//_________________________________________________________\n', '    /**\n', '     * Transfer tokens from other address\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;\n', '        require(_valueA <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\n', '        _transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        \n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        if(msg.sender != owner){\n', '\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);          \n', '\t        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\n', '\t        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        }\n', '        //\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        allowance[msg.sender][_spender] = _valueA;\n', '        Approval(msg.sender, _spender, _valueA);\n', '         _valueA =0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address and notify\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        if (approve(_spender, _valueA)) {           \n', '            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \n', '        }\n', '        _valueA = 0; \n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\n', '        frozenAccount[target] = freeze;      \n', '        //FrozenFunds(target, freeze);\n', '        return true;\n', '    }\n', '//________________________________________________________\n', '//\n', '    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\n', '          \n', '          uint tkA = amount;\n', '          uint tkAtemp = tkA;\n', '          tkA = 0;\n', '                   _transfer(_from, _to, tkAtemp); \n', '          tkAtemp = 0;\n', '          return true;\n', '    }      \n', '//_________________________________________________________\n', '//\n', '    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\n', '              \n', '          uint pA = payment; \n', '          uint paymentTemp = pA;\n', '          pA = 0;\n', '                  paymentBenfcry.transfer(paymentTemp); \n', '          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \n', '          paymentTemp = 0; \n', '          \n', '          return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\n', '              \n', '    // payment req to ico\n', '          uint Pm = payment;\n', '          uint PmTemp = Pm;\n', '          Pm = 0;  \n', '          ICO ico = ICO(_getIcoAddr());       \n', '          // paytype 1 for redeempayment and 2 for sell payment\n', '          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\n', '          require(pymActSucs ==  true);\n', '          PmTemp = 0;\n', '          \n', '          return true;\n', '    }\n', '//_____________________________________________________________\n', '//\n', '\n', '\tfunction buyCoinsCrowdSale(address buyer, uint payment, address crowdSaleContr) public returns(bool success, uint retPayment) { \n', '\t\t\n', '\t\trequire(crowdSaleOpen == true && crowdSaleContr == _getCsAddr());\n', '\n', '\t\tsuccess = false;\n', '\t\t(success , retPayment) = _buyCoins( buyer, payment);\n', '\t\trequire(success == true);\n', '\t\treturn (success, retPayment);\n', '\t}\n', '//_____________________________________________________________\n', '//\n', '    function _buyCoins(address buyer, uint payment) internal returns(bool success, uint retPayment) { \n', '\n', '        msgSndr[buyer] = payment;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        require(  payment > 0 );\n', '        \n', '        bool icosuccess;  uint tknsBuyAppr;  \n', '        (icosuccess, tknsBuyAppr, retPayment ) = ico.buy( payment, buyer, false);         \n', '        require( icosuccess == true );\n', '        \n', '        if(crowdSaleOpen == false) {\n', '        // return payment to buyer \n', '\t        if( retPayment > 0 ) {\n', '\t                \n', '\t          bool sucsTrPaymnt;\n', '\t          sucsTrPaymnt = _safeTransferPaymnt( buyer, retPayment );\n', '\t          require(sucsTrPaymnt == true );\n', '\t        }\n', '        }\n', '        // tkn transfer\n', '        bool sucsTrTk =  _safeTransferTkn( owner, buyer, tknsBuyAppr);\n', '        require(sucsTrTk == true);\n', '\n', '        msgSndr[buyer] = 0;\n', '\n', '        return (true, retPayment);\n', '    }   \n', '//_____________________________________________________________\n', '  \n', '    function redeemOrSellCoinsToICO(uint enter1forRedeemOR2forSell, uint256 amountOfCoinPartsToRedeemOrSell) public returns (bool success ) {\n', '\n', '    require(crowdSaleOpen == false);\n', '\n', '    uint amount = amountOfCoinPartsToRedeemOrSell;\n', '\n', '    msgSndr[msg.sender] = amount;  \n', '      bool isPreview = false;\n', '\n', '      ICO ico = ICO(_getIcoAddr());\n', '\n', '      // redeem exe at ico\n', '        bool icosuccess ; uint redeemOrSellPaymentValue;\n', '      \n', '\t      if(enter1forRedeemOR2forSell == 1){\n', '\n', '\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\n', '\t      }\n', '\t      if(enter1forRedeemOR2forSell == 2){\n', '\n', '\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\n', '\t      }\t      \n', '\n', '      require( icosuccess == true);  \n', '\n', '        require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemOrSellPaymentValue) );\n', '\n', '      bool sucsTrTk = false; bool pymActSucs = false;\n', '      if(isPreview == false) {\n', '\n', '        // transfer tkns\n', '        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\n', '        require(sucsTrTk == true);        \n', '\n', '        // payment req to ico  1 for redeempayment and 2 for sell payment         \n', '      msgSndr[msg.sender] = redeemOrSellPaymentValue;\n', '        pymActSucs = _safePaymentActionAtIco( redeemOrSellPaymentValue, msg.sender, enter1forRedeemOR2forSell);\n', '        require(pymActSucs ==  true);\n', '      } \n', '     \n', '    msgSndr[msg.sender] = 0;  \n', '\n', '      return (true);        \n', '    } \n', '//________________________________________________________\n', '\n', '    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \n', '\n', '      uint amountTkns = amountOfCoinsSellerCanSell; \n', '      success = false;\n', '      ICO ico = ICO( _getIcoAddr() );\n', '      uint seriesCapFactor = ico.getSCF();\n', '      \n', '\t      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\n', '\t        success = true;\n', '\t      }\n', '\n', '      return success;\n', '    }\n', '    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\n', '//_________________________________________________________    \n', '//\n', '    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\n', '\n', '    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\n', '        success = false;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        uint seriesCapFactor = ico.getSCF();\n', '\n', '\t        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\n', '\t          success = true;\n', '\t        } \n', '\n', '        return success;        \n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\n', '       \n', '       success = false;\n', '\n', '      // buyer limits\n', '       bool sucs1 = false; \n', '       sucs1 = _chkBuyerLmts( buyer, amountTkns);\n', '\n', '      // buyer funds\n', '       ICO ico = ICO( _getIcoAddr() );\n', '       bool sucs2 = false;\n', '       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\n', '       if( sucs1 == true && sucs2 == true)  success = true;   \n', '\n', '       return success;\n', '    }\n', '//_________________________________________________________\n', '//\n', '     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\n', '     \n', '      // seller limits check\n', '        bool successSlrl; \n', '        (successSlrl) = _chkSellerLmts( seller, amountTkns); \n', '\n', '      // buyer limits check\n', '        bool successByrlAFinl;\n', '        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\n', '        \n', '        require( successSlrl == true && successByrlAFinl == true);\n', '\n', '        return true;\n', '    }\n', '//___________________________________________________________\n', '\n', '    function () public payable {\n', '       \n', '        if(msg.sender != owner){\n', '\n', '            require(crowdSaleOpen == false);\n', '            bool success = false;\n', '            uint retPayment;\n', '\t\t\t(success , retPayment) = _buyCoins( msg.sender, msg.value);\n', '\t\t\trequire(success == true);    \n', '        }\n', '    }\n', '//_________________________________________________________\n', '\n', '\t\t    function burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \n', '\n', '\t\t    \trequire(crowdSaleOpen == false);\n', '\n', '\t\t        msgSndr[msg.sender] = value;\n', '\t\t         ICO ico = ICO( _getIcoAddr() );\n', '\t\t            if( unburn == false) {\n', '\n', '\t\t                balanceOf[owner] = safeSub( balanceOf[owner] , value);\n', '\t\t                totalSupply = safeSub( totalSupply, value);\n', '\t\t                BurnOrUnBurn(owner, value, 1);\n', '\n', '\t\t            }\n', '\t\t            if( unburn == true) {\n', '\n', '\t\t                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\n', '\t\t                totalSupply = safeAdd( totalSupply , value);\n', '\t\t                BurnOrUnBurn(owner, value, 2);\n', '\n', '\t\t            }\n', '\t\t        \n', '\t\t        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\n', '\t\t        require( icosuccess == true);             \n', '\t\t        \n', '\t\t        return true;   \n', '\t                    \n', '           }\n', '//_________________________________________________________\n', '\n', '    function withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\n', '      \n', '        success = _withdraw(withdrawAmount);          \n', '        return success;      \n', '    }   \n', '//_________________________________________________________\n', '\n', '    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\n', '\n', '        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \n', '        require(sucsTrPaymnt == true);         \n', '        return true;     \n', '    }\n', '//_________________________________________________________\n', '\n', '    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \n', '\n', '      require(crowdSaleOpen == false);\n', '\n', '      msgSndr[msg.sender] = amountOfCoinsToReceive;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        bool  icosuccess;  \n', '        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \n', '        require (icosuccess == true);\n', '\n', '        bool sucsTrTk;\n', '        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\n', '        require(sucsTrTk == true);\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return  true;\n', '    }\n', '//___________________________________________________________________\n', '\n', '      function sellBkgAtExchg( uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) public returns(bool success){\n', '        \n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amntTkns = sellerCoinPartsForSale;\n', '        uint tknPrice = sellerPricePerCoinPartInWEI;\n', '      \n', '        // seller limits\n', '        bool successSlrl;\n', '        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \n', '        require(successSlrl == true);\n', '\n', '      msgSndr[msg.sender] = amntTkns;  \n', '\n', '      // bkg registration at exchange\n', '\n', '        Exchg em = Exchg(_getExchgAddr());\n', '\n', '        bool  emsuccess; \n', '        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\n', '        require(emsuccess == true );\n', '            \n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return true;         \n', '    }\n', '//_________________________________________________________ \n', '//     \n', '      function buyBkgAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \n', '\n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amountTkns = sellerCoinPartsForSale;\n', '        uint priceOfr = sellerPricePerCoinPartInWEI;\n', '        uint payment = myProposedPaymentInWEI;   \n', '\n', '\t\t// calc tokens that can be bought         \n', '        uint tknsBuyAppr = 0;    \n', '        if( amountTkns > 2 &&  payment >=  (2 * priceOfr) &&  payment <= (amountTkns * priceOfr) ) {\n', '\n', '        \ttknsBuyAppr = safeDiv( payment , priceOfr );\n', '        }\n', '        require(tknsBuyAppr > 0);\n', '\n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // seller buyer limits check\n', '        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\n', '        require(sucsLmt == true);\n', '\n', '        // booking at exchange\n', '     \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool emBkgsuccess;\n', '        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\n', '            require( emBkgsuccess == true );\n', '\n', '      msgSndr[msg.sender] = 0;  \n', '\n', '        return true;        \n', '    }\n', '//________________________________________________________\n', '\n', '    function buyCoinsAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) payable public returns(bool success) {\n', '        \n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amountTkns = sellerCoinPartsForSale;\n', '        uint priceOfr = sellerPricePerCoinPartInWEI;\t  \n', '\t\t\n', '\t\t// calc tokens that can be bought         \n', '        uint tknsBuyAppr = 0;  // this var as used as the indicator to update buyerbkg and seller update for ok or no txn.\n', '\n', '        if( amountTkns > 2 &&  msg.value >=  (2 * priceOfr) &&  msg.value <= (amountTkns * priceOfr) ) {\n', '\n', '        \ttknsBuyAppr = safeDiv( msg.value , priceOfr );\n', '        }\n', '        // calc return payment to buyer\n', '        uint retPayment = 0;\n', '        if(  msg.value > 0 ){\n', '            retPayment = safeSub( msg.value , tknsBuyAppr * priceOfr);\n', '        }\n', '\n', '      msgSndr[msg.sender] = amountTkns;               \n', '        \n', '        // check buyer booking at exchange\n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool sucsBkgChk = false;\n', '        if(tknsBuyAppr > 0){\n', '\t        sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \n', '        }\n', '        if(sucsBkgChk == false) tknsBuyAppr = 0;\n', '        //\n', '\n', '\t\t\tmsgSndr[msg.sender] = tknsBuyAppr;  \n', ' \n', '        \tbool emUpdateSuccess;\n', '       \t\t(emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \n', '        \trequire( emUpdateSuccess == true );\n', '        \n', '        //\n', '        if(sucsBkgChk == true && tknsBuyAppr > 0){\n', '      \n', '\t       // token transfer in this token contract\n', '\n', '\t        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\n', '\t        require(sucsTrTkn == true);\n', '\n', '\t        // payment to seller        \n', '\t        bool sucsTrPaymnt;\n', '\t        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\n', '\t        require(sucsTrPaymnt == true );        \n', '        }\n', '    \t// return payment to buyer \n', '        if( retPayment > 0 ) {\n', '                \n', '          bool sucsTrRetPaymnt;\n', '          sucsTrRetPaymnt = _safeTransferPaymnt( msg.sender, retPayment );\n', '          require(sucsTrRetPaymnt == true );\n', '        }         \n', '      msgSndr[msg.sender] = 0; \n', '        \n', '        return true;\n', '    } \n', '//_______________________________________________________\n', '//  called by other contracts\n', '    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\n', '        \n', '        (success, value) = _sendMsgSndr(caller, origin);        \n', '         return(success, value);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \n', '       \n', '        require( caller == _getIcoAddr() || caller == _getExchgAddr() || caller == _getCsAddr() ); \n', '          //require(origin == tx.origin);          \n', '        return(true, msgSndr[origin]);  \n', '    }\n', '//_________________________________________________________\n', '//\n', '    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime){\n', '\n', '      if(show == true){\n', '\n', '        Exchg em = Exchg(_getExchgAddr()); \n', '       \n', '        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, ) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \n', '\n', '        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime);\n', '      }\n', '    }\n', '//_________________________________________________________\n', '//\n', '\t\tfunction viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\n', '\n', '\t\t    if(show == true){\n', '\t\t      ICO ico = ICO( _getIcoAddr() );\n', '\n', '\t\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\n', '\n', '\t\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\n', '\t\t    }\n', '\t\t}\n', '//_________________________________________________________\n', '//\n', '/*    \t\t\t\n', '\t\t\tbool private isEndOk;\n', '\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\n', '\n', '\t\t\t\t\t\tisEndOk == isEndNow;\n', '\t\t\t\t}\n', '\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\n', '\n', '\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\n', '\t\t\t\t}\n', '*/\t\t\t\n', '//_______________________________________________________\n', '}\n', '// END_OF_CONTRACT']
['pragma solidity ^0.4.19;\n', '//\n', '/* CONTRACT */\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '// END_OF_contract_SafeMath\n', '//_________________________________________________________\n', '//\n', '/* INTERFACES */\n', '//\n', 'interface tokenRecipient {\n', '\t\n', '\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \n', '}   \n', '//________________________________________________________\n', '//\n', '    interface ICO {\n', '\n', '        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount, uint retPayment);\n', '        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\n', '        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\n', '        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\n', '\n', '        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\n', '        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\n', '\n', '        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\n', '        function getMinBal() public returns(uint minBalForAccnts_ );\n', '        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\n', '    }\n', '//_________________________________________________________\n', '//\n', '    interface Exchg{\n', '        \n', '        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\n', '        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\n', '        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\n', '        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \n', '\n', '        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \n', '\n', '  \t    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\n', '\n', '    }\n', '//_________________________________________________________\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\n', '/* CONTRACT */\n', '//\n', '    contract TokenERC20Interface {\n', '\n', '        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\n', '        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\n', '        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\n', '        function transfer(address to, uint tokens) public returns (bool success);\n', '        function approve(address spender, uint tokens) public returns (bool success);\n', '        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\n', '        event Transfer(address indexed _from, address indexed to, uint tokens);\n', '        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    }\n', '//END_OF_contract_ERC20Interface \n', '//_________________________________________________________________\n', '/* CONTRACT */\n', '/**\n', '* COPYRIGHT Macroansy \n', '* http://www.macroansy.org\n', '*/\n', 'contract TokenMacroansyPower is TokenERC20Interface, SafeMath { \n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 3;\n', '    //\n', '    address internal owner; \n', '    address private  beneficiaryFunds;\n', '    //\n', '    uint256 public totalSupply;\n', '    uint256 internal totalSupplyStart;\n', '    //\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping( address => bool) internal frozenAccount;\n', '    //\n', '    mapping(address => uint) private msgSndr;\n', '    //\n', '    address internal tkn_addr; address internal ico_addr; address internal exchg_addr;\n', '    address internal cs_addr;  \n', '    //\n', '    uint256 internal allowedIndividualShare;\n', '    uint256 internal allowedPublicShare;\n', '    //\n', '    bool public crowdSaleOpen;\n', '//_________________________________________________________\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn);\n', '    event FundOrPaymentTransfer(address beneficiary, uint amount); \n', '    // event FrozenFunds(address target, bool frozen);\n', '    //event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\n', '//_________________________________________________________\n', '//\n', '//CONSTRUCTOR\n', '    /* Initializes contract with initial supply tokens to the creator of the contract \n', '    */\n', '    function TokenMacroansyPower()  public {\n', '        \n', '        owner = msg.sender;\n', '        beneficiaryFunds = owner; \n', '        totalSupplyStart = 270000000 * 10** uint256(decimals);     \n', '        totalSupply = totalSupplyStart; \n', '        //\n', '        balanceOf[msg.sender] = totalSupplyStart;    \n', '        Transfer(address(0), msg.sender, totalSupplyStart);\n', '        //                 \n', '        name = "TokenMacroansyPower";  \n', '        symbol = "$BEEPower";\n', '        //  \n', '        allowedIndividualShare = uint(1)*totalSupplyStart/100; \n', '        allowedPublicShare = uint(20)* totalSupplyStart/100;     \n', '        //\n', '        crowdSaleOpen = false;\n', '    } \n', '//_________________________________________________________\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    } \n', '    function transferOr(address _Or) public onlyOwner {\n', '        owner = _Or;\n', '    }          \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `totalSupply` for this Token contract\n', '     */\n', '    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\n', '        return totalSupply ;   \n', '    }  \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the `tokenOwner` balances for this contract\n', '     * @param tokenOwner the token owners address\n', '     */\n', '    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\n', '        return balanceOf[tokenOwner];\n', '    } \n', '//_________________________________________________________\n', '   /**\n', '     * @notice Show the allowance given by `tokenOwner` to the `spender`\n', '     * @param tokenOwner the token owner address allocating allowance\n', '     * @param spender the allowance spenders address\n', '     */\n', '    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\n', '        return allowance[tokenOwner][spender];\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function setContrAddrAndCrwSale(bool setAddress,  address icoAddr, address exchAddr, address csAddr, bool setCrowdSale, bool crowdSaleOpen_ ) public onlyOwner returns(bool success){\n', '\n', '       if(setAddress == true){\n', '       \t\tico_addr = icoAddr; exchg_addr = exchAddr; cs_addr = csAddr;       \t\t\n', '       }\n', '       //\n', '       if( setCrowdSale == true )crowdSaleOpen = crowdSaleOpen_;\n', '       \n', '       return true;   \n', '    }          \n', '    //\n', '    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \n', '    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \n', '    function _getCsAddr() internal returns(address cs_ma_addr){ return(cs_addr); } \n', '//_________________________________________________________\n', '//\n', '    /* Internal transfer, only can be called by this contract */\n', '    //\n', '    function _transfer(address _from, address _to, uint _value) internal  {\n', '        require (_to != 0x0);                                       \n', '        require(!frozenAccount[_from]);                             \n', '        require(!frozenAccount[_to]);                               \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;                       \n', '        require (balanceOf[_from] >= _valueA);                       \n', '        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \n', '        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \n', '        Transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \n', '    }\n', '//________________________________________________________\n', '    /**\n', '     * Transfer tokens\n', '     */\n', '     function transfer(address _to, uint256 _value) public returns(bool success) {\n', '\n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        if(msg.sender != owner){\n', '\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);    \n', '\t        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\n', '\t        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        }\n', '        //\n', '        uint valtmp = _value;    \n', '        uint _valueTemp = valtmp; \n', '        valtmp = 0;                 \n', '        _transfer(msg.sender, _to, _valueTemp);\n', '        _valueTemp = 0;\n', '        return true;      \n', '    }  \n', '//_________________________________________________________\n', '    /**\n', '     * Transfer tokens from other address\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;\n', '        require(_valueA <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\n', '        _transfer(_from, _to, _valueA);\n', '        _valueA = 0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        \n', '        //check sender and receiver allw limits in accordance with ico contract\n', '        if(msg.sender != owner){\n', '\t        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);          \n', '\t        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\n', '\t        require(sucsSlrLmt == true && sucsByrLmt == true);\n', '        }\n', '        //\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        allowance[msg.sender][_spender] = _valueA;\n', '        Approval(msg.sender, _spender, _valueA);\n', '         _valueA =0;\n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '    /**\n', '     * Set allowance for other address and notify\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        uint valtmp = _value;\n', '        uint _valueA = valtmp;\n', '        valtmp = 0;         \n', '        if (approve(_spender, _valueA)) {           \n', '            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \n', '        }\n', '        _valueA = 0; \n', '        return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\n', '        frozenAccount[target] = freeze;      \n', '        //FrozenFunds(target, freeze);\n', '        return true;\n', '    }\n', '//________________________________________________________\n', '//\n', '    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\n', '          \n', '          uint tkA = amount;\n', '          uint tkAtemp = tkA;\n', '          tkA = 0;\n', '                   _transfer(_from, _to, tkAtemp); \n', '          tkAtemp = 0;\n', '          return true;\n', '    }      \n', '//_________________________________________________________\n', '//\n', '    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\n', '              \n', '          uint pA = payment; \n', '          uint paymentTemp = pA;\n', '          pA = 0;\n', '                  paymentBenfcry.transfer(paymentTemp); \n', '          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \n', '          paymentTemp = 0; \n', '          \n', '          return true;\n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\n', '              \n', '    // payment req to ico\n', '          uint Pm = payment;\n', '          uint PmTemp = Pm;\n', '          Pm = 0;  \n', '          ICO ico = ICO(_getIcoAddr());       \n', '          // paytype 1 for redeempayment and 2 for sell payment\n', '          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\n', '          require(pymActSucs ==  true);\n', '          PmTemp = 0;\n', '          \n', '          return true;\n', '    }\n', '//_____________________________________________________________\n', '//\n', '\n', '\tfunction buyCoinsCrowdSale(address buyer, uint payment, address crowdSaleContr) public returns(bool success, uint retPayment) { \n', '\t\t\n', '\t\trequire(crowdSaleOpen == true && crowdSaleContr == _getCsAddr());\n', '\n', '\t\tsuccess = false;\n', '\t\t(success , retPayment) = _buyCoins( buyer, payment);\n', '\t\trequire(success == true);\n', '\t\treturn (success, retPayment);\n', '\t}\n', '//_____________________________________________________________\n', '//\n', '    function _buyCoins(address buyer, uint payment) internal returns(bool success, uint retPayment) { \n', '\n', '        msgSndr[buyer] = payment;\n', '\n', '        ICO ico = ICO(_getIcoAddr() );\n', '\n', '        require(  payment > 0 );\n', '        \n', '        bool icosuccess;  uint tknsBuyAppr;  \n', '        (icosuccess, tknsBuyAppr, retPayment ) = ico.buy( payment, buyer, false);         \n', '        require( icosuccess == true );\n', '        \n', '        if(crowdSaleOpen == false) {\n', '        // return payment to buyer \n', '\t        if( retPayment > 0 ) {\n', '\t                \n', '\t          bool sucsTrPaymnt;\n', '\t          sucsTrPaymnt = _safeTransferPaymnt( buyer, retPayment );\n', '\t          require(sucsTrPaymnt == true );\n', '\t        }\n', '        }\n', '        // tkn transfer\n', '        bool sucsTrTk =  _safeTransferTkn( owner, buyer, tknsBuyAppr);\n', '        require(sucsTrTk == true);\n', '\n', '        msgSndr[buyer] = 0;\n', '\n', '        return (true, retPayment);\n', '    }   \n', '//_____________________________________________________________\n', '  \n', '    function redeemOrSellCoinsToICO(uint enter1forRedeemOR2forSell, uint256 amountOfCoinPartsToRedeemOrSell) public returns (bool success ) {\n', '\n', '    require(crowdSaleOpen == false);\n', '\n', '    uint amount = amountOfCoinPartsToRedeemOrSell;\n', '\n', '    msgSndr[msg.sender] = amount;  \n', '      bool isPreview = false;\n', '\n', '      ICO ico = ICO(_getIcoAddr());\n', '\n', '      // redeem exe at ico\n', '        bool icosuccess ; uint redeemOrSellPaymentValue;\n', '      \n', '\t      if(enter1forRedeemOR2forSell == 1){\n', '\n', '\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\n', '\t      }\n', '\t      if(enter1forRedeemOR2forSell == 2){\n', '\n', '\t      \t(icosuccess , redeemOrSellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\n', '\t      }\t      \n', '\n', '      require( icosuccess == true);  \n', '\n', '        require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemOrSellPaymentValue) );\n', '\n', '      bool sucsTrTk = false; bool pymActSucs = false;\n', '      if(isPreview == false) {\n', '\n', '        // transfer tkns\n', '        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\n', '        require(sucsTrTk == true);        \n', '\n', '        // payment req to ico  1 for redeempayment and 2 for sell payment         \n', '      msgSndr[msg.sender] = redeemOrSellPaymentValue;\n', '        pymActSucs = _safePaymentActionAtIco( redeemOrSellPaymentValue, msg.sender, enter1forRedeemOR2forSell);\n', '        require(pymActSucs ==  true);\n', '      } \n', '     \n', '    msgSndr[msg.sender] = 0;  \n', '\n', '      return (true);        \n', '    } \n', '//________________________________________________________\n', '\n', '    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \n', '\n', '      uint amountTkns = amountOfCoinsSellerCanSell; \n', '      success = false;\n', '      ICO ico = ICO( _getIcoAddr() );\n', '      uint seriesCapFactor = ico.getSCF();\n', '      \n', '\t      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\n', '\t        success = true;\n', '\t      }\n', '\n', '      return success;\n', '    }\n', '    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\n', '//_________________________________________________________    \n', '//\n', '    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\n', '\n', '    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\n', '        success = false;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        uint seriesCapFactor = ico.getSCF();\n', '\n', '\t        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\n', '\t          success = true;\n', '\t        } \n', '\n', '        return success;        \n', '    }\n', '//_________________________________________________________\n', '//\n', '    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\n', '       \n', '       success = false;\n', '\n', '      // buyer limits\n', '       bool sucs1 = false; \n', '       sucs1 = _chkBuyerLmts( buyer, amountTkns);\n', '\n', '      // buyer funds\n', '       ICO ico = ICO( _getIcoAddr() );\n', '       bool sucs2 = false;\n', '       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\n', '       if( sucs1 == true && sucs2 == true)  success = true;   \n', '\n', '       return success;\n', '    }\n', '//_________________________________________________________\n', '//\n', '     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\n', '     \n', '      // seller limits check\n', '        bool successSlrl; \n', '        (successSlrl) = _chkSellerLmts( seller, amountTkns); \n', '\n', '      // buyer limits check\n', '        bool successByrlAFinl;\n', '        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\n', '        \n', '        require( successSlrl == true && successByrlAFinl == true);\n', '\n', '        return true;\n', '    }\n', '//___________________________________________________________\n', '\n', '    function () public payable {\n', '       \n', '        if(msg.sender != owner){\n', '\n', '            require(crowdSaleOpen == false);\n', '            bool success = false;\n', '            uint retPayment;\n', '\t\t\t(success , retPayment) = _buyCoins( msg.sender, msg.value);\n', '\t\t\trequire(success == true);    \n', '        }\n', '    }\n', '//_________________________________________________________\n', '\n', '\t\t    function burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \n', '\n', '\t\t    \trequire(crowdSaleOpen == false);\n', '\n', '\t\t        msgSndr[msg.sender] = value;\n', '\t\t         ICO ico = ICO( _getIcoAddr() );\n', '\t\t            if( unburn == false) {\n', '\n', '\t\t                balanceOf[owner] = safeSub( balanceOf[owner] , value);\n', '\t\t                totalSupply = safeSub( totalSupply, value);\n', '\t\t                BurnOrUnBurn(owner, value, 1);\n', '\n', '\t\t            }\n', '\t\t            if( unburn == true) {\n', '\n', '\t\t                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\n', '\t\t                totalSupply = safeAdd( totalSupply , value);\n', '\t\t                BurnOrUnBurn(owner, value, 2);\n', '\n', '\t\t            }\n', '\t\t        \n', '\t\t        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\n', '\t\t        require( icosuccess == true);             \n', '\t\t        \n', '\t\t        return true;   \n', '\t                    \n', '           }\n', '//_________________________________________________________\n', '\n', '    function withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\n', '      \n', '        success = _withdraw(withdrawAmount);          \n', '        return success;      \n', '    }   \n', '//_________________________________________________________\n', '\n', '    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\n', '\n', '        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \n', '        require(sucsTrPaymnt == true);         \n', '        return true;     \n', '    }\n', '//_________________________________________________________\n', '\n', '    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \n', '\n', '      require(crowdSaleOpen == false);\n', '\n', '      msgSndr[msg.sender] = amountOfCoinsToReceive;\n', '        ICO ico = ICO( _getIcoAddr() );\n', '        bool  icosuccess;  \n', '        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \n', '        require (icosuccess == true);\n', '\n', '        bool sucsTrTk;\n', '        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\n', '        require(sucsTrTk == true);\n', '\n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return  true;\n', '    }\n', '//___________________________________________________________________\n', '\n', '      function sellBkgAtExchg( uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) public returns(bool success){\n', '        \n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amntTkns = sellerCoinPartsForSale;\n', '        uint tknPrice = sellerPricePerCoinPartInWEI;\n', '      \n', '        // seller limits\n', '        bool successSlrl;\n', '        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \n', '        require(successSlrl == true);\n', '\n', '      msgSndr[msg.sender] = amntTkns;  \n', '\n', '      // bkg registration at exchange\n', '\n', '        Exchg em = Exchg(_getExchgAddr());\n', '\n', '        bool  emsuccess; \n', '        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\n', '        require(emsuccess == true );\n', '            \n', '      msgSndr[msg.sender] = 0;\n', '\n', '        return true;         \n', '    }\n', '//_________________________________________________________ \n', '//     \n', '      function buyBkgAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \n', '\n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amountTkns = sellerCoinPartsForSale;\n', '        uint priceOfr = sellerPricePerCoinPartInWEI;\n', '        uint payment = myProposedPaymentInWEI;   \n', '\n', '\t\t// calc tokens that can be bought         \n', '        uint tknsBuyAppr = 0;    \n', '        if( amountTkns > 2 &&  payment >=  (2 * priceOfr) &&  payment <= (amountTkns * priceOfr) ) {\n', '\n', '        \ttknsBuyAppr = safeDiv( payment , priceOfr );\n', '        }\n', '        require(tknsBuyAppr > 0);\n', '\n', '      msgSndr[msg.sender] = amountTkns;\n', '\n', '        // seller buyer limits check\n', '        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\n', '        require(sucsLmt == true);\n', '\n', '        // booking at exchange\n', '     \n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool emBkgsuccess;\n', '        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\n', '            require( emBkgsuccess == true );\n', '\n', '      msgSndr[msg.sender] = 0;  \n', '\n', '        return true;        \n', '    }\n', '//________________________________________________________\n', '\n', '    function buyCoinsAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) payable public returns(bool success) {\n', '        \n', '        require(crowdSaleOpen == false);\n', '\n', '        uint amountTkns = sellerCoinPartsForSale;\n', '        uint priceOfr = sellerPricePerCoinPartInWEI;\t  \n', '\t\t\n', '\t\t// calc tokens that can be bought         \n', '        uint tknsBuyAppr = 0;  // this var as used as the indicator to update buyerbkg and seller update for ok or no txn.\n', '\n', '        if( amountTkns > 2 &&  msg.value >=  (2 * priceOfr) &&  msg.value <= (amountTkns * priceOfr) ) {\n', '\n', '        \ttknsBuyAppr = safeDiv( msg.value , priceOfr );\n', '        }\n', '        // calc return payment to buyer\n', '        uint retPayment = 0;\n', '        if(  msg.value > 0 ){\n', '            retPayment = safeSub( msg.value , tknsBuyAppr * priceOfr);\n', '        }\n', '\n', '      msgSndr[msg.sender] = amountTkns;               \n', '        \n', '        // check buyer booking at exchange\n', '        Exchg em = Exchg(_getExchgAddr()); \n', '\n', '        bool sucsBkgChk = false;\n', '        if(tknsBuyAppr > 0){\n', '\t        sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \n', '        }\n', '        if(sucsBkgChk == false) tknsBuyAppr = 0;\n', '        //\n', '\n', '\t\t\tmsgSndr[msg.sender] = tknsBuyAppr;  \n', ' \n', '        \tbool emUpdateSuccess;\n', '       \t\t(emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \n', '        \trequire( emUpdateSuccess == true );\n', '        \n', '        //\n', '        if(sucsBkgChk == true && tknsBuyAppr > 0){\n', '      \n', '\t       // token transfer in this token contract\n', '\n', '\t        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\n', '\t        require(sucsTrTkn == true);\n', '\n', '\t        // payment to seller        \n', '\t        bool sucsTrPaymnt;\n', '\t        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\n', '\t        require(sucsTrPaymnt == true );        \n', '        }\n', '    \t// return payment to buyer \n', '        if( retPayment > 0 ) {\n', '                \n', '          bool sucsTrRetPaymnt;\n', '          sucsTrRetPaymnt = _safeTransferPaymnt( msg.sender, retPayment );\n', '          require(sucsTrRetPaymnt == true );\n', '        }         \n', '      msgSndr[msg.sender] = 0; \n', '        \n', '        return true;\n', '    } \n', '//_______________________________________________________\n', '//  called by other contracts\n', '    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\n', '        \n', '        (success, value) = _sendMsgSndr(caller, origin);        \n', '         return(success, value);  \n', '    }\n', '//_______________________________________________________\n', '//\n', '    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \n', '       \n', '        require( caller == _getIcoAddr() || caller == _getExchgAddr() || caller == _getCsAddr() ); \n', '          //require(origin == tx.origin);          \n', '        return(true, msgSndr[origin]);  \n', '    }\n', '//_________________________________________________________\n', '//\n', '    function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime){\n', '\n', '      if(show == true){\n', '\n', '        Exchg em = Exchg(_getExchgAddr()); \n', '       \n', '        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, ) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \n', '\n', '        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime);\n', '      }\n', '    }\n', '//_________________________________________________________\n', '//\n', '\t\tfunction viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\n', '\n', '\t\t    if(show == true){\n', '\t\t      ICO ico = ICO( _getIcoAddr() );\n', '\n', '\t\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\n', '\n', '\t\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\n', '\t\t    }\n', '\t\t}\n', '//_________________________________________________________\n', '//\n', '/*    \t\t\t\n', '\t\t\tbool private isEndOk;\n', '\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\n', '\n', '\t\t\t\t\t\tisEndOk == isEndNow;\n', '\t\t\t\t}\n', '\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\n', '\n', '\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\n', '\t\t\t\t}\n', '*/\t\t\t\n', '//_______________________________________________________\n', '}\n', '// END_OF_CONTRACT']
