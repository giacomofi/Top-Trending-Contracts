['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Platform\n', '{\n', '    address public platform = 0x709a0A8deB88A2d19DAB2492F669ef26Fd176f6C;\n', '\n', '    modifier onlyPlatform() {\n', '        require(msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    function isPlatform() public view returns (bool) {\n', '        return platform == msg.sender;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract BeneficiaryInterface\n', '{\n', '    function getAvailableWithdrawInvestmentsForBeneficiary() public view returns (uint);\n', '    function withdrawInvestmentsBeneficiary(address withdraw_address) public returns (bool);\n', '}\n', '\n', '\n', '//Интерфейс для ICO контрактов, чтобы те могли говорить CNRToken-у\n', '//о том что ему перевели бабки\n', 'contract CNRAddBalanceInterface\n', '{\n', '    function addTokenBalance(address, uint) public;\n', '}\n', '\n', '\n', '//Интерфейс для фабрики, чтобы она могла добавлять токены\n', 'contract CNRAddTokenInterface\n', '{\n', '    function addTokenAddress(address) public;\n', '}\n', '\n', '//TODO: может сделать класс TokensCollection, куда вынести всю функциональность из  tokens_map, tokens_arr итд\n', 'contract CNRToken is ERC20, CNRAddBalanceInterface, CNRAddTokenInterface, Platform\n', '{\n', '    using SafeMath for uint256;\n', '\n', '\n', '    //Токен  ERC20\n', '    string public constant name = "ICO Constructor token";\n', '    string public constant symbol = "CNR";\n', '    uint256 public constant decimals = 18;\n', '\n', '\n', '    //-------------------------ERC20 interface----------------------------------\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '    mapping(address => uint256) balances;\n', '    ////////////////////////////ERC20 interface/////////////////////////////////\n', '\n', '    //Адрес гранд фабрики\n', '    address public grand_factory = address(0);\n', '\n', '    //Мапа и массив добавленнх токенов. Нулевой элемент  зарезервирован для\n', '    //эфира. Остальные для токенов\n', '    mapping(address => uint256) public  tokens_map;\n', '    TokenInfo[] public                  tokens_arr;\n', '\n', '    //Мапа с забранными сущностями (эфиром, токенами). (адрес кошелька клиента => (индекс токена => сколько уже забрал))\n', '    //По индексу 0 - всегда эфир.\n', '    mapping(address => mapping(uint => uint)) withdrawns;\n', '\n', '    function CNRToken() public\n', '    {\n', '        totalSupply = 10*1000*1000*(10**decimals); // 10 mln\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        //На нулевом индексе находится эфир\n', '        tokens_arr.push(\n', '            TokenInfo(\n', '                address(0),\n', '                0));\n', '    }\n', '\n', '\n', '    //Функция получения адресов всех добавленных токенов\n', '    function getRegisteredTokens()\n', '    public view\n', '    returns (address[])\n', '    {\n', '        // ситуация, когда не добавлены токены. <= чтобы убрать пред mythril,\n', '        // который не понимает что в конструкторе забит первый элемент\n', '        if (tokens_arr.length <= 1)\n', '            return;\n', '\n', '        address[] memory token_addresses = new address[](tokens_arr.length-1);\n', '        for (uint i = 1; i < tokens_arr.length; i++)\n', '        {\n', '            token_addresses[i-1] = tokens_arr[i].contract_address;\n', '        }\n', '\n', '        return token_addresses;\n', '    }\n', '\n', '    //Функиця получения данных о всех доступных доходах в ether со всех\n', '    //зарегистрированных контрактов токенов. Чтобы воспользоваться этими\n', '    //доходами нужно для кажжого токена вызвать takeICOInvestmentsEtherCommission\n', '    function getAvailableEtherCommissions()\n', '    public view\n', '    returns(\n', '        address[],\n', '        uint[]\n', '    )\n', '    {\n', '        // ситуация, когда не добавлены токены. <= чтобы убрать пред mythril,\n', '        // который не понимает что в конструкторе забит первый элемент\n', '        if (tokens_arr.length <= 1)\n', '            return;\n', '\n', '        address[] memory token_addresses = new address[](tokens_arr.length-1);\n', '        uint[] memory available_withdraws = new uint[](tokens_arr.length-1);\n', '        //Здесь должно быть от 1-го, потому что на 0-ом - эфир\n', '        for (uint i = 1; i < tokens_arr.length; i++)\n', '        {\n', '            token_addresses[i-1] = tokens_arr[i].contract_address;\n', '            available_withdraws[i-1] =\n', '                BeneficiaryInterface(tokens_arr[i].contract_address).getAvailableWithdrawInvestmentsForBeneficiary();\n', '        }\n', '\n', '        return (token_addresses, available_withdraws);\n', '    }\n', '\n', '\n', '    //Функция, которую может дергнуть кто угодно, чтобы на данный  контракт были переведен\n', '    //комиссии с инвестиций в эфире\n', '    function takeICOInvestmentsEtherCommission(address ico_token_address)\n', '    public\n', '    {\n', '        //Проверяем что ранее был! добавлен такой токен\n', '        require(tokens_map[ico_token_address] != 0);\n', '\n', '        //Узнаем сколько мы можем вывести бабла\n', '        uint available_investments_commission =\n', '            BeneficiaryInterface(ico_token_address).getAvailableWithdrawInvestmentsForBeneficiary();\n', '\n', '        //Запоминаем что бабки забрали\n', '        //запоминаем до перевода, так как потом дергаем external contract method\n', '        tokens_arr[0].ever_added = tokens_arr[0].ever_added.add(available_investments_commission);\n', '\n', '        //Переводим бабло на адрес этого контракта\n', '        BeneficiaryInterface(ico_token_address).withdrawInvestmentsBeneficiary(\n', '            address(this));\n', '    }\n', '\n', '\n', '    //Специально разрешаем получение бабла\n', '    function()\n', '    public payable\n', '    {\n', '\n', '    }\n', '\n', '\n', '    //Метод установки адреса grandFactory, который будет использован\n', '    function setGrandFactory(address _grand_factory)\n', '    public\n', '        onlyPlatform\n', '    {\n', '        //Проверяем чтобы адрес был передан нормальный\n', '        require(_grand_factory != address(0));\n', '\n', '        grand_factory = _grand_factory;\n', '    }\n', '\n', '    // баланс рассчитывается по формуле:\n', '    // общее количество токенов контракта _token_address, которым владеет контракт CNR\n', '    // умножаем на количество токенов CNR у _owner, делим на totalSupply (получаем долю)\n', '    // и отнимаем уже выведенную _owner&#39;ом сумму токенов\n', '    //Доступный к выводу баланс в токенах некоторого ICO\n', '    function balanceOfToken(address _owner, address _token_address)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        //Проверка наличия такого токена\n', '        require(tokens_map[_token_address] != 0);\n', '\n', '        uint idx = tokens_map[_token_address];\n', '        balance =\n', '            tokens_arr[idx].ever_added\n', '            .mul(balances[_owner])\n', '            .div(totalSupply)\n', '            .sub(withdrawns[_owner][idx]);\n', '        }\n', '\n', '    // все как и в balanceOfToken, только используем 0 элемент в tokens_arr и withdrawns[_owner]\n', '    //Доступный к выводу баланс в эфирах\n', '    function balanceOfETH(address _owner)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        balance =\n', '            tokens_arr[0].ever_added\n', '            .mul(balances[_owner])\n', '            .div(totalSupply)\n', '            .sub(withdrawns[_owner][0]);\n', '    }\n', '\n', '    //Функция перевода доступных токенов некоторого ICO на указанный кошелек\n', '    function withdrawTokens(address _token_address, address _destination_address)\n', '    public\n', '    {\n', '        //Проверка наличия такого токена\n', '        require(tokens_map[_token_address] != 0);\n', '\n', '        uint token_balance = balanceOfToken(msg.sender, _token_address);\n', '        uint token_idx = tokens_map[_token_address];\n', '        withdrawns[msg.sender][token_idx] = withdrawns[msg.sender][token_idx].add(token_balance);\n', '        ERC20Basic(_token_address).transfer(_destination_address, token_balance);\n', '    }\n', '\n', '    //Функиця забирания доступного эфира на указанный кошелек\n', '    function withdrawETH(address _destination_address)\n', '    public\n', '    {\n', '        uint value_in_wei = balanceOfETH(msg.sender);\n', '        withdrawns[msg.sender][0] = withdrawns[msg.sender][0].add(value_in_wei);\n', '        _destination_address.transfer(value_in_wei);\n', '    }\n', '\n', '\n', '    //Данная функция дложна вызываться из контрактов-токенов, в тот момент когда бенефициару\n', '    //(на контракт бенефициара) переводятся токены\n', '    function addTokenBalance(address _token_contract, uint amount)\n', '    public\n', '    {\n', '        //Проверяем что функция вызывается из ранее добавленноно! контракта токена\n', '        require(tokens_map[msg.sender] != 0);\n', '\n', '        //ДОбавление данных обо всех токенах, переведенных бенефициару\n', '        tokens_arr[tokens_map[_token_contract]].ever_added = tokens_arr[tokens_map[_token_contract]].ever_added.add(amount);\n', '    }\n', '\n', '    //Функиця добавления нового токена. Данная функция должна вызываться\n', '    //только GrandFactory при создании нового ICO токена\n', '    function addTokenAddress(address ico_token_address)\n', '    public\n', '    {\n', '        //Проверяем чтобы это был вызов из grand_factory\n', '        require(grand_factory == msg.sender);\n', '\n', '        //Проверяем что ранее не был доавлен такой токен\n', '        require(tokens_map[ico_token_address] == 0);\n', '\n', '        tokens_arr.push(\n', '            TokenInfo(\n', '                ico_token_address,\n', '                0));\n', '        tokens_map[ico_token_address] = tokens_arr.length - 1;\n', '    }\n', '\n', '\n', '\n', '    //------------------------------ERC20---------------------------------------\n', '\n', '    //Баланс в токенах\n', '    function balanceOf(address _owner)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        //        uint withdraw_to_transfer = withdrawn[msg.sender] *  _value / balances[msg.sender];\n', '\n', '        for (uint i = 0; i < tokens_arr.length; i++)\n', '        {\n', '            //Сколько забранных сущностей переместить на другой аккаунт\n', '            uint withdraw_to_transfer = withdrawns[msg.sender][i].mul(_value).div(balances[msg.sender]);\n', '\n', '            //Перводим забранный доход\n', '            withdrawns[msg.sender][i] = withdrawns[msg.sender][i].sub(withdraw_to_transfer);\n', '            withdrawns[_to][i] = withdrawns[_to][i].add(withdraw_to_transfer);\n', '        }\n', '\n', '\n', '        //Переводим токены\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '\n', '        //Генерим событие\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        for (uint i = 0; i < tokens_arr.length; i++)\n', '        {\n', '            //Сколько забранных сущностей переместить на другой аккаунт\n', '            uint withdraw_to_transfer = withdrawns[_from][i].mul(_value).div(balances[_from]);\n', '\n', '            //Перводим забранный доход\n', '            withdrawns[_from][i] = withdrawns[_from][i].sub(withdraw_to_transfer);\n', '            withdrawns[_to][i] = withdrawns[_to][i].add(withdraw_to_transfer);\n', '        }\n', '\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    ///////////////////////////////////ERC20////////////////////////////////////\n', '\n', '    struct TokenInfo\n', '    {\n', '        //Адрес контракта токена (может выплить потом?)\n', '        address contract_address;\n', '\n', '        //Весь доход, переведенный на адрес данного контракта вызовом\n', '        //функции addTokenBalance\n', '        uint256 ever_added;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Platform\n', '{\n', '    address public platform = 0x709a0A8deB88A2d19DAB2492F669ef26Fd176f6C;\n', '\n', '    modifier onlyPlatform() {\n', '        require(msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    function isPlatform() public view returns (bool) {\n', '        return platform == msg.sender;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract BeneficiaryInterface\n', '{\n', '    function getAvailableWithdrawInvestmentsForBeneficiary() public view returns (uint);\n', '    function withdrawInvestmentsBeneficiary(address withdraw_address) public returns (bool);\n', '}\n', '\n', '\n', '//Интерфейс для ICO контрактов, чтобы те могли говорить CNRToken-у\n', '//о том что ему перевели бабки\n', 'contract CNRAddBalanceInterface\n', '{\n', '    function addTokenBalance(address, uint) public;\n', '}\n', '\n', '\n', '//Интерфейс для фабрики, чтобы она могла добавлять токены\n', 'contract CNRAddTokenInterface\n', '{\n', '    function addTokenAddress(address) public;\n', '}\n', '\n', '//TODO: может сделать класс TokensCollection, куда вынести всю функциональность из  tokens_map, tokens_arr итд\n', 'contract CNRToken is ERC20, CNRAddBalanceInterface, CNRAddTokenInterface, Platform\n', '{\n', '    using SafeMath for uint256;\n', '\n', '\n', '    //Токен  ERC20\n', '    string public constant name = "ICO Constructor token";\n', '    string public constant symbol = "CNR";\n', '    uint256 public constant decimals = 18;\n', '\n', '\n', '    //-------------------------ERC20 interface----------------------------------\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '    mapping(address => uint256) balances;\n', '    ////////////////////////////ERC20 interface/////////////////////////////////\n', '\n', '    //Адрес гранд фабрики\n', '    address public grand_factory = address(0);\n', '\n', '    //Мапа и массив добавленнх токенов. Нулевой элемент  зарезервирован для\n', '    //эфира. Остальные для токенов\n', '    mapping(address => uint256) public  tokens_map;\n', '    TokenInfo[] public                  tokens_arr;\n', '\n', '    //Мапа с забранными сущностями (эфиром, токенами). (адрес кошелька клиента => (индекс токена => сколько уже забрал))\n', '    //По индексу 0 - всегда эфир.\n', '    mapping(address => mapping(uint => uint)) withdrawns;\n', '\n', '    function CNRToken() public\n', '    {\n', '        totalSupply = 10*1000*1000*(10**decimals); // 10 mln\n', '        balances[msg.sender] = totalSupply;\n', '\n', '        //На нулевом индексе находится эфир\n', '        tokens_arr.push(\n', '            TokenInfo(\n', '                address(0),\n', '                0));\n', '    }\n', '\n', '\n', '    //Функция получения адресов всех добавленных токенов\n', '    function getRegisteredTokens()\n', '    public view\n', '    returns (address[])\n', '    {\n', '        // ситуация, когда не добавлены токены. <= чтобы убрать пред mythril,\n', '        // который не понимает что в конструкторе забит первый элемент\n', '        if (tokens_arr.length <= 1)\n', '            return;\n', '\n', '        address[] memory token_addresses = new address[](tokens_arr.length-1);\n', '        for (uint i = 1; i < tokens_arr.length; i++)\n', '        {\n', '            token_addresses[i-1] = tokens_arr[i].contract_address;\n', '        }\n', '\n', '        return token_addresses;\n', '    }\n', '\n', '    //Функиця получения данных о всех доступных доходах в ether со всех\n', '    //зарегистрированных контрактов токенов. Чтобы воспользоваться этими\n', '    //доходами нужно для кажжого токена вызвать takeICOInvestmentsEtherCommission\n', '    function getAvailableEtherCommissions()\n', '    public view\n', '    returns(\n', '        address[],\n', '        uint[]\n', '    )\n', '    {\n', '        // ситуация, когда не добавлены токены. <= чтобы убрать пред mythril,\n', '        // который не понимает что в конструкторе забит первый элемент\n', '        if (tokens_arr.length <= 1)\n', '            return;\n', '\n', '        address[] memory token_addresses = new address[](tokens_arr.length-1);\n', '        uint[] memory available_withdraws = new uint[](tokens_arr.length-1);\n', '        //Здесь должно быть от 1-го, потому что на 0-ом - эфир\n', '        for (uint i = 1; i < tokens_arr.length; i++)\n', '        {\n', '            token_addresses[i-1] = tokens_arr[i].contract_address;\n', '            available_withdraws[i-1] =\n', '                BeneficiaryInterface(tokens_arr[i].contract_address).getAvailableWithdrawInvestmentsForBeneficiary();\n', '        }\n', '\n', '        return (token_addresses, available_withdraws);\n', '    }\n', '\n', '\n', '    //Функция, которую может дергнуть кто угодно, чтобы на данный  контракт были переведен\n', '    //комиссии с инвестиций в эфире\n', '    function takeICOInvestmentsEtherCommission(address ico_token_address)\n', '    public\n', '    {\n', '        //Проверяем что ранее был! добавлен такой токен\n', '        require(tokens_map[ico_token_address] != 0);\n', '\n', '        //Узнаем сколько мы можем вывести бабла\n', '        uint available_investments_commission =\n', '            BeneficiaryInterface(ico_token_address).getAvailableWithdrawInvestmentsForBeneficiary();\n', '\n', '        //Запоминаем что бабки забрали\n', '        //запоминаем до перевода, так как потом дергаем external contract method\n', '        tokens_arr[0].ever_added = tokens_arr[0].ever_added.add(available_investments_commission);\n', '\n', '        //Переводим бабло на адрес этого контракта\n', '        BeneficiaryInterface(ico_token_address).withdrawInvestmentsBeneficiary(\n', '            address(this));\n', '    }\n', '\n', '\n', '    //Специально разрешаем получение бабла\n', '    function()\n', '    public payable\n', '    {\n', '\n', '    }\n', '\n', '\n', '    //Метод установки адреса grandFactory, который будет использован\n', '    function setGrandFactory(address _grand_factory)\n', '    public\n', '        onlyPlatform\n', '    {\n', '        //Проверяем чтобы адрес был передан нормальный\n', '        require(_grand_factory != address(0));\n', '\n', '        grand_factory = _grand_factory;\n', '    }\n', '\n', '    // баланс рассчитывается по формуле:\n', '    // общее количество токенов контракта _token_address, которым владеет контракт CNR\n', '    // умножаем на количество токенов CNR у _owner, делим на totalSupply (получаем долю)\n', "    // и отнимаем уже выведенную _owner'ом сумму токенов\n", '    //Доступный к выводу баланс в токенах некоторого ICO\n', '    function balanceOfToken(address _owner, address _token_address)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        //Проверка наличия такого токена\n', '        require(tokens_map[_token_address] != 0);\n', '\n', '        uint idx = tokens_map[_token_address];\n', '        balance =\n', '            tokens_arr[idx].ever_added\n', '            .mul(balances[_owner])\n', '            .div(totalSupply)\n', '            .sub(withdrawns[_owner][idx]);\n', '        }\n', '\n', '    // все как и в balanceOfToken, только используем 0 элемент в tokens_arr и withdrawns[_owner]\n', '    //Доступный к выводу баланс в эфирах\n', '    function balanceOfETH(address _owner)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        balance =\n', '            tokens_arr[0].ever_added\n', '            .mul(balances[_owner])\n', '            .div(totalSupply)\n', '            .sub(withdrawns[_owner][0]);\n', '    }\n', '\n', '    //Функция перевода доступных токенов некоторого ICO на указанный кошелек\n', '    function withdrawTokens(address _token_address, address _destination_address)\n', '    public\n', '    {\n', '        //Проверка наличия такого токена\n', '        require(tokens_map[_token_address] != 0);\n', '\n', '        uint token_balance = balanceOfToken(msg.sender, _token_address);\n', '        uint token_idx = tokens_map[_token_address];\n', '        withdrawns[msg.sender][token_idx] = withdrawns[msg.sender][token_idx].add(token_balance);\n', '        ERC20Basic(_token_address).transfer(_destination_address, token_balance);\n', '    }\n', '\n', '    //Функиця забирания доступного эфира на указанный кошелек\n', '    function withdrawETH(address _destination_address)\n', '    public\n', '    {\n', '        uint value_in_wei = balanceOfETH(msg.sender);\n', '        withdrawns[msg.sender][0] = withdrawns[msg.sender][0].add(value_in_wei);\n', '        _destination_address.transfer(value_in_wei);\n', '    }\n', '\n', '\n', '    //Данная функция дложна вызываться из контрактов-токенов, в тот момент когда бенефициару\n', '    //(на контракт бенефициара) переводятся токены\n', '    function addTokenBalance(address _token_contract, uint amount)\n', '    public\n', '    {\n', '        //Проверяем что функция вызывается из ранее добавленноно! контракта токена\n', '        require(tokens_map[msg.sender] != 0);\n', '\n', '        //ДОбавление данных обо всех токенах, переведенных бенефициару\n', '        tokens_arr[tokens_map[_token_contract]].ever_added = tokens_arr[tokens_map[_token_contract]].ever_added.add(amount);\n', '    }\n', '\n', '    //Функиця добавления нового токена. Данная функция должна вызываться\n', '    //только GrandFactory при создании нового ICO токена\n', '    function addTokenAddress(address ico_token_address)\n', '    public\n', '    {\n', '        //Проверяем чтобы это был вызов из grand_factory\n', '        require(grand_factory == msg.sender);\n', '\n', '        //Проверяем что ранее не был доавлен такой токен\n', '        require(tokens_map[ico_token_address] == 0);\n', '\n', '        tokens_arr.push(\n', '            TokenInfo(\n', '                ico_token_address,\n', '                0));\n', '        tokens_map[ico_token_address] = tokens_arr.length - 1;\n', '    }\n', '\n', '\n', '\n', '    //------------------------------ERC20---------------------------------------\n', '\n', '    //Баланс в токенах\n', '    function balanceOf(address _owner)\n', '    public view\n', '    returns (uint256 balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        //        uint withdraw_to_transfer = withdrawn[msg.sender] *  _value / balances[msg.sender];\n', '\n', '        for (uint i = 0; i < tokens_arr.length; i++)\n', '        {\n', '            //Сколько забранных сущностей переместить на другой аккаунт\n', '            uint withdraw_to_transfer = withdrawns[msg.sender][i].mul(_value).div(balances[msg.sender]);\n', '\n', '            //Перводим забранный доход\n', '            withdrawns[msg.sender][i] = withdrawns[msg.sender][i].sub(withdraw_to_transfer);\n', '            withdrawns[_to][i] = withdrawns[_to][i].add(withdraw_to_transfer);\n', '        }\n', '\n', '\n', '        //Переводим токены\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '\n', '        //Генерим событие\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        for (uint i = 0; i < tokens_arr.length; i++)\n', '        {\n', '            //Сколько забранных сущностей переместить на другой аккаунт\n', '            uint withdraw_to_transfer = withdrawns[_from][i].mul(_value).div(balances[_from]);\n', '\n', '            //Перводим забранный доход\n', '            withdrawns[_from][i] = withdrawns[_from][i].sub(withdraw_to_transfer);\n', '            withdrawns[_to][i] = withdrawns[_to][i].add(withdraw_to_transfer);\n', '        }\n', '\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    ///////////////////////////////////ERC20////////////////////////////////////\n', '\n', '    struct TokenInfo\n', '    {\n', '        //Адрес контракта токена (может выплить потом?)\n', '        address contract_address;\n', '\n', '        //Весь доход, переведенный на адрес данного контракта вызовом\n', '        //функции addTokenBalance\n', '        uint256 ever_added;\n', '    }\n', '}']
