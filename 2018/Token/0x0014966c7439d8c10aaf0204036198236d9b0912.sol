['//File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    assert(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '    assert(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    assert(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/ownership/CanReclaimToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/math/SafeMath.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '//File: src/contracts/ico/KYCBase.sol\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '// Abstract base contract\n', 'contract KYCBase {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => bool) public isKycSigner;\n', '    mapping (uint64 => uint256) public alreadyPayed;\n', '\n', '    event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);\n', '\n', '    function KYCBase(address [] kycSigners) internal {\n', '        for (uint i = 0; i < kycSigners.length; i++) {\n', '            isKycSigner[kycSigners[i]] = true;\n', '        }\n', '    }\n', '\n', '    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\n', '    function releaseTokensTo(address buyer) internal returns(bool);\n', '\n', '    // This method can be overridden to enable some sender to buy token for a different address\n', '    function senderAllowedFor(address buyer)\n', '        internal view returns(bool)\n', '    {\n', '        return buyer == msg.sender;\n', '    }\n', '\n', '    function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n', '        public payable returns (bool)\n', '    {\n', '        require(senderAllowedFor(buyerAddress));\n', '        return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);\n', '    }\n', '\n', '    function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n', '        public payable returns (bool)\n', '    {\n', '        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\n', '    }\n', '\n', '    function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n', '        private returns (bool)\n', '    {\n', '        // check the signature\n', '        bytes32 hash = sha256("Eidoo icoengine authorization", this, buyerAddress, buyerId, maxAmount);\n', '        address signer = ecrecover(hash, v, r, s);\n', '        if (!isKycSigner[signer]) {\n', '            revert();\n', '        } else {\n', '            uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);\n', '            require(totalPayed <= maxAmount);\n', '            alreadyPayed[buyerId] = totalPayed;\n', '            KycVerified(signer, buyerAddress, buyerId, maxAmount);\n', '            return releaseTokensTo(buyerAddress);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor\n', '    function () public {\n', '        revert();\n', '    }\n', '}\n', '//File: src/contracts/ico/ICOEngineInterface.sol\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', 'contract ICOEngineInterface {\n', '\n', '    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\n', '    function started() public view returns(bool);\n', '\n', '    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\n', '    function ended() public view returns(bool);\n', '\n', '    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\n', '    function startTime() public view returns(uint);\n', '\n', '    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\n', '    function endTime() public view returns(uint);\n', '\n', '    // Optional function, can be implemented in place of startTime\n', '    // Returns the starting block number of the ico, must return 0 if it depends on the time stamp\n', '    // function startBlock() public view returns(uint);\n', '\n', '    // Optional function, can be implemented in place of endTime\n', '    // Returns theending block number of the ico, must retrun 0 if it depends on the time stamp\n', '    // function endBlock() public view returns(uint);\n', '\n', '    // returns the total number of the tokens available for the sale, must not change when the ico is started\n', '    function totalTokens() public view returns(uint);\n', '\n', '    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\n', '    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\n', '    function remainingTokens() public view returns(uint);\n', '\n', '    // return the price as number of tokens released for each ether\n', '    function price() public view returns(uint);\n', '}\n', '//File: src/contracts/ico/CrowdsaleBase.sol\n', '/**\n', ' * @title CrowdsaleBase\n', ' * @dev Base crowdsale contract to be inherited by the UacCrowdsale and Reservation contracts.\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="92fbfcf4fdd2e4f3fefbf6fbe6ebfef3f0e1bcfde0f5">[email&#160;protected]</a>>\n', ' */\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract CrowdsaleBase is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase {\n', '\n', '    /*** CONSTANTS ***/\n', '    uint256 public constant USD_PER_TOKEN = 2;                        //\n', '    uint256 public constant USD_PER_ETHER = 795;                      // \n', '\n', '    uint256 public start;                                             // ICOEngineInterface\n', '    uint256 public end;                                               // ICOEngineInterface\n', '    uint256 public cap;                                               // ICOEngineInterface\n', '    address public wallet;\n', '    uint256 public tokenPerEth;\n', '    uint256 public availableTokens;                                   // ICOEngineInterface\n', '    address[] public kycSigners;                                      // KYCBase\n', '    bool public capReached;\n', '    uint256 public weiRaised;\n', '    uint256 public tokensSold;\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _start The start time of the sale.\n', '     * @param _end The end time of the sale.\n', '     * @param _cap The maximum amount of tokens to be sold during the sale.\n', '     * @param _wallet The address where funds should be transferred.\n', '     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\n', '     * See https://github.com/eidoo/icoengine\n', '     */\n', '    function CrowdsaleBase(\n', '        uint256 _start,\n', '        uint256 _end,\n', '        uint256 _cap,\n', '        address _wallet,\n', '        address[] _kycSigners\n', '    )\n', '        public\n', '        KYCBase(_kycSigners)\n', '    {\n', '        require(_end >= _start);\n', '        require(_cap > 0);\n', '\n', '        start = _start;\n', '        end = _end;\n', '        cap = _cap;\n', '        wallet = _wallet;\n', '        tokenPerEth = USD_PER_ETHER.div(USD_PER_TOKEN);\n', '        availableTokens = _cap;\n', '        kycSigners = _kycSigners;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return False if the ico is not started, true if the ico is started and running, true if the ico is completed.\n', '     */\n', '    function started() public view returns(bool) {\n', '        if (block.timestamp >= start) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return False if the ico is not started, false if the ico is started and running, true if the ico is completed.\n', '     */\n', '    function ended() public view returns(bool) {\n', '        if (block.timestamp >= end) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return Timestamp of the ico start time.\n', '     */\n', '    function startTime() public view returns(uint) {\n', '        return start;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return Timestamp of the ico end time.\n', '     */\n', '    function endTime() public view returns(uint) {\n', '        return end;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return The total number of the tokens available for the sale, must not change when the ico is started.\n', '     */\n', '    function totalTokens() public view returns(uint) {\n', '        return cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the ICOEngineInterface.\n', '     * @return The number of the tokens available for the ico. At the moment the ico starts it must be equal to totalTokens(),\n', '     * then it will decrease.\n', '     */\n', '    function remainingTokens() public view returns(uint) {\n', '        return availableTokens;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the KYCBase senderAllowedFor function to enable a sender to buy tokens for a different address.\n', '     * @return true.\n', '     */\n', '    function senderAllowedFor(address buyer) internal view returns(bool) {\n', '        require(buyer != address(0));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the KYCBase releaseTokensTo function to mint tokens for an investor. Called after the KYC process has passed.\n', '     * @return A bollean that indicates if the operation was successful.\n', '     */\n', '    function releaseTokensTo(address buyer) internal returns(bool) {\n', '        require(validPurchase());\n', '\n', '        uint256 overflowTokens;\n', '        uint256 refundWeiAmount;\n', '\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokenAmount = weiAmount.mul(price());\n', '\n', '        if (tokenAmount >= availableTokens) {\n', '            capReached = true;\n', '            overflowTokens = tokenAmount.sub(availableTokens);\n', '            tokenAmount = tokenAmount.sub(overflowTokens);\n', '            refundWeiAmount = overflowTokens.div(price());\n', '            weiAmount = weiAmount.sub(refundWeiAmount);\n', '            buyer.transfer(refundWeiAmount);\n', '        }\n', '\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokenAmount);\n', '        availableTokens = availableTokens.sub(tokenAmount);\n', '        mintTokens(buyer, tokenAmount);\n', '        forwardFunds(weiAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Fired by the releaseTokensTo function after minting tokens, to forward the raised wei to the address that collects funds.\n', '     * @param _weiAmount Amount of wei send by the investor.\n', '     */\n', '    function forwardFunds(uint256 _weiAmount) internal {\n', '        wallet.transfer(_weiAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Validates an incoming purchase. Required statements revert state when conditions are not met.\n', '     * @return true If the transaction can buy tokens.\n', '     */\n', '    function validPurchase() internal view returns (bool) {\n', '        require(!paused && !capReached);\n', '        require(block.timestamp >= start && block.timestamp <= end);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Abstract function to mint tokens, to be implemented in the Crowdsale and Reservation contracts.\n', '    * @param to The address that will receive the minted tokens.\n', '    * @param amount The amount of tokens to mint.\n', '    */\n', '    function mintTokens(address to, uint256 amount) private;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/TokenVesting.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TokenVesting\n', ' * @dev A token holder contract that can release its token balance gradually like a\n', ' * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n', ' * owner.\n', ' */\n', 'contract TokenVesting is Ownable {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  event Released(uint256 amount);\n', '  event Revoked();\n', '\n', '  // beneficiary of tokens after they are released\n', '  address public beneficiary;\n', '\n', '  uint256 public cliff;\n', '  uint256 public start;\n', '  uint256 public duration;\n', '\n', '  bool public revocable;\n', '\n', '  mapping (address => uint256) public released;\n', '  mapping (address => bool) public revoked;\n', '\n', '  /**\n', '   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n', '   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n', '   * of the balance will have vested.\n', '   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n', '   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n', '   * @param _duration duration in seconds of the period in which the tokens will vest\n', '   * @param _revocable whether the vesting is revocable or not\n', '   */\n', '  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\n', '    require(_beneficiary != address(0));\n', '    require(_cliff <= _duration);\n', '\n', '    beneficiary = _beneficiary;\n', '    revocable = _revocable;\n', '    duration = _duration;\n', '    cliff = _start.add(_cliff);\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers vested tokens to beneficiary.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function release(ERC20Basic token) public {\n', '    uint256 unreleased = releasableAmount(token);\n', '\n', '    require(unreleased > 0);\n', '\n', '    released[token] = released[token].add(unreleased);\n', '\n', '    token.safeTransfer(beneficiary, unreleased);\n', '\n', '    Released(unreleased);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the owner to revoke the vesting. Tokens already vested\n', '   * remain in the contract, the rest are returned to the owner.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function revoke(ERC20Basic token) public onlyOwner {\n', '    require(revocable);\n', '    require(!revoked[token]);\n', '\n', '    uint256 balance = token.balanceOf(this);\n', '\n', '    uint256 unreleased = releasableAmount(token);\n', '    uint256 refund = balance.sub(unreleased);\n', '\n', '    revoked[token] = true;\n', '\n', '    token.safeTransfer(owner, refund);\n', '\n', '    Revoked();\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the amount that has already vested but hasn&#39;t been released yet.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function releasableAmount(ERC20Basic token) public view returns (uint256) {\n', '    return vestedAmount(token).sub(released[token]);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the amount that has already vested.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function vestedAmount(ERC20Basic token) public view returns (uint256) {\n', '    uint256 currentBalance = token.balanceOf(this);\n', '    uint256 totalBalance = currentBalance.add(released[token]);\n', '\n', '    if (now < cliff) {\n', '      return 0;\n', '    } else if (now >= start.add(duration) || revoked[token]) {\n', '      return totalBalance;\n', '    } else {\n', '      return totalBalance.mul(now.sub(start)).div(duration);\n', '    }\n', '  }\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', '//File: node_modules/zeppelin-solidity/contracts/token/ERC20/PausableToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', '//File: src/contracts/ico/UacToken.sol\n', '/**\n', ' * @title Ubiatar Coin token\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dbb2b5bdb49badbab7b2bfb2afa2b7bab9a8f5b4a9bc">[email&#160;protected]</a>>\n', ' */\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '\n', 'contract UacToken is CanReclaimToken, MintableToken, PausableToken {\n', '    string public constant name = "Ubiatar Coin";\n', '    string public constant symbol = "UAC";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /**\n', '     * @dev Constructor of UacToken that instantiates a new Mintable Pausable Token\n', '     */\n', '    function UacToken() public {\n', '        // token should not be transferrable until after all tokens have been issued\n', '        paused = true;\n', '    }\n', '}\n', '\n', '//File: src/contracts/ico/UbiatarPlayVault.sol\n', '/**\n', ' * @title UbiatarPlayVault\n', ' * @dev A token holder contract that allows the release of tokens to the UbiatarPlay Wallet.\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e9eee6efc0f6e1ece9e4e9f4f9ece1e2f3aeeff2e7">[email&#160;protected]</a>>\n', ' */\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract UbiatarPlayVault {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for UacToken;\n', '\n', '    uint256[6] public vesting_offsets = [\n', '        90 days,\n', '        180 days,\n', '        270 days,\n', '        360 days,\n', '        540 days,\n', '        720 days\n', '    ];\n', '\n', '    uint256[6] public vesting_amounts = [\n', '        2e6 * 1e18,\n', '        4e6 * 1e18,\n', '        6e6 * 1e18,\n', '        8e6 * 1e18,\n', '        10e6 * 1e18,\n', '        20.5e6 * 1e18\n', '    ];\n', '\n', '    address public ubiatarPlayWallet;\n', '    UacToken public token;\n', '    uint256 public start;\n', '    uint256 public released;\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _ubiatarPlayWallet The address that will receive the vested tokens.\n', '     * @param _token The UAC Token, which is being vested.\n', '     * @param _start The start time from which each release time will be calculated.\n', '     */\n', '    function UbiatarPlayVault(\n', '        address _ubiatarPlayWallet,\n', '        address _token,\n', '        uint256 _start\n', '    )\n', '        public\n', '    {\n', '        ubiatarPlayWallet = _ubiatarPlayWallet;\n', '        token = UacToken(_token);\n', '        start = _start;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers vested tokens to ubiatarPlayWallet.\n', '     */\n', '    function release() public {\n', '        uint256 unreleased = releasableAmount();\n', '        require(unreleased > 0);\n', '\n', '        released = released.add(unreleased);\n', '\n', '        token.safeTransfer(ubiatarPlayWallet, unreleased);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the amount that has already vested but hasn&#39;t been released yet.\n', '     */\n', '    function releasableAmount() public view returns (uint256) {\n', '        return vestedAmount().sub(released);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the amount that has already vested.\n', '     */\n', '    function vestedAmount() public view returns (uint256) {\n', '        uint256 vested = 0;\n', '\n', '        for (uint256 i = 0; i < vesting_offsets.length; i = i.add(1)) {\n', '            if (block.timestamp > start.add(vesting_offsets[i])) {\n', '                vested = vested.add(vesting_amounts[i]);\n', '            }\n', '        }\n', '\n', '        return vested;\n', '    }\n', '}\n', '\n', '\n', '\n', '//File: src/contracts/ico/PresaleTokenVault.sol\n', '/**\n', ' * @title PresaleTokenVault\n', ' * @dev A token holder contract that allows multiple beneficiaries to extract their tokens after a given release time.\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83eaede5ecc3f5e2efeae7eaf7faefe2e1f0adecf1e4">[email&#160;protected]</a>>\n', ' */\n', 'pragma solidity ^0.4.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PresaleTokenVault {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    /*** CONSTANTS ***/\n', '    uint256 public constant VESTING_OFFSET = 90 days;                   // starting of vesting\n', '    uint256 public constant VESTING_DURATION = 180 days;                // duration of vesting\n', '\n', '    uint256 public start;\n', '    uint256 public cliff;\n', '    uint256 public end;\n', '\n', '    ERC20Basic public token;\n', '\n', '    struct Investment {\n', '        address beneficiary;\n', '        uint256 totalBalance;\n', '        uint256 released;\n', '    }\n', '\n', '    Investment[] public investments;\n', '\n', '    // key: investor address; value: index in investments array.\n', '    mapping(address => uint256) public investorLUT;\n', '\n', '    function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\n', '        // makes sure this function is only called once\n', '        require(token == address(0));\n', '        require(beneficiaries.length == balances.length);\n', '\n', '        start = startTime;\n', '        cliff = start.add(VESTING_OFFSET);\n', '        end = cliff.add(VESTING_DURATION);\n', '\n', '        token = ERC20Basic(_token);\n', '\n', '        for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\n', '            investorLUT[beneficiaries[i]] = investments.length;\n', '            investments.push(Investment(beneficiaries[i], balances[i], 0));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Allows a sender to transfer vested tokens to the beneficiary&#39;s address.\n', '     * @param beneficiary The address that will receive the vested tokens.\n', '     */\n', '    function release(address beneficiary) public {\n', '        uint256 unreleased = releasableAmount(beneficiary);\n', '        require(unreleased > 0);\n', '\n', '        uint256 investmentIndex = investorLUT[beneficiary];\n', '        investments[investmentIndex].released = investments[investmentIndex].released.add(unreleased);\n', '        token.safeTransfer(beneficiary, unreleased);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers vested tokens to the sender&#39;s address.\n', '     */\n', '    function release() public {\n', '        release(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the amount that has already vested but hasn&#39;t been released yet.\n', '     * @param beneficiary The address that will receive the vested tokens.\n', '     */\n', '    function releasableAmount(address beneficiary) public view returns (uint256) {\n', '        uint256 investmentIndex = investorLUT[beneficiary];\n', '\n', '        return vestedAmount(beneficiary).sub(investments[investmentIndex].released);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the amount that has already vested.\n', '     * @param beneficiary The address that will receive the vested tokens.\n', '     */\n', '    function vestedAmount(address beneficiary) public view returns (uint256) {\n', '\n', '        uint256 investmentIndex = investorLUT[beneficiary];\n', '\n', '        uint256 vested = 0;\n', '\n', '        if (block.timestamp >= start) {\n', '            // after start -> 1/3 released (fixed)\n', '            vested = investments[investmentIndex].totalBalance.div(3);\n', '        }\n', '        if (block.timestamp >= cliff && block.timestamp < end) {\n', '            // after cliff -> linear vesting over time\n', '            uint256 p1 = investments[investmentIndex].totalBalance.div(3);\n', '            uint256 p2 = investments[investmentIndex].totalBalance;\n', '\n', '            /*\n', '              released amount:  r\n', '              1/3:              p1\n', '              all:              p2\n', '              current time:     t\n', '              cliff:            c\n', '              end:              e\n', '\n', '              r = p1 +  / d_time * time\n', '                = p1 + (p2-p1) / (e-c) * (t-c)\n', '            */\n', '            uint256 d_token = p2.sub(p1);\n', '            uint256 time = block.timestamp.sub(cliff);\n', '            uint256 d_time = end.sub(cliff);\n', '\n', '            vested = vested.add(d_token.mul(time).div(d_time));\n', '        }\n', '        if (block.timestamp >= end) {\n', '            // after end -> all vested\n', '            vested = investments[investmentIndex].totalBalance;\n', '        }\n', '        return vested;\n', '    }\n', '}\n', '\n', '//File: src/contracts/ico/UacCrowdsale.sol\n', '/**\n', ' * @title UacCrowdsale\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="60090e060f2016010c09040914190c0102134e0f1207">[email&#160;protected]</a>>\n', ' */\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract UacCrowdsale is CrowdsaleBase {\n', '\n', '    /*** CONSTANTS ***/\n', '    uint256 public constant START_TIME = 1525856400;                     // 9 May 2018 09:00:00 GMT\n', '    uint256 public constant END_TIME = 1528448400;                       // 8 June 2018 09:00:00 GMT\n', '    uint256 public constant PRESALE_VAULT_START = END_TIME + 7 days;\n', '    uint256 public constant PRESALE_CAP = 17584778551358900100698693;\n', '    uint256 public constant TOTAL_MAX_CAP = 15e6 * 1e18;                // Reservation plus main sale tokens\n', '    uint256 public constant CROWDSALE_CAP = 7.5e6 * 1e18;\n', '    uint256 public constant FOUNDERS_CAP = 12e6 * 1e18;\n', '    uint256 public constant UBIATARPLAY_CAP = 50.5e6 * 1e18;\n', '    uint256 public constant ADVISORS_CAP = 4915221448641099899301307;\n', '\n', '    // Eidoo interface requires price as tokens/ether, therefore the discounts are presented as bonus tokens.\n', '    uint256 public constant BONUS_TIER1 = 108;                           // 8% during first 3 hours\n', '    uint256 public constant BONUS_TIER2 = 106;                           // 6% during next 9 hours\n', '    uint256 public constant BONUS_TIER3 = 104;                           // 4% during next 30 hours\n', '    uint256 public constant BONUS_DURATION_1 = 3 hours;\n', '    uint256 public constant BONUS_DURATION_2 = 12 hours;\n', '    uint256 public constant BONUS_DURATION_3 = 42 hours;\n', '\n', '    uint256 public constant FOUNDERS_VESTING_CLIFF = 1 years;\n', '    uint256 public constant FOUNDERS_VESTING_DURATION = 2 years;\n', '\n', '    Reservation public reservation;\n', '\n', '    // Vesting contracts.\n', '    PresaleTokenVault public presaleTokenVault;\n', '    TokenVesting public foundersVault;\n', '    UbiatarPlayVault public ubiatarPlayVault;\n', '\n', '    // Vesting wallets.\n', '    address public foundersWallet;\n', '    address public advisorsWallet;\n', '    address public ubiatarPlayWallet;\n', '\n', '    address public wallet;\n', '\n', '    UacToken public token;\n', '\n', '    // Lets owner manually end crowdsale.\n', '    bool public didOwnerEndCrowdsale;\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @param _foundersWallet address Wallet holding founders tokens.\n', '     * @param _advisorsWallet address Wallet holding advisors tokens.\n', '     * @param _ubiatarPlayWallet address Wallet holding ubiatarPlay tokens.\n', '     * @param _wallet The address where funds should be transferred.\n', '     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\n', '     * See https://github.com/eidoo/icoengine\n', '     */\n', '    function UacCrowdsale(\n', '        address _token,\n', '        address _reservation,\n', '        address _presaleTokenVault,\n', '        address _foundersWallet,\n', '        address _advisorsWallet,\n', '        address _ubiatarPlayWallet,\n', '        address _wallet,\n', '        address[] _kycSigners\n', '    )\n', '        public\n', '        CrowdsaleBase(START_TIME, END_TIME, TOTAL_MAX_CAP, _wallet, _kycSigners)\n', '    {\n', '        token = UacToken(_token);\n', '        reservation = Reservation(_reservation);\n', '        presaleTokenVault = PresaleTokenVault(_presaleTokenVault);\n', '        foundersWallet = _foundersWallet;\n', '        advisorsWallet = _advisorsWallet;\n', '        ubiatarPlayWallet = _ubiatarPlayWallet;\n', '        wallet = _wallet;\n', '        // Create founders vault contract\n', '        foundersVault = new TokenVesting(foundersWallet, END_TIME, FOUNDERS_VESTING_CLIFF, FOUNDERS_VESTING_DURATION, false);\n', '\n', '        // Create Ubiatar Play vault contract\n', '        ubiatarPlayVault = new UbiatarPlayVault(ubiatarPlayWallet, address(token), END_TIME);\n', '    }\n', '\n', '    function mintPreAllocatedTokens() public onlyOwner {\n', '        mintTokens(address(foundersVault), FOUNDERS_CAP);\n', '        mintTokens(advisorsWallet, ADVISORS_CAP);\n', '        mintTokens(address(ubiatarPlayVault), UBIATARPLAY_CAP);\n', '    }\n', '\n', '    /**\n', '     * @dev Creates the presale vault contract.\n', '     * @param beneficiaries Array of the presale investors addresses to whom vested tokens are transferred.\n', '     * @param balances Array of token amount per beneficiary.\n', '     */\n', '    function initPresaleTokenVault(address[] beneficiaries, uint256[] balances) public onlyOwner {\n', '        require(beneficiaries.length == balances.length);\n', '\n', '        presaleTokenVault.init(beneficiaries, balances, PRESALE_VAULT_START, token);\n', '\n', '        uint256 totalPresaleBalance = 0;\n', '        uint256 balancesLength = balances.length;\n', '        for(uint256 i = 0; i < balancesLength; i++) {\n', '            totalPresaleBalance = totalPresaleBalance.add(balances[i]);\n', '        }\n', '\n', '        mintTokens(presaleTokenVault, totalPresaleBalance);\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the price function from EidooEngineInterface.\n', '     * @notice Calculates the price as tokens/ether based on the corresponding bonus bracket.\n', '     * @return Price as tokens/ether.\n', '     */\n', '    function price() public view returns (uint256 _price) {\n', '        if (block.timestamp <= start.add(BONUS_DURATION_1)) {\n', '            return tokenPerEth.mul(BONUS_TIER1).div(1e2);\n', '        } else if (block.timestamp <= start.add(BONUS_DURATION_2)) {\n', '            return tokenPerEth.mul(BONUS_TIER2).div(1e2);\n', '        } else if (block.timestamp <= start.add(BONUS_DURATION_3)) {\n', '            return tokenPerEth.mul(BONUS_TIER3).div(1e2);\n', '        }\n', '        return tokenPerEth;\n', '    }\n', '\n', '    /**\n', '     * @dev Mints tokens being sold during the reservation phase, as part of the implementation of the releaseTokensTo function\n', '     * from the KYCBase contract.\n', '     * Also, updates tokensSold and availableTokens in the crowdsale contract.\n', '     * @param to The address that will receive the minted tokens.\n', '     * @param amount The amount of tokens to mint.\n', '     */\n', '    function mintReservationTokens(address to, uint256 amount) public {\n', '        require(msg.sender == address(reservation));\n', '        tokensSold = tokensSold.add(amount);\n', '        availableTokens = availableTokens.sub(amount);\n', '        mintTokens(to, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Mints tokens being sold during the crowdsale phase as part of the implementation of releaseTokensTo function\n', '     * from the KYCBase contract.\n', '     * @param to The address that will receive the minted tokens.\n', '     * @param amount The amount of tokens to mint.\n', '     */\n', '    function mintTokens(address to, uint256 amount) private {\n', '        token.mint(to, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the owner to close the crowdsale manually before the end time.\n', '     */\n', '    function closeCrowdsale() public onlyOwner {\n', '        require(block.timestamp >= START_TIME && block.timestamp < END_TIME);\n', '        didOwnerEndCrowdsale = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the owner to unpause tokens, stop minting and transfer ownership of the token contract.\n', '     */\n', '    function finalise() public onlyOwner {\n', '        require(didOwnerEndCrowdsale || block.timestamp > end || capReached);\n', '        token.finishMinting();\n', '        token.unpause();\n', '\n', '        // Token contract extends CanReclaimToken so the owner can recover any ERC20 token received in this contract by mistake.\n', '        // So far, the owner of the token contract is the crowdsale contract.\n', '        // We transfer the ownership so the owner of the crowdsale is also the owner of the token.\n', '        token.transferOwnership(owner);\n', '    }\n', '}\n', '\n', '\n', '//File: src/contracts/ico/Reservation.sol\n', '/**\n', ' * @title Reservation\n', ' *\n', ' * @version 1.0\n', ' * @author Validity Labs AG <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a9c0c7cfc6e9dfc8c5c0cdc0ddd0c5c8cbda87c6dbce">[email&#160;protected]</a>>\n', ' */\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', 'contract Reservation is CrowdsaleBase {\n', '\n', '    /*** CONSTANTS ***/\n', '    uint256 public constant START_TIME = 1525683600;                     // 7 May 2018 09:00:00 GMT\n', '    uint256 public constant END_TIME = 1525856400;                       // 9 May 2018 09:00:00 GMT\n', '    uint256 public constant RESERVATION_CAP = 7.5e6 * 1e18;\n', '    uint256 public constant BONUS = 110;                                 // 10% bonus\n', '\n', '    UacCrowdsale public crowdsale;\n', '\n', '    /**\n', '     * @dev Constructor.\n', '     * @notice Unsold tokens should add up to the crowdsale hard cap.\n', '     * @param _wallet The address where funds should be transferred.\n', '     * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo.\n', '     * See https://github.com/eidoo/icoengine\n', '     */\n', '    function Reservation(\n', '        address _wallet,\n', '        address[] _kycSigners\n', '    )\n', '        public\n', '        CrowdsaleBase(START_TIME, END_TIME, RESERVATION_CAP, _wallet, _kycSigners)\n', '    {\n', '    }\n', '\n', '    function setCrowdsale(address _crowdsale) public {\n', '        require(crowdsale == address(0));\n', '        crowdsale = UacCrowdsale(_crowdsale);\n', '    }\n', '\n', '    /**\n', '     * @dev Implements the price function from EidooEngineInterface.\n', '     * @notice Calculates the price as tokens/ether based on the corresponding bonus.\n', '     * @return Price as tokens/ether.\n', '     */\n', '    function price() public view returns (uint256) {\n', '        return tokenPerEth.mul(BONUS).div(1e2);\n', '    }\n', '\n', '    /**\n', '     * @dev Fires the mintReservationTokens function on the crowdsale contract to mint the tokens being sold during the reservation phase.\n', '     * This function is called by the releaseTokensTo function, as part of the KYCBase implementation.\n', '     * @param to The address that will receive the minted tokens.\n', '     * @param amount The amount of tokens to mint.\n', '     */\n', '    function mintTokens(address to, uint256 amount) private {\n', '        crowdsale.mintReservationTokens(to, amount);\n', '    }\n', '}']