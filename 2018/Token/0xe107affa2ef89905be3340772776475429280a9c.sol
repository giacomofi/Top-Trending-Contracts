['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '      if (msg.data.length < size + 4) {\n', '      revert();\n', '      }\n', '      _;\n', '  }\n', '\n', '\n', '  function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '    \n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /*\n', '  */\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', '*/\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /*\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\n', '    require(_to != address(0));\n', '    require(allowed[_from][msg.sender] >= _value);\n', '    require(balances[_from] >= _value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /*\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /*\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  \n', '  /*\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /*\n', '   */\n', '  function Ownable() internal {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /*\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /*\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' */\n', 'contract Pausable is Ownable  {\n', '    event Pause();\n', '    event Unpause();\n', '    event Freeze ();\n', '    event LogFreeze();\n', '\n', '    bool public paused = false;\n', '\n', '    address public founder;\n', '    \n', '    /*\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused || msg.sender == founder);\n', '        _;\n', '    }\n', '\n', '    /*\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /*\n', '    */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '    \n', '\n', '    /*\n', '    */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(address _to, uint256 _value) public whenNotPaused onlyPayloadSize(2 * 32) returns (bool) {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused onlyPayloadSize(3 * 32) returns (bool) {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  //The functions below surve no real purpose. Even if one were to approve another to spend\n', '  //tokens on their behalf, those tokens will still only be transferable when the token contract\n', '  //is not paused.\n', '\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', 'contract MintableToken is PausableToken {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    emit Mint(_to, _amount);\n', '    emit Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  function finishMinting() public onlyOwner canMint returns (bool) {\n', '    mintingFinished = true;\n', '    emit MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract TokenBank is MintableToken {\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  event TokensBurned(address initiatior, address indexed _partner, uint256 _tokens);\n', ' \n', '\n', '  /*\n', '   */\n', '    function TokenBank() public {\n', '        name = "Token Bank";\n', '        symbol = "TKB";\n', '        decimals = 8;\n', '        totalSupply = 1000000000e8;\n', '        founder = 0xd606c83Bc9C740cBf39a42eB4c338828e90F451a;\n', '        balances[founder] = totalSupply;\n', '        emit Transfer(0x0, founder, totalSupply);\n', '        pause();\n', '    }\n', '\n', '    modifier onlyFounder {\n', '      require(msg.sender == founder);\n', '      _;\n', '    }\n', '\n', '    event NewFounderAddress(address indexed from, address indexed to);\n', '\n', '    function changeFounderAddress(address _newFounder) public onlyFounder {\n', '        require(_newFounder != 0x0);\n', '        emit NewFounderAddress(founder, _newFounder);\n', '        founder = _newFounder;\n', '    }\n', '\n', '    /*\n', '    */\n', '    function burnTokens(address _partner, uint256 _tokens) public onlyFounder {\n', '        require(balances[_partner] >= _tokens);\n', '        balances[_partner] = balances[_partner].sub(_tokens);\n', '        totalSupply = totalSupply.sub(_tokens);\n', '        emit TokensBurned(msg.sender, _partner, _tokens);\n', '    }\n', '}\n', '\n', '\n', 'contract TokenBankICO is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    TokenBank public token;\n', '\n', '    uint256 public TokenBankFirstStage;\n', '    uint256 public TokenBankSecondStage;\n', '    uint256 public TokenBankThirdStage;\n', '    uint256 public TokenBankFourthStage;\n', '\tuint256 public TokenBankFifthStage;\n', '    uint256 public TokenBankForSale;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    address public wallet;\n', '    uint256 public rate;\n', '    uint256 public weiRaised;\n', '    bool public ICOpaused;\n', '\n', '    uint256[4] public TokenBankBonusStage;\n', '\n', '    uint256 public TokenBankSold;\n', '\n', '    /*\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event ICOSaleExtended(uint256 newEndTime);\n', '\n', '    function ICO() public {\n', '        token = new TokenBank();  \n', '        startTime = 1525478400; \n', '        rate = 400000;\n', '        wallet = 0xd606c83Bc9C740cBf39a42eB4c338828e90F451a;\n', '        TokenBankForSale = 500000000e8;\n', '        TokenBankSold = 0;\n', '\n', '        TokenBankFirstStage = 100000000e8;\n', '        TokenBankSecondStage = 200000000e8;  \n', '        TokenBankThirdStage = 300000000e8;  \n', '        TokenBankFourthStage = 400000000e8;\n', '\t\tTokenBankFifthStage = 500000000e8;\t\t\n', '    \n', '        TokenBankBonusStage[0] = now.add(5 days);\n', '        for (uint y = 1; y < TokenBankBonusStage.length; y++) {\n', '            TokenBankBonusStage[y] = TokenBankBonusStage[y - 1].add(5 days);\n', '        }\n', '        \n', '        endTime = TokenBankBonusStage[3];\n', '        \n', '        ICOpaused = false;\n', '    }\n', '    \n', '    modifier whenNotPaused {\n', '        require(!ICOpaused);\n', '        _;\n', '    }\n', '\n', '    function() external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _addr) public payable whenNotPaused {\n', '        require(validPurchase() && TokenBankSold < TokenBankForSale);\n', '        require(_addr != 0x0 && msg.value >= 100 finney);  \n', '        uint256 toMint;\n', '        toMint = msg.value.mul(getRateWithBonus());\n', '        TokenBankSold = TokenBankSold.add(toMint);\n', '        token.mint(_addr, toMint);\n', '        forwardFunds();\n', '    }\n', '\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function processOfflinePurchase(address _to, uint256 _toMint) public onlyOwner {\n', '        require(TokenBankSold.add(_toMint) <= TokenBankForSale);\n', '        require(_toMint > 0 && _to != 0x0);\n', '        TokenBankSold = TokenBankSold.add(_toMint);\n', '        token.mint(_to, _toMint);\n', '    }\n', '    \n', '    \n', '    /*\n', '     */\n', '    function airDrop(address[] _addrs, uint256[] _values) public onlyOwner {\n', '        //require(_addrs.length > 0);\n', '        for (uint i = 0; i < _addrs.length; i++) {\n', '            if (_addrs[i] != 0x0 && _values[i] > 0) {\n', '                token.mint(_addrs[i], _values[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    function validPurchase() internal view returns (bool) {\n', '        bool withinPeriod = now >= startTime && now <= endTime; \n', '        bool nonZeroPurchase = msg.value != 0; \n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    \n', '    function finishMinting() public onlyOwner {\n', '        token.finishMinting();\n', '    }\n', '    \n', '    function getRateWithBonus() internal view returns (uint256 rateWithDiscount) {\n', '        if (TokenBankSold < TokenBankForSale) {\n', '            return rate.mul(getCurrentBonus()).div(100).add(rate);\n', '            return rateWithDiscount;\n', '        }\n', '        return rate;\n', '    }\n', '\n', '    /*\n', '    */\n', '    function getCurrentBonus() internal view returns (uint256 discount) {\n', '        require(TokenBankSold < TokenBankFifthStage);\n', '        uint256 timeStamp = now;\n', '        uint256 stage;\n', '\n', '        for (uint i = 0; i < TokenBankBonusStage.length; i++) {\n', '            if (timeStamp <= TokenBankBonusStage[i]) {\n', '                stage = i + 1;\n', '                break;\n', '            } \n', '        } \n', '\n', '        if(stage == 1 && TokenBankSold < TokenBankFirstStage) { discount = 20; }\n', '        if(stage == 1 && TokenBankSold >= TokenBankSecondStage) { discount = 15; }\n', '        if(stage == 1 && TokenBankSold >= TokenBankThirdStage) { discount = 10; }\n', '        if(stage == 1 && TokenBankSold >= TokenBankFourthStage) { discount = 5; }\n', '\t\tif(stage == 1 && TokenBankSold >= TokenBankFifthStage) { discount = 0; }\n', '\t\t\n', '        if(stage == 2 && TokenBankSold < TokenBankSecondStage) { discount = 15; }\n', '        if(stage == 2 && TokenBankSold >= TokenBankThirdStage) { discount = 10; }\n', '        if(stage == 2 && TokenBankSold >= TokenBankFourthStage) { discount = 5; }\n', '\t\tif(stage == 2 && TokenBankSold >= TokenBankFifthStage) { discount = 0; }\n', '\n', '        if(stage == 3 && TokenBankSold < TokenBankThirdStage) { discount = 10; }\n', '        if(stage == 3 && TokenBankSold >= TokenBankFourthStage) { discount = 5; }\n', '\t\tif(stage == 3 && TokenBankSold >= TokenBankFifthStage) { discount = 0; }\n', '\t\t\n', '\t\tif(stage == 4 && TokenBankSold < TokenBankFourthStage) { discount = 5; }\n', '        if(stage == 4 && TokenBankSold >= TokenBankFifthStage) { discount = 0; }\n', '\n', '        if(stage == 5) { discount = 0; }\n', '\n', '        return discount;\n', '    }\n', '\n', '\n', '\n', '    function extendDuration(uint256 _newEndTime) public onlyOwner {\n', '        require(endTime < _newEndTime);\n', '        endTime = _newEndTime;\n', '        emit ICOSaleExtended(_newEndTime);\n', '    }\n', '\n', '\n', '    function hasEnded() public view returns (bool) { \n', '        return now > endTime;\n', '    }\n', '\n', '    /**\n', '    * Allows the owner of the ICO contract to unpause the token contract. This function is needed\n', '    * because the ICO contract deploys a new instance of the token contract, and by default the \n', '    * ETH address which deploys a contract which is Ownable is assigned ownership of the contract,\n', '    * so the ICO contract is the owner of the token contract. Since unpause is a function which can\n', '    * only be executed by the owner, by adding this function here, then the owner of the ICO contract\n', '    * can call this and then the ICO contract will invoke the unpause function of the token contract\n', '    * and thus the token contract will successfully unpause as its owner the ICO contract invokend\n', '    * the the function. \n', '    */\n', '    function unpauseToken() public onlyOwner {\n', '        token.unpause();\n', '    }\n', '    \n', '    function pauseUnpauseICO() public onlyOwner {\n', '        if (ICOpaused) {\n', '            ICOpaused = false;\n', '        } else {\n', '            ICOpaused = true;\n', '        }\n', '    }\n', '}']