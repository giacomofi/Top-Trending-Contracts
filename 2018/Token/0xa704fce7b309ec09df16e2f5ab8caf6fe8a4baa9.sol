['pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;AGRI&#39; - AgriChain Utility Token Contract\n', '//\n', '// Symbol           : AGRI\n', '// Name             : AgriChain Utility Token\n', '// Max Total supply : 1,000,000,000.000000000000000000 (1 billion)\n', '// Decimals         : 18\n', '//\n', '// Company          : AgriChain Pty Ltd (trading as BlockGrain)\n', '//                  : https://agrichain.com\n', '// Version          : 2.1 \n', '// Author           : Martin Halford <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d7e69725d7c7a6f747e757c7473337e7270">[email&#160;protected]</a>>\n', '// Published        : 15 Aug 2018\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe Maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    \n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b, "Muliply overflow error.");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0, "Divide by zero error."); \n', '        uint256 c = _a / _b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a, "Subtraction overflow error.");\n', '        uint256 c = _a - _b;\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a, "Addition overflow error.");\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "Mod overflow error");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Not contract owner.");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner, "Not new contract owner.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Agri Token\n', '// ----------------------------------------------------------------------------\n', 'contract AgriChainToken is ERC20Interface, Owned {\n', '    \n', '    using SafeMath for uint;\n', '\n', '    uint256 constant public MAX_SUPPLY = 1000000000000000000000000000; // 1 billion Agri \n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint256 _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // Flag to allow or disallow transfers\n', '    bool public isAllowingTransfers;\n', '\n', '    // List of admins who can mint, burn and allow transfers of tokens\n', '    mapping (address => bool) public administrators;\n', '\n', '    // modifier to check if transfers being allowed\n', '    modifier allowingTransfers() {\n', '        require(isAllowingTransfers, "Contract currently not allowing transfers.");\n', '        _;\n', '    }\n', '\n', '    // modifier to check admin status\n', '    modifier onlyAdmin() {\n', '        require(administrators[msg.sender], "Not contract administrator.");\n', '        _;\n', '    }\n', '\n', '    // This notifies clients about the amount burnt, only admins can burn tokens\n', '    event Burn(address indexed burner, uint256 value); \n', '\n', '    // This notifies clients about the transfers being allowed or disallowed\n', '    event AllowTransfers ();\n', '    event DisallowTransfers ();\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor(uint initialTokenSupply) public {\n', '        symbol = "AGRI";\n', '        name = "AgriChain Utility Token";\n', '        decimals = 18;\n', '        _totalSupply = initialTokenSupply * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from token owner&#39;s account to `to` account\n', '    // - Owner&#39;s account must have sufficient balance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public allowingTransfers returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public allowingTransfers returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account. The `spender` contract function\n', '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Don&#39;t accept ETH\n', '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert("Contract does not accept ETH.");\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyAdmin returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can mint additional tokens \n', '    // Do ** NOT ** let totalSupply exceed MAX_SUPPLY\n', '    // ------------------------------------------------------------------------\n', '    function mintTokens(uint256 _value) public onlyAdmin {\n', '        require(_totalSupply.add(_value) <= MAX_SUPPLY, "Cannot mint greater than maximum supply.");\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        _totalSupply = _totalSupply.add(_value);\n', '        emit Transfer(0, msg.sender, _value);      \n', '    }    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can burn tokens\n', '    // ------------------------------------------------------------------------\n', '    function burn(uint256 _value) public onlyAdmin {\n', '        require(_value <= balances[msg.sender], "Burn value exceeds balance.");\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(burner, _value);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can allow transfer of tokens\n', '    // ------------------------------------------------------------------------\n', '    function allowTransfers() public onlyAdmin {\n', '        isAllowingTransfers = true;\n', '        emit AllowTransfers();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can disallow transfer of tokens\n', '    // ------------------------------------------------------------------------\n', '    function disallowTransfers() public onlyAdmin {\n', '        isAllowingTransfers = false;\n', '        emit DisallowTransfers();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can add administrators of tokens\n', '    // ------------------------------------------------------------------------\n', '    function addAdministrator(address _admin) public onlyOwner {\n', '        administrators[_admin] = true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can remove administrators of tokens\n', '    // ------------------------------------------------------------------------\n', '    function removeAdministrator(address _admin) public onlyOwner {\n', '        administrators[_admin] = false;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'AGRI' - AgriChain Utility Token Contract\n", '//\n', '// Symbol           : AGRI\n', '// Name             : AgriChain Utility Token\n', '// Max Total supply : 1,000,000,000.000000000000000000 (1 billion)\n', '// Decimals         : 18\n', '//\n', '// Company          : AgriChain Pty Ltd (trading as BlockGrain)\n', '//                  : https://agrichain.com\n', '// Version          : 2.1 \n', '// Author           : Martin Halford <cto@agrichain.com>\n', '// Published        : 15 Aug 2018\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe Maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    \n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b, "Muliply overflow error.");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0, "Divide by zero error."); \n', '        uint256 c = _a / _b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a, "Subtraction overflow error.");\n', '        uint256 c = _a - _b;\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a, "Addition overflow error.");\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "Mod overflow error");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Not contract owner.");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner, "Not new contract owner.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Agri Token\n', '// ----------------------------------------------------------------------------\n', 'contract AgriChainToken is ERC20Interface, Owned {\n', '    \n', '    using SafeMath for uint;\n', '\n', '    uint256 constant public MAX_SUPPLY = 1000000000000000000000000000; // 1 billion Agri \n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint256 _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // Flag to allow or disallow transfers\n', '    bool public isAllowingTransfers;\n', '\n', '    // List of admins who can mint, burn and allow transfers of tokens\n', '    mapping (address => bool) public administrators;\n', '\n', '    // modifier to check if transfers being allowed\n', '    modifier allowingTransfers() {\n', '        require(isAllowingTransfers, "Contract currently not allowing transfers.");\n', '        _;\n', '    }\n', '\n', '    // modifier to check admin status\n', '    modifier onlyAdmin() {\n', '        require(administrators[msg.sender], "Not contract administrator.");\n', '        _;\n', '    }\n', '\n', '    // This notifies clients about the amount burnt, only admins can burn tokens\n', '    event Burn(address indexed burner, uint256 value); \n', '\n', '    // This notifies clients about the transfers being allowed or disallowed\n', '    event AllowTransfers ();\n', '    event DisallowTransfers ();\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor(uint initialTokenSupply) public {\n', '        symbol = "AGRI";\n', '        name = "AgriChain Utility Token";\n', '        decimals = 18;\n', '        _totalSupply = initialTokenSupply * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public allowingTransfers returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public allowingTransfers returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert("Contract does not accept ETH.");\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyAdmin returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can mint additional tokens \n', '    // Do ** NOT ** let totalSupply exceed MAX_SUPPLY\n', '    // ------------------------------------------------------------------------\n', '    function mintTokens(uint256 _value) public onlyAdmin {\n', '        require(_totalSupply.add(_value) <= MAX_SUPPLY, "Cannot mint greater than maximum supply.");\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        _totalSupply = _totalSupply.add(_value);\n', '        emit Transfer(0, msg.sender, _value);      \n', '    }    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can burn tokens\n', '    // ------------------------------------------------------------------------\n', '    function burn(uint256 _value) public onlyAdmin {\n', '        require(_value <= balances[msg.sender], "Burn value exceeds balance.");\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(burner, _value);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can allow transfer of tokens\n', '    // ------------------------------------------------------------------------\n', '    function allowTransfers() public onlyAdmin {\n', '        isAllowingTransfers = true;\n', '        emit AllowTransfers();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Administrator can disallow transfer of tokens\n', '    // ------------------------------------------------------------------------\n', '    function disallowTransfers() public onlyAdmin {\n', '        isAllowingTransfers = false;\n', '        emit DisallowTransfers();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can add administrators of tokens\n', '    // ------------------------------------------------------------------------\n', '    function addAdministrator(address _admin) public onlyOwner {\n', '        administrators[_admin] = true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can remove administrators of tokens\n', '    // ------------------------------------------------------------------------\n', '    function removeAdministrator(address _admin) public onlyOwner {\n', '        administrators[_admin] = false;\n', '    }\n', '}']
