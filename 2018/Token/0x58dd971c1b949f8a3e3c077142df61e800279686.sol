['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '        require(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c>=a && c>=b);\n', '        return c;\n', '    }\n', '  }\n', '\n', 'contract BitgetToken is SafeMath{   \n', '    address public owner;\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '     /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public freezeOf;\n', '\n', '    //events\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* This notifies clients about the amount burnt */\n', '    event Burn(address indexed from, uint256 value);\n', '\t\n', '\t/* This notifies clients about the amount frozen */\n', '    event Freeze(address indexed from, uint256 value);\n', '\t\n', '\t/* This notifies clients about the amount unfrozen */\n', '    event Unfreeze(address indexed from, uint256 value);\n', '\n', '    constructor(\n', '        uint256 initSupply, \n', '        string tokenName, \n', '        string tokenSymbol, \n', '        uint8 decimalUnits) public {\n', '        owner = msg.sender;\n', '        totalSupply = initSupply;\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        decimals = decimalUnits;  \n', '        balanceOf[msg.sender] = totalSupply;\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '\n', '    // public functions\n', '    /// @return total amount of tokens\n', '    function totalSupply() public view returns (uint256){\n', '        return totalSupply;\n', '    }\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balanceOf[_owner];\n', '    }\n', '    \n', '    /// @param _owner The address from which the freeze amount will be retrieved\n', '    /// @return The freeze amount\n', '    function freezeOf(address _owner) public view returns (uint256) {\n', '        return freezeOf[_owner];\n', '    }\n', '\n', '    /* Send coins */\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(_to != 0x0);                                // Prevent transfer to 0x0 address.\n', '        require(_value > 0);                                // Check send amount is greater than 0.\n', '        require(balanceOf[msg.sender] >= _value);           // Check balance of the sender is enough\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);  // Check for overflow\n', '        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], _value);// Subtract _value amount from the sender\n', '        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);// Add the same amount to the recipient\n', '        emit Transfer(msg.sender, _to, _value);// Notify anyone listening that this transfer took place\n', '    }\n', '\n', '    /* Burn coins */\n', '    /// @notice burn `_value` token of owner\n', '    /// @param _value The amount of token to be burned\n', '    function burn(uint256 _value) public {\n', '        require(owner == msg.sender);                //Check owner\n', '        require(balanceOf[msg.sender] >= _value);    // Check if the sender has enough\n', '        require(_value > 0);                         //Check _value is valid\n', '        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], _value);    // Subtract from the owner\n', '        totalSupply = SafeMath.sub(totalSupply,_value);                         // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '    }\n', '\t\n', "    /// @notice freeze `_value` token of '_addr' address\n", '    /// @param _addr The address to be freezed\n', '    /// @param _value The amount of token to be freezed\n', '\tfunction freeze(address _addr, uint256 _value) public {\n', '        require(owner == msg.sender);                //Check owner\n', '        require(balanceOf[_addr] >= _value);         // Check if the sender has enough\n', '\t\trequire(_value > 0);                         //Check _value is valid\n', '        balanceOf[_addr] = SafeMath.sub(balanceOf[_addr], _value);              // Subtract _value amount from balance of _addr address\n', '        freezeOf[_addr] = SafeMath.add(freezeOf[_addr], _value);                // Add the same amount to freeze of _addr address\n', '        emit Freeze(_addr, _value);\n', '    }\n', '\t\n', "    /// @notice unfreeze `_value` token of '_addr' address\n", '    /// @param _addr The address to be unfreezed\n', '    /// @param _value The amount of token to be unfreezed\n', '\tfunction unfreeze(address _addr, uint256 _value) public {\n', '        require(owner == msg.sender);                //Check owner\n', '        require(freezeOf[_addr] >= _value);          // Check if the sender has enough\n', '\t\trequire(_value > 0);                         //Check _value is valid\n', '        freezeOf[_addr] = SafeMath.sub(freezeOf[_addr], _value);                // Subtract _value amount from freeze of _addr address\n', '\t\tbalanceOf[_addr] = SafeMath.add(balanceOf[_addr], _value);              // Add the same amount to balance of _addr address\n', '        emit Unfreeze(_addr, _value);\n', '    }\n', '\n', '    // transfer balance to owner\n', '\tfunction withdrawEther(uint256 amount) public {\n', '\t\trequire(owner == msg.sender);\n', '\t\towner.transfer(amount);\n', '\t}\n', '\t\n', '\t// can accept ether\n', '\tfunction() payable public {\n', '    }\n', '}']