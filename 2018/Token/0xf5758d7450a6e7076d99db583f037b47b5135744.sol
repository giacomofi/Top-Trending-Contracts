['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/IPFSEvents.sol\n', '\n', 'contract IPFSEvents {\n', '    event HashAdded(string hash, uint ttl);\n', '    event HashRemoved(string hash);\n', '\n', '    event MetadataObjectAdded(string hash);\n', '    event MetadataObjectRemoved(string hash);    \n', '}\n', '\n', '// File: contracts/Multimember.sol\n', '\n', 'contract Multimember {\n', '\n', '    // TYPES\n', '\n', '    // struct for the status of a pending operation.\n', '    struct PendingState {\n', '        uint yetNeeded;\n', '        uint membersDone;\n', '        uint index;\n', '    }\n', '\n', '    // EVENTS\n', '\n', '    // this contract only has seven types of events: it can accept a confirmation, in which case\n', '    // we record member and operation (hash) alongside it.\n', '    event Confirmation(address member, bytes32 operation);\n', '    event Revoke(address member, bytes32 operation);\n', '    // some others are in the case of an member changing.\n', '    event MemberChanged(address oldMember, address newMember);\n', '    event MemberAdded(address newMember);\n', '    event MemberRemoved(address oldMember);\n', '    // the last one is emitted if the required signatures change\n', '    event RequirementChanged(uint newRequirement);\n', '\n', '    // MODIFIERS\n', '\n', '    // simple single-sig function modifier.\n', '    modifier onlymember {\n', '        if (isMember(msg.sender))\n', '            _;\n', '    }\n', '    // multi-sig function modifier: the operation must have an intrinsic hash in order\n', '    // that later attempts can be realised as the same underlying operation and\n', '    // thus count as confirmations.\n', '    modifier onlymanymembers(bytes32 _operation) {\n', '        if (confirmAndCheck(_operation))\n', '            _;\n', '    }\n', '\n', '    // METHODS\n', '\n', '    // constructor is given number of sigs required to do protected "onlymanymembers" transactions\n', '    // as well as the selection of addresses capable of confirming them.\n', '    function Multimember(address[] _members, uint _required) public {\n', '        m_numMembers = _members.length + 1;\n', '        m_members[1] = uint(msg.sender);\n', '        m_memberIndex[uint(msg.sender)] = 1;\n', '        for (uint i = 0; i < _members.length; ++i) {\n', '            m_members[2 + i] = uint(_members[i]);\n', '            m_memberIndex[uint(_members[i])] = 2 + i;\n', '        }\n', '        m_required = _required;\n', '    }\n', '    \n', '    // Revokes a prior confirmation of the given operation\n', '    function revoke(bytes32 _operation) external {\n', '        uint memberIndex = m_memberIndex[uint(msg.sender)];\n', '        // make sure they&#39;re an member\n', '        if (memberIndex == 0) \n', '            return;\n', '        uint memberIndexBit = 2**memberIndex;\n', '        var pending = m_pending[_operation];\n', '        if (pending.membersDone & memberIndexBit > 0) {\n', '            pending.yetNeeded++;\n', '            pending.membersDone -= memberIndexBit;\n', '            Revoke(msg.sender, _operation);\n', '        }\n', '    }\n', '    \n', '    // Replaces an member `_from` with another `_to`.\n', '    function changeMember(address _from, address _to) onlymanymembers(keccak256(_from,_to)) external {\n', '        if (isMember(_to)) \n', '            return;\n', '        uint memberIndex = m_memberIndex[uint(_from)];\n', '        if (memberIndex == 0) \n', '            return;\n', '\n', '        clearPending();\n', '        m_members[memberIndex] = uint(_to);\n', '        m_memberIndex[uint(_from)] = 0;\n', '        m_memberIndex[uint(_to)] = memberIndex;\n', '        MemberChanged(_from, _to);\n', '    }\n', '    \n', '    function addMember(address _member) onlymanymembers(keccak256(_member)) public {\n', '        if (isMember(_member)) \n', '            return;\n', '\n', '        clearPending();\n', '        if (m_numMembers >= MAXMEMBERS)\n', '            reorganizeMembers();\n', '        if (m_numMembers >= MAXMEMBERS)\n', '            return;\n', '        m_numMembers++;\n', '        m_members[m_numMembers] = uint(_member);\n', '        m_memberIndex[uint(_member)] = m_numMembers;\n', '        MemberAdded(_member);\n', '    }\n', '    \n', '    function removeMember(address _member) onlymanymembers(keccak256(_member)) public {\n', '        uint memberIndex = m_memberIndex[uint(_member)];\n', '        if (memberIndex == 0) \n', '            return;\n', '        if (m_required > m_numMembers - 1) \n', '            return;\n', '\n', '        m_members[memberIndex] = 0;\n', '        m_memberIndex[uint(_member)] = 0;\n', '        clearPending();\n', '        reorganizeMembers(); //make sure m_numMembers is equal to the number of members and always points to the optimal free slot\n', '        MemberRemoved(_member);\n', '    }\n', '    \n', '    function changeRequirement(uint _newRequired) onlymanymembers(keccak256(_newRequired)) external {\n', '        if (_newRequired > m_numMembers) \n', '            return;\n', '        m_required = _newRequired;\n', '        clearPending();\n', '        RequirementChanged(_newRequired);\n', '    }\n', '    \n', '    function isMember(address _addr) public constant returns (bool) { \n', '        return m_memberIndex[uint(_addr)] > 0;\n', '    }\n', '    \n', '    function hasConfirmed(bytes32 _operation, address _member) external constant returns (bool) {\n', '        var pending = m_pending[_operation];\n', '        uint memberIndex = m_memberIndex[uint(_member)];\n', '\n', '        // make sure they&#39;re an member\n', '        if (memberIndex == 0) \n', '            return false;\n', '\n', '        // determine the bit to set for this member.\n', '        uint memberIndexBit = 2**memberIndex;\n', '        return !(pending.membersDone & memberIndexBit == 0);\n', '    }\n', '    \n', '    // INTERNAL METHODS\n', '\n', '    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n', '        // determine what index the present sender is:\n', '        uint memberIndex = m_memberIndex[uint(msg.sender)];\n', '        // make sure they&#39;re an member\n', '        if (memberIndex == 0) \n', '            return;\n', '\n', '        var pending = m_pending[_operation];\n', '        // if we&#39;re not yet working on this operation, switch over and reset the confirmation status.\n', '        if (pending.yetNeeded == 0) {\n', '            // reset count of confirmations needed.\n', '            pending.yetNeeded = m_required;\n', '            // reset which members have confirmed (none) - set our bitmap to 0.\n', '            pending.membersDone = 0;\n', '            pending.index = m_pendingIndex.length++;\n', '            m_pendingIndex[pending.index] = _operation;\n', '        }\n', '        // determine the bit to set for this member.\n', '        uint memberIndexBit = 2**memberIndex;\n', '        // make sure we (the message sender) haven&#39;t confirmed this operation previously.\n', '        if (pending.membersDone & memberIndexBit == 0) {\n', '            Confirmation(msg.sender, _operation);\n', '            // ok - check if count is enough to go ahead.\n', '            if (pending.yetNeeded <= 1) {\n', '                // enough confirmations: reset and run interior.\n', '                delete m_pendingIndex[m_pending[_operation].index];\n', '                delete m_pending[_operation];\n', '                return true;\n', '            } else {\n', '                // not enough: record that this member in particular confirmed.\n', '                pending.yetNeeded--;\n', '                pending.membersDone |= memberIndexBit;\n', '            }\n', '        }\n', '    }\n', '\n', '    function reorganizeMembers() private returns (bool) {\n', '        uint free = 1;\n', '        while (free < m_numMembers) {\n', '            while (free < m_numMembers && m_members[free] != 0) {\n', '                free++;\n', '            } \n', '\n', '            while (m_numMembers > 1 && m_members[m_numMembers] == 0) {\n', '                m_numMembers--;\n', '            } \n', '\n', '            if (free < m_numMembers && m_members[m_numMembers] != 0 && m_members[free] == 0) {\n', '                m_members[free] = m_members[m_numMembers];\n', '                m_memberIndex[m_members[free]] = free;\n', '                m_members[m_numMembers] = 0;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function clearPending() internal {\n', '        uint length = m_pendingIndex.length;\n', '        for (uint i = 0; i < length; ++i) {\n', '            if (m_pendingIndex[i] != 0) {\n', '                delete m_pending[m_pendingIndex[i]];\n', '            }\n', '        }\n', '        delete m_pendingIndex;\n', '    }\n', '        \n', '    // FIELDS\n', '\n', '    // the number of members that must confirm the same operation before it is run.\n', '    uint public m_required;\n', '    // pointer used to find a free slot in m_members\n', '    uint public m_numMembers;\n', '    \n', '    // list of members\n', '    uint[256] m_members;\n', '    uint constant MAXMEMBERS = 250;\n', '    // index on the list of members to allow reverse lookup\n', '    mapping(uint => uint) m_memberIndex;\n', '    // the ongoing operations.\n', '    mapping(bytes32 => PendingState) m_pending;\n', '    bytes32[] m_pendingIndex;\n', '}\n', '\n', '// File: contracts/IPFSProxy.sol\n', '\n', 'contract IPFSProxy is IPFSEvents, Multimember {\n', '    uint public persistLimit;\n', '\n', '    event PersistLimitChanged(uint limit);\t\n', '    event ContractAdded(address pubKey,uint startBlock);\n', '    event ContractRemoved(address pubKey);\n', '\n', '    /**\n', '    * @dev Constructor - adds the owner of the contract to the list of valid members\n', '    */\n', '    function IPFSProxy(address[] _members,uint _required, uint _persistlimit) Multimember (_members, _required) public {\n', '        setTotalPersistLimit(_persistlimit);\n', '        for (uint i = 0; i < _members.length; ++i) {\n', '            MemberAdded(_members[i]);\n', '        }\n', '        addContract(this,block.number);\n', '    }\n', '\n', '    /**\n', '    * @dev Add hash to persistent storage\n', '    * @param _ipfsHash The ipfs hash to propagate.\n', '    * @param _ttl amount of time is seconds to persist this. 0 = infinite\n', '    */\n', '    function addHash(string _ipfsHash, uint _ttl) public onlymember {\n', '        HashAdded(_ipfsHash,_ttl);\n', '    }\n', '\n', '    /**\n', '    * @dev Remove hash from persistent storage\n', '    * @param _ipfsHash The ipfs hash to propagate.\t\n', '    */\n', '    function removeHash(string _ipfsHash) public onlymember {\n', '        HashRemoved(_ipfsHash);\n', '    }\n', '\n', '   /** \n', '    * Add a contract to watch list. Each proxy will then \n', '    * watch it for HashAdded and HashRemoved events \n', '    * and cache these events\n', '    * @param _contractAddress The contract address.\n', '    * @param _startBlock The startblock where to look for events.\n', '    */\n', '    function addContract(address _contractAddress,uint _startBlock) public onlymember {\n', '        ContractAdded(_contractAddress,_startBlock);\n', '    }\n', '\n', '    /**\n', '    * @dev Remove contract from watch list\n', '    */\n', '    function removeContract(address _contractAddress) public onlymember {\n', '        require(_contractAddress != address(this));\n', '        ContractRemoved(_contractAddress);\n', '    }\n', '\n', '   /** \n', '    * Add a metadata of an object. Each proxy will then \n', '    * read the ipfs hash file with the metadata about the object and parse it \n', '    */\n', '    function addMetadataObject(string _metadataHash) public onlymember {\n', '        HashAdded(_metadataHash,0);\n', '        MetadataObjectAdded(_metadataHash);\n', '    }\n', '\n', '    /** \n', '    * removed a metadata of an object.\n', '    */\n', '    function removeMetadataObject(string _metadataHash) public onlymember {\n', '        HashRemoved(_metadataHash);\n', '        MetadataObjectRemoved(_metadataHash);\n', '    }\n', '\n', '    /**\n', '    * @dev set total allowed upload\n', '    *\n', '    **/\n', '    function setTotalPersistLimit (uint _limit) public onlymanymembers(keccak256(_limit)) {\n', '        persistLimit = _limit;\n', '        PersistLimitChanged(_limit);\n', '    }\n', '}']