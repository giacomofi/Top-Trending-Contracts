['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' * Government Token (GOVT) ERC20\n', ' *\n', ' * See https://thegovernment.network/\n', ' */\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract GovToken {\n', '    using SafeMath for uint;\n', '\n', '    string  public name = "GovToken";\n', '    string  public symbol = "GOVT";\n', '    string  public standard = "GovToken v1.0";\n', '    uint256 public totalSupply = 125000000 ether; // 125,000,000 GOVT\n', '    uint    public decimals = 18;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    // Events\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _value\n', '    );\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _value\n', '    );\n', '\n', '    // Fix for the ERC20 short address attack.\n', '    modifier onlyPayloadSize(uint size) {\n', '        if(msg.data.length < size + 4) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '    constructor() public {\n', '        balances[msg.sender] = totalSupply;\n', '        emit Transfer(0x00, msg.sender, totalSupply);\n', '    }\n', '\n', '    // Transfer\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Check the balance\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Approve for another address\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Check approved allowance\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    // Transfer from approved funds\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool success) {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Default function - prevents accidental money loss by sending ether to the contract\n', '    function () payable public {\n', '        revert();\n', '    }\n', '\n', '}']