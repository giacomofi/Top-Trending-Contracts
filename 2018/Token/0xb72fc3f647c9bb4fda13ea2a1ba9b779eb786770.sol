['contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract tokenRecipientInterface {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract MintableTokenInterface {\n', '    function mint(address _to, uint256 _amount) public;\n', '}\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', 'contract MintingContractInterface {\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\n', '    function doTeamMinting(address _destination) public;\n', '    function setTokenContractAddress(address _newAddress) public;\n', '    function setCrowdsaleContractAddress(address _newAddress) public;\n', '    function killContract() public;\n', '}\n', 'contract Lockable is Owned {\n', '\n', '    uint256 public lockedUntilBlock;\n', '\n', '    event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '    modifier lockAffected {\n', '        require(block.number > lockedUntilBlock);\n', '        _;\n', '    }\n', '\n', '    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '        lockedUntilBlock = _untilBlock;\n', '        emit ContractLocked(_untilBlock, _reason);\n', '    }\n', '\n', '\n', '    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\n', '        lockedUntilBlock = _untilBlock;\n', '        emit ContractLocked(_untilBlock, _reason);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress;\n', '    address public tokenAddress = 0x0;\n', '    address public kycAddress = 0x0;\n', '    address public mintingContractAddress = 0x0;\n', '\n', '    uint public startPhaseLength = 720;\n', '    uint public startPhaseMinimumContribution = 0.1 * 10**18;\n', '    uint public startPhaseMaximumcontribution = 40 * 10**18;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint nextContributorIndex;\n', '    mapping(uint => address) contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokenTotalSupply = 300000000 * 10**18;\n', '    uint public tokensIssued = 0;\n', '    uint blocksInADay;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    uint nextContributorToClaim;\n', '    mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '    function() noReentrancy payable public {\n', '        require(msg.value != 0);\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\n', '\n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            return _eth * 8640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            return _eth * 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            return _eth * 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            return _eth * 8160;\n', '        } else {\n', '            return _eth * 8000;\n', '        }\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\n', '        uint tempTokenAmount;\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 1008640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8160;\n', '        } else {\n', '            tempTokenAmount = _token * 1000 / 8000;\n', '        }\n', '        return tempTokenAmount / 1000;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '\n', '        if (block.number < crowdsaleStartBlock + startPhaseLength && _amount > startPhaseMaximumcontribution) {\n', '            contributionAmount = startPhaseMaximumcontribution;\n', '            returnAmount = _amount - startPhaseMaximumcontribution;\n', '        } else {\n', '            contributionAmount = _amount;\n', '        }\n', '        tokensToGive = calculateEthToToken(contributionAmount, block.number);\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive, contributionAmount);\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(this.balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(this.balance);\n', '    }\n', '\n', '    function claimEthIfFailed() public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        require(contributorList[msg.sender].contributionAmount > 0);\n', '        require(!hasClaimedEthWhenFail[msg.sender]);\n', '\n', '        uint ethContributed = contributorList[msg.sender].contributionAmount;\n', '        hasClaimedEthWhenFail[msg.sender] = true;\n', '        if (!msg.sender.send(ethContributed)) {\n', '            emit ErrorSendingETH(msg.sender, ethContributed);\n', '        }\n', '    }\n', '\n', '    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\n', '            if (currentParticipantAddress == 0x0) {\n', '                return;\n', '            }\n', '            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\n', '                contribution = contributorList[currentParticipantAddress].contributionAmount;\n', '                hasClaimedEthWhenFail[currentParticipantAddress] = true;\n', '                if (!currentParticipantAddress.send(contribution)) {\n', '                    emit ErrorSendingETH(currentParticipantAddress, contribution);\n', '                }\n', '            }\n', '            nextContributorToClaim += 1;\n', '        }\n', '    }\n', '\n', '    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '        require(this.balance != 0);\n', '        require(block.number > crowdsaleEndedBlock);\n', '        require(contributorIndexes[nextContributorToClaim] == 0x0);\n', '        multisigAddress.transfer(this.balance);\n', '    }\n', '\n', '    function setMultisigAddress(address _newAddress) onlyOwner public {\n', '        multisigAddress = _newAddress;\n', '    }\n', '\n', '    function setToken(address _newAddress) onlyOwner public {\n', '        tokenAddress = _newAddress;\n', '    }\n', '\n', '    function setKycAddress(address _newAddress) onlyOwner public {\n', '        kycAddress = _newAddress;\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '}\n', '\n', 'contract ERC20Token is ERC20TokenInterface, SafeMath, Owned, Lockable {\n', '\n', '    string public standard;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    address public mintingContractAddress;\n', '\n', '    uint256 supply = 0;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '\n', '    event Mint(address indexed _to, uint256 _value);\n', '    event Burn(address indexed _from, uint _value);\n', '\n', '    function totalSupply() constant public returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) lockAffected public returns (bool success) {\n', '        require(_to != 0x0 && _to != address(this));\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) lockAffected public returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) lockAffected public returns (bool success) {\n', '        tokenRecipientInterface spender = tokenRecipientInterface(_spender);\n', '        approve(_spender, _value);\n', '        spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) lockAffected public returns (bool success) {\n', '        require(_to != 0x0 && _to != address(this));\n', '        balances[_from] = safeSub(balanceOf(_from), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) public {\n', '        require(msg.sender == mintingContractAddress);\n', '        supply = safeAdd(supply, _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(0x0, _to, _amount);\n', '    }\n', '\n', '    function burn(uint _amount) public {\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _amount);\n', '        supply = safeSub(supply, _amount);\n', '        emit Burn(msg.sender, _amount);\n', '        emit Transfer(msg.sender, 0x0, _amount);\n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', 'contract EligmaMintingContract is Owned{\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _tokensMinted, string _message);\n', '\n', '    function EligmaMintingContract() public {\n', '        tokenTotalSupply = 500000000 * 10 ** 18;\n', '    }\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount) public onlyOwner {\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\n', '        emit MintMade(_destination, _tokensAmount, "Presale mint");\n', '    }\n', '\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public {\n', '        require(msg.sender == crowdsaleContractAddress);\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\n', '        emit MintMade(_destination, _tokensAmount, "Crowdsale mint");\n', '    }\n', '\n', '    function doTeamMinting(address _destination) public onlyOwner {\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() < tokenTotalSupply);\n', '        uint amountToMint = tokenTotalSupply - ERC20TokenInterface(tokenContractAddress).totalSupply();\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, amountToMint);\n', '        emit MintMade(_destination, amountToMint, "Team mint");\n', '    }\n', '\n', '    function setTokenContractAddress(address _newAddress) public onlyOwner {\n', '        tokenContractAddress = _newAddress;\n', '    }\n', '\n', '    function setCrowdsaleContractAddress(address _newAddress) public onlyOwner {\n', '        crowdsaleContractAddress = _newAddress;\n', '    }\n', '\n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
['contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract tokenRecipientInterface {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract MintableTokenInterface {\n', '    function mint(address _to, uint256 _amount) public;\n', '}\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', 'contract MintingContractInterface {\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount, uint _ethAmount) public;\n', '    function doTeamMinting(address _destination) public;\n', '    function setTokenContractAddress(address _newAddress) public;\n', '    function setCrowdsaleContractAddress(address _newAddress) public;\n', '    function killContract() public;\n', '}\n', 'contract Lockable is Owned {\n', '\n', '    uint256 public lockedUntilBlock;\n', '\n', '    event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '    modifier lockAffected {\n', '        require(block.number > lockedUntilBlock);\n', '        _;\n', '    }\n', '\n', '    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '        lockedUntilBlock = _untilBlock;\n', '        emit ContractLocked(_untilBlock, _reason);\n', '    }\n', '\n', '\n', '    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\n', '        lockedUntilBlock = _untilBlock;\n', '        emit ContractLocked(_untilBlock, _reason);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress;\n', '    address public tokenAddress = 0x0;\n', '    address public kycAddress = 0x0;\n', '    address public mintingContractAddress = 0x0;\n', '\n', '    uint public startPhaseLength = 720;\n', '    uint public startPhaseMinimumContribution = 0.1 * 10**18;\n', '    uint public startPhaseMaximumcontribution = 40 * 10**18;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint nextContributorIndex;\n', '    mapping(uint => address) contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokenTotalSupply = 300000000 * 10**18;\n', '    uint public tokensIssued = 0;\n', '    uint blocksInADay;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    uint nextContributorToClaim;\n', '    mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '    function() noReentrancy payable public {\n', '        require(msg.value != 0);\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\n', '\n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            return _eth * 8640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            return _eth * 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            return _eth * 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            return _eth * 8160;\n', '        } else {\n', '            return _eth * 8000;\n', '        }\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\n', '        uint tempTokenAmount;\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 1008640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            tempTokenAmount = _token * 1000 / 8160;\n', '        } else {\n', '            tempTokenAmount = _token * 1000 / 8000;\n', '        }\n', '        return tempTokenAmount / 1000;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '\n', '        if (block.number < crowdsaleStartBlock + startPhaseLength && _amount > startPhaseMaximumcontribution) {\n', '            contributionAmount = startPhaseMaximumcontribution;\n', '            returnAmount = _amount - startPhaseMaximumcontribution;\n', '        } else {\n', '            contributionAmount = _amount;\n', '        }\n', '        tokensToGive = calculateEthToToken(contributionAmount, block.number);\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive, contributionAmount);\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(this.balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(this.balance);\n', '    }\n', '\n', '    function claimEthIfFailed() public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        require(contributorList[msg.sender].contributionAmount > 0);\n', '        require(!hasClaimedEthWhenFail[msg.sender]);\n', '\n', '        uint ethContributed = contributorList[msg.sender].contributionAmount;\n', '        hasClaimedEthWhenFail[msg.sender] = true;\n', '        if (!msg.sender.send(ethContributed)) {\n', '            emit ErrorSendingETH(msg.sender, ethContributed);\n', '        }\n', '    }\n', '\n', '    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\n', '            if (currentParticipantAddress == 0x0) {\n', '                return;\n', '            }\n', '            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\n', '                contribution = contributorList[currentParticipantAddress].contributionAmount;\n', '                hasClaimedEthWhenFail[currentParticipantAddress] = true;\n', '                if (!currentParticipantAddress.send(contribution)) {\n', '                    emit ErrorSendingETH(currentParticipantAddress, contribution);\n', '                }\n', '            }\n', '            nextContributorToClaim += 1;\n', '        }\n', '    }\n', '\n', '    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '        require(this.balance != 0);\n', '        require(block.number > crowdsaleEndedBlock);\n', '        require(contributorIndexes[nextContributorToClaim] == 0x0);\n', '        multisigAddress.transfer(this.balance);\n', '    }\n', '\n', '    function setMultisigAddress(address _newAddress) onlyOwner public {\n', '        multisigAddress = _newAddress;\n', '    }\n', '\n', '    function setToken(address _newAddress) onlyOwner public {\n', '        tokenAddress = _newAddress;\n', '    }\n', '\n', '    function setKycAddress(address _newAddress) onlyOwner public {\n', '        kycAddress = _newAddress;\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '}\n', '\n', 'contract ERC20Token is ERC20TokenInterface, SafeMath, Owned, Lockable {\n', '\n', '    string public standard;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    address public mintingContractAddress;\n', '\n', '    uint256 supply = 0;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '\n', '    event Mint(address indexed _to, uint256 _value);\n', '    event Burn(address indexed _from, uint _value);\n', '\n', '    function totalSupply() constant public returns (uint256) {\n', '        return supply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) lockAffected public returns (bool success) {\n', '        require(_to != 0x0 && _to != address(this));\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) lockAffected public returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) lockAffected public returns (bool success) {\n', '        tokenRecipientInterface spender = tokenRecipientInterface(_spender);\n', '        approve(_spender, _value);\n', '        spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) lockAffected public returns (bool success) {\n', '        require(_to != 0x0 && _to != address(this));\n', '        balances[_from] = safeSub(balanceOf(_from), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) public {\n', '        require(msg.sender == mintingContractAddress);\n', '        supply = safeAdd(supply, _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(0x0, _to, _amount);\n', '    }\n', '\n', '    function burn(uint _amount) public {\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _amount);\n', '        supply = safeSub(supply, _amount);\n', '        emit Burn(msg.sender, _amount);\n', '        emit Transfer(msg.sender, 0x0, _amount);\n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', 'contract EligmaMintingContract is Owned{\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _tokensMinted, string _message);\n', '\n', '    function EligmaMintingContract() public {\n', '        tokenTotalSupply = 500000000 * 10 ** 18;\n', '    }\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount) public onlyOwner {\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\n', '        emit MintMade(_destination, _tokensAmount, "Presale mint");\n', '    }\n', '\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public {\n', '        require(msg.sender == crowdsaleContractAddress);\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() + _tokensAmount <= tokenTotalSupply);\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, _tokensAmount);\n', '        emit MintMade(_destination, _tokensAmount, "Crowdsale mint");\n', '    }\n', '\n', '    function doTeamMinting(address _destination) public onlyOwner {\n', '        require(ERC20TokenInterface(tokenContractAddress).totalSupply() < tokenTotalSupply);\n', '        uint amountToMint = tokenTotalSupply - ERC20TokenInterface(tokenContractAddress).totalSupply();\n', '        MintableTokenInterface(tokenContractAddress).mint(_destination, amountToMint);\n', '        emit MintMade(_destination, amountToMint, "Team mint");\n', '    }\n', '\n', '    function setTokenContractAddress(address _newAddress) public onlyOwner {\n', '        tokenContractAddress = _newAddress;\n', '    }\n', '\n', '    function setCrowdsaleContractAddress(address _newAddress) public onlyOwner {\n', '        crowdsaleContractAddress = _newAddress;\n', '    }\n', '\n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
