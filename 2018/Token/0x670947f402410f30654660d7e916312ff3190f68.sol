['pragma solidity ^0.4.23;\n', 'pragma experimental "v0.5.0";\n', '/*\n', '  This file is part of The Colony Network.\n', '\n', '  The Colony Network is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  The Colony Network is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '/*\n', '  This file is part of The Colony Network.\n', '\n', '  The Colony Network is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  The Colony Network is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '/// base.sol -- basic ERC20 implementation\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', '/// erc20.sol -- API for the ERC20 token standard\n', '\n', '// See <https://github.com/ethereum/EIPs/issues/20>.\n', '\n', '// This file likely does not meet the threshold of originality\n', '// required for copyright to apply.  As a result, this is free and\n', '// unencumbered software belonging to the public domain.\n', '\n', '\n', '\n', 'contract ERC20Events {\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '}\n', '\n', 'contract ERC20 is ERC20Events {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address guy) public view returns (uint);\n', '    function allowance(address src, address guy) public view returns (uint);\n', '\n', '    function approve(address guy, uint wad) public returns (bool);\n', '    function transfer(address dst, uint wad) public returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint wad\n', '    ) public returns (bool);\n', '}\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSTokenBase is ERC20, DSMath {\n', '    uint256                                            _supply;\n', '    mapping (address => uint256)                       _balances;\n', '    mapping (address => mapping (address => uint256))  _approvals;\n', '\n', '    constructor(uint supply) public {\n', '        _balances[msg.sender] = supply;\n', '        _supply = supply;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _supply;\n', '    }\n', '    function balanceOf(address src) public view returns (uint) {\n', '        return _balances[src];\n', '    }\n', '    function allowance(address src, address guy) public view returns (uint) {\n', '        return _approvals[src][guy];\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender) {\n', '            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n', '        }\n', '\n', '        _balances[src] = sub(_balances[src], wad);\n', '        _balances[dst] = add(_balances[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        _approvals[msg.sender][guy] = wad;\n', '\n', '        emit Approval(msg.sender, guy, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '/*\n', '  This file is part of The Colony Network.\n', '\n', '  The Colony Network is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  The Colony Network is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with The Colony Network. If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20Extended is ERC20 {\n', '  event Mint(address indexed guy, uint wad);\n', '  event Burn(address indexed guy, uint wad);\n', '\n', '  function mint(uint wad) public;\n', '  \n', '  function burn(uint wad) public;\n', '}\n', '\n', '\n', 'contract Token is DSTokenBase(0), DSAuth, ERC20Extended {\n', '  uint8 public decimals;\n', '  string public symbol;\n', '  string public name;\n', '\n', '  bool public locked;\n', '\n', '  modifier unlocked {\n', '    if (locked) {\n', '      require(isAuthorized(msg.sender, msg.sig));\n', '    }\n', '    _;\n', '  }\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '    locked = true;\n', '  }\n', '\n', '  function transferFrom(address src, address dst, uint wad) public \n', '  unlocked\n', '  returns (bool)\n', '  {\n', '    return super.transferFrom(src, dst, wad);\n', '  }\n', '\n', '  function mint(uint wad) public\n', '  auth\n', '  {\n', '    _balances[msg.sender] = add(_balances[msg.sender], wad);\n', '    _supply = add(_supply, wad);\n', '\n', '    emit Mint(msg.sender, wad);\n', '  }\n', '\n', '  function burn(uint wad) public {\n', '    _balances[msg.sender] = sub(_balances[msg.sender], wad);\n', '    _supply = sub(_supply, wad);\n', '\n', '    emit Burn(msg.sender, wad);\n', '  }\n', '\n', '  function unlock() public\n', '  auth\n', '  {\n', '    locked = false;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Vesting is DSMath {\n', '  Token public token;\n', '  address public colonyMultiSig;\n', '\n', '  uint constant internal SECONDS_PER_MONTH = 2628000;\n', '\n', '  event GrantAdded(address recipient, uint256 startTime, uint128 amount, uint16 vestingDuration, uint16 vestingCliff);\n', '  event GrantRemoved(address recipient, uint128 amountVested, uint128 amountNotVested);\n', '  event GrantTokensClaimed(address recipient, uint128 amountClaimed);\n', '\n', '  struct Grant {\n', '    uint startTime;\n', '    uint128 amount;\n', '    uint16 vestingDuration;\n', '    uint16 vestingCliff;\n', '    uint16 monthsClaimed;\n', '    uint128 totalClaimed;\n', '  }\n', '  mapping (address => Grant) public tokenGrants;\n', '\n', '  modifier onlyColonyMultiSig {\n', '    require(msg.sender == colonyMultiSig);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address x) {\n', '    require(x != 0);\n', '    _;\n', '  }\n', '\n', '  modifier noGrantExistsForUser(address _user) {\n', '    require(tokenGrants[_user].startTime == 0);\n', '    _;\n', '  }\n', '\n', '  constructor(address _token, address _colonyMultiSig) public\n', '  nonZeroAddress(_token)\n', '  nonZeroAddress(_colonyMultiSig)\n', '  {\n', '    token = Token(_token);\n', '    colonyMultiSig = _colonyMultiSig;\n', '  }\n', '\n', '  /// @notice Add a new token grant for user `_recipient`. Only one grant per user is allowed\n', '  /// The amount of CLNY tokens here need to be preapproved for transfer by this `Vesting` contract before this call\n', '  /// Secured to the Colony MultiSig only\n', '  /// @param _recipient Address of the token grant recipient entitled to claim the grant funds\n', '  /// @param _startTime Grant start time as seconds since unix epoch\n', '  /// Allows backdating grants by passing time in the past. If `0` is passed here current blocktime is used. \n', '  /// @param _amount Total number of tokens in grant\n', '  /// @param _vestingDuration Number of months of the grant&#39;s duration\n', '  /// @param _vestingCliff Number of months of the grant&#39;s vesting cliff\n', '  function addTokenGrant(address _recipient, uint256 _startTime, uint128 _amount, uint16 _vestingDuration, uint16 _vestingCliff) public \n', '  onlyColonyMultiSig\n', '  noGrantExistsForUser(_recipient)\n', '  {\n', '    require(_vestingCliff > 0);\n', '    require(_vestingDuration > _vestingCliff);\n', '    uint amountVestedPerMonth = _amount / _vestingDuration;\n', '    require(amountVestedPerMonth > 0);\n', '\n', '    // Transfer the grant tokens under the control of the vesting contract\n', '    token.transferFrom(colonyMultiSig, address(this), _amount);\n', '\n', '    Grant memory grant = Grant({\n', '      startTime: _startTime == 0 ? now : _startTime,\n', '      amount: _amount,\n', '      vestingDuration: _vestingDuration,\n', '      vestingCliff: _vestingCliff,\n', '      monthsClaimed: 0,\n', '      totalClaimed: 0\n', '    });\n', '\n', '    tokenGrants[_recipient] = grant;\n', '    emit GrantAdded(_recipient, grant.startTime, _amount, _vestingDuration, _vestingCliff);\n', '  }\n', '\n', '  /// @notice Terminate token grant transferring all vested tokens to the `_recipient`\n', '  /// and returning all non-vested tokens to the Colony MultiSig\n', '  /// Secured to the Colony MultiSig only\n', '  /// @param _recipient Address of the token grant recipient\n', '  function removeTokenGrant(address _recipient) public \n', '  onlyColonyMultiSig\n', '  {\n', '    Grant storage tokenGrant = tokenGrants[_recipient];\n', '    uint16 monthsVested;\n', '    uint128 amountVested;\n', '    (monthsVested, amountVested) = calculateGrantClaim(_recipient);\n', '    uint128 amountNotVested = uint128(sub(sub(tokenGrant.amount, tokenGrant.totalClaimed), amountVested));\n', '\n', '    require(token.transfer(_recipient, amountVested));\n', '    require(token.transfer(colonyMultiSig, amountNotVested));\n', '\n', '    tokenGrant.startTime = 0;\n', '    tokenGrant.amount = 0;\n', '    tokenGrant.vestingDuration = 0;\n', '    tokenGrant.vestingCliff = 0;\n', '    tokenGrant.monthsClaimed = 0;\n', '    tokenGrant.totalClaimed = 0;\n', '\n', '    emit GrantRemoved(_recipient, amountVested, amountNotVested);\n', '  }\n', '\n', '  /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\n', '  /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\n', '  function claimVestedTokens() public {\n', '    uint16 monthsVested;\n', '    uint128 amountVested;\n', '    (monthsVested, amountVested) = calculateGrantClaim(msg.sender);\n', '    require(amountVested > 0);\n', '\n', '    Grant storage tokenGrant = tokenGrants[msg.sender];\n', '    tokenGrant.monthsClaimed = uint16(add(tokenGrant.monthsClaimed, monthsVested));\n', '    tokenGrant.totalClaimed = uint128(add(tokenGrant.totalClaimed, amountVested));\n', '    \n', '    require(token.transfer(msg.sender, amountVested));\n', '    emit GrantTokensClaimed(msg.sender, amountVested);\n', '  }\n', '\n', '  /// @notice Calculate the vested and unclaimed months and tokens available for `_recepient` to claim\n', '  /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\n', '  /// Returns (0, 0) if cliff has not been reached\n', '  function calculateGrantClaim(address _recipient) public view returns (uint16, uint128) {\n', '    Grant storage tokenGrant = tokenGrants[_recipient];\n', '\n', '    // Check cliff was reached\n', '    uint elapsedTime = sub(now, tokenGrant.startTime);\n', '    uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH;\n', '    \n', '    if (elapsedMonths < tokenGrant.vestingCliff) {\n', '      return (0, 0);\n', '    }\n', '\n', '    // If over vesting duration, all tokens vested\n', '    if (elapsedMonths >= tokenGrant.vestingDuration) {\n', '      uint128 remainingGrant = tokenGrant.amount - tokenGrant.totalClaimed;\n', '      return (tokenGrant.vestingDuration, remainingGrant);\n', '    } else {\n', '      uint16 monthsVested = uint16(sub(elapsedMonths, tokenGrant.monthsClaimed));\n', '      uint amountVestedPerMonth = tokenGrant.amount / tokenGrant.vestingDuration;\n', '      uint128 amountVested = uint128(mul(monthsVested, amountVestedPerMonth));\n', '      return (monthsVested, amountVested);\n', '    }\n', '  }\n', '}']