['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    mapping(address => uint) internal balances;\n', '    mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '        balances[msg.sender] = _totalSupply;\n', '        emit Transfer(address(0), msg.sender, _totalSupply);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SwissBorg Referendum 2\n', ' * @dev Hardcoded version with exactly 6 voting addresses.\n', ' */\n', 'contract VotingToken is StandardToken, Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public constant numberOfAlternatives = 6;\n', '\n', '    event Reward(address indexed to, uint amount);\n', '    event Result(address indexed votingAddress, uint amount);\n', '\n', '    ERC20 private rewardToken;\n', '\n', '    bool public opened;\n', '    bool public closed;\n', '\n', '    address[numberOfAlternatives] public votingAddresses;\n', '\n', '    // ~~~~~ Constructor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    constructor(\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        ERC20 _rewardToken,\n', '        address[numberOfAlternatives] _votingAddresses\n', '    ) public StandardToken(_name, _symbol, _decimals, 0) {\n', '        require(_votingAddresses.length == numberOfAlternatives);\n', '        rewardToken = _rewardToken;\n', '        votingAddresses = _votingAddresses;\n', '    }\n', '\n', '    // ~~~~~ Public Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(super.transfer(_to, _value));\n', '        _rewardVote(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(super.transferFrom(_from, _to, _value));\n', '        _rewardVote(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Refuse ETH\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ~~~~~ Admin Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function mint(address _to, uint _amount) onlyOwner external returns (bool) {\n', '        require(!opened);\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function batchMint(address[] _tos, uint[] _amounts) onlyOwner external returns (bool) {\n', '        require(!opened);\n', '        require(_tos.length == _amounts.length);\n', '        uint sum = 0;\n', '        for (uint i = 0; i < _tos.length; i++) {\n', '            address to = _tos[i];\n', '            uint amount = _amounts[i];\n', '            sum = sum.add(amount);\n', '            balances[to] = balances[to].add(amount);\n', '            emit Transfer(address(0), to, amount);\n', '        }\n', '        totalSupply = totalSupply.add(sum);\n', '        return true;\n', '    }\n', '\n', '    function open() onlyOwner external {\n', '        require(!opened);\n', '        opened = true;\n', '    }\n', '\n', '    function close() onlyOwner external {\n', '        require(opened && !closed);\n', '        closed = true;\n', '    }\n', '\n', '    function destroy(address[] tokens) onlyOwner external {\n', '\n', '        // Transfer tokens to owner\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            uint balance = token.balanceOf(this);\n', '            token.transfer(owner, balance);\n', '        }\n', '\n', '        for (uint j = 0; j < numberOfAlternatives; j++) {\n', '            address votingAddress = votingAddresses[j];\n', '            uint votes = balances[votingAddress];\n', '            emit Result(votingAddress, votes);\n', '        }\n', '\n', '        // Transfer Eth to owner and terminate contract\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    // ~~~~~ Private Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function _rewardVote(address _from, address _to, uint _value) private {\n', '        if(_isVotingAddress(_to)) {\n', '            require(opened && !closed);\n', '            uint rewardTokens = _value.div(100);\n', '            require(rewardToken.transfer(_from, rewardTokens));\n', '            emit Reward(_from, _value);\n', '        }\n', '    }\n', '\n', '    function _isVotingAddress(address votingAddress) private view returns (bool) {\n', '        for (uint i = 0; i < numberOfAlternatives; i++) {\n', '            if (votingAddresses[i] == votingAddress) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    mapping(address => uint) internal balances;\n', '    mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '        balances[msg.sender] = _totalSupply;\n', '        emit Transfer(address(0), msg.sender, _totalSupply);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SwissBorg Referendum 2\n', ' * @dev Hardcoded version with exactly 6 voting addresses.\n', ' */\n', 'contract VotingToken is StandardToken, Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public constant numberOfAlternatives = 6;\n', '\n', '    event Reward(address indexed to, uint amount);\n', '    event Result(address indexed votingAddress, uint amount);\n', '\n', '    ERC20 private rewardToken;\n', '\n', '    bool public opened;\n', '    bool public closed;\n', '\n', '    address[numberOfAlternatives] public votingAddresses;\n', '\n', '    // ~~~~~ Constructor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    constructor(\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        ERC20 _rewardToken,\n', '        address[numberOfAlternatives] _votingAddresses\n', '    ) public StandardToken(_name, _symbol, _decimals, 0) {\n', '        require(_votingAddresses.length == numberOfAlternatives);\n', '        rewardToken = _rewardToken;\n', '        votingAddresses = _votingAddresses;\n', '    }\n', '\n', '    // ~~~~~ Public Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(super.transfer(_to, _value));\n', '        _rewardVote(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(super.transferFrom(_from, _to, _value));\n', '        _rewardVote(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // Refuse ETH\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ~~~~~ Admin Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function mint(address _to, uint _amount) onlyOwner external returns (bool) {\n', '        require(!opened);\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function batchMint(address[] _tos, uint[] _amounts) onlyOwner external returns (bool) {\n', '        require(!opened);\n', '        require(_tos.length == _amounts.length);\n', '        uint sum = 0;\n', '        for (uint i = 0; i < _tos.length; i++) {\n', '            address to = _tos[i];\n', '            uint amount = _amounts[i];\n', '            sum = sum.add(amount);\n', '            balances[to] = balances[to].add(amount);\n', '            emit Transfer(address(0), to, amount);\n', '        }\n', '        totalSupply = totalSupply.add(sum);\n', '        return true;\n', '    }\n', '\n', '    function open() onlyOwner external {\n', '        require(!opened);\n', '        opened = true;\n', '    }\n', '\n', '    function close() onlyOwner external {\n', '        require(opened && !closed);\n', '        closed = true;\n', '    }\n', '\n', '    function destroy(address[] tokens) onlyOwner external {\n', '\n', '        // Transfer tokens to owner\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            uint balance = token.balanceOf(this);\n', '            token.transfer(owner, balance);\n', '        }\n', '\n', '        for (uint j = 0; j < numberOfAlternatives; j++) {\n', '            address votingAddress = votingAddresses[j];\n', '            uint votes = balances[votingAddress];\n', '            emit Result(votingAddress, votes);\n', '        }\n', '\n', '        // Transfer Eth to owner and terminate contract\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    // ~~~~~ Private Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n', '\n', '    function _rewardVote(address _from, address _to, uint _value) private {\n', '        if(_isVotingAddress(_to)) {\n', '            require(opened && !closed);\n', '            uint rewardTokens = _value.div(100);\n', '            require(rewardToken.transfer(_from, rewardTokens));\n', '            emit Reward(_from, _value);\n', '        }\n', '    }\n', '\n', '    function _isVotingAddress(address votingAddress) private view returns (bool) {\n', '        for (uint i = 0; i < numberOfAlternatives; i++) {\n', '            if (votingAddresses[i] == votingAddress) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '}']
