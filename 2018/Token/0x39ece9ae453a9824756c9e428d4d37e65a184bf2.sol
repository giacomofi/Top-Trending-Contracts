['pragma solidity ^0.4.18;        // v0.4.18 was the latest possible version. 0.4.19 and above were not allowed\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', 'library SafeMath \n', '{\n', '    //--------------------------------------------------------------------------\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0)     return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'library StringLib \n', '{\n', '    function concat(string strA, string strB) internal pure returns (string)\n', '    {\n', '        uint            i;\n', '        uint            g;\n', '        uint            finalLen;\n', '        bytes memory    dataStrA;\n', '        bytes memory    dataStrB;\n', '        bytes memory    buffer;\n', '\n', '        dataStrA  = bytes(strA);\n', '        dataStrB  = bytes(strB);\n', '\n', '        finalLen  = dataStrA.length + dataStrB.length;\n', '        buffer    = new bytes(finalLen);\n', '\n', '        for (g=i=0; i<dataStrA.length; i++)   buffer[g++] = dataStrA[i];\n', '        for (i=0;   i<dataStrB.length; i++)   buffer[g++] = dataStrB[i];\n', '\n', '        return string(buffer);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function same(string strA, string strB) internal pure returns(bool)\n', '    {\n', '        return keccak256(strA)==keccak256(strB);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function uintToAscii(uint number) internal pure returns(byte) \n', '    {\n', '             if (number < 10)         return byte(48 + number);\n', '        else if (number < 16)         return byte(87 + number);\n', '\n', '        revert();\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function asciiToUint(byte char) internal pure returns (uint) \n', '    {\n', '        uint asciiNum = uint(char);\n', '\n', '             if (asciiNum > 47 && asciiNum < 58)    return asciiNum - 48;\n', '        else if (asciiNum > 96 && asciiNum < 103)   return asciiNum - 87;\n', '\n', '        revert();\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function bytes32ToString (bytes32 data) internal pure returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(64);\n', '\n', '        for (uint j=0; j < 32; j++) \n', '        {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '\n', '            bytesString[j*2+0] = uintToAscii(uint(char) / 16);\n', '            bytesString[j*2+1] = uintToAscii(uint(char) % 16);\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function stringToBytes32(string str) internal pure returns (bytes32) \n', '    {\n', '        bytes memory bString = bytes(str);\n', '        uint uintString;\n', '\n', '        if (bString.length != 64) { revert(); }\n', '\n', '        for (uint i = 0; i < 64; i++) \n', '        {\n', '            uintString = uintString*16 + uint(asciiToUint(bString[i]));\n', '        }\n', '        return bytes32(uintString);\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract ERC20 \n', '{\n', '    function balanceOf(   address _owner)                               public constant returns (uint256 balance);\n', '    function transfer(    address toAddr,  uint256 amount)              public returns (bool success);\n', '    function allowance(   address owner,   address spender)             public constant returns (uint256);\n', '    function approve(     address spender, uint256 value)               public returns (bool);\n', '\n', '    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\n', '    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\n', '\n', '    uint256 public totalSupply;\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Ownable \n', '{\n', '    address public owner;\n', '\n', '    //-------------------------------------------------------------------------- @dev The Ownable constructor sets the original `owner` of the contract to the sender account\n', '    function Ownable() public \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    //-------------------------------------------------------------------------- @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Lockable is Ownable \n', '{\n', '    uint256 internal constant lockedUntil = 1533513600;     // 2018-08-06 00:00 (GMT+0)\n', '\n', '    address internal allowedSender;     // the address that can make transactions when the transaction is locked \n', '\n', '    //-------------------------------------------------------------------------- @dev Allow access only when is unlocked. This function is good when you make crowdsale to avoid token expose in exchanges\n', '    modifier unlocked() \n', '    {\n', '        require((now > lockedUntil) || (allowedSender == msg.sender));\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\n', '    {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '\n', '        allowedSender = newOwner;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Token is ERC20, Lockable \n', '{\n', '    using SafeMath for uint256;\n', '\n', '    address public                                      owner;          // Owner of this contract\n', '    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\n', '    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\n', '\n', '    //------ TOKEN SPECIFICATION\n', '\n', '    string public constant      name     = "Playrs";\n', '    string public constant      symbol   = "PLAYR";\n', '\n', '    uint256 public constant     decimals = 4;      // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\n', '\n', '    uint256 public constant     initSupply = 126000000 * 10**decimals;        // 10**18 max\n', '\n', '    string private constant     supplyReserveMode="quantity";        // "quantity" or "percent"\n', '    uint256 public constant     supplyReserveVal = 26000000 * 10**decimals;          // if quantity => (val * 10**decimals)   if percent => val;\n', '\n', '    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\n', '    uint256 public              icoReserveSupply = 0;\n', '\n', '    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() \n', '    {\n', '        if (msg.sender != allowedSender) \n', '        {\n', '            assert(true==false);\n', '        }\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwnerDuringIco() \n', '    {\n', '        if (msg.sender!=allowedSender || now > lockedUntil) \n', '        {\n', '            assert(true==false);\n', '        }\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- Constructor\n', '    function Token() public \n', '    {\n', '        owner           = msg.sender;\n', '        totalSupply     = initSupply;\n', '        balances[owner] = initSupply;   // send the tokens to the owner\n', '\n', '        //-----\n', '\n', '        allowedSender = owner;          // In this contract, only the contract owner can send token while ICO is active.\n', '\n', '        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\n', '\n', '        icoSalesSupply = totalSupply;   \n', '\n', '        if (StringLib.same(supplyReserveMode, "quantity"))\n', '        {\n', '            icoSalesSupply = totalSupply.sub(supplyReserveVal);\n', '        }\n', '        else if (StringLib.same(supplyReserveMode, "percent"))\n', '        {\n', '            icoSalesSupply = totalSupply.mul(supplyReserveVal).div(100);\n', '        }\n', '\n', '        icoReserveSupply = totalSupply.sub(icoSalesSupply);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function transfer(address toAddr, uint256 amount)  public   unlocked returns (bool success) \n', '    {\n', '        require(toAddr!=0x0 && toAddr!=msg.sender && amount>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\n', '\n', '        uint256 availableTokens      = balances[msg.sender];\n', '\n', '        if (msg.sender==allowedSender)                              // Special handling on contract owner \n', '        {\n', '            if (now <= lockedUntil)                                 // The ICO is now running\n', '            {\n', '                uint256 balanceAfterTransfer = availableTokens.sub(amount);      \n', '\n', '                assert(balanceAfterTransfer >= icoReserveSupply);          // don&#39;t sell more than allowed during ICO\n', '            }\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        balances[toAddr]     = balances[toAddr].add(amount);\n', '\n', '        emit Transfer(msg.sender, toAddr, amount);\n', '        //Transfer(msg.sender, toAddr, amount);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function balanceOf(address _owner)  public   constant returns (uint256 balance) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function approve(address _spender, uint256 amount)  public   returns (bool) \n', '    {\n', '        require((amount == 0) || (allowances[msg.sender][_spender] == 0));\n', '\n', '        allowances[msg.sender][_spender] = amount;\n', '\n', '        emit Approval(msg.sender, _spender, amount);\n', '        //Approval(msg.sender, _spender, amount);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function allowance(address _owner, address _spender)  public   constant returns (uint remaining)\n', '    {\n', '        return allowances[_owner][_spender];    // Return the allowance for _spender approved by _owner\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function() public                       \n', '    {\n', '        assert(true == false);      // If Ether is sent to this address, don&#39;t handle it -> send it back.\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '\n', '\n', '    //--------------------------------------------------------------------------\n', '    //\n', '    // When ICO is closed, send the relaining (unsold) tokens to address 0x0\n', '    // So no one will be able to use it anymore... \n', '    // Anyone can check address 0x0, so to proove unsold tokens belong to no one anymore\n', '    //\n', '    //--------------------------------------------------------------------------\n', '    function destroyRemainingTokens() public unlocked /*view*/ returns(uint)\n', '    {\n', '        require(msg.sender==allowedSender && now>lockedUntil);\n', '\n', '        address   toAddr = 0x0000000000000000000000000000000000000000;\n', '\n', '        uint256   amountToBurn = balances[allowedSender];\n', '\n', '        if (amountToBurn > icoReserveSupply)\n', '        {\n', '            amountToBurn = amountToBurn.sub(icoReserveSupply);\n', '        }\n', '\n', '        balances[owner]  = balances[allowedSender].sub(amountToBurn);\n', '        balances[toAddr] = balances[toAddr].add(amountToBurn);\n', '\n', '        //emit Transfer(msg.sender, toAddr, amount);\n', '        Transfer(msg.sender, toAddr, amountToBurn);\n', '\n', '        return 1;\n', '    }        \n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '}']
['pragma solidity ^0.4.18;        // v0.4.18 was the latest possible version. 0.4.19 and above were not allowed\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', 'library SafeMath \n', '{\n', '    //--------------------------------------------------------------------------\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0)     return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'library StringLib \n', '{\n', '    function concat(string strA, string strB) internal pure returns (string)\n', '    {\n', '        uint            i;\n', '        uint            g;\n', '        uint            finalLen;\n', '        bytes memory    dataStrA;\n', '        bytes memory    dataStrB;\n', '        bytes memory    buffer;\n', '\n', '        dataStrA  = bytes(strA);\n', '        dataStrB  = bytes(strB);\n', '\n', '        finalLen  = dataStrA.length + dataStrB.length;\n', '        buffer    = new bytes(finalLen);\n', '\n', '        for (g=i=0; i<dataStrA.length; i++)   buffer[g++] = dataStrA[i];\n', '        for (i=0;   i<dataStrB.length; i++)   buffer[g++] = dataStrB[i];\n', '\n', '        return string(buffer);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function same(string strA, string strB) internal pure returns(bool)\n', '    {\n', '        return keccak256(strA)==keccak256(strB);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function uintToAscii(uint number) internal pure returns(byte) \n', '    {\n', '             if (number < 10)         return byte(48 + number);\n', '        else if (number < 16)         return byte(87 + number);\n', '\n', '        revert();\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function asciiToUint(byte char) internal pure returns (uint) \n', '    {\n', '        uint asciiNum = uint(char);\n', '\n', '             if (asciiNum > 47 && asciiNum < 58)    return asciiNum - 48;\n', '        else if (asciiNum > 96 && asciiNum < 103)   return asciiNum - 87;\n', '\n', '        revert();\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function bytes32ToString (bytes32 data) internal pure returns (string) \n', '    {\n', '        bytes memory bytesString = new bytes(64);\n', '\n', '        for (uint j=0; j < 32; j++) \n', '        {\n', '            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\n', '\n', '            bytesString[j*2+0] = uintToAscii(uint(char) / 16);\n', '            bytesString[j*2+1] = uintToAscii(uint(char) % 16);\n', '        }\n', '        return string(bytesString);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function stringToBytes32(string str) internal pure returns (bytes32) \n', '    {\n', '        bytes memory bString = bytes(str);\n', '        uint uintString;\n', '\n', '        if (bString.length != 64) { revert(); }\n', '\n', '        for (uint i = 0; i < 64; i++) \n', '        {\n', '            uintString = uintString*16 + uint(asciiToUint(bString[i]));\n', '        }\n', '        return bytes32(uintString);\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract ERC20 \n', '{\n', '    function balanceOf(   address _owner)                               public constant returns (uint256 balance);\n', '    function transfer(    address toAddr,  uint256 amount)              public returns (bool success);\n', '    function allowance(   address owner,   address spender)             public constant returns (uint256);\n', '    function approve(     address spender, uint256 value)               public returns (bool);\n', '\n', '    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\n', '    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\n', '\n', '    uint256 public totalSupply;\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Ownable \n', '{\n', '    address public owner;\n', '\n', '    //-------------------------------------------------------------------------- @dev The Ownable constructor sets the original `owner` of the contract to the sender account\n', '    function Ownable() public \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    //-------------------------------------------------------------------------- @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Lockable is Ownable \n', '{\n', '    uint256 internal constant lockedUntil = 1533513600;     // 2018-08-06 00:00 (GMT+0)\n', '\n', '    address internal allowedSender;     // the address that can make transactions when the transaction is locked \n', '\n', '    //-------------------------------------------------------------------------- @dev Allow access only when is unlocked. This function is good when you make crowdsale to avoid token expose in exchanges\n', '    modifier unlocked() \n', '    {\n', '        require((now > lockedUntil) || (allowedSender == msg.sender));\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\n', '    {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '\n', '        allowedSender = newOwner;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract Token is ERC20, Lockable \n', '{\n', '    using SafeMath for uint256;\n', '\n', '    address public                                      owner;          // Owner of this contract\n', '    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\n', '    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\n', '\n', '    //------ TOKEN SPECIFICATION\n', '\n', '    string public constant      name     = "Playrs";\n', '    string public constant      symbol   = "PLAYR";\n', '\n', '    uint256 public constant     decimals = 4;      // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\n', '\n', '    uint256 public constant     initSupply = 126000000 * 10**decimals;        // 10**18 max\n', '\n', '    string private constant     supplyReserveMode="quantity";        // "quantity" or "percent"\n', '    uint256 public constant     supplyReserveVal = 26000000 * 10**decimals;          // if quantity => (val * 10**decimals)   if percent => val;\n', '\n', '    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\n', '    uint256 public              icoReserveSupply = 0;\n', '\n', '    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwner() \n', '    {\n', '        if (msg.sender != allowedSender) \n', '        {\n', '            assert(true==false);\n', '        }\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\n', '    modifier onlyOwnerDuringIco() \n', '    {\n', '        if (msg.sender!=allowedSender || now > lockedUntil) \n', '        {\n', '            assert(true==false);\n', '        }\n', '        _;\n', '    }\n', '    //-------------------------------------------------------------------------- Constructor\n', '    function Token() public \n', '    {\n', '        owner           = msg.sender;\n', '        totalSupply     = initSupply;\n', '        balances[owner] = initSupply;   // send the tokens to the owner\n', '\n', '        //-----\n', '\n', '        allowedSender = owner;          // In this contract, only the contract owner can send token while ICO is active.\n', '\n', '        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\n', '\n', '        icoSalesSupply = totalSupply;   \n', '\n', '        if (StringLib.same(supplyReserveMode, "quantity"))\n', '        {\n', '            icoSalesSupply = totalSupply.sub(supplyReserveVal);\n', '        }\n', '        else if (StringLib.same(supplyReserveMode, "percent"))\n', '        {\n', '            icoSalesSupply = totalSupply.mul(supplyReserveVal).div(100);\n', '        }\n', '\n', '        icoReserveSupply = totalSupply.sub(icoSalesSupply);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function transfer(address toAddr, uint256 amount)  public   unlocked returns (bool success) \n', '    {\n', '        require(toAddr!=0x0 && toAddr!=msg.sender && amount>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\n', '\n', '        uint256 availableTokens      = balances[msg.sender];\n', '\n', '        if (msg.sender==allowedSender)                              // Special handling on contract owner \n', '        {\n', '            if (now <= lockedUntil)                                 // The ICO is now running\n', '            {\n', '                uint256 balanceAfterTransfer = availableTokens.sub(amount);      \n', '\n', "                assert(balanceAfterTransfer >= icoReserveSupply);          // don't sell more than allowed during ICO\n", '            }\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        balances[toAddr]     = balances[toAddr].add(amount);\n', '\n', '        emit Transfer(msg.sender, toAddr, amount);\n', '        //Transfer(msg.sender, toAddr, amount);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function balanceOf(address _owner)  public   constant returns (uint256 balance) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function approve(address _spender, uint256 amount)  public   returns (bool) \n', '    {\n', '        require((amount == 0) || (allowances[msg.sender][_spender] == 0));\n', '\n', '        allowances[msg.sender][_spender] = amount;\n', '\n', '        emit Approval(msg.sender, _spender, amount);\n', '        //Approval(msg.sender, _spender, amount);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function allowance(address _owner, address _spender)  public   constant returns (uint remaining)\n', '    {\n', '        return allowances[_owner][_spender];    // Return the allowance for _spender approved by _owner\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function() public                       \n', '    {\n', "        assert(true == false);      // If Ether is sent to this address, don't handle it -> send it back.\n", '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '\n', '\n', '    //--------------------------------------------------------------------------\n', '    //\n', '    // When ICO is closed, send the relaining (unsold) tokens to address 0x0\n', '    // So no one will be able to use it anymore... \n', '    // Anyone can check address 0x0, so to proove unsold tokens belong to no one anymore\n', '    //\n', '    //--------------------------------------------------------------------------\n', '    function destroyRemainingTokens() public unlocked /*view*/ returns(uint)\n', '    {\n', '        require(msg.sender==allowedSender && now>lockedUntil);\n', '\n', '        address   toAddr = 0x0000000000000000000000000000000000000000;\n', '\n', '        uint256   amountToBurn = balances[allowedSender];\n', '\n', '        if (amountToBurn > icoReserveSupply)\n', '        {\n', '            amountToBurn = amountToBurn.sub(icoReserveSupply);\n', '        }\n', '\n', '        balances[owner]  = balances[allowedSender].sub(amountToBurn);\n', '        balances[toAddr] = balances[toAddr].add(amountToBurn);\n', '\n', '        //emit Transfer(msg.sender, toAddr, amount);\n', '        Transfer(msg.sender, toAddr, amountToBurn);\n', '\n', '        return 1;\n', '    }        \n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '}']
