['pragma solidity ^0.4.10;\n', '\n', 'contract GasToken1 {\n', '    //////////////////////////////////////////////////////////////////////////\n', '    // Generic ERC20\n', '    //////////////////////////////////////////////////////////////////////////\n', '\n', '    // owner -> amount\n', '    mapping(address => uint256) s_balances;\n', '    // owner -> spender -> max amount\n', '    mapping(address => mapping(address => uint256)) s_allowances;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    // Spec: Get the account balance of another account with address `owner`\n', '    function balanceOf(address owner) public constant returns (uint256 balance) {\n', '        return s_balances[owner];\n', '    }\n', '\n', '    function internalTransfer(address from, address to, uint256 value) internal returns (bool success) {\n', '        if (value <= s_balances[from]) {\n', '            s_balances[from] -= value;\n', '            s_balances[to] += value;\n', '            Transfer(from, to, value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Spec: Send `value` amount of tokens to address `to`\n', '    function transfer(address to, uint256 value) public returns (bool success) {\n', '        address from = msg.sender;\n', '        return internalTransfer(from, to, value);\n', '    }\n', '\n', '    // Spec: Send `value` amount of tokens from address `from` to address `to`\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n', '        address spender = msg.sender;\n', '        if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) {\n', '            s_allowances[from][spender] -= value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Spec: Allow `spender` to withdraw from your account, multiple times, up\n', '    // to the `value` amount. If this function is called again it overwrites the\n', '    // current allowance with `value`.\n', '    function approve(address spender, uint256 value) public returns (bool success) {\n', '        address owner = msg.sender;\n', '        if (value != 0 && s_allowances[owner][spender] != 0) {\n', '            return false;\n', '        }\n', '        s_allowances[owner][spender] = value;\n', '        Approval(owner, spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Spec: Returns the `amount` which `spender` is still allowed to withdraw\n', '    // from `owner`.\n', '    // What if the allowance is higher than the balance of the `owner`?\n', '    // Callers should be careful to use min(allowance, balanceOf) to make sure\n', '    // that the allowance is actually present in the account!\n', '    function allowance(address owner, address spender) public constant returns (uint256 remaining) {\n', '        return s_allowances[owner][spender];\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////\n', '    // GasToken specifics\n', '    //////////////////////////////////////////////////////////////////////////\n', '\n', '    uint8 constant public decimals = 2;\n', '    string constant public name = "Gastoken.io";\n', '    string constant public symbol = "GST1";\n', '\n', '    // We start our storage at this location. The EVM word at this location\n', '    // contains the number of stored words. The stored words follow at\n', '    // locations (STORAGE_LOCATION_ARRAY+1), (STORAGE_LOCATION_ARRAY+2), ...\n', '    uint256 constant STORAGE_LOCATION_ARRAY = 0xDEADBEEF;\n', '\n', '\n', '    // totalSupply is the number of words we have in storage\n', '    function totalSupply() public constant returns (uint256 supply) {\n', '        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '    }\n', '\n', '    // Mints `value` new sub-tokens (e.g. cents, pennies, ...) by filling up\n', '    // `value` words of EVM storage. The minted tokens are owned by the\n', '    // caller of this function.\n', '    function mint(uint256 value) public {\n', '        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;  // can&#39;t use constants inside assembly\n', '\n', '        if (value == 0) {\n', '            return;\n', '        }\n', '\n', '        // Read supply\n', '        uint256 supply;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '\n', '        // Set memory locations in interval [l, r]\n', '        uint256 l = storage_location_array + supply + 1;\n', '        uint256 r = storage_location_array + supply + value;\n', '        assert(r >= l);\n', '\n', '        for (uint256 i = l; i <= r; i++) {\n', '            assembly {\n', '                sstore(i, 1)\n', '            }\n', '        }\n', '\n', '        // Write updated supply & balance\n', '        assembly {\n', '            sstore(storage_location_array, add(supply, value))\n', '        }\n', '        s_balances[msg.sender] += value;\n', '    }\n', '\n', '    function freeStorage(uint256 value) internal {\n', '        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;  // can&#39;t use constants inside assembly\n', '\n', '        // Read supply\n', '        uint256 supply;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '\n', '        // Clear memory locations in interval [l, r]\n', '        uint256 l = storage_location_array + supply - value + 1;\n', '        uint256 r = storage_location_array + supply;\n', '        for (uint256 i = l; i <= r; i++) {\n', '            assembly {\n', '                sstore(i, 0)\n', '            }\n', '        }\n', '\n', '        // Write updated supply\n', '        assembly {\n', '            sstore(storage_location_array, sub(supply, value))\n', '        }\n', '    }\n', '\n', '    // Frees `value` sub-tokens (e.g. cents, pennies, ...) belonging to the\n', '    // caller of this function by clearing value words of EVM storage, which\n', '    // will trigger a partial gas refund.\n', '    function free(uint256 value) public returns (bool success) {\n', '        uint256 from_balance = s_balances[msg.sender];\n', '        if (value > from_balance) {\n', '            return false;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[msg.sender] = from_balance - value;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Frees up to `value` sub-tokens. Returns how many tokens were freed.\n', '    // Otherwise, identical to free.\n', '    function freeUpTo(uint256 value) public returns (uint256 freed) {\n', '        uint256 from_balance = s_balances[msg.sender];\n', '        if (value > from_balance) {\n', '            value = from_balance;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[msg.sender] = from_balance - value;\n', '\n', '        return value;\n', '    }\n', '\n', '    // Frees `value` sub-tokens owned by address `from`. Requires that `msg.sender`\n', '    // has been approved by `from`.\n', '    function freeFrom(address from, uint256 value) public returns (bool success) {\n', '        address spender = msg.sender;\n', '        uint256 from_balance = s_balances[from];\n', '        if (value > from_balance) {\n', '            return false;\n', '        }\n', '\n', '        mapping(address => uint256) from_allowances = s_allowances[from];\n', '        uint256 spender_allowance = from_allowances[spender];\n', '        if (value > spender_allowance) {\n', '            return false;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[from] = from_balance - value;\n', '        from_allowances[spender] = spender_allowance - value;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Frees up to `value` sub-tokens owned by address `from`. Returns how many tokens were freed.\n', '    // Otherwise, identical to `freeFrom`.\n', '    function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {\n', '        address spender = msg.sender;\n', '        uint256 from_balance = s_balances[from];\n', '        if (value > from_balance) {\n', '            value = from_balance;\n', '        }\n', '\n', '        mapping(address => uint256) from_allowances = s_allowances[from];\n', '        uint256 spender_allowance = from_allowances[spender];\n', '        if (value > spender_allowance) {\n', '            value = spender_allowance;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[from] = from_balance - value;\n', '        from_allowances[spender] = spender_allowance - value;\n', '\n', '        return value;\n', '    }\n', '}']
['pragma solidity ^0.4.10;\n', '\n', 'contract GasToken1 {\n', '    //////////////////////////////////////////////////////////////////////////\n', '    // Generic ERC20\n', '    //////////////////////////////////////////////////////////////////////////\n', '\n', '    // owner -> amount\n', '    mapping(address => uint256) s_balances;\n', '    // owner -> spender -> max amount\n', '    mapping(address => mapping(address => uint256)) s_allowances;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    // Spec: Get the account balance of another account with address `owner`\n', '    function balanceOf(address owner) public constant returns (uint256 balance) {\n', '        return s_balances[owner];\n', '    }\n', '\n', '    function internalTransfer(address from, address to, uint256 value) internal returns (bool success) {\n', '        if (value <= s_balances[from]) {\n', '            s_balances[from] -= value;\n', '            s_balances[to] += value;\n', '            Transfer(from, to, value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Spec: Send `value` amount of tokens to address `to`\n', '    function transfer(address to, uint256 value) public returns (bool success) {\n', '        address from = msg.sender;\n', '        return internalTransfer(from, to, value);\n', '    }\n', '\n', '    // Spec: Send `value` amount of tokens from address `from` to address `to`\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n', '        address spender = msg.sender;\n', '        if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) {\n', '            s_allowances[from][spender] -= value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Spec: Allow `spender` to withdraw from your account, multiple times, up\n', '    // to the `value` amount. If this function is called again it overwrites the\n', '    // current allowance with `value`.\n', '    function approve(address spender, uint256 value) public returns (bool success) {\n', '        address owner = msg.sender;\n', '        if (value != 0 && s_allowances[owner][spender] != 0) {\n', '            return false;\n', '        }\n', '        s_allowances[owner][spender] = value;\n', '        Approval(owner, spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Spec: Returns the `amount` which `spender` is still allowed to withdraw\n', '    // from `owner`.\n', '    // What if the allowance is higher than the balance of the `owner`?\n', '    // Callers should be careful to use min(allowance, balanceOf) to make sure\n', '    // that the allowance is actually present in the account!\n', '    function allowance(address owner, address spender) public constant returns (uint256 remaining) {\n', '        return s_allowances[owner][spender];\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////\n', '    // GasToken specifics\n', '    //////////////////////////////////////////////////////////////////////////\n', '\n', '    uint8 constant public decimals = 2;\n', '    string constant public name = "Gastoken.io";\n', '    string constant public symbol = "GST1";\n', '\n', '    // We start our storage at this location. The EVM word at this location\n', '    // contains the number of stored words. The stored words follow at\n', '    // locations (STORAGE_LOCATION_ARRAY+1), (STORAGE_LOCATION_ARRAY+2), ...\n', '    uint256 constant STORAGE_LOCATION_ARRAY = 0xDEADBEEF;\n', '\n', '\n', '    // totalSupply is the number of words we have in storage\n', '    function totalSupply() public constant returns (uint256 supply) {\n', '        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '    }\n', '\n', '    // Mints `value` new sub-tokens (e.g. cents, pennies, ...) by filling up\n', '    // `value` words of EVM storage. The minted tokens are owned by the\n', '    // caller of this function.\n', '    function mint(uint256 value) public {\n', "        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;  // can't use constants inside assembly\n", '\n', '        if (value == 0) {\n', '            return;\n', '        }\n', '\n', '        // Read supply\n', '        uint256 supply;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '\n', '        // Set memory locations in interval [l, r]\n', '        uint256 l = storage_location_array + supply + 1;\n', '        uint256 r = storage_location_array + supply + value;\n', '        assert(r >= l);\n', '\n', '        for (uint256 i = l; i <= r; i++) {\n', '            assembly {\n', '                sstore(i, 1)\n', '            }\n', '        }\n', '\n', '        // Write updated supply & balance\n', '        assembly {\n', '            sstore(storage_location_array, add(supply, value))\n', '        }\n', '        s_balances[msg.sender] += value;\n', '    }\n', '\n', '    function freeStorage(uint256 value) internal {\n', "        uint256 storage_location_array = STORAGE_LOCATION_ARRAY;  // can't use constants inside assembly\n", '\n', '        // Read supply\n', '        uint256 supply;\n', '        assembly {\n', '            supply := sload(storage_location_array)\n', '        }\n', '\n', '        // Clear memory locations in interval [l, r]\n', '        uint256 l = storage_location_array + supply - value + 1;\n', '        uint256 r = storage_location_array + supply;\n', '        for (uint256 i = l; i <= r; i++) {\n', '            assembly {\n', '                sstore(i, 0)\n', '            }\n', '        }\n', '\n', '        // Write updated supply\n', '        assembly {\n', '            sstore(storage_location_array, sub(supply, value))\n', '        }\n', '    }\n', '\n', '    // Frees `value` sub-tokens (e.g. cents, pennies, ...) belonging to the\n', '    // caller of this function by clearing value words of EVM storage, which\n', '    // will trigger a partial gas refund.\n', '    function free(uint256 value) public returns (bool success) {\n', '        uint256 from_balance = s_balances[msg.sender];\n', '        if (value > from_balance) {\n', '            return false;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[msg.sender] = from_balance - value;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Frees up to `value` sub-tokens. Returns how many tokens were freed.\n', '    // Otherwise, identical to free.\n', '    function freeUpTo(uint256 value) public returns (uint256 freed) {\n', '        uint256 from_balance = s_balances[msg.sender];\n', '        if (value > from_balance) {\n', '            value = from_balance;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[msg.sender] = from_balance - value;\n', '\n', '        return value;\n', '    }\n', '\n', '    // Frees `value` sub-tokens owned by address `from`. Requires that `msg.sender`\n', '    // has been approved by `from`.\n', '    function freeFrom(address from, uint256 value) public returns (bool success) {\n', '        address spender = msg.sender;\n', '        uint256 from_balance = s_balances[from];\n', '        if (value > from_balance) {\n', '            return false;\n', '        }\n', '\n', '        mapping(address => uint256) from_allowances = s_allowances[from];\n', '        uint256 spender_allowance = from_allowances[spender];\n', '        if (value > spender_allowance) {\n', '            return false;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[from] = from_balance - value;\n', '        from_allowances[spender] = spender_allowance - value;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Frees up to `value` sub-tokens owned by address `from`. Returns how many tokens were freed.\n', '    // Otherwise, identical to `freeFrom`.\n', '    function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {\n', '        address spender = msg.sender;\n', '        uint256 from_balance = s_balances[from];\n', '        if (value > from_balance) {\n', '            value = from_balance;\n', '        }\n', '\n', '        mapping(address => uint256) from_allowances = s_allowances[from];\n', '        uint256 spender_allowance = from_allowances[spender];\n', '        if (value > spender_allowance) {\n', '            value = spender_allowance;\n', '        }\n', '\n', '        freeStorage(value);\n', '\n', '        s_balances[from] = from_balance - value;\n', '        from_allowances[spender] = spender_allowance - value;\n', '\n', '        return value;\n', '    }\n', '}']
