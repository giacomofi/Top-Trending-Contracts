['pragma solidity ^0.4.18;\n', '\n', 'contract safeMath {\n', '\n', '    function add( uint256 x, uint256 y ) internal pure returns ( uint256 z ) {\n', '        assert( ( z = x + y ) >= x );\n', '    }\n', '\n', '    function sub( uint256 x, uint256 y ) internal pure returns ( uint256 z ) {\n', '        assert( ( z = x - y ) <= x );\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function    totalSupply() public constant returns (uint);\n', '    function    balanceOf(address who) public view returns (uint256);\n', '    function    allowance(address owner, address spender) public view returns (uint256);\n', '\n', '    function    transfer(address to, uint256 value) public returns (bool);\n', '    function    transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function    approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event       Transfer( address indexed from, address indexed to, uint value );\n', '    event       Approval( address indexed owner, address indexed spender, uint value );\n', '}\n', '\n', 'contract    baseToken is ERC20, safeMath {\n', '    uint256     public  _totalSupply;\n', '    string      public  _name;\n', '    string      public  _symbol;\n', '    uint8       public  _decimals;\n', '\n', '    mapping ( address => uint256 )                          _balanceOf;\n', '    mapping ( address => mapping ( address => uint256 ) )   _allowance;\n', '\n', '    event Burn( address indexed from, uint256 value );\n', '\n', '    function    baseToken( ) public {\n', '        uint256     balance;\n', '\n', '        balance = 50000;\n', '        _name = "Onkostop";\n', '        _symbol = "OSC";\n', '        _balanceOf[msg.sender] = balance;\n', '        _totalSupply = balance;\n', '        _decimals = 0;\n', '    }   \n', '\n', '    function    totalSupply() public constant returns ( uint256 ) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function    balanceOf( address user ) public view returns ( uint256 ) {\n', '        return _balanceOf[user];\n', '    }\n', '\n', '    function    allowance( address owner, address spender ) public view returns ( uint256 ) {\n', '        return _allowance[owner][spender];\n', '    }\n', '\n', '    function    transfer( address to, uint amount ) public returns ( bool ) {\n', '        assert(_balanceOf[msg.sender] >= amount);\n', '        _balanceOf[msg.sender] = sub( _balanceOf[msg.sender], amount );\n', '        _balanceOf[to] = add( _balanceOf[to], amount );\n', '        Transfer( msg.sender, to, amount );\n', '        return true;\n', '    }\n', '\n', '    function    transferFrom( address from, address to, uint amount ) public returns ( bool ) {\n', '        assert( _balanceOf[from] >= amount );\n', '        assert( _allowance[from][msg.sender] >= amount );\n', '        _allowance[from][msg.sender] = sub( _allowance[from][msg.sender], amount );\n', '        _balanceOf[from] = sub( _balanceOf[from], amount );\n', '        _balanceOf[to] = add( _balanceOf[to], amount );\n', '        Transfer( from, to, amount );\n', '        return true;\n', '    }\n', '\n', '    function    approve( address spender, uint256 amount ) public returns ( bool ) {\n', '        _allowance[msg.sender][spender] = amount;\n', '        Approval( msg.sender, spender, amount );\n', '        return true;\n', '    }\n', '\n', '    function    burn( uint256 value ) public returns ( bool success ) {\n', '        assert( _balanceOf[msg.sender] >= value );  // Check if the sender has enough\n', '        _balanceOf[msg.sender] -= value;            // Subtract from the sender\n', '        _totalSupply -= value;                      // Updates _totalSupply\n', '        Burn( msg.sender, value );\n', '        return true;\n', '    }\n', '}']