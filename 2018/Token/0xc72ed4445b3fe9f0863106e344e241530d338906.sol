['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '          return 0;\n', '      }\n', '      uint256 c = a * b;\n', '      assert(c / a == b);\n', '      return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a / b;\n', '      return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '      owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '      require(newOwner != address(0));\n', '\n', '      OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Authorizable {\n', '    mapping(address => bool) authorizers;\n', '\n', '    modifier onlyAuthorized {\n', '      require(isAuthorized(msg.sender));\n', '      _;\n', '    }\n', '\n', '    function Authorizable() public {\n', '      authorizers[msg.sender] = true;\n', '    }\n', '\n', '\n', '    function isAuthorized(address _addr) public constant returns(bool) {\n', '      require(_addr != address(0));\n', '\n', '      bool result = bool(authorizers[_addr]);\n', '      return result;\n', '    }\n', '\n', '    function addAuthorized(address _addr) external onlyAuthorized {\n', '      require(_addr != address(0));\n', '\n', '      authorizers[_addr] = true;\n', '    }\n', '\n', '    function delAuthorized(address _addr) external onlyAuthorized {\n', '      require(_addr != address(0));\n', '      require(_addr != msg.sender);\n', '\n', '      //authorizers[_addr] = false;\n', '      delete authorizers[_addr];\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    //modifier onlyPayloadSize(uint size) {\n', '    //  require(msg.data.length < size + 4);\n', '    //  _;\n', '    //}\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '      return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '      //requeres in FrozenToken\n', '      //require(_to != address(0));\n', '      //require(_value <= balances[msg.sender]);\n', '\n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '      return balances[_owner];\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '      //requires in FrozenToken\n', '      //require(_to != address(0));\n', '      //require(_value <= balances[_from]);\n', '      //require(_value <= allowed[_from][msg.sender]);\n', '\n', '      balances[_from] = balances[_from].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '      require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '      allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '      uint oldValue = allowed[msg.sender][_spender];\n', '      if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '      }\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract FrozenToken is StandardToken, Ownable {\n', '    mapping(address => bool) frozens;\n', '    mapping(address => uint256) frozenTokens;\n', '\n', '    event FrozenAddress(address addr);\n', '    event UnFrozenAddress(address addr);\n', '    event FrozenTokenEvent(address addr, uint256 amount);\n', '    event UnFrozenTokenEvent(address addr, uint256 amount);\n', '\n', '    modifier isNotFrozen() {\n', '      require(frozens[msg.sender] == false);\n', '      _;\n', '    }\n', '\n', '    function frozenAddress(address _addr) onlyOwner public returns (bool) {\n', '      require(_addr != address(0));\n', '\n', '      frozens[_addr] = true;\n', '      FrozenAddress(_addr);\n', '      return frozens[_addr];\n', '    }\n', '\n', '    function unFrozenAddress(address _addr) onlyOwner public returns (bool) {\n', '      require(_addr != address(0));\n', '\n', '      delete frozens[_addr];\n', '      //frozens[_addr] = false;\n', '      UnFrozenAddress(_addr);\n', '      return frozens[_addr];\n', '    }\n', '\n', '    function isFrozenByAddress(address _addr) public constant returns(bool) {\n', '      require(_addr != address(0));\n', '\n', '      bool result = bool(frozens[_addr]);\n', '      return result;\n', '    }\n', '\n', '    function balanceFrozenTokens(address _addr) public constant returns(uint256) {\n', '      require(_addr != address(0));\n', '\n', '      uint256 result = uint256(frozenTokens[_addr]);\n', '      return result;\n', '    }\n', '\n', '    function balanceAvailableTokens(address _addr) public constant returns(uint256) {\n', '      require(_addr != address(0));\n', '\n', '      uint256 frozen = uint256(frozenTokens[_addr]);\n', '      uint256 balance = uint256(balances[_addr]);\n', '      require(balance >= frozen);\n', '\n', '      uint256 result = balance.sub(frozen);\n', '\n', '      return result;\n', '    }\n', '\n', '    function frozenToken(address _addr, uint256 _amount) onlyOwner public returns(bool) {\n', '      require(_addr != address(0));\n', '      require(_amount > 0);\n', '\n', '      uint256 balance = uint256(balances[_addr]);\n', '      require(balance >= _amount);\n', '\n', '      frozenTokens[_addr] = frozenTokens[_addr].add(_amount);\n', '      FrozenTokenEvent(_addr, _amount);\n', '      return true;\n', '    }\n', '    \n', '\n', '    function unFrozenToken(address _addr, uint256 _amount) onlyOwner public returns(bool) {\n', '      require(_addr != address(0));\n', '      require(_amount > 0);\n', '      require(frozenTokens[_addr] >= _amount);\n', '\n', '      frozenTokens[_addr] = frozenTokens[_addr].sub(_amount);\n', '      UnFrozenTokenEvent(_addr, _amount);\n', '      return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) isNotFrozen() public returns (bool) {\n', '      require(_to != address(0));\n', '      require(_value <= balances[msg.sender]);\n', '\n', '      uint256 balance = balances[msg.sender];\n', '      uint256 frozen = frozenTokens[msg.sender];\n', '      uint256 availableBalance = balance.sub(frozen);\n', '      require(availableBalance >= _value);\n', '\n', '      return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) isNotFrozen() public returns (bool) {\n', '      require(_to != address(0));\n', '      require(_value <= balances[_from]);\n', '      require(_value <= allowed[_from][msg.sender]);\n', '\n', '      uint256 balance = balances[_from];\n', '      uint256 frozen = frozenTokens[_from];\n', '      uint256 availableBalance = balance.sub(frozen);\n', '      require(availableBalance >= _value);\n', '\n', '      return super.transferFrom(_from ,_to, _value);\n', '    }\n', '}\n', '\n', 'contract MallcoinToken is FrozenToken, Authorizable {\n', '      string public constant name = "Mallcoin Token";\n', '      string public constant symbol = "MLC";\n', '      uint8 public constant decimals = 18;\n', '      uint256 public MAX_TOKEN_SUPPLY = 250000000 * 1 ether;\n', '\n', '      event CreateToken(address indexed to, uint256 amount);\n', '      event CreateTokenByAtes(address indexed to, uint256 amount, string data);\n', '\n', '      modifier onlyOwnerOrAuthorized {\n', '        require(msg.sender == owner || isAuthorized(msg.sender));\n', '        _;\n', '      }\n', '\n', '      function createToken(address _to, uint256 _amount) onlyOwnerOrAuthorized public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_amount > 0);\n', '        require(MAX_TOKEN_SUPPLY >= totalSupply_ + _amount);\n', '\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // KYC\n', '        frozens[_to] = true;\n', '        FrozenAddress(_to);\n', '\n', '        CreateToken(_to, _amount);\n', '        Transfer(address(0), _to, _amount);\n', '        return true;\n', '      }\n', '\n', '      function createTokenByAtes(address _to, uint256 _amount, string _data) onlyOwnerOrAuthorized public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_amount > 0);\n', '        require(bytes(_data).length > 0);\n', '        require(MAX_TOKEN_SUPPLY >= totalSupply_ + _amount);\n', '\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        // KYC\n', '        frozens[_to] = true;\n', '        FrozenAddress(_to);\n', '\n', '        CreateTokenByAtes(_to, _amount, _data);\n', '        Transfer(address(0), _to, _amount);\n', '        return true;\n', '      }\n', '}']