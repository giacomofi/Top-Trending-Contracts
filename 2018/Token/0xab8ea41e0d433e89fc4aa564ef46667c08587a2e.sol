['/***\n', ' *     $$$$$$\\            $$\\       $$\\        $$$$$$\\            $$\\       $$\\ \n', ' *    $$  __$$\\           $$ |      $$ |      $$  __$$\\           $$ |      $$ |\n', ' *    $$ /  \\__| $$$$$$\\  $$$$$$$\\  $$$$$$$\\  $$ /  \\__| $$$$$$\\  $$ | $$$$$$$ |\n', ' *    $$ |      $$  __$$\\ $$  __$$\\ $$  __$$\\ $$ |$$$$\\ $$  __$$\\ $$ |$$  __$$ |\n', ' *    $$ |      $$$$$$$$ |$$ |  $$ |$$ |  $$ |$$ |\\_$$ |$$ /  $$ |$$ |$$ /  $$ |\n', ' *    $$ |  $$\\ $$   ____|$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |$$ |  $$ |\n', ' *    \\$$$$$$  |\\$$$$$$$\\ $$ |  $$ |$$ |  $$ |\\$$$$$$  |\\$$$$$$  |$$ |\\$$$$$$$ |\n', ' *     \\______/  \\_______|\\__|  \\__|\\__|  \\__| \\______/  \\______/ \\__| \\_______|\n', ' *                                                                              \n', ' *                                  by Cehhiro                                                                  \n', ' *                                                                              \n', ' */\n', '\n', 'pragma solidity ^ 0.4.24;\n', '\n', 'library ECRecovery {\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '    \n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20 is ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    uint _totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '\n', 'contract ERC891 is ERC20 {\n', '    using ECRecovery for bytes32;\n', '\n', '    uint public constant maxReward = 50 * 10**18;\n', '    mapping(address => bool) internal claimed;\n', '\n', '    function claim() public {\n', '        claimFor(msg.sender);\n', '    }\n', '\n', '    function claimFor(address _address) public returns(uint) {\n', '        require(!claimed[_address]);\n', '        \n', '        uint reward = checkFind(_address);\n', '        require(reward > 0);\n', '        \n', '        claimed[_address]   = true;\n', '        balances[_address]  = balances[_address].add(reward);\n', '        _totalSupply        = _totalSupply.add(reward);\n', '        \n', '        emit Transfer(address(0), _address, reward);\n', '        \n', '        return reward;\n', '    }\n', '\n', '    function checkFind(address _address) pure public returns(uint) {\n', '        uint maxBitRun  = 0;\n', '        uint data       = uint(bytes20(_address) & 0xffffffffffffffffff);\n', '        \n', '        while (data > 0) {\n', '            maxBitRun = maxBitRun + uint(data & 1);\n', '            data = uint(data & 1) == 1 ? data >> 1 : 0;\n', '        }\n', '        \n', '        return maxReward >> (18 * 4 - maxBitRun);\n', '    }\n', '\n', '    function claimWithSignature(bytes _sig) public {\n', '        bytes32 hash = bytes32(keccak256(abi.encodePacked(\n', '            "\\x19Ethereum Signed Message:\\n32",\n', '            keccak256(abi.encodePacked(msg.sender))\n', '        )));\n', '        \n', '        address minedAddress = hash.recover(_sig);\n', '        uint reward          = claimFor(minedAddress);\n', '\n', '        allowed[minedAddress][msg.sender] = reward;\n', '        transferFrom(minedAddress, msg.sender, reward);\n', '    }\n', '}\n', '\n', 'contract CehhGold is ERC891 {\n', '    string  public constant name        = "CehhGold";\n', '    string  public constant symbol      = "CEHH+";\n', '    uint    public constant decimals    = 18;\n', '    uint    public version              = 0;\n', '}']
['/***\n', ' *     $$$$$$\\            $$\\       $$\\        $$$$$$\\            $$\\       $$\\ \n', ' *    $$  __$$\\           $$ |      $$ |      $$  __$$\\           $$ |      $$ |\n', ' *    $$ /  \\__| $$$$$$\\  $$$$$$$\\  $$$$$$$\\  $$ /  \\__| $$$$$$\\  $$ | $$$$$$$ |\n', ' *    $$ |      $$  __$$\\ $$  __$$\\ $$  __$$\\ $$ |$$$$\\ $$  __$$\\ $$ |$$  __$$ |\n', ' *    $$ |      $$$$$$$$ |$$ |  $$ |$$ |  $$ |$$ |\\_$$ |$$ /  $$ |$$ |$$ /  $$ |\n', ' *    $$ |  $$\\ $$   ____|$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |$$ |  $$ |\n', ' *    \\$$$$$$  |\\$$$$$$$\\ $$ |  $$ |$$ |  $$ |\\$$$$$$  |\\$$$$$$  |$$ |\\$$$$$$$ |\n', ' *     \\______/  \\_______|\\__|  \\__|\\__|  \\__| \\______/  \\______/ \\__| \\_______|\n', ' *                                                                              \n', ' *                                  by Cehhiro                                                                  \n', ' *                                                                              \n', ' */\n', '\n', 'pragma solidity ^ 0.4.24;\n', '\n', 'library ECRecovery {\n', '  function recover(bytes32 hash, bytes sig) internal pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '    \n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint tokens, address token, bytes data) public;\n', '}\n', '\n', 'contract ERC20 is ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    uint _totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '\n', 'contract ERC891 is ERC20 {\n', '    using ECRecovery for bytes32;\n', '\n', '    uint public constant maxReward = 50 * 10**18;\n', '    mapping(address => bool) internal claimed;\n', '\n', '    function claim() public {\n', '        claimFor(msg.sender);\n', '    }\n', '\n', '    function claimFor(address _address) public returns(uint) {\n', '        require(!claimed[_address]);\n', '        \n', '        uint reward = checkFind(_address);\n', '        require(reward > 0);\n', '        \n', '        claimed[_address]   = true;\n', '        balances[_address]  = balances[_address].add(reward);\n', '        _totalSupply        = _totalSupply.add(reward);\n', '        \n', '        emit Transfer(address(0), _address, reward);\n', '        \n', '        return reward;\n', '    }\n', '\n', '    function checkFind(address _address) pure public returns(uint) {\n', '        uint maxBitRun  = 0;\n', '        uint data       = uint(bytes20(_address) & 0xffffffffffffffffff);\n', '        \n', '        while (data > 0) {\n', '            maxBitRun = maxBitRun + uint(data & 1);\n', '            data = uint(data & 1) == 1 ? data >> 1 : 0;\n', '        }\n', '        \n', '        return maxReward >> (18 * 4 - maxBitRun);\n', '    }\n', '\n', '    function claimWithSignature(bytes _sig) public {\n', '        bytes32 hash = bytes32(keccak256(abi.encodePacked(\n', '            "\\x19Ethereum Signed Message:\\n32",\n', '            keccak256(abi.encodePacked(msg.sender))\n', '        )));\n', '        \n', '        address minedAddress = hash.recover(_sig);\n', '        uint reward          = claimFor(minedAddress);\n', '\n', '        allowed[minedAddress][msg.sender] = reward;\n', '        transferFrom(minedAddress, msg.sender, reward);\n', '    }\n', '}\n', '\n', 'contract CehhGold is ERC891 {\n', '    string  public constant name        = "CehhGold";\n', '    string  public constant symbol      = "CEHH+";\n', '    uint    public constant decimals    = 18;\n', '    uint    public version              = 0;\n', '}']
