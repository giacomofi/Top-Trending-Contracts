['pragma solidity ^0.4.19;\n', '\n', '// Turn the usage of callcode\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract CreatorEnabled {\n', '    address public creator = 0x0;\n', '\n', '    modifier onlyCreator() { require(msg.sender==creator); _; }\n', '\n', '    function changeCreator(address _to) public onlyCreator {\n', '        creator = _to;\n', '    }\n', '}\n', '\n', '// ERC20 standard\n', 'contract StdToken is SafeMath {\n', '\n', '    mapping(address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint public totalSupply = 0;\n', '\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {\n', '      require(0x0!=_to);\n', '\n', '      balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '      balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {\n', '      require(0x0!=_to);\n', '\n', '      balances[_to] = safeAdd(balances[_to],_value);\n', '      balances[_from] = safeSub(balances[_from],_value);\n', '      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '      return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool) {\n', '      // To change the approve amount you first have to reduce the addresses`\n', '      //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '      //  already 0 to mitigate the race condition described here:\n', '      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '      require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint _size) {\n', '      require(msg.data.length >= _size + 4);\n', '      _;\n', '    }\n', '}\n', '\n', 'contract IGoldFee {\n', '    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);\n', '}\n', '\n', 'contract GoldFee is CreatorEnabled {\n', '\n', '    mapping(address => bool) exceptAddresses;\n', '\n', '    function GoldFee() {\n', '        creator = msg.sender;\n', '    }\n', '\n', '    function getMin(uint out)returns (uint) {\n', '        // 0.002 GOLD is min fee\n', '        uint minFee = (2 * 1 ether) / 1000;\n', '        if (out < minFee) {\n', '             return minFee;\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function getMax(uint out)returns (uint) {\n', '        // 0.02 GOLD is max fee\n', '        uint maxFee = (2 * 1 ether) / 100;\n', '        if (out >= maxFee) {\n', '             return maxFee;\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)\n', '    {\n', '       //if this is an excaptional address\n', '       if (exceptAddresses[_sender]) {\n', '            return 0;\n', '       }\n', '\n', '        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.\n', '        if (_isMigrationFinished) {\n', '             return (_value / 100);\n', '        }\n', '\n', '        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.\n', '\n', '        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,\n', '        // but not less than 0.002 MNTP\n', '\n', '        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,\n', '        // but not less than 0.002 MNTP\n', '\n', '        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,\n', '        // but not more than 0.02 MNTP\n', '        if (_mntpBalance >= (10000 * 1 ether)) {\n', '             return getMax((_value / 100) / 30);\n', '        }\n', '        if (_mntpBalance >= (1000 * 1 ether)) {\n', '             return getMin((_value / 100) / 30);\n', '        }\n', '        if (_mntpBalance >= (10 * 1 ether)) {\n', '             return getMin((_value / 100) / 3);\n', '        }\n', '\n', '        // 1%\n', '        return getMin(_value / 100);\n', '    }\n', '\n', '    function addExceptAddress(address _address) public onlyCreator {\n', '        exceptAddresses[_address] = true;\n', '    }\n', '\n', '    function removeExceptAddress(address _address) public onlyCreator {\n', '        exceptAddresses[_address] = false;\n', '    }\n', '\n', '    function isAddressExcept(address _address) public constant returns(bool) {\n', '        return exceptAddresses[_address];\n', '    }\n', '}\n', '\n', 'contract Gold is StdToken, CreatorEnabled {\n', '\n', '    string public constant name = "GoldMint GOLD cryptoasset";\n', '    string public constant symbol = "GOLD";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // this is used to send fees (that is then distributed as rewards)\n', '    address public migrationAddress = 0x0;\n', '    address public storageControllerAddress = 0x0;\n', '\n', '    address public goldmintTeamAddress = 0x0;\n', '    IMNTP public mntpToken;\n', '    IGoldFee public goldFee;\n', '\n', '\n', '    bool public transfersLocked = false;\n', '    bool public contractLocked = false;\n', '    bool public migrationStarted = false;\n', '    bool public migrationFinished = false;\n', '\n', '    uint public totalIssued = 0;\n', '    uint public totalBurnt = 0;\n', '\n', '    // Modifiers:\n', '    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }\n', '    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }\n', '    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }\n', '    modifier onlyIfUnlocked() { require(!transfersLocked); _; }\n', '\n', '    // Functions:\n', '    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {\n', '        creator = msg.sender;\n', '\n', '        mntpToken = IMNTP(_mntpContractAddress);\n', '        goldmintTeamAddress = _goldmintTeamAddress;\n', '        goldFee = IGoldFee(_goldFeeAddress);\n', '    }\n', '\n', '    function setCreator(address _address) public onlyCreator {\n', '       creator = _address;\n', '    }\n', '\n', '    function lockContract(bool _contractLocked) public onlyCreator {\n', '       contractLocked = _contractLocked;\n', '    }\n', '\n', '    function setStorageControllerContractAddress(address _address) public onlyCreator {\n', '        storageControllerAddress = _address;\n', '    }\n', '\n', '    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {\n', '        migrationAddress = _migrationAddress;\n', '    }\n', '\n', '    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {\n', '        goldmintTeamAddress = _teamAddress;\n', '    }\n', '\n', '    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {\n', '        goldFee = IGoldFee(_goldFeeAddress);\n', '    }\n', '\n', '    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {\n', '        require(!contractLocked);\n', '\n', '        balances[_who] = safeAdd(balances[_who],_tokens);\n', '        totalSupply = safeAdd(totalSupply,_tokens);\n', '        totalIssued = safeAdd(totalIssued,_tokens);\n', '\n', '        Transfer(0x0, _who, _tokens);\n', '    }\n', '\n', '    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {\n', '        require(!contractLocked);\n', '        balances[_who] = safeSub(balances[_who],_tokens);\n', '        totalSupply = safeSub(totalSupply,_tokens);\n', '        totalBurnt = safeAdd(totalBurnt,_tokens);\n', '    }\n', '\n', '    // there is no way to revert that\n', '    function startMigration() public onlyMigration {\n', '        require(false == migrationStarted);\n', '        migrationStarted = true;\n', '    }\n', '\n', '    // there is no way to revert that\n', '    function finishMigration() public onlyMigration {\n', '        require(true == migrationStarted);\n', '\n', '        migrationFinished = true;\n', '    }\n', '\n', '    function lockTransfer(bool _lock) public onlyMigration {\n', '        transfersLocked = _lock;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {\n', '\n', '        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);\n', '\n', '        // you can transfer if fee is ZERO\n', '        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\n', '        uint sendThis = _value;\n', '        if (0 != fee) {\n', '             sendThis = safeSub(_value,fee);\n', '\n', '             // 1.Transfer fee\n', '             // A -> rewards account\n', '             //\n', '             // Each GOLD token transfer should send transaction fee to\n', '             // GoldmintMigration contract if Migration process is not started.\n', '             // Goldmint team if Migration process is started.\n', '             if (migrationStarted) {\n', '                  super.transfer(goldmintTeamAddress, fee);\n', '             } else {\n', '                  super.transfer(migrationAddress, fee);\n', '             }\n', '        }\n', '\n', '        // 2.Transfer\n', '        // A -> B\n', '        return super.transfer(_to, sendThis);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {\n', '\n', '        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);\n', '\n', '        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\n', '        if (0 != fee) {\n', '             // 1.Transfer fee\n', '             // A -> rewards account\n', '             //\n', '             // Each GOLD token transfer should send transaction fee to\n', '             // GoldmintMigration contract if Migration process is not started.\n', '             // Goldmint team if Migration process is started.\n', '             if (migrationStarted) {\n', '                  super.transferFrom(_from, goldmintTeamAddress, fee);\n', '             } else {\n', '                  super.transferFrom(_from, migrationAddress, fee);\n', '             }\n', '        }\n', '\n', '        // 2.Transfer\n', '        // A -> B\n', '        uint sendThis = safeSub(_value,fee);\n', '        return super.transferFrom(_from, _to, sendThis);\n', '    }\n', '\n', '    // Used to send rewards)\n', '    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {\n', '        require(0x0!=_to);\n', '\n', '        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '        Transfer(migrationAddress, _to, _value);\n', '    }\n', '\n', '    // This is an emergency function that can be called by Creator only\n', '    function rescueAllRewards(address _to) public onlyCreator {\n', '        require(0x0!=_to);\n', '\n', '        uint totalReward = balances[migrationAddress];\n', '\n', '        balances[_to] = safeAdd(balances[_to],totalReward);\n', '        balances[migrationAddress] = 0;\n', '\n', '        Transfer(migrationAddress, _to, totalReward);\n', '    }\n', '\n', '\n', '    function getTotalIssued() public constant returns (uint) {\n', '        return totalIssued;\n', '    }\n', '\n', '    function getTotalBurnt() public constant returns (uint) {\n', '        return totalBurnt;\n', '    }\n', '}\n', '\n', 'contract IMNTP is StdToken {\n', '    // Additional methods that MNTP contract provides\n', '    function lockTransfer(bool _lock);\n', '    function issueTokens(address _who, uint _tokens);\n', '    function burnTokens(address _who, uint _tokens);\n', '}\n', '\n', 'contract GoldmintMigration is CreatorEnabled {\n', '    // Fields:\n', '    IMNTP public mntpToken;\n', '    Gold public goldToken;\n', '\n', '    enum State {\n', '        Init,\n', '        MigrationStarted,\n', '        MigrationPaused,\n', '        MigrationFinished\n', '    }\n', '\n', '    State public state = State.Init;\n', '\n', '    // this is total collected GOLD rewards (launch to migration start)\n', '    uint public mntpToMigrateTotal = 0;\n', '    uint public migrationRewardTotal = 0;\n', '    uint64 public migrationStartedTime = 0;\n', '    uint64 public migrationFinishedTime = 0;\n', '\n', '    struct Migration {\n', '        address ethAddress;\n', '        string gmAddress;\n', '        uint tokensCount;\n', '        bool migrated;\n', '        uint64 date;\n', '        string comment;\n', '    }\n', '\n', '    mapping (uint=>Migration) public mntpMigrations;\n', '    mapping (address=>uint) public mntpMigrationIndexes;\n', '    uint public mntpMigrationsCount = 0;\n', '\n', '    mapping (uint=>Migration) public goldMigrations;\n', '    mapping (address=>uint) public goldMigrationIndexes;\n', '    uint public goldMigrationsCount = 0;\n', '\n', '    event MntpMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);\n', '    event MntpMigrated(address _ethAddress, string _gmAddress, uint256 _value);\n', '\n', '    event GoldMigrateWanted(address _ethAddress, string _gmAddress, uint256 _value);\n', '    event GoldMigrated(address _ethAddress, string _gmAddress, uint256 _value);\n', '\n', '    // Access methods\n', '    function getMntpMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){\n', '        Migration memory mig = mntpMigrations[index];\n', '        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);\n', '    }\n', '\n', '    function getGoldMigration(uint index) public constant returns(address,string,uint,bool,uint64,string){\n', '        Migration memory mig = goldMigrations[index];\n', '        return (mig.ethAddress, mig.gmAddress, mig.tokensCount, mig.migrated, mig.date, mig.comment);\n', '    }\n', '\n', '    // Functions:\n', '    // Constructor\n', '    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {\n', '        creator = msg.sender;\n', '\n', '        require(_mntpContractAddress != 0);\n', '        require(_goldContractAddress != 0);\n', '\n', '        mntpMigrationIndexes[address(0x0)] = 0;\n', '        goldMigrationIndexes[address(0x0)] = 0;\n', '\n', '        mntpToken = IMNTP(_mntpContractAddress);\n', '        goldToken = Gold(_goldContractAddress);\n', '    }\n', '\n', '    function lockMntpTransfers(bool _lock) public onlyCreator {\n', '        mntpToken.lockTransfer(_lock);\n', '    }\n', '\n', '    function lockGoldTransfers(bool _lock) public onlyCreator {\n', '        goldToken.lockTransfer(_lock);\n', '    }\n', '\n', '    // This method is called when migration to Goldmint&#39;s blockchain\n', '    // process is started...\n', '    function startMigration() public onlyCreator {\n', '        require((State.Init == state) || (State.MigrationPaused == state));\n', '\n', '        if (State.Init == state) {\n', '             // 1 - change fees\n', '             goldToken.startMigration();\n', '\n', '             // 2 - store the current values\n', '             migrationRewardTotal = goldToken.balanceOf(this);\n', '             migrationStartedTime = uint64(now);\n', '             mntpToMigrateTotal = mntpToken.totalSupply();\n', '        }\n', '\n', '        state = State.MigrationStarted;\n', '    }\n', '\n', '    function pauseMigration() public onlyCreator {\n', '        require((state == State.MigrationStarted) || (state == State.MigrationFinished));\n', '\n', '        state = State.MigrationPaused;\n', '    }\n', '\n', '    // that doesn&#39;t mean that you cant migrate from Ethereum -> Goldmint blockchain\n', '    // that means that you will get no reward\n', '    function finishMigration() public onlyCreator {\n', '        require((State.MigrationStarted == state) || (State.MigrationPaused == state));\n', '\n', '        if (State.MigrationStarted == state) {\n', '             goldToken.finishMigration();\n', '             migrationFinishedTime = uint64(now);\n', '        }\n', '\n', '        state = State.MigrationFinished;\n', '    }\n', '\n', '    function destroyMe() public onlyCreator {\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    // MNTP\n', '    // Call this to migrate your MNTP tokens to Goldmint MNT\n', '    // (this is one-way only)\n', '    // _gmAddress is something like that - "BTS7yRXCkBjKxho57RCbqYE3nEiprWXXESw3Hxs5CKRnft8x7mdGi"\n', '    //\n', '    // !!! WARNING: will not allow anyone to migrate tokens partly\n', '    // !!! DISCLAIMER: check goldmint blockchain address format. You will not be able to change that!\n', '    function migrateMntp(string _gmAddress) public {\n', '        require((state==State.MigrationStarted) || (state==State.MigrationFinished));\n', '\n', '        // 1 - calculate current reward\n', '        uint myBalance = mntpToken.balanceOf(msg.sender);\n', '        require(0!=myBalance);\n', '\n', '        uint myRewardMax = calculateMyRewardMax(msg.sender);\n', '        uint myReward = calculateMyReward(myRewardMax);\n', '\n', '        // 2 - pay the reward to our user\n', '        goldToken.transferRewardWithoutFee(msg.sender, myReward);\n', '\n', '        // 3 - burn tokens\n', '        // WARNING: burn will reduce totalSupply\n', '        //\n', '        // WARNING: creator must call\n', '        // setIcoContractAddress(migrationContractAddress)\n', '        // of the mntpToken\n', '        mntpToken.burnTokens(msg.sender,myBalance);\n', '\n', '        // save tuple\n', '        Migration memory mig;\n', '        mig.ethAddress = msg.sender;\n', '        mig.gmAddress = _gmAddress;\n', '        mig.tokensCount = myBalance;\n', '        mig.migrated = false;\n', '        mig.date = uint64(now);\n', '        mig.comment = &#39;&#39;;\n', '\n', '        mntpMigrations[mntpMigrationsCount + 1] = mig;\n', '        mntpMigrationIndexes[msg.sender] = mntpMigrationsCount + 1;\n', '        mntpMigrationsCount++;\n', '\n', '        // send an event\n', '        MntpMigrateWanted(msg.sender, _gmAddress, myBalance);\n', '    }\n', '\n', '    function isMntpMigrated(address _who) public constant returns(bool) {\n', '        uint index = mntpMigrationIndexes[_who];\n', '\n', '        Migration memory mig = mntpMigrations[index];\n', '        return mig.migrated;\n', '    }\n', '\n', '    function setMntpMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {\n', '        uint index = mntpMigrationIndexes[_who];\n', '        require(index > 0);\n', '\n', '        mntpMigrations[index].migrated = _isMigrated;\n', '        mntpMigrations[index].comment = _comment;\n', '\n', '        // send an event\n', '        if (_isMigrated) {\n', '             MntpMigrated(  mntpMigrations[index].ethAddress,\n', '                            mntpMigrations[index].gmAddress,\n', '                            mntpMigrations[index].tokensCount);\n', '        }\n', '    }\n', '\n', '    // GOLD\n', '    function migrateGold(string _gmAddress) public {\n', '        require((state==State.MigrationStarted) || (state==State.MigrationFinished));\n', '\n', '        // 1 - get balance\n', '        uint myBalance = goldToken.balanceOf(msg.sender);\n', '        require(0!=myBalance);\n', '\n', '        // 2 - burn tokens\n', '        // WARNING: burn will reduce totalSupply\n', '        //\n', '        goldToken.burnTokens(msg.sender,myBalance);\n', '\n', '        // save tuple\n', '        Migration memory mig;\n', '        mig.ethAddress = msg.sender;\n', '        mig.gmAddress = _gmAddress;\n', '        mig.tokensCount = myBalance;\n', '        mig.migrated = false;\n', '        mig.date = uint64(now);\n', '        mig.comment = &#39;&#39;;\n', '\n', '        goldMigrations[goldMigrationsCount + 1] = mig;\n', '        goldMigrationIndexes[msg.sender] = goldMigrationsCount + 1;\n', '        goldMigrationsCount++;\n', '\n', '        // send an event\n', '        GoldMigrateWanted(msg.sender, _gmAddress, myBalance);\n', '    }\n', '\n', '    function isGoldMigrated(address _who) public constant returns(bool) {\n', '        uint index = goldMigrationIndexes[_who];\n', '\n', '        Migration memory mig = goldMigrations[index];\n', '        return mig.migrated;\n', '    }\n', '\n', '    function setGoldMigrated(address _who, bool _isMigrated, string _comment) public onlyCreator {\n', '        uint index = goldMigrationIndexes[_who];\n', '        require(index > 0);\n', '\n', '        goldMigrations[index].migrated = _isMigrated;\n', '        goldMigrations[index].comment = _comment;\n', '\n', '        // send an event\n', '        if (_isMigrated) {\n', '             GoldMigrated(  goldMigrations[index].ethAddress,\n', '                            goldMigrations[index].gmAddress,\n', '                            goldMigrations[index].tokensCount);\n', '        }\n', '    }\n', '\n', '    // Each MNTP token holder gets a GOLD reward as a percent of all rewards\n', '    // proportional to his MNTP token stake\n', '    function calculateMyRewardMax(address _of) public constant returns(uint){\n', '        if (0 == mntpToMigrateTotal) {\n', '             return 0;\n', '        }\n', '\n', '        uint myCurrentMntpBalance = mntpToken.balanceOf(_of);\n', '        if (0 == myCurrentMntpBalance) {\n', '             return 0;\n', '        }\n', '\n', '        return (migrationRewardTotal * myCurrentMntpBalance) / mntpToMigrateTotal;\n', '    }\n', '\n', '    //emergency function. used in case of a mistake to transfer all the reward to a new migraiton smart contract.\n', '    function transferReward(address _newContractAddress) public onlyCreator {\n', '      goldToken.transferRewardWithoutFee(_newContractAddress, goldToken.balanceOf(this));\n', '    }\n', '\n', '    // Migration rewards decreased linearly.\n', '    //\n', '    // The formula is: rewardPercents = max(100 - 100 * day / 365, 0)\n', '    //\n', '    // On 1st day of migration, you will get: 100 - 100 * 0/365 = 100% of your rewards\n', '    // On 2nd day of migration, you will get: 100 - 100 * 1/365 = 99.7261% of your rewards\n', '    // On 365th day of migration, you will get: 100 - 100 * 364/365 = 0.274%\n', '    function calculateMyRewardDecreased(uint _day, uint _myRewardMax) public constant returns(uint){\n', '        if (_day >= 365) {\n', '             return 0;\n', '        }\n', '\n', '        uint x = ((100 * 1000000000 * _day) / 365);\n', '        return (_myRewardMax * ((100 * 1000000000) - x)) / (100 * 1000000000);\n', '    }\n', '\n', '    function calculateMyReward(uint _myRewardMax) public constant returns(uint){\n', '        // day starts from 0\n', '        uint day = (uint64(now) - migrationStartedTime) / uint64(1 days);\n', '        return calculateMyRewardDecreased(day, _myRewardMax);\n', '    }\n', '\n', '    // do not allow to send money to this contract...\n', '    function() external payable {\n', '        revert();\n', '    }\n', '}']