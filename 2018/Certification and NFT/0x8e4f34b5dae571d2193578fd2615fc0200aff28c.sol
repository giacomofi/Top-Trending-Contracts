['pragma solidity ^0.4.23;\n', '\n', '/************************************************************************\n', '*********************** COMPTROLLER *************************************\n', '*************************************************************************\n', '\n', '   The Comptroller creates the DividendToken and DividendTokenLocker,\n', '   runs the CrowdSale, and can raise capital for Treasury.\n', '\n', '\n', 'THE CROWDSALE\n', '------------------------------------------------------------------------\n', '\n', '  The owner can configure the CrowdSale via .initSale().\n', '  Owner is allowed to change the terms of the CrowdSale at any time,\n', '  as long as it hasn&#39;t started yet. Configurable parameters are:\n', '    - dateSaleStarted: when the sale will start\n', '    - daleSaleEnded: when the sale will end\n', '    - softCap: amount required for the sale to be considered successful\n', '    - hardCap: maximum amount to be raised\n', '    - bonusCap: how many Ether the bonus period extends to\n', '    - capital: how many Ether to send to Treasury as capital\n', '\n', '  The CrowdSale is started as soon as one user buys tokens, and ends\n', '  if the hardCap is met, or dateSaleEnded is reached. The CrowdSale\n', '  will be considered "successful" if the SoftCap is reached. The \n', '  exchange rate is 1 Ether = 1 Token, plus a bonus amount that \n', '  starts at 50% for the 1st Ether, sliding down to 0% at `bonusCap`.\n', '\n', '  Upon a successful CrowdSale:\n', '    - Tokens are unfronzen\n', '    - Owner wallet gets 20% of tokens, which will vest for 600 days.\n', '    - `capitalPct` of raised funds go to Treasury\n', '    - the remaning Ether is sent to the owner wallet\n', '\n', '  Upon an unsuccessful CrowdSale:\n', '    - Tokens remain frozen\n', '    - Investors can call .getRefund() for a full refund\n', '    - Owner gets minted a ton of tokens (to maintain ~100% ownership)\n', '\n', 'RAISING CAPITAL\n', '------------------------------------------------------------------------\n', '\n', '  The Treasury has a method called .capitalNeeded(). This value is \n', '  changable by Admin, via a governance described in Treasury. When this\n', '  value is > 0, Comptroller will accept Ether in exchange for tokens at\n', '  a rate of 1 Ether per Token, until Treasury.capitalNeeded() is zero.\n', '\n', '  For each Ether raised, a token is minted, and the Ether is sent to\n', '  the Treasury as Capital.\n', '\n', '\n', 'PERMISSIONS\n', '------------------------------------------------------------------------\n', '\n', '  Comptroller owns the Token, and is only address that can call:\n', '    - token.mint(address, amount)\n', '        - Initially mints 1 token for the owner\n', '        - During CrowdSale\n', '        - When raising capital for Treasury\n', '    - token.burn(address, amount)\n', '        - never called\n', '\n', '  The following addresses have permission on Comptroller:\n', '    - Owner Wallet (permanent):\n', '        - Can set CrowdSale parameters, if it hasn&#39;t started yet.\n', '    - Anybody:\n', '        - During CrowdSale:\n', '            .fund(): Send Ether, get Tokens. Refunds on failure.\n', '            .endSale(): End the sales, provided conditions are met.\n', '        - After unsuccessful Crowdsale:\n', '            .refund(): Receive a full refund of amount sent to .fund()\n', '        - If Treasury.capitalNeeded() > 0\n', '            .fundCapital(): Send Ether, get Tokens. Refunds on failure.\n', '\n', 'CONCLUSION\n', '------------------------------------------------------------------------\n', '\n', '  The above description covers the entirety of this contract. There are\n', '  no emergency features or emergency stop gaps in the contract. All\n', '  addresses in this contract (wallet, treasury, token, locker) are \n', '  unchangable. If you find behavior in this contract that is incorrect,\n', '  do the right thing and let us know. Enjoy.\n', '\n', '  A full suite of tests can be found here:\n', '\n', '\n', '  And, ideally, this contract will have been audited by third parties.\n', '\n', '*************************************************************************/\n', '\n', '// This is the interface to the Treasury.\n', 'interface _ICompTreasury {\n', '    // after CrowdSale, will add funds to bankroll.\n', '    function addCapital() external payable;\n', '    // used to determine if Treasury wants to raise capital.\n', '    function capitalNeeded() external view returns (uint);\n', '}\n', 'contract Comptroller {\n', '    // These values are set in the constructor and can never be changed.\n', '    address public wallet;              // Wallet can call .initSale().\n', '    _ICompTreasury public treasury;     // Location of the treasury.\n', '    DividendToken public token;         // Token contract\n', '    DividendTokenLocker public locker;  // Locker that holds PennyEther&#39;s tokens.\n', '\n', '    // These values are set on .initSale()\n', '    uint public dateSaleStarted;    // date sale begins\n', '    uint public dateSaleEnded;      // date sale is endable\n', '    uint public softCap;            // sale considered successfull if amt met\n', '    uint public hardCap;            // will not raise more than this\n', '    uint public bonusCap;           // amt at which bonus ends\n', '    uint public capitalPctBips;     // amt to send to Treasury as capital (100 = 1%)\n', '\n', '    // CrowdSale Variables\n', '    uint public totalRaised;\n', '    bool public wasSaleStarted;             // True if sale was started\n', '    bool public wasSaleEnded;               // True if sale was ended\n', '    bool public wasSoftCapMet;              // True if softCap was met\n', '    // Stores amtFunded for useres contributing before softCap is met\n', '    mapping (address => uint) public amtFunded; \n', '\n', '    event Created(uint time, address wallet, address treasury, address token, address locker);\n', '    // CrowdSale Meta Events\n', '    event SaleInitalized(uint time);        // emitted when wallet calls .initSale()\n', '    event SaleStarted(uint time);           // emitted upon first tokens bought\n', '    event SaleSuccessful(uint time);        // emitted when sale ends (may happen early)\n', '    event SaleFailed(uint time);            // emitted if softCap not reached\n', '    // CrowdSale purchase\n', '    event BuyTokensSuccess(uint time, address indexed account, uint funded, uint numTokens);\n', '    event BuyTokensFailure(uint time, address indexed account, string reason);\n', '    // If user sends too much, or if .refund() called\n', '    event UserRefunded(uint time, address indexed account, uint refund);\n', '\n', '    constructor(address _wallet, address _treasury)\n', '        public\n', '    {\n', '        wallet = _wallet;\n', '        treasury = _ICompTreasury(_treasury);\n', '        token = new DividendToken("PennyEtherToken", "PENNY");\n', '        locker = new DividendTokenLocker(token, _wallet);\n', '        token.freeze(true);\n', '        emit Created(now, wallet, treasury, token, locker);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** WALLET (OWNER) FUNCTIONS *************************/\n', '    /*************************************************************/\n', '\n', '    // Sets parameters of the CrowdSale\n', '    // Cannot be called once the crowdsale has started.\n', '    function initSale(uint _dateStarted, uint _dateEnded, uint _softCap, uint _hardCap, uint _bonusCap, uint _capitalPctBips)\n', '        public\n', '    {\n', '        require(msg.sender == wallet);\n', '        require(!wasSaleStarted);\n', '        require(_softCap <= _hardCap);\n', '        require(_bonusCap <= _hardCap);\n', '        require(_capitalPctBips <= 10000);\n', '        dateSaleStarted = _dateStarted;\n', '        dateSaleEnded = _dateEnded;\n', '        softCap = _softCap;\n', '        hardCap = _hardCap;\n', '        bonusCap = _bonusCap;\n', '        capitalPctBips = _capitalPctBips;\n', '        emit SaleInitalized(now);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** DURING CROWDSALE *********************************/\n', '    /*************************************************************/\n', '\n', '    function () public payable {\n', '        fund();\n', '    }\n', '\n', '    // Allows the sender to buy tokens.\n', '    //\n', '    // Refunds if:\n', '    //  - CrowdSale start not defined, or time is before it.\n', '    //  - CrowdSale end date reached.\n', '    //  - CrowdSale HardCap has been met.\n', '    //  - Non-even amount of GWei sent.\n', '    //\n', '    // Otherwise:\n', '    //  - Starts sale (if it&#39;s not already started)\n', '    //  - Issues tokens to user (takes into account bonus period)\n', '    //  - If SoftCap not yet met, records amtFunded (so can refund)\n', '    //  - Refunds any excess amount sent (if HardCap was just met)\n', '    function fund()\n', '        public\n', '        payable\n', '    {\n', '        if (dateSaleStarted==0 || now < dateSaleStarted)\n', '            return _errorBuyingTokens("CrowdSale has not yet started.");\n', '        if (now > dateSaleEnded)\n', '            return _errorBuyingTokens("CrowdSale has ended.");\n', '        if (totalRaised >= hardCap)\n', '            return _errorBuyingTokens("HardCap has been reached.");\n', '        if (msg.value % 1000000000 != 0)\n', '            return _errorBuyingTokens("Must send an even amount of GWei.");\n', '\n', '        // Mark sale as started if haven&#39;t done so already.\n', '        if (!wasSaleStarted) {\n', '            wasSaleStarted = true;\n', '            emit SaleStarted(now);\n', '        }\n', '\n', '        // Only allow up to (hardCap - totalRaised) to be raised.\n', '        uint _amtToFund = (totalRaised + msg.value) > hardCap\n', '            ? hardCap - totalRaised\n', '            : msg.value;\n', '\n', '        // Mint the tokens for the user, increment totalRaised\n', '        uint _numTokens = getTokensFromEth(_amtToFund);\n', '        token.mint(msg.sender, _numTokens);\n', '        totalRaised += _amtToFund;\n', '        emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);\n', '\n', '        // Increment the amount they funded, if softCap not met.\n', '        if (totalRaised < softCap) {\n', '            amtFunded[msg.sender] += _amtToFund;\n', '        }\n', '\n', '        // Refund the user any amount sent over _amtToFund\n', '        uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;\n', '        if (_refund > 0){\n', '            require(msg.sender.call.value(_refund)());\n', '            emit UserRefunded(now, msg.sender, _refund);\n', '        }\n', '    }\n', '        \n', '    // Ends the CrowdSale. Callable by anyone.\n', '    //\n', '    // Throws if:\n', '    //   - Sale is not started, or sale is already ended.\n', '    //   - HardCap not met and sale end date not reached.\n', '    //\n', '    // If SoftCap met:\n', '    //   - Unfreezes tokens.\n', '    //   - Gives owners 20% in TokenLocker, vesting 600 days.\n', '    //   - Sends `capitalPctBip` to Treasury, as capital raised.\n', '    //   - Sends remaining funds to Owner Wallet\n', '    //\n', '    // If SoftCap not met:\n', '    //   - Mints a ton of tokens for owner (to maintain 100% ownership)\n', '    //   - Funders will be able to call .refund()\n', '    function endSale()\n', '        public\n', '    {\n', '        // Require sale has been started but not yet ended.\n', '        require(wasSaleStarted && !wasSaleEnded);\n', '        // Require hardCap met, or date is after sale ended.\n', '        require(totalRaised >= hardCap || now > dateSaleEnded);\n', '        \n', '        // Mark sale as over, and if it was successful.\n', '        wasSaleEnded = true;\n', '        wasSoftCapMet = totalRaised >= softCap;\n', '\n', '        // Softcap not met. Mint tokens so wallet owns ~100%.\n', '        if (!wasSoftCapMet) {\n', '            token.mint(wallet, 1e30);\n', '            emit SaleFailed(now);\n', '            return;\n', '        }\n', '\n', '        // Unfreeze tokens\n', '        token.freeze(false);\n', '\n', '        // Mint 1/4 to locker (resuling in 20%), and start vesting.\n', '        uint _lockerAmt = token.totalSupply() / 4;\n', '        token.mint(locker, _lockerAmt);\n', '        locker.startVesting(_lockerAmt, 600);   // vest for 600 days.\n', '\n', '        // Send up to `_capitalAmt` ETH to treasury as capital\n', '        uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;\n', '        if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;\n', '        treasury.addCapital.value(_capitalAmt)();\n', '        \n', '        // Send remaining balance to wallet\n', '        if (wallet.call.value(address(this).balance)()) {}\n', '        // Emit event once and forever\n', '        emit SaleSuccessful(now);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** AFTER CROWDSALE **********************************/\n', '    /*************************************************************/\n', '\n', '    // If softCap was not met, allow users to get full refund.\n', '    function refund()\n', '        public\n', '    {\n', '        // Ensure softCap not met, and user funded.\n', '        require(wasSaleEnded && !wasSoftCapMet);\n', '        require(amtFunded[msg.sender] > 0);\n', '        // Send the user the amount they funded, or throw\n', '        uint _amt = amtFunded[msg.sender];\n', '        amtFunded[msg.sender] = 0;\n', '        require(msg.sender.call.value(_amt)());\n', '        emit UserRefunded(now, msg.sender, _amt);\n', '    }\n', '\n', '    // Callable any time Treasury.capitalNeeded() > 0.\n', '    //\n', '    // For each Ether received, 1 Token is minted, and the Ether is sent\n', '    //  to the Treasury as Captial.\n', '    //\n', '    // Raising capital dilutes everyone, owners included, and as such\n', '    //  would only realistically happen if the raised funds are expected\n', '    //  to generate returns. Additionally, the Ether raised only goes to\n', '    //  Treasury -- 0 goes to the owners -- so there is no incentive to\n', '    //  raise capital other than to increase dividends.\n', '    function fundCapital()\n', '        public\n', '        payable\n', '    {\n', '        if (!wasSaleEnded)\n', '            return _errorBuyingTokens("Sale has not ended.");\n', '        if (!wasSoftCapMet)\n', '            return _errorBuyingTokens("SoftCap was not met.");\n', '            \n', '        // Cap _amount to the amount we need. Error if 0.\n', '        uint _amtNeeded = capitalFundable();\n', '        uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;\n', '        if (_amount == 0) {\n', '            return _errorBuyingTokens("No capital is needed.");\n', '        }\n', '\n', '        // Mint tokens, send capital.\n', '        totalRaised += _amount;\n', '        token.mint(msg.sender, _amount);\n', '        treasury.addCapital.value(_amount)();\n', '        emit BuyTokensSuccess(now, msg.sender, _amount, _amount);\n', '\n', '        // Refund excess\n', '        uint _refund = msg.value > _amount ? msg.value - _amount : 0;\n', '        if (_refund > 0) {\n', '            require(msg.sender.call.value(_refund)());\n', '            emit UserRefunded(now, msg.sender, _refund);\n', '        }\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** PRIVATE ******************************************/\n', '    /*************************************************************/\n', '\n', '    // Called when user cannot buy tokens.\n', '    // Returns nice error message and saves gas.\n', '    function _errorBuyingTokens(string _reason)\n', '        private\n', '    {\n', '        require(msg.sender.call.value(msg.value)());\n', '        emit BuyTokensFailure(now, msg.sender, _reason);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** PUBLIC VIEWS *************************************/\n', '    /*************************************************************/\n', '\n', '    // Returns the amount of Ether that can be sent to ".fundCapital()"\n', '    function capitalFundable()\n', '        public\n', '        view\n', '        returns (uint _amt)\n', '    {\n', '        return treasury.capitalNeeded();\n', '    }\n', '\n', '    // Returns the total amount of tokens minted at a given _ethAmt raised.\n', '    // This hard codes the following:\n', '    //   - Start at 50% bonus, linear decay to 0% bonus at bonusCap.\n', '    // The math behind it is explaind in comments.\n', '    function getTokensMintedAt(uint _ethAmt)\n', '        public\n', '        view\n', '        returns (uint _numTokens)\n', '    {\n', '        if (_ethAmt > hardCap) {\n', '            // Past HardCap. Return the full bonus amount, plus the rest\n', '            _numTokens = (5*bonusCap/4) + (hardCap - bonusCap);\n', '        } else if (_ethAmt > bonusCap) {\n', '            // Past Bonus Period. Return the full bonus amount, plus the non-bonus amt.\n', '            _numTokens = (5*bonusCap/4) + (_ethAmt - bonusCap);\n', '        } else {\n', '            // In Bonus period. Use a closed form integral to compute tokens.\n', '            //\n', '            //   First make a function for tokensPerEth:\n', '            //      tokensPerEth(x) = 3/2 - x/(2c), where c is bonusCap\n', '            //      Test: with c=20000: (0, 1.5), (10000, 1.25), (20000, 1)\n', '            //   Next, create a closed form integral:\n', '            //      integral(3/2 - x/(2c), x) = 3x/2 - x^2/(4c)\n', '            //      Test: with c=20000: (0, 0), (10000, 13750), (20000, 25000)\n', '            //\n', '            // Note: if _ethAmt = bonusCap, _numTokens = (5*bonusCap)/4\n', '            // Note: Overflows if _ethAmt^2 > 2^256, or ~3e38 Eth. Bonus Cap << 3e38\n', '            _numTokens = (3*_ethAmt/2) - (_ethAmt*_ethAmt)/(4*bonusCap);\n', '        }\n', '    }\n', '\n', '    // Returns how many tokens would be issued for _ethAmt sent,\n', '    // depending on current totalRaised.\n', '    function getTokensFromEth(uint _amt)\n', '        public\n', '        view\n', '        returns (uint _numTokens)\n', '    {\n', '        return getTokensMintedAt(totalRaised + _amt) - getTokensMintedAt(totalRaised);\n', '    }\n', '}\n', '\n', '\n', '/*\n', '  Standard ERC20 Token.\n', '  https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '*/\n', 'contract ERC20 {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    uint public totalSupply;\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '\n', '    event Created(uint time);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event Approval(address indexed owner, address indexed spender, uint amount);\n', '    event AllowanceUsed(address indexed owner, address indexed spender, uint amount);\n', '\n', '    constructor(string _name, string _symbol)\n', '        public\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        emit Created(now);\n', '    }\n', '\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Attempts to transfer `_value` from `_from` to `_to`\n', '    //  if `_from` has sufficient allowance for `msg.sender`.\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        address _spender = msg.sender;\n', '        require(allowance[_from][_spender] >= _value);\n', '        allowance[_from][_spender] -= _value;\n', '        emit AllowanceUsed(_from, _spender, _value);\n', '        return _transfer(_from, _to, _value);\n', '    }\n', '\n', '    // Transfers balance from `_from` to `_to` if `_to` has sufficient balance.\n', '    // Called from transfer() and transferFrom().\n', '    function _transfer(address _from, address _to, uint _value)\n', '        private\n', '        returns (bool success)\n', '    {\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface HasTokenFallback {\n', '    function tokenFallback(address _from, uint256 _amount, bytes _data)\n', '        external\n', '        returns (bool success);\n', '}\n', 'contract ERC667 is ERC20 {\n', '    constructor(string _name, string _symbol)\n', '        public\n', '        ERC20(_name, _symbol)\n', '    {}\n', '\n', '    function transferAndCall(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(super.transfer(_to, _value));\n', '        require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data));\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', '/*********************************************************\n', '******************* DIVIDEND TOKEN ***********************\n', '**********************************************************\n', '\n', 'An ERC20 token that can accept Ether and distribute it\n', 'perfectly to all Token Holders relative to each account&#39;s\n', 'balance at the time the dividend is received.\n', '\n', 'The Token is owned by the creator, and can be frozen,\n', 'minted, and burned by the owner.\n', '\n', 'Notes:\n', '    - Accounts can view or receive dividends owed at any time\n', '    - Dividends received are immediately credited to all\n', '      current Token Holders and can be redeemed at any time.\n', '    - Per above, upon transfers, dividends are not\n', '      transferred. They are kept by the original sender, and\n', '      not credited to the receiver.\n', '    - Uses "pull" instead of "push". Token holders must pull\n', '      their own dividends.\n', '\n', 'Comptroller Permissions:\n', '    - mintTokens(account, amt): via comp.fund() and comp.fundCapital()\n', '    - burnTokens(account, amt): via comp.burnTokens()\n', '    - setFrozen(true): Called before CrowdSale\n', '    - setFrozen(false): Called after CrowdSale, if softCap met\n', '*/\n', 'contract DividendToken is ERC667\n', '{\n', '    // if true, tokens cannot be transferred\n', '    bool public isFrozen;\n', '\n', '    // Comptroller can call .mintTokens() and .burnTokens().\n', '    address public comptroller = msg.sender;\n', '    modifier onlyComptroller(){ require(msg.sender==comptroller); _; }\n', '\n', '    // How dividends work:\n', '    //\n', '    // - A "point" is a fraction of a Wei (1e-32), it&#39;s used to reduce rounding errors.\n', '    //\n', '    // - totalPointsPerToken represents how many points each token is entitled to\n', '    //   from all the dividends ever received. Each time a new deposit is made, it\n', '    //   is incremented by the points oweable per token at the time of deposit:\n', '    //     (depositAmtInWei * POINTS_PER_WEI) / totalSupply\n', '    //\n', '    // - Each account has a `creditedPoints` and `lastPointsPerToken`\n', '    //   - lastPointsPerToken:\n', '    //       The value of totalPointsPerToken the last time `creditedPoints` was changed.\n', '    //   - creditedPoints:\n', '    //       How many points have been credited to the user. This is incremented by:\n', '    //         (`totalPointsPerToken` - `lastPointsPerToken` * balance) via\n', '    //         `.updateCreditedPoints(account)`. This occurs anytime the balance changes\n', '    //         (transfer, mint, burn).\n', '    //\n', '    // - .collectOwedDividends() calls .updateCreditedPoints(account), converts points\n', '    //   to wei and pays account, then resets creditedPoints[account] to 0.\n', '    //\n', '    // - "Credit" goes to Nick Johnson for the concept.\n', '    //\n', '    uint constant POINTS_PER_WEI = 1e32;\n', '    uint public dividendsTotal;\n', '    uint public dividendsCollected;\n', '    uint public totalPointsPerToken;\n', '    uint public totalBurned;\n', '    mapping (address => uint) public creditedPoints;\n', '    mapping (address => uint) public lastPointsPerToken;\n', '\n', '    // Events\n', '    event Frozen(uint time);\n', '    event UnFrozen(uint time);\n', '    event TokensMinted(uint time, address indexed account, uint amount, uint newTotalSupply);\n', '    event TokensBurned(uint time, address indexed account, uint amount, uint newTotalSupply);\n', '    event CollectedDividends(uint time, address indexed account, uint amount);\n', '    event DividendReceived(uint time, address indexed sender, uint amount);\n', '\n', '    constructor(string _name, string _symbol)\n', '        public\n', '        ERC667(_name, _symbol)\n', '    {}\n', '\n', '    // Upon receiving payment, increment lastPointsPerToken.\n', '    function ()\n', '        payable\n', '        public\n', '    {\n', '        if (msg.value == 0) return;\n', '        // POINTS_PER_WEI is 1e32.\n', '        // So, no multiplication overflow unless msg.value > 1e45 wei (1e27 ETH)\n', '        totalPointsPerToken += (msg.value * POINTS_PER_WEI) / totalSupply;\n', '        dividendsTotal += msg.value;\n', '        emit DividendReceived(now, msg.sender, msg.value);\n', '    }\n', '\n', '    /*************************************************************/\n', '    /******* COMPTROLLER FUNCTIONS *******************************/\n', '    /*************************************************************/\n', '    // Credits dividends, then mints more tokens.\n', '    function mint(address _to, uint _amount)\n', '        onlyComptroller\n', '        public\n', '    {\n', '        _updateCreditedPoints(_to);\n', '        totalSupply += _amount;\n', '        balanceOf[_to] += _amount;\n', '        emit TokensMinted(now, _to, _amount, totalSupply);\n', '    }\n', '    \n', '    // Credits dividends, burns tokens.\n', '    function burn(address _account, uint _amount)\n', '        onlyComptroller\n', '        public\n', '    {\n', '        require(balanceOf[_account] >= _amount);\n', '        _updateCreditedPoints(_account);\n', '        balanceOf[_account] -= _amount;\n', '        totalSupply -= _amount;\n', '        totalBurned += _amount;\n', '        emit TokensBurned(now, _account, _amount, totalSupply);\n', '    }\n', '\n', '    // when set to true, prevents tokens from being transferred\n', '    function freeze(bool _isFrozen)\n', '        onlyComptroller\n', '        public\n', '    {\n', '        if (isFrozen == _isFrozen) return;\n', '        isFrozen = _isFrozen;\n', '        if (_isFrozen) emit Frozen(now);\n', '        else emit UnFrozen(now);\n', '    }\n', '\n', '    /*************************************************************/\n', '    /********** PUBLIC FUNCTIONS *********************************/\n', '    /*************************************************************/\n', '    \n', '    // Normal ERC20 transfer, except before transferring\n', '    //  it credits points for both the sender and receiver.\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {   \n', '        // ensure tokens are not frozen.\n', '        require(!isFrozen);\n', '        _updateCreditedPoints(msg.sender);\n', '        _updateCreditedPoints(_to);\n', '        return ERC20.transfer(_to, _value);\n', '    }\n', '\n', '    // Normal ERC20 transferFrom, except before transferring\n', '    //  it credits points for both the sender and receiver.\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(!isFrozen);\n', '        _updateCreditedPoints(_from);\n', '        _updateCreditedPoints(_to);\n', '        return ERC20.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    // Normal ERC667 transferAndCall, except before transferring\n', '    //  it credits points for both the sender and receiver.\n', '    function transferAndCall(address _to, uint _value, bytes _data)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(!isFrozen);\n', '        _updateCreditedPoints(msg.sender);\n', '        _updateCreditedPoints(_to);\n', '        return ERC667.transferAndCall(_to, _value, _data);  \n', '    }\n', '\n', '    // Updates creditedPoints, sends all wei to the owner\n', '    function collectOwedDividends()\n', '        public\n', '        returns (uint _amount)\n', '    {\n', '        // update creditedPoints, store amount, and zero it.\n', '        _updateCreditedPoints(msg.sender);\n', '        _amount = creditedPoints[msg.sender] / POINTS_PER_WEI;\n', '        creditedPoints[msg.sender] = 0;\n', '        dividendsCollected += _amount;\n', '        emit CollectedDividends(now, msg.sender, _amount);\n', '        require(msg.sender.call.value(_amount)());\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********** PRIVATE METHODS / VIEWS **************************/\n', '    /*************************************************************/\n', '    // Credits _account with whatever dividend points they haven&#39;t yet been credited.\n', '    //  This needs to be called before any user&#39;s balance changes to ensure their\n', '    //  "lastPointsPerToken" credits their current balance, and not an altered one.\n', '    function _updateCreditedPoints(address _account)\n', '        private\n', '    {\n', '        creditedPoints[_account] += _getUncreditedPoints(_account);\n', '        lastPointsPerToken[_account] = totalPointsPerToken;\n', '    }\n', '\n', '    // For a given account, returns how many Wei they haven&#39;t yet been credited.\n', '    function _getUncreditedPoints(address _account)\n', '        private\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _pointsPerToken = totalPointsPerToken - lastPointsPerToken[_account];\n', '        // The upper bound on this number is:\n', '        //   ((1e32 * TOTAL_DIVIDEND_AMT) / totalSupply) * balances[_account]\n', '        // Since totalSupply >= balances[_account], this will overflow only if\n', '        //   TOTAL_DIVIDEND_AMT is around 1e45 wei. Not ever going to happen.\n', '        return _pointsPerToken * balanceOf[_account];\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /********* CONSTANTS *****************************************/\n', '    /*************************************************************/\n', '    // Returns how many wei a call to .collectOwedDividends() would transfer.\n', '    function getOwedDividends(address _account)\n', '        public\n', '        constant\n', '        returns (uint _amount)\n', '    {\n', '        return (_getUncreditedPoints(_account) + creditedPoints[_account])/POINTS_PER_WEI;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/*********************************************************\n', '*************** DIVIDEND TOKEN LOCKER ********************\n', '**********************************************************\n', '\n', 'This contract holds a balance of tokens and enforces that\n', 'the balance of tokens is always above the amount that has\n', 'not yet vested. All dividends are always collectable.\n', '\n', 'Owner Permissions:\n', '    - to collect all dividends\n', '    - to transfer tokens, such that some minimum balance\n', '      is maintained, as defined by the vesting parameters\n', '\n', 'Comptroller Permissions:\n', '    - Specifies the token and owner\n', '    - Specifies the amount to vest, and over what period\n', '*/\n', 'contract IDividendToken {\n', '    function collectOwedDividends() external returns (uint);\n', '    function transfer(address _to, uint _value) external;\n', '    function balanceOf(address _addr) external view returns (uint);\n', '}\n', 'contract DividendTokenLocker {\n', '    // set in the constructor\n', '    address public comptroller;\n', '    address public owner;\n', '    IDividendToken public token;\n', '    // set by comptroller via .setVesting()\n', '    uint public vestingAmt;\n', '    uint public vestingStartDay;\n', '    uint public vestingDays;\n', '\n', '    // events, for transparency\n', '    event Created(uint time, address comptroller, address token, address owner);\n', '    event VestingStarted(uint time, uint numTokens, uint vestingDays);\n', '    event Transferred(uint time, address recipient, uint numTokens);\n', '    event Collected(uint time, address recipient, uint amount);\n', '    \n', '    // Initialize the comptroller, token, and owner addresses.\n', '    constructor(address _token, address _owner)\n', '        public\n', '    {\n', '        comptroller = msg.sender;\n', '        token = IDividendToken(_token);\n', '        owner = _owner;\n', '        emit Created(now, comptroller, token, owner);\n', '    }\n', '\n', '    // Allow this contract to get sent Ether (eg, dividendsOwed)\n', '    function () payable public {}\n', '\n', '\n', '    /***************************************************/\n', '    /*********** CREATOR FUNCTIONS *********************/\n', '    /***************************************************/\n', '\n', '    // Starts the vesting process for the current balance.\n', '    // TokenLocker will ensure a minimum balance is maintained\n', '    //  based off of the vestingAmt and vestingDays.\n', '    function startVesting(uint _numTokens, uint _vestingDays)\n', '        public\n', '    {\n', '        require(msg.sender == comptroller);\n', '        vestingAmt = _numTokens;\n', '        vestingStartDay = _today();\n', '        vestingDays = _vestingDays;\n', '        emit VestingStarted(now, _numTokens, _vestingDays);\n', '    }\n', '\n', '\n', '    /***************************************************/\n', '    /*********** OWNER FUNCTIONS ***********************/\n', '    /***************************************************/\n', '\n', '    // Allows the owner to collect the balance of this contract,\n', '    //  including any owed dividends.\n', '    function collect()\n', '        public\n', '    {\n', '        require(msg.sender == owner);\n', '        // Collect dividends, and get new balance.\n', '        token.collectOwedDividends();\n', '        uint _amount = address(this).balance;\n', '\n', '        // Send amount (if any), emit event.\n', '        if (_amount > 0) require(owner.call.value(_amount)());\n', '        emit Collected(now, owner, _amount);\n', '    }\n', '\n', '    // Allows the owner to transfer tokens, such that the\n', '    //  balance of tokens cannot go below getMinTokenBalance().\n', '    function transfer(address _to, uint _numTokens)\n', '        public\n', '    {\n', '        require(msg.sender == owner);\n', '        uint _available = tokensAvailable();\n', '        if (_numTokens > _available) _numTokens = _available;\n', '\n', '        // Transfer (if _numTokens > 0), and emit event.\n', '        if (_numTokens > 0) {\n', '            token.transfer(_to, _numTokens);\n', '        }\n', '        emit Transferred(now, _to, _numTokens);\n', '    }\n', '\n', '\n', '    /***************************************************/\n', '    /*********** VIEWS *********************************/\n', '    /***************************************************/\n', '\n', '    function tokens()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return token.balanceOf(this);\n', '    }\n', '\n', '    // Returns the minimum allowed tokenBalance.\n', '    // Starts at vestingAmt, goes to 0 after vestingDays.\n', '    function tokensUnvested()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return vestingAmt - tokensVested();\n', '    }\n', '\n', '    // Returns how many tokens have vested.\n', '    // Starts at 0, goes to vestingAmt after vestingDays.\n', '    function tokensVested()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint _daysElapsed = _today() - vestingStartDay;\n', '        return _daysElapsed >= vestingDays\n', '            ? vestingAmt\n', '            : (vestingAmt * _daysElapsed) / vestingDays;\n', '    }\n', '\n', '    // Returns the amount of tokens available to be transferred.\n', '    // This is the balance, minus how many tokens must be maintained due to vesting.\n', '    function tokensAvailable()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        // token.balanceOf() and getMinTokenBalance() can never be greater than\n', '        //   all the Ether in the world, so we dont worry about overflow.\n', '        int _available = int(tokens()) - int(tokensUnvested());\n', '        return _available > 0 ? uint(_available) : 0;\n', '    }\n', '\n', '    // Returns the current day.\n', '    function _today()\n', '        private \n', '        view \n', '        returns (uint)\n', '    {\n', '        return now / 1 days;\n', '    }\n', '}']