['pragma solidity ^0.4.20;\n', '\n', 'contract ERC20Interface {\n', ' \n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Common uitility functions\n', '// ----------------------------------------------------------------------------\n', 'contract Common {\n', '    \n', '    function Common() internal {\n', '\n', '    }\n', '\n', '    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {\n', '        for (uint i = 0; i < list.length; i++) {\n', '            if (list[i] == addr) {\n', '                return int(i);\n', '            }\n', '        }\n', '        return -1;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    address public operator;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    event OperatorTransfered(address indexed _from, address indexed _to);\n', '\n', '    function Owned() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrOperator {\n', '        require(msg.sender == owner || msg.sender == operator);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function transferOperator(address _newOperator) public onlyOwner {\n', '        address originalOperator = operator;\n', '        operator = _newOperator;\n', '        OperatorTransfered(originalOperator, _newOperator);\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract TokenHeld {\n', '    \n', '    address[] public addressIndices;\n', '\n', '    event OnPushedAddress(address addr, uint index);\n', '\n', '    function TokenHeld() internal {\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Scan the addressIndices for ensuring the target address is included\n', '    // ------------------------------------------------------------------------\n', '    function scanAddresses(address addr) internal {\n', '        bool isAddrExist = false;\n', '        for (uint i = 0;i < addressIndices.length; i++) {\n', '            if (addressIndices[i] == addr) {\n', '                isAddrExist = true;\n', '                break;\n', '            }\n', '        }\n', '        if (isAddrExist == false) {\n', '            addressIndices.push(addr);\n', '            OnPushedAddress(addr, addressIndices.length);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Restricted is Common, Owned {\n', '\n', '    bool isChargingTokenTransferFee;\n', '    bool isAllocatingInterest;\n', '    bool isChargingManagementFee;\n', '    bool isTokenTransferOpen;\n', '\n', '    address[] tokenTransferDisallowedAddresses;\n', '\n', '    event OnIsChargingTokenTransferFeeUpdated(bool from, bool to);\n', '    event OnIsAllocatingInterestUpdated(bool from, bool to);\n', '    event OnIsChargingManagementFeeUpdated(bool from, bool to);\n', '    event OnIsTokenTransferOpenUpdated(bool from, bool to);\n', '    event OnTransferDisallowedAddressesChanged(string action, address indexed addr);\n', '    \n', '    modifier onlyWhenAllocatingInterestOpen {\n', '        require(isAllocatingInterest == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenChargingManagementFeeOpen {\n', '        require(isChargingManagementFee == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenTokenTransferOpen {\n', '        require(isTokenTransferOpen == true);\n', '        _;\n', '    }\n', '\n', '    modifier shouldBeAllowed(address[] list, address addr) {\n', '        require(getIndexOfTarget(list, addr) == -1);\n', '        _;\n', '    }\n', '    \n', '    function Restricted() internal {\n', '        isChargingTokenTransferFee = false;\n', '        isAllocatingInterest = false;\n', '        isChargingManagementFee = false;\n', '        isTokenTransferOpen = true;\n', '    }\n', '    \n', '    function setIsChargingTokenTransferFee(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isChargingTokenTransferFee;\n', '        isChargingTokenTransferFee = onOff;\n', '        OnIsChargingTokenTransferFeeUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsAllocatingInterest(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isAllocatingInterest;\n', '        isAllocatingInterest = onOff;\n', '        OnIsAllocatingInterestUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsChargingManagementFee(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isChargingManagementFee;\n', '        isChargingManagementFee = onOff;\n', '        OnIsChargingManagementFeeUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsTokenTransferOpen(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isTokenTransferOpen;\n', '        isTokenTransferOpen = onOff;\n', '        OnIsTokenTransferOpenUpdated(original, onOff);\n', '    }\n', '\n', '    function addToTokenTransferDisallowedList(address addr) public onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\n', '        if (idx == -1) {\n', '            tokenTransferDisallowedAddresses.push(addr);\n', '            OnTransferDisallowedAddressesChanged("add", addr);\n', '        }\n', '    }\n', '\n', '    function removeFromTokenTransferDisallowedAddresses(address addr) public onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\n', '        if (idx >= 0) {\n', '            uint uidx = uint(idx);\n', '            delete tokenTransferDisallowedAddresses[uidx];\n', '            OnTransferDisallowedAddressesChanged("remove", addr);\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenTransaction is Common, Owned {\n', '\n', '    bool isTokenTransactionOpen;\n', '\n', '    address[] transactionDisallowedAddresses;\n', '\n', '    uint exchangeRateFor1Eth;\n', '\n', '    event OnIsTokenTransactionOpenUpdated(bool from, bool to);\n', '    event OnTransactionDisallowedAddressesChanged(string action, address indexed addr);\n', '    event OnExchangeRateUpdated(uint from, uint to);\n', '\n', '    modifier onlyWhenTokenTransactionOpen {\n', '        require(isTokenTransactionOpen == true);\n', '        _;\n', '    }\n', '\n', '    function TokenTransaction() internal {\n', '        isTokenTransactionOpen = true;\n', '        exchangeRateFor1Eth = 1000;\n', '    }\n', '\n', '    function setIsTokenTransactionOpen(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isTokenTransactionOpen;\n', '        isTokenTransactionOpen = onOff;\n', '        OnIsTokenTransactionOpenUpdated(original, onOff);\n', '    }\n', '\n', '    function addToTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\n', '        if (idx == -1) {\n', '            transactionDisallowedAddresses.push(addr);\n', '            OnTransactionDisallowedAddressesChanged("add", addr);\n', '        }\n', '    }\n', '\n', '    function removeFromTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\n', '        if (idx >= 0) {\n', '            uint uidx = uint(idx);\n', '            delete transactionDisallowedAddresses[uidx];\n', '            OnTransactionDisallowedAddressesChanged("remove", addr);\n', '        }\n', '    }\n', '\n', '    function updateExchangeRate(uint newExchangeRate) public onlyOwner {\n', '        uint originalRate = exchangeRateFor1Eth;\n', '        exchangeRateFor1Eth = newExchangeRate;\n', '        OnExchangeRateUpdated(originalRate, newExchangeRate);\n', '    }\n', '}\n', '\n', 'contract Distributed is Owned {\n', '    using SafeMath for uint;\n', '    \n', '    // Allocation related\n', '    uint tokenTransferPercentageNumerator;\n', '    uint tokenTransferPercentageDenominator;\n', '    uint interestAllocationPercentageNumerator;\n', '    uint interestAllocationPercentageDenominator;\n', '    uint managementFeeChargePercentageNumerator;\n', '    uint managementFeeChargePercentageDenominator;\n', '\n', '    uint distCompanyPercentage;\n', '    uint distTeamPercentage;\n', '    uint distOfferPercentage;\n', '\n', '    event OnPercentageChanged(string state, uint _m, uint _d, uint m, uint d);\n', '    event OnDistributionChanged(uint _c, uint _t, uint _o, uint c, uint t, uint o);\n', '    \n', '    modifier onlyWhenPercentageSettingIsValid(uint c, uint t, uint o) {\n', '        require((c.add(t).add(o)) == 100);\n', '        _;\n', '    }\n', '\n', '    function Distributed() internal {\n', '\n', '        tokenTransferPercentageNumerator = 1;\n', '        tokenTransferPercentageDenominator = 100;\n', '        interestAllocationPercentageNumerator = 1;\n', '        interestAllocationPercentageDenominator = 100;\n', '        managementFeeChargePercentageNumerator = 1;\n', '        managementFeeChargePercentageDenominator = 100;\n', '\n', '        distCompanyPercentage = 20;\n', '        distTeamPercentage = 10;\n', '        distOfferPercentage = 70;\n', '    }\n', '\n', '    function setTokenTransferPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = tokenTransferPercentageNumerator;\n', '        uint d = tokenTransferPercentageDenominator;\n', '        tokenTransferPercentageNumerator = numerator;\n', '        tokenTransferPercentageDenominator = denominator;\n', '        OnPercentageChanged("TokenTransferFee", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setInterestAllocationPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = interestAllocationPercentageNumerator;\n', '        uint d = interestAllocationPercentageDenominator;\n', '        interestAllocationPercentageNumerator = numerator;\n', '        interestAllocationPercentageDenominator = denominator;\n', '        OnPercentageChanged("InterestAllocation", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setManagementFeeChargePercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = managementFeeChargePercentageNumerator;\n', '        uint d = managementFeeChargePercentageDenominator;\n', '        managementFeeChargePercentageNumerator = numerator;\n', '        managementFeeChargePercentageDenominator = denominator;\n', '        OnPercentageChanged("ManagementFee", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setDistributionPercentage(uint c, uint t, uint o) public onlyWhenPercentageSettingIsValid(c, t, o) onlyOwner {\n', '        uint _c = distCompanyPercentage;\n', '        uint _t = distTeamPercentage;\n', '        uint _o = distOfferPercentage;\n', '        distCompanyPercentage = c;\n', '        distTeamPercentage = t;\n', '        distOfferPercentage = o;\n', '        OnDistributionChanged(_c, _t, _o, distCompanyPercentage, distTeamPercentage, distOfferPercentage);\n', '    }\n', '}\n', '\n', 'contract FeeCalculation {\n', '    using SafeMath for uint;\n', '    \n', '    function FeeCalculation() internal {\n', '\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate the fee tokens for transferring.\n', '    // ------------------------------------------------------------------------\n', '    function calculateTransferFee(uint tokens) internal pure returns (uint) {\n', '        uint calFee = 0;\n', '        if (tokens > 0 && tokens <= 1000)\n', '            calFee = 1;\n', '        else if (tokens > 1000 && tokens <= 5000)\n', '            calFee = tokens.mul(1).div(1000);\n', '        else if (tokens > 5000 && tokens <= 10000)\n', '            calFee = tokens.mul(2).div(1000);\n', '        else if (tokens > 10000)\n', '            calFee = 30;\n', '        return calFee;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// initial fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract FixedSupplyToken is ERC20Interface, Distributed, TokenHeld, Restricted, TokenTransaction, FeeCalculation {\n', '    using SafeMath for uint;\n', '\n', '    // Token information related\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    event OnAllocated(address indexed addr, uint allocatedTokens);\n', '    event OnCharged(address indexed addr, uint chargedTokens);\n', '    \n', '    modifier onlyWhenOfferredIsLowerThanDistOfferPercentage {\n', '        uint expectedTokens = msg.value.mul(1000);\n', '        uint totalOfferredTokens = 0;\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            totalOfferredTokens += balances[addressIndices[i]];\n', '        }\n', '        require(_totalSupply.mul(distOfferPercentage).div(100) - expectedTokens >= 0);\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function FixedSupplyToken() public {\n', '        symbol = "AGC";\n', '        name = "Agile Coin";\n', '        decimals = 0;\n', '        _totalSupply = 100000000 * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        uint balance = balances[address(0)];\n', '        return _totalSupply - balance;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from token owner&#39;s account to `to` account\n', '    // - Owner&#39;s account must have sufficient balance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(transactionDisallowedAddresses, msg.sender) returns (bool success) {\n', '        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\n', '        scanAddresses(to);\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens + calFee);\n', '\t\tbalances[owner] = balances[owner].add(calFee);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        Transfer(msg.sender, owner, calFee);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(tokenTransferDisallowedAddresses, msg.sender) returns (bool success) {\n', '        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\n', '        scanAddresses(to);\n', '        balances[from] = balances[from].sub(tokens + calFee);\n', '        balances[owner] = balances[owner].add(calFee);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(from, to, tokens);\n', '        Transfer(from, owner, calFee);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account. The `spender` contract function\n', '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Don&#39;t accept ETH\n', '    // ------------------------------------------------------------------------\n', '    function () public payable onlyWhenTokenTransactionOpen onlyWhenOfferredIsLowerThanDistOfferPercentage {\n', '        // Exchange: ETH --> ETTA Coin\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Allocate interest.\n', '    // ------------------------------------------------------------------------\n', '    function allocateTokens() public onlyOwnerOrOperator onlyWhenAllocatingInterestOpen {\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            address crntAddr = addressIndices[i];\n', '            uint balanceOfCrntAddr = balances[crntAddr];\n', '            uint allocatedTokens = balanceOfCrntAddr.mul(interestAllocationPercentageNumerator).div(interestAllocationPercentageDenominator);\n', '            balances[crntAddr] = balances[crntAddr].add(allocatedTokens);\n', '            balances[owner] = balances[owner].sub(allocatedTokens);\n', '            Transfer(owner, crntAddr, allocatedTokens);\n', '            OnAllocated(crntAddr, allocatedTokens);\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Charge investers for management fee.\n', '    // ------------------------------------------------------------------------\n', '    function chargeTokensForManagement() public onlyOwnerOrOperator onlyWhenChargingManagementFeeOpen {\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            address crntAddr = addressIndices[i];\n', '            uint balanceOfCrntAddr = balances[crntAddr];\n', '            uint chargedTokens = balanceOfCrntAddr.mul(managementFeeChargePercentageNumerator).div(managementFeeChargePercentageDenominator);\n', '            balances[crntAddr] = balances[crntAddr].sub(chargedTokens);\n', '            balances[owner] = balances[owner].add(chargedTokens);\n', '            Transfer(crntAddr,owner, chargedTokens);\n', '            OnCharged(crntAddr, chargedTokens);\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Distribute more token of contract and transfer to owner \n', '    // ------------------------------------------------------------------------\n', '    function mintToken(uint256 mintedAmount) public onlyOwner {\n', '        require(mintedAmount > 0);\n', '        balances[owner] = balances[owner].add(mintedAmount);\n', '        _totalSupply = _totalSupply.add(mintedAmount);\n', '        Transfer(address(0), owner, mintedAmount);\n', '    }\n', '\n', '    event OnTokenBurned(uint256 totalBurnedTokens);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Remove `numerator / denominator` % of tokens from the system irreversibly\n', '    // ------------------------------------------------------------------------\n', '    function burnByPercentage(uint8 m, uint8 d) public onlyOwner returns (bool success) {\n', '        require(m > 0 && d > 0 && m <= d);\n', '        uint totalBurnedTokens = balances[owner].mul(m).div(d);\n', '        balances[owner] = balances[owner].sub(totalBurnedTokens);\n', '        _totalSupply = _totalSupply.sub(totalBurnedTokens);\n', '        Transfer(owner, address(0), totalBurnedTokens);\n', '        OnTokenBurned(totalBurnedTokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Remove a quantity of tokens\n', '    // ------------------------------------------------------------------------\n', '    function burnByAmount(uint256 tokens) public onlyOwner returns (bool success) {\n', '        require(tokens > 0 && tokens <= balances[owner]);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        _totalSupply = _totalSupply.sub(tokens);\n', '        Transfer(owner, address(0), tokens);\n', '        OnTokenBurned(tokens);\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', 'contract ERC20Interface {\n', ' \n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Common uitility functions\n', '// ----------------------------------------------------------------------------\n', 'contract Common {\n', '    \n', '    function Common() internal {\n', '\n', '    }\n', '\n', '    function getIndexOfTarget(address[] list, address addr) internal pure returns (int) {\n', '        for (uint i = 0; i < list.length; i++) {\n', '            if (list[i] == addr) {\n', '                return int(i);\n', '            }\n', '        }\n', '        return -1;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    address public operator;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    event OperatorTransfered(address indexed _from, address indexed _to);\n', '\n', '    function Owned() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrOperator {\n', '        require(msg.sender == owner || msg.sender == operator);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function transferOperator(address _newOperator) public onlyOwner {\n', '        address originalOperator = operator;\n', '        operator = _newOperator;\n', '        OperatorTransfered(originalOperator, _newOperator);\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract TokenHeld {\n', '    \n', '    address[] public addressIndices;\n', '\n', '    event OnPushedAddress(address addr, uint index);\n', '\n', '    function TokenHeld() internal {\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Scan the addressIndices for ensuring the target address is included\n', '    // ------------------------------------------------------------------------\n', '    function scanAddresses(address addr) internal {\n', '        bool isAddrExist = false;\n', '        for (uint i = 0;i < addressIndices.length; i++) {\n', '            if (addressIndices[i] == addr) {\n', '                isAddrExist = true;\n', '                break;\n', '            }\n', '        }\n', '        if (isAddrExist == false) {\n', '            addressIndices.push(addr);\n', '            OnPushedAddress(addr, addressIndices.length);\n', '        }\n', '    }\n', '}\n', '\n', 'contract Restricted is Common, Owned {\n', '\n', '    bool isChargingTokenTransferFee;\n', '    bool isAllocatingInterest;\n', '    bool isChargingManagementFee;\n', '    bool isTokenTransferOpen;\n', '\n', '    address[] tokenTransferDisallowedAddresses;\n', '\n', '    event OnIsChargingTokenTransferFeeUpdated(bool from, bool to);\n', '    event OnIsAllocatingInterestUpdated(bool from, bool to);\n', '    event OnIsChargingManagementFeeUpdated(bool from, bool to);\n', '    event OnIsTokenTransferOpenUpdated(bool from, bool to);\n', '    event OnTransferDisallowedAddressesChanged(string action, address indexed addr);\n', '    \n', '    modifier onlyWhenAllocatingInterestOpen {\n', '        require(isAllocatingInterest == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenChargingManagementFeeOpen {\n', '        require(isChargingManagementFee == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenTokenTransferOpen {\n', '        require(isTokenTransferOpen == true);\n', '        _;\n', '    }\n', '\n', '    modifier shouldBeAllowed(address[] list, address addr) {\n', '        require(getIndexOfTarget(list, addr) == -1);\n', '        _;\n', '    }\n', '    \n', '    function Restricted() internal {\n', '        isChargingTokenTransferFee = false;\n', '        isAllocatingInterest = false;\n', '        isChargingManagementFee = false;\n', '        isTokenTransferOpen = true;\n', '    }\n', '    \n', '    function setIsChargingTokenTransferFee(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isChargingTokenTransferFee;\n', '        isChargingTokenTransferFee = onOff;\n', '        OnIsChargingTokenTransferFeeUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsAllocatingInterest(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isAllocatingInterest;\n', '        isAllocatingInterest = onOff;\n', '        OnIsAllocatingInterestUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsChargingManagementFee(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isChargingManagementFee;\n', '        isChargingManagementFee = onOff;\n', '        OnIsChargingManagementFeeUpdated(original, onOff);\n', '    }\n', '\n', '    function setIsTokenTransferOpen(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isTokenTransferOpen;\n', '        isTokenTransferOpen = onOff;\n', '        OnIsTokenTransferOpenUpdated(original, onOff);\n', '    }\n', '\n', '    function addToTokenTransferDisallowedList(address addr) public onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\n', '        if (idx == -1) {\n', '            tokenTransferDisallowedAddresses.push(addr);\n', '            OnTransferDisallowedAddressesChanged("add", addr);\n', '        }\n', '    }\n', '\n', '    function removeFromTokenTransferDisallowedAddresses(address addr) public onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(tokenTransferDisallowedAddresses, addr);\n', '        if (idx >= 0) {\n', '            uint uidx = uint(idx);\n', '            delete tokenTransferDisallowedAddresses[uidx];\n', '            OnTransferDisallowedAddressesChanged("remove", addr);\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenTransaction is Common, Owned {\n', '\n', '    bool isTokenTransactionOpen;\n', '\n', '    address[] transactionDisallowedAddresses;\n', '\n', '    uint exchangeRateFor1Eth;\n', '\n', '    event OnIsTokenTransactionOpenUpdated(bool from, bool to);\n', '    event OnTransactionDisallowedAddressesChanged(string action, address indexed addr);\n', '    event OnExchangeRateUpdated(uint from, uint to);\n', '\n', '    modifier onlyWhenTokenTransactionOpen {\n', '        require(isTokenTransactionOpen == true);\n', '        _;\n', '    }\n', '\n', '    function TokenTransaction() internal {\n', '        isTokenTransactionOpen = true;\n', '        exchangeRateFor1Eth = 1000;\n', '    }\n', '\n', '    function setIsTokenTransactionOpen(bool onOff) public onlyOwnerOrOperator {\n', '        bool original = isTokenTransactionOpen;\n', '        isTokenTransactionOpen = onOff;\n', '        OnIsTokenTransactionOpenUpdated(original, onOff);\n', '    }\n', '\n', '    function addToTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\n', '        if (idx == -1) {\n', '            transactionDisallowedAddresses.push(addr);\n', '            OnTransactionDisallowedAddressesChanged("add", addr);\n', '        }\n', '    }\n', '\n', '    function removeFromTransactionDisallowedList(address addr) public constant onlyOwnerOrOperator {\n', '        int idx = getIndexOfTarget(transactionDisallowedAddresses, addr);\n', '        if (idx >= 0) {\n', '            uint uidx = uint(idx);\n', '            delete transactionDisallowedAddresses[uidx];\n', '            OnTransactionDisallowedAddressesChanged("remove", addr);\n', '        }\n', '    }\n', '\n', '    function updateExchangeRate(uint newExchangeRate) public onlyOwner {\n', '        uint originalRate = exchangeRateFor1Eth;\n', '        exchangeRateFor1Eth = newExchangeRate;\n', '        OnExchangeRateUpdated(originalRate, newExchangeRate);\n', '    }\n', '}\n', '\n', 'contract Distributed is Owned {\n', '    using SafeMath for uint;\n', '    \n', '    // Allocation related\n', '    uint tokenTransferPercentageNumerator;\n', '    uint tokenTransferPercentageDenominator;\n', '    uint interestAllocationPercentageNumerator;\n', '    uint interestAllocationPercentageDenominator;\n', '    uint managementFeeChargePercentageNumerator;\n', '    uint managementFeeChargePercentageDenominator;\n', '\n', '    uint distCompanyPercentage;\n', '    uint distTeamPercentage;\n', '    uint distOfferPercentage;\n', '\n', '    event OnPercentageChanged(string state, uint _m, uint _d, uint m, uint d);\n', '    event OnDistributionChanged(uint _c, uint _t, uint _o, uint c, uint t, uint o);\n', '    \n', '    modifier onlyWhenPercentageSettingIsValid(uint c, uint t, uint o) {\n', '        require((c.add(t).add(o)) == 100);\n', '        _;\n', '    }\n', '\n', '    function Distributed() internal {\n', '\n', '        tokenTransferPercentageNumerator = 1;\n', '        tokenTransferPercentageDenominator = 100;\n', '        interestAllocationPercentageNumerator = 1;\n', '        interestAllocationPercentageDenominator = 100;\n', '        managementFeeChargePercentageNumerator = 1;\n', '        managementFeeChargePercentageDenominator = 100;\n', '\n', '        distCompanyPercentage = 20;\n', '        distTeamPercentage = 10;\n', '        distOfferPercentage = 70;\n', '    }\n', '\n', '    function setTokenTransferPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = tokenTransferPercentageNumerator;\n', '        uint d = tokenTransferPercentageDenominator;\n', '        tokenTransferPercentageNumerator = numerator;\n', '        tokenTransferPercentageDenominator = denominator;\n', '        OnPercentageChanged("TokenTransferFee", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setInterestAllocationPercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = interestAllocationPercentageNumerator;\n', '        uint d = interestAllocationPercentageDenominator;\n', '        interestAllocationPercentageNumerator = numerator;\n', '        interestAllocationPercentageDenominator = denominator;\n', '        OnPercentageChanged("InterestAllocation", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setManagementFeeChargePercentage(uint numerator, uint denominator) public onlyOwnerOrOperator {\n', '        uint m = managementFeeChargePercentageNumerator;\n', '        uint d = managementFeeChargePercentageDenominator;\n', '        managementFeeChargePercentageNumerator = numerator;\n', '        managementFeeChargePercentageDenominator = denominator;\n', '        OnPercentageChanged("ManagementFee", m, d, numerator, denominator);\n', '    }\n', '\n', '    function setDistributionPercentage(uint c, uint t, uint o) public onlyWhenPercentageSettingIsValid(c, t, o) onlyOwner {\n', '        uint _c = distCompanyPercentage;\n', '        uint _t = distTeamPercentage;\n', '        uint _o = distOfferPercentage;\n', '        distCompanyPercentage = c;\n', '        distTeamPercentage = t;\n', '        distOfferPercentage = o;\n', '        OnDistributionChanged(_c, _t, _o, distCompanyPercentage, distTeamPercentage, distOfferPercentage);\n', '    }\n', '}\n', '\n', 'contract FeeCalculation {\n', '    using SafeMath for uint;\n', '    \n', '    function FeeCalculation() internal {\n', '\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate the fee tokens for transferring.\n', '    // ------------------------------------------------------------------------\n', '    function calculateTransferFee(uint tokens) internal pure returns (uint) {\n', '        uint calFee = 0;\n', '        if (tokens > 0 && tokens <= 1000)\n', '            calFee = 1;\n', '        else if (tokens > 1000 && tokens <= 5000)\n', '            calFee = tokens.mul(1).div(1000);\n', '        else if (tokens > 5000 && tokens <= 10000)\n', '            calFee = tokens.mul(2).div(1000);\n', '        else if (tokens > 10000)\n', '            calFee = 30;\n', '        return calFee;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// initial fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract FixedSupplyToken is ERC20Interface, Distributed, TokenHeld, Restricted, TokenTransaction, FeeCalculation {\n', '    using SafeMath for uint;\n', '\n', '    // Token information related\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    event OnAllocated(address indexed addr, uint allocatedTokens);\n', '    event OnCharged(address indexed addr, uint chargedTokens);\n', '    \n', '    modifier onlyWhenOfferredIsLowerThanDistOfferPercentage {\n', '        uint expectedTokens = msg.value.mul(1000);\n', '        uint totalOfferredTokens = 0;\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            totalOfferredTokens += balances[addressIndices[i]];\n', '        }\n', '        require(_totalSupply.mul(distOfferPercentage).div(100) - expectedTokens >= 0);\n', '        _;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function FixedSupplyToken() public {\n', '        symbol = "AGC";\n', '        name = "Agile Coin";\n', '        decimals = 0;\n', '        _totalSupply = 100000000 * 10**uint(decimals);\n', '\n', '        balances[owner] = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        uint balance = balances[address(0)];\n', '        return _totalSupply - balance;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(transactionDisallowedAddresses, msg.sender) returns (bool success) {\n', '        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\n', '        scanAddresses(to);\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens + calFee);\n', '\t\tbalances[owner] = balances[owner].add(calFee);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        Transfer(msg.sender, owner, calFee);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public onlyWhenTokenTransferOpen shouldBeAllowed(tokenTransferDisallowedAddresses, msg.sender) returns (bool success) {\n', '        uint calFee = isChargingTokenTransferFee ? calculateTransferFee(tokens) : 0;\n', '        scanAddresses(to);\n', '        balances[from] = balances[from].sub(tokens + calFee);\n', '        balances[owner] = balances[owner].add(calFee);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(from, to, tokens);\n', '        Transfer(from, owner, calFee);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable onlyWhenTokenTransactionOpen onlyWhenOfferredIsLowerThanDistOfferPercentage {\n', '        // Exchange: ETH --> ETTA Coin\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Allocate interest.\n', '    // ------------------------------------------------------------------------\n', '    function allocateTokens() public onlyOwnerOrOperator onlyWhenAllocatingInterestOpen {\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            address crntAddr = addressIndices[i];\n', '            uint balanceOfCrntAddr = balances[crntAddr];\n', '            uint allocatedTokens = balanceOfCrntAddr.mul(interestAllocationPercentageNumerator).div(interestAllocationPercentageDenominator);\n', '            balances[crntAddr] = balances[crntAddr].add(allocatedTokens);\n', '            balances[owner] = balances[owner].sub(allocatedTokens);\n', '            Transfer(owner, crntAddr, allocatedTokens);\n', '            OnAllocated(crntAddr, allocatedTokens);\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Charge investers for management fee.\n', '    // ------------------------------------------------------------------------\n', '    function chargeTokensForManagement() public onlyOwnerOrOperator onlyWhenChargingManagementFeeOpen {\n', '        for (uint i = 0; i < addressIndices.length; i++) {\n', '            address crntAddr = addressIndices[i];\n', '            uint balanceOfCrntAddr = balances[crntAddr];\n', '            uint chargedTokens = balanceOfCrntAddr.mul(managementFeeChargePercentageNumerator).div(managementFeeChargePercentageDenominator);\n', '            balances[crntAddr] = balances[crntAddr].sub(chargedTokens);\n', '            balances[owner] = balances[owner].add(chargedTokens);\n', '            Transfer(crntAddr,owner, chargedTokens);\n', '            OnCharged(crntAddr, chargedTokens);\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Distribute more token of contract and transfer to owner \n', '    // ------------------------------------------------------------------------\n', '    function mintToken(uint256 mintedAmount) public onlyOwner {\n', '        require(mintedAmount > 0);\n', '        balances[owner] = balances[owner].add(mintedAmount);\n', '        _totalSupply = _totalSupply.add(mintedAmount);\n', '        Transfer(address(0), owner, mintedAmount);\n', '    }\n', '\n', '    event OnTokenBurned(uint256 totalBurnedTokens);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Remove `numerator / denominator` % of tokens from the system irreversibly\n', '    // ------------------------------------------------------------------------\n', '    function burnByPercentage(uint8 m, uint8 d) public onlyOwner returns (bool success) {\n', '        require(m > 0 && d > 0 && m <= d);\n', '        uint totalBurnedTokens = balances[owner].mul(m).div(d);\n', '        balances[owner] = balances[owner].sub(totalBurnedTokens);\n', '        _totalSupply = _totalSupply.sub(totalBurnedTokens);\n', '        Transfer(owner, address(0), totalBurnedTokens);\n', '        OnTokenBurned(totalBurnedTokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Remove a quantity of tokens\n', '    // ------------------------------------------------------------------------\n', '    function burnByAmount(uint256 tokens) public onlyOwner returns (bool success) {\n', '        require(tokens > 0 && tokens <= balances[owner]);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        _totalSupply = _totalSupply.sub(tokens);\n', '        Transfer(owner, address(0), tokens);\n', '        OnTokenBurned(tokens);\n', '        return true;\n', '    }\n', '}']
