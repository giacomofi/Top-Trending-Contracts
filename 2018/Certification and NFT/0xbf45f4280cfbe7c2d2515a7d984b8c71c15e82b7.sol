['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/EtherDeltaI.sol\n', '\n', 'contract EtherDeltaI {\n', '\n', '  uint public feeMake; //percentage times (1 ether)\n', '  uint public feeTake; //percentage times (1 ether)\n', '\n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  function deposit() payable;\n', '\n', '  function withdraw(uint amount);\n', '\n', '  function depositToken(address token, uint amount);\n', '\n', '  function withdrawToken(address token, uint amount);\n', '\n', '  function balanceOf(address token, address user) constant returns (uint);\n', '\n', '  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce);\n', '\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\n', '\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool);\n', '\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s);\n', '\n', '}\n', '\n', '// File: contracts/KindMath.sol\n', '\n', '/**\n', ' * @title KindMath\n', ' * @dev Math operations with safety checks that fail\n', ' */\n', 'library KindMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/KeyValueStorage.sol\n', '\n', 'contract KeyValueStorage {\n', '\n', '  mapping(address => mapping(bytes32 => uint256)) _uintStorage;\n', '  mapping(address => mapping(bytes32 => address)) _addressStorage;\n', '  mapping(address => mapping(bytes32 => bool)) _boolStorage;\n', '  mapping(address => mapping(bytes32 => bytes32)) _bytes32Storage;\n', '\n', '  /**** Get Methods ***********/\n', '\n', '  function getAddress(bytes32 key) public view returns (address) {\n', '      return _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function getUint(bytes32 key) public view returns (uint) {\n', '      return _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBool(bytes32 key) public view returns (bool) {\n', '      return _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBytes32(bytes32 key) public view returns (bytes32) {\n', '      return _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '  /**** Set Methods ***********/\n', '\n', '  function setAddress(bytes32 key, address value) public {\n', '      _addressStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setUint(bytes32 key, uint value) public {\n', '      _uintStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBool(bytes32 key, bool value) public {\n', '      _boolStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBytes32(bytes32 key, bytes32 value) public {\n', '      _bytes32Storage[msg.sender][key] = value;\n', '  }\n', '\n', '  /**** Delete Methods ***********/\n', '\n', '  function deleteAddress(bytes32 key) public {\n', '      delete _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteUint(bytes32 key) public {\n', '      delete _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBool(bytes32 key) public {\n', '      delete _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBytes32(bytes32 key) public {\n', '      delete _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/StorageStateful.sol\n', '\n', 'contract StorageStateful {\n', '  KeyValueStorage public keyValueStorage;\n', '}\n', '\n', '// File: contracts/StorageConsumer.sol\n', '\n', 'contract StorageConsumer is StorageStateful {\n', '  function StorageConsumer(address _storageAddress) public {\n', '    require(_storageAddress != address(0));\n', '    keyValueStorage = KeyValueStorage(_storageAddress);\n', '  }\n', '}\n', '\n', '// File: contracts/TokenI.sol\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() public returns (uint256);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public returns (uint256);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public returns (uint256);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint256 public decimals;\n', '  string public name;\n', '}\n', '\n', '// File: contracts/EnclavesDEXProxy.sol\n', '\n', 'contract EnclavesDEXProxy is StorageConsumer {\n', '  using KindMath for uint256;\n', '\n', '  address public admin; //the admin address\n', '  address public feeAccount; //the account that will receive fees\n', '\n', '  struct EtherDeltaInfo {\n', '    uint256 feeMake;\n', '    uint256 feeTake;\n', '  }\n', '\n', '  EtherDeltaInfo public etherDeltaInfo;\n', '\n', '  uint256 public feeTake; //percentage times 1 ether\n', '  uint256 public feeAmountThreshold; //gasPrice amount under which no fees are charged\n', '\n', '  address public etherDelta;\n', '\n', '  bool public useEIP712 = true;\n', '  bytes32 public tradeABIHash;\n', '  bytes32 public withdrawABIHash;\n', '\n', '  bool freezeTrading;\n', '  bool depositTokenLock;\n', '\n', '  mapping (address => mapping (uint256 => bool)) nonceCheck;\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  address internal implementation;\n', '  address public proposedImplementation;\n', '  uint256 public proposedTimestamp;\n', '\n', '  event Upgraded(address _implementation);\n', '  event UpgradedProposed(address _proposedImplementation, uint256 _proposedTimestamp);\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  function EnclavesDEXProxy(address _storageAddress, address _implementation, address _admin, address _feeAccount, uint256 _feeTake, uint256 _feeAmountThreshold, address _etherDelta, bytes32 _tradeABIHash, bytes32 _withdrawABIHash) public\n', '    StorageConsumer(_storageAddress)\n', '  {\n', '    require(_implementation != address(0));\n', '    implementation = _implementation;\n', '    admin = _admin;\n', '    feeAccount = _feeAccount;\n', '    feeTake = _feeTake;\n', '    feeAmountThreshold = _feeAmountThreshold;\n', '    etherDelta = _etherDelta;\n', '    tradeABIHash = _tradeABIHash;\n', '    withdrawABIHash = _withdrawABIHash;\n', '    etherDeltaInfo.feeMake = EtherDeltaI(etherDelta).feeMake();\n', '    etherDeltaInfo.feeTake = EtherDeltaI(etherDelta).feeTake();\n', '  }\n', '\n', '  function getImplementation() public view returns(address) {\n', '    return implementation;\n', '  }\n', '\n', '  function proposeUpgrade(address _proposedImplementation) public onlyAdmin {\n', '    require(implementation != _proposedImplementation);\n', '    require(_proposedImplementation != address(0));\n', '    proposedImplementation = _proposedImplementation;\n', '    proposedTimestamp = now + 2 weeks;\n', '    UpgradedProposed(proposedImplementation, now);\n', '  }\n', '\n', '  function upgrade() public onlyAdmin {\n', '    require(proposedImplementation != address(0));\n', '    require(proposedTimestamp < now);\n', '    implementation = proposedImplementation;\n', '    Upgraded(implementation);\n', '  }\n', '\n', '  function () payable public {\n', '    bytes memory data = msg.data;\n', '    address impl = getImplementation();\n', '\n', '    assembly {\n', '      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)\n', '      let size := returndatasize\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/EtherDeltaI.sol\n', '\n', 'contract EtherDeltaI {\n', '\n', '  uint public feeMake; //percentage times (1 ether)\n', '  uint public feeTake; //percentage times (1 ether)\n', '\n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  function deposit() payable;\n', '\n', '  function withdraw(uint amount);\n', '\n', '  function depositToken(address token, uint amount);\n', '\n', '  function withdrawToken(address token, uint amount);\n', '\n', '  function balanceOf(address token, address user) constant returns (uint);\n', '\n', '  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce);\n', '\n', '  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\n', '\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool);\n', '\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s);\n', '\n', '}\n', '\n', '// File: contracts/KindMath.sol\n', '\n', '/**\n', ' * @title KindMath\n', ' * @dev Math operations with safety checks that fail\n', ' */\n', 'library KindMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/KeyValueStorage.sol\n', '\n', 'contract KeyValueStorage {\n', '\n', '  mapping(address => mapping(bytes32 => uint256)) _uintStorage;\n', '  mapping(address => mapping(bytes32 => address)) _addressStorage;\n', '  mapping(address => mapping(bytes32 => bool)) _boolStorage;\n', '  mapping(address => mapping(bytes32 => bytes32)) _bytes32Storage;\n', '\n', '  /**** Get Methods ***********/\n', '\n', '  function getAddress(bytes32 key) public view returns (address) {\n', '      return _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function getUint(bytes32 key) public view returns (uint) {\n', '      return _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBool(bytes32 key) public view returns (bool) {\n', '      return _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function getBytes32(bytes32 key) public view returns (bytes32) {\n', '      return _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '  /**** Set Methods ***********/\n', '\n', '  function setAddress(bytes32 key, address value) public {\n', '      _addressStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setUint(bytes32 key, uint value) public {\n', '      _uintStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBool(bytes32 key, bool value) public {\n', '      _boolStorage[msg.sender][key] = value;\n', '  }\n', '\n', '  function setBytes32(bytes32 key, bytes32 value) public {\n', '      _bytes32Storage[msg.sender][key] = value;\n', '  }\n', '\n', '  /**** Delete Methods ***********/\n', '\n', '  function deleteAddress(bytes32 key) public {\n', '      delete _addressStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteUint(bytes32 key) public {\n', '      delete _uintStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBool(bytes32 key) public {\n', '      delete _boolStorage[msg.sender][key];\n', '  }\n', '\n', '  function deleteBytes32(bytes32 key) public {\n', '      delete _bytes32Storage[msg.sender][key];\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/StorageStateful.sol\n', '\n', 'contract StorageStateful {\n', '  KeyValueStorage public keyValueStorage;\n', '}\n', '\n', '// File: contracts/StorageConsumer.sol\n', '\n', 'contract StorageConsumer is StorageStateful {\n', '  function StorageConsumer(address _storageAddress) public {\n', '    require(_storageAddress != address(0));\n', '    keyValueStorage = KeyValueStorage(_storageAddress);\n', '  }\n', '}\n', '\n', '// File: contracts/TokenI.sol\n', '\n', 'contract Token {\n', '  /// @return total amount of tokens\n', '  function totalSupply() public returns (uint256);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public returns (uint256);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of wei to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public returns (uint256);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  uint256 public decimals;\n', '  string public name;\n', '}\n', '\n', '// File: contracts/EnclavesDEXProxy.sol\n', '\n', 'contract EnclavesDEXProxy is StorageConsumer {\n', '  using KindMath for uint256;\n', '\n', '  address public admin; //the admin address\n', '  address public feeAccount; //the account that will receive fees\n', '\n', '  struct EtherDeltaInfo {\n', '    uint256 feeMake;\n', '    uint256 feeTake;\n', '  }\n', '\n', '  EtherDeltaInfo public etherDeltaInfo;\n', '\n', '  uint256 public feeTake; //percentage times 1 ether\n', '  uint256 public feeAmountThreshold; //gasPrice amount under which no fees are charged\n', '\n', '  address public etherDelta;\n', '\n', '  bool public useEIP712 = true;\n', '  bytes32 public tradeABIHash;\n', '  bytes32 public withdrawABIHash;\n', '\n', '  bool freezeTrading;\n', '  bool depositTokenLock;\n', '\n', '  mapping (address => mapping (uint256 => bool)) nonceCheck;\n', '\n', '  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '\n', '  address internal implementation;\n', '  address public proposedImplementation;\n', '  uint256 public proposedTimestamp;\n', '\n', '  event Upgraded(address _implementation);\n', '  event UpgradedProposed(address _proposedImplementation, uint256 _proposedTimestamp);\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  function EnclavesDEXProxy(address _storageAddress, address _implementation, address _admin, address _feeAccount, uint256 _feeTake, uint256 _feeAmountThreshold, address _etherDelta, bytes32 _tradeABIHash, bytes32 _withdrawABIHash) public\n', '    StorageConsumer(_storageAddress)\n', '  {\n', '    require(_implementation != address(0));\n', '    implementation = _implementation;\n', '    admin = _admin;\n', '    feeAccount = _feeAccount;\n', '    feeTake = _feeTake;\n', '    feeAmountThreshold = _feeAmountThreshold;\n', '    etherDelta = _etherDelta;\n', '    tradeABIHash = _tradeABIHash;\n', '    withdrawABIHash = _withdrawABIHash;\n', '    etherDeltaInfo.feeMake = EtherDeltaI(etherDelta).feeMake();\n', '    etherDeltaInfo.feeTake = EtherDeltaI(etherDelta).feeTake();\n', '  }\n', '\n', '  function getImplementation() public view returns(address) {\n', '    return implementation;\n', '  }\n', '\n', '  function proposeUpgrade(address _proposedImplementation) public onlyAdmin {\n', '    require(implementation != _proposedImplementation);\n', '    require(_proposedImplementation != address(0));\n', '    proposedImplementation = _proposedImplementation;\n', '    proposedTimestamp = now + 2 weeks;\n', '    UpgradedProposed(proposedImplementation, now);\n', '  }\n', '\n', '  function upgrade() public onlyAdmin {\n', '    require(proposedImplementation != address(0));\n', '    require(proposedTimestamp < now);\n', '    implementation = proposedImplementation;\n', '    Upgraded(implementation);\n', '  }\n', '\n', '  function () payable public {\n', '    bytes memory data = msg.data;\n', '    address impl = getImplementation();\n', '\n', '    assembly {\n', '      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)\n', '      let size := returndatasize\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '}']
