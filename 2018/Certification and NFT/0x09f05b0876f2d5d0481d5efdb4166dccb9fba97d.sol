['pragma solidity ^0.4.24;\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner,"Have no legal powerd");\n', '    _;\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', 'contract ERC20Interface {\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', 'contract VoterFactory is Ownable{\n', '    using SafeMath for uint256; //uint256 library\n', '    mapping(address=>uint) total; //player total Voter\n', '    mapping(address=>mapping(uint=>uint)) totalForVoter;\n', '    mapping(address=>uint) balances;//player gamcoin \n', '    mapping(address=>uint) playerP;//player PID\n', '    mapping(uint=>address) playerA;//PID to player address\n', '    mapping(address=>mapping(uint=>uint)) playerV;//player=>voterID=>voters\n', '    mapping(address=>uint) playerEth;//player=>ETHER\n', '    mapping(address=>address) referees;//player=>referees\n', '    mapping(address=>address[]) totalReferees;//referees=>totalplayer\n', '    mapping(address=>uint) isCreated;\n', '    \n', '    \n', '    event NewVoter(uint _id,uint256 _name,uint _value,uint _vectoryvalue);// new model event\n', '    event GiveVoter(address indexed _fromaddress,uint _toid,uint _number);// voter event\n', '    event gameover(bool isReady);//gameover\n', '    event NewPlayer(uint _id,address indexed _address);//createPlayer\n', '    event restart(bool isReady,uint _RID);//reboot\n', '    event EgiveToVoterOnlyowner(uint _toid,uint _number);\n', '    event EgetPlayerCoin(address indexed _address,uint256 _number,bool _bool);\n', '    event Ewithdraw(uint _ether);\n', '    event EsetFee(uint _time,uint _fee);\n', '    event Ebuygamecoin(uint _time,uint _number,address indexed _address);\n', '    event EgetEveryDayEarnings(uint _time,uint _number,uint _totalplayers,address _address);\n', '    \n', '    struct Voter{\n', '        uint id;\n', '        uint256 name;\n', '        uint value;\n', '        address[] pa;\n', '        uint totalplayer;\n', '    }\n', '    struct Winner{\n', '        uint256 name;\n', '        uint value;\n', '    }\n', '    Winner[] public winners;\n', '    Voter[] public voters;\n', '    Voter[] voterss;\n', '    uint public RID=0;\n', '    uint public totalRef;\n', '    uint public totalplayers;//total player\n', '    uint public ids=0;//total model\n', '    uint public fee = 340000000000000;//gamcoin fee\n', '    uint public createTime = now;//create Time\n', '    uint public shutTime = 0 minutes;//shutdown time\n', '    uint public decimals = 18; \n', '    bool public started = false;\n', '    uint public EthOther = 100000000000000000000;\n', '    uint public EthOtherfee = 10000;\n', '    address public winnerOfplayer;\n', '    address[]  public _addrs;\n', '    ERC20Interface CDS;\n', '}\n', 'contract VoterServiceImpl is VoterFactory{\n', '    function _createPlayer(address _address) internal {\n', '        playerA[totalplayers] = _address;\n', '        playerP[_address] = totalplayers;\n', '        totalplayers=totalplayers.add(1);\n', '        _addrs.push(_address);\n', '        emit NewPlayer(totalplayers-1,_address);\n', '    }\n', '    function _getEarnings(address _address,uint _playerTotal,uint _value,uint _oldvalue) internal {\n', '        uint proportion = _playerTotal.div(_oldvalue);\n', '        uint surplus = (_value.div(2)).add(_value.div(5));\n', '        balances[_address] = balances[_address].add(proportion.mul(_value.sub(surplus)));\n', '        totalRef = totalRef.add(proportion.mul(_value.sub(surplus)));\n', '    }\n', '    function _shutDown() internal{\n', '        require(now>=(createTime+shutTime),"Not over yet");\n', '        if(balances[owner]!=0){\n', '            uint256  vectoryId=0;\n', '            if(ids!=0){\n', '                for(uint256 i=0;i<ids;i=i.add(1)){\n', '                    if(voters[i].value>voters[vectoryId].value){\n', '                        vectoryId=i;\n', '                    }\n', '                }\n', '                winners.push(Winner(voters[vectoryId].name,voters[vectoryId].value));\n', '                uint vectoryValue = balances[owner];\n', '                uint oldvalue = voters[vectoryId].value;\n', '                for(uint256 k=0;k<voters[vectoryId].totalplayer;k=k.add(1)){\n', '                    address add = voters[vectoryId].pa[k];\n', '                    uint playerTotal = playerV[add][vectoryId];\n', '                    _getEarnings(add,playerTotal,vectoryValue,oldvalue);\n', '                }\n', '                for(uint256 j=0;j<ids;j=j.add(1)){\n', '                voters[j].value=0;\n', '                }\n', '            }\n', '            if(totalplayers!=0){\n', '                for(uint256 s=0;s<totalplayers;s=s.add(1)){\n', '                    total[playerA[s]]=0;\n', '                    playerP[playerA[s]]=0;\n', '                    for(uint256 n=0;n<ids;n=n.add(1)){\n', '                        playerV[playerA[s]][n]=0;\n', '                    }\n', '                    playerEth[playerA[s]]=0;\n', '                    referees[playerA[s]];\n', '                    totalReferees[playerA[s]];\n', '                    playerA[s]=0;\n', '                }\n', '            }\n', '            balances[winnerOfplayer] = balances[winnerOfplayer].add(vectoryValue.div(50));\n', '        }\n', '        totalplayers=0;\n', '        ids=0;\n', '        EthOtherfee=10000;\n', '        EthOther=100000000000000000000;\n', '        winnerOfplayer = owner;\n', '        voters = voterss;\n', '        balances[owner]=0;\n', '        started=false;\n', '    }\n', '    function _createVoter(uint256 _str) internal onlyOwner{\n', '        address[] memory p;\n', '        voters.push(Voter(ids,_str,0,p,0));\n', '        ids=ids.add(1);\n', '    }\n', '}\n', '\n', '\n', 'contract Voterplayer is VoterServiceImpl{\n', '    function giveToVoter(uint _value,uint _id) public {\n', '        require(started);\n', '        require(msg.sender!=owner);\n', '        uint time = createTime.add(shutTime);\n', '        require(now<time);\n', '        require(_id<=ids);\n', '        require(msg.sender!=owner,"owner Can\'t vote");\n', '        require(balances[msg.sender]>=_value,"balances too low");\n', '        balances[msg.sender]=balances[msg.sender].sub(_value);\n', '        totalForVoter[msg.sender][_id]=totalForVoter[msg.sender][_id].add(_value);\n', '        if(playerV[msg.sender][_id]==0){\n', '            voters[_id].pa.push(msg.sender);\n', '            voters[_id].totalplayer=voters[_id].totalplayer.add(1);\n', '        }\n', '        if(referees[msg.sender]!=0){\n', '            balances[referees[msg.sender]] = balances[referees[msg.sender]].add(_value.mul(1).div(10));\n', '            totalRef = totalRef.add(_value.mul(1).div(10));\n', '        }\n', '        total[msg.sender]=total[msg.sender].add(_value);\n', '        balances[owner]=balances[owner].add(_value);\n', '        voters[_id].value=voters[_id].value.add(_value);\n', '        playerV[msg.sender][_id] = playerV[msg.sender][_id].add(_value);\n', '        emit GiveVoter(msg.sender,_id,_value);\n', '        return;\n', '    }\n', '    function createAllVoter(uint256[] _voter) public onlyOwner{\n', '        for(uint i=0;i<_voter.length;i=i.add(1)){\n', '             createVoter(_voter[i]);\n', '        }\n', '    }\n', '    function giveToVoterOnlyowner(uint _value,uint _id) public onlyOwner{\n', '        require(started);\n', '        voters[_id].value=voters[_id].value.add(_value);\n', '        balances[owner]=balances[owner].add(_value);\n', '        emit EgiveToVoterOnlyowner(_id,_value);\n', '    }\n', '    function getaddresstotal(uint _id) public view returns(uint){\n', '        return voters[_id].totalplayer;\n', '    }\n', '    function getTotalForVoter(address _address,uint _id) view public returns(uint){\n', '        return totalForVoter[_address][_id];\n', '    } \n', '    function getTotalVoter(address _address) view public returns(uint totals){\n', '        return total[_address];\n', '    }\n', '    function balanceOf(address _address) view public returns(uint balance){\n', '        return balances[_address];\n', '    }\n', '    function refereesOf(address _address) view public returns(address[]){\n', '        return totalReferees[_address];\n', '    }\n', '    function getAllPlayer() view public returns(address[]){\n', '        return _addrs;\n', '    }\n', '    function buyGameCoin(uint256 _number,address _address) public payable{\n', '        require(started);\n', '        require(msg.sender!=owner);\n', '        uint256  coinfee = _number.div(10).mul(fee);\n', '        require(msg.value>=coinfee);\n', '        if(msg.sender!=_address&&referees[msg.sender]==0){\n', '            require(balances[_address]>0);\n', '            balances[_address] = balances[_address].add((_number.mul(30).div(100)).mul(1).div(10));\n', '            totalRef = totalRef.add(_number.mul(10).div(100));\n', '            referees[msg.sender] = _address;\n', '            totalReferees[_address].push(msg.sender);\n', '        }else if(msg.sender==_address&&referees[msg.sender]!=0){\n', '            balances[referees[msg.sender]] = balances[referees[msg.sender]].add((_number.mul(30).div(100)).mul(1).div(10));\n', '            totalRef = totalRef.add((_number.mul(30).div(100)).mul(1).div(10));\n', '        }\n', '        total[msg.sender] = total[msg.sender].add(_number.mul(30).div(100));\n', '        if(isCreated[msg.sender]==0){\n', '            isCreated[msg.sender] = 1;\n', '            _createPlayer(msg.sender);\n', '        }\n', '        balances[msg.sender]=balances[msg.sender].add(_number.mul(70).div(100));\n', '        balances[owner] = balances[owner].add(_number.mul(30).div(100));\n', '        if(playerEth[owner]>=EthOther){\n', '            EthOtherfee=EthOtherfee.mul(2);\n', '            EthOther = EthOther.mul(3);\n', '        }\n', '        fee=fee.add(fee.div(EthOtherfee.mul(1000)).mul((msg.value.sub(msg.value%1000000000000000)).div(1000000000000000)));\n', '        playerEth[owner] = playerEth[owner].add(msg.value);\n', '        msg.sender.transfer(msg.value.sub(coinfee));\n', '        owner.transfer(coinfee);\n', '        shutTime = shutTime.add(_number.div(10));\n', '        winnerOfplayer = msg.sender;\n', '        emit Ebuygamecoin(now,_number,_address);\n', '    }\n', '    function getPlayerCoin(uint256 _number) external {\n', '        require(balances[msg.sender]>=_number);\n', '        balances[msg.sender] = balances[msg.sender].sub(_number);\n', '        uint256 _token = _number.div(10).mul(10**decimals);\n', '        require(CDS.transferFrom(owner,msg.sender,_token));\n', '        emit EgetPlayerCoin(msg.sender,_number,true);\n', '    }\n', '    function createVoter(uint256 _name) public onlyOwner{\n', '        _createVoter(_name);\n', '        emit NewVoter(ids-1,_name,0,0);\n', '    }\n', '    function startGame(uint _time,address _address,uint256 _decimals) public onlyOwner{\n', '        require(!started);\n', '        require(_address!=address(0));\n', '        CDS=ERC20Interface(_address);\n', '        decimals=_decimals;\n', '        createTime=now;\n', '        shutTime= _time;\n', '        RID=RID.add(1);\n', '        started=true;\n', '        totalRef=0;\n', '        emit restart(started,RID);\n', '    }\n', '    function setTime(uint _time) public onlyOwner{\n', '        require(started);\n', '        shutTime= _time;\n', '    }\n', '    function setFee(uint _fee) public onlyOwner{\n', '        fee=_fee;\n', '        emit EsetFee(now,_fee);\n', '    }\n', '    function gameOver() public onlyOwner{\n', '        _shutDown();\n', '        emit gameover(true);\n', '    }\n', '    function withdraw() external onlyOwner {\n', '        address myAddress = address(this);\n', '        owner.transfer(myAddress.balance);\n', '        emit Ewithdraw(myAddress.balance);\n', '    }\n', '    function setCDStokenAddress(address _address,uint256 _decimals) public onlyOwner{\n', '       require(_address!=address(0));\n', '        decimals=_decimals;\n', '        CDS=ERC20Interface(_address);\n', '    }\n', '    \n', '    function getEveryDayEarnings(address _address,uint256 _number) public onlyOwner{\n', '        require(balances[owner]>=_number);\n', '        totalRef=totalRef.add(_number.mul(2));\n', '        balances[_address]=balances[_address].add(_number);\n', '        if(totalplayers!=0){\n', '                for(uint256 s=0;s<totalplayers;s=s.add(1)){\n', '                    if(total[playerA[s]]==0){\n', '                        continue;\n', '                    }\n', '                    balances[playerA[s]] = balances[playerA[s]].add(_number.mul(total[playerA[s]]).div(balances[owner]));\n', '                }\n', '            }\n', '        emit EgetEveryDayEarnings(now,_number,totalplayers,_address);\n', '    }\n', '    \n', '}\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']