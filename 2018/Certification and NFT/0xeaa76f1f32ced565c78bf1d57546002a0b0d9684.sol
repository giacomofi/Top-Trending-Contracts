['pragma solidity 0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure  returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure  returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure  returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(address(0) != _newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends tokens to contributors\n', 'contract Crowdsale is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensToSend; // amount of tokens  sent\n', '        bool refunded;\n', '    }\n', '\n', '    Token public token; // Token contract reference\n', '    address public multisig; // Multisig contract that will receive the ETH\n', '    address public team; // Address at which the team tokens will be sent\n', '    uint public ethReceivedPresale; // Number of ETH received in presale\n', '    uint public ethReceivedMain; // Number of ETH received in public sale\n', '    uint public tokensSentPresale; // Tokens sent during presale\n', '    uint public tokensSentMain; // Tokens sent during public ICO\n', '    uint public totalTokensSent; // Total number of tokens sent to contributors\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of tokens to sell\n', '    uint public minInvestETH; // Minimum amount to invest\n', '    bool public crowdsaleClosed; // Is crowdsale still in progress\n', '    Step public currentStep;  // To allow for controlled steps of the campaign\n', '    uint public refundCount;  // Number of refunds\n', '    uint public totalRefunded; // Total amount of Eth refunded\n', '    uint public numOfBlocksInMinute; // number of blocks in one minute * 100. eg.\n', '    WhiteList public whiteList;     // whitelist contract\n', '    uint public tokenPriceWei;      // Price of token in wei\n', '\n', '    mapping(address => Backer) public backers; // contributors list\n', '    address[] public backersIndex; // to be able to iterate through backers for verification.\n', '    uint public priorTokensSent;\n', '    uint public presaleCap;\n', '\n', '\n', '    // @notice to verify if action is not performed out of the campaign range\n', '    modifier respectTimeFrame() {\n', '        require(block.number >= startBlock && block.number <= endBlock);\n', '        _;\n', '    }\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {\n', '        FundingPreSale,     // presale mode\n', '        FundingPublicSale,  // public mode\n', '        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\n', '    }\n', '\n', '    // Events\n', '    event ReceivedETH(address indexed backer, uint amount, uint tokenAmount);\n', '    event RefundETH(address indexed backer, uint amount);\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initializes all constant and initial values.\n', '    // @param _dollarToEtherRatio {uint} how many dollars are in one eth.  $333.44/ETH would be passed as 33344\n', '    function Crowdsale(WhiteList _whiteList) public {\n', '\n', '        require(_whiteList != address(0));\n', '        multisig = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\n', '        team = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\n', '        maxCap = 1510000000e8;\n', '        minInvestETH = 1 ether/2;\n', '        currentStep = Step.FundingPreSale;\n', '        numOfBlocksInMinute = 408;          // E.g. 4.38 block/per minute wold be entered as 438\n', '        priorTokensSent = 4365098999e7;     //tokens distributed in private sale and airdrops\n', '        whiteList = _whiteList;             // white list address\n', '        presaleCap = 160000000e8;           // max for sell in presale\n', '        tokenPriceWei = 57142857142857;     // 17500 tokens per ether\n', '    }\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function setTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\n', '        require(token == address(0));\n', '        token = _tokenAddress;\n', '        return true;\n', '    }\n', '\n', '    // @notice set the step of the campaign from presale to public sale\n', '    // contract is deployed in presale mode\n', '    // WARNING: there is no way to go back\n', '    function advanceStep() public onlyOwner() {\n', '        require(Step.FundingPreSale == currentStep);\n', '        currentStep = Step.FundingPublicSale;\n', '        minInvestETH = 1 ether/4;\n', '    }\n', '\n', '    // @notice in case refunds are needed, money can be returned to the contract\n', '    // and contract switched to mode refunding\n', '    function prepareRefund() public payable onlyOwner() {\n', '\n', '        require(crowdsaleClosed);\n', '        require(msg.value == ethReceivedPresale.add(ethReceivedMain)); // make sure that proper amount of ether is sent\n', '        currentStep = Step.Refunding;\n', '    }\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors\n', '    function numberOfBackers() public view returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\n', '    // Contributor will be instructed to specify sufficient amount of gas. e.g. 250,000\n', '    function () external payable {\n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale\n', '    function start(uint _block) external onlyOwner() {\n', '\n', '        require(startBlock == 0);\n', '        require(_block <= (numOfBlocksInMinute * 60 * 24 * 54)/100);  // allow max 54 days for campaign\n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(_block);\n', '    }\n', '\n', '    // @notice Due to changing average of block time\n', '    // this function will allow on adjusting duration of campaign closer to the end\n', '    function adjustDuration(uint _block) external onlyOwner() {\n', '\n', '        require(startBlock > 0);\n', '        require(_block < (numOfBlocksInMinute * 60 * 24 * 60)/100); // allow for max of 60 days for campaign\n', '        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\n', '        endBlock = startBlock.add(_block);\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of contributor\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal whenNotPaused() respectTimeFrame() returns(bool res) {\n', '        require(!crowdsaleClosed);\n', '        require(whiteList.isWhiteListed(_backer));      // ensure that user is whitelisted\n', '\n', '        uint tokensToSend = determinePurchase();\n', '\n', '        Backer storage backer = backers[_backer];\n', '\n', '        if (backer.weiReceived == 0)\n', '            backersIndex.push(_backer);\n', '\n', '        backer.tokensToSend += tokensToSend; // save contributor&#39;s total tokens sent\n', '        backer.weiReceived = backer.weiReceived.add(msg.value);  // save contributor&#39;s total ether contributed\n', '\n', '        if (Step.FundingPublicSale == currentStep) { // Update the total Ether received and tokens sent during public sale\n', '            ethReceivedMain = ethReceivedMain.add(msg.value);\n', '            tokensSentMain += tokensToSend;\n', '        }else {                                                 // Update the total Ether recived and tokens sent during presale\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value);\n', '            tokensSentPresale += tokensToSend;\n', '        }\n', '\n', '        totalTokensSent += tokensToSend;     // update the total amount of tokens sent\n', '        multisig.transfer(address(this).balance);   // transfer funds to multisignature wallet\n', '\n', '        require(token.transfer(_backer, tokensToSend));   // Transfer tokens\n', '\n', '        emit ReceivedETH(_backer, msg.value, tokensToSend); // Register event\n', '        return true;\n', '    }\n', '\n', '    // @notice determine if purchase is valid and return proper number of tokens\n', '    // @return tokensToSend {uint} proper number of tokens based on the timline\n', '    function determinePurchase() internal view  returns (uint) {\n', '\n', '        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\n', '\n', '        uint tokensToSend = msg.value.mul(1e8) / tokenPriceWei;   //1e8 ensures that token gets 8 decimal values\n', '\n', '        if (Step.FundingPublicSale == currentStep) {  // calculate price of token in public sale\n', '            require(totalTokensSent + tokensToSend + priorTokensSent <= maxCap); // Ensure that max cap hasn&#39;t been reached\n', '        }else {\n', '            tokensToSend += (tokensToSend * 50) / 100;\n', '            require(totalTokensSent + tokensToSend <= presaleCap); // Ensure that max cap hasn&#39;t been reached for presale\n', '        }\n', '        return tokensToSend;\n', '    }\n', '\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    // it will fail if minimum cap is not reached\n', '    function finalize() external onlyOwner() {\n', '\n', '        require(!crowdsaleClosed);\n', '        // purchasing precise number of tokens might be impractical, thus subtract 1000\n', '        // tokens so finalization is possible near the end\n', '        require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000);\n', '        crowdsaleClosed = true;\n', '\n', '        require(token.transfer(team, token.balanceOf(this))); // transfer all remaining tokens to team address\n', '        token.unlock();\n', '    }\n', '\n', '    // @notice Fail-safe drain\n', '    function drain() external onlyOwner() {\n', '        multisig.transfer(address(this).balance);\n', '    }\n', '\n', '    // @notice Fail-safe token transfer\n', '    function tokenDrain() external onlyOwner() {\n', '        if (block.number > endBlock) {\n', '            require(token.transfer(multisig, token.balanceOf(this)));\n', '        }\n', '    }\n', '\n', '    // @notice it will allow contributors to get refund in case campaign failed\n', '    // @return {bool} true if successful\n', '    function refund() external whenNotPaused() returns (bool) {\n', '\n', '        require(currentStep == Step.Refunding);\n', '\n', '        Backer storage backer = backers[msg.sender];\n', '\n', '        require(backer.weiReceived > 0);  // ensure that user has sent contribution\n', '        require(!backer.refunded);        // ensure that user hasn&#39;t been refunded yet\n', '\n', '        backer.refunded = true;  // save refund status to true\n', '        refundCount++;\n', '        totalRefunded = totalRefunded + backer.weiReceived;\n', '\n', '        require(token.transfer(msg.sender, backer.tokensToSend)); // return allocated tokens\n', '        msg.sender.transfer(backer.weiReceived);  // send back the contribution\n', '        emit RefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint);\n', '\n', '    function allowance(address owner, address spender) public view returns(uint);\n', '\n', '    function transfer(address to, uint value) public returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) public returns(bool ok);\n', '\n', '    function approve(address spender, uint value) public returns(bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '// The token\n', 'contract Token is ERC20, Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals; // How many decimals to show.\n', '    string public version = "v0.1";\n', '    uint public totalSupply;\n', '    bool public locked;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    address public crowdSaleAddress;\n', '\n', '\n', '    // Lock transfer for contributors during the ICO\n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleAddress && msg.sender != owner && locked)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != owner && msg.sender != crowdSaleAddress)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice The Token contract\n', '    function Token(address _crowdsaleAddress) public {\n', '\n', '        require(_crowdsaleAddress != address(0));\n', '        locked = true; // Lock the transfer of tokens during the crowdsale\n', '        totalSupply = 2600000000e8;\n', '        name = "Kripton";                           // Set the name for display purposes\n', '        symbol = "LPK";                             // Set the symbol for display purposes\n', '        decimals = 8;                               // Amount of decimals\n', '        crowdSaleAddress = _crowdsaleAddress;\n', '        balances[_crowdsaleAddress] = totalSupply;\n', '    }\n', '\n', '    // @notice unlock token for trading\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '    }\n', '\n', '    // @lock token from trading during ICO\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '    }\n', '\n', '    // @notice transfer tokens to given address\n', '    // @param _to {address} address or recipient\n', '    // @param _value {uint} amount to transfer\n', '    // @return  {bool} true if successful\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice transfer tokens from given address to another address\n', '    // @param _from {address} from whom tokens are transferred\n', '    // @param _to {address} to whom tokens are transferred\n', '    // @parm _value {uint} amount of tokens to transfer\n', '    // @return  {bool} true if successful\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\n', '        require(balances[_from] >= _value); // Check if the sender has enough\n', '        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\n', '        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\n', '        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice to query balance of account\n', '    // @return _owner {address} address of user to query balance\n', '    function balanceOf(address _owner) public view returns(uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '    * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice to query of allowance of one user to the other\n', '    // @param _owner {address} of the owner of the account\n', '    // @param _spender {address} of the spender of the account\n', '    // @return remaining {uint} amount of remaining allowance\n', '    function allowance(address _owner, address _spender) public view returns(uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// Whitelist smart contract\n', '// This smart contract keeps list of addresses to whitelist\n', 'contract WhiteList is Ownable {\n', '\n', '\n', '    mapping(address => bool) public whiteList;\n', '    uint public totalWhiteListed; //white listed users number\n', '\n', '    event LogWhiteListed(address indexed user, uint whiteListedNum);\n', '    event LogWhiteListedMultiple(uint whiteListedNum);\n', '    event LogRemoveWhiteListed(address indexed user);\n', '\n', '    // @notice it will return status of white listing\n', '    // @return true if user is white listed and false if is not\n', '    function isWhiteListed(address _user) external view returns (bool) {\n', '\n', '        return whiteList[_user];\n', '    }\n', '\n', '    // @notice it will remove whitelisted user\n', '    // @param _contributor {address} of user to unwhitelist\n', '    function removeFromWhiteList(address _user) external onlyOwner() {\n', '\n', '        require(whiteList[_user] == true);\n', '        whiteList[_user] = false;\n', '        totalWhiteListed--;\n', '        emit LogRemoveWhiteListed(_user);\n', '    }\n', '\n', '    // @notice it will white list one member\n', '    // @param _user {address} of user to whitelist\n', '    // @return true if successful\n', '    function addToWhiteList(address _user) external onlyOwner() {\n', '\n', '        if (whiteList[_user] != true) {\n', '            whiteList[_user] = true;\n', '            totalWhiteListed++;\n', '            emit LogWhiteListed(_user, totalWhiteListed);\n', '        }else\n', '\n', '            revert();\n', '    }\n', '\n', '    // @notice it will white list multiple members\n', '    // @param _user {address[]} of users to whitelist\n', '    // @return true if successful\n', '    function addToWhiteListMultiple(address[] _users) external onlyOwner() {\n', '\n', '        for (uint i = 0; i < _users.length; ++i) {\n', '\n', '            if (whiteList[_users[i]] != true) {\n', '                whiteList[_users[i]] = true;\n', '                totalWhiteListed++;\n', '            }\n', '        }\n', '        emit LogWhiteListedMultiple(totalWhiteListed);\n', '    }\n', '}']
['pragma solidity 0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) internal pure  returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure  returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure  returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(address(0) != _newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends tokens to contributors\n', 'contract Crowdsale is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensToSend; // amount of tokens  sent\n', '        bool refunded;\n', '    }\n', '\n', '    Token public token; // Token contract reference\n', '    address public multisig; // Multisig contract that will receive the ETH\n', '    address public team; // Address at which the team tokens will be sent\n', '    uint public ethReceivedPresale; // Number of ETH received in presale\n', '    uint public ethReceivedMain; // Number of ETH received in public sale\n', '    uint public tokensSentPresale; // Tokens sent during presale\n', '    uint public tokensSentMain; // Tokens sent during public ICO\n', '    uint public totalTokensSent; // Total number of tokens sent to contributors\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of tokens to sell\n', '    uint public minInvestETH; // Minimum amount to invest\n', '    bool public crowdsaleClosed; // Is crowdsale still in progress\n', '    Step public currentStep;  // To allow for controlled steps of the campaign\n', '    uint public refundCount;  // Number of refunds\n', '    uint public totalRefunded; // Total amount of Eth refunded\n', '    uint public numOfBlocksInMinute; // number of blocks in one minute * 100. eg.\n', '    WhiteList public whiteList;     // whitelist contract\n', '    uint public tokenPriceWei;      // Price of token in wei\n', '\n', '    mapping(address => Backer) public backers; // contributors list\n', '    address[] public backersIndex; // to be able to iterate through backers for verification.\n', '    uint public priorTokensSent;\n', '    uint public presaleCap;\n', '\n', '\n', '    // @notice to verify if action is not performed out of the campaign range\n', '    modifier respectTimeFrame() {\n', '        require(block.number >= startBlock && block.number <= endBlock);\n', '        _;\n', '    }\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {\n', '        FundingPreSale,     // presale mode\n', '        FundingPublicSale,  // public mode\n', '        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\n', '    }\n', '\n', '    // Events\n', '    event ReceivedETH(address indexed backer, uint amount, uint tokenAmount);\n', '    event RefundETH(address indexed backer, uint amount);\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initializes all constant and initial values.\n', '    // @param _dollarToEtherRatio {uint} how many dollars are in one eth.  $333.44/ETH would be passed as 33344\n', '    function Crowdsale(WhiteList _whiteList) public {\n', '\n', '        require(_whiteList != address(0));\n', '        multisig = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\n', '        team = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\n', '        maxCap = 1510000000e8;\n', '        minInvestETH = 1 ether/2;\n', '        currentStep = Step.FundingPreSale;\n', '        numOfBlocksInMinute = 408;          // E.g. 4.38 block/per minute wold be entered as 438\n', '        priorTokensSent = 4365098999e7;     //tokens distributed in private sale and airdrops\n', '        whiteList = _whiteList;             // white list address\n', '        presaleCap = 160000000e8;           // max for sell in presale\n', '        tokenPriceWei = 57142857142857;     // 17500 tokens per ether\n', '    }\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function setTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\n', '        require(token == address(0));\n', '        token = _tokenAddress;\n', '        return true;\n', '    }\n', '\n', '    // @notice set the step of the campaign from presale to public sale\n', '    // contract is deployed in presale mode\n', '    // WARNING: there is no way to go back\n', '    function advanceStep() public onlyOwner() {\n', '        require(Step.FundingPreSale == currentStep);\n', '        currentStep = Step.FundingPublicSale;\n', '        minInvestETH = 1 ether/4;\n', '    }\n', '\n', '    // @notice in case refunds are needed, money can be returned to the contract\n', '    // and contract switched to mode refunding\n', '    function prepareRefund() public payable onlyOwner() {\n', '\n', '        require(crowdsaleClosed);\n', '        require(msg.value == ethReceivedPresale.add(ethReceivedMain)); // make sure that proper amount of ether is sent\n', '        currentStep = Step.Refunding;\n', '    }\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors\n', '    function numberOfBackers() public view returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\n', '    // Contributor will be instructed to specify sufficient amount of gas. e.g. 250,000\n', '    function () external payable {\n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale\n', '    function start(uint _block) external onlyOwner() {\n', '\n', '        require(startBlock == 0);\n', '        require(_block <= (numOfBlocksInMinute * 60 * 24 * 54)/100);  // allow max 54 days for campaign\n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(_block);\n', '    }\n', '\n', '    // @notice Due to changing average of block time\n', '    // this function will allow on adjusting duration of campaign closer to the end\n', '    function adjustDuration(uint _block) external onlyOwner() {\n', '\n', '        require(startBlock > 0);\n', '        require(_block < (numOfBlocksInMinute * 60 * 24 * 60)/100); // allow for max of 60 days for campaign\n', '        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\n', '        endBlock = startBlock.add(_block);\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of contributor\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal whenNotPaused() respectTimeFrame() returns(bool res) {\n', '        require(!crowdsaleClosed);\n', '        require(whiteList.isWhiteListed(_backer));      // ensure that user is whitelisted\n', '\n', '        uint tokensToSend = determinePurchase();\n', '\n', '        Backer storage backer = backers[_backer];\n', '\n', '        if (backer.weiReceived == 0)\n', '            backersIndex.push(_backer);\n', '\n', "        backer.tokensToSend += tokensToSend; // save contributor's total tokens sent\n", "        backer.weiReceived = backer.weiReceived.add(msg.value);  // save contributor's total ether contributed\n", '\n', '        if (Step.FundingPublicSale == currentStep) { // Update the total Ether received and tokens sent during public sale\n', '            ethReceivedMain = ethReceivedMain.add(msg.value);\n', '            tokensSentMain += tokensToSend;\n', '        }else {                                                 // Update the total Ether recived and tokens sent during presale\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value);\n', '            tokensSentPresale += tokensToSend;\n', '        }\n', '\n', '        totalTokensSent += tokensToSend;     // update the total amount of tokens sent\n', '        multisig.transfer(address(this).balance);   // transfer funds to multisignature wallet\n', '\n', '        require(token.transfer(_backer, tokensToSend));   // Transfer tokens\n', '\n', '        emit ReceivedETH(_backer, msg.value, tokensToSend); // Register event\n', '        return true;\n', '    }\n', '\n', '    // @notice determine if purchase is valid and return proper number of tokens\n', '    // @return tokensToSend {uint} proper number of tokens based on the timline\n', '    function determinePurchase() internal view  returns (uint) {\n', '\n', '        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\n', '\n', '        uint tokensToSend = msg.value.mul(1e8) / tokenPriceWei;   //1e8 ensures that token gets 8 decimal values\n', '\n', '        if (Step.FundingPublicSale == currentStep) {  // calculate price of token in public sale\n', "            require(totalTokensSent + tokensToSend + priorTokensSent <= maxCap); // Ensure that max cap hasn't been reached\n", '        }else {\n', '            tokensToSend += (tokensToSend * 50) / 100;\n', "            require(totalTokensSent + tokensToSend <= presaleCap); // Ensure that max cap hasn't been reached for presale\n", '        }\n', '        return tokensToSend;\n', '    }\n', '\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    // it will fail if minimum cap is not reached\n', '    function finalize() external onlyOwner() {\n', '\n', '        require(!crowdsaleClosed);\n', '        // purchasing precise number of tokens might be impractical, thus subtract 1000\n', '        // tokens so finalization is possible near the end\n', '        require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000);\n', '        crowdsaleClosed = true;\n', '\n', '        require(token.transfer(team, token.balanceOf(this))); // transfer all remaining tokens to team address\n', '        token.unlock();\n', '    }\n', '\n', '    // @notice Fail-safe drain\n', '    function drain() external onlyOwner() {\n', '        multisig.transfer(address(this).balance);\n', '    }\n', '\n', '    // @notice Fail-safe token transfer\n', '    function tokenDrain() external onlyOwner() {\n', '        if (block.number > endBlock) {\n', '            require(token.transfer(multisig, token.balanceOf(this)));\n', '        }\n', '    }\n', '\n', '    // @notice it will allow contributors to get refund in case campaign failed\n', '    // @return {bool} true if successful\n', '    function refund() external whenNotPaused() returns (bool) {\n', '\n', '        require(currentStep == Step.Refunding);\n', '\n', '        Backer storage backer = backers[msg.sender];\n', '\n', '        require(backer.weiReceived > 0);  // ensure that user has sent contribution\n', "        require(!backer.refunded);        // ensure that user hasn't been refunded yet\n", '\n', '        backer.refunded = true;  // save refund status to true\n', '        refundCount++;\n', '        totalRefunded = totalRefunded + backer.weiReceived;\n', '\n', '        require(token.transfer(msg.sender, backer.tokensToSend)); // return allocated tokens\n', '        msg.sender.transfer(backer.weiReceived);  // send back the contribution\n', '        emit RefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint);\n', '\n', '    function allowance(address owner, address spender) public view returns(uint);\n', '\n', '    function transfer(address to, uint value) public returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) public returns(bool ok);\n', '\n', '    function approve(address spender, uint value) public returns(bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '// The token\n', 'contract Token is ERC20, Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals; // How many decimals to show.\n', '    string public version = "v0.1";\n', '    uint public totalSupply;\n', '    bool public locked;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    address public crowdSaleAddress;\n', '\n', '\n', '    // Lock transfer for contributors during the ICO\n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleAddress && msg.sender != owner && locked)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != owner && msg.sender != crowdSaleAddress)\n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice The Token contract\n', '    function Token(address _crowdsaleAddress) public {\n', '\n', '        require(_crowdsaleAddress != address(0));\n', '        locked = true; // Lock the transfer of tokens during the crowdsale\n', '        totalSupply = 2600000000e8;\n', '        name = "Kripton";                           // Set the name for display purposes\n', '        symbol = "LPK";                             // Set the symbol for display purposes\n', '        decimals = 8;                               // Amount of decimals\n', '        crowdSaleAddress = _crowdsaleAddress;\n', '        balances[_crowdsaleAddress] = totalSupply;\n', '    }\n', '\n', '    // @notice unlock token for trading\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '    }\n', '\n', '    // @lock token from trading during ICO\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '    }\n', '\n', '    // @notice transfer tokens to given address\n', '    // @param _to {address} address or recipient\n', '    // @param _value {uint} amount to transfer\n', '    // @return  {bool} true if successful\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice transfer tokens from given address to another address\n', '    // @param _from {address} from whom tokens are transferred\n', '    // @param _to {address} to whom tokens are transferred\n', '    // @parm _value {uint} amount of tokens to transfer\n', '    // @return  {bool} true if successful\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\n', '        require(balances[_from] >= _value); // Check if the sender has enough\n', '        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\n', '        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\n', '        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice to query balance of account\n', '    // @return _owner {address} address of user to query balance\n', '    function balanceOf(address _owner) public view returns(uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // @notice to query of allowance of one user to the other\n', '    // @param _owner {address} of the owner of the account\n', '    // @param _spender {address} of the spender of the account\n', '    // @return remaining {uint} amount of remaining allowance\n', '    function allowance(address _owner, address _spender) public view returns(uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// Whitelist smart contract\n', '// This smart contract keeps list of addresses to whitelist\n', 'contract WhiteList is Ownable {\n', '\n', '\n', '    mapping(address => bool) public whiteList;\n', '    uint public totalWhiteListed; //white listed users number\n', '\n', '    event LogWhiteListed(address indexed user, uint whiteListedNum);\n', '    event LogWhiteListedMultiple(uint whiteListedNum);\n', '    event LogRemoveWhiteListed(address indexed user);\n', '\n', '    // @notice it will return status of white listing\n', '    // @return true if user is white listed and false if is not\n', '    function isWhiteListed(address _user) external view returns (bool) {\n', '\n', '        return whiteList[_user];\n', '    }\n', '\n', '    // @notice it will remove whitelisted user\n', '    // @param _contributor {address} of user to unwhitelist\n', '    function removeFromWhiteList(address _user) external onlyOwner() {\n', '\n', '        require(whiteList[_user] == true);\n', '        whiteList[_user] = false;\n', '        totalWhiteListed--;\n', '        emit LogRemoveWhiteListed(_user);\n', '    }\n', '\n', '    // @notice it will white list one member\n', '    // @param _user {address} of user to whitelist\n', '    // @return true if successful\n', '    function addToWhiteList(address _user) external onlyOwner() {\n', '\n', '        if (whiteList[_user] != true) {\n', '            whiteList[_user] = true;\n', '            totalWhiteListed++;\n', '            emit LogWhiteListed(_user, totalWhiteListed);\n', '        }else\n', '\n', '            revert();\n', '    }\n', '\n', '    // @notice it will white list multiple members\n', '    // @param _user {address[]} of users to whitelist\n', '    // @return true if successful\n', '    function addToWhiteListMultiple(address[] _users) external onlyOwner() {\n', '\n', '        for (uint i = 0; i < _users.length; ++i) {\n', '\n', '            if (whiteList[_users[i]] != true) {\n', '                whiteList[_users[i]] = true;\n', '                totalWhiteListed++;\n', '            }\n', '        }\n', '        emit LogWhiteListedMultiple(totalWhiteListed);\n', '    }\n', '}']
