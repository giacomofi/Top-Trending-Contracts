['pragma solidity ^0.4.21;\n', '\n', 'library BWUtility {\n', '    \n', '    // -------- UTILITY FUNCTIONS ----------\n', '\n', '\n', '    // Return next higher even _multiple for _amount parameter (e.g used to round up to even finneys).\n', '    function ceil(uint _amount, uint _multiple) pure public returns (uint) {\n', '        return ((_amount + _multiple - 1) / _multiple) * _multiple;\n', '    }\n', '\n', '    // Checks if two coordinates are adjacent:\n', '    // xxx\n', '    // xox\n', '    // xxx\n', '    // All x (_x2, _xy2) are adjacent to o (_x1, _y1) in this ascii image. \n', '    // Adjacency does not wrapp around map edges so if y2 = 255 and y1 = 0 then they are not ajacent\n', '    function isAdjacent(uint8 _x1, uint8 _y1, uint8 _x2, uint8 _y2) pure public returns (bool) {\n', '        return ((_x1 == _x2 &&      (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Same column\n', '               ((_y1 == _y2 &&      (_x2 - _x1 == 1 || _x1 - _x2 == 1))) ||      // Same row\n', '               ((_x2 - _x1 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1))) ||      // Right upper or lower diagonal\n', '               ((_x1 - _x2 == 1 &&  (_y2 - _y1 == 1 || _y1 - _y2 == 1)));        // Left upper or lower diagonal\n', '    }\n', '\n', '    // Converts (x, y) to tileId xy\n', '    function toTileId(uint8 _x, uint8 _y) pure public returns (uint16) {\n', '        return uint16(_x) << 8 | uint16(_y);\n', '    }\n', '\n', '    // Converts _tileId to (x, y)\n', '    function fromTileId(uint16 _tileId) pure public returns (uint8, uint8) {\n', '        uint8 y = uint8(_tileId);\n', '        uint8 x = uint8(_tileId >> 8);\n', '        return (x, y);\n', '    }\n', '    \n', '    function getBoostFromTile(address _claimer, address _attacker, address _defender, uint _blockValue) pure public returns (uint, uint) {\n', '        if (_claimer == _attacker) {\n', '            return (_blockValue, 0);\n', '        } else if (_claimer == _defender) {\n', '            return (0, _blockValue);\n', '        }\n', '    }\n', '}']