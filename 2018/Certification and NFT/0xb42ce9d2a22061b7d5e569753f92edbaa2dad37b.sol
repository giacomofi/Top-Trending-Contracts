['interface IYeekFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\n', '}\n', '\n', 'interface ITradeableAsset {\n', '    function totalSupply() external view returns (uint256);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function decimals() external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function balanceOf(address _address) external view returns (uint256);\n', '}\n', '\n', '/* A basic permissions hierarchy (Owner -> Admin -> Everyone else). One owner may appoint and remove any number of admins\n', '   and may transfer ownership to another individual address */\n', 'contract Administered {\n', '    address public creator;\n', '    uint public commission = 1;\n', '    mapping (address => bool) public admins;\n', '    \n', '    constructor()  public {\n', '        creator = msg.sender;\n', '        admins[creator] = true;\n', '    }\n', '\n', '    //Restrict to the current owner. There may be only 1 owner at a time, but \n', '    //ownership can be transferred.\n', '    modifier onlyOwner {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    //Restrict to any admin. Not sufficient for highly sensitive methods\n', '    //since basic admin can be granted programatically regardless of msg.sender\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender] || creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    //Add an admin with basic privileges. Can be done by any superuser (or the owner)\n', '    function grantAdmin(address newAdmin) onlyOwner  public {\n', '        _grantAdmin(newAdmin);\n', '    }\n', '\n', '    function _grantAdmin(address newAdmin) internal\n', '    {\n', '        admins[newAdmin] = true;\n', '    }\n', '\n', '    //Transfer ownership\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        creator = newOwner;\n', '    }\n', '\n', '    //Remove an admin\n', '    function revokeAdminStatus(address user) onlyOwner public {\n', '        admins[user] = false;\n', '    }\n', '}\n', '\n', '/* A liqudity pool that executes buy and sell orders for an ETH / Token Pair */\n', '/* The owner deploys it and then adds tokens / ethereum in the desired ratio */\n', '\n', 'contract Exchanger is Administered {\n', '    bool public enabled = false;    //Owner can turn off and on\n', '\n', '    //The token which is being bought and sold\n', '    ITradeableAsset public tokenContract;\n', '    //The contract that does the calculations to determine buy and sell pricing\n', '    IYeekFormula public formulaContract;\n', '    //The reserve pct of this exchanger, expressed in ppm\n', '    uint32 public weight;\n', '\n', '    /** \n', '        @dev Deploys an exchanger contract for a given token / Ether pairing\n', '        @param _token An ERC20 token\n', '        @param _weight The reserve fraction of this exchanger, in ppm\n', '        @param _formulaContract The contract with the algorithms to calculate price\n', '     */\n', '\n', '    constructor(address _token, \n', '                uint32 _weight,\n', '                address _formulaContract) {\n', '        require (_weight > 0 && weight <= 1000000);\n', '        \n', '        weight = _weight;\n', '        tokenContract = ITradeableAsset(_token);\n', '        formulaContract = IYeekFormula(_formulaContract);\n', '    }\n', '\n', '    //Events raised on completion of buy and sell orders. \n', '    //The web client can use this info to provide users with their trading history for a given token\n', '    //and also to notify when a trade has completed.\n', '\n', '    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\n', '    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\n', '\n', '\n', '    // The following methods are for the owner and admins to manage the Exchanger\n', '    \n', '    /**\n', '     @dev Deposit tokens to the reserve.\n', '     */\n', '    function depositTokens(uint amount) onlyOwner public {\n', '        tokenContract.transferFrom(msg.sender, this, amount);\n', '    }\n', '        \n', '    /**\n', '     @dev Deposit ether to the reserve\n', '     */\n', '     function depositEther() onlyOwner public payable {\n', '        //return getQuotePrice(); \n', '     }\n', '\n', '    /**  \n', '     @dev Withdraw tokens from the reserve\n', '     */\n', '    function withdrawTokens(uint amount) onlyOwner public {\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw ether from the reserve\n', '     */\n', '    function withdrawEther(uint amountInWei) onlyOwner public {\n', '        msg.sender.transfer(amountInWei); //Transfers in wei\n', '    }\n', '\n', '    /**\n', '     @dev Enable trading\n', '     */\n', '     function enable() onlyAdmin public {\n', '         enabled = true;\n', '     }\n', '\n', '     /**\n', '      @dev Disable trading\n', '     */\n', '     function disable() onlyAdmin public {\n', '         enabled = false;\n', '     }\n', '\n', '     /**\n', '      @dev Play central banker and set the fractional reserve ratio, from 1 to 1000000 ppm.\n', '      It is highly disrecommended to do this while trading is enabled! If you don&#39;t know what \n', '      a fractional reserve is, please put this contract away and go work for your local government.\n', '     */\n', '     function setReserveWeight(uint32 ppm) onlyAdmin public {\n', '         require (ppm>0 && ppm<=1000000);\n', '         weight = ppm;\n', '     }\n', '\n', '    //These methods return information about the exchanger, and the buy / sell rates offered on the Token / ETH pairing.\n', '    //They can be called without gas from any client.\n', '\n', '    /**  \n', '     @dev Audit the reserve balances, in the base token and in ether\n', '     */\n', '    function getReserveBalances() public view returns (uint256, uint256) {\n', '        return (tokenContract.balanceOf(this), address(this).balance);\n', '    }\n', '\n', '\n', '    /**\n', '     @dev Gets price based on a sample 1 ether BUY order\n', '     */\n', '    function getQuotePrice() public view returns(uint) {\n', '        uint tokensPerEther = \n', '        formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            1 ether \n', '        ); \n', '\n', '        return tokensPerEther;\n', '    }\n', '\n', '    /**\n', '     @dev Get the BUY price based on the order size. Returned as the number of tokens that the amountInWei will buy.\n', '     */\n', '    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\n', '        uint tokensPerEther =  formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            amountInWei \n', '        ); \n', '        \n', '        return tokensPerEther - (tokensPerEther * commission / 100);\n', '    }\n', '\n', '    /**\n', '     @dev Get the SELL price based on the order size. Returned as amount (in wei) that you&#39;ll get for your tokens.\n', '     */\n', '    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\n', '        uint weiRaw= formulaContract.calculateSaleReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            tokensToSell \n', '        ); \n', '        \n', '        return weiRaw - (weiRaw * commission / 100);\n', '    }\n', '\n', '    //buy and sell execute live trades against the exchanger. For either method, \n', '    //you must specify your minimum return (in total tokens or ether that you expect to receive for your trade)\n', '    //this protects the trader against slippage due to other orders that make it into earlier blocks after they \n', '    //place their order. \n', '    //\n', '    //With buy, send the amount of ether you want to spend on the token - you&#39;ll get it back immediately if minPurchaseReturn\n', '    //is not met or if this Exchanger is not in a condition to service your order (usually this happens when there is not a full \n', '    //reserve of tokens to satisfy the stated weight)\n', '    //\n', '    //With sell, first approve the exchanger to spend the number of tokens you want to sell\n', '    //Then call sell with that number and your minSaleReturn. The token transfer will not happen \n', '    //if the minSaleReturn is not met.\n', '    //\n', '    //Sales always go through, as long as there is any ether in the reserve... but those dumping massive quantities of tokens\n', '    //will naturally be given the shittest rates.\n', '\n', '    /**\n', '     @dev Buy tokens with ether. \n', '     @param minPurchaseReturn The minimum number of tokens you will accept.\n', '     */\n', '    function buy(uint minPurchaseReturn) public payable {\n', '        uint amount = formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance - msg.value,\n', '            weight,\n', '            msg.value);\n', '        require (enabled);\n', '        require (amount >= minPurchaseReturn);\n', '        require (tokenContract.balanceOf(this) >= amount);\n', '        emit Buy(msg.sender, msg.value, amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '    /**\n', '     @dev Sell tokens for ether\n', '     @param quantity Number of tokens to sell\n', '     @param minSaleReturn Minimum amount of ether (in wei) you will accept for your tokens\n', '     */\n', '     function sell(uint quantity, uint minSaleReturn) public {\n', '         uint amountInWei = formulaContract.calculateSaleReturn(\n', '             tokenContract.totalSupply(),\n', '             address(this).balance,\n', '             weight,\n', '             quantity\n', '         );\n', '         require (enabled);\n', '         require (amountInWei >= minSaleReturn);\n', '         require (amountInWei <= address(this).balance);\n', '         require (tokenContract.transferFrom(msg.sender, this, quantity));\n', '         emit Sell(msg.sender, quantity, amountInWei);\n', '         msg.sender.transfer(amountInWei); //Always send ether last\n', '     }\n', '}']
['interface IYeekFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\n', '}\n', '\n', 'interface ITradeableAsset {\n', '    function totalSupply() external view returns (uint256);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function decimals() external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function balanceOf(address _address) external view returns (uint256);\n', '}\n', '\n', '/* A basic permissions hierarchy (Owner -> Admin -> Everyone else). One owner may appoint and remove any number of admins\n', '   and may transfer ownership to another individual address */\n', 'contract Administered {\n', '    address public creator;\n', '    uint public commission = 1;\n', '    mapping (address => bool) public admins;\n', '    \n', '    constructor()  public {\n', '        creator = msg.sender;\n', '        admins[creator] = true;\n', '    }\n', '\n', '    //Restrict to the current owner. There may be only 1 owner at a time, but \n', '    //ownership can be transferred.\n', '    modifier onlyOwner {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    //Restrict to any admin. Not sufficient for highly sensitive methods\n', '    //since basic admin can be granted programatically regardless of msg.sender\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender] || creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    //Add an admin with basic privileges. Can be done by any superuser (or the owner)\n', '    function grantAdmin(address newAdmin) onlyOwner  public {\n', '        _grantAdmin(newAdmin);\n', '    }\n', '\n', '    function _grantAdmin(address newAdmin) internal\n', '    {\n', '        admins[newAdmin] = true;\n', '    }\n', '\n', '    //Transfer ownership\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        creator = newOwner;\n', '    }\n', '\n', '    //Remove an admin\n', '    function revokeAdminStatus(address user) onlyOwner public {\n', '        admins[user] = false;\n', '    }\n', '}\n', '\n', '/* A liqudity pool that executes buy and sell orders for an ETH / Token Pair */\n', '/* The owner deploys it and then adds tokens / ethereum in the desired ratio */\n', '\n', 'contract Exchanger is Administered {\n', '    bool public enabled = false;    //Owner can turn off and on\n', '\n', '    //The token which is being bought and sold\n', '    ITradeableAsset public tokenContract;\n', '    //The contract that does the calculations to determine buy and sell pricing\n', '    IYeekFormula public formulaContract;\n', '    //The reserve pct of this exchanger, expressed in ppm\n', '    uint32 public weight;\n', '\n', '    /** \n', '        @dev Deploys an exchanger contract for a given token / Ether pairing\n', '        @param _token An ERC20 token\n', '        @param _weight The reserve fraction of this exchanger, in ppm\n', '        @param _formulaContract The contract with the algorithms to calculate price\n', '     */\n', '\n', '    constructor(address _token, \n', '                uint32 _weight,\n', '                address _formulaContract) {\n', '        require (_weight > 0 && weight <= 1000000);\n', '        \n', '        weight = _weight;\n', '        tokenContract = ITradeableAsset(_token);\n', '        formulaContract = IYeekFormula(_formulaContract);\n', '    }\n', '\n', '    //Events raised on completion of buy and sell orders. \n', '    //The web client can use this info to provide users with their trading history for a given token\n', '    //and also to notify when a trade has completed.\n', '\n', '    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\n', '    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\n', '\n', '\n', '    // The following methods are for the owner and admins to manage the Exchanger\n', '    \n', '    /**\n', '     @dev Deposit tokens to the reserve.\n', '     */\n', '    function depositTokens(uint amount) onlyOwner public {\n', '        tokenContract.transferFrom(msg.sender, this, amount);\n', '    }\n', '        \n', '    /**\n', '     @dev Deposit ether to the reserve\n', '     */\n', '     function depositEther() onlyOwner public payable {\n', '        //return getQuotePrice(); \n', '     }\n', '\n', '    /**  \n', '     @dev Withdraw tokens from the reserve\n', '     */\n', '    function withdrawTokens(uint amount) onlyOwner public {\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**  \n', '     @dev Withdraw ether from the reserve\n', '     */\n', '    function withdrawEther(uint amountInWei) onlyOwner public {\n', '        msg.sender.transfer(amountInWei); //Transfers in wei\n', '    }\n', '\n', '    /**\n', '     @dev Enable trading\n', '     */\n', '     function enable() onlyAdmin public {\n', '         enabled = true;\n', '     }\n', '\n', '     /**\n', '      @dev Disable trading\n', '     */\n', '     function disable() onlyAdmin public {\n', '         enabled = false;\n', '     }\n', '\n', '     /**\n', '      @dev Play central banker and set the fractional reserve ratio, from 1 to 1000000 ppm.\n', "      It is highly disrecommended to do this while trading is enabled! If you don't know what \n", '      a fractional reserve is, please put this contract away and go work for your local government.\n', '     */\n', '     function setReserveWeight(uint32 ppm) onlyAdmin public {\n', '         require (ppm>0 && ppm<=1000000);\n', '         weight = ppm;\n', '     }\n', '\n', '    //These methods return information about the exchanger, and the buy / sell rates offered on the Token / ETH pairing.\n', '    //They can be called without gas from any client.\n', '\n', '    /**  \n', '     @dev Audit the reserve balances, in the base token and in ether\n', '     */\n', '    function getReserveBalances() public view returns (uint256, uint256) {\n', '        return (tokenContract.balanceOf(this), address(this).balance);\n', '    }\n', '\n', '\n', '    /**\n', '     @dev Gets price based on a sample 1 ether BUY order\n', '     */\n', '    function getQuotePrice() public view returns(uint) {\n', '        uint tokensPerEther = \n', '        formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            1 ether \n', '        ); \n', '\n', '        return tokensPerEther;\n', '    }\n', '\n', '    /**\n', '     @dev Get the BUY price based on the order size. Returned as the number of tokens that the amountInWei will buy.\n', '     */\n', '    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\n', '        uint tokensPerEther =  formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            amountInWei \n', '        ); \n', '        \n', '        return tokensPerEther - (tokensPerEther * commission / 100);\n', '    }\n', '\n', '    /**\n', "     @dev Get the SELL price based on the order size. Returned as amount (in wei) that you'll get for your tokens.\n", '     */\n', '    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\n', '        uint weiRaw= formulaContract.calculateSaleReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance,\n', '            weight,\n', '            tokensToSell \n', '        ); \n', '        \n', '        return weiRaw - (weiRaw * commission / 100);\n', '    }\n', '\n', '    //buy and sell execute live trades against the exchanger. For either method, \n', '    //you must specify your minimum return (in total tokens or ether that you expect to receive for your trade)\n', '    //this protects the trader against slippage due to other orders that make it into earlier blocks after they \n', '    //place their order. \n', '    //\n', "    //With buy, send the amount of ether you want to spend on the token - you'll get it back immediately if minPurchaseReturn\n", '    //is not met or if this Exchanger is not in a condition to service your order (usually this happens when there is not a full \n', '    //reserve of tokens to satisfy the stated weight)\n', '    //\n', '    //With sell, first approve the exchanger to spend the number of tokens you want to sell\n', '    //Then call sell with that number and your minSaleReturn. The token transfer will not happen \n', '    //if the minSaleReturn is not met.\n', '    //\n', '    //Sales always go through, as long as there is any ether in the reserve... but those dumping massive quantities of tokens\n', '    //will naturally be given the shittest rates.\n', '\n', '    /**\n', '     @dev Buy tokens with ether. \n', '     @param minPurchaseReturn The minimum number of tokens you will accept.\n', '     */\n', '    function buy(uint minPurchaseReturn) public payable {\n', '        uint amount = formulaContract.calculatePurchaseReturn(\n', '            tokenContract.totalSupply(),\n', '            address(this).balance - msg.value,\n', '            weight,\n', '            msg.value);\n', '        require (enabled);\n', '        require (amount >= minPurchaseReturn);\n', '        require (tokenContract.balanceOf(this) >= amount);\n', '        emit Buy(msg.sender, msg.value, amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '    /**\n', '     @dev Sell tokens for ether\n', '     @param quantity Number of tokens to sell\n', '     @param minSaleReturn Minimum amount of ether (in wei) you will accept for your tokens\n', '     */\n', '     function sell(uint quantity, uint minSaleReturn) public {\n', '         uint amountInWei = formulaContract.calculateSaleReturn(\n', '             tokenContract.totalSupply(),\n', '             address(this).balance,\n', '             weight,\n', '             quantity\n', '         );\n', '         require (enabled);\n', '         require (amountInWei >= minSaleReturn);\n', '         require (amountInWei <= address(this).balance);\n', '         require (tokenContract.transferFrom(msg.sender, this, quantity));\n', '         emit Sell(msg.sender, quantity, amountInWei);\n', '         msg.sender.transfer(amountInWei); //Always send ether last\n', '     }\n', '}']
