['pragma solidity ^0.4.24;\n', '\n', '/// @title A facet of CSportsCore that holds all important constants and modifiers\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsConstants {\n', '\n', '    /// @dev The maximum # of marketing tokens that can ever be created\n', '    /// by the commissioner.\n', '    uint16 public MAX_MARKETING_TOKENS = 2500;\n', '\n', '    /// @dev The starting price for commissioner auctions (if the average\n', '    ///   of the last 2 is less than this, we will use this value)\n', '    ///   A finney is 1/1000 of an ether.\n', '    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\n', '\n', '    /// @dev The duration of commissioner auctions\n', '    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\n', '\n', '    /// @dev Number of seconds in a week\n', '    uint32 constant WEEK_SECS = 1 weeks;\n', '\n', '}\n', '\n', '/// @title A facet of CSportsCore that manages an individual&#39;s authorized role against access privileges.\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsAuth is CSportsConstants {\n', '    // This facet controls access control for CryptoSports. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the CSportsCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can perform administrative functions.\n', '    //\n', '    //     - The Commisioner can perform "oracle" functions like adding new real world players,\n', '    //       setting players active/inactive, and scoring contests.\n', '    //\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '    address public commissionerAddress;\n', '\n', '    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Flag that identifies whether or not we are in development and should allow development\n', '    /// only functions to be called.\n', '    bool public isDevelopment = true;\n', '\n', '    /// @dev Access modifier to allow access to development mode functions\n', '    modifier onlyUnderDevelopment() {\n', '      require(isDevelopment == true);\n', '      _;\n', '    }\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for Commissioner-only functionality\n', '    modifier onlyCommissioner() {\n', '        require(msg.sender == commissionerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Requires any one of the C level addresses\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress ||\n', '            msg.sender == commissionerAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev prevents contracts from hitting the method\n', '    modifier notContract() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev One way switch to set the contract into prodution mode. This is one\n', '    /// way in that the contract can never be set back into development mode. Calling\n', '    /// this function will block all future calls to functions that are meant for\n', '    /// access only while we are under development. It will also enable more strict\n', '    /// additional checking on various parameters and settings.\n', '    function setProduction() public onlyCEO onlyUnderDevelopment {\n', '      isDevelopment = false;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\n', '    /// @param _newCommissioner The address of the new COO\n', '    function setCommissioner(address _newCommissioner) public onlyCEO {\n', '        require(_newCommissioner != address(0));\n', '\n', '        commissionerAddress = _newCommissioner;\n', '    }\n', '\n', '    /// @dev Assigns all C-Level addresses\n', '    /// @param _ceo CEO address\n', '    /// @param _cfo CFO address\n', '    /// @param _coo COO address\n', '    /// @param _commish Commissioner address\n', '    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\n', '        require(_ceo != address(0));\n', '        require(_cfo != address(0));\n', '        require(_coo != address(0));\n', '        require(_commish != address(0));\n', '        ceoAddress = _ceo;\n', '        cfoAddress = _cfo;\n', '        cooAddress = _coo;\n', '        commissionerAddress = _commish;\n', '    }\n', '\n', '    /// @dev Transfers the balance of this contract to the CFO\n', '    function withdrawBalance() external onlyCFO {\n', '        cfoAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() public onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '/// @title CSportsContestBase base class for contests and teams contracts\n', '/// @dev This interface defines base class for contests and teams contracts\n', '/// @author CryptoSports\n', 'contract CSportsContestBase {\n', '\n', '    /// @dev Structure holding the player token IDs for a team\n', '    struct Team {\n', '      address owner;              // Address of the owner of the player tokens\n', '      int32 score;                // Score assigned to this team after a contest\n', '      uint32 place;               // Place this team finished in its contest\n', '      bool holdsEntryFee;         // TRUE if this team currently holds an entry fee\n', '      bool ownsPlayerTokens;      // True if the tokens are being escrowed by the Team contract\n', '      uint32[] playerTokenIds;    // IDs of the tokens held by this team\n', '    }\n', '\n', '}\n', '\n', '/// @title CSportsTeam Interface\n', '/// @dev This interface defines methods required by the CSportsContestCore\n', '///   in implementing a contest.\n', '/// @author CryptoSports\n', 'contract CSportsTeam {\n', '\n', '    bool public isTeamContract;\n', '\n', '    /// @dev Define team events\n', '    event TeamCreated(uint256 teamId, address owner);\n', '    event TeamUpdated(uint256 teamId);\n', '    event TeamReleased(uint256 teamId);\n', '    event TeamScored(uint256 teamId, int32 score, uint32 place);\n', '    event TeamPaid(uint256 teamId);\n', '\n', '    function setCoreContractAddress(address _address) public;\n', '    function setLeagueRosterContractAddress(address _address) public;\n', '    function setContestContractAddress(address _address) public;\n', '    function createTeam(address _owner, uint32[] _tokenIds) public returns (uint32);\n', '    function updateTeam(address _owner, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public;\n', '    function releaseTeam(uint32 _teamId) public;\n', '    function getTeamOwner(uint32 _teamId) public view returns (address);\n', '    function scoreTeams(uint32[] _teamIds, int32[] _scores, uint32[] _places) public;\n', '    function getScore(uint32 _teamId) public view returns (int32);\n', '    function getPlace(uint32 _teamId) public view returns (uint32);\n', '    function ownsPlayerTokens(uint32 _teamId) public view returns (bool);\n', '    function refunded(uint32 _teamId) public;\n', '    function tokenIdsForTeam(uint32 _teamId) public view returns (uint32, uint32[50]);\n', '    function getTeam(uint32 _teamId) public view returns (\n', '        address _owner,\n', '        int32 _score,\n', '        uint32 _place,\n', '        bool _holdsEntryFee,\n', '        bool _ownsPlayerTokens);\n', '}\n', '\n', '/// @title CSports Contest\n', '/// @dev Implementation of a fantasy sports contest using tokens managed\n', '///   by a CSportsCore contract. This class implements functionality that\n', '///   is generic to any sport that involves teams. The specifics of how\n', '///   teams are structured, validated, and scored happen in the attached\n', '///   contract that implements the CSportsTeam interface.\n', 'contract CSportsContest is CSportsAuth, CSportsContestBase {\n', '\n', '  enum ContestStatus { Invalid, Active, Scoring, Paying, Paid, Canceled }\n', '  enum PayoutKey { Invalid, WinnerTakeAll, FiftyFifty, TopTen }\n', '\n', '  /// @dev Used as sanity check by other contracts\n', '  bool public isContestContract = true;\n', '\n', '  /// @dev Instance of the team contract connected to this contest. It is\n', '  ///   the team contract that implements most of the specific rules for\n', '  ///   this contrest.\n', '  CSportsTeam public teamContract;\n', '\n', '  /// @dev Cut owner takes of the entry fees paid into a contest as a fee for\n', '  ///   scoring the contest (measured in basis points (1/100 of a percent).\n', '  ///   Values 0-10,000 map to 0%-100%\n', '  uint256 public ownerCut;\n', '\n', '  /// @dev Structure for the definition of a single contest.\n', '  struct Contest {\n', '    address scoringOracleAddress;                 // Eth address of scoring oracle, if == 0, it&#39;s our commissioner address\n', '    address creator;                              // Address of the creator of the contest\n', '    uint32 gameSetId;                             // ID of the gameset associated with this contest\n', '    uint32 numWinners;                            // Number of winners in this contest\n', '    uint32 winnersToPay;                          // Number of winners that remain to be paid\n', '    uint64 startTime;                             // Starting time for the contest (lock time)\n', '    uint64 endTime;                               // Ending time for  the contest (can score after this time)\n', '    uint128 entryFee;                             // Fee to enter the contest\n', '    uint128 prizeAmount;                          // Fee to enter the contest\n', '    uint128 remainingPrizeAmount;                 // Remaining amount of prize money to payout\n', '    uint64 maxMinEntries;                         // Maximum and minimum number of entries allowed in the contest\n', '    ContestStatus status;                         // 1 = active, 2 = scoring, 3 = paying, 4 = paid, 5 = canceled\n', '    PayoutKey payoutKey;                          // Identifies the payout structure for the contest (see comments above)\n', '    uint32[] teamIds;                             // An array of teams entered into this contest\n', '    string name;                                  // Name of contest\n', '    mapping (uint32 => uint32) placeToWinner;     // Winners list mapping place to teamId\n', '    mapping (uint32 => uint32) teamIdToIdx;       // Maps a team ID to its index into the teamIds array\n', '  }\n', '\n', '  /// @dev Holds all of our contests (public)\n', '  Contest[] public contests;\n', '\n', '  /// @dev Maps team IDs to contest IDs\n', '  mapping (uint32 => uint32) public teamIdToContestId;\n', '\n', '  /// @dev We do not transfer funds directly to users when making any kind of payout. We\n', '  ///   require the user to pull his own funds. This is to eliminate DoS and reentrancy problems.\n', '  mapping (address => uint128) public authorizedUserPayment;\n', '\n', '  /// @dev Always has the total amount this contract is authorized to pay out to\n', '  ///   users.\n', '  uint128 public totalAuthorizedForPayment;\n', '\n', '  /// @dev Define contest events\n', '  event ContestCreated(uint256 contestId);\n', '  event ContestCanceled(uint256 contestId);\n', '  event ContestEntered(uint256 contestId, uint256 teamId);\n', '  event ContestExited(uint256 contestId, uint256 teamId);\n', '  event ContestClosed(uint32 contestId);\n', '  event ContestTeamWinningsPaid(uint32 contestId, uint32 teamId, uint128 amount);\n', '  event ContestTeamRefundPaid(uint32 contestId, uint32 teamId, uint128 amount);\n', '  event ContestCreatorEntryFeesPaid(uint32 contestId, uint128 amount);\n', '  event ContestApprovedFundsDelivered(address toAddress, uint128 amount);\n', '\n', '  /// @dev Class constructor creates the main CSportsContest smart contract instance.\n', '  constructor(uint256 _cut) public {\n', '      require(_cut <= 10000);\n', '      ownerCut = _cut;\n', '\n', '      // All C-level roles are the message sender\n', '      ceoAddress = msg.sender;\n', '      cfoAddress = msg.sender;\n', '      cooAddress = msg.sender;\n', '      commissionerAddress = msg.sender;\n', '\n', '      // Create a contest to take up the 0th slot.\n', '      // Create it in the canceled state with no teams.\n', '      // This is to deal with the fact that mappings return 0\n', '      // when queried with non-existent keys.\n', '      Contest memory _contest = Contest({\n', '          scoringOracleAddress: commissionerAddress,\n', '          gameSetId: 0,\n', '          maxMinEntries: 0,\n', '          numWinners: 0,\n', '          winnersToPay: 0,\n', '          startTime: 0,\n', '          endTime: 0,\n', '          creator: msg.sender,\n', '          entryFee: 0,\n', '          prizeAmount: 0,\n', '          remainingPrizeAmount: 0,\n', '          status: ContestStatus.Canceled,\n', '          payoutKey: PayoutKey(0),\n', '          name: "mythical",\n', '          teamIds: new uint32[](0)\n', '        });\n', '\n', '        contests.push(_contest);\n', '  }\n', '\n', '  /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '  ///  one reason we may pause the contract is when CFO or COO accounts are\n', '  ///  compromised.\n', '  function unpause() public onlyCEO whenPaused {\n', '    // can&#39;t unpause if contract was upgraded\n', '    paused = false;\n', '  }\n', '\n', '  /// @dev Sets the teamContract that will manage teams for this contest\n', '  /// @param _address - Address of our team contract\n', '  function setTeamContractAddress(address _address) public onlyCEO {\n', '    CSportsTeam candidateContract = CSportsTeam(_address);\n', '    require(candidateContract.isTeamContract());\n', '    teamContract = candidateContract;\n', '  }\n', '\n', '  /// @dev Allows anyone who has funds approved to receive them. We use this\n', '  ///   "pull" funds mechanism to eliminate problems resulting from malicious behavior.\n', '  function transferApprovedFunds() public {\n', '    uint128 amount = authorizedUserPayment[msg.sender];\n', '    if (amount > 0) {\n', '\n', '      // Shouldn&#39;t have to check this, but if for any reason things got screwed up,\n', '      // this prevents anyone from withdrawing more than has been approved in total\n', '      // on the contract.\n', '      if (totalAuthorizedForPayment >= amount) {\n', '\n', '        // Imporant to do the delete before the transfer to eliminate re-entrancy attacks\n', '        delete authorizedUserPayment[msg.sender];\n', '        totalAuthorizedForPayment -= amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        // Create log entry\n', '        emit ContestApprovedFundsDelivered(msg.sender, amount);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the amount of funds available for a given sender\n', '  function authorizedFundsAvailable() public view returns (uint128) {\n', '    return authorizedUserPayment[msg.sender];\n', '  }\n', '\n', '  /// @dev Returns the total amount of ether held by this contract\n', '  /// that has been approved for dispursement to contest creators\n', '  /// and participants.\n', '  function getTotalAuthorizedForPayment() public view returns (uint128) {\n', '    return totalAuthorizedForPayment;\n', '  }\n', '\n', '  /// @dev Creates a team for this contest. Called by an end-user of the CSportsCore\n', '  ///   contract. If the contract is paused, no additional contests can be created (although\n', '  ///   all other contract functionality remains valid.\n', '  /// @param _gameSetId - Identifes the games associated with contest. Used by the scoring oracle.\n', '  /// @param _startTime - Start time for the contest, used to determine locking of the teams\n', '  /// @param _endTime - End time representing the earliest this contest can be scored by the oracle\n', '  /// @param _entryFee - Entry fee paid to enter a team into this contest\n', '  /// @param _prizeAmount - Prize amount awarded to the winner\n', '  /// @param _maxEntries - Maximum number of entries in the contest\n', '  /// @param _minEntries - If false, we will return all ether and release all players\n', '  /// @param _payoutKey - Identifes the payout structure for the contest\n', '  ///   if we hit the start time with fewer than _maxEntries teams entered into the contest.\n', '  /// @param _tokenIds - Player token ids to be associated with the creator&#39;s team.\n', '  function createContest\n', '  (\n', '    string _name,\n', '    address _scoringOracleAddress,\n', '    uint32 _gameSetId,\n', '    uint64 _startTime,\n', '    uint64 _endTime,\n', '    uint128 _entryFee,\n', '    uint128 _prizeAmount,\n', '    uint32 _maxEntries,\n', '    uint32 _minEntries,\n', '    uint8 _payoutKey,\n', '    uint32[] _tokenIds\n', '  ) public payable whenNotPaused {\n', '\n', '      require (msg.sender != address(0));\n', '      require (_endTime > _startTime);\n', '      require (_maxEntries != 1);\n', '      require (_minEntries <= _maxEntries);\n', '      require(_startTime > uint64(now));\n', '\n', '      // The commissioner is allowed to create contests with no initial entry\n', '      require((msg.sender == commissionerAddress) || (_tokenIds.length > 0));\n', '\n', '      // Make sure we don&#39;t overflow\n', '      require(((_prizeAmount + _entryFee) >= _prizeAmount) && ((_prizeAmount + _entryFee) >= _entryFee));\n', '\n', '      // Creator must put up the correct amount of ether to cover the prize as well\n', '      // as his own entry fee if a team has been entered.\n', '      if (_tokenIds.length > 0) {\n', '        require(msg.value == (_prizeAmount + _entryFee));\n', '      } else {\n', '        require(msg.value == _prizeAmount);\n', '      }\n', '\n', '      // The default scoring oracle address will be set to the commissionerAddress\n', '      if (_scoringOracleAddress == address(0)) {\n', '        _scoringOracleAddress = commissionerAddress;\n', '      }\n', '\n', '      // Pack our maxMinEntries (due to stack limitations on struct sizes)\n', '      // uint64 maxMinEntries = (uint64(_maxEntries) << 32) | uint64(_minEntries);\n', '\n', '      // Create the contest object in memory\n', '      Contest memory _contest = Contest({\n', '          scoringOracleAddress: _scoringOracleAddress,\n', '          gameSetId: _gameSetId,\n', '          maxMinEntries: (uint64(_maxEntries) << 32) | uint64(_minEntries),\n', '          numWinners: 0,\n', '          winnersToPay: 0,\n', '          startTime: _startTime,\n', '          endTime: _endTime,\n', '          creator: msg.sender,\n', '          entryFee: _entryFee,\n', '          prizeAmount: _prizeAmount,\n', '          remainingPrizeAmount: _prizeAmount,\n', '          status: ContestStatus.Active,\n', '          payoutKey: PayoutKey(_payoutKey),\n', '          name: _name,\n', '          teamIds: new uint32[](0)\n', '        });\n', '\n', '      // We only create a team if we have tokens\n', '      uint32 uniqueTeamId = 0;\n', '      if (_tokenIds.length > 0) {\n', '        // Create the team for the creator of this contest. This\n', '        // will throw if msg.sender does not own all _tokenIds. The result\n', '        // of this call is that the team contract will now own the tokens.\n', '        //\n', '        // Note that the _tokenIds MUST BE OWNED by the msg.sender, and\n', '        // there may be other conditions enforced by the CSportsTeam contract&#39;s\n', '        // createTeam(...) method.\n', '        uniqueTeamId = teamContract.createTeam(msg.sender, _tokenIds);\n', '\n', '        // Again, we make sure our unique teamId stays within bounds\n', '        require(uniqueTeamId < 4294967295);\n', '        _contest.teamIds = new uint32[](1);\n', '        _contest.teamIds[0] = uniqueTeamId;\n', '\n', '        // We do not have to do this mapping here because 0 is returned from accessing\n', '        // a non existent member of a mapping (we deal with this when we use this\n', '        // structure in removing a team from the teamIds array). Can&#39;t do it anyway because\n', '        // mappings can&#39;t be accessed outside of storage.\n', '        //\n', '        // _contest.teamIdToIdx[uniqueTeamId] = 0;\n', '      }\n', '\n', '      // Save our contest\n', '      //\n', '      // It&#39;s probably never going to happen, 4 billion contests and teams is A LOT, but\n', '      // let&#39;s just be 100% sure we never let this happen because teamIds are\n', '      // often cast as uint32.\n', '      uint256 _contestId = contests.push(_contest) - 1;\n', '      require(_contestId < 4294967295);\n', '\n', '      // Map our entered teamId if we in fact entered a team\n', '      if (_tokenIds.length > 0) {\n', '        teamIdToContestId[uniqueTeamId] = uint32(_contestId);\n', '      }\n', '\n', '      // Fire events\n', '      emit ContestCreated(_contestId);\n', '      if (_tokenIds.length > 0) {\n', '        emit ContestEntered(_contestId, uniqueTeamId);\n', '      }\n', '  }\n', '\n', '  /// @dev Method to enter an existing contest. The msg.sender must own\n', '  ///   all of the player tokens on the team.\n', '  /// @param _contestId - ID of contest being entered\n', '  /// @param _tokenIds - IDs of player tokens on the team being entered\n', '  function enterContest(uint32 _contestId, uint32[] _tokenIds) public  payable whenNotPaused {\n', '\n', '    require (msg.sender != address(0));\n', '    require ((_contestId > 0) && (_contestId < contests.length));\n', '\n', '    // Grab the contest and make sure it is available to enter\n', '    Contest storage _contestToEnter = contests[_contestId];\n', '    require (_contestToEnter.status == ContestStatus.Active);\n', '    require(_contestToEnter.startTime > uint64(now));\n', '\n', '    // Participant must put up the entry fee.\n', '    require(msg.value >= _contestToEnter.entryFee);\n', '\n', '    // Cannot exceed the contest&#39;s max entry requirement\n', '    uint32 maxEntries = uint32(_contestToEnter.maxMinEntries >> 32);\n', '    if (maxEntries > 0) {\n', '      require(_contestToEnter.teamIds.length < maxEntries);\n', '    }\n', '\n', '    // Note that the _tokenIds MUST BE OWNED by the msg.sender, and\n', '    // there may be other conditions enforced by the CSportsTeam contract&#39;s\n', '    // createTeam(...) method.\n', '    uint32 _newTeamId = teamContract.createTeam(msg.sender, _tokenIds);\n', '\n', '    // Add the new team to our contest\n', '    uint256 _teamIndex = _contestToEnter.teamIds.push(_newTeamId) - 1;\n', '    require(_teamIndex < 4294967295);\n', '\n', '    // Map the team&#39;s ID to its index in the teamIds array\n', '    _contestToEnter.teamIdToIdx[_newTeamId] = uint32(_teamIndex);\n', '\n', '    // Map the team to the contest\n', '    teamIdToContestId[_newTeamId] = uint32(_contestId);\n', '\n', '    // Fire event\n', '    emit ContestEntered(_contestId, _newTeamId);\n', '\n', '  }\n', '\n', '  /// @dev Removes a team from a contest. The msg.sender must be the owner\n', '  ///   of the team being removed.\n', '  function exitContest(uint32 _teamId) public {\n', '\n', '    // Get the team from the team contract\n', '    address owner;\n', '    int32 score;\n', '    uint32 place;\n', '    bool holdsEntryFee;\n', '    bool ownsPlayerTokens;\n', '    (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(_teamId);\n', '\n', '    // Caller must own the team\n', '    require (owner == msg.sender);\n', '\n', '    uint32 _contestId = teamIdToContestId[_teamId];\n', '    require(_contestId > 0);\n', '    Contest storage _contestToExitFrom = contests[_contestId];\n', '\n', '    // Cannot exit a contest that has already begun\n', '    require(_contestToExitFrom.startTime > uint64(now));\n', '\n', '    // Return the entry fee to the owner and release the team\n', '    if (holdsEntryFee) {\n', '      teamContract.refunded(_teamId);\n', '      if (_contestToExitFrom.entryFee > 0) {\n', '        _authorizePayment(owner, _contestToExitFrom.entryFee);\n', '        emit ContestTeamRefundPaid(_contestId, _teamId, _contestToExitFrom.entryFee);\n', '      }\n', '    }\n', '    teamContract.releaseTeam(_teamId);  // Will throw if _teamId does not exist\n', '\n', '    // Remove the team from our list of teams participating in the contest\n', '    //\n', '    // Note that this mechanism works even if the teamId to be removed is the last\n', '    // entry in the teamIds array. In this case, the lastTeamIdx == toRemoveIdx so\n', '    // we would overwrite the last entry with itself. This last entry is subsequently\n', '    // removed from the teamIds array.\n', '    //\n', '    // Note that because of this method of removing a team from the teamIds array,\n', '    // the teamIds array is not guaranteed to be in an order that maps to the order of\n', '    // teams entering the contest (the order is now arbitrary).\n', '    uint32 lastTeamIdx = uint32(_contestToExitFrom.teamIds.length) - 1;\n', '    uint32 lastTeamId = _contestToExitFrom.teamIds[lastTeamIdx];\n', '    uint32 toRemoveIdx = _contestToExitFrom.teamIdToIdx[_teamId];\n', '\n', '    require(_contestToExitFrom.teamIds[toRemoveIdx] == _teamId);      // Sanity check (handle&#39;s Solidity&#39;s mapping of non-existing entries to 0)\n', '\n', '    _contestToExitFrom.teamIds[toRemoveIdx] = lastTeamId;             // Overwriting the teamIds array entry for the team\n', '                                                                      // being removed with the last entry&#39;s teamId\n', '    _contestToExitFrom.teamIdToIdx[lastTeamId] = toRemoveIdx;         // Re-map the lastTeamId to the removed teamId&#39;s index\n', '\n', '    delete _contestToExitFrom.teamIds[lastTeamIdx];                   // Remove the last entry that is now repositioned\n', '    _contestToExitFrom.teamIds.length--;                              // Shorten the array\n', '    delete _contestToExitFrom.teamIdToIdx[_teamId];                   // Remove the index mapping for the removed team\n', '\n', '    // Remove the team from our list of teams participating in the contest\n', '    // (OLD way that would limit the # of teams in a contest due to gas consumption)\n', '//    for (uint i = 0; i < _contestToExitFrom.teamIds.length; i++) {\n', '//      if (_contestToExitFrom.teamIds[i] == _teamId) {\n', '//        uint32 stopAt = uint32(_contestToExitFrom.teamIds.length - 1);\n', '//        for (uint  j = i; j < stopAt; j++) {\n', '//          _contestToExitFrom.teamIds[j] = _contestToExitFrom.teamIds[j+1];\n', '//        }\n', '//        delete _contestToExitFrom.teamIds[_contestToExitFrom.teamIds.length-1];\n', '//        _contestToExitFrom.teamIds.length--;\n', '//        break;\n', '//      }\n', '//    }\n', '\n', '    // This _teamId will no longer map to any contest\n', '    delete teamIdToContestId[_teamId];\n', '\n', '    // Fire event\n', '    emit ContestExited(_contestId, _teamId);\n', '  }\n', '\n', '  /// @dev Method that allows a contest creator to cancel his/her contest.\n', '  ///   Throws if we try to cancel a contest not owned by the msg.sender\n', '  ///   or by contract&#39;s scoring oracle. Also throws if we try to cancel a contest that\n', '  ///   is not int the ContestStatus.Active state.\n', '  function cancelContest(uint32 _contestId) public {\n', '\n', '    require(_contestId > 0);\n', '    Contest storage _toCancel = contests[_contestId];\n', '\n', '    // The a contest can only be canceled if it is in the active state.\n', '    require (_toCancel.status == ContestStatus.Active);\n', '\n', '    // Now make sure the calling entity is authorized to cancel the contest\n', '    // based on the state of the contest.\n', '    if (_toCancel.startTime > uint64(now)) {\n', '      // This is a contest that starts in the future. The creator of\n', '      // the contest or the scoringOracle can cancel it.\n', '      require((msg.sender == _toCancel.creator) || (msg.sender == _toCancel.scoringOracleAddress));\n', '    } else {\n', '      // This is a contest that has passed its lock time (i.e. started).\n', '      if (_toCancel.teamIds.length >= uint32(_toCancel.maxMinEntries & 0x00000000FFFFFFFF)) {\n', '\n', '        // A contest that has met its minimum entry count can only be canceled\n', '        // by the scoringOracle.\n', '        require(msg.sender == _toCancel.scoringOracleAddress);\n', '      }\n', '    }\n', '\n', '    // Note: Contests that have not met their minimum entry requirement\n', '    // can be canceled by anyone since they cannot be scored or paid out. Once canceled,\n', '    // anyone can release the teams back to their owners and refund any entry\n', '    // fees. Otherwise, it would require the contests&#39; ending time to pass\n', '    // before anyone could release and refund as implemented in the\n', '    // releaseTeams(...) method.\n', '\n', '    // Return the creator&#39;s prizeAmount\n', '    if (_toCancel.prizeAmount > 0) {\n', '      _authorizePayment(_toCancel.creator, _toCancel.prizeAmount);\n', '      _toCancel.remainingPrizeAmount = 0;\n', '    }\n', '\n', '    // Mark the contest as canceled, which then will allow anyone to\n', '    // release the teams (and refund the entryFees if any) for this contest.\n', '    // Generally, this is automatically done by the scoring oracle.\n', '    _toCancel.status = ContestStatus.Canceled;\n', '\n', '    // Fire event\n', '    emit ContestCanceled(_contestId);\n', '  }\n', '\n', '  /// @dev - Releases a set of teams if the contest has passed its ending\n', '  //    time (or has been canceled). This method can be called by the general\n', '  ///   public, but should called by our scoring oracle automatically.\n', '  /// @param _contestId - The ID of the contest the teams belong to\n', '  /// @param _teamIds - TeamIds of the teams we want to release. Array should\n', '  ///   be short enough in length so as not to run out of gas\n', '  function releaseTeams(uint32 _contestId, uint32[] _teamIds) public {\n', '    require((_contestId < contests.length) && (_contestId > 0));\n', '    Contest storage c = contests[_contestId];\n', '\n', '    // Teams can only be released for canceled contests or contests that have\n', '    // passed their end times.\n', '    require ((c.status == ContestStatus.Canceled) || (c.endTime <= uint64(now)));\n', '\n', '    for (uint32 i = 0; i < _teamIds.length; i++) {\n', '      uint32 teamId = _teamIds[i];\n', '      uint32 teamContestId = teamIdToContestId[teamId];\n', '      if (teamContestId == _contestId) {\n', '        address owner;\n', '        int32 score;\n', '        uint32 place;\n', '        bool holdsEntryFee;\n', '        bool ownsPlayerTokens;\n', '        (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(teamId);\n', '        if ((c.status == ContestStatus.Canceled) && holdsEntryFee) {\n', '          teamContract.refunded(teamId);\n', '          if (c.entryFee > 0) {\n', '            emit ContestTeamRefundPaid(_contestId, teamId, c.entryFee);\n', '            _authorizePayment(owner, c.entryFee);\n', '          }\n', '        }\n', '        if (ownsPlayerTokens) {\n', '          teamContract.releaseTeam(teamId);\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev - Updates a team with new player tokens, releasing ones that are replaced back\n', '  ///   to the owner. New player tokens must be approved for transfer to the team contract.\n', '  /// @param _contestId - ID of the contest we are working on\n', '  /// @param _teamId - Team ID of the team being updated\n', '  /// @param _indices - Indices of playerTokens to be replaced\n', '  /// @param _tokenIds - Array of player token IDs that will replace those\n', '  ///   currently held at the indices specified.\n', '  function updateContestTeam(uint32 _contestId, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public whenNotPaused {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require (c.status == ContestStatus.Active);\n', '\n', '    // To prevent a form of sniping, we do not allow you to update your\n', '    // team within 1 hour of the starting time of the contest.\n', '    require(c.startTime > uint64(now + 1 hours));\n', '\n', '    teamContract.updateTeam(msg.sender, _teamId, _indices, _tokenIds);\n', '  }\n', '\n', '  /// @dev Returns the contest data for a specific contest\n', '  ///@param _contestId - contest ID we are seeking the full info for\n', '  function getContest(uint32 _contestId) public view returns (\n', '    string name,                    // Name of this contest\n', '    address scoringOracleAddress,   // Address of the scoring oracle for this contest\n', '    uint32 gameSetId,               // ID of the gameset associated with this contest\n', '    uint32 maxEntries,              // Maximum number of entries allowed in the contest\n', '    uint64 startTime,               // Starting time for the contest (lock time)\n', '    uint64 endTime,                 // Ending time for the contest (lock time)\n', '    address creator,                // Address of the creator of the contest\n', '    uint128 entryFee,               // Fee to enter the contest\n', '    uint128 prizeAmount,            // Fee to enter the contest\n', '    uint32 minEntries,              // Wide receivers\n', '    uint8 status,                   // 1 = active, 2 = scored, 3-paying, 4 = paid, 5 = canceled\n', '    uint8 payoutKey,                // Identifies the payout structure for the contest (see comments above)\n', '    uint32 entryCount               // Current number of entries in the contest\n', '  )\n', '  {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '\n', '    // Unpack max & min entries (packed in struct due to stack limitations)\n', '    // Couldn&#39;t create these local vars due to stack limitation too.\n', '    /* uint32 _maxEntries = uint32(c.maxMinEntries >> 32);\n', '    uint32 _minEntries = uint32(c.maxMinEntries & 0x00000000FFFFFFFF); */\n', '\n', '    Contest storage c = contests[_contestId];\n', '    scoringOracleAddress = c.scoringOracleAddress;\n', '    gameSetId = c.gameSetId;\n', '    maxEntries = uint32(c.maxMinEntries >> 32);\n', '    startTime = c.startTime;\n', '    endTime = c.endTime;\n', '    creator = c.creator;\n', '    entryFee = c.entryFee;\n', '    prizeAmount = c.prizeAmount;\n', '    minEntries = uint32(c.maxMinEntries & 0x00000000FFFFFFFF);\n', '    status = uint8(c.status);\n', '    payoutKey = uint8(c.payoutKey);\n', '    name = c.name;\n', '    entryCount = uint32(c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Returns the number of teams in a particular contest\n', '  /// @param _contestId ID of contest we are inquiring about\n', '  function getContestTeamCount(uint32 _contestId) public view returns (uint32 count) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    count = uint32(c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Returns the index into the teamIds array of a contest a particular teamId sits at\n', '  /// @param _contestId ID of contest we are inquiring about\n', '  /// @param _teamId The team ID within the contest that we are interested in learning its teamIds index\n', '  function getIndexForTeamId(uint32 _contestId, uint32 _teamId) public view returns (uint32 idx) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    idx = c.teamIdToIdx[_teamId];\n', '\n', '    require (idx < c.teamIds.length);  // Handles the Solidity returning 0 from mapping for non-existent entries\n', '    require(c.teamIds[idx] == _teamId);\n', '  }\n', '\n', '  /// @dev Returns the team data for a particular team entered into the contest\n', '  /// @param _contestId - ID of contest we are getting a team from\n', '  /// @param _teamIndex - Index of team we are getting from the contest\n', '  function getContestTeam(uint32 _contestId, uint32 _teamIndex) public view returns (\n', '    uint32 teamId,\n', '    address owner,\n', '    int score,\n', '    uint place,\n', '    bool holdsEntryFee,\n', '    bool ownsPlayerTokens,\n', '    uint32 count,\n', '    uint32[50] playerTokenIds\n', '  )\n', '  {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require(_teamIndex < c.teamIds.length);\n', '\n', '    uint32 _teamId = c.teamIds[_teamIndex];\n', '    (teamId) = _teamId;\n', '    (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(_teamId);\n', '    (count, playerTokenIds) = teamContract.tokenIdsForTeam(_teamId);\n', '  }\n', '\n', '  /// @dev - Puts the contest into a state where the scoring oracle can\n', '  ///   now score the contest. CAN ONLY BE CALLED BY THE SCORING ORACLE\n', '  ///   for the given contest.\n', '  function prepareToScore(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Active) && (c.endTime <= uint64(now)));\n', '\n', '    // Cannot score a contest that has not met its minimum entry count\n', '    require (uint32(c.teamIds.length) >= uint32(c.maxMinEntries & 0x00000000FFFFFFFF));\n', '\n', '    c.status = ContestStatus.Scoring;\n', '\n', '    // Calculate the # of winners to payout\n', '    uint32 numWinners = 1;\n', '    if (c.payoutKey == PayoutKey.TopTen) {\n', '        numWinners = 10;\n', '    } else if (c.payoutKey == PayoutKey.FiftyFifty) {\n', '        numWinners = uint32(c.teamIds.length) / 2;\n', '    }\n', '    c.winnersToPay = numWinners;\n', '    c.numWinners = numWinners;\n', '\n', '    // We must have at least as many entries into the contest as there are\n', '    // number of winners. i.e. must have 10 or more entries in a top ten\n', '    // payout contest.\n', '    require(c.numWinners <= c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Assigns a score and place for an array of teams. The indexes into the\n', '  ///   arrays are what tie a particular teamId to score and place. The contest being\n', '  ///   scored must (a) be in the ContestStatus.Scoring state, and (b) have its\n', '  ///   scoringOracleAddress == the msg.sender.\n', '  /// @param _contestId - ID of contest the teams being scored belong to\n', '  /// @param _teamIds - IDs of the teams we are scoring\n', '  /// @param _scores - Scores to assign\n', '  /// @param _places - Places to assign\n', '  /// @param _startingPlaceOffset - Offset the _places[0] is from first place\n', '  /// @param _totalWinners - Total number of winners including ties\n', '  function scoreTeams(uint32 _contestId, uint32[] _teamIds, int32[] _scores, uint32[] _places, uint32 _startingPlaceOffset, uint32 _totalWinners) public {\n', '    require ((_teamIds.length == _scores.length) && (_teamIds.length == _places.length));\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Scoring));\n', '\n', '    // Deal with validating the teams all belong to the contest,\n', '    // and assign to winners list if we have a prizeAmount.\n', '    for (uint32 i = 0; i < _places.length; i++) {\n', '      uint32 teamId = _teamIds[i];\n', '\n', '      // Make sure ALL TEAMS PASED IN BELONG TO THE CONTEST BEING SCORED\n', '      uint32 contestIdForTeamBeingScored = teamIdToContestId[teamId];\n', '      require(contestIdForTeamBeingScored == _contestId);\n', '\n', '      // Add the team to the winners list if we have a prize\n', '      if (c.prizeAmount > 0) {\n', '        if ((_places[i] <= _totalWinners - _startingPlaceOffset) && (_places[i] > 0)) {\n', '          c.placeToWinner[_places[i] + _startingPlaceOffset] = teamId;\n', '        }\n', '      }\n', '    }\n', '\n', '    // Relay request over to the team contract\n', '    teamContract.scoreTeams(_teamIds, _scores, _places);\n', '  }\n', '\n', '  /// @dev Returns the place a particular team finished in (or is currently\n', '  ///   recorded as being in). Mostly used just to verify things during dev.\n', '  /// @param _teamId - Team ID of the team we are inquiring about\n', '  function getWinningPosition(uint32 _teamId) public view returns (uint32) {\n', '    uint32 _contestId = teamIdToContestId[_teamId];\n', '    require(_contestId > 0);\n', '    Contest storage c = contests[_contestId];\n', '    for (uint32 i = 1; i <= c.teamIds.length; i++) {\n', '      if (c.placeToWinner[i] == _teamId) {\n', '        return i;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  /// @dev - Puts the contest into a state where the scoring oracle can\n', '  ///   pay the winners of a contest. CAN ONLY BE CALLED BY THE SCORING ORACLE\n', '  ///   for the given contest. Contest must be in the ContestStatus.Scoring state.\n', '  /// @param _contestId - ID of contest being prepared to payout.\n', '  function prepareToPayWinners(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Scoring) && (c.endTime < uint64(now)));\n', '    c.status = ContestStatus.Paying;\n', '  }\n', '\n', '  /// @dev Returns the # of winners to pay if we are in the paying state.\n', '  /// @param _contestId - ID of contestId we are inquiring about\n', '  function numWinnersToPay(uint32 _contestId) public view returns (uint32) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest memory c = contests[_contestId];\n', '    if (c.status == ContestStatus.Paying) {\n', '      return c.winnersToPay;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /// @dev Pays the next batch of winners (authorizes payment) and return TRUE if there\n', '  ///   more to pay, otherwise FALSE. Contest must be in the ContestStatus.Paying state\n', '  ///   and CAN ONLY BE CALLED BY THE SCORING ORACLE. The scoring oracle is intended to\n', '  ///   loop on this until it returns FALSE.\n', '  /// @param _contestId - ID of contest being paid out.\n', '  /// @param _payingStartingIndex - Starting index of winner being paid. Equal to the number\n', '  /// of winners paid in previous calls to this method. Starts at 0 and goes up by numToPay\n', '  /// each time the method is called.\n', '  /// @param _numToPay - The number of winners to pay this time, can exceed the number\n', '  ///   left to pay.\n', '  /// @param _isFirstPlace - True if the first entry at the place being scored is a first\n', '  ///   place winner\n', '  /// @param _prevTies - # of places prior to the first place being paid in this call that\n', '  ///   had a tied value to the first place being paid in this call\n', '  /// @param _nextTies - # of places after to the last place being scored in this call that\n', '  ///   had a tied value to the last place paid in this call\n', '  function payWinners(uint32 _contestId, uint32 _payingStartingIndex, uint _numToPay, bool _isFirstPlace, uint32 _prevTies, uint32 _nextTies) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Paying));\n', '\n', '    // Due to EVM stack restrictings, certain local variables are packed into\n', '    // an array that is stored in memory as opposed to the stack.\n', '    //\n', '    // localVars index 0 = placeBeingPaid (\n', '    // localVars index 1 = nextBeingPaid\n', '    uint32[] memory localVars = new uint32[](2);\n', '    localVars[0] = _payingStartingIndex + 1;\n', '\n', '    // We have to add _prevTies here to handle the case where a batch holding the final\n', '    // winner to pay position (1, 10, or 50%) finishes processing its batch size, but\n', '    // the final position is a tie and the next batch is a tie of the final position.\n', '    // When the next batch is called, the c.winnersToPay would be 0 but there are still\n', '    // positions to be paid as ties to last place. This is where _prevTies comes in\n', '    // and keeps us going. However, a rogue scoring oracle could keep calling this\n', '    // payWinners method with a positive _prevTies value, which could cause us to\n', '    // pay out too much. This is why we have the c.remainingPrizeAmount check when\n', '    // we loop and actually payout the winners.\n', '    if (c.winnersToPay + _prevTies > 0) {\n', '      // Calculation of place amount:\n', '      //\n', '      // let n = c.numWinners\n', '      //\n', '      // s = sum of numbers 1 through c.numWinners\n', '      // m = (2*prizeAmount) / c.numWinners * (c.numWinners + 1);\n', '      // payout = placeBeingPaid*m\n', '      //\n', '      uint32 s = (c.numWinners * (c.numWinners + 1)) / 2;\n', '      uint128 m = c.prizeAmount / uint128(s);\n', '      while ((c.winnersToPay + _prevTies > 0) && (_numToPay > 0)) {\n', '\n', '        uint128 totalPayout = 0;\n', '        uint32 totalNumWinnersWithTies = _prevTies;\n', '        if (_prevTies > 0) {\n', '          // Adding the prize money associated with the _prevTies number of\n', '          // places that are getting aggregated into this tied position.\n', '          totalPayout = m*(_prevTies * c.winnersToPay + (_prevTies * (_prevTies + 1)) / 2);\n', '        }\n', '\n', '        // nextBeingPaid = placeBeingPaid;\n', '        localVars[1] = localVars[0];\n', '\n', '        // This loop accumulates the payouts associated with a string of tied scores.\n', '        // It always executes at least once.\n', '        uint32 numProcessedThisTime = 0;\n', '        while (teamContract.getScore(c.placeToWinner[localVars[1]]) == teamContract.getScore(c.placeToWinner[localVars[0]])) {\n', '\n', '          // Accumulate the prize money for each place in a string of tied scores\n', '          // (but only if there are winners left to pay)\n', '          if (c.winnersToPay > 0) {\n', '            totalPayout += m*c.winnersToPay;\n', '          }\n', '\n', '          // This value represents the number of ties at a particular score\n', '          totalNumWinnersWithTies++;\n', '\n', '          // Incerement the number processed in this call\n', '          numProcessedThisTime++;\n', '\n', '          // We decrement our winnersToPay value for each team at the same\n', '          // score, but we don&#39;t let it go negative.\n', '          if (c.winnersToPay > 0) {\n', '            c.winnersToPay--;\n', '          }\n', '\n', '          localVars[1]++;\n', '          _numToPay -= 1;\n', '          if ((_numToPay == 0) || (c.placeToWinner[localVars[1]] == 0)) {\n', '            break;\n', '          }\n', '        }\n', '\n', '        // Deal with first place getting the distributed rounding error\n', '        if (_isFirstPlace) {\n', '          totalPayout += c.prizeAmount - m * s;\n', '        }\n', '        _isFirstPlace = false;\n', '\n', '        // If we are on the last loop of this call, we need to deal\n', '        // with the _nextTies situation\n', '        if ((_numToPay == 0) && (_nextTies > 0)) {\n', '          totalNumWinnersWithTies += _nextTies;\n', '          if (_nextTies < c.winnersToPay) {\n', '            totalPayout += m*(_nextTies * (c.winnersToPay + 1) - (_nextTies * (_nextTies + 1)) / 2);\n', '          } else {\n', '            totalPayout += m*(c.winnersToPay * (c.winnersToPay + 1) - (c.winnersToPay * (c.winnersToPay + 1)) / 2);\n', '          }\n', '        }\n', '\n', '        // Payout is evenly distributed to all players with the same score\n', '        uint128 payout = totalPayout / totalNumWinnersWithTies;\n', '\n', '        // If this is the last place being paid, we are going to evenly distribute\n', '        // the remaining amount this contest holds in prize money evenly over other\n', '        // the number of folks remaining to be paid.\n', '        if (c.winnersToPay == 0) {\n', '          payout = c.remainingPrizeAmount / (numProcessedThisTime + _nextTies);\n', '        }\n', '\n', '        for (uint32 i = _prevTies; (i < (numProcessedThisTime + _prevTies)) && (c.remainingPrizeAmount > 0); i++) {\n', '\n', '          // Deals with rounding error in the last payout in a group of ties since the totalPayout\n', '          // was divided among tied players.\n', '          if (i == (totalNumWinnersWithTies - 1)) {\n', '            if ((c.winnersToPay == 0) && (_nextTies == 0)) {\n', '              payout = c.remainingPrizeAmount;\n', '            } else {\n', '              payout = totalPayout - (totalNumWinnersWithTies - 1)*payout;\n', '            }\n', '          }\n', '\n', '          // This is a safety check. Shouldn&#39;t be needed but this prevents a rogue scoringOracle\n', '          // from draining anything more than the prize amount for the contest they are oracle of.\n', '          if (payout > c.remainingPrizeAmount) {\n', '            payout = c.remainingPrizeAmount;\n', '          }\n', '          c.remainingPrizeAmount -= payout;\n', '\n', '          _authorizePayment(teamContract.getTeamOwner(c.placeToWinner[localVars[0]]), payout);\n', '\n', '          // Fire the event\n', '          emit ContestTeamWinningsPaid(_contestId, c.placeToWinner[localVars[0]], payout);\n', '\n', '          // Increment our placeBeingPaid value\n', '          localVars[0]++;\n', '        }\n', '\n', '        // We only initialize with _prevTies the first time through the loop\n', '        _prevTies = 0;\n', '\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Closes out a contest that is currently in the ContestStatus.Paying state.\n', '  ///   The contest being closed must (a) be in the ContestStatus.Paying state, and (b) have its\n', '  ///   scoringOracleAddress == the msg.sender, and (c) have no more winners to payout.\n', '  ///   Will then allow for the player tokens associated with any team in this contest to be released.\n', '  ///   Also authorizes the payment of all entry fees to the contest creator (less ownerCut if\n', '  ///   cryptosports was the scoring oracle)\n', '  /// @param _contestId - ID of the contest to close\n', '  function closeContest(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Paying) && (c.winnersToPay == 0));\n', '\n', '    // Move to the Paid state so we can only close the contest once\n', '    c.status = ContestStatus.Paid;\n', '\n', '    uint128 totalEntryFees = c.entryFee * uint128(c.teamIds.length);\n', '\n', '    // Transfer owner cut to the CFO address if the contest was scored by the commissioner\n', '    if (c.scoringOracleAddress == commissionerAddress) {\n', '      uint128 cut = _computeCut(totalEntryFees);\n', '      totalEntryFees -= cut;\n', '      cfoAddress.transfer(cut);\n', '    }\n', '\n', '    // Payout the contest creator\n', '    if (totalEntryFees > 0) {\n', '      _authorizePayment(c.creator, totalEntryFees);\n', '      emit ContestCreatorEntryFeesPaid(_contestId, totalEntryFees);\n', '    }\n', '\n', '    emit ContestClosed(_contestId);\n', '  }\n', '\n', '  // ---------------------------------------------------------------------------\n', '  // PRIVATE METHODS -----------------------------------------------------------\n', '  // ---------------------------------------------------------------------------\n', '\n', '  /// @dev Authorizes a user to receive payment from this contract.\n', '  /// @param _to - Address authorized to withdraw funds\n', '  /// @param _amount - Amount to authorize\n', '  function _authorizePayment(address _to, uint128 _amount) private {\n', '    totalAuthorizedForPayment += _amount;\n', '    uint128 _currentlyAuthorized = authorizedUserPayment[_to];\n', '    authorizedUserPayment[_to] = _currentlyAuthorized + _amount;\n', '  }\n', '\n', '  /// @dev Computes owner&#39;s cut of a contest&#39;s entry fees.\n', '  /// @param _amount - Amount owner is getting cut of\n', '  function _computeCut(uint128 _amount) internal view returns (uint128) {\n', '      // NOTE: We don&#39;t use SafeMath (or similar) in this function because\n', '      //  all of our entry functions carefully cap the maximum values for\n', '      //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '      //  statement in the CSportsContest constructor). The result of this\n', '      //  function is always guaranteed to be <= _amount.\n', '      return uint128(_amount * ownerCut / 10000);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/// @title A facet of CSportsCore that holds all important constants and modifiers\n', '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsConstants {\n', '\n', '    /// @dev The maximum # of marketing tokens that can ever be created\n', '    /// by the commissioner.\n', '    uint16 public MAX_MARKETING_TOKENS = 2500;\n', '\n', '    /// @dev The starting price for commissioner auctions (if the average\n', '    ///   of the last 2 is less than this, we will use this value)\n', '    ///   A finney is 1/1000 of an ether.\n', '    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\n', '\n', '    /// @dev The duration of commissioner auctions\n', '    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\n', '\n', '    /// @dev Number of seconds in a week\n', '    uint32 constant WEEK_SECS = 1 weeks;\n', '\n', '}\n', '\n', "/// @title A facet of CSportsCore that manages an individual's authorized role against access privileges.\n", '/// @author CryptoSports, Inc. (https://cryptosports.team))\n', '/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\n', 'contract CSportsAuth is CSportsConstants {\n', '    // This facet controls access control for CryptoSports. There are four roles managed here:\n', '    //\n', '    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n', '    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n', '    //         set to the address that created the smart contract in the CSportsCore constructor.\n', '    //\n', '    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\n', '    //\n', '    //     - The COO: The COO can perform administrative functions.\n', '    //\n', '    //     - The Commisioner can perform "oracle" functions like adding new real world players,\n', '    //       setting players active/inactive, and scoring contests.\n', '    //\n', '\n', '    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n', '    event ContractUpgrade(address newContract);\n', '\n', '    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '    address public cooAddress;\n', '    address public commissionerAddress;\n', '\n', '    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n', '    bool public paused = false;\n', '\n', '    /// @dev Flag that identifies whether or not we are in development and should allow development\n', '    /// only functions to be called.\n', '    bool public isDevelopment = true;\n', '\n', '    /// @dev Access modifier to allow access to development mode functions\n', '    modifier onlyUnderDevelopment() {\n', '      require(isDevelopment == true);\n', '      _;\n', '    }\n', '\n', '    /// @dev Access modifier for CEO-only functionality\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for CFO-only functionality\n', '    modifier onlyCFO() {\n', '        require(msg.sender == cfoAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for COO-only functionality\n', '    modifier onlyCOO() {\n', '        require(msg.sender == cooAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Access modifier for Commissioner-only functionality\n', '    modifier onlyCommissioner() {\n', '        require(msg.sender == commissionerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Requires any one of the C level addresses\n', '    modifier onlyCLevel() {\n', '        require(\n', '            msg.sender == cooAddress ||\n', '            msg.sender == ceoAddress ||\n', '            msg.sender == cfoAddress ||\n', '            msg.sender == commissionerAddress\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev prevents contracts from hitting the method\n', '    modifier notContract() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0);\n', '        _;\n', '    }\n', '\n', '    /// @dev One way switch to set the contract into prodution mode. This is one\n', '    /// way in that the contract can never be set back into development mode. Calling\n', '    /// this function will block all future calls to functions that are meant for\n', '    /// access only while we are under development. It will also enable more strict\n', '    /// additional checking on various parameters and settings.\n', '    function setProduction() public onlyCEO onlyUnderDevelopment {\n', '      isDevelopment = false;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '    /// @param _newCEO The address of the new CEO\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n', '    /// @param _newCFO The address of the new CFO\n', '    function setCFO(address _newCFO) public onlyCEO {\n', '        require(_newCFO != address(0));\n', '\n', '        cfoAddress = _newCFO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n', '    /// @param _newCOO The address of the new COO\n', '    function setCOO(address _newCOO) public onlyCEO {\n', '        require(_newCOO != address(0));\n', '\n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\n', '    /// @param _newCommissioner The address of the new COO\n', '    function setCommissioner(address _newCommissioner) public onlyCEO {\n', '        require(_newCommissioner != address(0));\n', '\n', '        commissionerAddress = _newCommissioner;\n', '    }\n', '\n', '    /// @dev Assigns all C-Level addresses\n', '    /// @param _ceo CEO address\n', '    /// @param _cfo CFO address\n', '    /// @param _coo COO address\n', '    /// @param _commish Commissioner address\n', '    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\n', '        require(_ceo != address(0));\n', '        require(_cfo != address(0));\n', '        require(_coo != address(0));\n', '        require(_commish != address(0));\n', '        ceoAddress = _ceo;\n', '        cfoAddress = _cfo;\n', '        cooAddress = _coo;\n', '        commissionerAddress = _commish;\n', '    }\n', '\n', '    /// @dev Transfers the balance of this contract to the CFO\n', '    function withdrawBalance() external onlyCFO {\n', '        cfoAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    /*** Pausable functionality adapted from OpenZeppelin ***/\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS NOT paused\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to allow actions only when the contract IS paused\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '    ///  a bug or exploit is detected and we need to limit damage.\n', '    function pause() public onlyCLevel whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '    ///  one reason we may pause the contract is when CFO or COO accounts are\n', '    ///  compromised.\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', '/// @title CSportsContestBase base class for contests and teams contracts\n', '/// @dev This interface defines base class for contests and teams contracts\n', '/// @author CryptoSports\n', 'contract CSportsContestBase {\n', '\n', '    /// @dev Structure holding the player token IDs for a team\n', '    struct Team {\n', '      address owner;              // Address of the owner of the player tokens\n', '      int32 score;                // Score assigned to this team after a contest\n', '      uint32 place;               // Place this team finished in its contest\n', '      bool holdsEntryFee;         // TRUE if this team currently holds an entry fee\n', '      bool ownsPlayerTokens;      // True if the tokens are being escrowed by the Team contract\n', '      uint32[] playerTokenIds;    // IDs of the tokens held by this team\n', '    }\n', '\n', '}\n', '\n', '/// @title CSportsTeam Interface\n', '/// @dev This interface defines methods required by the CSportsContestCore\n', '///   in implementing a contest.\n', '/// @author CryptoSports\n', 'contract CSportsTeam {\n', '\n', '    bool public isTeamContract;\n', '\n', '    /// @dev Define team events\n', '    event TeamCreated(uint256 teamId, address owner);\n', '    event TeamUpdated(uint256 teamId);\n', '    event TeamReleased(uint256 teamId);\n', '    event TeamScored(uint256 teamId, int32 score, uint32 place);\n', '    event TeamPaid(uint256 teamId);\n', '\n', '    function setCoreContractAddress(address _address) public;\n', '    function setLeagueRosterContractAddress(address _address) public;\n', '    function setContestContractAddress(address _address) public;\n', '    function createTeam(address _owner, uint32[] _tokenIds) public returns (uint32);\n', '    function updateTeam(address _owner, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public;\n', '    function releaseTeam(uint32 _teamId) public;\n', '    function getTeamOwner(uint32 _teamId) public view returns (address);\n', '    function scoreTeams(uint32[] _teamIds, int32[] _scores, uint32[] _places) public;\n', '    function getScore(uint32 _teamId) public view returns (int32);\n', '    function getPlace(uint32 _teamId) public view returns (uint32);\n', '    function ownsPlayerTokens(uint32 _teamId) public view returns (bool);\n', '    function refunded(uint32 _teamId) public;\n', '    function tokenIdsForTeam(uint32 _teamId) public view returns (uint32, uint32[50]);\n', '    function getTeam(uint32 _teamId) public view returns (\n', '        address _owner,\n', '        int32 _score,\n', '        uint32 _place,\n', '        bool _holdsEntryFee,\n', '        bool _ownsPlayerTokens);\n', '}\n', '\n', '/// @title CSports Contest\n', '/// @dev Implementation of a fantasy sports contest using tokens managed\n', '///   by a CSportsCore contract. This class implements functionality that\n', '///   is generic to any sport that involves teams. The specifics of how\n', '///   teams are structured, validated, and scored happen in the attached\n', '///   contract that implements the CSportsTeam interface.\n', 'contract CSportsContest is CSportsAuth, CSportsContestBase {\n', '\n', '  enum ContestStatus { Invalid, Active, Scoring, Paying, Paid, Canceled }\n', '  enum PayoutKey { Invalid, WinnerTakeAll, FiftyFifty, TopTen }\n', '\n', '  /// @dev Used as sanity check by other contracts\n', '  bool public isContestContract = true;\n', '\n', '  /// @dev Instance of the team contract connected to this contest. It is\n', '  ///   the team contract that implements most of the specific rules for\n', '  ///   this contrest.\n', '  CSportsTeam public teamContract;\n', '\n', '  /// @dev Cut owner takes of the entry fees paid into a contest as a fee for\n', '  ///   scoring the contest (measured in basis points (1/100 of a percent).\n', '  ///   Values 0-10,000 map to 0%-100%\n', '  uint256 public ownerCut;\n', '\n', '  /// @dev Structure for the definition of a single contest.\n', '  struct Contest {\n', "    address scoringOracleAddress;                 // Eth address of scoring oracle, if == 0, it's our commissioner address\n", '    address creator;                              // Address of the creator of the contest\n', '    uint32 gameSetId;                             // ID of the gameset associated with this contest\n', '    uint32 numWinners;                            // Number of winners in this contest\n', '    uint32 winnersToPay;                          // Number of winners that remain to be paid\n', '    uint64 startTime;                             // Starting time for the contest (lock time)\n', '    uint64 endTime;                               // Ending time for  the contest (can score after this time)\n', '    uint128 entryFee;                             // Fee to enter the contest\n', '    uint128 prizeAmount;                          // Fee to enter the contest\n', '    uint128 remainingPrizeAmount;                 // Remaining amount of prize money to payout\n', '    uint64 maxMinEntries;                         // Maximum and minimum number of entries allowed in the contest\n', '    ContestStatus status;                         // 1 = active, 2 = scoring, 3 = paying, 4 = paid, 5 = canceled\n', '    PayoutKey payoutKey;                          // Identifies the payout structure for the contest (see comments above)\n', '    uint32[] teamIds;                             // An array of teams entered into this contest\n', '    string name;                                  // Name of contest\n', '    mapping (uint32 => uint32) placeToWinner;     // Winners list mapping place to teamId\n', '    mapping (uint32 => uint32) teamIdToIdx;       // Maps a team ID to its index into the teamIds array\n', '  }\n', '\n', '  /// @dev Holds all of our contests (public)\n', '  Contest[] public contests;\n', '\n', '  /// @dev Maps team IDs to contest IDs\n', '  mapping (uint32 => uint32) public teamIdToContestId;\n', '\n', '  /// @dev We do not transfer funds directly to users when making any kind of payout. We\n', '  ///   require the user to pull his own funds. This is to eliminate DoS and reentrancy problems.\n', '  mapping (address => uint128) public authorizedUserPayment;\n', '\n', '  /// @dev Always has the total amount this contract is authorized to pay out to\n', '  ///   users.\n', '  uint128 public totalAuthorizedForPayment;\n', '\n', '  /// @dev Define contest events\n', '  event ContestCreated(uint256 contestId);\n', '  event ContestCanceled(uint256 contestId);\n', '  event ContestEntered(uint256 contestId, uint256 teamId);\n', '  event ContestExited(uint256 contestId, uint256 teamId);\n', '  event ContestClosed(uint32 contestId);\n', '  event ContestTeamWinningsPaid(uint32 contestId, uint32 teamId, uint128 amount);\n', '  event ContestTeamRefundPaid(uint32 contestId, uint32 teamId, uint128 amount);\n', '  event ContestCreatorEntryFeesPaid(uint32 contestId, uint128 amount);\n', '  event ContestApprovedFundsDelivered(address toAddress, uint128 amount);\n', '\n', '  /// @dev Class constructor creates the main CSportsContest smart contract instance.\n', '  constructor(uint256 _cut) public {\n', '      require(_cut <= 10000);\n', '      ownerCut = _cut;\n', '\n', '      // All C-level roles are the message sender\n', '      ceoAddress = msg.sender;\n', '      cfoAddress = msg.sender;\n', '      cooAddress = msg.sender;\n', '      commissionerAddress = msg.sender;\n', '\n', '      // Create a contest to take up the 0th slot.\n', '      // Create it in the canceled state with no teams.\n', '      // This is to deal with the fact that mappings return 0\n', '      // when queried with non-existent keys.\n', '      Contest memory _contest = Contest({\n', '          scoringOracleAddress: commissionerAddress,\n', '          gameSetId: 0,\n', '          maxMinEntries: 0,\n', '          numWinners: 0,\n', '          winnersToPay: 0,\n', '          startTime: 0,\n', '          endTime: 0,\n', '          creator: msg.sender,\n', '          entryFee: 0,\n', '          prizeAmount: 0,\n', '          remainingPrizeAmount: 0,\n', '          status: ContestStatus.Canceled,\n', '          payoutKey: PayoutKey(0),\n', '          name: "mythical",\n', '          teamIds: new uint32[](0)\n', '        });\n', '\n', '        contests.push(_contest);\n', '  }\n', '\n', '  /// @dev Called by any "C-level" role to pause the contract. Used only when\n', '  ///  a bug or exploit is detected and we need to limit damage.\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n', '  ///  one reason we may pause the contract is when CFO or COO accounts are\n', '  ///  compromised.\n', '  function unpause() public onlyCEO whenPaused {\n', "    // can't unpause if contract was upgraded\n", '    paused = false;\n', '  }\n', '\n', '  /// @dev Sets the teamContract that will manage teams for this contest\n', '  /// @param _address - Address of our team contract\n', '  function setTeamContractAddress(address _address) public onlyCEO {\n', '    CSportsTeam candidateContract = CSportsTeam(_address);\n', '    require(candidateContract.isTeamContract());\n', '    teamContract = candidateContract;\n', '  }\n', '\n', '  /// @dev Allows anyone who has funds approved to receive them. We use this\n', '  ///   "pull" funds mechanism to eliminate problems resulting from malicious behavior.\n', '  function transferApprovedFunds() public {\n', '    uint128 amount = authorizedUserPayment[msg.sender];\n', '    if (amount > 0) {\n', '\n', "      // Shouldn't have to check this, but if for any reason things got screwed up,\n", '      // this prevents anyone from withdrawing more than has been approved in total\n', '      // on the contract.\n', '      if (totalAuthorizedForPayment >= amount) {\n', '\n', '        // Imporant to do the delete before the transfer to eliminate re-entrancy attacks\n', '        delete authorizedUserPayment[msg.sender];\n', '        totalAuthorizedForPayment -= amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        // Create log entry\n', '        emit ContestApprovedFundsDelivered(msg.sender, amount);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Returns the amount of funds available for a given sender\n', '  function authorizedFundsAvailable() public view returns (uint128) {\n', '    return authorizedUserPayment[msg.sender];\n', '  }\n', '\n', '  /// @dev Returns the total amount of ether held by this contract\n', '  /// that has been approved for dispursement to contest creators\n', '  /// and participants.\n', '  function getTotalAuthorizedForPayment() public view returns (uint128) {\n', '    return totalAuthorizedForPayment;\n', '  }\n', '\n', '  /// @dev Creates a team for this contest. Called by an end-user of the CSportsCore\n', '  ///   contract. If the contract is paused, no additional contests can be created (although\n', '  ///   all other contract functionality remains valid.\n', '  /// @param _gameSetId - Identifes the games associated with contest. Used by the scoring oracle.\n', '  /// @param _startTime - Start time for the contest, used to determine locking of the teams\n', '  /// @param _endTime - End time representing the earliest this contest can be scored by the oracle\n', '  /// @param _entryFee - Entry fee paid to enter a team into this contest\n', '  /// @param _prizeAmount - Prize amount awarded to the winner\n', '  /// @param _maxEntries - Maximum number of entries in the contest\n', '  /// @param _minEntries - If false, we will return all ether and release all players\n', '  /// @param _payoutKey - Identifes the payout structure for the contest\n', '  ///   if we hit the start time with fewer than _maxEntries teams entered into the contest.\n', "  /// @param _tokenIds - Player token ids to be associated with the creator's team.\n", '  function createContest\n', '  (\n', '    string _name,\n', '    address _scoringOracleAddress,\n', '    uint32 _gameSetId,\n', '    uint64 _startTime,\n', '    uint64 _endTime,\n', '    uint128 _entryFee,\n', '    uint128 _prizeAmount,\n', '    uint32 _maxEntries,\n', '    uint32 _minEntries,\n', '    uint8 _payoutKey,\n', '    uint32[] _tokenIds\n', '  ) public payable whenNotPaused {\n', '\n', '      require (msg.sender != address(0));\n', '      require (_endTime > _startTime);\n', '      require (_maxEntries != 1);\n', '      require (_minEntries <= _maxEntries);\n', '      require(_startTime > uint64(now));\n', '\n', '      // The commissioner is allowed to create contests with no initial entry\n', '      require((msg.sender == commissionerAddress) || (_tokenIds.length > 0));\n', '\n', "      // Make sure we don't overflow\n", '      require(((_prizeAmount + _entryFee) >= _prizeAmount) && ((_prizeAmount + _entryFee) >= _entryFee));\n', '\n', '      // Creator must put up the correct amount of ether to cover the prize as well\n', '      // as his own entry fee if a team has been entered.\n', '      if (_tokenIds.length > 0) {\n', '        require(msg.value == (_prizeAmount + _entryFee));\n', '      } else {\n', '        require(msg.value == _prizeAmount);\n', '      }\n', '\n', '      // The default scoring oracle address will be set to the commissionerAddress\n', '      if (_scoringOracleAddress == address(0)) {\n', '        _scoringOracleAddress = commissionerAddress;\n', '      }\n', '\n', '      // Pack our maxMinEntries (due to stack limitations on struct sizes)\n', '      // uint64 maxMinEntries = (uint64(_maxEntries) << 32) | uint64(_minEntries);\n', '\n', '      // Create the contest object in memory\n', '      Contest memory _contest = Contest({\n', '          scoringOracleAddress: _scoringOracleAddress,\n', '          gameSetId: _gameSetId,\n', '          maxMinEntries: (uint64(_maxEntries) << 32) | uint64(_minEntries),\n', '          numWinners: 0,\n', '          winnersToPay: 0,\n', '          startTime: _startTime,\n', '          endTime: _endTime,\n', '          creator: msg.sender,\n', '          entryFee: _entryFee,\n', '          prizeAmount: _prizeAmount,\n', '          remainingPrizeAmount: _prizeAmount,\n', '          status: ContestStatus.Active,\n', '          payoutKey: PayoutKey(_payoutKey),\n', '          name: _name,\n', '          teamIds: new uint32[](0)\n', '        });\n', '\n', '      // We only create a team if we have tokens\n', '      uint32 uniqueTeamId = 0;\n', '      if (_tokenIds.length > 0) {\n', '        // Create the team for the creator of this contest. This\n', '        // will throw if msg.sender does not own all _tokenIds. The result\n', '        // of this call is that the team contract will now own the tokens.\n', '        //\n', '        // Note that the _tokenIds MUST BE OWNED by the msg.sender, and\n', "        // there may be other conditions enforced by the CSportsTeam contract's\n", '        // createTeam(...) method.\n', '        uniqueTeamId = teamContract.createTeam(msg.sender, _tokenIds);\n', '\n', '        // Again, we make sure our unique teamId stays within bounds\n', '        require(uniqueTeamId < 4294967295);\n', '        _contest.teamIds = new uint32[](1);\n', '        _contest.teamIds[0] = uniqueTeamId;\n', '\n', '        // We do not have to do this mapping here because 0 is returned from accessing\n', '        // a non existent member of a mapping (we deal with this when we use this\n', "        // structure in removing a team from the teamIds array). Can't do it anyway because\n", "        // mappings can't be accessed outside of storage.\n", '        //\n', '        // _contest.teamIdToIdx[uniqueTeamId] = 0;\n', '      }\n', '\n', '      // Save our contest\n', '      //\n', "      // It's probably never going to happen, 4 billion contests and teams is A LOT, but\n", "      // let's just be 100% sure we never let this happen because teamIds are\n", '      // often cast as uint32.\n', '      uint256 _contestId = contests.push(_contest) - 1;\n', '      require(_contestId < 4294967295);\n', '\n', '      // Map our entered teamId if we in fact entered a team\n', '      if (_tokenIds.length > 0) {\n', '        teamIdToContestId[uniqueTeamId] = uint32(_contestId);\n', '      }\n', '\n', '      // Fire events\n', '      emit ContestCreated(_contestId);\n', '      if (_tokenIds.length > 0) {\n', '        emit ContestEntered(_contestId, uniqueTeamId);\n', '      }\n', '  }\n', '\n', '  /// @dev Method to enter an existing contest. The msg.sender must own\n', '  ///   all of the player tokens on the team.\n', '  /// @param _contestId - ID of contest being entered\n', '  /// @param _tokenIds - IDs of player tokens on the team being entered\n', '  function enterContest(uint32 _contestId, uint32[] _tokenIds) public  payable whenNotPaused {\n', '\n', '    require (msg.sender != address(0));\n', '    require ((_contestId > 0) && (_contestId < contests.length));\n', '\n', '    // Grab the contest and make sure it is available to enter\n', '    Contest storage _contestToEnter = contests[_contestId];\n', '    require (_contestToEnter.status == ContestStatus.Active);\n', '    require(_contestToEnter.startTime > uint64(now));\n', '\n', '    // Participant must put up the entry fee.\n', '    require(msg.value >= _contestToEnter.entryFee);\n', '\n', "    // Cannot exceed the contest's max entry requirement\n", '    uint32 maxEntries = uint32(_contestToEnter.maxMinEntries >> 32);\n', '    if (maxEntries > 0) {\n', '      require(_contestToEnter.teamIds.length < maxEntries);\n', '    }\n', '\n', '    // Note that the _tokenIds MUST BE OWNED by the msg.sender, and\n', "    // there may be other conditions enforced by the CSportsTeam contract's\n", '    // createTeam(...) method.\n', '    uint32 _newTeamId = teamContract.createTeam(msg.sender, _tokenIds);\n', '\n', '    // Add the new team to our contest\n', '    uint256 _teamIndex = _contestToEnter.teamIds.push(_newTeamId) - 1;\n', '    require(_teamIndex < 4294967295);\n', '\n', "    // Map the team's ID to its index in the teamIds array\n", '    _contestToEnter.teamIdToIdx[_newTeamId] = uint32(_teamIndex);\n', '\n', '    // Map the team to the contest\n', '    teamIdToContestId[_newTeamId] = uint32(_contestId);\n', '\n', '    // Fire event\n', '    emit ContestEntered(_contestId, _newTeamId);\n', '\n', '  }\n', '\n', '  /// @dev Removes a team from a contest. The msg.sender must be the owner\n', '  ///   of the team being removed.\n', '  function exitContest(uint32 _teamId) public {\n', '\n', '    // Get the team from the team contract\n', '    address owner;\n', '    int32 score;\n', '    uint32 place;\n', '    bool holdsEntryFee;\n', '    bool ownsPlayerTokens;\n', '    (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(_teamId);\n', '\n', '    // Caller must own the team\n', '    require (owner == msg.sender);\n', '\n', '    uint32 _contestId = teamIdToContestId[_teamId];\n', '    require(_contestId > 0);\n', '    Contest storage _contestToExitFrom = contests[_contestId];\n', '\n', '    // Cannot exit a contest that has already begun\n', '    require(_contestToExitFrom.startTime > uint64(now));\n', '\n', '    // Return the entry fee to the owner and release the team\n', '    if (holdsEntryFee) {\n', '      teamContract.refunded(_teamId);\n', '      if (_contestToExitFrom.entryFee > 0) {\n', '        _authorizePayment(owner, _contestToExitFrom.entryFee);\n', '        emit ContestTeamRefundPaid(_contestId, _teamId, _contestToExitFrom.entryFee);\n', '      }\n', '    }\n', '    teamContract.releaseTeam(_teamId);  // Will throw if _teamId does not exist\n', '\n', '    // Remove the team from our list of teams participating in the contest\n', '    //\n', '    // Note that this mechanism works even if the teamId to be removed is the last\n', '    // entry in the teamIds array. In this case, the lastTeamIdx == toRemoveIdx so\n', '    // we would overwrite the last entry with itself. This last entry is subsequently\n', '    // removed from the teamIds array.\n', '    //\n', '    // Note that because of this method of removing a team from the teamIds array,\n', '    // the teamIds array is not guaranteed to be in an order that maps to the order of\n', '    // teams entering the contest (the order is now arbitrary).\n', '    uint32 lastTeamIdx = uint32(_contestToExitFrom.teamIds.length) - 1;\n', '    uint32 lastTeamId = _contestToExitFrom.teamIds[lastTeamIdx];\n', '    uint32 toRemoveIdx = _contestToExitFrom.teamIdToIdx[_teamId];\n', '\n', "    require(_contestToExitFrom.teamIds[toRemoveIdx] == _teamId);      // Sanity check (handle's Solidity's mapping of non-existing entries to 0)\n", '\n', '    _contestToExitFrom.teamIds[toRemoveIdx] = lastTeamId;             // Overwriting the teamIds array entry for the team\n', "                                                                      // being removed with the last entry's teamId\n", "    _contestToExitFrom.teamIdToIdx[lastTeamId] = toRemoveIdx;         // Re-map the lastTeamId to the removed teamId's index\n", '\n', '    delete _contestToExitFrom.teamIds[lastTeamIdx];                   // Remove the last entry that is now repositioned\n', '    _contestToExitFrom.teamIds.length--;                              // Shorten the array\n', '    delete _contestToExitFrom.teamIdToIdx[_teamId];                   // Remove the index mapping for the removed team\n', '\n', '    // Remove the team from our list of teams participating in the contest\n', '    // (OLD way that would limit the # of teams in a contest due to gas consumption)\n', '//    for (uint i = 0; i < _contestToExitFrom.teamIds.length; i++) {\n', '//      if (_contestToExitFrom.teamIds[i] == _teamId) {\n', '//        uint32 stopAt = uint32(_contestToExitFrom.teamIds.length - 1);\n', '//        for (uint  j = i; j < stopAt; j++) {\n', '//          _contestToExitFrom.teamIds[j] = _contestToExitFrom.teamIds[j+1];\n', '//        }\n', '//        delete _contestToExitFrom.teamIds[_contestToExitFrom.teamIds.length-1];\n', '//        _contestToExitFrom.teamIds.length--;\n', '//        break;\n', '//      }\n', '//    }\n', '\n', '    // This _teamId will no longer map to any contest\n', '    delete teamIdToContestId[_teamId];\n', '\n', '    // Fire event\n', '    emit ContestExited(_contestId, _teamId);\n', '  }\n', '\n', '  /// @dev Method that allows a contest creator to cancel his/her contest.\n', '  ///   Throws if we try to cancel a contest not owned by the msg.sender\n', "  ///   or by contract's scoring oracle. Also throws if we try to cancel a contest that\n", '  ///   is not int the ContestStatus.Active state.\n', '  function cancelContest(uint32 _contestId) public {\n', '\n', '    require(_contestId > 0);\n', '    Contest storage _toCancel = contests[_contestId];\n', '\n', '    // The a contest can only be canceled if it is in the active state.\n', '    require (_toCancel.status == ContestStatus.Active);\n', '\n', '    // Now make sure the calling entity is authorized to cancel the contest\n', '    // based on the state of the contest.\n', '    if (_toCancel.startTime > uint64(now)) {\n', '      // This is a contest that starts in the future. The creator of\n', '      // the contest or the scoringOracle can cancel it.\n', '      require((msg.sender == _toCancel.creator) || (msg.sender == _toCancel.scoringOracleAddress));\n', '    } else {\n', '      // This is a contest that has passed its lock time (i.e. started).\n', '      if (_toCancel.teamIds.length >= uint32(_toCancel.maxMinEntries & 0x00000000FFFFFFFF)) {\n', '\n', '        // A contest that has met its minimum entry count can only be canceled\n', '        // by the scoringOracle.\n', '        require(msg.sender == _toCancel.scoringOracleAddress);\n', '      }\n', '    }\n', '\n', '    // Note: Contests that have not met their minimum entry requirement\n', '    // can be canceled by anyone since they cannot be scored or paid out. Once canceled,\n', '    // anyone can release the teams back to their owners and refund any entry\n', "    // fees. Otherwise, it would require the contests' ending time to pass\n", '    // before anyone could release and refund as implemented in the\n', '    // releaseTeams(...) method.\n', '\n', "    // Return the creator's prizeAmount\n", '    if (_toCancel.prizeAmount > 0) {\n', '      _authorizePayment(_toCancel.creator, _toCancel.prizeAmount);\n', '      _toCancel.remainingPrizeAmount = 0;\n', '    }\n', '\n', '    // Mark the contest as canceled, which then will allow anyone to\n', '    // release the teams (and refund the entryFees if any) for this contest.\n', '    // Generally, this is automatically done by the scoring oracle.\n', '    _toCancel.status = ContestStatus.Canceled;\n', '\n', '    // Fire event\n', '    emit ContestCanceled(_contestId);\n', '  }\n', '\n', '  /// @dev - Releases a set of teams if the contest has passed its ending\n', '  //    time (or has been canceled). This method can be called by the general\n', '  ///   public, but should called by our scoring oracle automatically.\n', '  /// @param _contestId - The ID of the contest the teams belong to\n', '  /// @param _teamIds - TeamIds of the teams we want to release. Array should\n', '  ///   be short enough in length so as not to run out of gas\n', '  function releaseTeams(uint32 _contestId, uint32[] _teamIds) public {\n', '    require((_contestId < contests.length) && (_contestId > 0));\n', '    Contest storage c = contests[_contestId];\n', '\n', '    // Teams can only be released for canceled contests or contests that have\n', '    // passed their end times.\n', '    require ((c.status == ContestStatus.Canceled) || (c.endTime <= uint64(now)));\n', '\n', '    for (uint32 i = 0; i < _teamIds.length; i++) {\n', '      uint32 teamId = _teamIds[i];\n', '      uint32 teamContestId = teamIdToContestId[teamId];\n', '      if (teamContestId == _contestId) {\n', '        address owner;\n', '        int32 score;\n', '        uint32 place;\n', '        bool holdsEntryFee;\n', '        bool ownsPlayerTokens;\n', '        (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(teamId);\n', '        if ((c.status == ContestStatus.Canceled) && holdsEntryFee) {\n', '          teamContract.refunded(teamId);\n', '          if (c.entryFee > 0) {\n', '            emit ContestTeamRefundPaid(_contestId, teamId, c.entryFee);\n', '            _authorizePayment(owner, c.entryFee);\n', '          }\n', '        }\n', '        if (ownsPlayerTokens) {\n', '          teamContract.releaseTeam(teamId);\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev - Updates a team with new player tokens, releasing ones that are replaced back\n', '  ///   to the owner. New player tokens must be approved for transfer to the team contract.\n', '  /// @param _contestId - ID of the contest we are working on\n', '  /// @param _teamId - Team ID of the team being updated\n', '  /// @param _indices - Indices of playerTokens to be replaced\n', '  /// @param _tokenIds - Array of player token IDs that will replace those\n', '  ///   currently held at the indices specified.\n', '  function updateContestTeam(uint32 _contestId, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public whenNotPaused {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require (c.status == ContestStatus.Active);\n', '\n', '    // To prevent a form of sniping, we do not allow you to update your\n', '    // team within 1 hour of the starting time of the contest.\n', '    require(c.startTime > uint64(now + 1 hours));\n', '\n', '    teamContract.updateTeam(msg.sender, _teamId, _indices, _tokenIds);\n', '  }\n', '\n', '  /// @dev Returns the contest data for a specific contest\n', '  ///@param _contestId - contest ID we are seeking the full info for\n', '  function getContest(uint32 _contestId) public view returns (\n', '    string name,                    // Name of this contest\n', '    address scoringOracleAddress,   // Address of the scoring oracle for this contest\n', '    uint32 gameSetId,               // ID of the gameset associated with this contest\n', '    uint32 maxEntries,              // Maximum number of entries allowed in the contest\n', '    uint64 startTime,               // Starting time for the contest (lock time)\n', '    uint64 endTime,                 // Ending time for the contest (lock time)\n', '    address creator,                // Address of the creator of the contest\n', '    uint128 entryFee,               // Fee to enter the contest\n', '    uint128 prizeAmount,            // Fee to enter the contest\n', '    uint32 minEntries,              // Wide receivers\n', '    uint8 status,                   // 1 = active, 2 = scored, 3-paying, 4 = paid, 5 = canceled\n', '    uint8 payoutKey,                // Identifies the payout structure for the contest (see comments above)\n', '    uint32 entryCount               // Current number of entries in the contest\n', '  )\n', '  {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '\n', '    // Unpack max & min entries (packed in struct due to stack limitations)\n', "    // Couldn't create these local vars due to stack limitation too.\n", '    /* uint32 _maxEntries = uint32(c.maxMinEntries >> 32);\n', '    uint32 _minEntries = uint32(c.maxMinEntries & 0x00000000FFFFFFFF); */\n', '\n', '    Contest storage c = contests[_contestId];\n', '    scoringOracleAddress = c.scoringOracleAddress;\n', '    gameSetId = c.gameSetId;\n', '    maxEntries = uint32(c.maxMinEntries >> 32);\n', '    startTime = c.startTime;\n', '    endTime = c.endTime;\n', '    creator = c.creator;\n', '    entryFee = c.entryFee;\n', '    prizeAmount = c.prizeAmount;\n', '    minEntries = uint32(c.maxMinEntries & 0x00000000FFFFFFFF);\n', '    status = uint8(c.status);\n', '    payoutKey = uint8(c.payoutKey);\n', '    name = c.name;\n', '    entryCount = uint32(c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Returns the number of teams in a particular contest\n', '  /// @param _contestId ID of contest we are inquiring about\n', '  function getContestTeamCount(uint32 _contestId) public view returns (uint32 count) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    count = uint32(c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Returns the index into the teamIds array of a contest a particular teamId sits at\n', '  /// @param _contestId ID of contest we are inquiring about\n', '  /// @param _teamId The team ID within the contest that we are interested in learning its teamIds index\n', '  function getIndexForTeamId(uint32 _contestId, uint32 _teamId) public view returns (uint32 idx) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    idx = c.teamIdToIdx[_teamId];\n', '\n', '    require (idx < c.teamIds.length);  // Handles the Solidity returning 0 from mapping for non-existent entries\n', '    require(c.teamIds[idx] == _teamId);\n', '  }\n', '\n', '  /// @dev Returns the team data for a particular team entered into the contest\n', '  /// @param _contestId - ID of contest we are getting a team from\n', '  /// @param _teamIndex - Index of team we are getting from the contest\n', '  function getContestTeam(uint32 _contestId, uint32 _teamIndex) public view returns (\n', '    uint32 teamId,\n', '    address owner,\n', '    int score,\n', '    uint place,\n', '    bool holdsEntryFee,\n', '    bool ownsPlayerTokens,\n', '    uint32 count,\n', '    uint32[50] playerTokenIds\n', '  )\n', '  {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require(_teamIndex < c.teamIds.length);\n', '\n', '    uint32 _teamId = c.teamIds[_teamIndex];\n', '    (teamId) = _teamId;\n', '    (owner, score, place, holdsEntryFee, ownsPlayerTokens) = teamContract.getTeam(_teamId);\n', '    (count, playerTokenIds) = teamContract.tokenIdsForTeam(_teamId);\n', '  }\n', '\n', '  /// @dev - Puts the contest into a state where the scoring oracle can\n', '  ///   now score the contest. CAN ONLY BE CALLED BY THE SCORING ORACLE\n', '  ///   for the given contest.\n', '  function prepareToScore(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Active) && (c.endTime <= uint64(now)));\n', '\n', '    // Cannot score a contest that has not met its minimum entry count\n', '    require (uint32(c.teamIds.length) >= uint32(c.maxMinEntries & 0x00000000FFFFFFFF));\n', '\n', '    c.status = ContestStatus.Scoring;\n', '\n', '    // Calculate the # of winners to payout\n', '    uint32 numWinners = 1;\n', '    if (c.payoutKey == PayoutKey.TopTen) {\n', '        numWinners = 10;\n', '    } else if (c.payoutKey == PayoutKey.FiftyFifty) {\n', '        numWinners = uint32(c.teamIds.length) / 2;\n', '    }\n', '    c.winnersToPay = numWinners;\n', '    c.numWinners = numWinners;\n', '\n', '    // We must have at least as many entries into the contest as there are\n', '    // number of winners. i.e. must have 10 or more entries in a top ten\n', '    // payout contest.\n', '    require(c.numWinners <= c.teamIds.length);\n', '  }\n', '\n', '  /// @dev Assigns a score and place for an array of teams. The indexes into the\n', '  ///   arrays are what tie a particular teamId to score and place. The contest being\n', '  ///   scored must (a) be in the ContestStatus.Scoring state, and (b) have its\n', '  ///   scoringOracleAddress == the msg.sender.\n', '  /// @param _contestId - ID of contest the teams being scored belong to\n', '  /// @param _teamIds - IDs of the teams we are scoring\n', '  /// @param _scores - Scores to assign\n', '  /// @param _places - Places to assign\n', '  /// @param _startingPlaceOffset - Offset the _places[0] is from first place\n', '  /// @param _totalWinners - Total number of winners including ties\n', '  function scoreTeams(uint32 _contestId, uint32[] _teamIds, int32[] _scores, uint32[] _places, uint32 _startingPlaceOffset, uint32 _totalWinners) public {\n', '    require ((_teamIds.length == _scores.length) && (_teamIds.length == _places.length));\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Scoring));\n', '\n', '    // Deal with validating the teams all belong to the contest,\n', '    // and assign to winners list if we have a prizeAmount.\n', '    for (uint32 i = 0; i < _places.length; i++) {\n', '      uint32 teamId = _teamIds[i];\n', '\n', '      // Make sure ALL TEAMS PASED IN BELONG TO THE CONTEST BEING SCORED\n', '      uint32 contestIdForTeamBeingScored = teamIdToContestId[teamId];\n', '      require(contestIdForTeamBeingScored == _contestId);\n', '\n', '      // Add the team to the winners list if we have a prize\n', '      if (c.prizeAmount > 0) {\n', '        if ((_places[i] <= _totalWinners - _startingPlaceOffset) && (_places[i] > 0)) {\n', '          c.placeToWinner[_places[i] + _startingPlaceOffset] = teamId;\n', '        }\n', '      }\n', '    }\n', '\n', '    // Relay request over to the team contract\n', '    teamContract.scoreTeams(_teamIds, _scores, _places);\n', '  }\n', '\n', '  /// @dev Returns the place a particular team finished in (or is currently\n', '  ///   recorded as being in). Mostly used just to verify things during dev.\n', '  /// @param _teamId - Team ID of the team we are inquiring about\n', '  function getWinningPosition(uint32 _teamId) public view returns (uint32) {\n', '    uint32 _contestId = teamIdToContestId[_teamId];\n', '    require(_contestId > 0);\n', '    Contest storage c = contests[_contestId];\n', '    for (uint32 i = 1; i <= c.teamIds.length; i++) {\n', '      if (c.placeToWinner[i] == _teamId) {\n', '        return i;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  /// @dev - Puts the contest into a state where the scoring oracle can\n', '  ///   pay the winners of a contest. CAN ONLY BE CALLED BY THE SCORING ORACLE\n', '  ///   for the given contest. Contest must be in the ContestStatus.Scoring state.\n', '  /// @param _contestId - ID of contest being prepared to payout.\n', '  function prepareToPayWinners(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Scoring) && (c.endTime < uint64(now)));\n', '    c.status = ContestStatus.Paying;\n', '  }\n', '\n', '  /// @dev Returns the # of winners to pay if we are in the paying state.\n', '  /// @param _contestId - ID of contestId we are inquiring about\n', '  function numWinnersToPay(uint32 _contestId) public view returns (uint32) {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest memory c = contests[_contestId];\n', '    if (c.status == ContestStatus.Paying) {\n', '      return c.winnersToPay;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /// @dev Pays the next batch of winners (authorizes payment) and return TRUE if there\n', '  ///   more to pay, otherwise FALSE. Contest must be in the ContestStatus.Paying state\n', '  ///   and CAN ONLY BE CALLED BY THE SCORING ORACLE. The scoring oracle is intended to\n', '  ///   loop on this until it returns FALSE.\n', '  /// @param _contestId - ID of contest being paid out.\n', '  /// @param _payingStartingIndex - Starting index of winner being paid. Equal to the number\n', '  /// of winners paid in previous calls to this method. Starts at 0 and goes up by numToPay\n', '  /// each time the method is called.\n', '  /// @param _numToPay - The number of winners to pay this time, can exceed the number\n', '  ///   left to pay.\n', '  /// @param _isFirstPlace - True if the first entry at the place being scored is a first\n', '  ///   place winner\n', '  /// @param _prevTies - # of places prior to the first place being paid in this call that\n', '  ///   had a tied value to the first place being paid in this call\n', '  /// @param _nextTies - # of places after to the last place being scored in this call that\n', '  ///   had a tied value to the last place paid in this call\n', '  function payWinners(uint32 _contestId, uint32 _payingStartingIndex, uint _numToPay, bool _isFirstPlace, uint32 _prevTies, uint32 _nextTies) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Paying));\n', '\n', '    // Due to EVM stack restrictings, certain local variables are packed into\n', '    // an array that is stored in memory as opposed to the stack.\n', '    //\n', '    // localVars index 0 = placeBeingPaid (\n', '    // localVars index 1 = nextBeingPaid\n', '    uint32[] memory localVars = new uint32[](2);\n', '    localVars[0] = _payingStartingIndex + 1;\n', '\n', '    // We have to add _prevTies here to handle the case where a batch holding the final\n', '    // winner to pay position (1, 10, or 50%) finishes processing its batch size, but\n', '    // the final position is a tie and the next batch is a tie of the final position.\n', '    // When the next batch is called, the c.winnersToPay would be 0 but there are still\n', '    // positions to be paid as ties to last place. This is where _prevTies comes in\n', '    // and keeps us going. However, a rogue scoring oracle could keep calling this\n', '    // payWinners method with a positive _prevTies value, which could cause us to\n', '    // pay out too much. This is why we have the c.remainingPrizeAmount check when\n', '    // we loop and actually payout the winners.\n', '    if (c.winnersToPay + _prevTies > 0) {\n', '      // Calculation of place amount:\n', '      //\n', '      // let n = c.numWinners\n', '      //\n', '      // s = sum of numbers 1 through c.numWinners\n', '      // m = (2*prizeAmount) / c.numWinners * (c.numWinners + 1);\n', '      // payout = placeBeingPaid*m\n', '      //\n', '      uint32 s = (c.numWinners * (c.numWinners + 1)) / 2;\n', '      uint128 m = c.prizeAmount / uint128(s);\n', '      while ((c.winnersToPay + _prevTies > 0) && (_numToPay > 0)) {\n', '\n', '        uint128 totalPayout = 0;\n', '        uint32 totalNumWinnersWithTies = _prevTies;\n', '        if (_prevTies > 0) {\n', '          // Adding the prize money associated with the _prevTies number of\n', '          // places that are getting aggregated into this tied position.\n', '          totalPayout = m*(_prevTies * c.winnersToPay + (_prevTies * (_prevTies + 1)) / 2);\n', '        }\n', '\n', '        // nextBeingPaid = placeBeingPaid;\n', '        localVars[1] = localVars[0];\n', '\n', '        // This loop accumulates the payouts associated with a string of tied scores.\n', '        // It always executes at least once.\n', '        uint32 numProcessedThisTime = 0;\n', '        while (teamContract.getScore(c.placeToWinner[localVars[1]]) == teamContract.getScore(c.placeToWinner[localVars[0]])) {\n', '\n', '          // Accumulate the prize money for each place in a string of tied scores\n', '          // (but only if there are winners left to pay)\n', '          if (c.winnersToPay > 0) {\n', '            totalPayout += m*c.winnersToPay;\n', '          }\n', '\n', '          // This value represents the number of ties at a particular score\n', '          totalNumWinnersWithTies++;\n', '\n', '          // Incerement the number processed in this call\n', '          numProcessedThisTime++;\n', '\n', '          // We decrement our winnersToPay value for each team at the same\n', "          // score, but we don't let it go negative.\n", '          if (c.winnersToPay > 0) {\n', '            c.winnersToPay--;\n', '          }\n', '\n', '          localVars[1]++;\n', '          _numToPay -= 1;\n', '          if ((_numToPay == 0) || (c.placeToWinner[localVars[1]] == 0)) {\n', '            break;\n', '          }\n', '        }\n', '\n', '        // Deal with first place getting the distributed rounding error\n', '        if (_isFirstPlace) {\n', '          totalPayout += c.prizeAmount - m * s;\n', '        }\n', '        _isFirstPlace = false;\n', '\n', '        // If we are on the last loop of this call, we need to deal\n', '        // with the _nextTies situation\n', '        if ((_numToPay == 0) && (_nextTies > 0)) {\n', '          totalNumWinnersWithTies += _nextTies;\n', '          if (_nextTies < c.winnersToPay) {\n', '            totalPayout += m*(_nextTies * (c.winnersToPay + 1) - (_nextTies * (_nextTies + 1)) / 2);\n', '          } else {\n', '            totalPayout += m*(c.winnersToPay * (c.winnersToPay + 1) - (c.winnersToPay * (c.winnersToPay + 1)) / 2);\n', '          }\n', '        }\n', '\n', '        // Payout is evenly distributed to all players with the same score\n', '        uint128 payout = totalPayout / totalNumWinnersWithTies;\n', '\n', '        // If this is the last place being paid, we are going to evenly distribute\n', '        // the remaining amount this contest holds in prize money evenly over other\n', '        // the number of folks remaining to be paid.\n', '        if (c.winnersToPay == 0) {\n', '          payout = c.remainingPrizeAmount / (numProcessedThisTime + _nextTies);\n', '        }\n', '\n', '        for (uint32 i = _prevTies; (i < (numProcessedThisTime + _prevTies)) && (c.remainingPrizeAmount > 0); i++) {\n', '\n', '          // Deals with rounding error in the last payout in a group of ties since the totalPayout\n', '          // was divided among tied players.\n', '          if (i == (totalNumWinnersWithTies - 1)) {\n', '            if ((c.winnersToPay == 0) && (_nextTies == 0)) {\n', '              payout = c.remainingPrizeAmount;\n', '            } else {\n', '              payout = totalPayout - (totalNumWinnersWithTies - 1)*payout;\n', '            }\n', '          }\n', '\n', "          // This is a safety check. Shouldn't be needed but this prevents a rogue scoringOracle\n", '          // from draining anything more than the prize amount for the contest they are oracle of.\n', '          if (payout > c.remainingPrizeAmount) {\n', '            payout = c.remainingPrizeAmount;\n', '          }\n', '          c.remainingPrizeAmount -= payout;\n', '\n', '          _authorizePayment(teamContract.getTeamOwner(c.placeToWinner[localVars[0]]), payout);\n', '\n', '          // Fire the event\n', '          emit ContestTeamWinningsPaid(_contestId, c.placeToWinner[localVars[0]], payout);\n', '\n', '          // Increment our placeBeingPaid value\n', '          localVars[0]++;\n', '        }\n', '\n', '        // We only initialize with _prevTies the first time through the loop\n', '        _prevTies = 0;\n', '\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Closes out a contest that is currently in the ContestStatus.Paying state.\n', '  ///   The contest being closed must (a) be in the ContestStatus.Paying state, and (b) have its\n', '  ///   scoringOracleAddress == the msg.sender, and (c) have no more winners to payout.\n', '  ///   Will then allow for the player tokens associated with any team in this contest to be released.\n', '  ///   Also authorizes the payment of all entry fees to the contest creator (less ownerCut if\n', '  ///   cryptosports was the scoring oracle)\n', '  /// @param _contestId - ID of the contest to close\n', '  function closeContest(uint32 _contestId) public {\n', '    require((_contestId > 0) && (_contestId < contests.length));\n', '    Contest storage c = contests[_contestId];\n', '    require ((c.scoringOracleAddress == msg.sender) && (c.status == ContestStatus.Paying) && (c.winnersToPay == 0));\n', '\n', '    // Move to the Paid state so we can only close the contest once\n', '    c.status = ContestStatus.Paid;\n', '\n', '    uint128 totalEntryFees = c.entryFee * uint128(c.teamIds.length);\n', '\n', '    // Transfer owner cut to the CFO address if the contest was scored by the commissioner\n', '    if (c.scoringOracleAddress == commissionerAddress) {\n', '      uint128 cut = _computeCut(totalEntryFees);\n', '      totalEntryFees -= cut;\n', '      cfoAddress.transfer(cut);\n', '    }\n', '\n', '    // Payout the contest creator\n', '    if (totalEntryFees > 0) {\n', '      _authorizePayment(c.creator, totalEntryFees);\n', '      emit ContestCreatorEntryFeesPaid(_contestId, totalEntryFees);\n', '    }\n', '\n', '    emit ContestClosed(_contestId);\n', '  }\n', '\n', '  // ---------------------------------------------------------------------------\n', '  // PRIVATE METHODS -----------------------------------------------------------\n', '  // ---------------------------------------------------------------------------\n', '\n', '  /// @dev Authorizes a user to receive payment from this contract.\n', '  /// @param _to - Address authorized to withdraw funds\n', '  /// @param _amount - Amount to authorize\n', '  function _authorizePayment(address _to, uint128 _amount) private {\n', '    totalAuthorizedForPayment += _amount;\n', '    uint128 _currentlyAuthorized = authorizedUserPayment[_to];\n', '    authorizedUserPayment[_to] = _currentlyAuthorized + _amount;\n', '  }\n', '\n', "  /// @dev Computes owner's cut of a contest's entry fees.\n", '  /// @param _amount - Amount owner is getting cut of\n', '  function _computeCut(uint128 _amount) internal view returns (uint128) {\n', "      // NOTE: We don't use SafeMath (or similar) in this function because\n", '      //  all of our entry functions carefully cap the maximum values for\n', '      //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n', '      //  statement in the CSportsContest constructor). The result of this\n', '      //  function is always guaranteed to be <= _amount.\n', '      return uint128(_amount * ownerCut / 10000);\n', '  }\n', '\n', '}']
