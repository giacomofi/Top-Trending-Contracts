['pragma solidity ^0.4.23;\n', '\n', 'contract ERC20 {\n', '\n', '    // optional functions\n', '    function name() public view returns (string);\n', '    function symbol() public view returns (string);\n', '    function decimals() public view returns (uint8);\n', '\n', '    // required functios\n', '    function balanceOf(address user) public view returns (uint256);\n', '    function allowance(address user, address spender) public view returns (uint256);\n', '    function totalSupply() public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool); \n', '    function approve(address spender, uint256 value) public returns (bool); \n', '\n', '    // required events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed user, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BatchTransfer {\n', '    address private _owner;\n', '    address private _erc20_address;\n', '    mapping(address => bool) private _authed_addresses;\n', '\n', '    constructor(address erc20_address) public {\n', '        _owner = msg.sender;\n', '        _erc20_address = erc20_address;\n', '        _authed_addresses[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _owner, "require owner permission");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthed() {\n', '        require(_authed_addresses[msg.sender], "require auth permission");\n', '        _;\n', '    }\n', '\n', '    /**\n', '        function to update auth, contract owner can grant other account auth permission by this\n', '        it require:\n', '            1. transaction sender grant owner permission\n', '        please check requirement before you invoke  \n', '     */\n', '    function updateAuth(address auth_address, bool is_auth) public onlyOwner {\n', '        _authed_addresses[auth_address] = is_auth;\n', '    }\n', '\n', '    /**\n', '        convinient function for read token&#39;s owner\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '        convinient function for read token&#39;s erc20Address\n', '     */\n', '    function erc20Address() public view returns (address) {\n', '        return _erc20_address;\n', '    }\n', '\n', '    /**\n', '        convinient function for read is address authed\n', '     */\n', '    function isAuthed(address authed_address) public view returns (bool){\n', '        return _authed_addresses[authed_address];\n', '    }\n', '\n', '    /**\n', '        function for batch transfer\n', '        it require:\n', '            1. token_holder have suffcient balance\n', '            2. token_holder approve enough token to this contract\n', '            3. transaction sender grant auth permission\n', '        please check requirement before you invoke  \n', '     */\n', '    function transferFrom(address token_holder, address[] token_receivers, uint256[] values) public onlyAuthed returns (bool) {\n', '        require(token_receivers.length == values.length, "token_receiver&#39;s size must eq value&#39;s size");\n', '        require(token_receivers.length > 0, "token_receiver&#39;s length must gt 0");\n', '        \n', '        uint length = token_receivers.length;\n', '\n', '        // share variables, declare here for reuse later\n', '        uint i = 0;\n', '        uint value = 0;\n', '        uint total_value = 0;\n', '\n', '        for(i = 0; i < length; ++i) {\n', '            value = values[i];\n', '            require(value > 0, "value must gt 0");\n', '            total_value += value;\n', '        }\n', '        \n', '        ERC20 token_contract = ERC20(_erc20_address);\n', '        uint256 holder_balance = token_contract.balanceOf(token_holder);\n', '        require(holder_balance >= total_value, "balance of holder must gte total_value");\n', '        uint256 my_allowance = token_contract.allowance(token_holder, this);\n', '        require(my_allowance >= total_value, "allowance to contract must gte total_value");\n', '\n', '        // perform real transfer; require all transaction success; if one fail, all fail\n', '        for(i = 0; i < length; ++i) {\n', '            address token_receiver = token_receivers[i];\n', '            value = values[i];\n', '            bool is_success = token_contract.transferFrom(token_holder, token_receiver, value);\n', '            require(is_success, "transaction should be success");\n', '        }\n', '\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract ERC20 {\n', '\n', '    // optional functions\n', '    function name() public view returns (string);\n', '    function symbol() public view returns (string);\n', '    function decimals() public view returns (uint8);\n', '\n', '    // required functios\n', '    function balanceOf(address user) public view returns (uint256);\n', '    function allowance(address user, address spender) public view returns (uint256);\n', '    function totalSupply() public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool); \n', '    function approve(address spender, uint256 value) public returns (bool); \n', '\n', '    // required events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed user, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BatchTransfer {\n', '    address private _owner;\n', '    address private _erc20_address;\n', '    mapping(address => bool) private _authed_addresses;\n', '\n', '    constructor(address erc20_address) public {\n', '        _owner = msg.sender;\n', '        _erc20_address = erc20_address;\n', '        _authed_addresses[msg.sender] = true;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _owner, "require owner permission");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthed() {\n', '        require(_authed_addresses[msg.sender], "require auth permission");\n', '        _;\n', '    }\n', '\n', '    /**\n', '        function to update auth, contract owner can grant other account auth permission by this\n', '        it require:\n', '            1. transaction sender grant owner permission\n', '        please check requirement before you invoke  \n', '     */\n', '    function updateAuth(address auth_address, bool is_auth) public onlyOwner {\n', '        _authed_addresses[auth_address] = is_auth;\n', '    }\n', '\n', '    /**\n', "        convinient function for read token's owner\n", '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', "        convinient function for read token's erc20Address\n", '     */\n', '    function erc20Address() public view returns (address) {\n', '        return _erc20_address;\n', '    }\n', '\n', '    /**\n', '        convinient function for read is address authed\n', '     */\n', '    function isAuthed(address authed_address) public view returns (bool){\n', '        return _authed_addresses[authed_address];\n', '    }\n', '\n', '    /**\n', '        function for batch transfer\n', '        it require:\n', '            1. token_holder have suffcient balance\n', '            2. token_holder approve enough token to this contract\n', '            3. transaction sender grant auth permission\n', '        please check requirement before you invoke  \n', '     */\n', '    function transferFrom(address token_holder, address[] token_receivers, uint256[] values) public onlyAuthed returns (bool) {\n', '        require(token_receivers.length == values.length, "token_receiver\'s size must eq value\'s size");\n', '        require(token_receivers.length > 0, "token_receiver\'s length must gt 0");\n', '        \n', '        uint length = token_receivers.length;\n', '\n', '        // share variables, declare here for reuse later\n', '        uint i = 0;\n', '        uint value = 0;\n', '        uint total_value = 0;\n', '\n', '        for(i = 0; i < length; ++i) {\n', '            value = values[i];\n', '            require(value > 0, "value must gt 0");\n', '            total_value += value;\n', '        }\n', '        \n', '        ERC20 token_contract = ERC20(_erc20_address);\n', '        uint256 holder_balance = token_contract.balanceOf(token_holder);\n', '        require(holder_balance >= total_value, "balance of holder must gte total_value");\n', '        uint256 my_allowance = token_contract.allowance(token_holder, this);\n', '        require(my_allowance >= total_value, "allowance to contract must gte total_value");\n', '\n', '        // perform real transfer; require all transaction success; if one fail, all fail\n', '        for(i = 0; i < length; ++i) {\n', '            address token_receiver = token_receivers[i];\n', '            value = values[i];\n', '            bool is_success = token_contract.transferFrom(token_holder, token_receiver, value);\n', '            require(is_success, "transaction should be success");\n', '        }\n', '\n', '        return true;\n', '    }\n', '}']
