['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', '        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ICO Rocket Fuel contract for LastMile service.\n', ' */\n', 'contract IcoRocketFuel is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Crowdsale states\n', '    enum States {Active, Refunding, Closed}\n', '\n', '    struct Crowdsale {\n', '        address owner;        // Crowdsale proposer\n', '        address refundWallet; // Tokens for sale will refund to this wallet\n', '        uint256 cap;          // Hard cap\n', '        uint256 goal;         // Soft cap\n', '        uint256 raised;       // wei raised\n', '        uint256 rate;         // Sell rate. Set to 10 means 1 Wei = 10 token units\n', '        uint256 minInvest;    // Minimum investment in Wei\n', '        uint256 closingTime;  // Crowdsale closing time\n', '        bool earlyClosure;    // Whether allow early closure\n', '        uint8 commission;     // Commission percentage. Set to 10 means 10%\n', '        States state;         // Crowdsale current state\n', '    }\n', '\n', '    // When crowdsale is closed, commissions will transfer to this wallet.\n', '    address public commissionWallet;    \n', '\n', '    // Use crowdsales[token] to get corresponding crowdsale.\n', '    // The token is an ERC20 token address.\n', '    mapping(address => Crowdsale) public crowdsales;\n', '\n', '    // Use deposits[buyer][token] to get deposited Wei for buying the token.\n', '    // The buyer is the buyer address.\n', '    // The token is an ERC20 token address.\n', '    mapping (address => mapping(address => uint256)) public deposits;\n', '\n', '    modifier onlyCrowdsaleOwner(address _token) {\n', '        require(\n', '            msg.sender == crowdsales[_token].owner,\n', '            "Failed to call function due to permission denied."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier inState(address _token, States _state) {\n', '        require(\n', '            crowdsales[_token].state == _state,\n', '            "Failed to call function due to crowdsale is not in right state."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier nonZeroAddress(address _token) {\n', '        require(\n', '            _token != address(0),\n', '            "Failed to call function due to address is 0x0."\n', '        );\n', '        _;\n', '    }\n', '\n', '    event CommissionWalletUpdated(\n', '        address indexed _previoudWallet, // Previous commission wallet address\n', '        address indexed _newWallet       // New commission wallet address\n', '    );\n', '\n', '    event CrowdsaleCreated(\n', '        address indexed _owner, // Crowdsale proposer\n', '        address indexed _token, // ERC20 token for crowdsale\n', '        address _refundWallet,  // Tokens for sale will refund to this wallet\n', '        uint256 _cap,           // Hard cap\n', '        uint256 _goal,          // Soft cap\n', '        uint256 _rate,          // Sell rate. Set to 10 means 1 Wei = 10 token units\n', '        uint256 closingTime,    // Crowdsale closing time\n', '        bool earlyClosure,      // Whether allow early closure\n', '        uint8 _commission       // Commission percentage. Set to 10 means 10%\n', '    );\n', '\n', '    event TokenBought(\n', '        address indexed _buyer, // Buyer address\n', '        address indexed _token, // Bought ERC20 token address\n', '        uint256 _value          // Spent wei amount\n', '    );\n', '\n', '    event CrowdsaleClosed(\n', '        address indexed _setter, // Address who closed crowdsale\n', '        address indexed _token   // Token address\n', '    );\n', '\n', '    event SurplusTokensRefunded(\n', '        address _token,       // ERC20 token for crowdsale\n', '        address _beneficiary, // Surplus tokens will refund to this wallet\n', '        uint256 _surplus      // Surplus token units\n', '    );\n', '\n', '    event CommissionPaid(\n', '        address indexed _payer,       // Commission payer        \n', '        address indexed _token,       // Paid from this crowdsale\n', '        address indexed _beneficiary, // Commission paid to this wallet\n', '        uint256 _value                // Paid commission in Wei amount\n', '    );\n', '\n', '    event RefundsEnabled(\n', '        address indexed _setter, // Address who enabled refunds\n', '        address indexed _token   // Token address\n', '    );\n', '\n', '    event CrowdsaleTokensRefunded(\n', '        address indexed _token,        // ERC20 token for crowdsale\n', '        address indexed _refundWallet, // Token will refund to this wallet\n', '        uint256 _value                 // Refuned amount\n', '    );\n', '\n', '    event RaisedWeiClaimed(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Raised Wei amount\n', '    );\n', '\n', '    event TokenClaimed(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Refund Wei amount \n', '    );\n', '\n', '    event CrowdsalePaused(\n', '        address indexed _owner, // Current contract owner\n', '        address indexed _token  // Paused crowdsale\n', '    );\n', '\n', '    event WeiRefunded(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Refund Wei amount \n', '    );\n', '\n', '    // Note no default constructor is required, but \n', '    // remember to set commission wallet before operating.\n', '\n', '    /**\n', '     * Set crowdsale commission wallet.\n', '     *\n', '     * @param _newWallet New commission wallet\n', '     */\n', '    function setCommissionWallet(\n', '        address _newWallet\n', '    )\n', '        external\n', '        onlyOwner\n', '        nonZeroAddress(_newWallet)\n', '    {\n', '        emit CommissionWalletUpdated(commissionWallet, _newWallet);\n', '        commissionWallet = _newWallet;\n', '    }\n', '\n', '    /**\n', '     * Create a crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     * @param _refundWallet Tokens for sale will refund to this wallet\n', '     * @param _cap Crowdsale cap\n', '     * @param _goal Crowdsale goal\n', '     * @param _rate Token sell rate. Set to 10 means 1 Wei = 10 token units\n', '     * @param _minInvest Minimum investment in Wei\n', '     * @param _closingTime Crowdsale closing time\n', '     * @param _earlyClosure True: allow early closure; False: not allow\n', '     * @param _commission Commission percentage. Set to 10 means 10%\n', '     */\n', '    function createCrowdsale(\n', '        address _token,\n', '        address _refundWallet,\n', '        uint256 _cap,\n', '        uint256 _goal,\n', '        uint256 _rate,\n', '        uint256 _minInvest,\n', '        uint256 _closingTime,\n', '        bool _earlyClosure,\n', '        uint8 _commission\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        nonZeroAddress(_refundWallet)\n', '    {\n', '        require(\n', '            crowdsales[_token].owner == address(0),\n', '            "Failed to create crowdsale due to the crowdsale is existed."\n', '        );\n', '\n', '        require(\n', '            _goal <= _cap,\n', '            "Failed to create crowdsale due to goal is larger than cap."\n', '        );\n', '\n', '        require(\n', '            _minInvest > 0,\n', '            "Failed to create crowdsale due to minimum investment is 0."\n', '        );\n', '\n', '        require(\n', '            _commission <= 100,\n', '            "Failed to create crowdsale due to commission is larger than 100."\n', '        );\n', '\n', '        // Leverage SafeMath to help potential overflow of maximum token untis.\n', '        _cap.mul(_rate);\n', '\n', '        crowdsales[_token] = Crowdsale({\n', '            owner: msg.sender,\n', '            refundWallet: _refundWallet,\n', '            cap: _cap,\n', '            goal: _goal,\n', '            raised: 0,\n', '            rate: _rate,\n', '            minInvest: _minInvest,\n', '            closingTime: _closingTime,\n', '            earlyClosure: _earlyClosure,\n', '            state: States.Active,\n', '            commission: _commission\n', '        });\n', '\n', '        emit CrowdsaleCreated(\n', '            msg.sender, \n', '            _token,\n', '            _refundWallet,\n', '            _cap, \n', '            _goal, \n', '            _rate,\n', '            _closingTime,\n', '            _earlyClosure,\n', '            _commission\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Buy token with Wei.\n', '     *\n', '     * The Wei will be deposited until crowdsale is finalized.\n', '     * If crowdsale is success, raised Wei will be transfered to the token.\n', '     * If crowdsale is fail, buyer can refund the Wei.\n', '     *\n', '     * Note The minimum investment is 1 ETH.\n', '     * Note the big finger issue is expected to be handled by frontends.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function buyToken(\n', '        address _token\n', '    )\n', '        external\n', '        inState(_token, States.Active)\n', '        nonZeroAddress(_token)\n', '        payable\n', '    {\n', '        require(\n', '            msg.value >= crowdsales[_token].minInvest,\n', '            "Failed to buy token due to less than minimum investment."\n', '        );\n', '\n', '        require(\n', '            crowdsales[_token].raised.add(msg.value) <= (\n', '                crowdsales[_token].cap\n', '            ),\n', '            "Failed to buy token due to exceed cap."\n', '        );\n', '\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp < crowdsales[_token].closingTime,\n', '            "Failed to buy token due to crowdsale is closed."\n', '        );\n', '\n', '        deposits[msg.sender][_token] = (\n', '            deposits[msg.sender][_token].add(msg.value)\n', '        );\n', '        crowdsales[_token].raised = crowdsales[_token].raised.add(msg.value);\n', '        emit TokenBought(msg.sender, _token, msg.value);        \n', '    }\n', '\n', '    /**\n', '     * Check whether crowdsale goal was reached or not.\n', '     *\n', '     * Goal reached condition:\n', '     * 1. total raised wei >= goal (soft cap); and\n', '     * 2. Right amout of token is prepared for this contract.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @return Whether crowdsale goal was reached or not\n', '     */\n', '    function _goalReached(\n', '        ERC20 _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        view\n', '        returns(bool) \n', '    {\n', '        return (crowdsales[_token].raised >= crowdsales[_token].goal) && (\n', '            _token.balanceOf(address(this)) >= \n', '            crowdsales[_token].raised.mul(crowdsales[_token].rate)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Refund surplus tokens to refund wallet.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @param _beneficiary Surplus tokens will refund to this wallet\n', '     */\n', '    function _refundSurplusTokens(\n', '        ERC20 _token,\n', '        address _beneficiary\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '    {\n', '        uint256 _balance = _token.balanceOf(address(this));\n', '        uint256 _surplus = _balance.sub(\n', '            crowdsales[_token].raised.mul(crowdsales[_token].rate));\n', '        emit SurplusTokensRefunded(_token, _beneficiary, _surplus);\n', '\n', '        if (_surplus > 0) {\n', '            // Refund surplus tokens to refund wallet.\n', '            _token.transfer(_beneficiary, _surplus);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Pay commission by raised Wei amount of crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function _payCommission(\n', '        address _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '        onlyCrowdsaleOwner(_token)\n', '    {\n', '        // Calculate commission, update rest raised Wei, and pay commission.\n', '        uint256 _commission = crowdsales[_token].raised\n', '            .mul(uint256(crowdsales[_token].commission))\n', '            .div(100);\n', '        crowdsales[_token].raised = crowdsales[_token].raised.sub(_commission);\n', '        emit CommissionPaid(msg.sender, _token, commissionWallet, _commission);\n', '        commissionWallet.transfer(_commission);\n', '    }\n', '\n', '    /**\n', '     * Refund crowdsale tokens to refund wallet.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @param _beneficiary Crowdsale tokens will refund to this wallet\n', '     */\n', '    function _refundCrowdsaleTokens(\n', '        ERC20 _token,\n', '        address _beneficiary\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Refunding)\n', '    {\n', '        // Set raised Wei to 0 to prevent unknown issues \n', '        // which might take Wei away. \n', '        // Theoretically, this step is unnecessary due to there is no available\n', '        // function for crowdsale owner to claim raised Wei.\n', '        crowdsales[_token].raised = 0;\n', '\n', '        uint256 _value = _token.balanceOf(address(this));\n', '        emit CrowdsaleTokensRefunded(_token, _beneficiary, _value);\n', '\n', '        if (_value > 0) {         \n', '            // Refund all tokens for crowdsale to refund wallet.\n', '            _token.transfer(_beneficiary, _token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Enable refunds of crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function _enableRefunds(\n', '        address _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Active)      \n', '    {\n', '        // Set state to Refunding while preventing reentry.\n', '        crowdsales[_token].state = States.Refunding;\n', '        emit RefundsEnabled(msg.sender, _token);\n', '    }\n', '\n', '    /**\n', '     * Finalize a crowdsale.\n', '     *\n', '     * Once a crowdsale is finalized, its state could be\n', '     * either Closed (success) or Refunding (fail).\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function finalize(\n', '        address _token\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Active)        \n', '        onlyCrowdsaleOwner(_token)\n', '    {\n', '        require(                    \n', '            crowdsales[_token].earlyClosure || (\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp >= crowdsales[_token].closingTime),                   \n', '            "Failed to finalize due to crowdsale is opening."\n', '        );\n', '\n', '        if (_goalReached(ERC20(_token))) {\n', '            // Set state to Closed whiling preventing reentry.\n', '            crowdsales[_token].state = States.Closed;\n', '            emit CrowdsaleClosed(msg.sender, _token);\n', '            _refundSurplusTokens(\n', '                ERC20(_token), \n', '                crowdsales[_token].refundWallet\n', '            );\n', '            _payCommission(_token);                        \n', '        } else {\n', '            _enableRefunds(_token);\n', '            _refundCrowdsaleTokens(\n', '                ERC20(_token), \n', '                crowdsales[_token].refundWallet\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Pause crowdsale, which will set the crowdsale state to Refunding.\n', '     *\n', '     * Note only pause crowdsales which are suspicious/scams.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function pauseCrowdsale(\n', '        address _token\n', '    )  \n', '        external      \n', '        nonZeroAddress(_token)\n', '        onlyOwner\n', '        inState(_token, States.Active)\n', '    {\n', '        emit CrowdsalePaused(msg.sender, _token);\n', '        _enableRefunds(_token);\n', '        _refundCrowdsaleTokens(ERC20(_token), crowdsales[_token].refundWallet);\n', '    }\n', '\n', '    /**\n', '     * Claim crowdsale raised Wei.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimRaisedWei(\n', '        address _token,\n', '        address _beneficiary\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        nonZeroAddress(_beneficiary)\n', '        inState(_token, States.Closed)\n', '        onlyCrowdsaleOwner(_token)        \n', '    {\n', '        require(\n', '            crowdsales[_token].raised > 0,\n', '            "Failed to claim raised Wei due to raised Wei is 0."\n', '        );\n', '\n', '        uint256 _raisedWei = crowdsales[_token].raised;\n', '        crowdsales[_token].raised = 0;\n', '        emit RaisedWeiClaimed(msg.sender, _token, _raisedWei);\n', '        _beneficiary.transfer(_raisedWei);\n', '    }\n', '\n', '    /**\n', '     * Claim token, which will transfer bought token amount to buyer.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimToken(\n', '        address _token\n', '    )\n', '        external \n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '    {\n', '        require(\n', '            deposits[msg.sender][_token] > 0,\n', '            "Failed to claim token due to deposit is 0."\n', '        );\n', '\n', '        // Calculate token unit amount to be transferred. \n', '        uint256 _value = (\n', '            deposits[msg.sender][_token].mul(crowdsales[_token].rate)\n', '        );\n', '        deposits[msg.sender][_token] = 0;\n', '        emit TokenClaimed(msg.sender, _token, _value);\n', '        ERC20(_token).transfer(msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '     * Claim refund, which will transfer refunded Wei amount back to buyer.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimRefund(\n', '        address _token\n', '    )\n', '        public\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Refunding)\n', '    {\n', '        require(\n', '            deposits[msg.sender][_token] > 0,\n', '            "Failed to claim refund due to deposit is 0."\n', '        );\n', '\n', '        uint256 _value = deposits[msg.sender][_token];\n', '        deposits[msg.sender][_token] = 0;\n', '        emit WeiRefunded(msg.sender, _token, _value);\n', '        msg.sender.transfer(_value);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address _who) public view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        public view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public returns (bool);\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address _newOwner) internal {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ICO Rocket Fuel contract for LastMile service.\n', ' */\n', 'contract IcoRocketFuel is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Crowdsale states\n', '    enum States {Active, Refunding, Closed}\n', '\n', '    struct Crowdsale {\n', '        address owner;        // Crowdsale proposer\n', '        address refundWallet; // Tokens for sale will refund to this wallet\n', '        uint256 cap;          // Hard cap\n', '        uint256 goal;         // Soft cap\n', '        uint256 raised;       // wei raised\n', '        uint256 rate;         // Sell rate. Set to 10 means 1 Wei = 10 token units\n', '        uint256 minInvest;    // Minimum investment in Wei\n', '        uint256 closingTime;  // Crowdsale closing time\n', '        bool earlyClosure;    // Whether allow early closure\n', '        uint8 commission;     // Commission percentage. Set to 10 means 10%\n', '        States state;         // Crowdsale current state\n', '    }\n', '\n', '    // When crowdsale is closed, commissions will transfer to this wallet.\n', '    address public commissionWallet;    \n', '\n', '    // Use crowdsales[token] to get corresponding crowdsale.\n', '    // The token is an ERC20 token address.\n', '    mapping(address => Crowdsale) public crowdsales;\n', '\n', '    // Use deposits[buyer][token] to get deposited Wei for buying the token.\n', '    // The buyer is the buyer address.\n', '    // The token is an ERC20 token address.\n', '    mapping (address => mapping(address => uint256)) public deposits;\n', '\n', '    modifier onlyCrowdsaleOwner(address _token) {\n', '        require(\n', '            msg.sender == crowdsales[_token].owner,\n', '            "Failed to call function due to permission denied."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier inState(address _token, States _state) {\n', '        require(\n', '            crowdsales[_token].state == _state,\n', '            "Failed to call function due to crowdsale is not in right state."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier nonZeroAddress(address _token) {\n', '        require(\n', '            _token != address(0),\n', '            "Failed to call function due to address is 0x0."\n', '        );\n', '        _;\n', '    }\n', '\n', '    event CommissionWalletUpdated(\n', '        address indexed _previoudWallet, // Previous commission wallet address\n', '        address indexed _newWallet       // New commission wallet address\n', '    );\n', '\n', '    event CrowdsaleCreated(\n', '        address indexed _owner, // Crowdsale proposer\n', '        address indexed _token, // ERC20 token for crowdsale\n', '        address _refundWallet,  // Tokens for sale will refund to this wallet\n', '        uint256 _cap,           // Hard cap\n', '        uint256 _goal,          // Soft cap\n', '        uint256 _rate,          // Sell rate. Set to 10 means 1 Wei = 10 token units\n', '        uint256 closingTime,    // Crowdsale closing time\n', '        bool earlyClosure,      // Whether allow early closure\n', '        uint8 _commission       // Commission percentage. Set to 10 means 10%\n', '    );\n', '\n', '    event TokenBought(\n', '        address indexed _buyer, // Buyer address\n', '        address indexed _token, // Bought ERC20 token address\n', '        uint256 _value          // Spent wei amount\n', '    );\n', '\n', '    event CrowdsaleClosed(\n', '        address indexed _setter, // Address who closed crowdsale\n', '        address indexed _token   // Token address\n', '    );\n', '\n', '    event SurplusTokensRefunded(\n', '        address _token,       // ERC20 token for crowdsale\n', '        address _beneficiary, // Surplus tokens will refund to this wallet\n', '        uint256 _surplus      // Surplus token units\n', '    );\n', '\n', '    event CommissionPaid(\n', '        address indexed _payer,       // Commission payer        \n', '        address indexed _token,       // Paid from this crowdsale\n', '        address indexed _beneficiary, // Commission paid to this wallet\n', '        uint256 _value                // Paid commission in Wei amount\n', '    );\n', '\n', '    event RefundsEnabled(\n', '        address indexed _setter, // Address who enabled refunds\n', '        address indexed _token   // Token address\n', '    );\n', '\n', '    event CrowdsaleTokensRefunded(\n', '        address indexed _token,        // ERC20 token for crowdsale\n', '        address indexed _refundWallet, // Token will refund to this wallet\n', '        uint256 _value                 // Refuned amount\n', '    );\n', '\n', '    event RaisedWeiClaimed(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Raised Wei amount\n', '    );\n', '\n', '    event TokenClaimed(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Refund Wei amount \n', '    );\n', '\n', '    event CrowdsalePaused(\n', '        address indexed _owner, // Current contract owner\n', '        address indexed _token  // Paused crowdsale\n', '    );\n', '\n', '    event WeiRefunded(\n', '        address indexed _beneficiary, // Who claimed refunds\n', '        address indexed _token,       // Refund from this crowdsale\n', '        uint256 _value                // Refund Wei amount \n', '    );\n', '\n', '    // Note no default constructor is required, but \n', '    // remember to set commission wallet before operating.\n', '\n', '    /**\n', '     * Set crowdsale commission wallet.\n', '     *\n', '     * @param _newWallet New commission wallet\n', '     */\n', '    function setCommissionWallet(\n', '        address _newWallet\n', '    )\n', '        external\n', '        onlyOwner\n', '        nonZeroAddress(_newWallet)\n', '    {\n', '        emit CommissionWalletUpdated(commissionWallet, _newWallet);\n', '        commissionWallet = _newWallet;\n', '    }\n', '\n', '    /**\n', '     * Create a crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     * @param _refundWallet Tokens for sale will refund to this wallet\n', '     * @param _cap Crowdsale cap\n', '     * @param _goal Crowdsale goal\n', '     * @param _rate Token sell rate. Set to 10 means 1 Wei = 10 token units\n', '     * @param _minInvest Minimum investment in Wei\n', '     * @param _closingTime Crowdsale closing time\n', '     * @param _earlyClosure True: allow early closure; False: not allow\n', '     * @param _commission Commission percentage. Set to 10 means 10%\n', '     */\n', '    function createCrowdsale(\n', '        address _token,\n', '        address _refundWallet,\n', '        uint256 _cap,\n', '        uint256 _goal,\n', '        uint256 _rate,\n', '        uint256 _minInvest,\n', '        uint256 _closingTime,\n', '        bool _earlyClosure,\n', '        uint8 _commission\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        nonZeroAddress(_refundWallet)\n', '    {\n', '        require(\n', '            crowdsales[_token].owner == address(0),\n', '            "Failed to create crowdsale due to the crowdsale is existed."\n', '        );\n', '\n', '        require(\n', '            _goal <= _cap,\n', '            "Failed to create crowdsale due to goal is larger than cap."\n', '        );\n', '\n', '        require(\n', '            _minInvest > 0,\n', '            "Failed to create crowdsale due to minimum investment is 0."\n', '        );\n', '\n', '        require(\n', '            _commission <= 100,\n', '            "Failed to create crowdsale due to commission is larger than 100."\n', '        );\n', '\n', '        // Leverage SafeMath to help potential overflow of maximum token untis.\n', '        _cap.mul(_rate);\n', '\n', '        crowdsales[_token] = Crowdsale({\n', '            owner: msg.sender,\n', '            refundWallet: _refundWallet,\n', '            cap: _cap,\n', '            goal: _goal,\n', '            raised: 0,\n', '            rate: _rate,\n', '            minInvest: _minInvest,\n', '            closingTime: _closingTime,\n', '            earlyClosure: _earlyClosure,\n', '            state: States.Active,\n', '            commission: _commission\n', '        });\n', '\n', '        emit CrowdsaleCreated(\n', '            msg.sender, \n', '            _token,\n', '            _refundWallet,\n', '            _cap, \n', '            _goal, \n', '            _rate,\n', '            _closingTime,\n', '            _earlyClosure,\n', '            _commission\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Buy token with Wei.\n', '     *\n', '     * The Wei will be deposited until crowdsale is finalized.\n', '     * If crowdsale is success, raised Wei will be transfered to the token.\n', '     * If crowdsale is fail, buyer can refund the Wei.\n', '     *\n', '     * Note The minimum investment is 1 ETH.\n', '     * Note the big finger issue is expected to be handled by frontends.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function buyToken(\n', '        address _token\n', '    )\n', '        external\n', '        inState(_token, States.Active)\n', '        nonZeroAddress(_token)\n', '        payable\n', '    {\n', '        require(\n', '            msg.value >= crowdsales[_token].minInvest,\n', '            "Failed to buy token due to less than minimum investment."\n', '        );\n', '\n', '        require(\n', '            crowdsales[_token].raised.add(msg.value) <= (\n', '                crowdsales[_token].cap\n', '            ),\n', '            "Failed to buy token due to exceed cap."\n', '        );\n', '\n', '        require(\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp < crowdsales[_token].closingTime,\n', '            "Failed to buy token due to crowdsale is closed."\n', '        );\n', '\n', '        deposits[msg.sender][_token] = (\n', '            deposits[msg.sender][_token].add(msg.value)\n', '        );\n', '        crowdsales[_token].raised = crowdsales[_token].raised.add(msg.value);\n', '        emit TokenBought(msg.sender, _token, msg.value);        \n', '    }\n', '\n', '    /**\n', '     * Check whether crowdsale goal was reached or not.\n', '     *\n', '     * Goal reached condition:\n', '     * 1. total raised wei >= goal (soft cap); and\n', '     * 2. Right amout of token is prepared for this contract.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @return Whether crowdsale goal was reached or not\n', '     */\n', '    function _goalReached(\n', '        ERC20 _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        view\n', '        returns(bool) \n', '    {\n', '        return (crowdsales[_token].raised >= crowdsales[_token].goal) && (\n', '            _token.balanceOf(address(this)) >= \n', '            crowdsales[_token].raised.mul(crowdsales[_token].rate)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Refund surplus tokens to refund wallet.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @param _beneficiary Surplus tokens will refund to this wallet\n', '     */\n', '    function _refundSurplusTokens(\n', '        ERC20 _token,\n', '        address _beneficiary\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '    {\n', '        uint256 _balance = _token.balanceOf(address(this));\n', '        uint256 _surplus = _balance.sub(\n', '            crowdsales[_token].raised.mul(crowdsales[_token].rate));\n', '        emit SurplusTokensRefunded(_token, _beneficiary, _surplus);\n', '\n', '        if (_surplus > 0) {\n', '            // Refund surplus tokens to refund wallet.\n', '            _token.transfer(_beneficiary, _surplus);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Pay commission by raised Wei amount of crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function _payCommission(\n', '        address _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '        onlyCrowdsaleOwner(_token)\n', '    {\n', '        // Calculate commission, update rest raised Wei, and pay commission.\n', '        uint256 _commission = crowdsales[_token].raised\n', '            .mul(uint256(crowdsales[_token].commission))\n', '            .div(100);\n', '        crowdsales[_token].raised = crowdsales[_token].raised.sub(_commission);\n', '        emit CommissionPaid(msg.sender, _token, commissionWallet, _commission);\n', '        commissionWallet.transfer(_commission);\n', '    }\n', '\n', '    /**\n', '     * Refund crowdsale tokens to refund wallet.\n', '     *\n', '     * @param _token Deployed ERC20 token\n', '     * @param _beneficiary Crowdsale tokens will refund to this wallet\n', '     */\n', '    function _refundCrowdsaleTokens(\n', '        ERC20 _token,\n', '        address _beneficiary\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Refunding)\n', '    {\n', '        // Set raised Wei to 0 to prevent unknown issues \n', '        // which might take Wei away. \n', '        // Theoretically, this step is unnecessary due to there is no available\n', '        // function for crowdsale owner to claim raised Wei.\n', '        crowdsales[_token].raised = 0;\n', '\n', '        uint256 _value = _token.balanceOf(address(this));\n', '        emit CrowdsaleTokensRefunded(_token, _beneficiary, _value);\n', '\n', '        if (_value > 0) {         \n', '            // Refund all tokens for crowdsale to refund wallet.\n', '            _token.transfer(_beneficiary, _token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Enable refunds of crowdsale.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function _enableRefunds(\n', '        address _token\n', '    )\n', '        private\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Active)      \n', '    {\n', '        // Set state to Refunding while preventing reentry.\n', '        crowdsales[_token].state = States.Refunding;\n', '        emit RefundsEnabled(msg.sender, _token);\n', '    }\n', '\n', '    /**\n', '     * Finalize a crowdsale.\n', '     *\n', '     * Once a crowdsale is finalized, its state could be\n', '     * either Closed (success) or Refunding (fail).\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function finalize(\n', '        address _token\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Active)        \n', '        onlyCrowdsaleOwner(_token)\n', '    {\n', '        require(                    \n', '            crowdsales[_token].earlyClosure || (\n', '            // solium-disable-next-line security/no-block-members\n', '            block.timestamp >= crowdsales[_token].closingTime),                   \n', '            "Failed to finalize due to crowdsale is opening."\n', '        );\n', '\n', '        if (_goalReached(ERC20(_token))) {\n', '            // Set state to Closed whiling preventing reentry.\n', '            crowdsales[_token].state = States.Closed;\n', '            emit CrowdsaleClosed(msg.sender, _token);\n', '            _refundSurplusTokens(\n', '                ERC20(_token), \n', '                crowdsales[_token].refundWallet\n', '            );\n', '            _payCommission(_token);                        \n', '        } else {\n', '            _enableRefunds(_token);\n', '            _refundCrowdsaleTokens(\n', '                ERC20(_token), \n', '                crowdsales[_token].refundWallet\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Pause crowdsale, which will set the crowdsale state to Refunding.\n', '     *\n', '     * Note only pause crowdsales which are suspicious/scams.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function pauseCrowdsale(\n', '        address _token\n', '    )  \n', '        external      \n', '        nonZeroAddress(_token)\n', '        onlyOwner\n', '        inState(_token, States.Active)\n', '    {\n', '        emit CrowdsalePaused(msg.sender, _token);\n', '        _enableRefunds(_token);\n', '        _refundCrowdsaleTokens(ERC20(_token), crowdsales[_token].refundWallet);\n', '    }\n', '\n', '    /**\n', '     * Claim crowdsale raised Wei.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimRaisedWei(\n', '        address _token,\n', '        address _beneficiary\n', '    )\n', '        external\n', '        nonZeroAddress(_token)\n', '        nonZeroAddress(_beneficiary)\n', '        inState(_token, States.Closed)\n', '        onlyCrowdsaleOwner(_token)        \n', '    {\n', '        require(\n', '            crowdsales[_token].raised > 0,\n', '            "Failed to claim raised Wei due to raised Wei is 0."\n', '        );\n', '\n', '        uint256 _raisedWei = crowdsales[_token].raised;\n', '        crowdsales[_token].raised = 0;\n', '        emit RaisedWeiClaimed(msg.sender, _token, _raisedWei);\n', '        _beneficiary.transfer(_raisedWei);\n', '    }\n', '\n', '    /**\n', '     * Claim token, which will transfer bought token amount to buyer.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimToken(\n', '        address _token\n', '    )\n', '        external \n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Closed)\n', '    {\n', '        require(\n', '            deposits[msg.sender][_token] > 0,\n', '            "Failed to claim token due to deposit is 0."\n', '        );\n', '\n', '        // Calculate token unit amount to be transferred. \n', '        uint256 _value = (\n', '            deposits[msg.sender][_token].mul(crowdsales[_token].rate)\n', '        );\n', '        deposits[msg.sender][_token] = 0;\n', '        emit TokenClaimed(msg.sender, _token, _value);\n', '        ERC20(_token).transfer(msg.sender, _value);\n', '    }\n', '\n', '    /**\n', '     * Claim refund, which will transfer refunded Wei amount back to buyer.\n', '     *\n', '     * @param _token Deployed ERC20 token address\n', '     */\n', '    function claimRefund(\n', '        address _token\n', '    )\n', '        public\n', '        nonZeroAddress(_token)\n', '        inState(_token, States.Refunding)\n', '    {\n', '        require(\n', '            deposits[msg.sender][_token] > 0,\n', '            "Failed to claim refund due to deposit is 0."\n', '        );\n', '\n', '        uint256 _value = deposits[msg.sender][_token];\n', '        deposits[msg.sender][_token] = 0;\n', '        emit WeiRefunded(msg.sender, _token, _value);\n', '        msg.sender.transfer(_value);\n', '    }\n', '}']
