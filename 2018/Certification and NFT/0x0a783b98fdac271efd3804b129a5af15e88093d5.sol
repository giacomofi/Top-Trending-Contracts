['/*\n', 'The goico_kasko2go Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The goico_kasko2go Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the goico_kasko2go Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <<span class="__cf_email__" data-cfemail="bfd691ccc9d6cdd6d1ffcfcdd0c9dacd91d6d0">[email&#160;protected]</span>>\n', '*/\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '\n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', 'contract BaseERC20 {\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '}\n', '\n', 'contract Token is owned {\n', '\n', '    string  public standard = &#39;Token 0.1&#39;;\n', '    string  public name     = &#39;_K2G&#39;;\n', '    string  public symbol   = &#39;_K2G&#39;;\n', '    uint8   public decimals = 8;\n', '\n', '    uint                      public totalSupply;\n', '    mapping (address => uint) public balanceOf;\n', '\n', '    uint                      public numberOfInvestors;\n', '    mapping (address => bool) public investors;\n', '    mapping (address => uint) public depositedCPT;\n', '    mapping (address => uint) public depositedWei;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    enum State {\n', '        NotStarted,\n', '        Started,\n', '        Finished\n', '    }\n', '\n', '    address public backend;\n', '    address public cryptaurToken = 0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1;\n', '    uint    public tokenPriceInWei;\n', '    State   public state;\n', '\n', '    event Mint(address indexed minter, uint tokens, bytes32 originalTxHash);\n', '\n', '    constructor() public owned() {}\n', '\n', '    function startCrowdsale() public onlyOwner {\n', '        require(state==State.NotStarted);\n', '        state=State.Started;\n', '    }\n', '\n', '    function finishCrowdsale() public onlyOwner {\n', '        require(state==State.Started);\n', '        state=State.Finished;\n', '    }\n', '\n', '    function changeBackend(address _backend) public onlyOwner {\n', '        backend = _backend;\n', '    }\n', '\n', '    function setTokenPriceInWei(uint _tokenPriceInWei) public {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        tokenPriceInWei = _tokenPriceInWei;\n', '    }\n', '\n', '    function () payable public {\n', '        require(state==State.Started);\n', '        uint tokens = msg.value / tokenPriceInWei * 100000000;\n', '        require(balanceOf[msg.sender] + tokens > balanceOf[msg.sender]); // overflow\n', '        require(tokens > 0);\n', '        depositedWei[msg.sender]+=msg.value;\n', '        balanceOf[msg.sender] += tokens;\n', '        if (!investors[msg.sender]) {\n', '            investors[msg.sender] = true;\n', '            ++numberOfInvestors;\n', '        }\n', '        emit Transfer(this, msg.sender, tokens);\n', '        totalSupply += tokens;\n', '    }\n', '\n', '    function depositCPT(address _who, uint _valueCPT, bytes32 _originalTxHash) public {\n', '        require(msg.sender == backend || msg.sender == owner);\n', '        require(state==State.Started);\n', '        // decimals in K2G and PROOF are the same and equal 8\n', '        uint tokens = (_valueCPT * 10000) / 238894; // 1 K2G = 23,8894 CPT\n', '        depositedCPT[_who]+=_valueCPT;\n', '        require(balanceOf[_who] + tokens > balanceOf[_who]); // overflow\n', '        require(tokens > 0);\n', '        balanceOf[_who] += tokens;\n', '        totalSupply += tokens;\n', '        if (!investors[_who]) {\n', '            investors[_who] = true;\n', '            ++numberOfInvestors;\n', '        }\n', '        emit Transfer(this, _who, tokens);\n', '        emit Mint(_who, tokens, _originalTxHash);\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '        require(msg.sender.call.gas(3000000).value(address(this).balance)());\n', '        uint balance = BaseERC20(cryptaurToken).balanceOf(this);\n', '        BaseERC20(cryptaurToken).transfer(msg.sender, balance);\n', '    }\n', '\n', '    // untistupids function\n', '    function transferAnyTokens(address _erc20, address _receiver, uint _amount) public onlyOwner {\n', '        BaseERC20(_erc20).transfer(_receiver, _amount);\n', '    }\n', '}']
['/*\n', 'The goico_kasko2go Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The goico_kasko2go Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the goico_kasko2go Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@prover.io>\n', '*/\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '    address public candidate;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        candidate = _owner;\n', '    }\n', '\n', '    function confirmOwner() public {\n', '        require(candidate == msg.sender);\n', '        owner = candidate;\n', '        delete candidate;\n', '    }\n', '}\n', '\n', 'contract BaseERC20 {\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '}\n', '\n', 'contract Token is owned {\n', '\n', "    string  public standard = 'Token 0.1';\n", "    string  public name     = '_K2G';\n", "    string  public symbol   = '_K2G';\n", '    uint8   public decimals = 8;\n', '\n', '    uint                      public totalSupply;\n', '    mapping (address => uint) public balanceOf;\n', '\n', '    uint                      public numberOfInvestors;\n', '    mapping (address => bool) public investors;\n', '    mapping (address => uint) public depositedCPT;\n', '    mapping (address => uint) public depositedWei;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    enum State {\n', '        NotStarted,\n', '        Started,\n', '        Finished\n', '    }\n', '\n', '    address public backend;\n', '    address public cryptaurToken = 0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1;\n', '    uint    public tokenPriceInWei;\n', '    State   public state;\n', '\n', '    event Mint(address indexed minter, uint tokens, bytes32 originalTxHash);\n', '\n', '    constructor() public owned() {}\n', '\n', '    function startCrowdsale() public onlyOwner {\n', '        require(state==State.NotStarted);\n', '        state=State.Started;\n', '    }\n', '\n', '    function finishCrowdsale() public onlyOwner {\n', '        require(state==State.Started);\n', '        state=State.Finished;\n', '    }\n', '\n', '    function changeBackend(address _backend) public onlyOwner {\n', '        backend = _backend;\n', '    }\n', '\n', '    function setTokenPriceInWei(uint _tokenPriceInWei) public {\n', '        require(msg.sender == owner || msg.sender == backend);\n', '        tokenPriceInWei = _tokenPriceInWei;\n', '    }\n', '\n', '    function () payable public {\n', '        require(state==State.Started);\n', '        uint tokens = msg.value / tokenPriceInWei * 100000000;\n', '        require(balanceOf[msg.sender] + tokens > balanceOf[msg.sender]); // overflow\n', '        require(tokens > 0);\n', '        depositedWei[msg.sender]+=msg.value;\n', '        balanceOf[msg.sender] += tokens;\n', '        if (!investors[msg.sender]) {\n', '            investors[msg.sender] = true;\n', '            ++numberOfInvestors;\n', '        }\n', '        emit Transfer(this, msg.sender, tokens);\n', '        totalSupply += tokens;\n', '    }\n', '\n', '    function depositCPT(address _who, uint _valueCPT, bytes32 _originalTxHash) public {\n', '        require(msg.sender == backend || msg.sender == owner);\n', '        require(state==State.Started);\n', '        // decimals in K2G and PROOF are the same and equal 8\n', '        uint tokens = (_valueCPT * 10000) / 238894; // 1 K2G = 23,8894 CPT\n', '        depositedCPT[_who]+=_valueCPT;\n', '        require(balanceOf[_who] + tokens > balanceOf[_who]); // overflow\n', '        require(tokens > 0);\n', '        balanceOf[_who] += tokens;\n', '        totalSupply += tokens;\n', '        if (!investors[_who]) {\n', '            investors[_who] = true;\n', '            ++numberOfInvestors;\n', '        }\n', '        emit Transfer(this, _who, tokens);\n', '        emit Mint(_who, tokens, _originalTxHash);\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '        require(msg.sender.call.gas(3000000).value(address(this).balance)());\n', '        uint balance = BaseERC20(cryptaurToken).balanceOf(this);\n', '        BaseERC20(cryptaurToken).transfer(msg.sender, balance);\n', '    }\n', '\n', '    // untistupids function\n', '    function transferAnyTokens(address _erc20, address _receiver, uint _amount) public onlyOwner {\n', '        BaseERC20(_erc20).transfer(_receiver, _amount);\n', '    }\n', '}']
