['pragma solidity ^0.4.24;\n', '\n', '\n', '// A 2/3 multisig contract compatible with Trezor or Ledger-signed messages.\n', '//\n', '// To authorize a spend, two signtures must be provided by 2 of the 3 owners.\n', '// To generate the message to be signed, provide the destination address and\n', '// spend amount (in wei) to the generateMessageToSignmethod.\n', '// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\n', '// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c\n', '// (27 and 28), respectively.\n', '// See the test file for example inputs.\n', '//\n', '// If you use other software than the provided dApp or scripts to sign the\n', '// message, verify that the message shown by the device matches the\n', '// generated message in hex.\n', '//\n', '// WARNING: The generated message is only valid until the next spend\n', '//          is executed. After that, a new message will need to be calculated.\n', '//\n', '// ADDITIONAL WARNING: This contract is **NOT** ERC20 compatible.\n', '// Tokens sent to this contract will be lost forever.\n', '//\n', '// ERROR CODES:\n', '//\n', '// 1: Invalid Owner Address. You must provide three distinct addresses.\n', '//    None of the provided addresses may be 0x00.\n', "// 2: Invalid Destination. You may not send ETH to this contract's address.\n", '// 3: Insufficient Balance. You have tried to send more ETH that this\n', '//    contract currently owns.\n', '// 4: Invalid Signature. The provided signature does not correspond to\n', '//    the provided destination, amount, nonce and current contract.\n', '//    Did you swap the R and S fields?\n', '// 5: Invalid Signers. The provided signatures are correctly signed, but are\n', '//    not signed by the correct addresses. You must provide signatures from\n', '//    two of the owner addresses.\n', '//\n', '// Developed by Unchained Capital, Inc.\n', '\n', '\n', '\n', 'contract MultiSig2of3 {\n', '\n', '    // The 3 addresses which control the funds in this contract.  The\n', '    // owners of 2 of these addresses will need to both sign a message\n', '    // allowing the funds in this contract to be spent.\n', '    mapping(address => bool) private owners;\n', '\n', '    // The contract nonce is not accessible to the contract so we\n', '    // implement a nonce-like variable for replay protection.\n', '    uint256 public spendNonce = 0;\n', '\n', '    // Contract Versioning\n', '    uint256 public unchainedMultisigVersionMajor = 2;\n', '    uint256 public unchainedMultisigVersionMinor = 0;\n', '\n', '    // An event sent when funds are received.\n', '    event Funded(uint newBalance);\n', '\n', '    // An event sent when a spend is triggered to the given address.\n', '    event Spent(address to, uint transfer);\n', '\n', '    // Instantiate a new Multisig 2 of 3 contract owned by the\n', '    // three given addresses\n', '    constructor(address owner1, address owner2, address owner3) public {\n', '        address zeroAddress = 0x0;\n', '\n', '        require(owner1 != zeroAddress, "1");\n', '        require(owner2 != zeroAddress, "1");\n', '        require(owner3 != zeroAddress, "1");\n', '\n', '        require(owner1 != owner2, "1");\n', '        require(owner2 != owner3, "1");\n', '        require(owner1 != owner3, "1");\n', '\n', '        owners[owner1] = true;\n', '        owners[owner2] = true;\n', '        owners[owner3] = true;\n', '    }\n', '\n', '    // The fallback function for this contract.\n', '    function() public payable {\n', '        emit Funded(address(this).balance);\n', '    }\n', '\n', '    // Generates the message to sign given the output destination address and amount.\n', "    // includes this contract's address and a nonce for replay protection.\n", '    // One option to independently verify:\n', '    //     https://leventozturk.com/engineering/sha3/ and select keccak\n', '    function generateMessageToSign(\n', '        address destination,\n', '        uint256 value\n', '    )\n', '        public view returns (bytes32)\n', '    {\n', '        require(destination != address(this), "2");\n', '        bytes32 message = keccak256(\n', '            abi.encodePacked(\n', '                spendNonce,\n', '                this,\n', '                value,\n', '                destination\n', '            )\n', '        );\n', '        return message;\n', '    }\n', '\n', '    // Send the given amount of ETH to the given destination using\n', '    // the two triplets (v1, r1, s1) and (v2, r2, s2) as signatures.\n', '    // s1 and s2 should be 0x00 or 0x01 corresponding to 0x1b and 0x1c respectively.\n', '    function spend(\n', '        address destination,\n', '        uint256 value,\n', '        uint8 v1,\n', '        bytes32 r1,\n', '        bytes32 s1,\n', '        uint8 v2,\n', '        bytes32 r2,\n', '        bytes32 s2\n', '    )\n', '        public\n', '    {\n', '        // This require is handled by generateMessageToSign()\n', '        // require(destination != address(this));\n', '        require(address(this).balance >= value, "3");\n', '        require(\n', '            _validSignature(\n', '                destination,\n', '                value,\n', '                v1, r1, s1,\n', '                v2, r2, s2\n', '            ),\n', '            "4");\n', '        spendNonce = spendNonce + 1;\n', '        destination.transfer(value);\n', '        emit Spent(destination, value);\n', '    }\n', '\n', '    // Confirm that the two signature triplets (v1, r1, s1) and (v2, r2, s2)\n', "    // both authorize a spend of this contract's funds to the given\n", '    // destination address.\n', '    function _validSignature(\n', '        address destination,\n', '        uint256 value,\n', '        uint8 v1, bytes32 r1, bytes32 s1,\n', '        uint8 v2, bytes32 r2, bytes32 s2\n', '    )\n', '        private view returns (bool)\n', '    {\n', '        bytes32 message = _messageToRecover(destination, value);\n', '        address addr1 = ecrecover(\n', '            message,\n', '            v1+27, r1, s1\n', '        );\n', '        address addr2 = ecrecover(\n', '            message,\n', '            v2+27, r2, s2\n', '        );\n', '        require(_distinctOwners(addr1, addr2), "5");\n', '\n', '        return true;\n', '    }\n', '\n', "    // Generate the the unsigned message (in bytes32) that each owner's\n", '    // wallet would have signed for the given destination and amount.\n', '    //\n', '    // The generated message from generateMessageToSign is converted to\n', '    // ascii when signed by a trezor.\n', '    //\n', '    // The required signing prefix, the length of this\n', '    // unsigned message, and the unsigned ascii message itself are\n', '    // then concatenated and hashed with keccak256.\n', '    function _messageToRecover(\n', '        address destination,\n', '        uint256 value\n', '    )\n', '        private view returns (bytes32)\n', '    {\n', '        bytes32 hashedUnsignedMessage = generateMessageToSign(\n', '            destination,\n', '            value\n', '        );\n', '        bytes memory unsignedMessageBytes = _hashToAscii(\n', '            hashedUnsignedMessage\n', '        );\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n64";\n', '        return keccak256(abi.encodePacked(prefix,unsignedMessageBytes));\n', '    }\n', '\n', '    // Confirm the pair of addresses as two distinct owners of this contract.\n', '    function _distinctOwners(\n', '        address addr1,\n', '        address addr2\n', '    )\n', '        private view returns (bool)\n', '    {\n', '        // Check that both addresses are different\n', '        require(addr1 != addr2, "5");\n', '        // Check that both addresses are owners\n', '        require(owners[addr1], "5");\n', '        require(owners[addr2], "5");\n', '        return true;\n', '    }\n', '\n', '    // Construct the byte representation of the ascii-encoded\n', '    // hashed message written in hex.\n', '    function _hashToAscii(bytes32 hash) private pure returns (bytes) {\n', '        bytes memory s = new bytes(64);\n', '        for (uint i = 0; i < 32; i++) {\n', '            byte  b = hash[i];\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2*i] = _char(hi);\n', '            s[2*i+1] = _char(lo);\n', '        }\n', '        return s;\n', '    }\n', '\n', '    // Convert from byte to ASCII of 0-f\n', '    // http://www.unicode.org/charts/PDF/U0000.pdf\n', '    function _char(byte b) private pure returns (byte c) {\n', '        if (b < 10) {\n', '            return byte(uint8(b) + 0x30);\n', '        } else {\n', '            return byte(uint8(b) + 0x57);\n', '        }\n', '    }\n', '}']