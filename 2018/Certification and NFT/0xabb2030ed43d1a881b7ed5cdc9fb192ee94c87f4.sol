['pragma solidity ^0.4.23;\n', '\n', '/* Team Littafi\n', '**/\n', '\n', ' \n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', '     if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert( c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '    //assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    //assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '\n', ' contract LittafiOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public{\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOnwership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner,newOwner);\n', '        owner=newOwner;\n', '        newOwner=address(0);\n', '    }\n', '\n', '}\n', '\n', ' contract Littafi is LittafiOwned{\n', '\n', '      using SafeMath for uint256;\n', '\n', '      uint256   public littID=0;\n', '      uint256   public littClientId=1;\n', '      bool      public sentinel=true;\n', '      uint256   public littafiAccount=0;\n', '      uint256   public littAdmins;\n', '\n', '      littafiContents[] public littafi;\n', '\n', '      mapping(bytes32 => address) littClientAddress;\n', '\n', '      mapping(bytes32 => string)  littIPFS;\n', '\n', '      mapping(bytes32 => uint256) littHashID;\n', '\n', '      mapping(bytes32 => uint256) littCapsule;\n', '\n', '      mapping(address => littafiAdmin) admins;\n', '\n', '      mapping(address => littafiSubscribtion) subscriber;\n', '\n', '      mapping(address => bool) subscriberStatus;\n', '\n', '      mapping(uint256 => address) poolAdmin;\n', '\n', '      mapping(uint256 => address) setPoolAdmin;\n', '\n', '      mapping(address => bool) isDelegateAdmin;\n', '\n', '      mapping(uint256 => string)  poolName;\n', '\n', '      mapping(address => bytes32[]) subscriberContentHashes;\n', '\n', '      mapping(address => uint256)  subscriberContentCount;\n', '      \n', '      mapping(address => bool) transferred;\n', '\n', '      struct littafiContents{\n', '          uint256 id;\n', '          bytes32 hash;\n', '          string  ipfs;\n', '          string timestamp;\n', '          string  metadata;\n', '          string  unique;\n', '          uint256 clientPool;\n', '          bool    access;\n', '      }\n', '\n', '      struct littafiAdmin{\n', '          uint256 poolID;\n', '          bool isAdmin;\n', '          string poolName;\n', '      }\n', '\n', '      struct littafiSubscribtion{\n', '          uint256 subID;\n', '          uint256 clientPool;\n', '      }\n', '\n', '      modifier onlyLittafiAdmin(uint256 _poolID){\n', '          require(admins[msg.sender].isAdmin == true && admins[msg.sender].poolID == _poolID && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiSubscribed(){\n', '          require(msg.value > 0 && subscriber[msg.sender].subID > 0 && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiNonSubscribed(){\n', '          require(msg.value > 0 && subscriber[msg.sender].subID == 0 && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyDelegate(){\n', '          require(msg.sender == owner || isDelegateAdmin[msg.sender] == true);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiContentOwner(bytes32 _hash){\n', '          require(msg.sender == littClientAddress[_hash]);\n', '          _;\n', '      }\n', '\n', '      event littContent(address indexed _address,bytes32 _hash, string _ipfs, string _timestamp, string _metadata, string unique, uint256 _poolID, bool _access, bool success);\n', '\n', '      event littClientSubscribed(address indexed _address, string _timestamp,uint256 _fee,uint256 _poolID,bool success);\n', '\n', '      event littafiAssignedID(address indexed _adminAddress, string _timestamp, uint256 _poolID, address indexed _address);\n', '\n', '      event littafiAdminReassigned(address indexed _previousAdmin,address indexed _newAdmin,string _timestamp,uint256 _assignedID);\n', '\n', '      event littafiDelegateAdmin(address indexed _admin, address indexed _delegate,bool _state,string _timestamp);\n', '\n', '      event littContentAccessModified(address indexed _admin,bytes32 _hash, uint256 _poolID,bool _access);\n', '\n', '      event littPoolModified(address indexed _address,string _poolName,uint256 _poolID);\n', '\n', '      event littContentOwnershipTransferred(bytes32 _hash, address indexed _address, string _timestamp);\n', '\n', '      constructor() public{\n', '          LittafiOwned(msg.sender);\n', '      }\n', '\n', '      function subscribtionLittafi(uint256 _assignedID,string _timestamp, string _poolName) public payable onlyLittafiNonSubscribed(){\n', '\n', '          if(_assignedID > 0 && setPoolAdmin[_assignedID] == msg.sender){\n', '             subscriber[msg.sender].subID=littClientId;\n', '             subscriber[msg.sender].clientPool=_assignedID;\n', '             subscriberStatus[msg.sender]=true;\n', '             admins[msg.sender].poolID=_assignedID;\n', '             admins[msg.sender].isAdmin=true;\n', '             admins[msg.sender].poolName=_poolName;\n', '             poolAdmin[_assignedID]=msg.sender;\n', '             poolName[_assignedID]=_poolName;\n', '             littClientId++;\n', '             littAdmins++;\n', '             owner.transfer(msg.value);\n', '             littafiAccount.add(msg.value);\n', '\n', '             emit littClientSubscribed(msg.sender,_timestamp,msg.value,_assignedID,true);\n', '             return;\n', '          }else{\n', '              subscriber[msg.sender].subID=littClientId;\n', '              subscriber[msg.sender].clientPool=0;\n', '              subscriberStatus[msg.sender]=true;\n', '              littClientId++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littClientSubscribed(msg.sender,_timestamp,msg.value,0,true);\n', '              return;\n', '          }\n', '      }\n', '\n', '      function littafiContentCommit(bytes32 _hash,string _ipfs,string _timestamp,string _metadata,string _unique,bool _sentinel) public payable onlyLittafiSubscribed(){\n', '\n', '             uint256 id=littHashID[_hash];\n', '             if (littClientAddress[_hash] != address(0)){\n', '                emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[id].timestamp,littafi[id].metadata,littafi[id].unique,littafi[id].clientPool,littafi[id].access,true);\n', '                return;\n', '             }else{\n', '\n', '              if(admins[msg.sender].isAdmin == true) sentinel=_sentinel;\n', '\n', '              littafiContents memory commit=littafiContents(littID,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel);\n', '              littafi.push(commit);\n', '\n', '              subscriberContentCount[msg.sender]++;\n', '              subscriberContentHashes[msg.sender].push(_hash);\n', '              littClientAddress[_hash]=msg.sender;\n', '              littIPFS[_hash]=_ipfs;\n', '              littHashID[_hash]=littID;\n', '              littID++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littContent(msg.sender,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel,true);\n', '              return;\n', '             }\n', '\n', '      }\n', '\n', '      function littafiTimeCapsule(bytes32 _hash,string _ipfs,string _timestamp,string _metadata,string _unique,uint256 _capsuleRelease) public payable onlyLittafiSubscribed(){\n', '\n', '             uint256 id=littHashID[_hash];\n', '             if (littClientAddress[_hash] != address(0)){\n', '                emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[id].timestamp,littafi[id].metadata,littafi[id].unique,littafi[id].clientPool,littafi[id].access,true);\n', '                return;\n', '             }else{\n', '\n', '              littafiContents memory commit=littafiContents(littID,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel);\n', '              littafi.push(commit);\n', '\n', '              subscriberContentCount[msg.sender]++;\n', '              littCapsule[_hash]=_capsuleRelease;\n', '              littClientAddress[_hash]=msg.sender;\n', '              littIPFS[_hash]=_ipfs;\n', '              littHashID[_hash]=littID;\n', '              littID++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littContent(msg.sender,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel,true);\n', '              return;\n', '             }\n', '\n', '      }\n', '\n', '      function transferContentOwnership(bytes32 _hash, address _address, string _timestamp) public {\n', '          require(littClientAddress[_hash] == msg.sender);\n', '          littClientAddress[_hash]=_address;\n', '          emit littContentOwnershipTransferred(_hash,_address,_timestamp);\n', '          return;\n', '      }\n', '\n', '      function getLittafiContent(bytes32 _hash,uint256 _poolID) public payable{\n', '        if (littClientAddress[_hash] != address(0) && littafi[littHashID[_hash]].clientPool==_poolID){\n', '            owner.transfer(msg.value);\n', '            emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[littHashID[_hash]].timestamp,littafi[littHashID[_hash]].metadata,littafi[littHashID[_hash]].unique,littafi[littHashID[_hash]].clientPool,littafi[littHashID[_hash]].access,true);\n', '            return;\n', '        }\n', '      }\n', '\n', '      function setDelegateAdmin(address _address, string _timestamp, bool _state) public onlyOwner() returns(bool){\n', '          require(admins[_address].isAdmin == false);\n', '          isDelegateAdmin[_address]=_state;\n', '          emit littafiDelegateAdmin(msg.sender,_address,_state,_timestamp);\n', '          return true;\n', '      }\n', '\n', '      function setAssignedID(address _address,uint256 _assignedID, string _timestamp) public onlyDelegate(){\n', '          require(setPoolAdmin[_assignedID] == address(0));\n', '          setPoolAdmin[_assignedID]=_address;\n', '          emit littafiAssignedID(msg.sender,_timestamp,_assignedID,_address);\n', '          return;\n', '      }\n', '\n', '      function changeAssignedAdmin(address _newAdmin, uint256 _assignedID, string _timestamp) public onlyOwner(){\n', '          address _previousAdmin=poolAdmin[_assignedID];\n', '\n', '          admins[_previousAdmin].isAdmin=false;\n', '          admins[_previousAdmin].poolID=0;\n', '          subscriber[_previousAdmin].clientPool=0;\n', '\n', '          if(!subscriberStatus[_newAdmin])\n', '             subscriber[_newAdmin].subID=littID;\n', '             subscriber[_newAdmin].clientPool=_assignedID;\n', '\n', '          admins[_newAdmin].isAdmin=true;\n', '          admins[_newAdmin].poolID=_assignedID;\n', '          littID++;\n', '\n', '          emit littafiAdminReassigned(_previousAdmin,_newAdmin,_timestamp,_assignedID);\n', '          return;\n', '      }\n', '\n', '      function getPoolAdmin(uint256 _poolID) public view onlyDelegate() returns(address){\n', '          return poolAdmin[_poolID];\n', '      }\n', '\n', '      function modifyContentAccess(bytes32 _hash, bool _access, uint256 _poolID)public onlyLittafiAdmin(_poolID){\n', '         littafi[littHashID[_hash]].access=_access;\n', '         emit littContentAccessModified(msg.sender,_hash,_poolID,_access);\n', '         return;\n', '      }\n', '\n', '      function getClientCount() public view returns(uint256){\n', '          return littClientId;\n', '      }\n', '\n', '      function getContentCount() public view returns(uint256){\n', '          return littID;\n', '      }\n', '\n', '      function getLittAdminCount() public view onlyDelegate() returns(uint256){\n', '          return littAdmins;\n', '      }\n', '\n', '      function setPoolName(string _poolName,uint256 _poolID) public onlyLittafiAdmin(_poolID){\n', '          admins[msg.sender].poolName=_poolName;\n', '          emit littPoolModified(msg.sender,_poolName,_poolID);\n', '          return;\n', '      }\n', '\n', '      function getPoolName(uint256 _poolID) public view onlyLittafiAdmin(_poolID) returns(string){\n', '          return admins[msg.sender].poolName;\n', '      }\n', '\n', '      function getPoolNameByID(uint256 _poolID) public view returns(string){\n', '          return poolName[_poolID];\n', '      }\n', '\n', '      function getPoolID() public view returns(uint256){\n', '          return subscriber[msg.sender].clientPool;\n', '      }\n', '\n', '      function getSubscriberType() public view returns(bool){\n', '          return admins[msg.sender].isAdmin;\n', '      }\n', '\n', '      function getSubscriberStatus() public view returns(bool){\n', '          return subscriberStatus[msg.sender];\n', '      }\n', '\n', '      function getSubscriberContentCount() public view returns(uint256){\n', '          return subscriberContentCount[msg.sender];\n', '      }\n', '\n', '      function getSubscriberContentHashes() public view returns(bytes32[]){\n', '          return subscriberContentHashes[msg.sender];\n', '      }\n', '\n', '      function getDelegate() public view returns(bool){\n', '          return isDelegateAdmin[msg.sender];\n', '      }\n', '\n', '      function littContentExists(bytes32 _hash) public view returns(bool){\n', '          return littClientAddress[_hash] == address(0) ? false : true;\n', '      }\n', '\n', '      function littPoolIDExists(uint256 _poolID) public view returns(bool){\n', '          return poolAdmin[_poolID] == address(0) ? false : true;\n', '      }\n', '\n', '      function littIsCapsule(bytes32 _hash) public view returns(bool){\n', '          return littCapsule[_hash] == 0 ? false : true;\n', '      }\n', '\n', '      function littCapsuleGet(bytes32 _hash) public view returns(uint256){\n', '          return littIsCapsule(_hash) == true ? littCapsule[_hash] : 0;\n', '      }\n', '      \n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/* Team Littafi\n', '**/\n', '\n', ' \n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', '     if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert( c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '    //assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    //assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) public pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) external pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '\n', ' contract LittafiOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '     constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner public{\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOnwership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner,newOwner);\n', '        owner=newOwner;\n', '        newOwner=address(0);\n', '    }\n', '\n', '}\n', '\n', ' contract Littafi is LittafiOwned{\n', '\n', '      using SafeMath for uint256;\n', '\n', '      uint256   public littID=0;\n', '      uint256   public littClientId=1;\n', '      bool      public sentinel=true;\n', '      uint256   public littafiAccount=0;\n', '      uint256   public littAdmins;\n', '\n', '      littafiContents[] public littafi;\n', '\n', '      mapping(bytes32 => address) littClientAddress;\n', '\n', '      mapping(bytes32 => string)  littIPFS;\n', '\n', '      mapping(bytes32 => uint256) littHashID;\n', '\n', '      mapping(bytes32 => uint256) littCapsule;\n', '\n', '      mapping(address => littafiAdmin) admins;\n', '\n', '      mapping(address => littafiSubscribtion) subscriber;\n', '\n', '      mapping(address => bool) subscriberStatus;\n', '\n', '      mapping(uint256 => address) poolAdmin;\n', '\n', '      mapping(uint256 => address) setPoolAdmin;\n', '\n', '      mapping(address => bool) isDelegateAdmin;\n', '\n', '      mapping(uint256 => string)  poolName;\n', '\n', '      mapping(address => bytes32[]) subscriberContentHashes;\n', '\n', '      mapping(address => uint256)  subscriberContentCount;\n', '      \n', '      mapping(address => bool) transferred;\n', '\n', '      struct littafiContents{\n', '          uint256 id;\n', '          bytes32 hash;\n', '          string  ipfs;\n', '          string timestamp;\n', '          string  metadata;\n', '          string  unique;\n', '          uint256 clientPool;\n', '          bool    access;\n', '      }\n', '\n', '      struct littafiAdmin{\n', '          uint256 poolID;\n', '          bool isAdmin;\n', '          string poolName;\n', '      }\n', '\n', '      struct littafiSubscribtion{\n', '          uint256 subID;\n', '          uint256 clientPool;\n', '      }\n', '\n', '      modifier onlyLittafiAdmin(uint256 _poolID){\n', '          require(admins[msg.sender].isAdmin == true && admins[msg.sender].poolID == _poolID && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiSubscribed(){\n', '          require(msg.value > 0 && subscriber[msg.sender].subID > 0 && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiNonSubscribed(){\n', '          require(msg.value > 0 && subscriber[msg.sender].subID == 0 && msg.sender != owner);\n', '          _;\n', '      }\n', '\n', '      modifier onlyDelegate(){\n', '          require(msg.sender == owner || isDelegateAdmin[msg.sender] == true);\n', '          _;\n', '      }\n', '\n', '      modifier onlyLittafiContentOwner(bytes32 _hash){\n', '          require(msg.sender == littClientAddress[_hash]);\n', '          _;\n', '      }\n', '\n', '      event littContent(address indexed _address,bytes32 _hash, string _ipfs, string _timestamp, string _metadata, string unique, uint256 _poolID, bool _access, bool success);\n', '\n', '      event littClientSubscribed(address indexed _address, string _timestamp,uint256 _fee,uint256 _poolID,bool success);\n', '\n', '      event littafiAssignedID(address indexed _adminAddress, string _timestamp, uint256 _poolID, address indexed _address);\n', '\n', '      event littafiAdminReassigned(address indexed _previousAdmin,address indexed _newAdmin,string _timestamp,uint256 _assignedID);\n', '\n', '      event littafiDelegateAdmin(address indexed _admin, address indexed _delegate,bool _state,string _timestamp);\n', '\n', '      event littContentAccessModified(address indexed _admin,bytes32 _hash, uint256 _poolID,bool _access);\n', '\n', '      event littPoolModified(address indexed _address,string _poolName,uint256 _poolID);\n', '\n', '      event littContentOwnershipTransferred(bytes32 _hash, address indexed _address, string _timestamp);\n', '\n', '      constructor() public{\n', '          LittafiOwned(msg.sender);\n', '      }\n', '\n', '      function subscribtionLittafi(uint256 _assignedID,string _timestamp, string _poolName) public payable onlyLittafiNonSubscribed(){\n', '\n', '          if(_assignedID > 0 && setPoolAdmin[_assignedID] == msg.sender){\n', '             subscriber[msg.sender].subID=littClientId;\n', '             subscriber[msg.sender].clientPool=_assignedID;\n', '             subscriberStatus[msg.sender]=true;\n', '             admins[msg.sender].poolID=_assignedID;\n', '             admins[msg.sender].isAdmin=true;\n', '             admins[msg.sender].poolName=_poolName;\n', '             poolAdmin[_assignedID]=msg.sender;\n', '             poolName[_assignedID]=_poolName;\n', '             littClientId++;\n', '             littAdmins++;\n', '             owner.transfer(msg.value);\n', '             littafiAccount.add(msg.value);\n', '\n', '             emit littClientSubscribed(msg.sender,_timestamp,msg.value,_assignedID,true);\n', '             return;\n', '          }else{\n', '              subscriber[msg.sender].subID=littClientId;\n', '              subscriber[msg.sender].clientPool=0;\n', '              subscriberStatus[msg.sender]=true;\n', '              littClientId++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littClientSubscribed(msg.sender,_timestamp,msg.value,0,true);\n', '              return;\n', '          }\n', '      }\n', '\n', '      function littafiContentCommit(bytes32 _hash,string _ipfs,string _timestamp,string _metadata,string _unique,bool _sentinel) public payable onlyLittafiSubscribed(){\n', '\n', '             uint256 id=littHashID[_hash];\n', '             if (littClientAddress[_hash] != address(0)){\n', '                emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[id].timestamp,littafi[id].metadata,littafi[id].unique,littafi[id].clientPool,littafi[id].access,true);\n', '                return;\n', '             }else{\n', '\n', '              if(admins[msg.sender].isAdmin == true) sentinel=_sentinel;\n', '\n', '              littafiContents memory commit=littafiContents(littID,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel);\n', '              littafi.push(commit);\n', '\n', '              subscriberContentCount[msg.sender]++;\n', '              subscriberContentHashes[msg.sender].push(_hash);\n', '              littClientAddress[_hash]=msg.sender;\n', '              littIPFS[_hash]=_ipfs;\n', '              littHashID[_hash]=littID;\n', '              littID++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littContent(msg.sender,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel,true);\n', '              return;\n', '             }\n', '\n', '      }\n', '\n', '      function littafiTimeCapsule(bytes32 _hash,string _ipfs,string _timestamp,string _metadata,string _unique,uint256 _capsuleRelease) public payable onlyLittafiSubscribed(){\n', '\n', '             uint256 id=littHashID[_hash];\n', '             if (littClientAddress[_hash] != address(0)){\n', '                emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[id].timestamp,littafi[id].metadata,littafi[id].unique,littafi[id].clientPool,littafi[id].access,true);\n', '                return;\n', '             }else{\n', '\n', '              littafiContents memory commit=littafiContents(littID,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel);\n', '              littafi.push(commit);\n', '\n', '              subscriberContentCount[msg.sender]++;\n', '              littCapsule[_hash]=_capsuleRelease;\n', '              littClientAddress[_hash]=msg.sender;\n', '              littIPFS[_hash]=_ipfs;\n', '              littHashID[_hash]=littID;\n', '              littID++;\n', '              owner.transfer(msg.value);\n', '\n', '              emit littContent(msg.sender,_hash,_ipfs,_timestamp,_metadata,_unique,subscriber[msg.sender].clientPool,sentinel,true);\n', '              return;\n', '             }\n', '\n', '      }\n', '\n', '      function transferContentOwnership(bytes32 _hash, address _address, string _timestamp) public {\n', '          require(littClientAddress[_hash] == msg.sender);\n', '          littClientAddress[_hash]=_address;\n', '          emit littContentOwnershipTransferred(_hash,_address,_timestamp);\n', '          return;\n', '      }\n', '\n', '      function getLittafiContent(bytes32 _hash,uint256 _poolID) public payable{\n', '        if (littClientAddress[_hash] != address(0) && littafi[littHashID[_hash]].clientPool==_poolID){\n', '            owner.transfer(msg.value);\n', '            emit littContent(littClientAddress[_hash],_hash,littIPFS[_hash],littafi[littHashID[_hash]].timestamp,littafi[littHashID[_hash]].metadata,littafi[littHashID[_hash]].unique,littafi[littHashID[_hash]].clientPool,littafi[littHashID[_hash]].access,true);\n', '            return;\n', '        }\n', '      }\n', '\n', '      function setDelegateAdmin(address _address, string _timestamp, bool _state) public onlyOwner() returns(bool){\n', '          require(admins[_address].isAdmin == false);\n', '          isDelegateAdmin[_address]=_state;\n', '          emit littafiDelegateAdmin(msg.sender,_address,_state,_timestamp);\n', '          return true;\n', '      }\n', '\n', '      function setAssignedID(address _address,uint256 _assignedID, string _timestamp) public onlyDelegate(){\n', '          require(setPoolAdmin[_assignedID] == address(0));\n', '          setPoolAdmin[_assignedID]=_address;\n', '          emit littafiAssignedID(msg.sender,_timestamp,_assignedID,_address);\n', '          return;\n', '      }\n', '\n', '      function changeAssignedAdmin(address _newAdmin, uint256 _assignedID, string _timestamp) public onlyOwner(){\n', '          address _previousAdmin=poolAdmin[_assignedID];\n', '\n', '          admins[_previousAdmin].isAdmin=false;\n', '          admins[_previousAdmin].poolID=0;\n', '          subscriber[_previousAdmin].clientPool=0;\n', '\n', '          if(!subscriberStatus[_newAdmin])\n', '             subscriber[_newAdmin].subID=littID;\n', '             subscriber[_newAdmin].clientPool=_assignedID;\n', '\n', '          admins[_newAdmin].isAdmin=true;\n', '          admins[_newAdmin].poolID=_assignedID;\n', '          littID++;\n', '\n', '          emit littafiAdminReassigned(_previousAdmin,_newAdmin,_timestamp,_assignedID);\n', '          return;\n', '      }\n', '\n', '      function getPoolAdmin(uint256 _poolID) public view onlyDelegate() returns(address){\n', '          return poolAdmin[_poolID];\n', '      }\n', '\n', '      function modifyContentAccess(bytes32 _hash, bool _access, uint256 _poolID)public onlyLittafiAdmin(_poolID){\n', '         littafi[littHashID[_hash]].access=_access;\n', '         emit littContentAccessModified(msg.sender,_hash,_poolID,_access);\n', '         return;\n', '      }\n', '\n', '      function getClientCount() public view returns(uint256){\n', '          return littClientId;\n', '      }\n', '\n', '      function getContentCount() public view returns(uint256){\n', '          return littID;\n', '      }\n', '\n', '      function getLittAdminCount() public view onlyDelegate() returns(uint256){\n', '          return littAdmins;\n', '      }\n', '\n', '      function setPoolName(string _poolName,uint256 _poolID) public onlyLittafiAdmin(_poolID){\n', '          admins[msg.sender].poolName=_poolName;\n', '          emit littPoolModified(msg.sender,_poolName,_poolID);\n', '          return;\n', '      }\n', '\n', '      function getPoolName(uint256 _poolID) public view onlyLittafiAdmin(_poolID) returns(string){\n', '          return admins[msg.sender].poolName;\n', '      }\n', '\n', '      function getPoolNameByID(uint256 _poolID) public view returns(string){\n', '          return poolName[_poolID];\n', '      }\n', '\n', '      function getPoolID() public view returns(uint256){\n', '          return subscriber[msg.sender].clientPool;\n', '      }\n', '\n', '      function getSubscriberType() public view returns(bool){\n', '          return admins[msg.sender].isAdmin;\n', '      }\n', '\n', '      function getSubscriberStatus() public view returns(bool){\n', '          return subscriberStatus[msg.sender];\n', '      }\n', '\n', '      function getSubscriberContentCount() public view returns(uint256){\n', '          return subscriberContentCount[msg.sender];\n', '      }\n', '\n', '      function getSubscriberContentHashes() public view returns(bytes32[]){\n', '          return subscriberContentHashes[msg.sender];\n', '      }\n', '\n', '      function getDelegate() public view returns(bool){\n', '          return isDelegateAdmin[msg.sender];\n', '      }\n', '\n', '      function littContentExists(bytes32 _hash) public view returns(bool){\n', '          return littClientAddress[_hash] == address(0) ? false : true;\n', '      }\n', '\n', '      function littPoolIDExists(uint256 _poolID) public view returns(bool){\n', '          return poolAdmin[_poolID] == address(0) ? false : true;\n', '      }\n', '\n', '      function littIsCapsule(bytes32 _hash) public view returns(bool){\n', '          return littCapsule[_hash] == 0 ? false : true;\n', '      }\n', '\n', '      function littCapsuleGet(bytes32 _hash) public view returns(uint256){\n', '          return littIsCapsule(_hash) == true ? littCapsule[_hash] : 0;\n', '      }\n', '      \n', '}']
