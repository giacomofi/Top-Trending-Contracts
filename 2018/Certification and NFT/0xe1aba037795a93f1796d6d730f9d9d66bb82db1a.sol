['pragma solidity 0.4.24;\n', '\n', '// File: contracts/ERC780.sol\n', '\n', '/// @title ERC780\n', '/// @notice The ERC780 interface for storing and interacting with claims.\n', '/// See https://github.com/ethereum/EIPs/issues/780\n', 'contract ERC780 {\n', '    function setClaim(address subject, bytes32 key, bytes32 value) public;\n', '    function setSelfClaim(bytes32 key, bytes32 value) public;\n', '    function getClaim(address issuer, address subject, bytes32 key) public view returns (bytes32);\n', '    function removeClaim(address issuer, address subject, bytes32 key) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/RBACInterface.sol\n', '\n', '/// @title RBACInterface\n', '/// @notice The interface for Role-Based Access Control.\n', 'contract RBACInterface {\n', '    function hasRole(address addr, string role) public view returns (bool);\n', '}\n', '\n', '// File: contracts/RBACManaged.sol\n', '\n', '/// @title RBACManaged\n', '/// @notice Controls access by delegating to a deployed RBAC contract.\n', 'contract RBACManaged is Ownable {\n', '\n', '    RBACInterface public rbac;\n', '\n', '    /// @param rbacAddr The address of the RBAC contract which controls access.\n', '    constructor(address rbacAddr) public {\n', '        rbac = RBACInterface(rbacAddr);\n', '    }\n', '\n', '    function roleAdmin() internal pure returns (string);\n', '\n', '    /// @notice Check if an address has a role.\n', '    /// @param addr The address.\n', '    /// @param role The role.\n', '    /// @return A boolean indicating whether the address has the role.\n', '    function hasRole(address addr, string role) public view returns (bool) {\n', '        return rbac.hasRole(addr, role);\n', '    }\n', '\n', '    modifier onlyRole(string role) {\n', '        require(hasRole(msg.sender, role), "Access denied: missing role");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(\n', '            msg.sender == owner || hasRole(msg.sender, roleAdmin()), "Access denied: missing role");\n', '        _;\n', '    }\n', '\n', '    /// @notice Change the address of the deployed RBAC contract which\n', '    /// controls access. Only the owner or an admin can change the address.\n', '    /// @param rbacAddr The address of the RBAC contract which controls access.\n', '    function setRBACAddress(address rbacAddr) public onlyOwnerOrAdmin {\n', '        rbac = RBACInterface(rbacAddr);\n', '    }\n', '}\n', '\n', '// File: contracts/UserAddressAliasable.sol\n', '\n', '/// @title UserAddressAliasable\n', '/// @notice Allows the address that represents an entity (individual) to be\n', '/// changed by setting aliases. Any data about an entity should be associated\n', '/// to the original (canonical) address.\n', 'contract UserAddressAliasable is RBACManaged {\n', '\n', '    event UserAddressAliased(address indexed oldAddr, address indexed newAddr);\n', '\n', '    mapping(address => address) addressAlias;  // canonical => alias\n', '\n', '    function roleAddressAliaser() internal pure returns (string);\n', '\n', '    /// @notice Alias a new address to an old address. Requires caller to have\n', '    /// the address aliaser role returned by roleAddressAliaser(). Requires\n', '    /// that neither address is already aliased to another address.\n', '    /// @param oldAddr The old address.\n', '    /// @param newAddr The new address.\n', '    function setAddressAlias(address oldAddr, address newAddr) public onlyRole(roleAddressAliaser()) {\n', '        require(addressAlias[oldAddr] == address(0), "oldAddr is already aliased to another address");\n', '        require(addressAlias[newAddr] == address(0), "newAddr is already aliased to another address");\n', '        require(oldAddr != newAddr, "oldAddr and newAddr must be different");\n', '        setAddressAliasUnsafe(oldAddr, newAddr);\n', '    }\n', '\n', '    /// @notice Alias a new address to an old address, bypassing all safety\n', '    /// checks. Can result in broken state, so use at your own peril. Requires\n', '    /// caller to have the address aliaser role returned by\n', '    /// roleAddressAliaser().\n', '    /// @param oldAddr The old address.\n', '    /// @param newAddr The new address.\n', '    function setAddressAliasUnsafe(address oldAddr, address newAddr) public onlyRole(roleAddressAliaser()) {\n', '        addressAlias[newAddr] = oldAddr;\n', '        emit UserAddressAliased(oldAddr, newAddr);\n', '    }\n', '\n', '    /// @notice Change an address to no longer alias to anything else. Calling\n', '    /// setAddressAlias(oldAddr, newAddr) is reversed by calling\n', '    /// unsetAddressAlias(newAddr).\n', '    /// @param addr The address to unalias. Equivalent to newAddr in setAddressAlias.\n', '    function unsetAddressAlias(address addr) public onlyRole(roleAddressAliaser()) {\n', '        setAddressAliasUnsafe(0, addr);\n', '    }\n', '\n', '    /// @notice Resolve an address to its canonical address.\n', '    /// @param addr The address to resolve.\n', '    /// @return The canonical address.\n', '    function resolveAddress(address addr) public view returns (address) {\n', '        address parentAddr = addressAlias[addr];\n', '        if (parentAddr == address(0)) {\n', '            return addr;\n', '        } else {\n', '            return parentAddr;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/ODEMClaimsRegistry.sol\n', '\n', '/// @title ODEMClaimsRegistry\n', '/// @notice When an individual completes an event (educational course) with\n', '/// ODEM, ODEM generates a certificate of completion and sets a corresponding\n', '/// claim in this contract. The claim contains the URI (usually an IPFS path)\n', '/// where the certificate can be downloaded, and its hash (SHA-256) to prove its\n', '/// authenticity.\n', '/// If an individual changes their Ethereum address, for example if they lose\n', '/// access to their account, ODEM may alias the new address to the old\n', '/// address. Then claims apply automatically to both addresses.\n', '/// Implements the ERC780 interface.\n', 'contract ODEMClaimsRegistry is RBACManaged, UserAddressAliasable, ERC780 {\n', '\n', '    event ClaimSet(\n', '        address indexed issuer,\n', '        address indexed subject,\n', '        bytes32 indexed key,\n', '        bytes32 value,\n', '        uint updatedAt\n', '    );\n', '    event ClaimRemoved(\n', '        address indexed issuer,\n', '        address indexed subject,\n', '        bytes32 indexed key,\n', '        uint removedAt\n', '    );\n', '\n', '    string constant ROLE_ADMIN = "claims__admin";\n', '    string constant ROLE_ISSUER = "claims__issuer";\n', '    string constant ROLE_ADDRESS_ALIASER = "claims__address_aliaser";\n', '\n', '    struct Claim {\n', '        bytes uri;\n', '        bytes32 hash;\n', '    }\n', '\n', '    mapping(address => mapping(bytes32 => Claim)) internal claims;  // subject => key => claim\n', '\n', '    // Used for safe address aliasing. Never reset to false.\n', '    mapping(address => bool) internal hasClaims;\n', '\n', '    /// @param rbacAddr The address of the RBAC contract which controls access to this\n', '    /// contract.\n', '    constructor(address rbacAddr) RBACManaged(rbacAddr) public {}\n', '\n', '    /// @notice Get an ODEM claim.\n', '    /// @param subject The address of the individual.\n', '    /// @param key The ODEM event code.\n', '    /// @return The URI where the certificate can be downloaded, and the hash\n', '    /// of the certificate file.\n', '    function getODEMClaim(address subject, bytes32 key) public view returns (bytes uri, bytes32 hash) {\n', '        address resolved = resolveAddress(subject);\n', '        return (claims[resolved][key].uri, claims[resolved][key].hash);\n', '    }\n', '\n', '    /// @notice Set an ODEM claim.\n', '    /// Only ODEM can set claims.\n', '    /// @dev Requires caller to have the role "claims__issuer".\n', '    /// @param subject The address of the individual.\n', '    /// @param key The ODEM event code.\n', '    /// @param uri The URI where the certificate can be downloaded.\n', '    /// @param hash The hash of the certificate file.\n', '    function setODEMClaim(address subject, bytes32 key, bytes uri, bytes32 hash) public onlyRole(ROLE_ISSUER) {\n', '        address resolved = resolveAddress(subject);\n', '        claims[resolved][key].uri = uri;\n', '        claims[resolved][key].hash = hash;\n', '        hasClaims[resolved] = true;\n', '        emit ClaimSet(msg.sender, subject, key, hash, now);\n', '    }\n', '\n', '    /// @notice Remove an ODEM claim. Anyone can remove a claim about\n', '    /// themselves.\n', '    /// Only ODEM can remove claims about others.\n', '    /// @dev Requires caller to have the role "claims__issuer" or to be the\n', '    /// subject.\n', '    /// @param subject The address of the individual.\n', '    /// @param key The ODEM event code.\n', '    function removeODEMClaim(address subject, bytes32 key) public {\n', '        require(hasRole(msg.sender, ROLE_ISSUER) || msg.sender == subject, "Access denied: missing role");\n', '        address resolved = resolveAddress(subject);\n', '        delete claims[resolved][key];\n', '        emit ClaimRemoved(msg.sender, subject, key, now);\n', '    }\n', '\n', '    /// @notice Alias a new address to an old address.\n', '    /// Only ODEM can set aliases.\n', '    /// @dev Requires caller to have the role "claims__address_aliaser".\n', '    /// Requires that neither address is already aliased to another address,\n', '    /// and that the new address does not already have claims.\n', '    /// @param oldAddr The old address.\n', '    /// @param newAddr The new address.\n', '    function setAddressAlias(address oldAddr, address newAddr) public onlyRole(ROLE_ADDRESS_ALIASER) {\n', '        require(!hasClaims[newAddr], "newAddr already has claims");\n', '        super.setAddressAlias(oldAddr, newAddr);\n', '    }\n', '\n', '    /// @notice Get a claim. Provided for compatibility with ERC780.\n', '    /// Only gets claims where the issuer is ODEM.\n', '    /// @param issuer The address which set the claim.\n', '    /// @param subject The address of the individual.\n', '    /// @param key The ODEM event code.\n', '    /// @return The hash of the certificate file.\n', '    function getClaim(address issuer, address subject, bytes32 key) public view returns (bytes32) {\n', '        if (hasRole(issuer, ROLE_ISSUER)) {\n', '            return claims[subject][key].hash;\n', '        } else {\n', '            return bytes32(0);\n', '        }\n', '    }\n', '\n', '    /// @notice Provided for compatibility with ERC780. Always fails.\n', '    function setClaim(address subject, bytes32 key, bytes32 value) public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Provided for compatibility with ERC780. Always fails.\n', '    function setSelfClaim(bytes32 key, bytes32 value) public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Remove a claim. Provided for compatibility with ERC780.\n', '    /// Only removes claims where the issuer is ODEM.\n', '    /// Anyone can remove a claim about themselves. Only ODEM can remove\n', '    /// claims about others.\n', '    /// @dev Requires issuer to have the role "claims__issuer".\n', '    /// Requires caller to have the role "claims__issuer" or to be the\n', '    /// subject.\n', '    /// @param issuer The address which set the claim.\n', '    /// @param subject The address of the individual.\n', '    /// @param key The ODEM event code.\n', '    function removeClaim(address issuer, address subject, bytes32 key) public {\n', '        require(hasRole(issuer, ROLE_ISSUER), "Issuer not recognized");\n', '        removeODEMClaim(subject, key);\n', '    }\n', '\n', '    // Required by RBACManaged.\n', '    function roleAdmin() internal pure returns (string) {\n', '        return ROLE_ADMIN;\n', '    }\n', '\n', '    // Required by UserAddressAliasable\n', '    function roleAddressAliaser() internal pure returns (string) {\n', '        return ROLE_ADDRESS_ALIASER;\n', '    }\n', '}']