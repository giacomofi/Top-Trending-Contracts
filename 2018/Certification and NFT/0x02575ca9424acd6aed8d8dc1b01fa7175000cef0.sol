['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner{\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC721Interface {\n', '    // Required methods\n', '    // function totalSupply() public view returns (uint256 total);\n', '    // function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    // function approve(address _to, uint256 _tokenId) external;\n', '    // function transfer(address _to, uint256 _tokenId) external;\n', '    // function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '}\n', '\n', '/** \n', ' * @dev Name provider contract\n', ' * Allows saving names and descriptons for specified addresses and tokens\n', ' */\n', 'contract NameProvider is Ownable {\n', '    \n', '    uint256 public FEE = 1 finney;\n', '    \n', '    //name storage for addresses\n', '    mapping(bytes32 => mapping(address => string)) addressNames;\n', '    \n', '    //marks namespaces as already used on first name save to specified namespace\n', '    mapping(bytes32 => bool) takenNamespaces;\n', '    \n', '    //name storage for tokens\n', '    mapping(address => mapping(uint256 => string)) tokenNames;\n', '    \n', '    //description storage for tokens\n', '    mapping(address => mapping(uint256 => string)) tokenDescriptions;\n', '    \n', '    /* EVENTS */\n', '    \n', '    event NameChanged(bytes32 namespace, address account, string name);\n', '    \n', '    event TokenNameChanged(address tokenProvider, uint256 tokenId, string name);\n', '    \n', '    event TokenDescriptionChanged(address tokenProvider, uint256 tokenId, string description);\n', '    \n', '    function NameProvider(address _owner) public {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '    \n', '    modifier setTokenText(address _tokenInterface, uint256 _tokenId, string _text){\n', '        //check fee\n', '        require(msg.value >= FEE);\n', '        //no empty strings allowed\n', '        require(bytes(_text).length > 0);\n', '        \n', '        ERC721Interface tokenInterface = ERC721Interface(_tokenInterface);\n', '        //only token owner can set its name\n', '        require(msg.sender == tokenInterface.ownerOf(_tokenId));\n', '        \n', '        _;//set text code\n', '        \n', '        //return excess\n', '        if (msg.value > FEE) {\n', '            msg.sender.transfer(msg.value - FEE);\n', '        }\n', '    }\n', '    \n', '    //@dev set name for specified token,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose name will be set\n', '    //@param _name string that will be set as new token name\n', '    function setTokenName(address _tokenInterface, uint256 _tokenId, string _name) \n', '    setTokenText(_tokenInterface, _tokenId, _name) external payable {\n', '        _setTokenName(_tokenInterface, _tokenId, _name);\n', '    }\n', '    \n', '    //@dev set description for specified token,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose description will be set\n', '    //@param _description string that will be set as new token description\n', '    function setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description)\n', '    setTokenText(_tokenInterface, _tokenId, _description) external payable {\n', '        _setTokenDescription(_tokenInterface, _tokenId, _description);\n', '    }\n', '    \n', '    //@dev get name of specified token,\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose name will be returned\n', '    function getTokenName(address _tokenInterface, uint256 _tokenId) external view returns(string) {\n', '        return tokenNames[_tokenInterface][_tokenId];\n', '    }\n', '    \n', '    //@dev get description of specified token,\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose description will be returned\n', '    function getTokenDescription(address _tokenInterface, uint256 _tokenId) external view returns(string) {\n', '        return tokenDescriptions[_tokenInterface][_tokenId];\n', '    }\n', '    \n', '    //@dev set global name for msg.sender,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _name string that will be set as new address name\n', '    function setName(string _name) external payable {\n', '        setServiceName(bytes32(0), _name);\n', '    }\n', '    \n', '    //@dev set name for msg.sender in cpecified namespace,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _namespace bytes32 service identifier\n', '    //@param _name string that will be set as new address name\n', '    function setServiceName(bytes32 _namespace, string memory _name) public payable {\n', '        //check fee\n', '        require(msg.value >= FEE);\n', '        //set name\n', '        _setName(_namespace, _name);\n', '        //return excess\n', '        if (msg.value > FEE) {\n', '            msg.sender.transfer(msg.value - FEE);\n', '        }\n', '    }\n', '    \n', '    //@dev get global name for specified address,\n', '    //@param _address the address for whom name string will be returned\n', '    function getNameByAddress(address _address) external view returns(string) {\n', '        return addressNames[bytes32(0)][_address];\n', '    }\n', '    \n', '    //@dev get global name for msg.sender,\n', '    function getName() external view returns(string) {\n', '        return addressNames[bytes32(0)][msg.sender];\n', '    }\n', '    \n', '    //@dev get name for specified address and namespace,\n', '    //@param _namespace bytes32 service identifier\n', '    //@param _address the address for whom name string will be returned\n', '    function getServiceNameByAddress(bytes32 _namespace, address _address) external view returns(string) {\n', '        return addressNames[_namespace][_address];\n', '    }\n', '    \n', '    //@dev get name for specified namespace and msg.sender,\n', '    //@param _namespace bytes32 service identifier\n', '    function getServiceName(bytes32 _namespace) external view returns(string) {\n', '        return addressNames[_namespace][msg.sender];\n', '    }\n', '    \n', '    //@dev get names for specified addresses in global namespace (bytes32(0))\n', '    //@param _address address[] array of addresses for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \n', '    function getNames(address[] _address) external view returns(bytes32[] namesData, uint256[] nameLength) {\n', '        return getServiceNames(bytes32(0), _address);\n', '\t}\n', '\t\n', '\t//@dev get names for specified tokens \n', '    //@param _tokenIds uint256[] array of ids for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \n', '\tfunction getTokenNames(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        return _getTokenTexts(_tokenInterface, _tokenIds, true);\n', '\t}\n', '\t\n', '\t//@dev get names for specified tokens \n', '    //@param _tokenIds uint256[] array of ids for whom descriptons will be returned\n', '    //@return descriptonData bytes32 \n', '    //@return descriptionLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \n', '\tfunction getTokenDescriptions(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory descriptonData, uint256[] memory descriptionLength) {\n', '        return _getTokenTexts(_tokenInterface, _tokenIds, false);\n', '\t}\n', '\t\n', '\t//@dev get names for specified addresses and namespace\n', '\t//@param _namespace bytes32 namespace identifier\n', '    //@param _address address[] array of addresses for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \n', '    function getServiceNames(bytes32 _namespace, address[] _address) public view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        uint256 length = _address.length;\n', '        nameLength = new uint256[](length);\n', '        \n', '        bytes memory stringBytes;\n', '        uint256 size = 0;\n', '        uint256 i;\n', '        for (i = 0; i < length; i ++) {\n', '            stringBytes = bytes(addressNames[_namespace][_address[i]]);\n', '            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\n', '        }\n', '        namesData = new bytes32[](size);\n', '        size = 0;\n', '        for (i = 0; i < length; i ++) {\n', '            size += _stringToBytes32(addressNames[_namespace][_address[i]], namesData, size);\n', '        }\n', '    }\n', '    \n', '    function namespaceTaken(bytes32 _namespace) external view returns(bool) {\n', '        return takenNamespaces[_namespace];\n', '    }\n', '    \n', '    function setFee(uint256 _fee) onlyOwner external {\n', '        FEE = _fee;\n', '    }\n', '    \n', '    function withdraw() onlyOwner external {\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function _setName(bytes32 _namespace, string _name) internal {\n', '        addressNames[_namespace][msg.sender] = _name;\n', '        if (!takenNamespaces[_namespace]) {\n', '            takenNamespaces[_namespace] = true;\n', '        }\n', '        NameChanged(_namespace, msg.sender, _name);\n', '    }\n', '    \n', '    function _setTokenName(address _tokenInterface, uint256 _tokenId, string _name) internal {\n', '        tokenNames[_tokenInterface][_tokenId] = _name;\n', '        TokenNameChanged(_tokenInterface, _tokenId, _name);\n', '    }\n', '    \n', '    function _setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description) internal {\n', '        tokenDescriptions[_tokenInterface][_tokenId] = _description;\n', '        TokenDescriptionChanged(_tokenInterface, _tokenId, _description);\n', '    }\n', '    \n', '    function _getTokenTexts(address _tokenInterface, uint256[] memory _tokenIds, bool names) internal view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        uint256 length = _tokenIds.length;\n', '        nameLength = new uint256[](length);\n', '        mapping(address => mapping(uint256 => string)) textMap = names ? tokenNames : tokenDescriptions;\n', '        \n', '        bytes memory stringBytes;\n', '        uint256 size = 0;\n', '        uint256 i;\n', '        for (i = 0; i < length; i ++) {\n', '            stringBytes = bytes(textMap[_tokenInterface][_tokenIds[i]]);\n', '            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\n', '        }\n', '        namesData = new bytes32[](size);\n', '        size = 0;\n', '        for (i = 0; i < length; i ++) {\n', '            size += _stringToBytes32(textMap[_tokenInterface][_tokenIds[i]], namesData, size);\n', '        }\n', '    }\n', '    \n', '        \n', '    function _stringToBytes32(string memory source, bytes32[] memory namesData, uint256 _start) internal pure returns (uint256) {\n', '        bytes memory stringBytes = bytes(source);\n', '        uint256 length = stringBytes.length;\n', '        bytes32[] memory result = new bytes32[](length % 32 == 0 ? length / 32 : length / 32 + 1);\n', '        \n', '        bytes32 word;\n', '        uint256 index = 0;\n', '        uint256 limit = 0;\n', '        for (uint256 i = 0; i < length; i += 32) {\n', '            limit = i + 32;\n', '            assembly {\n', '                word := mload(add(source, limit))\n', '            }\n', '            namesData[_start + index++] = word;\n', '        }\n', '        return result.length;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner{\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC721Interface {\n', '    // Required methods\n', '    // function totalSupply() public view returns (uint256 total);\n', '    // function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    // function approve(address _to, uint256 _tokenId) external;\n', '    // function transfer(address _to, uint256 _tokenId) external;\n', '    // function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '}\n', '\n', '/** \n', ' * @dev Name provider contract\n', ' * Allows saving names and descriptons for specified addresses and tokens\n', ' */\n', 'contract NameProvider is Ownable {\n', '    \n', '    uint256 public FEE = 1 finney;\n', '    \n', '    //name storage for addresses\n', '    mapping(bytes32 => mapping(address => string)) addressNames;\n', '    \n', '    //marks namespaces as already used on first name save to specified namespace\n', '    mapping(bytes32 => bool) takenNamespaces;\n', '    \n', '    //name storage for tokens\n', '    mapping(address => mapping(uint256 => string)) tokenNames;\n', '    \n', '    //description storage for tokens\n', '    mapping(address => mapping(uint256 => string)) tokenDescriptions;\n', '    \n', '    /* EVENTS */\n', '    \n', '    event NameChanged(bytes32 namespace, address account, string name);\n', '    \n', '    event TokenNameChanged(address tokenProvider, uint256 tokenId, string name);\n', '    \n', '    event TokenDescriptionChanged(address tokenProvider, uint256 tokenId, string description);\n', '    \n', '    function NameProvider(address _owner) public {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '    }\n', '    \n', '    modifier setTokenText(address _tokenInterface, uint256 _tokenId, string _text){\n', '        //check fee\n', '        require(msg.value >= FEE);\n', '        //no empty strings allowed\n', '        require(bytes(_text).length > 0);\n', '        \n', '        ERC721Interface tokenInterface = ERC721Interface(_tokenInterface);\n', '        //only token owner can set its name\n', '        require(msg.sender == tokenInterface.ownerOf(_tokenId));\n', '        \n', '        _;//set text code\n', '        \n', '        //return excess\n', '        if (msg.value > FEE) {\n', '            msg.sender.transfer(msg.value - FEE);\n', '        }\n', '    }\n', '    \n', '    //@dev set name for specified token,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose name will be set\n', '    //@param _name string that will be set as new token name\n', '    function setTokenName(address _tokenInterface, uint256 _tokenId, string _name) \n', '    setTokenText(_tokenInterface, _tokenId, _name) external payable {\n', '        _setTokenName(_tokenInterface, _tokenId, _name);\n', '    }\n', '    \n', '    //@dev set description for specified token,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose description will be set\n', '    //@param _description string that will be set as new token description\n', '    function setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description)\n', '    setTokenText(_tokenInterface, _tokenId, _description) external payable {\n', '        _setTokenDescription(_tokenInterface, _tokenId, _description);\n', '    }\n', '    \n', '    //@dev get name of specified token,\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose name will be returned\n', '    function getTokenName(address _tokenInterface, uint256 _tokenId) external view returns(string) {\n', '        return tokenNames[_tokenInterface][_tokenId];\n', '    }\n', '    \n', '    //@dev get description of specified token,\n', '    //@param _tokenInterface ERC721 protocol provider address\n', '    //@param _tokenId id of the token, whose description will be returned\n', '    function getTokenDescription(address _tokenInterface, uint256 _tokenId) external view returns(string) {\n', '        return tokenDescriptions[_tokenInterface][_tokenId];\n', '    }\n', '    \n', '    //@dev set global name for msg.sender,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _name string that will be set as new address name\n', '    function setName(string _name) external payable {\n', '        setServiceName(bytes32(0), _name);\n', '    }\n', '    \n', '    //@dev set name for msg.sender in cpecified namespace,\n', '    // NB msg.sender must be owner of the specified token.\n', '    //@param _namespace bytes32 service identifier\n', '    //@param _name string that will be set as new address name\n', '    function setServiceName(bytes32 _namespace, string memory _name) public payable {\n', '        //check fee\n', '        require(msg.value >= FEE);\n', '        //set name\n', '        _setName(_namespace, _name);\n', '        //return excess\n', '        if (msg.value > FEE) {\n', '            msg.sender.transfer(msg.value - FEE);\n', '        }\n', '    }\n', '    \n', '    //@dev get global name for specified address,\n', '    //@param _address the address for whom name string will be returned\n', '    function getNameByAddress(address _address) external view returns(string) {\n', '        return addressNames[bytes32(0)][_address];\n', '    }\n', '    \n', '    //@dev get global name for msg.sender,\n', '    function getName() external view returns(string) {\n', '        return addressNames[bytes32(0)][msg.sender];\n', '    }\n', '    \n', '    //@dev get name for specified address and namespace,\n', '    //@param _namespace bytes32 service identifier\n', '    //@param _address the address for whom name string will be returned\n', '    function getServiceNameByAddress(bytes32 _namespace, address _address) external view returns(string) {\n', '        return addressNames[_namespace][_address];\n', '    }\n', '    \n', '    //@dev get name for specified namespace and msg.sender,\n', '    //@param _namespace bytes32 service identifier\n', '    function getServiceName(bytes32 _namespace) external view returns(string) {\n', '        return addressNames[_namespace][msg.sender];\n', '    }\n', '    \n', '    //@dev get names for specified addresses in global namespace (bytes32(0))\n', '    //@param _address address[] array of addresses for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \n', '    function getNames(address[] _address) external view returns(bytes32[] namesData, uint256[] nameLength) {\n', '        return getServiceNames(bytes32(0), _address);\n', '\t}\n', '\t\n', '\t//@dev get names for specified tokens \n', '    //@param _tokenIds uint256[] array of ids for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \n', '\tfunction getTokenNames(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        return _getTokenTexts(_tokenInterface, _tokenIds, true);\n', '\t}\n', '\t\n', '\t//@dev get names for specified tokens \n', '    //@param _tokenIds uint256[] array of ids for whom descriptons will be returned\n', '    //@return descriptonData bytes32 \n', '    //@return descriptionLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \n', '\tfunction getTokenDescriptions(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory descriptonData, uint256[] memory descriptionLength) {\n', '        return _getTokenTexts(_tokenInterface, _tokenIds, false);\n', '\t}\n', '\t\n', '\t//@dev get names for specified addresses and namespace\n', '\t//@param _namespace bytes32 namespace identifier\n', '    //@param _address address[] array of addresses for whom names will be returned\n', '    //@return namesData bytes32 \n', '    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \n', '    function getServiceNames(bytes32 _namespace, address[] _address) public view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        uint256 length = _address.length;\n', '        nameLength = new uint256[](length);\n', '        \n', '        bytes memory stringBytes;\n', '        uint256 size = 0;\n', '        uint256 i;\n', '        for (i = 0; i < length; i ++) {\n', '            stringBytes = bytes(addressNames[_namespace][_address[i]]);\n', '            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\n', '        }\n', '        namesData = new bytes32[](size);\n', '        size = 0;\n', '        for (i = 0; i < length; i ++) {\n', '            size += _stringToBytes32(addressNames[_namespace][_address[i]], namesData, size);\n', '        }\n', '    }\n', '    \n', '    function namespaceTaken(bytes32 _namespace) external view returns(bool) {\n', '        return takenNamespaces[_namespace];\n', '    }\n', '    \n', '    function setFee(uint256 _fee) onlyOwner external {\n', '        FEE = _fee;\n', '    }\n', '    \n', '    function withdraw() onlyOwner external {\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function _setName(bytes32 _namespace, string _name) internal {\n', '        addressNames[_namespace][msg.sender] = _name;\n', '        if (!takenNamespaces[_namespace]) {\n', '            takenNamespaces[_namespace] = true;\n', '        }\n', '        NameChanged(_namespace, msg.sender, _name);\n', '    }\n', '    \n', '    function _setTokenName(address _tokenInterface, uint256 _tokenId, string _name) internal {\n', '        tokenNames[_tokenInterface][_tokenId] = _name;\n', '        TokenNameChanged(_tokenInterface, _tokenId, _name);\n', '    }\n', '    \n', '    function _setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description) internal {\n', '        tokenDescriptions[_tokenInterface][_tokenId] = _description;\n', '        TokenDescriptionChanged(_tokenInterface, _tokenId, _description);\n', '    }\n', '    \n', '    function _getTokenTexts(address _tokenInterface, uint256[] memory _tokenIds, bool names) internal view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\n', '        uint256 length = _tokenIds.length;\n', '        nameLength = new uint256[](length);\n', '        mapping(address => mapping(uint256 => string)) textMap = names ? tokenNames : tokenDescriptions;\n', '        \n', '        bytes memory stringBytes;\n', '        uint256 size = 0;\n', '        uint256 i;\n', '        for (i = 0; i < length; i ++) {\n', '            stringBytes = bytes(textMap[_tokenInterface][_tokenIds[i]]);\n', '            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\n', '        }\n', '        namesData = new bytes32[](size);\n', '        size = 0;\n', '        for (i = 0; i < length; i ++) {\n', '            size += _stringToBytes32(textMap[_tokenInterface][_tokenIds[i]], namesData, size);\n', '        }\n', '    }\n', '    \n', '        \n', '    function _stringToBytes32(string memory source, bytes32[] memory namesData, uint256 _start) internal pure returns (uint256) {\n', '        bytes memory stringBytes = bytes(source);\n', '        uint256 length = stringBytes.length;\n', '        bytes32[] memory result = new bytes32[](length % 32 == 0 ? length / 32 : length / 32 + 1);\n', '        \n', '        bytes32 word;\n', '        uint256 index = 0;\n', '        uint256 limit = 0;\n', '        for (uint256 i = 0; i < length; i += 32) {\n', '            limit = i + 32;\n', '            assembly {\n', '                word := mload(add(source, limit))\n', '            }\n', '            namesData[_start + index++] = word;\n', '        }\n', '        return result.length;\n', '    }\n', '}']
