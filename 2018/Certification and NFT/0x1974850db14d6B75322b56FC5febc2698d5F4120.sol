['pragma solidity ^0.4.24;\n', '/** @title -MSFun- v0.2.4\n', ' * ┌┬┐┌─┐┌─┐┌┬┐   ╦╦ ╦╔═╗╔╦╗  ┌─┐┬─┐┌─┐┌─┐┌─┐┌┐┌┌┬┐┌─┐\n', ' *  │ ├┤ ├─┤│││   ║║ ║╚═╗ ║   ├─┘├┬┘├┤ └─┐├┤ │││ │ └─┐\n', ' *  ┴ └─┘┴ ┴┴ ┴  ╚╝╚═╝╚═╝ ╩   ┴  ┴└─└─┘└─┘└─┘┘└┘ ┴ └─┘\n', ' *                                  _____                      _____\n', ' *                                 (, /     /)       /) /)    (, /      /)          /)\n', ' *          ┌─┐                      /   _ (/_      // //       /  _   // _   __  _(/\n', ' *          ├─┤                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_\n', ' *          ┴ ┴                /   /          .-/ _____   (__ /                               \n', ' *                            (__ /          (_/ (, /                                      /)™ \n', ' *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/\n', ' * ┌─┐┬─┐┌─┐┌┬┐┬ ┬┌─┐┌┬┐                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_\n', ' * ├─┘├┬┘│ │ │││ ││   │                      (__ /              .-/  &#169; Jekyll Island Inc. 2018\n', ' * ┴  ┴└─└─┘─┴┘└─┘└─┘ ┴                                        (_/\n', ' *  _           _             _  _  _  _             _  _  _  _  _                                      \n', ' *=(_) _     _ (_)==========_(_)(_)(_)(_)_==========(_)(_)(_)(_)(_)================================*\n', ' * (_)(_)   (_)(_)         (_)          (_)         (_)       _         _    _  _  _  _                 \n', ' * (_) (_)_(_) (_)         (_)_  _  _  _            (_) _  _ (_)       (_)  (_)(_)(_)(_)_               \n', ' * (_)   (_)   (_)           (_)(_)(_)(_)_          (_)(_)(_)(_)       (_)  (_)        (_)              \n', ' * (_)         (_)  _  _    _           (_)  _  _   (_)      (_)       (_)  (_)        (_)  _  _        \n', ' *=(_)=========(_)=(_)(_)==(_)_  _  _  _(_)=(_)(_)==(_)======(_)_  _  _(_)_ (_)========(_)=(_)(_)==*\n', ' * (_)         (_) (_)(_)    (_)(_)(_)(_)   (_)(_)  (_)        (_)(_)(_) (_)(_)        (_) (_)(_)\n', ' *\n', ' * ╔═╗┌─┐┌┐┌┌┬┐┬─┐┌─┐┌─┐┌┬┐  ╔═╗┌─┐┌┬┐┌─┐ ┌──────────┐\n', ' * ║  │ ││││ │ ├┬┘├─┤│   │   ║  │ │ ││├┤  │ Inventor │\n', ' * ╚═╝└─┘┘└┘ ┴ ┴└─┴ ┴└─┘ ┴   ╚═╝└─┘─┴┘└─┘ └──────────┘\n', ' *  \n', ' *         ┌──────────────────────────────────────────────────────────────────────┐\n', ' *         │ MSFun, is an importable library that gives your contract the ability │\n', ' *         │ add multiSig requirement to functions.                               │\n', ' *         └──────────────────────────────────────────────────────────────────────┘\n', ' *                                ┌────────────────────┐\n', ' *                                │ Setup Instructions │\n', ' *                                └────────────────────┘\n', ' * (Step 1) import the library into your contract\n', ' * \n', ' *    import "./MSFun.sol";\n', ' *\n', ' * (Step 2) set up the signature data for msFun\n', ' * \n', ' *     MSFun.Data private msData;\n', ' *                                ┌────────────────────┐\n', ' *                                │ Usage Instructions │\n', ' *                                └────────────────────┘\n', ' * at the beginning of a function\n', ' * \n', ' *     function functionName() \n', ' *     {\n', ' *         if (MSFun.multiSig(msData, required signatures, "functionName") == true)\n', ' *         {\n', ' *             MSFun.deleteProposal(msData, "functionName");\n', ' * \n', ' *             // put function body here \n', ' *         }\n', ' *     }\n', ' *                           ┌────────────────────────────────┐\n', ' *                           │ Optional Wrappers For TeamJust │\n', ' *                           └────────────────────────────────┘\n', ' * multiSig wrapper function (cuts down on inputs, improves readability)\n', ' * this wrapper is HIGHLY recommended\n', ' * \n', ' *     function multiSig(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredSignatures(), _whatFunction));}\n', ' *     function multiSigDev(bytes32 _whatFunction) private returns (bool) {return(MSFun.multiSig(msData, TeamJust.requiredDevSignatures(), _whatFunction));}\n', ' *\n', ' * wrapper for delete proposal (makes code cleaner)\n', ' *     \n', ' *     function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\n', ' *                             ┌────────────────────────────┐\n', ' *                             │ Utility & Vanity Functions │\n', ' *                             └────────────────────────────┘\n', ' * delete any proposal is highly recommended.  without it, if an admin calls a multiSig\n', ' * function, with argument inputs that the other admins do not agree upon, the function\n', ' * can never be executed until the undesirable arguments are approved.\n', ' * \n', ' *     function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\n', ' * \n', ' * for viewing who has signed a proposal & proposal data\n', ' *     \n', ' *     function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32, uint256) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\n', ' *\n', ' * lets you check address of up to 3 signers (address)\n', ' * \n', ' *     function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(address, address, address) {return(MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\n', ' *\n', ' * same as above but will return names in string format.\n', ' *\n', ' *     function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJust.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\n', ' *                             ┌──────────────────────────┐\n', ' *                             │ Functions In Depth Guide │\n', ' *                             └──────────────────────────┘\n', ' * In the following examples, the Data is the proposal set for this library.  And\n', ' * the bytes32 is the name of the function.\n', ' *\n', ' * MSFun.multiSig(Data, uint256, bytes32) - Manages creating/updating multiSig \n', ' *      proposal for the function being called.  The uint256 is the required \n', ' *      number of signatures needed before the multiSig will return true.  \n', ' *      Upon first call, multiSig will create a proposal and store the arguments \n', ' *      passed with the function call as msgData.  Any admins trying to sign the \n', ' *      function call will need to send the same argument values. Once required\n', ' *      number of signatures is reached this will return a bool of true.\n', ' * \n', ' * MSFun.deleteProposal(Data, bytes32) - once multiSig unlocks the function body,\n', ' *      you will want to delete the proposal data.  This does that.\n', ' *\n', ' * MSFun.checkMsgData(Data, bytes32) - checks the message data for any given proposal \n', ' * \n', ' * MSFun.checkCount(Data, bytes32) - checks the number of admins that have signed\n', ' *      the proposal \n', ' * \n', ' * MSFun.checkSigners(data, bytes32, uint256) - checks the address of a given signer.\n', ' *      the uint256, is the log number of the signer (ie 1st signer, 2nd signer)\n', ' */\n', '\n', 'library MSFun {\n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // DATA SETS\n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // contact data setup\n', '    struct Data \n', '    {\n', '        mapping (bytes32 => ProposalData) proposal_;\n', '    }\n', '    struct ProposalData \n', '    {\n', '        // a hash of msg.data \n', '        bytes32 msgData;\n', '        // number of signers\n', '        uint256 count;\n', '        // tracking of wither admins have signed\n', '        mapping (address => bool) admin;\n', '        // list of admins who have signed\n', '        mapping (uint256 => address) log;\n', '    }\n', '    \n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // MULTI SIG FUNCTIONS\n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    function multiSig(Data storage self, uint256 _requiredSignatures, bytes32 _whatFunction)\n', '        internal\n', '        returns(bool) \n', '    {\n', '        // our proposal key will be a hash of our function name + our contracts address \n', '        // by adding our contracts address to this, we prevent anyone trying to circumvent\n', '        // the proposal&#39;s security via external calls.\n', '        bytes32 _whatProposal = whatProposal(_whatFunction);\n', '        \n', '        // this is just done to make the code more readable.  grabs the signature count\n', '        uint256 _currentCount = self.proposal_[_whatProposal].count;\n', '        \n', '        // store the address of the person sending the function call.  we use msg.sender \n', '        // here as a layer of security.  in case someone imports our contract and tries to \n', '        // circumvent function arguments.  still though, our contract that imports this\n', '        // library and calls multisig, needs to use onlyAdmin modifiers or anyone who\n', '        // calls the function will be a signer. \n', '        address _whichAdmin = msg.sender;\n', '        \n', '        // prepare our msg data.  by storing this we are able to verify that all admins\n', '        // are approving the same argument input to be executed for the function.  we hash \n', '        // it and store in bytes32 so its size is known and comparable\n', '        bytes32 _msgData = keccak256(msg.data);\n', '        \n', '        // check to see if this is a new execution of this proposal or not\n', '        if (_currentCount == 0)\n', '        {\n', '            // if it is, lets record the original signers data\n', '            self.proposal_[_whatProposal].msgData = _msgData;\n', '            \n', '            // record original senders signature\n', '            self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \n', '            \n', '            // update log (used to delete records later, and easy way to view signers)\n', '            // also useful if the calling function wants to give something to a \n', '            // specific signer.  \n', '            self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \n', '            \n', '            // track number of signatures\n', '            self.proposal_[_whatProposal].count += 1;  \n', '            \n', '            // if we now have enough signatures to execute the function, lets\n', '            // return a bool of true.  we put this here in case the required signatures\n', '            // is set to 1.\n', '            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\n', '                return(true);\n', '            }            \n', '        // if its not the first execution, lets make sure the msgData matches\n', '        } else if (self.proposal_[_whatProposal].msgData == _msgData) {\n', '            // msgData is a match\n', '            // make sure admin hasnt already signed\n', '            if (self.proposal_[_whatProposal].admin[_whichAdmin] == false) \n', '            {\n', '                // record their signature\n', '                self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \n', '                \n', '                // update log (used to delete records later, and easy way to view signers)\n', '                self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \n', '                \n', '                // track number of signatures\n', '                self.proposal_[_whatProposal].count += 1;  \n', '            }\n', '            \n', '            // if we now have enough signatures to execute the function, lets\n', '            // return a bool of true.\n', '            // we put this here for a few reasons.  (1) in normal operation, if \n', '            // that last recorded signature got us to our required signatures.  we \n', '            // need to return bool of true.  (2) if we have a situation where the \n', '            // required number of signatures was adjusted to at or lower than our current \n', '            // signature count, by putting this here, an admin who has already signed,\n', '            // can call the function again to make it return a true bool.  but only if\n', '            // they submit the correct msg data\n', '            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\n', '                return(true);\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    // deletes proposal signature data after successfully executing a multiSig function\n', '    function deleteProposal(Data storage self, bytes32 _whatFunction)\n', '        internal\n', '    {\n', '        //done for readability sake\n', '        bytes32 _whatProposal = whatProposal(_whatFunction);\n', '        address _whichAdmin;\n', '        \n', '        //delete the admins votes & log.   i know for loops are terrible.  but we have to do this \n', '        //for our data stored in mappings.  simply deleting the proposal itself wouldn&#39;t accomplish this.\n', '        for (uint256 i=0; i < self.proposal_[_whatProposal].count; i++) {\n', '            _whichAdmin = self.proposal_[_whatProposal].log[i];\n', '            delete self.proposal_[_whatProposal].admin[_whichAdmin];\n', '            delete self.proposal_[_whatProposal].log[i];\n', '        }\n', '        //delete the rest of the data in the record\n', '        delete self.proposal_[_whatProposal];\n', '    }\n', '    \n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // HELPER FUNCTIONS\n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '\n', '    function whatProposal(bytes32 _whatFunction)\n', '        private\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return(keccak256(abi.encodePacked(_whatFunction,this)));\n', '    }\n', '    \n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // VANITY FUNCTIONS\n', '    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', '    // returns a hashed version of msg.data sent by original signer for any given function\n', '    function checkMsgData (Data storage self, bytes32 _whatFunction)\n', '        internal\n', '        view\n', '        returns (bytes32 msg_data)\n', '    {\n', '        bytes32 _whatProposal = whatProposal(_whatFunction);\n', '        return (self.proposal_[_whatProposal].msgData);\n', '    }\n', '    \n', '    // returns number of signers for any given function\n', '    function checkCount (Data storage self, bytes32 _whatFunction)\n', '        internal\n', '        view\n', '        returns (uint256 signature_count)\n', '    {\n', '        bytes32 _whatProposal = whatProposal(_whatFunction);\n', '        return (self.proposal_[_whatProposal].count);\n', '    }\n', '    \n', '    // returns address of an admin who signed for any given function\n', '    function checkSigner (Data storage self, bytes32 _whatFunction, uint256 _signer)\n', '        internal\n', '        view\n', '        returns (address signer)\n', '    {\n', '        require(_signer > 0, "MSFun checkSigner failed - 0 not allowed");\n', '        bytes32 _whatProposal = whatProposal(_whatFunction);\n', '        return (self.proposal_[_whatProposal].log[_signer - 1]);\n', '    }\n', '}']