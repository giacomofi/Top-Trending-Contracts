['pragma solidity ^0.4.15;\n', '\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() internal {\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public constant returns (address) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract YooStop is Owned{\n', '\n', '    bool public stopped = false;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public ownerOnly{\n', '        stopped = true;\n', '    }\n', '    function start() public ownerOnly{\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract YoobaEarlyInvest is  Owned,YooStop,Utils {\n', '    IERC20Token public yoobaTokenAddress;\n', '\n', '\n', '    /**\n', '        @dev constructor\n', '        \n', '    */\n', '    function YoobaEarlyInvest(IERC20Token _yoobaTokenAddress) public{\n', '        yoobaTokenAddress = _yoobaTokenAddress;\n', '    }\n', '    \n', '\n', '    \n', '    function withdrawTo(address _to, uint256 _amount)\n', '        public ownerOnly stoppable\n', '        notThis(_to)\n', '    {   \n', '        require(_amount <= this.balance);\n', '        _to.transfer(_amount); // send the amount to the target account\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '\n', '    }\n', '    \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && msg.value >= 0.1 ether);\n', '        uint256  amount = msg.value * 350000;\n', '        assert(yoobaTokenAddress.transfer(msg.sender, amount));\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() internal {\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public constant returns (address) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract YooStop is Owned{\n', '\n', '    bool public stopped = false;\n', '\n', '    modifier stoppable {\n', '        assert (!stopped);\n', '        _;\n', '    }\n', '    function stop() public ownerOnly{\n', '        stopped = true;\n', '    }\n', '    function start() public ownerOnly{\n', '        stopped = false;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract YoobaEarlyInvest is  Owned,YooStop,Utils {\n', '    IERC20Token public yoobaTokenAddress;\n', '\n', '\n', '    /**\n', '        @dev constructor\n', '        \n', '    */\n', '    function YoobaEarlyInvest(IERC20Token _yoobaTokenAddress) public{\n', '        yoobaTokenAddress = _yoobaTokenAddress;\n', '    }\n', '    \n', '\n', '    \n', '    function withdrawTo(address _to, uint256 _amount)\n', '        public ownerOnly stoppable\n', '        notThis(_to)\n', '    {   \n', '        require(_amount <= this.balance);\n', '        _to.transfer(_amount); // send the amount to the target account\n', '    }\n', '    \n', '    function withdrawERC20TokenTo(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '\n', '    }\n', '    \n', '    function buyToken() internal\n', '    {\n', '        require(!stopped && msg.value >= 0.1 ether);\n', '        uint256  amount = msg.value * 350000;\n', '        assert(yoobaTokenAddress.transfer(msg.sender, amount));\n', '    }\n', '\n', '    function() public payable stoppable {\n', '        buyToken();\n', '    }\n', '}']
