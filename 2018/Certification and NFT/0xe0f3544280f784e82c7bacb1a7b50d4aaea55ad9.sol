['pragma solidity ^0.4.21;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function toWei(uint256 a) internal pure returns (uint256){\n', '    assert(a>0);\n', '    return a * 10 ** 18;\n', '  }\n', '}\n', '\n', 'interface tokenRecipient { \n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; \n', '}\n', '\n', 'contract TokenERC20 is SafeMath{\n', '\n', '    // Token information\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply * 10 ** uint256(decimals);\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(safeAdd(balanceOf[_to], _value) > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = safeAdd(balanceOf[_from],balanceOf[_to]);\n', '        // Subtract from the sender\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(safeAdd(balanceOf[_from],balanceOf[_to]) == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '      \n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);            // Subtract from the sender\n', '        totalSupply = safeSub(totalSupply,_value);                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);             // Subtract from the sender&#39;s allowance\n', '        totalSupply = safeSub(totalSupply,_value);                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/******************************************/\n', '/*          GAMEREWARD TOKEN              */\n', '/******************************************/\n', '\n', 'contract GameRewardToken is owned, TokenERC20 {\n', '\n', '    // State machine\n', '    enum State{PrivateFunding, PreFunding, Funding, Success, Failure}\n', '\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '    mapping (address => uint256) public bounties;\n', '    mapping (address => uint256) public bonus;\n', '    mapping (address => address) public referrals;\n', '    mapping (address => uint256) public investors;\n', '    mapping (address => uint256) public funders;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address indexed target, bool frozen);\n', '    event FundTransfer(address indexed to, uint256 eth , uint256 value, uint block);\n', '    event Fee(address indexed from, address indexed collector, uint256 fee);\n', '    event FreeDistribution(address indexed to, uint256 value, uint block);\n', '    event Refund(address indexed to, uint256 value, uint block);\n', '    event BonusTransfer(address indexed to, uint256 value, uint block);\n', '    event BountyTransfer(address indexed to, uint256 value, uint block);\n', '    event SetReferral(address indexed target, address indexed broker);\n', '    event ChangeCampaign(uint256 fundingStartBlock, uint256 fundingEndBlock);\n', '    event AddBounty(address indexed bountyHunter, uint256 value);\n', '    event ReferralBonus(address indexed investor, address indexed broker, uint256 value);\n', '\n', '     // Crowdsale information\n', '    bool public finalizedCrowdfunding = false;\n', '\n', '    uint256 public fundingStartBlock = 0; // crowdsale start block\n', '    uint256 public fundingEndBlock = 0;   // crowdsale end block\n', '    uint256 public constant lockedTokens =                250000000*10**18; //25% tokens to Vault and locked for 6 months - 250 millions\n', '    uint256 public bonusAndBountyTokens =                  50000000*10**18; //5% tokens for referral bonus and bounty - 50 millions\n', '    uint256 public constant devsTokens =                  100000000*10**18; //10% tokens for team - 100 millions\n', '    uint256 public constant hundredPercent =                           100;\n', '    uint256 public constant tokensPerEther =                         20000; //GRD:ETH exchange rate - 20.000 GRD per ETH\n', '    uint256 public constant tokenCreationMax =            600000000*10**18; //ICO hard target - 600 millions\n', '    uint256 public constant tokenCreationMin =             60000000*10**18; //ICO soft target - 60 millions\n', '\n', '    uint256 public constant tokenPrivateMax =             100000000*10**18; //Private-sale must stop when 100 millions tokens sold\n', '\n', '    uint256 public constant minContributionAmount =             0.1*10**18; //Investor must buy atleast 0.1ETH in open-sale\n', '    uint256 public constant maxContributionAmount =             100*10**18; //Max 100 ETH in open-sale and pre-sale\n', '\n', '    uint256 public constant minPrivateContribution =              5*10**18; //Investor must buy atleast 5ETH in private-sale\n', '    uint256 public constant minPreContribution =                  1*10**18; //Investor must buy atleast 1ETH in pre-sale\n', '\n', '    uint256 public constant minAmountToGetBonus =                 1*10**18; //Investor must buy atleast 1ETH to receive referral bonus\n', '    uint256 public constant referralBonus =                              5; //5% for referral bonus\n', '    uint256 public constant privateBonus =                              40; //40% bonus in private-sale\n', '    uint256 public constant preBonus =                                  20; //20% bonus in pre-sale;\n', '\n', '    uint256 public tokensSold;\n', '    uint256 public collectedETH;\n', '\n', '    uint256 public constant numBlocksLocked = 1110857;  //180 days locked vault tokens\n', '    bool public releasedBountyTokens = false; //bounty release status\n', '    uint256 public unlockedAtBlockNumber;\n', '\n', '    address public lockedTokenHolder;\n', '    address public releaseTokenHolder;\n', '    address public devsHolder;\n', '    address public multiSigWalletAddress;\n', '\n', '\n', '    constructor(address _lockedTokenHolder,\n', '                address _releaseTokenHolder,\n', '                address _devsAddress,\n', '                address _multiSigWalletAddress\n', '    ) TokenERC20("GameReward", // Name\n', '                 "GRD",        // Symbol \n', '                  18,          // Decimals\n', '                  1000000000   // Total Supply 1 Billion\n', '                  ) public {\n', '        \n', '        require (_lockedTokenHolder != 0x0);\n', '        require (_releaseTokenHolder != 0x0);\n', '        require (_devsAddress != 0x0);\n', '        require (_multiSigWalletAddress != 0x0);\n', '        lockedTokenHolder = _lockedTokenHolder;\n', '        releaseTokenHolder = _releaseTokenHolder;\n', '        devsHolder = _devsAddress;\n', '        multiSigWalletAddress = _multiSigWalletAddress;\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (getState() == State.Success);\n', '        require (_to != 0x0);                                      // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);                      // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (safeAdd(balanceOf[_to],_value) > balanceOf[_to]); // Check for overflows\n', '        require (!frozenAccount[_from]);                           // Check if sender is frozen\n', '        require (!frozenAccount[_to]);                             // Check if recipient is frozen\n', '        require (_from != lockedTokenHolder);\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);       // Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);           // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    ///@notice change token&#39;s name and symbol\n', '    function updateNameAndSymbol(string _newname, string _newsymbol) onlyOwner public{\n', '      name = _newname;\n', '      symbol = _newsymbol;\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param _target Address to be frozen\n', '    /// @param _freeze either to freeze it or not\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        frozenAccount[_target] = _freeze;\n', '        emit FrozenFunds(_target, _freeze);\n', '    }\n', '\n', '    function setMultiSigWallet(address newWallet) external {\n', '        require (msg.sender == multiSigWalletAddress);\n', '        multiSigWalletAddress = newWallet;\n', '    }\n', '\n', '    //Crowdsale Functions\n', '\n', '    /// @notice get early bonus for Investor\n', '    function _getEarlyBonus() internal view returns(uint){\n', '        if(getState()==State.PrivateFunding) return privateBonus;  \n', '        else if(getState()==State.PreFunding) return preBonus; \n', '        else return 0;\n', '    }\n', '\n', '    /// @notice set start and end block for funding\n', '    /// @param _fundingStartBlock start funding\n', '    /// @param _fundingEndBlock  end funding\n', '    function setCampaign(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner public{\n', '        if(block.number < _fundingStartBlock){\n', '            fundingStartBlock = _fundingStartBlock;\n', '        }\n', '        if(_fundingEndBlock > fundingStartBlock && _fundingEndBlock > block.number){\n', '            fundingEndBlock = _fundingEndBlock;\n', '        }\n', '        emit ChangeCampaign(_fundingStartBlock,_fundingEndBlock);\n', '    }\n', '\n', '    function releaseBountyTokens() onlyOwner public{\n', '      require(!releasedBountyTokens);\n', '      require(getState()==State.Success);\n', '      releasedBountyTokens = true;\n', '    }\n', '\n', '\n', '    /// @notice set Broker for Investor\n', '    /// @param _target address of Investor\n', '    /// @param _broker address of Broker\n', '    function setReferral(address _target, address _broker, uint256 _amount) onlyOwner public {\n', '        require (_target != 0x0);\n', '        require (_broker != 0x0);\n', '        referrals[_target] = _broker;\n', '        emit SetReferral(_target, _broker);\n', '        if(_amount>0x0){\n', '            uint256 brokerBonus = safeDiv(safeMul(_amount,referralBonus),hundredPercent);\n', '            bonus[_broker] = safeAdd(bonus[_broker],brokerBonus);\n', '            emit ReferralBonus(_target,_broker,brokerBonus);\n', '        }\n', '    }\n', '\n', '    /// @notice set token for bounty hunter to release when ICO success\n', '    function addBounty(address _hunter, uint256 _amount) onlyOwner public{\n', '        require(_hunter!=0x0);\n', '        require(toWei(_amount)<=safeSub(bonusAndBountyTokens,toWei(_amount)));\n', '        bounties[_hunter] = safeAdd(bounties[_hunter],toWei(_amount));\n', '        bonusAndBountyTokens = safeSub(bonusAndBountyTokens,toWei(_amount));\n', '        emit AddBounty(_hunter, toWei(_amount));\n', '    }\n', '\n', '    /// @notice Create tokens when funding is active. This fallback function require 90.000 gas or more\n', '    /// @dev Required state: Funding\n', '    /// @dev State transition: -> Funding Success (only if cap reached)\n', '    function() payable public{\n', '        // Abort if not in Funding Active state.\n', '        // Do not allow creating 0 or more than the cap tokens.\n', '        require (getState() != State.Success);\n', '        require (getState() != State.Failure);\n', '        require (msg.value != 0);\n', '\n', '        if(getState()==State.PrivateFunding){\n', '            require(msg.value>=minPrivateContribution);\n', '        }else if(getState()==State.PreFunding){\n', '            require(msg.value>=minPreContribution && msg.value < maxContributionAmount);\n', '        }else{\n', '            require(msg.value>=minContributionAmount && msg.value < maxContributionAmount);\n', '        }\n', '\n', '        // multiply by exchange rate to get newly created token amount\n', '        uint256 createdTokens = safeMul(msg.value, tokensPerEther);\n', '        uint256 brokerBonus = 0;\n', '        uint256 earlyBonus = safeDiv(safeMul(createdTokens,_getEarlyBonus()),hundredPercent);\n', '\n', '        createdTokens = safeAdd(createdTokens,earlyBonus);\n', '\n', '        // don&#39;t go over the limit!\n', '        if(getState()==State.PrivateFunding){\n', '            require(safeAdd(tokensSold,createdTokens) <= tokenPrivateMax);\n', '        }else{\n', '            require (safeAdd(tokensSold,createdTokens) <= tokenCreationMax);\n', '        }\n', '\n', '        // we are creating tokens, so increase the tokenSold\n', '        tokensSold = safeAdd(tokensSold, createdTokens);\n', '        collectedETH = safeAdd(collectedETH,msg.value);\n', '        \n', '        // add bonus if has referral\n', '        if(referrals[msg.sender]!= 0x0){\n', '            brokerBonus = safeDiv(safeMul(createdTokens,referralBonus),hundredPercent);\n', '            bonus[referrals[msg.sender]] = safeAdd(bonus[referrals[msg.sender]],brokerBonus);\n', '            emit ReferralBonus(msg.sender,referrals[msg.sender],brokerBonus);\n', '        }\n', '\n', '        // Save funder info for refund and free distribution\n', '        funders[msg.sender] = safeAdd(funders[msg.sender],msg.value);\n', '        investors[msg.sender] = safeAdd(investors[msg.sender],createdTokens);\n', '\n', '        // Assign new tokens to the sender\n', '        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], createdTokens);\n', '        // Log token creation event\n', '        emit FundTransfer(msg.sender,msg.value, createdTokens, block.number);\n', '        emit Transfer(0, msg.sender, createdTokens);\n', '    }\n', '\n', '    /// @notice send bonus token to broker\n', '    function requestBonus() external{\n', '      require(getState()==State.Success);\n', '      uint256 bonusAmount = bonus[msg.sender];\n', '      assert(bonusAmount>0);\n', '      require(bonusAmount<=safeSub(bonusAndBountyTokens,bonusAmount));\n', '      balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],bonusAmount);\n', '      bonus[msg.sender] = 0;\n', '      bonusAndBountyTokens = safeSub(bonusAndBountyTokens,bonusAmount);\n', '      emit BonusTransfer(msg.sender,bonusAmount,block.number);\n', '      emit Transfer(0,msg.sender,bonusAmount);\n', '    }\n', '\n', '    /// @notice send lockedTokens to devs address\n', '    /// require State == Success\n', '    /// require tokens unlocked\n', '    function releaseLockedToken() external {\n', '        require (getState() == State.Success);\n', '        require (balanceOf[lockedTokenHolder] > 0x0);\n', '        require (block.number >= unlockedAtBlockNumber);\n', '        balanceOf[devsHolder] = safeAdd(balanceOf[devsHolder],balanceOf[lockedTokenHolder]);\n', '        emit Transfer(lockedTokenHolder,devsHolder,balanceOf[lockedTokenHolder]);\n', '        balanceOf[lockedTokenHolder] = 0;\n', '    }\n', '    \n', '    /// @notice request to receive bounty tokens\n', '    /// @dev require State == Succes\n', '    function requestBounty() external{\n', '        require(releasedBountyTokens); //locked bounty hunter&#39;s token for 7 days after end of campaign\n', '        require(getState()==State.Success);\n', '        assert (bounties[msg.sender]>0);\n', '        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],bounties[msg.sender]);\n', '        emit BountyTransfer(msg.sender,bounties[msg.sender],block.number);\n', '        emit Transfer(0,msg.sender,bounties[msg.sender]);\n', '        bounties[msg.sender] = 0;\n', '    }\n', '\n', '    /// @notice Finalize crowdfunding\n', '    /// @dev If cap was reached or crowdfunding has ended then:\n', '    /// create GRD for the Vault and developer,\n', '    /// transfer ETH to the devs address.\n', '    /// @dev Required state: Success\n', '    function finalizeCrowdfunding() external {\n', '        // Abort if not in Funding Success state.\n', '        require (getState() == State.Success); // don&#39;t finalize unless we won\n', '        require (!finalizedCrowdfunding); // can&#39;t finalize twice (so sneaky!)\n', '\n', '        // prevent more creation of tokens\n', '        finalizedCrowdfunding = true;\n', '        // Endowment: 25% of total goes to vault, timelocked for 6 months\n', '        balanceOf[lockedTokenHolder] = safeAdd(balanceOf[lockedTokenHolder], lockedTokens);\n', '\n', '        // Transfer lockedTokens to lockedTokenHolder address\n', '        unlockedAtBlockNumber = block.number + numBlocksLocked;\n', '        emit Transfer(0, lockedTokenHolder, lockedTokens);\n', '\n', '        // Endowment: 10% of total goes to devs\n', '        balanceOf[devsHolder] = safeAdd(balanceOf[devsHolder], devsTokens);\n', '        emit Transfer(0, devsHolder, devsTokens);\n', '\n', '        // Transfer ETH to the multiSigWalletAddress address.\n', '        multiSigWalletAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @notice send @param _unSoldTokens to all Investor base on their share\n', '    function requestFreeDistribution() external{\n', '      require(getState()==State.Success);\n', '      assert(investors[msg.sender]>0);\n', '      uint256 unSoldTokens = safeSub(tokenCreationMax,tokensSold);\n', '      require(unSoldTokens>0);\n', '      uint256 freeTokens = safeDiv(safeMul(unSoldTokens,investors[msg.sender]),tokensSold);\n', '      balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],freeTokens);\n', '      investors[msg.sender] = 0;\n', '      emit FreeDistribution(msg.sender,freeTokens,block.number);\n', '      emit Transfer(0,msg.sender, freeTokens);\n', '\n', '    }\n', '\n', '    /// @notice Get back the ether sent during the funding in case the funding\n', '    /// has not reached the soft cap.\n', '    /// @dev Required state: Failure\n', '    function requestRefund() external {\n', '        // Abort if not in Funding Failure state.\n', '        assert (getState() == State.Failure);\n', '        assert (funders[msg.sender]>0);\n', '        msg.sender.transfer(funders[msg.sender]);  \n', '        emit Refund( msg.sender, funders[msg.sender],block.number);\n', '        funders[msg.sender]=0;\n', '    }\n', '\n', '    /// @notice This manages the crowdfunding state machine\n', '    /// We make it a function and do not assign the result to a variable\n', '    /// So there is no chance of the variable being stale\n', '    function getState() public constant returns (State){\n', '      // once we reach success, lock in the state\n', '      if (finalizedCrowdfunding) return State.Success;\n', '      if(fundingStartBlock ==0 && fundingEndBlock==0) return State.PrivateFunding;\n', '      else if (block.number < fundingStartBlock) return State.PreFunding;\n', '      else if (block.number <= fundingEndBlock && tokensSold < tokenCreationMax) return State.Funding;\n', '      else if (tokensSold >= tokenCreationMin) return State.Success;\n', '      else return State.Failure;\n', '    }\n', '}']