['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Sales{\n', '\n', '\tenum ICOSaleState{\n', '\t\tPrivateSale,\n', '\t    PreSale,\n', '\t    PublicSale,\n', '\t    Success,\n', '\t    Failed\n', '\t }\n', '}\n', '\n', 'contract Utils{\n', '\n', '\t//verifies the amount greater than zero\n', '\n', '\tmodifier greaterThanZero(uint256 _value){\n', '\t\trequire(_value>0);\n', '\t\t_;\n', '\t}\n', '\n', '\t///verifies an address\n', '\n', '\tmodifier validAddress(address _add){\n', '\t\trequire(_add!=0x0);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract GACToken is Token,Ownable,Sales {\n', '    string public constant name = "Gladage Care Token";\n', '    string public constant symbol = "GAC";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '    uint public valueToBeSent = 1;\n', '\n', '    bool public finalizedICO = false;\n', '\n', '    uint256 public ethraised;\n', '    uint256 public btcraised;\n', '    uint256 public usdraised;\n', '\n', '    bool public istransferAllowed;\n', '\n', '    uint256 public constant GACFund = 5 * (10**8) * 10**decimals; \n', '    uint256 public fundingStartBlock; // crowdsale start unix //now\n', '    uint256 public fundingEndBlock; // crowdsale end unix //1530403200 //07/01/2018 @ 12:00am (UTC)\n', '    uint256 public tokenCreationMax= 275 * (10**6) * 10**decimals;//TODO\n', '    mapping (address => bool) ownership;\n', '    uint256 public minCapUSD = 2000000;\n', '    uint256 public maxCapUSD = 20000000;\n', '\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '      if(!istransferAllowed) throw;\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function burnTokens(uint256 _value) public{\n', '        require(balances[msg.sender]>=_value);\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);\n', '        totalSupply =SafeMath.sub(totalSupply,_value);\n', '    }\n', '\n', '\n', '    //this is the default constructor\n', '    function GACToken(uint256 _fundingStartBlock, uint256 _fundingEndBlock){\n', '        totalSupply = GACFund;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '    }\n', '\n', '    ///change the funding end block\n', '    function changeEndBlock(uint256 _newFundingEndBlock) onlyOwner{\n', '        fundingEndBlock = _newFundingEndBlock;\n', '    }\n', '\n', '    ///change the funding start block\n', '    function changeStartBlock(uint256 _newFundingStartBlock) onlyOwner{\n', '        fundingStartBlock = _newFundingStartBlock;\n', '    }\n', '\n', '    ///the Min Cap USD \n', '    ///function too chage the miin cap usd\n', '    function changeMinCapUSD(uint256 _newMinCap) onlyOwner{\n', '        minCapUSD = _newMinCap;\n', '    }\n', '\n', '    ///fucntion to change the max cap usd\n', '    function changeMaxCapUSD(uint256 _newMaxCap) onlyOwner{\n', '        maxCapUSD = _newMaxCap;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '      if(!istransferAllowed) throw;\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '\n', '    function addToBalances(address _person,uint256 value) {\n', '        if(!ownership[msg.sender]) throw;\n', '        balances[_person] = SafeMath.add(balances[_person],value);\n', '        Transfer(address(this), _person, value);\n', '    }\n', '\n', '    function addToOwnership(address owners) onlyOwner{\n', '        ownership[owners] = true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseEthRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        ethraised+=value;\n', '    }\n', '\n', '    function increaseBTCRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        btcraised+=value;\n', '    }\n', '\n', '    function increaseUSDRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        usdraised+=value;\n', '    }\n', '\n', '    function finalizeICO(){\n', '        if(!ownership[msg.sender]) throw;\n', '        ///replace the below amount of 10000 with the min cap usd value\n', '        ///havent recieved the valus yet :(\n', '        if(usdraised<minCapUSD) throw;\n', '        finalizedICO = true;\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function enableTransfers() public onlyOwner{\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function disableTransfers() public onlyOwner{\n', '        istransferAllowed = false;\n', '    }\n', '\n', '    //functiion to force finalize the ICO by the owner no checks called here\n', '    function finalizeICOOwner() onlyOwner{\n', '        finalizedICO = true;\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function isValid() returns(bool){\n', '        if(now>=fundingStartBlock && now<fundingEndBlock ){\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '        if(usdraised>maxCapUSD) throw;\n', '    }\n', '\n', '    ///do not allow payments on this address\n', '\n', '    function() payable{\n', '        throw;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  modifier stopInEmergency {\n', '    if (paused) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '// Bitcoin transaction parsing library\n', '\n', '// Copyright 2016 rain <https://keybase.io/rain>\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the "License");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '//      http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '// https://en.bitcoin.it/wiki/Protocol_documentation#tx\n', '//\n', '// Raw Bitcoin transaction structure:\n', '//\n', '// field     | size | type     | description\n', '// version   | 4    | int32    | transaction version number\n', '// n_tx_in   | 1-9  | var_int  | number of transaction inputs\n', '// tx_in     | 41+  | tx_in[]  | list of transaction inputs\n', '// n_tx_out  | 1-9  | var_int  | number of transaction outputs\n', '// tx_out    | 9+   | tx_out[] | list of transaction outputs\n', '// lock_time | 4    | uint32   | block number / timestamp at which tx locked\n', '//\n', '// Transaction input (tx_in) structure:\n', '//\n', '// field      | size | type     | description\n', '// previous   | 36   | outpoint | Previous output transaction reference\n', '// script_len | 1-9  | var_int  | Length of the signature script\n', '// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\n', '// sequence   | 4    | uint32   | Sender transaction version\n', '//\n', '// OutPoint structure:\n', '//\n', '// field      | size | type     | description\n', '// hash       | 32   | char[32] | The hash of the referenced transaction\n', '// index      | 4    | uint32   | The index of this output in the referenced transaction\n', '//\n', '// Transaction output (tx_out) structure:\n', '//\n', '// field         | size | type     | description\n', '// value         | 8    | int64    | Transaction value (Satoshis)\n', '// pk_script_len | 1-9  | var_int  | Length of the public key script\n', '// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\n', '//\n', '// Variable integers (var_int) can be encoded differently depending\n', '// on the represented value, to save space. Variable integers always\n', '// precede an array of a variable length data type (e.g. tx_in).\n', '//\n', '// Variable integer encodings as a function of represented value:\n', '//\n', '// value           | bytes  | format\n', '// <0xFD (253)     | 1      | uint8\n', '// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\n', '// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\n', '// -               | 9      | 0xFF followed by length as uint64\n', '//\n', '// Public key scripts `pk_script` are set on the output and can\n', '// take a number of forms. The regular transaction script is\n', '// called &#39;pay-to-pubkey-hash&#39; (P2PKH):\n', '//\n', '// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n', '//\n', '// OP_x are Bitcoin script opcodes. The bytes representation (including\n', '// the 0x14 20-byte stack push) is:\n', '//\n', '// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\n', '//\n', '// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\n', '// the public key, preceded by a network version byte. (21 bytes total)\n', '//\n', '// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\n', '//\n', '// The Bitcoin address is derived from the pubKeyHash. The binary form is the\n', '// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\n', '// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\n', '// This is converted to base58 to form the publicly used Bitcoin address.\n', '// Mainnet P2PKH transaction scripts are to addresses beginning with &#39;1&#39;.\n', '//\n', '// P2SH (&#39;pay to script hash&#39;) scripts only supply a script hash. The spender\n', '// must then provide the script that would allow them to redeem this output.\n', '// This allows for arbitrarily complex scripts to be funded using only a\n', '// hash of the script, and moves the onus on providing the script from\n', '// the spender to the redeemer.\n', '//\n', '// The P2SH script format is simple:\n', '//\n', '// OP_HASH160 <scriptHash> OP_EQUAL\n', '//\n', '// 0xA9 0x14 <scriptHash> 0x87\n', '//\n', '// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\n', '// redeem script. The P2SH address is derived from the scriptHash.\n', '// Addresses are the scriptHash with a version prefix of 5, encoded as\n', '// Base58check. These addresses begin with a &#39;3&#39;.\n', '\n', '\n', '\n', '// parse a raw bitcoin transaction byte array\n', 'library BTC {\n', '    // Convert a variable integer into something useful and return it and\n', '    // the index to after it.\n', '    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\n', '        // the first byte tells us how big the integer is\n', '        var ibit = uint8(txBytes[pos]);\n', '        pos += 1;  // skip ibit\n', '\n', '        if (ibit < 0xfd) {\n', '            return (ibit, pos);\n', '        } else if (ibit == 0xfd) {\n', '            return (getBytesLE(txBytes, pos, 16), pos + 2);\n', '        } else if (ibit == 0xfe) {\n', '            return (getBytesLE(txBytes, pos, 32), pos + 4);\n', '        } else if (ibit == 0xff) {\n', '            return (getBytesLE(txBytes, pos, 64), pos + 8);\n', '        }\n', '    }\n', '    // convert little endian bytes to uint\n', '    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\n', '        if (bits == 8) {\n', '            return uint8(data[pos]);\n', '        } else if (bits == 16) {\n', '            return uint16(data[pos])\n', '                 + uint16(data[pos + 1]) * 2 ** 8;\n', '        } else if (bits == 32) {\n', '            return uint32(data[pos])\n', '                 + uint32(data[pos + 1]) * 2 ** 8\n', '                 + uint32(data[pos + 2]) * 2 ** 16\n', '                 + uint32(data[pos + 3]) * 2 ** 24;\n', '        } else if (bits == 64) {\n', '            return uint64(data[pos])\n', '                 + uint64(data[pos + 1]) * 2 ** 8\n', '                 + uint64(data[pos + 2]) * 2 ** 16\n', '                 + uint64(data[pos + 3]) * 2 ** 24\n', '                 + uint64(data[pos + 4]) * 2 ** 32\n', '                 + uint64(data[pos + 5]) * 2 ** 40\n', '                 + uint64(data[pos + 6]) * 2 ** 48\n', '                 + uint64(data[pos + 7]) * 2 ** 56;\n', '        }\n', '    }\n', '    // scan the full transaction bytes and return the first two output\n', '    // values (in satoshis) and addresses (in binary)\n', '    function getFirstTwoOutputs(bytes txBytes)\n', '             returns (uint, bytes20, uint, bytes20)\n', '    {\n', '        uint pos;\n', '        uint[] memory input_script_lens = new uint[](2);\n', '        uint[] memory output_script_lens = new uint[](2);\n', '        uint[] memory script_starts = new uint[](2);\n', '        uint[] memory output_values = new uint[](2);\n', '        bytes20[] memory output_addresses = new bytes20[](2);\n', '\n', '        pos = 4;  // skip version\n', '\n', '        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\n', '\n', '        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\n', '\n', '        for (uint i = 0; i < 2; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            output_addresses[i] = pkhash;\n', '        }\n', '\n', '        return (output_values[0], output_addresses[0],\n', '                output_values[1], output_addresses[1]);\n', '    }\n', '    // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '        // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\n', '             returns (bool,uint)\n', '    {\n', '        uint pos = 4;  // skip version\n', '        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\n', '\n', '        // scan *all* the outputs and find where they are\n', '        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\n', '\n', '        // look at each output and check whether it at least value to btcAddress\n', '        for (uint i = 0; i < output_values.length; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            if (pkhash == btcAddress && output_values[i] >= value) {\n', '                return (true,output_values[i]);\n', '            }\n', '        }\n', '    }\n', '    // scan the inputs and find the script lengths.\n', '    // return an array of script lengths and the end position\n', '    // of the inputs.\n', '    // takes a &#39;stop&#39; argument which sets the maximum number of\n', '    // outputs to scan through. stop=0 => scan all.\n', '    function scanInputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint)\n', '    {\n', '        uint n_inputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_inputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_inputs) {\n', '            halt = n_inputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_lens = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            pos += 36;  // skip outpoint\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_lens[i] = script_len;\n', '            pos += script_len + 4;  // skip sig_script, seq\n', '        }\n', '\n', '        return (script_lens, pos);\n', '    }\n', '    // scan the outputs and find the values and script lengths.\n', '    // return array of values, array of script lengths and the\n', '    // end position of the outputs.\n', '    // takes a &#39;stop&#39; argument which sets the maximum number of\n', '    // outputs to scan through. stop=0 => scan all.\n', '    function scanOutputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint[], uint[], uint)\n', '    {\n', '        uint n_outputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_outputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_outputs) {\n', '            halt = n_outputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_starts = new uint[](halt);\n', '        uint[] memory script_lens = new uint[](halt);\n', '        uint[] memory output_values = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            output_values[i] = getBytesLE(txBytes, pos, 64);\n', '            pos += 8;\n', '\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_starts[i] = pos;\n', '            script_lens[i] = script_len;\n', '            pos += script_len;\n', '        }\n', '\n', '        return (output_values, script_starts, script_lens, pos);\n', '    }\n', '    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\n', '    function sliceBytes20(bytes data, uint start) returns (bytes20) {\n', '        uint160 slice = 0;\n', '        for (uint160 i = 0; i < 20; i++) {\n', '            slice += uint160(data[i + start]) << (8 * (19 - i));\n', '        }\n', '        return bytes20(slice);\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2PKH script\n', '    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\n', '            && (txBytes[pos] == 0x76)       // OP_DUP\n', '            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 2] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\n', '            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2SH script\n', '    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\n', '            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 1] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\n', '    }\n', '    // Get the pubkeyhash / scripthash from an output script. Assumes\n', '    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\n', '    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\n', '    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\n', '             returns (bytes20)\n', '    {\n', '        if (isP2PKH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 3);\n', '        } else if (isP2SH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 2);\n', '        } else {\n', '            return;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract PricingStrategy is Ownable{\n', '    uint public ETHUSD=580;\n', '    uint public BTCUSD=9000;\n', '    uint256 public exchangeRate;\n', '    bool public called;\n', '    \n', '    function getLatest(uint btcusd,uint ethusd) onlyOwner{\n', '        ETHUSD = ethusd;\n', '        BTCUSD = btcusd;\n', '    }\n', '\n', '\n', '    uint256 public bonuspercentageprivate = 50;\n', '    uint256 public bonuspercentagepresale = 25;\n', '    uint256 public bonuspercentagepublic  = 0;\n', '\n', '    function changeprivatebonus(uint256 _value) public onlyOwner{\n', '        bonuspercentageprivate = _value;\n', '    }\n', '\n', '    function changepublicbonus(uint256 _value) public onlyOwner{\n', '        bonuspercentagepresale = _value;\n', '    }\n', '\n', '    function changepresalebonus(uint256 _value) public onlyOwner{\n', '        bonuspercentagepublic = _value;\n', '    }\n', '\n', '    uint256 public mincontribprivatesale = 15000;\n', '    uint256 public mincontribpresale = 1000;\n', '    uint256 public mincontribpublicsale = 0;\n', '\n', '    function changeminprivatesale(uint256 _value) public onlyOwner{\n', '        mincontribprivatesale = _value;\n', '    }\n', '\n', '    function changeminpresale(uint256 _value) public onlyOwner{\n', '        mincontribpresale = _value;\n', '    }\n', '\n', '    function changeminpublicsale(uint256 _value) public onlyOwner{\n', '        mincontribpublicsale = _value;\n', '    }\n', '\n', '\n', '    ///log the value to get the value in usd\n', '    event logval(uint256 s);\n', '\n', '    function totalDiscount(Sales.ICOSaleState state,uint256 contribution,string types) returns (uint256,uint256){\n', '        uint256 valueInUSD;\n', '        if(keccak256(types)==keccak256("ethereum")){\n', '            if(ETHUSD==0) throw;\n', '            valueInUSD = (ETHUSD*contribution)/1000000000000000000;\n', '            logval(valueInUSD);\n', '\n', '        }else if(keccak256(types)==keccak256("bitcoin")){\n', '            if(BTCUSD==0) throw;\n', '            valueInUSD = (BTCUSD*contribution)/100000000;\n', '            logval(valueInUSD);\n', '\n', '        }\n', '        if(state==Sales.ICOSaleState.PrivateSale){\n', '            if(valueInUSD<mincontribprivatesale) throw;\n', '            return (bonuspercentageprivate,valueInUSD);\n', '        }else if(state==Sales.ICOSaleState.PreSale){\n', '            if(valueInUSD<mincontribpresale) throw;\n', '            return (bonuspercentagepresale,valueInUSD);\n', '        }else if(state==Sales.ICOSaleState.PublicSale){\n', '            if(valueInUSD>=mincontribpublicsale) throw;\n', '            return (bonuspercentagepublic,valueInUSD);\n', '        }\n', '        else{\n', '            return (0,0);\n', '        }\n', '    }\n', '    \n', '    function() payable{\n', '        \n', '    }\n', '}\n', '\n', '\n', '///////https://ethereum.stackexchange.com/questions/11383/oracle-oraclize-it-with-truffle-and-testrpc\n', '\n', '////https://ethereum.stackexchange.com/questions/17015/regarding-oraclize-call-in-smart-contract\n', '\n', '\n', '\n', 'contract NewTokenSale is Ownable,Pausable, Utils,Sales{\n', '\n', '    GACToken token;\n', '    bool fundssent;\n', '    uint256 public tokensPerUSD;\n', '    uint256 public currentSupply = 634585000000000000000000;\n', '    PricingStrategy pricingstrategy;\n', '    uint256 public tokenCreationMax = 275 * (10**6) * 10**18;\n', '\n', '    ///the address of owner to recieve the token\n', '    address public ownerAddr =0xB0583785f27B7f87535B4c574D3B30928aD3A7eb ; //to be filled\n', '\n', '    ///this is the address of the distributong account admin\n', '    address public distributorAddress = 0x5377209111cBe0cfeeaA54c4C28465cbf81D5601;\n', '\n', '    ////MAX Tokens for private sale\n', '    uint256 public maxPrivateSale = 150 * (10**6) * (10**18);\n', '    ///MAX tokens for presale \n', '    uint256 public maxPreSale = 100 * (10**6) * (10**18);\n', '\n', '    ///MAX tokens for the public sale\n', '    uint256 public maxPublicSale = 20* (10**6) * (10**18);\n', '\n', '    ///current sales\n', '    uint256 public endprivate = 1525219200; // 05/02/2018 @ 12:00am (UTC)\n', '    uint256 public endpresale = 1527724800;//05/31/2018 @ 12:00am (UTC)\n', '    // uint256 public endpublicsale;\n', '    uint256 public currentPrivateSale = 630585000000000000000000;\n', '    uint256 public currentPreSale = 4000000000000000000000;\n', '    uint256 public currentPublicSale ; \n', '\n', '\n', '    ///array of addresses for the ethereum relateed back funding  contract\n', '    uint256  public numberOfBackers;\n', '\n', '    mapping(uint256 => bool) transactionsClaimed;\n', '    uint256 public valueToBeSent;\n', '    uint public investorCount;\n', '\n', '    struct balanceStruct{\n', '        uint256 value;\n', '        bool tokenstransferred;\n', '    }\n', '\n', '    mapping(address => balanceStruct) public balances;\n', '    address[] public balancesArr;\n', '\n', '    ///the event log to log out the address of the multisig wallet\n', '    event logaddr(address addr);\n', '\n', '    ///the function to get the balance\n', '    function getBalance(address addr) public view returns(uint256) {\n', '        return balances[addr].value;\n', '    }\n', '\n', '    ///the function of adding to balances\n', '    function addToBalances(address addr, uint256 tokenValue) internal{\n', '        balances[addr].value = SafeMath.add(balances[addr].value,tokenValue);\n', '        bool found;\n', '        for(uint i=0;i<balancesArr.length;i++){\n', '            if(balancesArr[i]==addr){\n', '                found = true;\n', '            }\n', '        }\n', '        if(!found){\n', '            balancesArr.push(addr);\n', '        }\n', '    }\n', '\n', '    ///the function of adding to the balances\n', '    function alottMainSaleToken(address[] arr) public {\n', '        require(msg.sender == distributorAddress);\n', '        for(uint i=0;i<arr.length;i++){\n', '            if(checkExistsInArray(arr[i])){\n', '            if(!balances[arr[i]].tokenstransferred){\n', '                balances[arr[i]].tokenstransferred = true;\n', '                token.addToBalances(arr[i], balances[arr[i]].value);\n', '            }\n', '        }\n', '        }\n', '    }\n', '\n', '    function checkExistsInArray(address addr) internal returns (bool) {\n', '        for(uint i=0;i<balancesArr.length;i++){\n', '            if(balancesArr[i]==addr){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    //the constructor function\n', '   function NewTokenSale(address tokenAddress,address strategy){\n', '        //require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\n', '        token = GACToken(tokenAddress);\n', '        tokensPerUSD = 10 * 10 ** 18;\n', '        valueToBeSent = token.valueToBeSent();\n', '        pricingstrategy = PricingStrategy(strategy);\n', '    }\n', '\n', '    /**\n', '        Payable function to send the ether funds\n', '    **/\n', '    function() external payable stopInEmergency{\n', '        require(token.isValid());\n', '        require(msg.value>0);\n', '        ICOSaleState currentState = getStateFunding();\n', '        require(currentState!=ICOSaleState.Failed);\n', '        require(currentState!=ICOSaleState.Success);\n', '        var (discount,usd) = pricingstrategy.totalDiscount(currentState,msg.value,"ethereum");\n', '        uint256 tokens = usd*tokensPerUSD;\n', '        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\n', '        if(currentState==ICOSaleState.PrivateSale){\n', '            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\n', '            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PreSale){\n', '            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\n', '            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PublicSale){\n', '            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\n', '            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\n', '        }\n', '        currentSupply = SafeMath.add(currentSupply,totalTokens);\n', '        require(currentSupply<=tokenCreationMax);\n', '        addToBalances(msg.sender,totalTokens);\n', '        token.increaseEthRaised(msg.value);\n', '        token.increaseUSDRaised(usd);\n', '        numberOfBackers++;\n', '        if(!ownerAddr.send(this.balance))throw;\n', '    }\n', '    \n', '    //Token distribution for the case of the ICO\n', '    ///function to run when the transaction has been veified\n', '    function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr)  onlyOwner returns (uint)\n', '    {   \n', '        bool  valueSent;\n', '        require(token.isValid());\n', '     ICOSaleState currentState = getStateFunding();\n', '\n', '        if(!transactionsClaimed[txHash]){\n', '            var (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent);\n', '            if(a){\n', '                valueSent = true;\n', '                transactionsClaimed[txHash] = true;\n', '                 ///since we are creating tokens we need to increase the total supply\n', '               allottTokensBTC(addr,b,currentState);\n', '                return 1;\n', '               }\n', '        }\n', '    }\n', '    \n', '    ///function to allot tokens to address\n', '    function allottTokensBTC(address addr,uint256 value,ICOSaleState state) internal{\n', '        ICOSaleState currentState = getStateFunding();\n', '        require(currentState!=ICOSaleState.Failed);\n', '        require(currentState!=ICOSaleState.Success);\n', '        var (discount,usd) = pricingstrategy.totalDiscount(state,value,"bitcoin");\n', '        uint256 tokens = usd*tokensPerUSD;\n', '        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\n', '        if(currentState==ICOSaleState.PrivateSale){\n', '            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\n', '            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PreSale){\n', '            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\n', '            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PublicSale){\n', '            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\n', '            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\n', '        }\n', '       currentSupply = SafeMath.add(currentSupply,totalTokens);\n', '       require(currentSupply<=tokenCreationMax);\n', '       addToBalances(addr,totalTokens);\n', '       token.increaseBTCRaised(value);\n', '       token.increaseUSDRaised(usd);\n', '       numberOfBackers++;\n', '    }\n', '\n', '\n', '    ///function to alott tokens by the owner\n', '\n', '    function alottTokensExchange(address contributor,uint256 value) public onlyOwner{\n', '        token.addToBalances(contributor,value);\n', '        currentSupply = SafeMath.add(currentSupply,value);\n', '    }\n', '\n', '    function finalizeTokenSale() public onlyOwner{\n', '        ICOSaleState currentState = getStateFunding();\n', '        if(currentState!=ICOSaleState.Success) throw;\n', '        token.finalizeICO();\n', '    }\n', '\n', '    ////kill the contract\n', '    function killContract() public onlyOwner{\n', '        selfdestruct(ownerAddr);\n', '    }\n', '\n', '\n', '    ///change the end private sale\n', '    function changeEndPrivateSale(uint256 _newend) public onlyOwner{\n', '        endprivate = _newend;\n', '    }\n', '\n', '    function changeEndPreSale(uint256 _newend) public onlyOwner{\n', '        endpresale  = _newend;\n', '    }\n', '\n', '\n', '    function changeTokensPerUSD(uint256 _val) public onlyOwner{\n', '        tokensPerUSD = _val;\n', '    }\n', '\n', '    function getStateFunding() returns (ICOSaleState){\n', '       if(now>token.fundingStartBlock() && now<=endprivate) return ICOSaleState.PrivateSale;\n', '       if(now>endprivate && now<=endpresale) return ICOSaleState.PreSale;\n', '       if(now>endpresale && now<=token.fundingEndBlock()) return ICOSaleState.PublicSale;\n', '       if(now>token.fundingEndBlock() && token.usdraised()<token.minCapUSD()) return ICOSaleState.Failed;\n', '       if(now>token.fundingEndBlock() && token.usdraised()>=token.minCapUSD()) return ICOSaleState.Success;\n', '    }\n', '\n', '    \n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Sales{\n', '\n', '\tenum ICOSaleState{\n', '\t\tPrivateSale,\n', '\t    PreSale,\n', '\t    PublicSale,\n', '\t    Success,\n', '\t    Failed\n', '\t }\n', '}\n', '\n', 'contract Utils{\n', '\n', '\t//verifies the amount greater than zero\n', '\n', '\tmodifier greaterThanZero(uint256 _value){\n', '\t\trequire(_value>0);\n', '\t\t_;\n', '\t}\n', '\n', '\t///verifies an address\n', '\n', '\tmodifier validAddress(address _add){\n', '\t\trequire(_add!=0x0);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract GACToken is Token,Ownable,Sales {\n', '    string public constant name = "Gladage Care Token";\n', '    string public constant symbol = "GAC";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '    uint public valueToBeSent = 1;\n', '\n', '    bool public finalizedICO = false;\n', '\n', '    uint256 public ethraised;\n', '    uint256 public btcraised;\n', '    uint256 public usdraised;\n', '\n', '    bool public istransferAllowed;\n', '\n', '    uint256 public constant GACFund = 5 * (10**8) * 10**decimals; \n', '    uint256 public fundingStartBlock; // crowdsale start unix //now\n', '    uint256 public fundingEndBlock; // crowdsale end unix //1530403200 //07/01/2018 @ 12:00am (UTC)\n', '    uint256 public tokenCreationMax= 275 * (10**6) * 10**decimals;//TODO\n', '    mapping (address => bool) ownership;\n', '    uint256 public minCapUSD = 2000000;\n', '    uint256 public maxCapUSD = 20000000;\n', '\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '      if(!istransferAllowed) throw;\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function burnTokens(uint256 _value) public{\n', '        require(balances[msg.sender]>=_value);\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);\n', '        totalSupply =SafeMath.sub(totalSupply,_value);\n', '    }\n', '\n', '\n', '    //this is the default constructor\n', '    function GACToken(uint256 _fundingStartBlock, uint256 _fundingEndBlock){\n', '        totalSupply = GACFund;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '    }\n', '\n', '    ///change the funding end block\n', '    function changeEndBlock(uint256 _newFundingEndBlock) onlyOwner{\n', '        fundingEndBlock = _newFundingEndBlock;\n', '    }\n', '\n', '    ///change the funding start block\n', '    function changeStartBlock(uint256 _newFundingStartBlock) onlyOwner{\n', '        fundingStartBlock = _newFundingStartBlock;\n', '    }\n', '\n', '    ///the Min Cap USD \n', '    ///function too chage the miin cap usd\n', '    function changeMinCapUSD(uint256 _newMinCap) onlyOwner{\n', '        minCapUSD = _newMinCap;\n', '    }\n', '\n', '    ///fucntion to change the max cap usd\n', '    function changeMaxCapUSD(uint256 _newMaxCap) onlyOwner{\n', '        maxCapUSD = _newMaxCap;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '      if(!istransferAllowed) throw;\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '\n', '    function addToBalances(address _person,uint256 value) {\n', '        if(!ownership[msg.sender]) throw;\n', '        balances[_person] = SafeMath.add(balances[_person],value);\n', '        Transfer(address(this), _person, value);\n', '    }\n', '\n', '    function addToOwnership(address owners) onlyOwner{\n', '        ownership[owners] = true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseEthRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        ethraised+=value;\n', '    }\n', '\n', '    function increaseBTCRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        btcraised+=value;\n', '    }\n', '\n', '    function increaseUSDRaised(uint256 value){\n', '        if(!ownership[msg.sender]) throw;\n', '        usdraised+=value;\n', '    }\n', '\n', '    function finalizeICO(){\n', '        if(!ownership[msg.sender]) throw;\n', '        ///replace the below amount of 10000 with the min cap usd value\n', '        ///havent recieved the valus yet :(\n', '        if(usdraised<minCapUSD) throw;\n', '        finalizedICO = true;\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function enableTransfers() public onlyOwner{\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function disableTransfers() public onlyOwner{\n', '        istransferAllowed = false;\n', '    }\n', '\n', '    //functiion to force finalize the ICO by the owner no checks called here\n', '    function finalizeICOOwner() onlyOwner{\n', '        finalizedICO = true;\n', '        istransferAllowed = true;\n', '    }\n', '\n', '    function isValid() returns(bool){\n', '        if(now>=fundingStartBlock && now<fundingEndBlock ){\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '        if(usdraised>maxCapUSD) throw;\n', '    }\n', '\n', '    ///do not allow payments on this address\n', '\n', '    function() payable{\n', '        throw;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  modifier stopInEmergency {\n', '    if (paused) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '// Bitcoin transaction parsing library\n', '\n', '// Copyright 2016 rain <https://keybase.io/rain>\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the "License");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '//      http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '// https://en.bitcoin.it/wiki/Protocol_documentation#tx\n', '//\n', '// Raw Bitcoin transaction structure:\n', '//\n', '// field     | size | type     | description\n', '// version   | 4    | int32    | transaction version number\n', '// n_tx_in   | 1-9  | var_int  | number of transaction inputs\n', '// tx_in     | 41+  | tx_in[]  | list of transaction inputs\n', '// n_tx_out  | 1-9  | var_int  | number of transaction outputs\n', '// tx_out    | 9+   | tx_out[] | list of transaction outputs\n', '// lock_time | 4    | uint32   | block number / timestamp at which tx locked\n', '//\n', '// Transaction input (tx_in) structure:\n', '//\n', '// field      | size | type     | description\n', '// previous   | 36   | outpoint | Previous output transaction reference\n', '// script_len | 1-9  | var_int  | Length of the signature script\n', '// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\n', '// sequence   | 4    | uint32   | Sender transaction version\n', '//\n', '// OutPoint structure:\n', '//\n', '// field      | size | type     | description\n', '// hash       | 32   | char[32] | The hash of the referenced transaction\n', '// index      | 4    | uint32   | The index of this output in the referenced transaction\n', '//\n', '// Transaction output (tx_out) structure:\n', '//\n', '// field         | size | type     | description\n', '// value         | 8    | int64    | Transaction value (Satoshis)\n', '// pk_script_len | 1-9  | var_int  | Length of the public key script\n', '// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\n', '//\n', '// Variable integers (var_int) can be encoded differently depending\n', '// on the represented value, to save space. Variable integers always\n', '// precede an array of a variable length data type (e.g. tx_in).\n', '//\n', '// Variable integer encodings as a function of represented value:\n', '//\n', '// value           | bytes  | format\n', '// <0xFD (253)     | 1      | uint8\n', '// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\n', '// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\n', '// -               | 9      | 0xFF followed by length as uint64\n', '//\n', '// Public key scripts `pk_script` are set on the output and can\n', '// take a number of forms. The regular transaction script is\n', "// called 'pay-to-pubkey-hash' (P2PKH):\n", '//\n', '// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n', '//\n', '// OP_x are Bitcoin script opcodes. The bytes representation (including\n', '// the 0x14 20-byte stack push) is:\n', '//\n', '// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\n', '//\n', '// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\n', '// the public key, preceded by a network version byte. (21 bytes total)\n', '//\n', '// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\n', '//\n', '// The Bitcoin address is derived from the pubKeyHash. The binary form is the\n', '// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\n', '// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\n', '// This is converted to base58 to form the publicly used Bitcoin address.\n', "// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\n", '//\n', "// P2SH ('pay to script hash') scripts only supply a script hash. The spender\n", '// must then provide the script that would allow them to redeem this output.\n', '// This allows for arbitrarily complex scripts to be funded using only a\n', '// hash of the script, and moves the onus on providing the script from\n', '// the spender to the redeemer.\n', '//\n', '// The P2SH script format is simple:\n', '//\n', '// OP_HASH160 <scriptHash> OP_EQUAL\n', '//\n', '// 0xA9 0x14 <scriptHash> 0x87\n', '//\n', '// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\n', '// redeem script. The P2SH address is derived from the scriptHash.\n', '// Addresses are the scriptHash with a version prefix of 5, encoded as\n', "// Base58check. These addresses begin with a '3'.\n", '\n', '\n', '\n', '// parse a raw bitcoin transaction byte array\n', 'library BTC {\n', '    // Convert a variable integer into something useful and return it and\n', '    // the index to after it.\n', '    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\n', '        // the first byte tells us how big the integer is\n', '        var ibit = uint8(txBytes[pos]);\n', '        pos += 1;  // skip ibit\n', '\n', '        if (ibit < 0xfd) {\n', '            return (ibit, pos);\n', '        } else if (ibit == 0xfd) {\n', '            return (getBytesLE(txBytes, pos, 16), pos + 2);\n', '        } else if (ibit == 0xfe) {\n', '            return (getBytesLE(txBytes, pos, 32), pos + 4);\n', '        } else if (ibit == 0xff) {\n', '            return (getBytesLE(txBytes, pos, 64), pos + 8);\n', '        }\n', '    }\n', '    // convert little endian bytes to uint\n', '    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\n', '        if (bits == 8) {\n', '            return uint8(data[pos]);\n', '        } else if (bits == 16) {\n', '            return uint16(data[pos])\n', '                 + uint16(data[pos + 1]) * 2 ** 8;\n', '        } else if (bits == 32) {\n', '            return uint32(data[pos])\n', '                 + uint32(data[pos + 1]) * 2 ** 8\n', '                 + uint32(data[pos + 2]) * 2 ** 16\n', '                 + uint32(data[pos + 3]) * 2 ** 24;\n', '        } else if (bits == 64) {\n', '            return uint64(data[pos])\n', '                 + uint64(data[pos + 1]) * 2 ** 8\n', '                 + uint64(data[pos + 2]) * 2 ** 16\n', '                 + uint64(data[pos + 3]) * 2 ** 24\n', '                 + uint64(data[pos + 4]) * 2 ** 32\n', '                 + uint64(data[pos + 5]) * 2 ** 40\n', '                 + uint64(data[pos + 6]) * 2 ** 48\n', '                 + uint64(data[pos + 7]) * 2 ** 56;\n', '        }\n', '    }\n', '    // scan the full transaction bytes and return the first two output\n', '    // values (in satoshis) and addresses (in binary)\n', '    function getFirstTwoOutputs(bytes txBytes)\n', '             returns (uint, bytes20, uint, bytes20)\n', '    {\n', '        uint pos;\n', '        uint[] memory input_script_lens = new uint[](2);\n', '        uint[] memory output_script_lens = new uint[](2);\n', '        uint[] memory script_starts = new uint[](2);\n', '        uint[] memory output_values = new uint[](2);\n', '        bytes20[] memory output_addresses = new bytes20[](2);\n', '\n', '        pos = 4;  // skip version\n', '\n', '        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\n', '\n', '        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\n', '\n', '        for (uint i = 0; i < 2; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            output_addresses[i] = pkhash;\n', '        }\n', '\n', '        return (output_values[0], output_addresses[0],\n', '                output_values[1], output_addresses[1]);\n', '    }\n', '    // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '        // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\n', '             returns (bool,uint)\n', '    {\n', '        uint pos = 4;  // skip version\n', '        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\n', '\n', '        // scan *all* the outputs and find where they are\n', '        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\n', '\n', '        // look at each output and check whether it at least value to btcAddress\n', '        for (uint i = 0; i < output_values.length; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            if (pkhash == btcAddress && output_values[i] >= value) {\n', '                return (true,output_values[i]);\n', '            }\n', '        }\n', '    }\n', '    // scan the inputs and find the script lengths.\n', '    // return an array of script lengths and the end position\n', '    // of the inputs.\n', "    // takes a 'stop' argument which sets the maximum number of\n", '    // outputs to scan through. stop=0 => scan all.\n', '    function scanInputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint)\n', '    {\n', '        uint n_inputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_inputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_inputs) {\n', '            halt = n_inputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_lens = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            pos += 36;  // skip outpoint\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_lens[i] = script_len;\n', '            pos += script_len + 4;  // skip sig_script, seq\n', '        }\n', '\n', '        return (script_lens, pos);\n', '    }\n', '    // scan the outputs and find the values and script lengths.\n', '    // return array of values, array of script lengths and the\n', '    // end position of the outputs.\n', "    // takes a 'stop' argument which sets the maximum number of\n", '    // outputs to scan through. stop=0 => scan all.\n', '    function scanOutputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint[], uint[], uint)\n', '    {\n', '        uint n_outputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_outputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_outputs) {\n', '            halt = n_outputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_starts = new uint[](halt);\n', '        uint[] memory script_lens = new uint[](halt);\n', '        uint[] memory output_values = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            output_values[i] = getBytesLE(txBytes, pos, 64);\n', '            pos += 8;\n', '\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_starts[i] = pos;\n', '            script_lens[i] = script_len;\n', '            pos += script_len;\n', '        }\n', '\n', '        return (output_values, script_starts, script_lens, pos);\n', '    }\n', '    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\n', '    function sliceBytes20(bytes data, uint start) returns (bytes20) {\n', '        uint160 slice = 0;\n', '        for (uint160 i = 0; i < 20; i++) {\n', '            slice += uint160(data[i + start]) << (8 * (19 - i));\n', '        }\n', '        return bytes20(slice);\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2PKH script\n', '    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\n', '            && (txBytes[pos] == 0x76)       // OP_DUP\n', '            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 2] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\n', '            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2SH script\n', '    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\n', '            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 1] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\n', '    }\n', '    // Get the pubkeyhash / scripthash from an output script. Assumes\n', '    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\n', '    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\n', '    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\n', '             returns (bytes20)\n', '    {\n', '        if (isP2PKH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 3);\n', '        } else if (isP2SH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 2);\n', '        } else {\n', '            return;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract PricingStrategy is Ownable{\n', '    uint public ETHUSD=580;\n', '    uint public BTCUSD=9000;\n', '    uint256 public exchangeRate;\n', '    bool public called;\n', '    \n', '    function getLatest(uint btcusd,uint ethusd) onlyOwner{\n', '        ETHUSD = ethusd;\n', '        BTCUSD = btcusd;\n', '    }\n', '\n', '\n', '    uint256 public bonuspercentageprivate = 50;\n', '    uint256 public bonuspercentagepresale = 25;\n', '    uint256 public bonuspercentagepublic  = 0;\n', '\n', '    function changeprivatebonus(uint256 _value) public onlyOwner{\n', '        bonuspercentageprivate = _value;\n', '    }\n', '\n', '    function changepublicbonus(uint256 _value) public onlyOwner{\n', '        bonuspercentagepresale = _value;\n', '    }\n', '\n', '    function changepresalebonus(uint256 _value) public onlyOwner{\n', '        bonuspercentagepublic = _value;\n', '    }\n', '\n', '    uint256 public mincontribprivatesale = 15000;\n', '    uint256 public mincontribpresale = 1000;\n', '    uint256 public mincontribpublicsale = 0;\n', '\n', '    function changeminprivatesale(uint256 _value) public onlyOwner{\n', '        mincontribprivatesale = _value;\n', '    }\n', '\n', '    function changeminpresale(uint256 _value) public onlyOwner{\n', '        mincontribpresale = _value;\n', '    }\n', '\n', '    function changeminpublicsale(uint256 _value) public onlyOwner{\n', '        mincontribpublicsale = _value;\n', '    }\n', '\n', '\n', '    ///log the value to get the value in usd\n', '    event logval(uint256 s);\n', '\n', '    function totalDiscount(Sales.ICOSaleState state,uint256 contribution,string types) returns (uint256,uint256){\n', '        uint256 valueInUSD;\n', '        if(keccak256(types)==keccak256("ethereum")){\n', '            if(ETHUSD==0) throw;\n', '            valueInUSD = (ETHUSD*contribution)/1000000000000000000;\n', '            logval(valueInUSD);\n', '\n', '        }else if(keccak256(types)==keccak256("bitcoin")){\n', '            if(BTCUSD==0) throw;\n', '            valueInUSD = (BTCUSD*contribution)/100000000;\n', '            logval(valueInUSD);\n', '\n', '        }\n', '        if(state==Sales.ICOSaleState.PrivateSale){\n', '            if(valueInUSD<mincontribprivatesale) throw;\n', '            return (bonuspercentageprivate,valueInUSD);\n', '        }else if(state==Sales.ICOSaleState.PreSale){\n', '            if(valueInUSD<mincontribpresale) throw;\n', '            return (bonuspercentagepresale,valueInUSD);\n', '        }else if(state==Sales.ICOSaleState.PublicSale){\n', '            if(valueInUSD>=mincontribpublicsale) throw;\n', '            return (bonuspercentagepublic,valueInUSD);\n', '        }\n', '        else{\n', '            return (0,0);\n', '        }\n', '    }\n', '    \n', '    function() payable{\n', '        \n', '    }\n', '}\n', '\n', '\n', '///////https://ethereum.stackexchange.com/questions/11383/oracle-oraclize-it-with-truffle-and-testrpc\n', '\n', '////https://ethereum.stackexchange.com/questions/17015/regarding-oraclize-call-in-smart-contract\n', '\n', '\n', '\n', 'contract NewTokenSale is Ownable,Pausable, Utils,Sales{\n', '\n', '    GACToken token;\n', '    bool fundssent;\n', '    uint256 public tokensPerUSD;\n', '    uint256 public currentSupply = 634585000000000000000000;\n', '    PricingStrategy pricingstrategy;\n', '    uint256 public tokenCreationMax = 275 * (10**6) * 10**18;\n', '\n', '    ///the address of owner to recieve the token\n', '    address public ownerAddr =0xB0583785f27B7f87535B4c574D3B30928aD3A7eb ; //to be filled\n', '\n', '    ///this is the address of the distributong account admin\n', '    address public distributorAddress = 0x5377209111cBe0cfeeaA54c4C28465cbf81D5601;\n', '\n', '    ////MAX Tokens for private sale\n', '    uint256 public maxPrivateSale = 150 * (10**6) * (10**18);\n', '    ///MAX tokens for presale \n', '    uint256 public maxPreSale = 100 * (10**6) * (10**18);\n', '\n', '    ///MAX tokens for the public sale\n', '    uint256 public maxPublicSale = 20* (10**6) * (10**18);\n', '\n', '    ///current sales\n', '    uint256 public endprivate = 1525219200; // 05/02/2018 @ 12:00am (UTC)\n', '    uint256 public endpresale = 1527724800;//05/31/2018 @ 12:00am (UTC)\n', '    // uint256 public endpublicsale;\n', '    uint256 public currentPrivateSale = 630585000000000000000000;\n', '    uint256 public currentPreSale = 4000000000000000000000;\n', '    uint256 public currentPublicSale ; \n', '\n', '\n', '    ///array of addresses for the ethereum relateed back funding  contract\n', '    uint256  public numberOfBackers;\n', '\n', '    mapping(uint256 => bool) transactionsClaimed;\n', '    uint256 public valueToBeSent;\n', '    uint public investorCount;\n', '\n', '    struct balanceStruct{\n', '        uint256 value;\n', '        bool tokenstransferred;\n', '    }\n', '\n', '    mapping(address => balanceStruct) public balances;\n', '    address[] public balancesArr;\n', '\n', '    ///the event log to log out the address of the multisig wallet\n', '    event logaddr(address addr);\n', '\n', '    ///the function to get the balance\n', '    function getBalance(address addr) public view returns(uint256) {\n', '        return balances[addr].value;\n', '    }\n', '\n', '    ///the function of adding to balances\n', '    function addToBalances(address addr, uint256 tokenValue) internal{\n', '        balances[addr].value = SafeMath.add(balances[addr].value,tokenValue);\n', '        bool found;\n', '        for(uint i=0;i<balancesArr.length;i++){\n', '            if(balancesArr[i]==addr){\n', '                found = true;\n', '            }\n', '        }\n', '        if(!found){\n', '            balancesArr.push(addr);\n', '        }\n', '    }\n', '\n', '    ///the function of adding to the balances\n', '    function alottMainSaleToken(address[] arr) public {\n', '        require(msg.sender == distributorAddress);\n', '        for(uint i=0;i<arr.length;i++){\n', '            if(checkExistsInArray(arr[i])){\n', '            if(!balances[arr[i]].tokenstransferred){\n', '                balances[arr[i]].tokenstransferred = true;\n', '                token.addToBalances(arr[i], balances[arr[i]].value);\n', '            }\n', '        }\n', '        }\n', '    }\n', '\n', '    function checkExistsInArray(address addr) internal returns (bool) {\n', '        for(uint i=0;i<balancesArr.length;i++){\n', '            if(balancesArr[i]==addr){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    //the constructor function\n', '   function NewTokenSale(address tokenAddress,address strategy){\n', '        //require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\n', '        token = GACToken(tokenAddress);\n', '        tokensPerUSD = 10 * 10 ** 18;\n', '        valueToBeSent = token.valueToBeSent();\n', '        pricingstrategy = PricingStrategy(strategy);\n', '    }\n', '\n', '    /**\n', '        Payable function to send the ether funds\n', '    **/\n', '    function() external payable stopInEmergency{\n', '        require(token.isValid());\n', '        require(msg.value>0);\n', '        ICOSaleState currentState = getStateFunding();\n', '        require(currentState!=ICOSaleState.Failed);\n', '        require(currentState!=ICOSaleState.Success);\n', '        var (discount,usd) = pricingstrategy.totalDiscount(currentState,msg.value,"ethereum");\n', '        uint256 tokens = usd*tokensPerUSD;\n', '        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\n', '        if(currentState==ICOSaleState.PrivateSale){\n', '            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\n', '            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PreSale){\n', '            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\n', '            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PublicSale){\n', '            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\n', '            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\n', '        }\n', '        currentSupply = SafeMath.add(currentSupply,totalTokens);\n', '        require(currentSupply<=tokenCreationMax);\n', '        addToBalances(msg.sender,totalTokens);\n', '        token.increaseEthRaised(msg.value);\n', '        token.increaseUSDRaised(usd);\n', '        numberOfBackers++;\n', '        if(!ownerAddr.send(this.balance))throw;\n', '    }\n', '    \n', '    //Token distribution for the case of the ICO\n', '    ///function to run when the transaction has been veified\n', '    function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr)  onlyOwner returns (uint)\n', '    {   \n', '        bool  valueSent;\n', '        require(token.isValid());\n', '     ICOSaleState currentState = getStateFunding();\n', '\n', '        if(!transactionsClaimed[txHash]){\n', '            var (a,b) = BTC.checkValueSent(txn,btcaddr,valueToBeSent);\n', '            if(a){\n', '                valueSent = true;\n', '                transactionsClaimed[txHash] = true;\n', '                 ///since we are creating tokens we need to increase the total supply\n', '               allottTokensBTC(addr,b,currentState);\n', '                return 1;\n', '               }\n', '        }\n', '    }\n', '    \n', '    ///function to allot tokens to address\n', '    function allottTokensBTC(address addr,uint256 value,ICOSaleState state) internal{\n', '        ICOSaleState currentState = getStateFunding();\n', '        require(currentState!=ICOSaleState.Failed);\n', '        require(currentState!=ICOSaleState.Success);\n', '        var (discount,usd) = pricingstrategy.totalDiscount(state,value,"bitcoin");\n', '        uint256 tokens = usd*tokensPerUSD;\n', '        uint256 totalTokens = SafeMath.add(tokens,SafeMath.div(SafeMath.mul(tokens,discount),100));\n', '        if(currentState==ICOSaleState.PrivateSale){\n', '            require(SafeMath.add(currentPrivateSale,totalTokens)<=maxPrivateSale);\n', '            currentPrivateSale = SafeMath.add(currentPrivateSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PreSale){\n', '            require(SafeMath.add(currentPreSale,totalTokens)<=maxPreSale);\n', '            currentPreSale = SafeMath.add(currentPreSale,totalTokens);\n', '        }else if(currentState==ICOSaleState.PublicSale){\n', '            require(SafeMath.add(currentPublicSale,totalTokens)<=maxPublicSale);\n', '            currentPublicSale = SafeMath.add(currentPublicSale,totalTokens);\n', '        }\n', '       currentSupply = SafeMath.add(currentSupply,totalTokens);\n', '       require(currentSupply<=tokenCreationMax);\n', '       addToBalances(addr,totalTokens);\n', '       token.increaseBTCRaised(value);\n', '       token.increaseUSDRaised(usd);\n', '       numberOfBackers++;\n', '    }\n', '\n', '\n', '    ///function to alott tokens by the owner\n', '\n', '    function alottTokensExchange(address contributor,uint256 value) public onlyOwner{\n', '        token.addToBalances(contributor,value);\n', '        currentSupply = SafeMath.add(currentSupply,value);\n', '    }\n', '\n', '    function finalizeTokenSale() public onlyOwner{\n', '        ICOSaleState currentState = getStateFunding();\n', '        if(currentState!=ICOSaleState.Success) throw;\n', '        token.finalizeICO();\n', '    }\n', '\n', '    ////kill the contract\n', '    function killContract() public onlyOwner{\n', '        selfdestruct(ownerAddr);\n', '    }\n', '\n', '\n', '    ///change the end private sale\n', '    function changeEndPrivateSale(uint256 _newend) public onlyOwner{\n', '        endprivate = _newend;\n', '    }\n', '\n', '    function changeEndPreSale(uint256 _newend) public onlyOwner{\n', '        endpresale  = _newend;\n', '    }\n', '\n', '\n', '    function changeTokensPerUSD(uint256 _val) public onlyOwner{\n', '        tokensPerUSD = _val;\n', '    }\n', '\n', '    function getStateFunding() returns (ICOSaleState){\n', '       if(now>token.fundingStartBlock() && now<=endprivate) return ICOSaleState.PrivateSale;\n', '       if(now>endprivate && now<=endpresale) return ICOSaleState.PreSale;\n', '       if(now>endpresale && now<=token.fundingEndBlock()) return ICOSaleState.PublicSale;\n', '       if(now>token.fundingEndBlock() && token.usdraised()<token.minCapUSD()) return ICOSaleState.Failed;\n', '       if(now>token.fundingEndBlock() && token.usdraised()>=token.minCapUSD()) return ICOSaleState.Success;\n', '    }\n', '\n', '    \n', '\n', '}']
