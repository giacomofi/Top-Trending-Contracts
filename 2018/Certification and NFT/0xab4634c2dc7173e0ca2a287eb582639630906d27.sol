['pragma solidity ^0.4.23;\n', '\n', '//safemath is not needed as only authorized trusted users can make calls.\n', 'contract disburseERC20v11 {\n', '    //indexed fields can be used for filtering event listeners\n', '    event Disbursement(address indexed _tokenContract,  address[] indexed _contributors, uint256[] _contributions, uint256 _amount);\n', '    event AdminSet(address indexed _tokenContract, address indexed _admin);\n', '    event OwnerSet(address _owner);\n', '\n', '    address owner;\n', '    mapping(address => address) tokenAdmins;\n', '    \n', '    constructor() public {\n', '        //set owner to contract creator\n', '        owner = msg.sender;\n', '        emit OwnerSet(owner);\n', '    }  \n', '\n', '    function disburseToken(address _tokenContract, address[] _contributors, uint256[] _contributions) public {\n', '\n', '        //only allow token admin to disburse\n', '        require(msg.sender == tokenAdmins[_tokenContract]);\n', '\n', '        // get this contract&#39;s balance of specified token\n', '        uint256 balance = ERC20Token(_tokenContract).balanceOf(address(this));\n', '\n', '        // calculate totalContributions\n', '        uint256 totalContributions;\n', '        for(uint16 i = 0; i < _contributions.length; i++){\n', '            totalContributions = totalContributions + _contributions[i];\n', '        }\n', '\n', '        //Send tokens to each contributor\n', '        for(i = 0; i < _contributors.length; i++){\n', '            // calculate members&#39;s disbursement\n', '            uint256 disbursement = (balance * _contributions[i]) / totalContributions;\n', '            \n', '            // ensure that token transfer is successful or  revert all previous actions and stop running\n', '            require(ERC20Token(_tokenContract).transfer(_contributors[i], disbursement));\n', '        }\n', '        // fire event to record disbursement\n', '        emit Disbursement(_tokenContract, _contributors, _contributions, balance);\n', '    }\n', '    \n', '    function setAdmin(address _tokenContract, address _admin) public {\n', '        //don&#39;t allow assignment to address 0x0\n', '        require(_admin != address(0));\n', '        \n', '        //only owner or current admin can set Admin\n', '        require(msg.sender == tokenAdmins[_tokenContract] || msg.sender == owner);\n', '        \n', '        //save admin to token address mapping\n', '        tokenAdmins[_tokenContract] = _admin;\n', '        \n', '        //fire event for client access\n', '        emit AdminSet(_tokenContract, _admin);\n', '    }\n', '    \n', '    function setOwner(address _owner) public {\n', '        //don&#39;t allow assignment to address 0x0\n', '        require(_owner != address(0));\n', '        \n', '        //only owner can set owner\n', '        require(msg.sender == owner);\n', '        \n', '        //save admin to token address mapping\n', '        owner = _owner;\n', '        \n', '        //fire event for client access\n', '        emit OwnerSet(_owner);\n', '    }\n', '}\n', '\n', '// interface to allow calls to ERC20 tokens\n', 'interface ERC20Token {\n', '    function balanceOf(address _holder) external returns(uint256 tokens);\n', '    function transfer(address _to, uint256 amount) external returns(bool success);\n', '}']