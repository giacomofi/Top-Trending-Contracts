['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(\n', '    ERC20 _token,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '\n', '  function safeApprove(\n', '    ERC20 _token,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.approve(_spender, _value));\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) public onlyOwner {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="05776068666a4537">[email&#160;protected]</span>π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param _contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address _contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(_contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20 compatible tokens\n', '   * @param _token ERC20 The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20 _token) external onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    _token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Automated buy back BOB tokens\n', ' */\n', 'contract BobBuyback is Claimable, HasNoContracts, CanReclaimToken, Destructible {\n', '    using SafeMath for uint256;    \n', '\n', '    ERC20 public token;                 //Address of BOB token contract\n', '    uint256 public maxGasPrice;         //Highest gas price allowed for buyback transaction\n', '    uint256 public maxTxValue;          //Highest amount of BOB sent in one transaction\n', '    uint256 public roundStartTime;      //Timestamp when buyback starts (timestamp of the first block where buyback allowed)\n', '    uint256 public rate;                //1 ETH = rate BOB\n', '\n', '    event Buyback(address indexed from, uint256 amountBob, uint256 amountEther);\n', '\n', '    constructor(ERC20 _token, uint256 _maxGasPrice, uint256 _maxTxValue) public {\n', '        token = _token;\n', '        maxGasPrice = _maxGasPrice;\n', '        maxTxValue = _maxTxValue;\n', '        roundStartTime = 0;\n', '        rate = 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Somebody may call this to sell his tokens\n', '     * @param _amount How much tokens to sell\n', '     * Call to token.approve() required before calling this function\n', '     */\n', '    function buyback(uint256 _amount) external {\n', '        require(tx.gasprice <= maxGasPrice);\n', '        require(_amount <= maxTxValue);\n', '        require(isRunning());\n', '\n', '        uint256 amount = _amount;\n', '        uint256 reward = calcReward(amount);\n', '\n', '        if(address(this).balance < reward) {\n', '            //If not enough money to fill request, handle it partially\n', '            reward = address(this).balance;\n', '            amount = reward.mul(rate);\n', '        }\n', '\n', '        require(token.transferFrom(msg.sender, address(this), amount));\n', '        msg.sender.transfer(reward);\n', '        emit Buyback(msg.sender, amount, reward);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates how much ETH somebody can receive for selling amount BOB\n', '     * @param amount How much tokens to sell\n', '     */\n', '    function calcReward(uint256 amount) view public returns(uint256) {\n', '        if(rate == 0) return 0;     //Handle situation when no Buyback is planned\n', '        return amount.div(rate);    //This operation may result in rounding. Which is fine here (rounded  amount < rate / 10**18)\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates how much BOB tokens this contract can buy (during current buyback round)\n', '     */\n', '    function calcTokensAvailableToBuyback() view public returns(uint256) {\n', '        return address(this).balance.mul(rate);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if Buyback round is running\n', '     */\n', '    function isRunning() view public returns(bool) {\n', '        return (rate > 0) && (now >= roundStartTime) && (address(this).balance > 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Changes buyback parameters\n', '     * @param _maxGasPrice Max gas price one ca use to sell is tokens. \n', '     * @param _maxTxValue Max amount of tokens to sell in one transaction\n', '     */\n', '    function setup(uint256 _maxGasPrice, uint256 _maxTxValue) onlyOwner external {\n', '        maxGasPrice = _maxGasPrice;\n', '        maxTxValue = _maxTxValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Starts buyback at specified time, with specified rate\n', '     * @param _roundStartTime Time when Buyback round starts\n', '     * @param _rate Rate of current Buyback round (1 ETH = rate BOB). Zero means no buyback is planned.\n', '     */\n', '    function startBuyback(uint256 _roundStartTime, uint256 _rate) onlyOwner external payable {\n', '        require(_roundStartTime > now);\n', '        roundStartTime = _roundStartTime;\n', '        rate = _rate;   //Rate is not required to be > 0\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all BOB tokens stored on the contract and send them to owner\n', '     */\n', '    function claimTokens() onlyOwner external {\n', '        require(token.transfer(owner, token.balanceOf(address(this))));\n', '    }\n', '    /**\n', '     * @notice Claim some of tokens stored on the contract\n', '     * @param amount How much tokens to claim\n', '     * @param beneficiary Who to send this tokens\n', '     */\n', '    function claimTokens(uint256 amount, address beneficiary) onlyOwner external {\n', '        require(token.transfer(beneficiary, amount));\n', '    }\n', '\n', '    /**\n', '    * @notice Transfer all Ether held by the contract to the owner.\n', '    */\n', '    function reclaimEther()  onlyOwner external {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '\n', '  function balanceOf(address _who) public view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(\n', '    ERC20 _token,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transfer(_to, _value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.transferFrom(_from, _to, _value));\n', '  }\n', '\n', '  function safeApprove(\n', '    ERC20 _token,\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    internal\n', '  {\n', '    require(_token.approve(_spender, _value));\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) public onlyOwner {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param _contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address _contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(_contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens\n', ' * @author SylTi\n', ' * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\n', ' * This will prevent any accidental loss of tokens.\n', ' */\n', 'contract CanReclaimToken is Ownable {\n', '  using SafeERC20 for ERC20;\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20 compatible tokens\n', '   * @param _token ERC20 The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20 _token) external onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    _token.safeTransfer(owner, balance);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Automated buy back BOB tokens\n', ' */\n', 'contract BobBuyback is Claimable, HasNoContracts, CanReclaimToken, Destructible {\n', '    using SafeMath for uint256;    \n', '\n', '    ERC20 public token;                 //Address of BOB token contract\n', '    uint256 public maxGasPrice;         //Highest gas price allowed for buyback transaction\n', '    uint256 public maxTxValue;          //Highest amount of BOB sent in one transaction\n', '    uint256 public roundStartTime;      //Timestamp when buyback starts (timestamp of the first block where buyback allowed)\n', '    uint256 public rate;                //1 ETH = rate BOB\n', '\n', '    event Buyback(address indexed from, uint256 amountBob, uint256 amountEther);\n', '\n', '    constructor(ERC20 _token, uint256 _maxGasPrice, uint256 _maxTxValue) public {\n', '        token = _token;\n', '        maxGasPrice = _maxGasPrice;\n', '        maxTxValue = _maxTxValue;\n', '        roundStartTime = 0;\n', '        rate = 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Somebody may call this to sell his tokens\n', '     * @param _amount How much tokens to sell\n', '     * Call to token.approve() required before calling this function\n', '     */\n', '    function buyback(uint256 _amount) external {\n', '        require(tx.gasprice <= maxGasPrice);\n', '        require(_amount <= maxTxValue);\n', '        require(isRunning());\n', '\n', '        uint256 amount = _amount;\n', '        uint256 reward = calcReward(amount);\n', '\n', '        if(address(this).balance < reward) {\n', '            //If not enough money to fill request, handle it partially\n', '            reward = address(this).balance;\n', '            amount = reward.mul(rate);\n', '        }\n', '\n', '        require(token.transferFrom(msg.sender, address(this), amount));\n', '        msg.sender.transfer(reward);\n', '        emit Buyback(msg.sender, amount, reward);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates how much ETH somebody can receive for selling amount BOB\n', '     * @param amount How much tokens to sell\n', '     */\n', '    function calcReward(uint256 amount) view public returns(uint256) {\n', '        if(rate == 0) return 0;     //Handle situation when no Buyback is planned\n', '        return amount.div(rate);    //This operation may result in rounding. Which is fine here (rounded  amount < rate / 10**18)\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates how much BOB tokens this contract can buy (during current buyback round)\n', '     */\n', '    function calcTokensAvailableToBuyback() view public returns(uint256) {\n', '        return address(this).balance.mul(rate);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if Buyback round is running\n', '     */\n', '    function isRunning() view public returns(bool) {\n', '        return (rate > 0) && (now >= roundStartTime) && (address(this).balance > 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Changes buyback parameters\n', '     * @param _maxGasPrice Max gas price one ca use to sell is tokens. \n', '     * @param _maxTxValue Max amount of tokens to sell in one transaction\n', '     */\n', '    function setup(uint256 _maxGasPrice, uint256 _maxTxValue) onlyOwner external {\n', '        maxGasPrice = _maxGasPrice;\n', '        maxTxValue = _maxTxValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Starts buyback at specified time, with specified rate\n', '     * @param _roundStartTime Time when Buyback round starts\n', '     * @param _rate Rate of current Buyback round (1 ETH = rate BOB). Zero means no buyback is planned.\n', '     */\n', '    function startBuyback(uint256 _roundStartTime, uint256 _rate) onlyOwner external payable {\n', '        require(_roundStartTime > now);\n', '        roundStartTime = _roundStartTime;\n', '        rate = _rate;   //Rate is not required to be > 0\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all BOB tokens stored on the contract and send them to owner\n', '     */\n', '    function claimTokens() onlyOwner external {\n', '        require(token.transfer(owner, token.balanceOf(address(this))));\n', '    }\n', '    /**\n', '     * @notice Claim some of tokens stored on the contract\n', '     * @param amount How much tokens to claim\n', '     * @param beneficiary Who to send this tokens\n', '     */\n', '    function claimTokens(uint256 amount, address beneficiary) onlyOwner external {\n', '        require(token.transfer(beneficiary, amount));\n', '    }\n', '\n', '    /**\n', '    * @notice Transfer all Ether held by the contract to the owner.\n', '    */\n', '    function reclaimEther()  onlyOwner external {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '}']
