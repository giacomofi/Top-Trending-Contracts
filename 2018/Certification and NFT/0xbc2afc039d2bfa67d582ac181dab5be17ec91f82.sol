['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Genetic.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.23;\n', '\n', '\n', 'contract Genetic {\n', '\n', '    // TODO mutations\n', '    // maximum number of random mutations per chromatid\n', '    uint8 public constant R = 5;\n', '\n', '    // solhint-disable-next-line function-max-lines\n', '    function breed(uint256[2] mother, uint256[2] father, uint256 seed) internal view returns (uint256[2] memOffset) {\n', '        // Meiosis I: recombining alleles (Chromosomal crossovers)\n', '\n', '        // Note about optimization I: no cell duplication,\n', '        //  producing 2 seeds/eggs per cell is enough, instead of 4 (like humans do)\n', '\n', '        // Note about optimization II: crossovers happen,\n', '        //  but only 1 side of the result is computed,\n', '        //  as the other side will not affect anything.\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // allocate output\n', '            // 1) get the pointer to our memory\n', '            memOffset := mload(0x40)\n', '            // 2) Change the free-memory pointer to keep our memory\n', '            //     (we will only use 64 bytes: 2 values of 256 bits)\n', '            mstore(0x40, add(memOffset, 64))\n', '\n', '\n', '            // Put seed in scratchpad 0\n', '            mstore(0x0, seed)\n', '            // Also use the timestamp, best we could do to increase randomness\n', '            //  without increasing costs dramatically. (Trade-off)\n', '            mstore(0x20, timestamp)\n', '\n', '            // Hash it for a universally random bitstring.\n', '            let hash := keccak256(0, 64)\n', '\n', '            // Byzantium VM does not support shift opcodes, will be introduced in Constantinople.\n', '            // Soldity itself, in non-assembly, also just uses other opcodes to simulate it.\n', '            // Optmizer should take care of inlining, just declare shiftR ourselves here.\n', '            // Where possible, better optimization is applied to make it cheaper.\n', '            function shiftR(value, offset) -> result {\n', '                result := div(value, exp(2, offset))\n', '            }\n', '\n', '            // solhint-disable max-line-length\n', '            // m_context << Instruction::SWAP1 << u256(2) << Instruction::EXP << Instruction::SWAP1 << (c_leftSigned ? Instruction::SDIV : Instruction::DIV);\n', '\n', '            // optimization: although one side consists of multiple chromatids,\n', '            //  we handle them just as one long chromatid:\n', '            //  only difference is that a crossover in chromatid i affects chromatid i+1.\n', '            //  No big deal, order and location is random anyway\n', '            function processSide(fatherSrc, motherSrc, rngSrc) -> result {\n', '\n', '                {\n', '                    // initial rngSrc bit length: 254 bits\n', '\n', '                    // Run the crossovers\n', '                    // =====================================================\n', '\n', '                    // Pick some crossovers\n', '                    // Each crossover is spaced ~64 bits on average.\n', '                    // To achieve this, we get a random 7 bit number, [0, 128), for each crossover.\n', '\n', '                    // 256 / 64 = 4, we need 4 crossovers,\n', '                    //  and will have 256 / 127 = 2 at least (rounded down).\n', '\n', '                    // Get one bit determining if we should pick DNA from the father,\n', '                    //  or from the mother.\n', '                    // This changes every crossover. (by swapping father and mother)\n', '                    {\n', '                        if eq(and(rngSrc, 0x1), 0) {\n', '                            // Swap mother and father,\n', '                            // create a temporary variable (code golf XOR swap costs more in gas)\n', '                            let temp := fatherSrc\n', '                            fatherSrc := motherSrc\n', '                            motherSrc := temp\n', '                        }\n', '\n', '                        // remove the bit from rng source, 253 rng bits left\n', '                        rngSrc := shiftR(rngSrc, 1)\n', '                    }\n', '\n', '                    // Don&#39;t push/pop this all the time, we have just enough space on stack.\n', '                    let mask := 0\n', '\n', '                    // Cap at 4 crossovers, no more than that.\n', '                    let cap := 0\n', '                    let crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\n', '                    // remove bits from hash, e.g. 254 - 7 = 247 left.\n', '                    rngSrc := shiftR(rngSrc, 7)\n', '                    let crossoverPos := crossoverLen\n', '\n', '                    // optimization: instead of shifting with an opcode we don&#39;t have until Constantinople,\n', '                    //  keep track of the a shifted number, updated using multiplications.\n', '                    let crossoverPosLeading1 := 1\n', '\n', '                    // solhint-disable-next-line no-empty-blocks\n', '                    for { } and(lt(crossoverPos, 256), lt(cap, 4)) {\n', '\n', '                        crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\n', '                        // remove bits from hash, e.g. 254 - 7 = 247 left.\n', '                        rngSrc := shiftR(rngSrc, 7)\n', '\n', '                        crossoverPos := add(crossoverPos, crossoverLen)\n', '\n', '                        cap := add(cap, 1)\n', '                    } {\n', '\n', '                        // Note: we go from right to left in the bit-string.\n', '\n', '                        // Create a mask for this crossover.\n', '                        // Example:\n', '                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\n', '                        // |Prev. data ||Crossover here  ||remaining data .......\n', '                        //\n', '                        // The crossover part is copied from the mother/father to the child.\n', '\n', '                        // Create the bit-mask\n', '                        // Create a bitstring that ignores the previous data:\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // First create a leading 1, just before the crossover, like:\n', '                        // 00000000000010000000000000000000000000000000000000000000000000000000000.....\n', '                        // Then substract 1, to get a long string of 1s\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // Now do the same for the remain part, and xor it.\n', '                        // leading 1\n', '                        // 00000000000000000000000000000010000000000000000000000000000000000000000000000000000000000.....\n', '                        // sub 1\n', '                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\n', '                        // xor with other\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\n', '                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\n', '\n', '                        // Use the final shifted 1 of the previous crossover as the start marker\n', '                        mask := sub(crossoverPosLeading1, 1)\n', '\n', '                        // update for this crossover, (and will be used as start for next crossover)\n', '                        crossoverPosLeading1 := mul(1, exp(2, crossoverPos))\n', '                        mask := xor(mask,\n', '                                    sub(crossoverPosLeading1, 1)\n', '                        )\n', '\n', '                        // Now add the parent data to the child genotype\n', '                        // E.g.\n', '                        // Mask:         00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000....\n', '                        // Parent:       10010111001000110101011111001010001011100000000000010011000001000100000001011101111000111....\n', '                        // Child (pre):  00000000000000000000000000000001111110100101111111000011001010000000101010100000110110110....\n', '                        // Child (post): 00000000000000110101011111001011111110100101111111000011001010000000101010100000110110110....\n', '\n', '                        // To do this, we run: child_post = child_pre | (mask & father)\n', '                        result := or(result, and(mask, fatherSrc))\n', '\n', '                        // Swap father and mother, next crossover will take a string from the other.\n', '                        let temp := fatherSrc\n', '                        fatherSrc := motherSrc\n', '                        motherSrc := temp\n', '                    }\n', '\n', '                    // We still have a left-over part that was not copied yet\n', '                    // E.g., we have something like:\n', '                    // Father: |            xxxxxxxxxxxxxxxxxxx          xxxxxxxxxxxxxxxxxxxxxxxx            ....\n', '                    // Mother: |############                   xxxxxxxxxx                        xxxxxxxxxxxx....\n', '                    // Child:  |            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx....\n', '                    // The ############ still needs to be applied to the child, also,\n', '                    //  this can be done cheaper than in the loop above,\n', '                    //  as we don&#39;t have to swap anything for the next crossover or something.\n', '\n', '                    // At this point we have to assume 4 crossovers ran,\n', '                    //  and that we only have 127 - 1 - (4 * 7) = 98 bits of randomness left.\n', '                    // We stopped at the bit after the crossoverPos index, see "x":\n', '                    // 000000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....\n', '                    // now create a leading 1 at crossoverPos like:\n', '                    // 000000001000000000000000000000000000000000000000000000000000000000000000000.....\n', '                    // Sub 1, get the mask for what we had.\n', '                    // 000000000111111111111111111111111111111111111111111111111111111111111111111.....\n', '                    // Invert, and we have the final mask:\n', '                    // 111111111000000000000000000000000000000000000000000000000000000000000000000.....\n', '                    mask := not(sub(crossoverPosLeading1, 1))\n', '                    // Apply it to the result\n', '                    result := or(result, and(mask, fatherSrc))\n', '\n', '                    // Random mutations\n', '                    // =====================================================\n', '\n', '                    // random mutations\n', '                    // Put rng source in scratchpad 0\n', '                    mstore(0x0, rngSrc)\n', '                    // And some arbitrary padding in scratchpad 1,\n', '                    //  used to create different hashes based on input size changes\n', '                    mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\n', '                    // Hash it for a universally random bitstring.\n', '                    // Then reduce the number of 1s by AND-ing it with other *different* hashes.\n', '                    // Each bit in mutations has a probability of 0.5^5 = 0.03125 = 3.125% to be a 1\n', '                    let mutations := and(\n', '                            and(\n', '                                and(keccak256(0, 32), keccak256(1, 33)),\n', '                                and(keccak256(2, 34), keccak256(3, 35))\n', '                            ),\n', '                            keccak256(0, 36)\n', '                    )\n', '\n', '                    result := xor(result, mutations)\n', '\n', '                }\n', '            }\n', '\n', '\n', '            {\n', '\n', '                // Get 1 bit of pseudo randomness that will\n', '                //  determine if side #1 will come from the left, or right side.\n', '                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\n', '                let relativeFatherSideLoc := mul(and(hash, 0x1), 0x20) // shift by 5 bits = mul by 2^5=32 (0x20)\n', '                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\n', '                let relativeMotherSideLoc := mul(and(hash, 0x2), 0x10) // already shifted by 1, mul by 2^4=16 (0x10)\n', '\n', '                // Now remove the used 2 bits from the hash, 254 bits remaining now.\n', '                hash := div(hash, 4)\n', '\n', '                // Process the side, load the relevant parent data that will be used.\n', '                mstore(memOffset, processSide(\n', '                    mload(add(father, relativeFatherSideLoc)),\n', '                    mload(add(mother, relativeMotherSideLoc)),\n', '                    hash\n', '                ))\n', '\n', '                // The other side will be the opposite index: 1 -> 0, 0 -> 1\n', '                // Apply it to the location,\n', '                //  which is either 0x20 (For index 1) or 0x0 for index 0.\n', '                relativeFatherSideLoc := xor(relativeFatherSideLoc, 0x20)\n', '                relativeMotherSideLoc := xor(relativeMotherSideLoc, 0x20)\n', '\n', '                mstore(0x0, seed)\n', '                // Second argument will be inverse,\n', '                //  resulting in a different second hash.\n', '                mstore(0x20, not(timestamp))\n', '\n', '                // Now create another hash, for the other side\n', '                hash := keccak256(0, 64)\n', '\n', '                // Process the other side\n', '                mstore(add(memOffset, 0x20), processSide(\n', '                    mload(add(father, relativeFatherSideLoc)),\n', '                    mload(add(mother, relativeMotherSideLoc)),\n', '                    hash\n', '                ))\n', '\n', '            }\n', '\n', '        }\n', '\n', '        // Sample input:\n', '        // ["0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC","0x4444444455555555555555556666666666666644444444455555555555666666"]\n', '        //\n', '        // ["0x1111111111112222222223333311111111122222223333333331111112222222","0x7777788888888888999999999999977777777777788888888888999999997777"]\n', '\n', '        // Expected results (or similar, depends on the seed):\n', '        // 0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC < Father side A\n', '        // 0x4444444455555555555555556666666666666644444444455555555555666666 < Father side B\n', '\n', '        // 0x1111111111112222222223333311111111122222223333333331111112222222 < Mother side A\n', '        // 0x7777788888888888999999999999977777777777788888888888999999997777 < Mother side B\n', '\n', '        //   xxxxxxxxxxxxxxxxx           xxxxxxxxx                         xx\n', '        // 0xAAABBBBBBBBCCCCCD99999999998BBBBBBBBF77778888888888899999999774C < Child side A\n', '        //   xxx                       xxxxxxxxxxx\n', '        // 0x4441111111112222222223333366666666666222223333333331111112222222 < Child side B\n', '\n', '        // And then random mutations, for gene pool expansion.\n', '        // Each bit is flipped with a 3.125% chance\n', '\n', '        // Example:\n', '        //a2c37edc61dca0ca0b199e098c80fd5a221c2ad03605b4b54332361358745042 < random hash 1\n', '        //c217d04b19a83fe497c1cf6e1e10030e455a0812a6949282feec27d67fe2baa7 < random hash 2\n', '        //2636a55f38bed26d804c63a13628e21b2d701c902ca37b2b0ca94fada3821364 < random hash 3\n', '        //86bb023a85e2da50ac233b946346a53aa070943b0a8e91c56e42ba181729a5f9 < random hash 4\n', '        //5d71456a1288ab30ddd4c955384d42e66a09d424bd7743791e3eab8e09aa13f1 < random hash 5\n', '        //0000000800800000000000000000000200000000000000000000020000000000 < resulting mutation\n', '        //aaabbbbbbbbcccccd99999999998bbbbbbbbf77778888888888899999999774c < original\n', '        //aaabbbb3bb3cccccd99999999998bbb9bbbbf7777888888888889b999999774c < mutated (= original XOR mutation)\n', '    }\n', '\n', '    // Generates (psuedo) random Pepe DNA\n', '    function randomDNA(uint256 seed) internal pure returns (uint256[2] memOffset) {\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // allocate output\n', '            // 1) get the pointer to our memory\n', '            memOffset := mload(0x40)\n', '            // 2) Change the free-memory pointer to keep our memory\n', '            //     (we will only use 64 bytes: 2 values of 256 bits)\n', '            mstore(0x40, add(memOffset, 64))\n', '\n', '            // Load the seed into 1st scratchpad memory slot.\n', '            // adjacent to the additional value (used to create two distinct hashes)\n', '            mstore(0x0, seed)\n', '\n', '            // In second scratchpad slot:\n', '            // The additional value can be any word, as long as the caller uses\n', '            //  it (second hash needs to be different)\n', '            mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\n', '\n', '\n', '            // // Create first element pointer of array\n', '            // mstore(memOffset, add(memOffset, 64)) // pointer 1\n', '            // mstore(add(memOffset, 32), add(memOffset, 96)) // pointer 2\n', '\n', '            // control block to auto-pop the hash.\n', '            {\n', '                // L * N * 2 * 4 = 4 * 2 * 2 * 4 = 64 bytes, 2x 256 bit hash\n', '\n', '                // Sha3 is cheaper than sha256, make use of it\n', '                let hash := keccak256(0, 64)\n', '\n', '                // Store first array value\n', '                mstore(memOffset, hash)\n', '\n', '                // Now hash again, but only 32 bytes of input,\n', '                //  to ignore make the input different than the previous call,\n', '                hash := keccak256(0, 32)\n', '                mstore(add(memOffset, 32), hash)\n', '\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Usernames.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', 'contract Usernames {\n', '\n', '    mapping(address => bytes32) public addressToUser;\n', '    mapping(bytes32 => address) public userToAddress;\n', '\n', '    event UserNamed(address indexed user, bytes32 indexed username);\n', '\n', '    /**\n', '     * Claim a username. Frees up a previously used one\n', '     * @param _username to claim\n', '     */\n', '    function claimUsername(bytes32 _username) external {\n', '        require(userToAddress[_username] == address(0));// Username must be free\n', '\n', '        if (addressToUser[msg.sender] != bytes32(0)) { // If user already has username free it up\n', '            userToAddress[addressToUser[msg.sender]] = address(0);\n', '        }\n', '\n', '        //all is well assign username\n', '        addressToUser[msg.sender] = _username;\n', '        userToAddress[_username] = msg.sender;\n', '\n', '        emit UserNamed(msg.sender, _username);\n', '\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Beneficiary.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/** @title Beneficiary */\n', 'contract Beneficiary is Ownable {\n', '    address public beneficiary;\n', '\n', '    constructor() public {\n', '        beneficiary = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Change the beneficiary address\n', '     * @param _beneficiary Address of the new beneficiary\n', '     */\n', '    function setBeneficiary(address _beneficiary) public onlyOwner {\n', '        beneficiary = _beneficiary;\n', '    }\n', '}\n', '\n', '// File: contracts/Affiliate.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', '\n', '/** @title Affiliate */\n', 'contract Affiliate is Ownable {\n', '    mapping(address => bool) public canSetAffiliate;\n', '    mapping(address => address) public userToAffiliate;\n', '\n', '    /** @dev Allows an address to set the affiliate address for a user\n', '      * @param _setter The address that should be allowed\n', '      */\n', '    function setAffiliateSetter(address _setter) public onlyOwner {\n', '        canSetAffiliate[_setter] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the affiliate of a user\n', '     * @param _user user to set affiliate for\n', '     * @param _affiliate address to set\n', '     */\n', '    function setAffiliate(address _user, address _affiliate) public {\n', '        require(canSetAffiliate[msg.sender]);\n', '        if (userToAffiliate[_user] == address(0)) {\n', '            userToAffiliate[_user] = _affiliate;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/interfaces/ERC721.sol\n', '\n', 'contract ERC721 {\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) ;\n', '    function transfer(address _to, uint256 _tokenId) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '// File: contracts/interfaces/PepeInterface.sol\n', '\n', 'contract PepeInterface is ERC721{\n', '    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) public returns (bool);\n', '    function getCozyAgain(uint256 _pepeId) public view returns(uint64);\n', '}\n', '\n', '// File: contracts/AuctionBase.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '/** @title AuctionBase */\n', 'contract AuctionBase is Beneficiary {\n', '    mapping(uint256 => PepeAuction) public auctions;//maps pepes to auctions\n', '    PepeInterface public pepeContract;\n', '    Affiliate public affiliateContract;\n', '    uint256 public fee = 37500; //in 1 10000th of a percent so 3.75% at the start\n', '    uint256 public constant FEE_DIVIDER = 1000000; //Perhaps needs better name?\n', '\n', '    struct PepeAuction {\n', '        address seller;\n', '        uint256 pepeId;\n', '        uint64 auctionBegin;\n', '        uint64 auctionEnd;\n', '        uint256 beginPrice;\n', '        uint256 endPrice;\n', '    }\n', '\n', '    event AuctionWon(uint256 indexed pepe, address indexed winner, address indexed seller);\n', '    event AuctionStarted(uint256 indexed pepe, address indexed seller);\n', '    event AuctionFinalized(uint256 indexed pepe, address indexed seller);\n', '\n', '    constructor(address _pepeContract, address _affiliateContract) public {\n', '        pepeContract = PepeInterface(_pepeContract);\n', '        affiliateContract = Affiliate(_affiliateContract);\n', '    }\n', '\n', '    /**\n', '     * @dev Return a pepe from a auction that has passed\n', '     * @param  _pepeId the id of the pepe to save\n', '     */\n', '    function savePepe(uint256 _pepeId) external {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(auctions[_pepeId].auctionEnd < now);//auction must have ended\n', '        require(pepeContract.transfer(auctions[_pepeId].seller, _pepeId));//transfer pepe back to seller\n', '\n', '        emit AuctionFinalized(_pepeId, auctions[_pepeId].seller);\n', '\n', '        delete auctions[_pepeId];//delete auction\n', '    }\n', '\n', '    /**\n', '     * @dev change the fee on pepe sales. Can only be lowerred\n', '     * @param _fee The new fee to set. Must be lower than current fee\n', '     */\n', '    function changeFee(uint256 _fee) external onlyOwner {\n', '        require(_fee < fee);//fee can not be raised\n', '        fee = _fee;\n', '    }\n', '\n', '    /**\n', '     * @dev Start a auction\n', '     * @param  _pepeId Pepe to sell\n', '     * @param  _beginPrice Price at which the auction starts\n', '     * @param  _endPrice Ending price of the auction\n', '     * @param  _duration How long the auction should take\n', '     */\n', '    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\n', '        require(pepeContract.transferFrom(msg.sender, address(this), _pepeId));\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\n', '\n', '        PepeAuction memory auction;\n', '\n', '        auction.seller = msg.sender;\n', '        auction.pepeId = _pepeId;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionBegin = uint64(now);\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionEnd = uint64(now) + _duration;\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.beginPrice = _beginPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_pepeId] = auction;\n', '\n', '        emit AuctionStarted(_pepeId, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev directly start a auction from the PepeBase contract\n', '     * @param  _pepeId Pepe to put on auction\n', '     * @param  _beginPrice Price at which the auction starts\n', '     * @param  _endPrice Ending price of the auction\n', '     * @param  _duration How long the auction should take\n', '     * @param  _seller The address selling the pepe\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\n', '        require(msg.sender == address(pepeContract)); //can only be called by pepeContract\n', '        //solhint-disable-next-line not-rely-on-time\n', '        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\n', '\n', '        PepeAuction memory auction;\n', '\n', '        auction.seller = _seller;\n', '        auction.pepeId = _pepeId;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionBegin = uint64(now);\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionEnd = uint64(now) + _duration;\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.beginPrice = _beginPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_pepeId] = auction;\n', '\n', '        emit AuctionStarted(_pepeId, _seller);\n', '    }\n', '\n', '  /**\n', '   * @dev Calculate the current price of a auction\n', '   * @param  _pepeId the pepeID to calculate the current price for\n', '   * @return currentBid the current price for the auction\n', '   */\n', '    function calculateBid(uint256 _pepeId) public view returns(uint256 currentBid) {\n', '        PepeAuction storage auction = auctions[_pepeId];\n', '        // solhint-disable-next-line not-rely-on-time\n', '        uint256 timePassed = now - auctions[_pepeId].auctionBegin;\n', '\n', '        // If auction ended return auction end price.\n', '        // solhint-disable-next-line not-rely-on-time\n', '        if (now >= auction.auctionEnd) {\n', '            return auction.endPrice;\n', '        } else {\n', '            // Can be negative\n', '            int256 priceDifference = int256(auction.endPrice) - int256(auction.beginPrice);\n', '            // Always positive\n', '            int256 duration = int256(auction.auctionEnd) - int256(auction.auctionBegin);\n', '\n', '            // As already proven in practice by CryptoKitties:\n', '            //  timePassed -> 64 bits at most\n', '            //  priceDifference -> 128 bits at most\n', '            //  timePassed * priceDifference -> 64 + 128 bits at most\n', '            int256 priceChange = priceDifference * int256(timePassed) / duration;\n', '\n', '            // Will be positive, both operands are less than 256 bits\n', '            int256 price = int256(auction.beginPrice) + priceChange;\n', '\n', '            return uint256(price);\n', '        }\n', '    }\n', '\n', '  /**\n', '   * @dev collect the fees from the auction\n', '   */\n', '    function getFees() public {\n', '        beneficiary.transfer(address(this).balance);\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/CozyTimeAuction.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/** @title CozyTimeAuction */\n', 'contract CozyTimeAuction is AuctionBase {\n', '    // solhint-disable-next-line\n', '    constructor (address _pepeContract, address _affiliateContract) AuctionBase(_pepeContract, _affiliateContract) public {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Start an auction\n', '     * @param  _pepeId The id of the pepe to start the auction for\n', '     * @param  _beginPrice Start price of the auction\n', '     * @param  _endPrice End price of the auction\n', '     * @param  _duration How long the auction should take\n', '     */\n', '    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\n', '        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);\n', '    }\n', '\n', '    /**\n', '     * @dev Start a auction direclty from the PepeBase smartcontract\n', '     * @param  _pepeId The id of the pepe to start the auction for\n', '     * @param  _beginPrice Start price of the auction\n', '     * @param  _endPrice End price of the auction\n', '     * @param  _duration How long the auction should take\n', '     * @param  _seller The address of the seller\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\n', '        super.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, _seller);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy cozy right from the auction\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _cozyCandidate the pepe to cozy with\n', '     * @param  _candidateAsFather Is the _cozyCandidate father?\n', '     * @param  _pepeReceiver address receiving the pepe after cozy time\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function buyCozy(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver) public payable {\n', '        require(address(pepeContract) == msg.sender); //caller needs to be the PepeBase contract\n', '\n', '        PepeAuction storage auction = auctions[_pepeId];\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now < auction.auctionEnd);// auction must be still going\n', '\n', '        uint256 price = calculateBid(_pepeId);\n', '        require(msg.value >= price);//must send enough ether\n', '        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\n', '\n', '        //Send ETH to seller\n', '        auction.seller.transfer(price - totalFee);\n', '        //send ETH to beneficiary\n', '\n', '        address affiliate = affiliateContract.userToAffiliate(_pepeReceiver);\n', '\n', '        //solhint-disable-next-line\n', '        if (affiliate != address(0) && affiliate.send(totalFee / 2)) { //if user has affiliate\n', '            //nothing just to suppress warning\n', '        }\n', '\n', '        //actual cozytiming\n', '        if (_candidateAsFather) {\n', '            if (!pepeContract.cozyTime(auction.pepeId, _cozyCandidate, _pepeReceiver)) {\n', '                revert();\n', '            }\n', '        } else {\n', '          // Swap around the two pepes, they have no set gender, the user decides what they are.\n', '            if (!pepeContract.cozyTime(_cozyCandidate, auction.pepeId, _pepeReceiver)) {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        //Send pepe to seller of auction\n', '        if (!pepeContract.transfer(auction.seller, _pepeId)) {\n', '            revert(); //can&#39;t complete transfer if this fails\n', '        }\n', '\n', '        if (msg.value > price) { //return ether send to much\n', '            _pepeReceiver.transfer(msg.value - price);\n', '        }\n', '\n', '        emit AuctionWon(_pepeId, _pepeReceiver, auction.seller);//emit event\n', '\n', '        delete auctions[_pepeId];//deletes auction\n', '    }\n', '\n', '    /**\n', '     * @dev Buy cozytime and pass along affiliate\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _cozyCandidate the pepe to cozy with\n', '     * @param  _candidateAsFather Is the _cozyCandidate father?\n', '     * @param  _pepeReceiver address receiving the pepe after cozy time\n', '     * @param  _affiliate Affiliate address to set\n', '     */\n', '    //solhint-disable-next-line max-line-length\n', '    function buyCozyAffiliated(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver, address _affiliate) public payable {\n', '        affiliateContract.setAffiliate(_pepeReceiver, _affiliate);\n', '        buyCozy(_pepeId, _cozyCandidate, _candidateAsFather, _pepeReceiver);\n', '    }\n', '}\n', '\n', '// File: contracts/Haltable.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Haltable is Ownable {\n', '    uint256 public haltTime; //when the contract was halted\n', '    bool public halted;//is the contract halted?\n', '    uint256 public haltDuration;\n', '    uint256 public maxHaltDuration = 8 weeks;//how long the contract can be halted\n', '\n', '    modifier stopWhenHalted {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenHalted {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Halt the contract for a set time smaller than maxHaltDuration\n', '     * @param  _duration Duration how long the contract should be halted. Must be smaller than maxHaltDuration\n', '     */\n', '    function halt(uint256 _duration) public onlyOwner {\n', '        require(haltTime == 0); //cannot halt if it was halted before\n', '        require(_duration <= maxHaltDuration);//cannot halt for longer than maxHaltDuration\n', '        haltDuration = _duration;\n', '        halted = true;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        haltTime = now;\n', '    }\n', '\n', '    /**\n', '     * @dev Unhalt the contract. Can only be called by the owner or when the haltTime has passed\n', '     */\n', '    function unhalt() public {\n', '        // solhint-disable-next-line\n', '        require(now > haltTime + haltDuration || msg.sender == owner);//unhalting is only possible when haltTime has passed or the owner unhalts\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/ERC721TokenReceiver.sol\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '// File: contracts/PepeBase.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '// solhint-disable func-order\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PepeBase is Genetic, Ownable, Usernames, Haltable {\n', '\n', '    uint32[15] public cozyCoolDowns = [ //determined by generation / 2\n', '        uint32(1 minutes),\n', '        uint32(2 minutes),\n', '        uint32(5 minutes),\n', '        uint32(15 minutes),\n', '        uint32(30 minutes),\n', '        uint32(45 minutes),\n', '        uint32(1 hours),\n', '        uint32(2 hours),\n', '        uint32(4 hours),\n', '        uint32(8 hours),\n', '        uint32(16 hours),\n', '        uint32(1 days),\n', '        uint32(2 days),\n', '        uint32(4 days),\n', '        uint32(7 days)\n', '    ];\n', '\n', '    struct Pepe {\n', '        address master; //The master of the pepe\n', '        uint256[2] genotype; //all genes stored here\n', '        uint64 canCozyAgain; //time when pepe can have nice time again\n', '        uint64 generation; //what generation?\n', '        uint64 father; //father of this pepe\n', '        uint64 mother; //mommy of this pepe\n', '        uint8 coolDownIndex;\n', '    }\n', '\n', '    mapping(uint256 => bytes32) public pepeNames;\n', '\n', '    //stores all pepes\n', '    Pepe[] public pepes;\n', '\n', '    bool public implementsERC721 = true; //signal erc721 support\n', '\n', '    // solhint-disable-next-line const-name-snakecase\n', '    string public constant name = "Crypto Pepe";\n', '    // solhint-disable-next-line const-name-snakecase\n', '    string public constant symbol = "CPEP";\n', '\n', '    mapping(address => uint256[]) private wallets;\n', '    mapping(address => uint256) public balances; //amounts of pepes per address\n', '    mapping(uint256 => address) public approved; //pepe index to address approved to transfer\n', '    mapping(address => mapping(address => bool)) public approvedForAll;\n', '\n', '    uint256 public zeroGenPepes; //how many zero gen pepes are mined\n', '    uint256 public constant MAX_PREMINE = 100;//how many pepes can be premined\n', '    uint256 public constant MAX_ZERO_GEN_PEPES = 1100; //max number of zero gen pepes\n', '    address public miner; //address of the miner contract\n', '\n', '    modifier onlyPepeMaster(uint256 _pepeId) {\n', '        require(pepes[_pepeId].master == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed(uint256 _tokenId) {\n', '        // solhint-disable-next-line max-line-length\n', '        require(msg.sender == pepes[_tokenId].master || msg.sender == approved[_tokenId] || approvedForAll[pepes[_tokenId].master][msg.sender]); //check if msg.sender is allowed\n', '        _;\n', '    }\n', '\n', '    event PepeBorn(uint256 indexed mother, uint256 indexed father, uint256 indexed pepeId);\n', '    event PepeNamed(uint256 indexed pepeId);\n', '\n', '    constructor() public {\n', '\n', '        Pepe memory pepe0 = Pepe({\n', '            master: 0x0,\n', '            genotype: [uint256(0), uint256(0)],\n', '            canCozyAgain: 0,\n', '            father: 0,\n', '            mother: 0,\n', '            generation: 0,\n', '            coolDownIndex: 0\n', '        });\n', '\n', '        pepes.push(pepe0);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that creates a new pepe\n', '     * @param  _genoType DNA of the new pepe\n', '     * @param  _mother The ID of the mother\n', '     * @param  _father The ID of the father\n', '     * @param  _generation The generation of the new Pepe\n', '     * @param  _master The owner of this new Pepe\n', '     * @return The ID of the newly generated Pepe\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function _newPepe(uint256[2] _genoType, uint64 _mother, uint64 _father, uint64 _generation, address _master) internal returns (uint256 pepeId) {\n', '        uint8 tempCoolDownIndex;\n', '\n', '        tempCoolDownIndex = uint8(_generation / 2);\n', '\n', '        if (_generation > 28) {\n', '            tempCoolDownIndex = 14;\n', '        }\n', '\n', '        Pepe memory _pepe = Pepe({\n', '            master: _master, //The master of the pepe\n', '            genotype: _genoType, //all genes stored here\n', '            canCozyAgain: 0, //time when pepe can have nice time again\n', '            father: _father, //father of this pepe\n', '            mother: _mother, //mommy of this pepe\n', '            generation: _generation, //what generation?\n', '            coolDownIndex: tempCoolDownIndex\n', '        });\n', '\n', '        if (_generation == 0) {\n', '            zeroGenPepes += 1; //count zero gen pepes\n', '        }\n', '\n', '        //push returns the new length, use it to get a new unique id\n', '        pepeId = pepes.push(_pepe) - 1;\n', '\n', '        //add it to the wallet of the master of the new pepe\n', '        addToWallet(_master, pepeId);\n', '\n', '        emit PepeBorn(_mother, _father, pepeId);\n', '        emit Transfer(address(0), _master, pepeId);\n', '\n', '        return pepeId;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the miner contract. Can only be called once\n', '     * @param _miner Address of the miner contract\n', '     */\n', '    function setMiner(address _miner) public onlyOwner {\n', '        require(miner == address(0));//can only be set once\n', '        miner = _miner;\n', '    }\n', '\n', '    /**\n', '     * @dev Mine a new Pepe. Can only be called by the miner contract.\n', '     * @param  _seed Seed to be used for the generation of the DNA\n', '     * @param  _receiver Address receiving the newly mined Pepe\n', '     * @return The ID of the newly mined Pepe\n', '     */\n', '    function minePepe(uint256 _seed, address _receiver) public stopWhenHalted returns(uint256) {\n', '        require(msg.sender == miner);//only miner contract can call\n', '        require(zeroGenPepes < MAX_ZERO_GEN_PEPES);\n', '\n', '        return _newPepe(randomDNA(_seed), 0, 0, 0, _receiver);\n', '    }\n', '\n', '    /**\n', '     * @dev Premine pepes. Can only be called by the owner and is limited to MAX_PREMINE\n', '     * @param  _amount Amount of Pepes to premine\n', '     */\n', '    function pepePremine(uint256 _amount) public onlyOwner stopWhenHalted {\n', '        for (uint i = 0; i < _amount; i++) {\n', '            require(zeroGenPepes <= MAX_PREMINE);//can only generate set amount during premine\n', '            //create a new pepe\n', '            // 1) who&#39;s genes are based on hash of the timestamp and the number of pepes\n', '            // 2) who has no mother or father\n', '            // 3) who is generation zero\n', '            // 4) who&#39;s master is the manager\n', '\n', '            // solhint-disable-next-line\n', '            _newPepe(randomDNA(uint256(keccak256(abi.encodePacked(block.timestamp, pepes.length)))), 0, 0, 0, owner);\n', '\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev CozyTime two Pepes together\n', '     * @param  _mother The mother of the new Pepe\n', '     * @param  _father The father of the new Pepe\n', '     * @param  _pepeReceiver Address receiving the new Pepe\n', '     * @return If it was a success\n', '     */\n', '    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) external stopWhenHalted returns (bool) {\n', '        //cannot cozyTime with itself\n', '        require(_mother != _father);\n', '        //caller has to either be master or approved for mother\n', '        // solhint-disable-next-line max-line-length\n', '        require(pepes[_mother].master == msg.sender || approved[_mother] == msg.sender || approvedForAll[pepes[_mother].master][msg.sender]);\n', '        //caller has to either be master or approved for father\n', '        // solhint-disable-next-line max-line-length\n', '        require(pepes[_father].master == msg.sender || approved[_father] == msg.sender || approvedForAll[pepes[_father].master][msg.sender]);\n', '        //require both parents to be ready for cozytime\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > pepes[_mother].canCozyAgain && now > pepes[_father].canCozyAgain);\n', '        //require both mother parents not to be father\n', '        require(pepes[_mother].mother != _father && pepes[_mother].father != _father);\n', '        //require both father parents not to be mother\n', '        require(pepes[_father].mother != _mother && pepes[_father].father != _mother);\n', '\n', '        Pepe storage father = pepes[_father];\n', '        Pepe storage mother = pepes[_mother];\n', '\n', '\n', '        approved[_father] = address(0);\n', '        approved[_mother] = address(0);\n', '\n', '        uint256[2] memory newGenotype = breed(father.genotype, mother.genotype, pepes.length);\n', '\n', '        uint64 newGeneration;\n', '\n', '        newGeneration = mother.generation + 1;\n', '        if (newGeneration < father.generation + 1) { //if father generation is bigger\n', '            newGeneration = father.generation + 1;\n', '        }\n', '\n', '        _handleCoolDown(_mother);\n', '        _handleCoolDown(_father);\n', '\n', '        //sets pepe birth when mother is done\n', '        // solhint-disable-next-line max-line-length\n', '        pepes[_newPepe(newGenotype, uint64(_mother), uint64(_father), newGeneration, _pepeReceiver)].canCozyAgain = mother.canCozyAgain; //_pepeReceiver becomes the master of the pepe\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to increase the coolDownIndex\n', '     * @param _pepeId The id of the Pepe to update the coolDown of\n', '     */\n', '    function _handleCoolDown(uint256 _pepeId) internal {\n', '        Pepe storage tempPep = pepes[_pepeId];\n', '\n', '        // solhint-disable-next-line not-rely-on-time\n', '        tempPep.canCozyAgain = uint64(now + cozyCoolDowns[tempPep.coolDownIndex]);\n', '\n', '        if (tempPep.coolDownIndex < 14) {// after every cozy time pepe gets slower\n', '            tempPep.coolDownIndex++;\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Set the name of a Pepe. Can only be set once\n', '     * @param _pepeId ID of the pepe to name\n', '     * @param _name The name to assign\n', '     */\n', '    function setPepeName(uint256 _pepeId, bytes32 _name) public stopWhenHalted onlyPepeMaster(_pepeId) returns(bool) {\n', '        require(pepeNames[_pepeId] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n', '        pepeNames[_pepeId] = _name;\n', '        emit PepeNamed(_pepeId);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer a Pepe to the auction contract and auction it\n', '     * @param  _pepeId ID of the Pepe to auction\n', '     * @param  _auction Auction contract address\n', '     * @param  _beginPrice Price the auction starts at\n', '     * @param  _endPrice Price the auction ends at\n', '     * @param  _duration How long the auction should run\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function transferAndAuction(uint256 _pepeId, address _auction, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public stopWhenHalted onlyPepeMaster(_pepeId) {\n', '        _transfer(msg.sender, _auction, _pepeId);//transfer pepe to auction\n', '        AuctionBase auction = AuctionBase(_auction);\n', '\n', '        auction.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve and buy. Used to buy cozyTime in one call\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _auction Address of the auction contract\n', '     * @param  _cozyCandidate Pepe to approve and cozy with\n', '     * @param  _candidateAsFather Use the candidate as father or not\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function approveAndBuy(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\n', '        approved[_cozyCandidate] = _auction;\n', '        // solhint-disable-next-line max-line-length\n', '        CozyTimeAuction(_auction).buyCozy.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender); //breeding resets approval\n', '    }\n', '\n', '    /**\n', '     * @dev The same as above only pass an extra parameter\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _auction Address of the auction contract\n', '     * @param  _cozyCandidate Pepe to approve and cozy with\n', '     * @param  _candidateAsFather Use the candidate as father or not\n', '     * @param  _affiliate Address to set as affiliate\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function approveAndBuyAffiliated(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather, address _affiliate) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\n', '        approved[_cozyCandidate] = _auction;\n', '        // solhint-disable-next-line max-line-length\n', '        CozyTimeAuction(_auction).buyCozyAffiliated.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender, _affiliate); //breeding resets approval\n', '    }\n', '\n', '    /**\n', '     * @dev get Pepe information\n', '     * @param  _pepeId ID of the Pepe to get information of\n', '     * @return master\n', '     * @return genotype\n', '     * @return canCozyAgain\n', '     * @return generation\n', '     * @return father\n', '     * @return mother\n', '     * @return pepeName\n', '     * @return coolDownIndex\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function getPepe(uint256 _pepeId) public view returns(address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\n', '        Pepe storage tempPep = pepes[_pepeId];\n', '\n', '        master = tempPep.master;\n', '        genotype = tempPep.genotype;\n', '        canCozyAgain = tempPep.canCozyAgain;\n', '        generation = tempPep.generation;\n', '        father = tempPep.father;\n', '        mother = tempPep.mother;\n', '        pepeName = pepeNames[_pepeId];\n', '        coolDownIndex = tempPep.coolDownIndex;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the time when a pepe can cozy again\n', '     * @param  _pepeId ID of the pepe\n', '     * @return Time when the pepe can cozy again\n', '     */\n', '    function getCozyAgain(uint256 _pepeId) public view returns(uint64) {\n', '        return pepes[_pepeId].canCozyAgain;\n', '    }\n', '\n', '    /**\n', '     *  ERC721 Compatibility\n', '     *\n', '     */\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /**\n', '     * @dev Get the total number of Pepes\n', '     * @return total Returns the total number of pepes\n', '     */\n', '    function totalSupply() public view returns(uint256 total) {\n', '        total = pepes.length - balances[address(0)];\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of pepes owned by an address\n', '     * @param  _owner Address to get the balance from\n', '     * @return balance The number of pepes\n', '     */\n', '    function balanceOf(address _owner) external view returns (uint256 balance) {\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Get the owner of a Pepe\n', '     * @param  _tokenId the token to get the owner of\n', '     * @return _owner the owner of the pepe\n', '     */\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n', '        _owner = pepes[_tokenId].master;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the id of an token by its index\n', '     * @param _owner The address to look up the tokens of\n', '     * @param _index Index to look at\n', '     * @return tokenId the ID of the token of the owner at the specified index\n', '     */\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256 tokenId) {\n', '        //The index must be smaller than the balance,\n', '        // to guarantee that there is no leftover token returned.\n', '        require(_index < balances[_owner]);\n', '\n', '        return wallets[_owner][_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Private method that ads a token to the wallet\n', '     * @param _owner Address of the owner\n', '     * @param _tokenId Pepe ID to add\n', '     */\n', '    function addToWallet(address _owner, uint256 _tokenId) private {\n', '        uint256[] storage wallet = wallets[_owner];\n', '        uint256 balance = balances[_owner];\n', '        if (balance < wallet.length) {\n', '            wallet[balance] = _tokenId;\n', '        } else {\n', '            wallet.push(_tokenId);\n', '        }\n', '        //increase owner balance\n', '        //overflow is not likely to happen(need very large amount of pepes)\n', '        balances[_owner] += 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a token from a address&#39;s wallet\n', '     * @param _owner Address of the owner\n', '     * @param _tokenId Token to remove from the wallet\n', '     */\n', '    function removeFromWallet(address _owner, uint256 _tokenId) private {\n', '        uint256[] storage wallet = wallets[_owner];\n', '        uint256 i = 0;\n', '        // solhint-disable-next-line no-empty-blocks\n', '        for (; wallet[i] != _tokenId; i++) {\n', '            // not the pepe we are looking for\n', '        }\n', '        if (wallet[i] == _tokenId) {\n', '            //found it!\n', '            uint256 last = balances[_owner] - 1;\n', '            if (last > 0) {\n', '                //move the last item to this spot, the last will become inaccessible\n', '                wallet[i] = wallet[last];\n', '            }\n', '            //else: no last item to move, the balance is 0, making everything inaccessible.\n', '\n', '            //only decrease balance if _tokenId was in the wallet\n', '            balances[_owner] -= 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal transfer function\n', '     * @param _from Address sending the token\n', '     * @param _to Address to token is send to\n', '     * @param _tokenId ID of the token to send\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        pepes[_tokenId].master = _to;\n', '        approved[_tokenId] = address(0);//reset approved of pepe on every transfer\n', '\n', '        //remove the token from the _from wallet\n', '        removeFromWallet(_from, _tokenId);\n', '\n', '        //add the token to the _to wallet\n', '        addToWallet(_to, _tokenId);\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev transfer a token. Can only be called by the owner of the token\n', '     * @param  _to Addres to send the token to\n', '     * @param  _tokenId ID of the token to send\n', '     */\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    function transfer(address _to, uint256 _tokenId) public stopWhenHalted\n', '        onlyPepeMaster(_tokenId) //check if msg.sender is the master of this pepe\n', '        returns(bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);//after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve a address to send a token\n', '     * @param _to Address to approve\n', '     * @param _tokenId Token to set approval for\n', '     */\n', '    function approve(address _to, uint256 _tokenId) external stopWhenHalted\n', '        onlyPepeMaster(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve or revoke approval an address for al tokens of a user\n', '     * @param _operator Address to (un)approve\n', '     * @param _approved Approving or revoking indicator\n', '     */\n', '    function setApprovalForAll(address _operator, bool _approved) external stopWhenHalted {\n', '        if (_approved) {\n', '            approvedForAll[msg.sender][_operator] = true;\n', '        } else {\n', '            approvedForAll[msg.sender][_operator] = false;\n', '        }\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Get approved address for a token\n', '     * @param _tokenId Token ID to get the approved address for\n', '     * @return The address that is approved for this token\n', '     */\n', '    function getApproved(uint256 _tokenId) external view returns (address) {\n', '        return approved[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Get if an operator is approved for all tokens of that owner\n', '     * @param _owner Owner to check the approval for\n', '     * @param _operator Operator to check approval for\n', '     * @return Boolean indicating if the operator is approved for that owner\n', '     */\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        return approvedForAll[_owner][_operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to signal support for an interface\n', '     * @param interfaceID the ID of the interface to check for\n', '     * @return Boolean indicating support\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n', '        if (interfaceID == 0x80ac58cd || interfaceID == 0x01ffc9a7) { //TODO: add more interfaces the contract supports\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Safe transferFrom function\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     */\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external stopWhenHalted {\n', '        _safeTransferFromInternal(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safe transferFrom function with aditional data attribute\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @param _data Data to pass along call\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external stopWhenHalted {\n', '        _safeTransferFromInternal(_from, _to, _tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal Safe transferFrom function with aditional data attribute\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @param _data Data to pass along call\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function _safeTransferFromInternal(address _from, address _to, uint256 _tokenId, bytes _data) internal onlyAllowed(_tokenId) {\n', '        require(pepes[_tokenId].master == _from);//check if from is current owner\n', '        require(_to != address(0));//throw on zero address\n', '\n', '        _transfer(_from, _to, _tokenId); //transfer token\n', '\n', '        if (isContract(_to)) { //check if is contract\n', '            // solhint-disable-next-line max-line-length\n', '            require(ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data) == bytes4(keccak256("onERC721Received(address,uint256,bytes)")));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev TransferFrom function\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @return If it was successful\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public stopWhenHalted onlyAllowed(_tokenId) returns(bool) {\n', '        require(pepes[_tokenId].master == _from);//check if _from is really the master.\n', '        require(_to != address(0));\n', '        _transfer(_from, _to, _tokenId);//handles event, balances and approval reset;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Utility method to check if an address is a contract\n', '     * @param _address Address to check\n', '     * @return Boolean indicating if the address is a contract\n', '     */\n', '    function isContract(address _address) internal view returns (bool) {\n', '        uint size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(_address) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/PepToken.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract PepToken is StandardToken {\n', '\n', '    string public name = "PEP Token";\n', '    string public symbol = "PEP";\n', '    uint8 public decimals = 18;\n', '    uint256 public constant INITIAL_BALANCE = 45000000 ether;\n', '\n', '    constructor() public {\n', '        balances[msg.sender] = INITIAL_BALANCE;\n', '        totalSupply_ = INITIAL_BALANCE;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow spender to revoke its own allowance\n', '     * @param _from Address from which allowance should be revoked\n', '     */\n', '    function revokeAllowance(address _from) public {\n', '        allowed[_from][msg.sender] = 0;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/PepeGrinder.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.4;\n', '\n', '\n', '\n', '\n', '\n', 'contract PepeGrinder is StandardToken, Ownable {\n', '\n', '    address public pepeContract;\n', '    address public miner;\n', '    uint256[] public pepes;\n', '    mapping(address => bool) public dusting;\n', '\n', '    string public name = "CryptoPepes DUST";\n', '    string public symbol = "DPEP";\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public constant DUST_PER_PEPE = 100 ether;\n', '\n', '    constructor(address _pepeContract) public {\n', '        pepeContract = _pepeContract;\n', '    }\n', '\n', '    /**\n', '     * Set the mining contract. Can only be set once\n', '     * @param _miner The address of the miner contract\n', '     */\n', '    function setMiner(address _miner) public onlyOwner {\n', '        require(miner == address(0));// can only be set once\n', '        miner = _miner;\n', '    }\n', '\n', '    /**\n', '     * Gets called by miners who wanna dust their mined Pepes\n', '     */\n', '    function setDusting() public {\n', '        dusting[msg.sender] = true;\n', '    }\n', '\n', '    /**\n', '     * Dust a pepe to pepeDust\n', '     * @param _pepeId Pepe to dust\n', '     * @param _miner address of the miner\n', '     */\n', '    function dustPepe(uint256 _pepeId, address _miner) public {\n', '        require(msg.sender == miner);\n', '        balances[_miner] += DUST_PER_PEPE;\n', '        pepes.push(_pepeId);\n', '        totalSupply_ += DUST_PER_PEPE;\n', '        emit Transfer(address(0), _miner, DUST_PER_PEPE);\n', '    }\n', '\n', '    /**\n', '     * Convert dust into a Pepe\n', '     */\n', '    function claimPepe() public {\n', '        require(balances[msg.sender] >= DUST_PER_PEPE);\n', '\n', '        balances[msg.sender] -= DUST_PER_PEPE; //change balance and total supply\n', '        totalSupply_ -= DUST_PER_PEPE;\n', '\n', '        PepeBase(pepeContract).transfer(msg.sender, pepes[pepes.length-1]);//transfer pepe\n', '        pepes.length -= 1;\n', '        emit Transfer(msg.sender, address(0), DUST_PER_PEPE);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Math/ExtendedMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library ExtendedMath {\n', '  //return the smaller of the two inputs (a or b)\n', '  function limitLessThan(uint a, uint b) internal pure returns (uint c) {\n', '    if(a > b) return b;\n', '    return a;\n', '  }\n', '}\n', '\n', '// File: contracts/Mining.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.4;\n', '\n', '// solhint-disable max-line-length\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// solhint-disable-next-line\n', 'contract Mining is Beneficiary {\n', '\n', '    using SafeMath for uint;\n', '    using ExtendedMath for uint;\n', '\n', '    uint public latestDifficultyPeriodStarted = block.number;\n', '    uint public epochCount = 0;//number of &#39;blocks&#39; mined\n', '    uint public constant MAX_EPOCH_COUNT = 16000;\n', '    uint public baseMiningReward = 2500 ether;\n', '    uint public blocksPerReadjustment = 20;\n', '    uint public tokensMinted;\n', '\n', '    // solhint-disable var-name-mixedcase\n', '    uint public _MINIMUM_TARGET = 2**16;\n', '    uint public _MAXIMUM_TARGET = 2**250; //Testing setting!\n', '    //uint public _MAXIMUM_TARGET = 2**230; //SHOULD MAKE THIS HARDER IN PRODUCTION\n', '\n', '    uint public constant STARTING_DIFFICULTY = 0x00000000000b4963208fc24a4a15e9ea7c1556f9583f1941a7515fabbd194584;\n', '\n', '    bytes32 public challengeNumber;\n', '    uint public difficulty;\n', '    uint public MINING_RATE_FACTOR = 31; //mint the token 31 times less often than ether\n', '    //difficulty adjustment parameters- be careful modifying these\n', '    uint public MAX_ADJUSTMENT_PERCENT = 100;\n', '    uint public TARGET_DIVISOR = 2000;\n', '    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\n', '    mapping(bytes32 => bytes32) public solutionForChallenge;\n', '\n', '    Statistics public statistics;\n', '\n', '    PepeBase public pepeContract;\n', '    PepToken public pepToken;\n', '    PepeGrinder public pepeGrinder;\n', '\n', '    uint256 public miningStart;//timestamp when mining starts\n', '\n', '    event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    // track read only minting statistics\n', '    struct Statistics {\n', '        address lastRewardTo;\n', '        uint lastRewardAmount;\n', '        uint lastRewardEthBlockNumber;\n', '        uint lastRewardTimestamp;\n', '    }\n', '\n', '    constructor(address _pepeContract, address _pepToken, address _pepeGrinder, uint256 _miningStart) public {\n', '        pepeContract = PepeBase(_pepeContract);\n', '        pepToken = PepToken(_pepToken);\n', '        pepeGrinder = PepeGrinder(_pepeGrinder);\n', '        difficulty = STARTING_DIFFICULTY;\n', '        miningStart = _miningStart;\n', '    }\n', '\n', '    /**\n', '     * Mint a new pepe if noce is correct\n', '     * @param nonce The nonce to submit\n', '     * @param challengeDigest The resulting digest\n', '     * @return success Boolean indicating if mint was successful\n', '     */\n', '    // solhint-disable-next-line\n', '    function mint(uint256 nonce, bytes32 challengeDigest) public returns (bool success) {\n', '        require(epochCount < MAX_EPOCH_COUNT);//max 16k blocks\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > miningStart);\n', '        // perform the hash function validation\n', '        _hash(nonce, challengeDigest);\n', '\n', '        // calculate the current reward\n', '        uint rewardAmount = _reward(nonce);\n', '\n', '        // increment the minted tokens amount\n', '        tokensMinted += rewardAmount;\n', '\n', '        epochCount += 1;\n', '        challengeNumber = blockhash(block.number - 1);\n', '\n', '        _adjustDifficulty();\n', '\n', '        //populate read only diagnostics data\n', '        // solhint-disable-next-line not-rely-on-time\n', '        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\n', '\n', '        // send Mint event indicating a successful implementation\n', '        emit Mint(msg.sender, rewardAmount, epochCount, challengeNumber);\n', '\n', '        if (epochCount == MAX_EPOCH_COUNT) { //destroy this smart contract on the latest block\n', '            selfdestruct(msg.sender);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Get the current challengeNumber\n', '     * @return bytes32 challengeNumber\n', '     */\n', '    function getChallengeNumber() public constant returns (bytes32) {\n', '        return challengeNumber;\n', '    }\n', '\n', '    /**\n', '     * Get the current mining difficulty\n', '     * @return the current difficulty\n', '     */\n', '    function getMiningDifficulty() public constant returns (uint) {\n', '        return _MAXIMUM_TARGET.div(difficulty);\n', '    }\n', '\n', '    /**\n', '     * Get the mining target\n', '     * @return The current mining target\n', '     */\n', '    function getMiningTarget() public constant returns (uint256) {\n', '        return difficulty;\n', '    }\n', '\n', '    /**\n', '     * Get the mining reward\n', '     * @return The current mining reward. Always 2500PEP\n', '     */\n', '    function getMiningReward() public constant returns (uint256) {\n', '        return baseMiningReward;\n', '    }\n', '\n', '    /**\n', '     * Helper method to check a nonce\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest the digest to check\n', '     * @param challengeNumber to check\n', '     * @return digesttest The resulting digest\n', '     */\n', '    // solhint-disable-next-line\n', '    function getMintDigest(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber) public view returns (bytes32 digesttest) {\n', '        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        return digest;\n', '    }\n', '\n', '    /**\n', '     * Helper method to check if a nonce meets the difficulty\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest the digest to check\n', '     * @param challengeNumber the challenge number to check\n', '     * @param testTarget the difficulty to check\n', '     * @return success Boolean indicating success\n', '     */\n', '    function checkMintSolution(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber, uint testTarget) public view returns (bool success) {\n', '        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        if (uint256(digest) > testTarget) revert();\n', '        return (digest == challengeDigest);\n', '    }\n', '\n', '    /**\n', '     * Internal function to check a hash\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest it should create\n', '     * @return digest The digest created\n', '     */\n', '    function _hash(uint256 nonce, bytes32 challengeDigest) internal returns (bytes32 digest) {\n', '        digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        //the challenge digest must match the expected\n', '        if (digest != challengeDigest) revert();\n', '        //the digest must be smaller than the target\n', '        if (uint256(digest) > difficulty) revert();\n', '        //only allow one reward for each challenge\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        solutionForChallenge[challengeNumber] = digest;\n', '        if (solution != 0x0) revert();  //prevent the same answer from awarding twice\n', '    }\n', '\n', '    /**\n', '     * Reward a miner Pep tokens\n', '     * @param nonce Nonce to use as seed for Pepe dna creation\n', '     * @return The amount of PEP tokens rewarded\n', '     */\n', '    function _reward(uint256 nonce) internal returns (uint) {\n', '        uint reward_amount = getMiningReward();\n', '        pepToken.transfer(msg.sender, reward_amount);\n', '\n', '        if (epochCount % 16 == 0) { //every 16th block reward a pepe\n', '            if (pepeGrinder.dusting(msg.sender)) { //if miner is pool mining send it through the grinder\n', '                uint256 newPepe = pepeContract.minePepe(nonce, address(pepeGrinder));\n', '                pepeGrinder.dustPepe(newPepe, msg.sender);\n', '            } else {\n', '                pepeContract.minePepe(nonce, msg.sender);\n', '            }\n', '            //every 16th block send part of the block reward\n', '            pepToken.transfer(beneficiary, reward_amount);\n', '        }\n', '\n', '        return reward_amount;\n', '    }\n', '\n', '    /**\n', '     * Internal method to readjust difficulty\n', '     * @return The new difficulty\n', '     */\n', '    function _adjustDifficulty() internal returns (uint) {\n', '        //every so often, readjust difficulty. Dont readjust when deploying\n', '        if (epochCount % blocksPerReadjustment != 0) {\n', '            return difficulty;\n', '        }\n', '\n', '        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n', '        //assume 360 ethereum blocks per hour\n', '        //we want miners to spend 8 minutes to mine each &#39;block&#39;, about 31 ethereum blocks = one CryptoPepes block\n', '        uint epochsMined = blocksPerReadjustment;\n', '        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\n', '        //if there were less eth blocks passed in time than expected\n', '        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\n', '            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\n', '            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\n', '            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n', '            //make it harder\n', '            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra));   //by up to 50 %\n', '        } else {\n', '            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\n', '            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\n', '            //make it easier\n', '            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra));   //by up to 50 %\n', '        }\n', '        latestDifficultyPeriodStarted = block.number;\n', '        if (difficulty < _MINIMUM_TARGET) { //very dificult\n', '            difficulty = _MINIMUM_TARGET;\n', '        }\n', '        if (difficulty > _MAXIMUM_TARGET) { //very easy\n', '            difficulty = _MAXIMUM_TARGET;\n', '        }\n', '\n', '        return difficulty;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/Genetic.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.23;\n', '\n', '\n', 'contract Genetic {\n', '\n', '    // TODO mutations\n', '    // maximum number of random mutations per chromatid\n', '    uint8 public constant R = 5;\n', '\n', '    // solhint-disable-next-line function-max-lines\n', '    function breed(uint256[2] mother, uint256[2] father, uint256 seed) internal view returns (uint256[2] memOffset) {\n', '        // Meiosis I: recombining alleles (Chromosomal crossovers)\n', '\n', '        // Note about optimization I: no cell duplication,\n', '        //  producing 2 seeds/eggs per cell is enough, instead of 4 (like humans do)\n', '\n', '        // Note about optimization II: crossovers happen,\n', '        //  but only 1 side of the result is computed,\n', '        //  as the other side will not affect anything.\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // allocate output\n', '            // 1) get the pointer to our memory\n', '            memOffset := mload(0x40)\n', '            // 2) Change the free-memory pointer to keep our memory\n', '            //     (we will only use 64 bytes: 2 values of 256 bits)\n', '            mstore(0x40, add(memOffset, 64))\n', '\n', '\n', '            // Put seed in scratchpad 0\n', '            mstore(0x0, seed)\n', '            // Also use the timestamp, best we could do to increase randomness\n', '            //  without increasing costs dramatically. (Trade-off)\n', '            mstore(0x20, timestamp)\n', '\n', '            // Hash it for a universally random bitstring.\n', '            let hash := keccak256(0, 64)\n', '\n', '            // Byzantium VM does not support shift opcodes, will be introduced in Constantinople.\n', '            // Soldity itself, in non-assembly, also just uses other opcodes to simulate it.\n', '            // Optmizer should take care of inlining, just declare shiftR ourselves here.\n', '            // Where possible, better optimization is applied to make it cheaper.\n', '            function shiftR(value, offset) -> result {\n', '                result := div(value, exp(2, offset))\n', '            }\n', '\n', '            // solhint-disable max-line-length\n', '            // m_context << Instruction::SWAP1 << u256(2) << Instruction::EXP << Instruction::SWAP1 << (c_leftSigned ? Instruction::SDIV : Instruction::DIV);\n', '\n', '            // optimization: although one side consists of multiple chromatids,\n', '            //  we handle them just as one long chromatid:\n', '            //  only difference is that a crossover in chromatid i affects chromatid i+1.\n', '            //  No big deal, order and location is random anyway\n', '            function processSide(fatherSrc, motherSrc, rngSrc) -> result {\n', '\n', '                {\n', '                    // initial rngSrc bit length: 254 bits\n', '\n', '                    // Run the crossovers\n', '                    // =====================================================\n', '\n', '                    // Pick some crossovers\n', '                    // Each crossover is spaced ~64 bits on average.\n', '                    // To achieve this, we get a random 7 bit number, [0, 128), for each crossover.\n', '\n', '                    // 256 / 64 = 4, we need 4 crossovers,\n', '                    //  and will have 256 / 127 = 2 at least (rounded down).\n', '\n', '                    // Get one bit determining if we should pick DNA from the father,\n', '                    //  or from the mother.\n', '                    // This changes every crossover. (by swapping father and mother)\n', '                    {\n', '                        if eq(and(rngSrc, 0x1), 0) {\n', '                            // Swap mother and father,\n', '                            // create a temporary variable (code golf XOR swap costs more in gas)\n', '                            let temp := fatherSrc\n', '                            fatherSrc := motherSrc\n', '                            motherSrc := temp\n', '                        }\n', '\n', '                        // remove the bit from rng source, 253 rng bits left\n', '                        rngSrc := shiftR(rngSrc, 1)\n', '                    }\n', '\n', "                    // Don't push/pop this all the time, we have just enough space on stack.\n", '                    let mask := 0\n', '\n', '                    // Cap at 4 crossovers, no more than that.\n', '                    let cap := 0\n', '                    let crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\n', '                    // remove bits from hash, e.g. 254 - 7 = 247 left.\n', '                    rngSrc := shiftR(rngSrc, 7)\n', '                    let crossoverPos := crossoverLen\n', '\n', "                    // optimization: instead of shifting with an opcode we don't have until Constantinople,\n", '                    //  keep track of the a shifted number, updated using multiplications.\n', '                    let crossoverPosLeading1 := 1\n', '\n', '                    // solhint-disable-next-line no-empty-blocks\n', '                    for { } and(lt(crossoverPos, 256), lt(cap, 4)) {\n', '\n', '                        crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\n', '                        // remove bits from hash, e.g. 254 - 7 = 247 left.\n', '                        rngSrc := shiftR(rngSrc, 7)\n', '\n', '                        crossoverPos := add(crossoverPos, crossoverLen)\n', '\n', '                        cap := add(cap, 1)\n', '                    } {\n', '\n', '                        // Note: we go from right to left in the bit-string.\n', '\n', '                        // Create a mask for this crossover.\n', '                        // Example:\n', '                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\n', '                        // |Prev. data ||Crossover here  ||remaining data .......\n', '                        //\n', '                        // The crossover part is copied from the mother/father to the child.\n', '\n', '                        // Create the bit-mask\n', '                        // Create a bitstring that ignores the previous data:\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // First create a leading 1, just before the crossover, like:\n', '                        // 00000000000010000000000000000000000000000000000000000000000000000000000.....\n', '                        // Then substract 1, to get a long string of 1s\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // Now do the same for the remain part, and xor it.\n', '                        // leading 1\n', '                        // 00000000000000000000000000000010000000000000000000000000000000000000000000000000000000000.....\n', '                        // sub 1\n', '                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\n', '                        // xor with other\n', '                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\n', '                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\n', '                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\n', '\n', '                        // Use the final shifted 1 of the previous crossover as the start marker\n', '                        mask := sub(crossoverPosLeading1, 1)\n', '\n', '                        // update for this crossover, (and will be used as start for next crossover)\n', '                        crossoverPosLeading1 := mul(1, exp(2, crossoverPos))\n', '                        mask := xor(mask,\n', '                                    sub(crossoverPosLeading1, 1)\n', '                        )\n', '\n', '                        // Now add the parent data to the child genotype\n', '                        // E.g.\n', '                        // Mask:         00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000....\n', '                        // Parent:       10010111001000110101011111001010001011100000000000010011000001000100000001011101111000111....\n', '                        // Child (pre):  00000000000000000000000000000001111110100101111111000011001010000000101010100000110110110....\n', '                        // Child (post): 00000000000000110101011111001011111110100101111111000011001010000000101010100000110110110....\n', '\n', '                        // To do this, we run: child_post = child_pre | (mask & father)\n', '                        result := or(result, and(mask, fatherSrc))\n', '\n', '                        // Swap father and mother, next crossover will take a string from the other.\n', '                        let temp := fatherSrc\n', '                        fatherSrc := motherSrc\n', '                        motherSrc := temp\n', '                    }\n', '\n', '                    // We still have a left-over part that was not copied yet\n', '                    // E.g., we have something like:\n', '                    // Father: |            xxxxxxxxxxxxxxxxxxx          xxxxxxxxxxxxxxxxxxxxxxxx            ....\n', '                    // Mother: |############                   xxxxxxxxxx                        xxxxxxxxxxxx....\n', '                    // Child:  |            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx....\n', '                    // The ############ still needs to be applied to the child, also,\n', '                    //  this can be done cheaper than in the loop above,\n', "                    //  as we don't have to swap anything for the next crossover or something.\n", '\n', '                    // At this point we have to assume 4 crossovers ran,\n', '                    //  and that we only have 127 - 1 - (4 * 7) = 98 bits of randomness left.\n', '                    // We stopped at the bit after the crossoverPos index, see "x":\n', '                    // 000000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....\n', '                    // now create a leading 1 at crossoverPos like:\n', '                    // 000000001000000000000000000000000000000000000000000000000000000000000000000.....\n', '                    // Sub 1, get the mask for what we had.\n', '                    // 000000000111111111111111111111111111111111111111111111111111111111111111111.....\n', '                    // Invert, and we have the final mask:\n', '                    // 111111111000000000000000000000000000000000000000000000000000000000000000000.....\n', '                    mask := not(sub(crossoverPosLeading1, 1))\n', '                    // Apply it to the result\n', '                    result := or(result, and(mask, fatherSrc))\n', '\n', '                    // Random mutations\n', '                    // =====================================================\n', '\n', '                    // random mutations\n', '                    // Put rng source in scratchpad 0\n', '                    mstore(0x0, rngSrc)\n', '                    // And some arbitrary padding in scratchpad 1,\n', '                    //  used to create different hashes based on input size changes\n', '                    mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\n', '                    // Hash it for a universally random bitstring.\n', '                    // Then reduce the number of 1s by AND-ing it with other *different* hashes.\n', '                    // Each bit in mutations has a probability of 0.5^5 = 0.03125 = 3.125% to be a 1\n', '                    let mutations := and(\n', '                            and(\n', '                                and(keccak256(0, 32), keccak256(1, 33)),\n', '                                and(keccak256(2, 34), keccak256(3, 35))\n', '                            ),\n', '                            keccak256(0, 36)\n', '                    )\n', '\n', '                    result := xor(result, mutations)\n', '\n', '                }\n', '            }\n', '\n', '\n', '            {\n', '\n', '                // Get 1 bit of pseudo randomness that will\n', '                //  determine if side #1 will come from the left, or right side.\n', '                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\n', '                let relativeFatherSideLoc := mul(and(hash, 0x1), 0x20) // shift by 5 bits = mul by 2^5=32 (0x20)\n', '                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\n', '                let relativeMotherSideLoc := mul(and(hash, 0x2), 0x10) // already shifted by 1, mul by 2^4=16 (0x10)\n', '\n', '                // Now remove the used 2 bits from the hash, 254 bits remaining now.\n', '                hash := div(hash, 4)\n', '\n', '                // Process the side, load the relevant parent data that will be used.\n', '                mstore(memOffset, processSide(\n', '                    mload(add(father, relativeFatherSideLoc)),\n', '                    mload(add(mother, relativeMotherSideLoc)),\n', '                    hash\n', '                ))\n', '\n', '                // The other side will be the opposite index: 1 -> 0, 0 -> 1\n', '                // Apply it to the location,\n', '                //  which is either 0x20 (For index 1) or 0x0 for index 0.\n', '                relativeFatherSideLoc := xor(relativeFatherSideLoc, 0x20)\n', '                relativeMotherSideLoc := xor(relativeMotherSideLoc, 0x20)\n', '\n', '                mstore(0x0, seed)\n', '                // Second argument will be inverse,\n', '                //  resulting in a different second hash.\n', '                mstore(0x20, not(timestamp))\n', '\n', '                // Now create another hash, for the other side\n', '                hash := keccak256(0, 64)\n', '\n', '                // Process the other side\n', '                mstore(add(memOffset, 0x20), processSide(\n', '                    mload(add(father, relativeFatherSideLoc)),\n', '                    mload(add(mother, relativeMotherSideLoc)),\n', '                    hash\n', '                ))\n', '\n', '            }\n', '\n', '        }\n', '\n', '        // Sample input:\n', '        // ["0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC","0x4444444455555555555555556666666666666644444444455555555555666666"]\n', '        //\n', '        // ["0x1111111111112222222223333311111111122222223333333331111112222222","0x7777788888888888999999999999977777777777788888888888999999997777"]\n', '\n', '        // Expected results (or similar, depends on the seed):\n', '        // 0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC < Father side A\n', '        // 0x4444444455555555555555556666666666666644444444455555555555666666 < Father side B\n', '\n', '        // 0x1111111111112222222223333311111111122222223333333331111112222222 < Mother side A\n', '        // 0x7777788888888888999999999999977777777777788888888888999999997777 < Mother side B\n', '\n', '        //   xxxxxxxxxxxxxxxxx           xxxxxxxxx                         xx\n', '        // 0xAAABBBBBBBBCCCCCD99999999998BBBBBBBBF77778888888888899999999774C < Child side A\n', '        //   xxx                       xxxxxxxxxxx\n', '        // 0x4441111111112222222223333366666666666222223333333331111112222222 < Child side B\n', '\n', '        // And then random mutations, for gene pool expansion.\n', '        // Each bit is flipped with a 3.125% chance\n', '\n', '        // Example:\n', '        //a2c37edc61dca0ca0b199e098c80fd5a221c2ad03605b4b54332361358745042 < random hash 1\n', '        //c217d04b19a83fe497c1cf6e1e10030e455a0812a6949282feec27d67fe2baa7 < random hash 2\n', '        //2636a55f38bed26d804c63a13628e21b2d701c902ca37b2b0ca94fada3821364 < random hash 3\n', '        //86bb023a85e2da50ac233b946346a53aa070943b0a8e91c56e42ba181729a5f9 < random hash 4\n', '        //5d71456a1288ab30ddd4c955384d42e66a09d424bd7743791e3eab8e09aa13f1 < random hash 5\n', '        //0000000800800000000000000000000200000000000000000000020000000000 < resulting mutation\n', '        //aaabbbbbbbbcccccd99999999998bbbbbbbbf77778888888888899999999774c < original\n', '        //aaabbbb3bb3cccccd99999999998bbb9bbbbf7777888888888889b999999774c < mutated (= original XOR mutation)\n', '    }\n', '\n', '    // Generates (psuedo) random Pepe DNA\n', '    function randomDNA(uint256 seed) internal pure returns (uint256[2] memOffset) {\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // allocate output\n', '            // 1) get the pointer to our memory\n', '            memOffset := mload(0x40)\n', '            // 2) Change the free-memory pointer to keep our memory\n', '            //     (we will only use 64 bytes: 2 values of 256 bits)\n', '            mstore(0x40, add(memOffset, 64))\n', '\n', '            // Load the seed into 1st scratchpad memory slot.\n', '            // adjacent to the additional value (used to create two distinct hashes)\n', '            mstore(0x0, seed)\n', '\n', '            // In second scratchpad slot:\n', '            // The additional value can be any word, as long as the caller uses\n', '            //  it (second hash needs to be different)\n', '            mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\n', '\n', '\n', '            // // Create first element pointer of array\n', '            // mstore(memOffset, add(memOffset, 64)) // pointer 1\n', '            // mstore(add(memOffset, 32), add(memOffset, 96)) // pointer 2\n', '\n', '            // control block to auto-pop the hash.\n', '            {\n', '                // L * N * 2 * 4 = 4 * 2 * 2 * 4 = 64 bytes, 2x 256 bit hash\n', '\n', '                // Sha3 is cheaper than sha256, make use of it\n', '                let hash := keccak256(0, 64)\n', '\n', '                // Store first array value\n', '                mstore(memOffset, hash)\n', '\n', '                // Now hash again, but only 32 bytes of input,\n', '                //  to ignore make the input different than the previous call,\n', '                hash := keccak256(0, 32)\n', '                mstore(add(memOffset, 32), hash)\n', '\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Usernames.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', 'contract Usernames {\n', '\n', '    mapping(address => bytes32) public addressToUser;\n', '    mapping(bytes32 => address) public userToAddress;\n', '\n', '    event UserNamed(address indexed user, bytes32 indexed username);\n', '\n', '    /**\n', '     * Claim a username. Frees up a previously used one\n', '     * @param _username to claim\n', '     */\n', '    function claimUsername(bytes32 _username) external {\n', '        require(userToAddress[_username] == address(0));// Username must be free\n', '\n', '        if (addressToUser[msg.sender] != bytes32(0)) { // If user already has username free it up\n', '            userToAddress[addressToUser[msg.sender]] = address(0);\n', '        }\n', '\n', '        //all is well assign username\n', '        addressToUser[msg.sender] = _username;\n', '        userToAddress[_username] = msg.sender;\n', '\n', '        emit UserNamed(msg.sender, _username);\n', '\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Beneficiary.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/** @title Beneficiary */\n', 'contract Beneficiary is Ownable {\n', '    address public beneficiary;\n', '\n', '    constructor() public {\n', '        beneficiary = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Change the beneficiary address\n', '     * @param _beneficiary Address of the new beneficiary\n', '     */\n', '    function setBeneficiary(address _beneficiary) public onlyOwner {\n', '        beneficiary = _beneficiary;\n', '    }\n', '}\n', '\n', '// File: contracts/Affiliate.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.25;\n', '\n', '\n', '\n', '/** @title Affiliate */\n', 'contract Affiliate is Ownable {\n', '    mapping(address => bool) public canSetAffiliate;\n', '    mapping(address => address) public userToAffiliate;\n', '\n', '    /** @dev Allows an address to set the affiliate address for a user\n', '      * @param _setter The address that should be allowed\n', '      */\n', '    function setAffiliateSetter(address _setter) public onlyOwner {\n', '        canSetAffiliate[_setter] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the affiliate of a user\n', '     * @param _user user to set affiliate for\n', '     * @param _affiliate address to set\n', '     */\n', '    function setAffiliate(address _user, address _affiliate) public {\n', '        require(canSetAffiliate[msg.sender]);\n', '        if (userToAffiliate[_user] == address(0)) {\n', '            userToAffiliate[_user] = _affiliate;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/interfaces/ERC721.sol\n', '\n', 'contract ERC721 {\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 total);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) ;\n', '    function transfer(address _to, uint256 _tokenId) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '// File: contracts/interfaces/PepeInterface.sol\n', '\n', 'contract PepeInterface is ERC721{\n', '    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) public returns (bool);\n', '    function getCozyAgain(uint256 _pepeId) public view returns(uint64);\n', '}\n', '\n', '// File: contracts/AuctionBase.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '/** @title AuctionBase */\n', 'contract AuctionBase is Beneficiary {\n', '    mapping(uint256 => PepeAuction) public auctions;//maps pepes to auctions\n', '    PepeInterface public pepeContract;\n', '    Affiliate public affiliateContract;\n', '    uint256 public fee = 37500; //in 1 10000th of a percent so 3.75% at the start\n', '    uint256 public constant FEE_DIVIDER = 1000000; //Perhaps needs better name?\n', '\n', '    struct PepeAuction {\n', '        address seller;\n', '        uint256 pepeId;\n', '        uint64 auctionBegin;\n', '        uint64 auctionEnd;\n', '        uint256 beginPrice;\n', '        uint256 endPrice;\n', '    }\n', '\n', '    event AuctionWon(uint256 indexed pepe, address indexed winner, address indexed seller);\n', '    event AuctionStarted(uint256 indexed pepe, address indexed seller);\n', '    event AuctionFinalized(uint256 indexed pepe, address indexed seller);\n', '\n', '    constructor(address _pepeContract, address _affiliateContract) public {\n', '        pepeContract = PepeInterface(_pepeContract);\n', '        affiliateContract = Affiliate(_affiliateContract);\n', '    }\n', '\n', '    /**\n', '     * @dev Return a pepe from a auction that has passed\n', '     * @param  _pepeId the id of the pepe to save\n', '     */\n', '    function savePepe(uint256 _pepeId) external {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(auctions[_pepeId].auctionEnd < now);//auction must have ended\n', '        require(pepeContract.transfer(auctions[_pepeId].seller, _pepeId));//transfer pepe back to seller\n', '\n', '        emit AuctionFinalized(_pepeId, auctions[_pepeId].seller);\n', '\n', '        delete auctions[_pepeId];//delete auction\n', '    }\n', '\n', '    /**\n', '     * @dev change the fee on pepe sales. Can only be lowerred\n', '     * @param _fee The new fee to set. Must be lower than current fee\n', '     */\n', '    function changeFee(uint256 _fee) external onlyOwner {\n', '        require(_fee < fee);//fee can not be raised\n', '        fee = _fee;\n', '    }\n', '\n', '    /**\n', '     * @dev Start a auction\n', '     * @param  _pepeId Pepe to sell\n', '     * @param  _beginPrice Price at which the auction starts\n', '     * @param  _endPrice Ending price of the auction\n', '     * @param  _duration How long the auction should take\n', '     */\n', '    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\n', '        require(pepeContract.transferFrom(msg.sender, address(this), _pepeId));\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\n', '\n', '        PepeAuction memory auction;\n', '\n', '        auction.seller = msg.sender;\n', '        auction.pepeId = _pepeId;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionBegin = uint64(now);\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionEnd = uint64(now) + _duration;\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.beginPrice = _beginPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_pepeId] = auction;\n', '\n', '        emit AuctionStarted(_pepeId, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev directly start a auction from the PepeBase contract\n', '     * @param  _pepeId Pepe to put on auction\n', '     * @param  _beginPrice Price at which the auction starts\n', '     * @param  _endPrice Ending price of the auction\n', '     * @param  _duration How long the auction should take\n', '     * @param  _seller The address selling the pepe\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\n', '        require(msg.sender == address(pepeContract)); //can only be called by pepeContract\n', '        //solhint-disable-next-line not-rely-on-time\n', '        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\n', '\n', '        PepeAuction memory auction;\n', '\n', '        auction.seller = _seller;\n', '        auction.pepeId = _pepeId;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionBegin = uint64(now);\n', '        // solhint-disable-next-line not-rely-on-time\n', '        auction.auctionEnd = uint64(now) + _duration;\n', '        require(auction.auctionEnd > auction.auctionBegin);\n', '        auction.beginPrice = _beginPrice;\n', '        auction.endPrice = _endPrice;\n', '\n', '        auctions[_pepeId] = auction;\n', '\n', '        emit AuctionStarted(_pepeId, _seller);\n', '    }\n', '\n', '  /**\n', '   * @dev Calculate the current price of a auction\n', '   * @param  _pepeId the pepeID to calculate the current price for\n', '   * @return currentBid the current price for the auction\n', '   */\n', '    function calculateBid(uint256 _pepeId) public view returns(uint256 currentBid) {\n', '        PepeAuction storage auction = auctions[_pepeId];\n', '        // solhint-disable-next-line not-rely-on-time\n', '        uint256 timePassed = now - auctions[_pepeId].auctionBegin;\n', '\n', '        // If auction ended return auction end price.\n', '        // solhint-disable-next-line not-rely-on-time\n', '        if (now >= auction.auctionEnd) {\n', '            return auction.endPrice;\n', '        } else {\n', '            // Can be negative\n', '            int256 priceDifference = int256(auction.endPrice) - int256(auction.beginPrice);\n', '            // Always positive\n', '            int256 duration = int256(auction.auctionEnd) - int256(auction.auctionBegin);\n', '\n', '            // As already proven in practice by CryptoKitties:\n', '            //  timePassed -> 64 bits at most\n', '            //  priceDifference -> 128 bits at most\n', '            //  timePassed * priceDifference -> 64 + 128 bits at most\n', '            int256 priceChange = priceDifference * int256(timePassed) / duration;\n', '\n', '            // Will be positive, both operands are less than 256 bits\n', '            int256 price = int256(auction.beginPrice) + priceChange;\n', '\n', '            return uint256(price);\n', '        }\n', '    }\n', '\n', '  /**\n', '   * @dev collect the fees from the auction\n', '   */\n', '    function getFees() public {\n', '        beneficiary.transfer(address(this).balance);\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: contracts/CozyTimeAuction.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/** @title CozyTimeAuction */\n', 'contract CozyTimeAuction is AuctionBase {\n', '    // solhint-disable-next-line\n', '    constructor (address _pepeContract, address _affiliateContract) AuctionBase(_pepeContract, _affiliateContract) public {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Start an auction\n', '     * @param  _pepeId The id of the pepe to start the auction for\n', '     * @param  _beginPrice Start price of the auction\n', '     * @param  _endPrice End price of the auction\n', '     * @param  _duration How long the auction should take\n', '     */\n', '    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\n', '        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);\n', '    }\n', '\n', '    /**\n', '     * @dev Start a auction direclty from the PepeBase smartcontract\n', '     * @param  _pepeId The id of the pepe to start the auction for\n', '     * @param  _beginPrice Start price of the auction\n', '     * @param  _endPrice End price of the auction\n', '     * @param  _duration How long the auction should take\n', '     * @param  _seller The address of the seller\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\n', '        super.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, _seller);\n', '    }\n', '\n', '    /**\n', '     * @dev Buy cozy right from the auction\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _cozyCandidate the pepe to cozy with\n', '     * @param  _candidateAsFather Is the _cozyCandidate father?\n', '     * @param  _pepeReceiver address receiving the pepe after cozy time\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function buyCozy(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver) public payable {\n', '        require(address(pepeContract) == msg.sender); //caller needs to be the PepeBase contract\n', '\n', '        PepeAuction storage auction = auctions[_pepeId];\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now < auction.auctionEnd);// auction must be still going\n', '\n', '        uint256 price = calculateBid(_pepeId);\n', '        require(msg.value >= price);//must send enough ether\n', '        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\n', '\n', '        //Send ETH to seller\n', '        auction.seller.transfer(price - totalFee);\n', '        //send ETH to beneficiary\n', '\n', '        address affiliate = affiliateContract.userToAffiliate(_pepeReceiver);\n', '\n', '        //solhint-disable-next-line\n', '        if (affiliate != address(0) && affiliate.send(totalFee / 2)) { //if user has affiliate\n', '            //nothing just to suppress warning\n', '        }\n', '\n', '        //actual cozytiming\n', '        if (_candidateAsFather) {\n', '            if (!pepeContract.cozyTime(auction.pepeId, _cozyCandidate, _pepeReceiver)) {\n', '                revert();\n', '            }\n', '        } else {\n', '          // Swap around the two pepes, they have no set gender, the user decides what they are.\n', '            if (!pepeContract.cozyTime(_cozyCandidate, auction.pepeId, _pepeReceiver)) {\n', '                revert();\n', '            }\n', '        }\n', '\n', '        //Send pepe to seller of auction\n', '        if (!pepeContract.transfer(auction.seller, _pepeId)) {\n', "            revert(); //can't complete transfer if this fails\n", '        }\n', '\n', '        if (msg.value > price) { //return ether send to much\n', '            _pepeReceiver.transfer(msg.value - price);\n', '        }\n', '\n', '        emit AuctionWon(_pepeId, _pepeReceiver, auction.seller);//emit event\n', '\n', '        delete auctions[_pepeId];//deletes auction\n', '    }\n', '\n', '    /**\n', '     * @dev Buy cozytime and pass along affiliate\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _cozyCandidate the pepe to cozy with\n', '     * @param  _candidateAsFather Is the _cozyCandidate father?\n', '     * @param  _pepeReceiver address receiving the pepe after cozy time\n', '     * @param  _affiliate Affiliate address to set\n', '     */\n', '    //solhint-disable-next-line max-line-length\n', '    function buyCozyAffiliated(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver, address _affiliate) public payable {\n', '        affiliateContract.setAffiliate(_pepeReceiver, _affiliate);\n', '        buyCozy(_pepeId, _cozyCandidate, _candidateAsFather, _pepeReceiver);\n', '    }\n', '}\n', '\n', '// File: contracts/Haltable.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Haltable is Ownable {\n', '    uint256 public haltTime; //when the contract was halted\n', '    bool public halted;//is the contract halted?\n', '    uint256 public haltDuration;\n', '    uint256 public maxHaltDuration = 8 weeks;//how long the contract can be halted\n', '\n', '    modifier stopWhenHalted {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhenHalted {\n', '        require(halted);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Halt the contract for a set time smaller than maxHaltDuration\n', '     * @param  _duration Duration how long the contract should be halted. Must be smaller than maxHaltDuration\n', '     */\n', '    function halt(uint256 _duration) public onlyOwner {\n', '        require(haltTime == 0); //cannot halt if it was halted before\n', '        require(_duration <= maxHaltDuration);//cannot halt for longer than maxHaltDuration\n', '        haltDuration = _duration;\n', '        halted = true;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        haltTime = now;\n', '    }\n', '\n', '    /**\n', '     * @dev Unhalt the contract. Can only be called by the owner or when the haltTime has passed\n', '     */\n', '    function unhalt() public {\n', '        // solhint-disable-next-line\n', '        require(now > haltTime + haltDuration || msg.sender == owner);//unhalting is only possible when haltTime has passed or the owner unhalts\n', '        halted = false;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/ERC721TokenReceiver.sol\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '// File: contracts/PepeBase.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '// solhint-disable func-order\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PepeBase is Genetic, Ownable, Usernames, Haltable {\n', '\n', '    uint32[15] public cozyCoolDowns = [ //determined by generation / 2\n', '        uint32(1 minutes),\n', '        uint32(2 minutes),\n', '        uint32(5 minutes),\n', '        uint32(15 minutes),\n', '        uint32(30 minutes),\n', '        uint32(45 minutes),\n', '        uint32(1 hours),\n', '        uint32(2 hours),\n', '        uint32(4 hours),\n', '        uint32(8 hours),\n', '        uint32(16 hours),\n', '        uint32(1 days),\n', '        uint32(2 days),\n', '        uint32(4 days),\n', '        uint32(7 days)\n', '    ];\n', '\n', '    struct Pepe {\n', '        address master; //The master of the pepe\n', '        uint256[2] genotype; //all genes stored here\n', '        uint64 canCozyAgain; //time when pepe can have nice time again\n', '        uint64 generation; //what generation?\n', '        uint64 father; //father of this pepe\n', '        uint64 mother; //mommy of this pepe\n', '        uint8 coolDownIndex;\n', '    }\n', '\n', '    mapping(uint256 => bytes32) public pepeNames;\n', '\n', '    //stores all pepes\n', '    Pepe[] public pepes;\n', '\n', '    bool public implementsERC721 = true; //signal erc721 support\n', '\n', '    // solhint-disable-next-line const-name-snakecase\n', '    string public constant name = "Crypto Pepe";\n', '    // solhint-disable-next-line const-name-snakecase\n', '    string public constant symbol = "CPEP";\n', '\n', '    mapping(address => uint256[]) private wallets;\n', '    mapping(address => uint256) public balances; //amounts of pepes per address\n', '    mapping(uint256 => address) public approved; //pepe index to address approved to transfer\n', '    mapping(address => mapping(address => bool)) public approvedForAll;\n', '\n', '    uint256 public zeroGenPepes; //how many zero gen pepes are mined\n', '    uint256 public constant MAX_PREMINE = 100;//how many pepes can be premined\n', '    uint256 public constant MAX_ZERO_GEN_PEPES = 1100; //max number of zero gen pepes\n', '    address public miner; //address of the miner contract\n', '\n', '    modifier onlyPepeMaster(uint256 _pepeId) {\n', '        require(pepes[_pepeId].master == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAllowed(uint256 _tokenId) {\n', '        // solhint-disable-next-line max-line-length\n', '        require(msg.sender == pepes[_tokenId].master || msg.sender == approved[_tokenId] || approvedForAll[pepes[_tokenId].master][msg.sender]); //check if msg.sender is allowed\n', '        _;\n', '    }\n', '\n', '    event PepeBorn(uint256 indexed mother, uint256 indexed father, uint256 indexed pepeId);\n', '    event PepeNamed(uint256 indexed pepeId);\n', '\n', '    constructor() public {\n', '\n', '        Pepe memory pepe0 = Pepe({\n', '            master: 0x0,\n', '            genotype: [uint256(0), uint256(0)],\n', '            canCozyAgain: 0,\n', '            father: 0,\n', '            mother: 0,\n', '            generation: 0,\n', '            coolDownIndex: 0\n', '        });\n', '\n', '        pepes.push(pepe0);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that creates a new pepe\n', '     * @param  _genoType DNA of the new pepe\n', '     * @param  _mother The ID of the mother\n', '     * @param  _father The ID of the father\n', '     * @param  _generation The generation of the new Pepe\n', '     * @param  _master The owner of this new Pepe\n', '     * @return The ID of the newly generated Pepe\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function _newPepe(uint256[2] _genoType, uint64 _mother, uint64 _father, uint64 _generation, address _master) internal returns (uint256 pepeId) {\n', '        uint8 tempCoolDownIndex;\n', '\n', '        tempCoolDownIndex = uint8(_generation / 2);\n', '\n', '        if (_generation > 28) {\n', '            tempCoolDownIndex = 14;\n', '        }\n', '\n', '        Pepe memory _pepe = Pepe({\n', '            master: _master, //The master of the pepe\n', '            genotype: _genoType, //all genes stored here\n', '            canCozyAgain: 0, //time when pepe can have nice time again\n', '            father: _father, //father of this pepe\n', '            mother: _mother, //mommy of this pepe\n', '            generation: _generation, //what generation?\n', '            coolDownIndex: tempCoolDownIndex\n', '        });\n', '\n', '        if (_generation == 0) {\n', '            zeroGenPepes += 1; //count zero gen pepes\n', '        }\n', '\n', '        //push returns the new length, use it to get a new unique id\n', '        pepeId = pepes.push(_pepe) - 1;\n', '\n', '        //add it to the wallet of the master of the new pepe\n', '        addToWallet(_master, pepeId);\n', '\n', '        emit PepeBorn(_mother, _father, pepeId);\n', '        emit Transfer(address(0), _master, pepeId);\n', '\n', '        return pepeId;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the miner contract. Can only be called once\n', '     * @param _miner Address of the miner contract\n', '     */\n', '    function setMiner(address _miner) public onlyOwner {\n', '        require(miner == address(0));//can only be set once\n', '        miner = _miner;\n', '    }\n', '\n', '    /**\n', '     * @dev Mine a new Pepe. Can only be called by the miner contract.\n', '     * @param  _seed Seed to be used for the generation of the DNA\n', '     * @param  _receiver Address receiving the newly mined Pepe\n', '     * @return The ID of the newly mined Pepe\n', '     */\n', '    function minePepe(uint256 _seed, address _receiver) public stopWhenHalted returns(uint256) {\n', '        require(msg.sender == miner);//only miner contract can call\n', '        require(zeroGenPepes < MAX_ZERO_GEN_PEPES);\n', '\n', '        return _newPepe(randomDNA(_seed), 0, 0, 0, _receiver);\n', '    }\n', '\n', '    /**\n', '     * @dev Premine pepes. Can only be called by the owner and is limited to MAX_PREMINE\n', '     * @param  _amount Amount of Pepes to premine\n', '     */\n', '    function pepePremine(uint256 _amount) public onlyOwner stopWhenHalted {\n', '        for (uint i = 0; i < _amount; i++) {\n', '            require(zeroGenPepes <= MAX_PREMINE);//can only generate set amount during premine\n', '            //create a new pepe\n', "            // 1) who's genes are based on hash of the timestamp and the number of pepes\n", '            // 2) who has no mother or father\n', '            // 3) who is generation zero\n', "            // 4) who's master is the manager\n", '\n', '            // solhint-disable-next-line\n', '            _newPepe(randomDNA(uint256(keccak256(abi.encodePacked(block.timestamp, pepes.length)))), 0, 0, 0, owner);\n', '\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev CozyTime two Pepes together\n', '     * @param  _mother The mother of the new Pepe\n', '     * @param  _father The father of the new Pepe\n', '     * @param  _pepeReceiver Address receiving the new Pepe\n', '     * @return If it was a success\n', '     */\n', '    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) external stopWhenHalted returns (bool) {\n', '        //cannot cozyTime with itself\n', '        require(_mother != _father);\n', '        //caller has to either be master or approved for mother\n', '        // solhint-disable-next-line max-line-length\n', '        require(pepes[_mother].master == msg.sender || approved[_mother] == msg.sender || approvedForAll[pepes[_mother].master][msg.sender]);\n', '        //caller has to either be master or approved for father\n', '        // solhint-disable-next-line max-line-length\n', '        require(pepes[_father].master == msg.sender || approved[_father] == msg.sender || approvedForAll[pepes[_father].master][msg.sender]);\n', '        //require both parents to be ready for cozytime\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > pepes[_mother].canCozyAgain && now > pepes[_father].canCozyAgain);\n', '        //require both mother parents not to be father\n', '        require(pepes[_mother].mother != _father && pepes[_mother].father != _father);\n', '        //require both father parents not to be mother\n', '        require(pepes[_father].mother != _mother && pepes[_father].father != _mother);\n', '\n', '        Pepe storage father = pepes[_father];\n', '        Pepe storage mother = pepes[_mother];\n', '\n', '\n', '        approved[_father] = address(0);\n', '        approved[_mother] = address(0);\n', '\n', '        uint256[2] memory newGenotype = breed(father.genotype, mother.genotype, pepes.length);\n', '\n', '        uint64 newGeneration;\n', '\n', '        newGeneration = mother.generation + 1;\n', '        if (newGeneration < father.generation + 1) { //if father generation is bigger\n', '            newGeneration = father.generation + 1;\n', '        }\n', '\n', '        _handleCoolDown(_mother);\n', '        _handleCoolDown(_father);\n', '\n', '        //sets pepe birth when mother is done\n', '        // solhint-disable-next-line max-line-length\n', '        pepes[_newPepe(newGenotype, uint64(_mother), uint64(_father), newGeneration, _pepeReceiver)].canCozyAgain = mother.canCozyAgain; //_pepeReceiver becomes the master of the pepe\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to increase the coolDownIndex\n', '     * @param _pepeId The id of the Pepe to update the coolDown of\n', '     */\n', '    function _handleCoolDown(uint256 _pepeId) internal {\n', '        Pepe storage tempPep = pepes[_pepeId];\n', '\n', '        // solhint-disable-next-line not-rely-on-time\n', '        tempPep.canCozyAgain = uint64(now + cozyCoolDowns[tempPep.coolDownIndex]);\n', '\n', '        if (tempPep.coolDownIndex < 14) {// after every cozy time pepe gets slower\n', '            tempPep.coolDownIndex++;\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Set the name of a Pepe. Can only be set once\n', '     * @param _pepeId ID of the pepe to name\n', '     * @param _name The name to assign\n', '     */\n', '    function setPepeName(uint256 _pepeId, bytes32 _name) public stopWhenHalted onlyPepeMaster(_pepeId) returns(bool) {\n', '        require(pepeNames[_pepeId] == 0x0000000000000000000000000000000000000000000000000000000000000000);\n', '        pepeNames[_pepeId] = _name;\n', '        emit PepeNamed(_pepeId);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer a Pepe to the auction contract and auction it\n', '     * @param  _pepeId ID of the Pepe to auction\n', '     * @param  _auction Auction contract address\n', '     * @param  _beginPrice Price the auction starts at\n', '     * @param  _endPrice Price the auction ends at\n', '     * @param  _duration How long the auction should run\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function transferAndAuction(uint256 _pepeId, address _auction, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public stopWhenHalted onlyPepeMaster(_pepeId) {\n', '        _transfer(msg.sender, _auction, _pepeId);//transfer pepe to auction\n', '        AuctionBase auction = AuctionBase(_auction);\n', '\n', '        auction.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve and buy. Used to buy cozyTime in one call\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _auction Address of the auction contract\n', '     * @param  _cozyCandidate Pepe to approve and cozy with\n', '     * @param  _candidateAsFather Use the candidate as father or not\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function approveAndBuy(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\n', '        approved[_cozyCandidate] = _auction;\n', '        // solhint-disable-next-line max-line-length\n', '        CozyTimeAuction(_auction).buyCozy.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender); //breeding resets approval\n', '    }\n', '\n', '    /**\n', '     * @dev The same as above only pass an extra parameter\n', '     * @param  _pepeId Pepe to cozy with\n', '     * @param  _auction Address of the auction contract\n', '     * @param  _cozyCandidate Pepe to approve and cozy with\n', '     * @param  _candidateAsFather Use the candidate as father or not\n', '     * @param  _affiliate Address to set as affiliate\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function approveAndBuyAffiliated(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather, address _affiliate) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\n', '        approved[_cozyCandidate] = _auction;\n', '        // solhint-disable-next-line max-line-length\n', '        CozyTimeAuction(_auction).buyCozyAffiliated.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender, _affiliate); //breeding resets approval\n', '    }\n', '\n', '    /**\n', '     * @dev get Pepe information\n', '     * @param  _pepeId ID of the Pepe to get information of\n', '     * @return master\n', '     * @return genotype\n', '     * @return canCozyAgain\n', '     * @return generation\n', '     * @return father\n', '     * @return mother\n', '     * @return pepeName\n', '     * @return coolDownIndex\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function getPepe(uint256 _pepeId) public view returns(address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\n', '        Pepe storage tempPep = pepes[_pepeId];\n', '\n', '        master = tempPep.master;\n', '        genotype = tempPep.genotype;\n', '        canCozyAgain = tempPep.canCozyAgain;\n', '        generation = tempPep.generation;\n', '        father = tempPep.father;\n', '        mother = tempPep.mother;\n', '        pepeName = pepeNames[_pepeId];\n', '        coolDownIndex = tempPep.coolDownIndex;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the time when a pepe can cozy again\n', '     * @param  _pepeId ID of the pepe\n', '     * @return Time when the pepe can cozy again\n', '     */\n', '    function getCozyAgain(uint256 _pepeId) public view returns(uint64) {\n', '        return pepes[_pepeId].canCozyAgain;\n', '    }\n', '\n', '    /**\n', '     *  ERC721 Compatibility\n', '     *\n', '     */\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /**\n', '     * @dev Get the total number of Pepes\n', '     * @return total Returns the total number of pepes\n', '     */\n', '    function totalSupply() public view returns(uint256 total) {\n', '        total = pepes.length - balances[address(0)];\n', '        return total;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the number of pepes owned by an address\n', '     * @param  _owner Address to get the balance from\n', '     * @return balance The number of pepes\n', '     */\n', '    function balanceOf(address _owner) external view returns (uint256 balance) {\n', '        balance = balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Get the owner of a Pepe\n', '     * @param  _tokenId the token to get the owner of\n', '     * @return _owner the owner of the pepe\n', '     */\n', '    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\n', '        _owner = pepes[_tokenId].master;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the id of an token by its index\n', '     * @param _owner The address to look up the tokens of\n', '     * @param _index Index to look at\n', '     * @return tokenId the ID of the token of the owner at the specified index\n', '     */\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256 tokenId) {\n', '        //The index must be smaller than the balance,\n', '        // to guarantee that there is no leftover token returned.\n', '        require(_index < balances[_owner]);\n', '\n', '        return wallets[_owner][_index];\n', '    }\n', '\n', '    /**\n', '     * @dev Private method that ads a token to the wallet\n', '     * @param _owner Address of the owner\n', '     * @param _tokenId Pepe ID to add\n', '     */\n', '    function addToWallet(address _owner, uint256 _tokenId) private {\n', '        uint256[] storage wallet = wallets[_owner];\n', '        uint256 balance = balances[_owner];\n', '        if (balance < wallet.length) {\n', '            wallet[balance] = _tokenId;\n', '        } else {\n', '            wallet.push(_tokenId);\n', '        }\n', '        //increase owner balance\n', '        //overflow is not likely to happen(need very large amount of pepes)\n', '        balances[_owner] += 1;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove a token from a address's wallet\n", '     * @param _owner Address of the owner\n', '     * @param _tokenId Token to remove from the wallet\n', '     */\n', '    function removeFromWallet(address _owner, uint256 _tokenId) private {\n', '        uint256[] storage wallet = wallets[_owner];\n', '        uint256 i = 0;\n', '        // solhint-disable-next-line no-empty-blocks\n', '        for (; wallet[i] != _tokenId; i++) {\n', '            // not the pepe we are looking for\n', '        }\n', '        if (wallet[i] == _tokenId) {\n', '            //found it!\n', '            uint256 last = balances[_owner] - 1;\n', '            if (last > 0) {\n', '                //move the last item to this spot, the last will become inaccessible\n', '                wallet[i] = wallet[last];\n', '            }\n', '            //else: no last item to move, the balance is 0, making everything inaccessible.\n', '\n', '            //only decrease balance if _tokenId was in the wallet\n', '            balances[_owner] -= 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal transfer function\n', '     * @param _from Address sending the token\n', '     * @param _to Address to token is send to\n', '     * @param _tokenId ID of the token to send\n', '     */\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        pepes[_tokenId].master = _to;\n', '        approved[_tokenId] = address(0);//reset approved of pepe on every transfer\n', '\n', '        //remove the token from the _from wallet\n', '        removeFromWallet(_from, _tokenId);\n', '\n', '        //add the token to the _to wallet\n', '        addToWallet(_to, _tokenId);\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev transfer a token. Can only be called by the owner of the token\n', '     * @param  _to Addres to send the token to\n', '     * @param  _tokenId ID of the token to send\n', '     */\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    function transfer(address _to, uint256 _tokenId) public stopWhenHalted\n', '        onlyPepeMaster(_tokenId) //check if msg.sender is the master of this pepe\n', '        returns(bool)\n', '    {\n', '        _transfer(msg.sender, _to, _tokenId);//after master modifier invoke internal transfer\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve a address to send a token\n', '     * @param _to Address to approve\n', '     * @param _tokenId Token to set approval for\n', '     */\n', '    function approve(address _to, uint256 _tokenId) external stopWhenHalted\n', '        onlyPepeMaster(_tokenId)\n', '    {\n', '        approved[_tokenId] = _to;\n', '        emit Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve or revoke approval an address for al tokens of a user\n', '     * @param _operator Address to (un)approve\n', '     * @param _approved Approving or revoking indicator\n', '     */\n', '    function setApprovalForAll(address _operator, bool _approved) external stopWhenHalted {\n', '        if (_approved) {\n', '            approvedForAll[msg.sender][_operator] = true;\n', '        } else {\n', '            approvedForAll[msg.sender][_operator] = false;\n', '        }\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Get approved address for a token\n', '     * @param _tokenId Token ID to get the approved address for\n', '     * @return The address that is approved for this token\n', '     */\n', '    function getApproved(uint256 _tokenId) external view returns (address) {\n', '        return approved[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Get if an operator is approved for all tokens of that owner\n', '     * @param _owner Owner to check the approval for\n', '     * @param _operator Operator to check approval for\n', '     * @return Boolean indicating if the operator is approved for that owner\n', '     */\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        return approvedForAll[_owner][_operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to signal support for an interface\n', '     * @param interfaceID the ID of the interface to check for\n', '     * @return Boolean indicating support\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n', '        if (interfaceID == 0x80ac58cd || interfaceID == 0x01ffc9a7) { //TODO: add more interfaces the contract supports\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Safe transferFrom function\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     */\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external stopWhenHalted {\n', '        _safeTransferFromInternal(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safe transferFrom function with aditional data attribute\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @param _data Data to pass along call\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external stopWhenHalted {\n', '        _safeTransferFromInternal(_from, _to, _tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal Safe transferFrom function with aditional data attribute\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @param _data Data to pass along call\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function _safeTransferFromInternal(address _from, address _to, uint256 _tokenId, bytes _data) internal onlyAllowed(_tokenId) {\n', '        require(pepes[_tokenId].master == _from);//check if from is current owner\n', '        require(_to != address(0));//throw on zero address\n', '\n', '        _transfer(_from, _to, _tokenId); //transfer token\n', '\n', '        if (isContract(_to)) { //check if is contract\n', '            // solhint-disable-next-line max-line-length\n', '            require(ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data) == bytes4(keccak256("onERC721Received(address,uint256,bytes)")));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev TransferFrom function\n', '     * @param _from Address currently owning the token\n', '     * @param _to Address to send token to\n', '     * @param _tokenId ID of the token to send\n', '     * @return If it was successful\n', '     */\n', '    // solhint-disable-next-line max-line-length\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public stopWhenHalted onlyAllowed(_tokenId) returns(bool) {\n', '        require(pepes[_tokenId].master == _from);//check if _from is really the master.\n', '        require(_to != address(0));\n', '        _transfer(_from, _to, _tokenId);//handles event, balances and approval reset;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Utility method to check if an address is a contract\n', '     * @param _address Address to check\n', '     * @return Boolean indicating if the address is a contract\n', '     */\n', '    function isContract(address _address) internal view returns (bool) {\n', '        uint size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(_address) }\n', '        return size > 0;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/PepToken.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract PepToken is StandardToken {\n', '\n', '    string public name = "PEP Token";\n', '    string public symbol = "PEP";\n', '    uint8 public decimals = 18;\n', '    uint256 public constant INITIAL_BALANCE = 45000000 ether;\n', '\n', '    constructor() public {\n', '        balances[msg.sender] = INITIAL_BALANCE;\n', '        totalSupply_ = INITIAL_BALANCE;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow spender to revoke its own allowance\n', '     * @param _from Address from which allowance should be revoked\n', '     */\n', '    function revokeAllowance(address _from) public {\n', '        allowed[_from][msg.sender] = 0;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/PepeGrinder.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.4;\n', '\n', '\n', '\n', '\n', '\n', 'contract PepeGrinder is StandardToken, Ownable {\n', '\n', '    address public pepeContract;\n', '    address public miner;\n', '    uint256[] public pepes;\n', '    mapping(address => bool) public dusting;\n', '\n', '    string public name = "CryptoPepes DUST";\n', '    string public symbol = "DPEP";\n', '    uint8 public decimals = 18;\n', '\n', '    uint256 public constant DUST_PER_PEPE = 100 ether;\n', '\n', '    constructor(address _pepeContract) public {\n', '        pepeContract = _pepeContract;\n', '    }\n', '\n', '    /**\n', '     * Set the mining contract. Can only be set once\n', '     * @param _miner The address of the miner contract\n', '     */\n', '    function setMiner(address _miner) public onlyOwner {\n', '        require(miner == address(0));// can only be set once\n', '        miner = _miner;\n', '    }\n', '\n', '    /**\n', '     * Gets called by miners who wanna dust their mined Pepes\n', '     */\n', '    function setDusting() public {\n', '        dusting[msg.sender] = true;\n', '    }\n', '\n', '    /**\n', '     * Dust a pepe to pepeDust\n', '     * @param _pepeId Pepe to dust\n', '     * @param _miner address of the miner\n', '     */\n', '    function dustPepe(uint256 _pepeId, address _miner) public {\n', '        require(msg.sender == miner);\n', '        balances[_miner] += DUST_PER_PEPE;\n', '        pepes.push(_pepeId);\n', '        totalSupply_ += DUST_PER_PEPE;\n', '        emit Transfer(address(0), _miner, DUST_PER_PEPE);\n', '    }\n', '\n', '    /**\n', '     * Convert dust into a Pepe\n', '     */\n', '    function claimPepe() public {\n', '        require(balances[msg.sender] >= DUST_PER_PEPE);\n', '\n', '        balances[msg.sender] -= DUST_PER_PEPE; //change balance and total supply\n', '        totalSupply_ -= DUST_PER_PEPE;\n', '\n', '        PepeBase(pepeContract).transfer(msg.sender, pepes[pepes.length-1]);//transfer pepe\n', '        pepes.length -= 1;\n', '        emit Transfer(msg.sender, address(0), DUST_PER_PEPE);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Math/ExtendedMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library ExtendedMath {\n', '  //return the smaller of the two inputs (a or b)\n', '  function limitLessThan(uint a, uint b) internal pure returns (uint c) {\n', '    if(a > b) return b;\n', '    return a;\n', '  }\n', '}\n', '\n', '// File: contracts/Mining.sol\n', '\n', '// solhint-disable-next-line\n', 'pragma solidity ^0.4.4;\n', '\n', '// solhint-disable max-line-length\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// solhint-disable-next-line\n', 'contract Mining is Beneficiary {\n', '\n', '    using SafeMath for uint;\n', '    using ExtendedMath for uint;\n', '\n', '    uint public latestDifficultyPeriodStarted = block.number;\n', "    uint public epochCount = 0;//number of 'blocks' mined\n", '    uint public constant MAX_EPOCH_COUNT = 16000;\n', '    uint public baseMiningReward = 2500 ether;\n', '    uint public blocksPerReadjustment = 20;\n', '    uint public tokensMinted;\n', '\n', '    // solhint-disable var-name-mixedcase\n', '    uint public _MINIMUM_TARGET = 2**16;\n', '    uint public _MAXIMUM_TARGET = 2**250; //Testing setting!\n', '    //uint public _MAXIMUM_TARGET = 2**230; //SHOULD MAKE THIS HARDER IN PRODUCTION\n', '\n', '    uint public constant STARTING_DIFFICULTY = 0x00000000000b4963208fc24a4a15e9ea7c1556f9583f1941a7515fabbd194584;\n', '\n', '    bytes32 public challengeNumber;\n', '    uint public difficulty;\n', '    uint public MINING_RATE_FACTOR = 31; //mint the token 31 times less often than ether\n', '    //difficulty adjustment parameters- be careful modifying these\n', '    uint public MAX_ADJUSTMENT_PERCENT = 100;\n', '    uint public TARGET_DIVISOR = 2000;\n', '    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\n', '    mapping(bytes32 => bytes32) public solutionForChallenge;\n', '\n', '    Statistics public statistics;\n', '\n', '    PepeBase public pepeContract;\n', '    PepToken public pepToken;\n', '    PepeGrinder public pepeGrinder;\n', '\n', '    uint256 public miningStart;//timestamp when mining starts\n', '\n', '    event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    // track read only minting statistics\n', '    struct Statistics {\n', '        address lastRewardTo;\n', '        uint lastRewardAmount;\n', '        uint lastRewardEthBlockNumber;\n', '        uint lastRewardTimestamp;\n', '    }\n', '\n', '    constructor(address _pepeContract, address _pepToken, address _pepeGrinder, uint256 _miningStart) public {\n', '        pepeContract = PepeBase(_pepeContract);\n', '        pepToken = PepToken(_pepToken);\n', '        pepeGrinder = PepeGrinder(_pepeGrinder);\n', '        difficulty = STARTING_DIFFICULTY;\n', '        miningStart = _miningStart;\n', '    }\n', '\n', '    /**\n', '     * Mint a new pepe if noce is correct\n', '     * @param nonce The nonce to submit\n', '     * @param challengeDigest The resulting digest\n', '     * @return success Boolean indicating if mint was successful\n', '     */\n', '    // solhint-disable-next-line\n', '    function mint(uint256 nonce, bytes32 challengeDigest) public returns (bool success) {\n', '        require(epochCount < MAX_EPOCH_COUNT);//max 16k blocks\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now > miningStart);\n', '        // perform the hash function validation\n', '        _hash(nonce, challengeDigest);\n', '\n', '        // calculate the current reward\n', '        uint rewardAmount = _reward(nonce);\n', '\n', '        // increment the minted tokens amount\n', '        tokensMinted += rewardAmount;\n', '\n', '        epochCount += 1;\n', '        challengeNumber = blockhash(block.number - 1);\n', '\n', '        _adjustDifficulty();\n', '\n', '        //populate read only diagnostics data\n', '        // solhint-disable-next-line not-rely-on-time\n', '        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\n', '\n', '        // send Mint event indicating a successful implementation\n', '        emit Mint(msg.sender, rewardAmount, epochCount, challengeNumber);\n', '\n', '        if (epochCount == MAX_EPOCH_COUNT) { //destroy this smart contract on the latest block\n', '            selfdestruct(msg.sender);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Get the current challengeNumber\n', '     * @return bytes32 challengeNumber\n', '     */\n', '    function getChallengeNumber() public constant returns (bytes32) {\n', '        return challengeNumber;\n', '    }\n', '\n', '    /**\n', '     * Get the current mining difficulty\n', '     * @return the current difficulty\n', '     */\n', '    function getMiningDifficulty() public constant returns (uint) {\n', '        return _MAXIMUM_TARGET.div(difficulty);\n', '    }\n', '\n', '    /**\n', '     * Get the mining target\n', '     * @return The current mining target\n', '     */\n', '    function getMiningTarget() public constant returns (uint256) {\n', '        return difficulty;\n', '    }\n', '\n', '    /**\n', '     * Get the mining reward\n', '     * @return The current mining reward. Always 2500PEP\n', '     */\n', '    function getMiningReward() public constant returns (uint256) {\n', '        return baseMiningReward;\n', '    }\n', '\n', '    /**\n', '     * Helper method to check a nonce\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest the digest to check\n', '     * @param challengeNumber to check\n', '     * @return digesttest The resulting digest\n', '     */\n', '    // solhint-disable-next-line\n', '    function getMintDigest(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber) public view returns (bytes32 digesttest) {\n', '        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        return digest;\n', '    }\n', '\n', '    /**\n', '     * Helper method to check if a nonce meets the difficulty\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest the digest to check\n', '     * @param challengeNumber the challenge number to check\n', '     * @param testTarget the difficulty to check\n', '     * @return success Boolean indicating success\n', '     */\n', '    function checkMintSolution(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber, uint testTarget) public view returns (bool success) {\n', '        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        if (uint256(digest) > testTarget) revert();\n', '        return (digest == challengeDigest);\n', '    }\n', '\n', '    /**\n', '     * Internal function to check a hash\n', '     * @param nonce The nonce to check\n', '     * @param challengeDigest it should create\n', '     * @return digest The digest created\n', '     */\n', '    function _hash(uint256 nonce, bytes32 challengeDigest) internal returns (bytes32 digest) {\n', '        digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\n', '        //the challenge digest must match the expected\n', '        if (digest != challengeDigest) revert();\n', '        //the digest must be smaller than the target\n', '        if (uint256(digest) > difficulty) revert();\n', '        //only allow one reward for each challenge\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        solutionForChallenge[challengeNumber] = digest;\n', '        if (solution != 0x0) revert();  //prevent the same answer from awarding twice\n', '    }\n', '\n', '    /**\n', '     * Reward a miner Pep tokens\n', '     * @param nonce Nonce to use as seed for Pepe dna creation\n', '     * @return The amount of PEP tokens rewarded\n', '     */\n', '    function _reward(uint256 nonce) internal returns (uint) {\n', '        uint reward_amount = getMiningReward();\n', '        pepToken.transfer(msg.sender, reward_amount);\n', '\n', '        if (epochCount % 16 == 0) { //every 16th block reward a pepe\n', '            if (pepeGrinder.dusting(msg.sender)) { //if miner is pool mining send it through the grinder\n', '                uint256 newPepe = pepeContract.minePepe(nonce, address(pepeGrinder));\n', '                pepeGrinder.dustPepe(newPepe, msg.sender);\n', '            } else {\n', '                pepeContract.minePepe(nonce, msg.sender);\n', '            }\n', '            //every 16th block send part of the block reward\n', '            pepToken.transfer(beneficiary, reward_amount);\n', '        }\n', '\n', '        return reward_amount;\n', '    }\n', '\n', '    /**\n', '     * Internal method to readjust difficulty\n', '     * @return The new difficulty\n', '     */\n', '    function _adjustDifficulty() internal returns (uint) {\n', '        //every so often, readjust difficulty. Dont readjust when deploying\n', '        if (epochCount % blocksPerReadjustment != 0) {\n', '            return difficulty;\n', '        }\n', '\n', '        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n', '        //assume 360 ethereum blocks per hour\n', "        //we want miners to spend 8 minutes to mine each 'block', about 31 ethereum blocks = one CryptoPepes block\n", '        uint epochsMined = blocksPerReadjustment;\n', '        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\n', '        //if there were less eth blocks passed in time than expected\n', '        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\n', '            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\n', '            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\n', '            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n', '            //make it harder\n', '            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra));   //by up to 50 %\n', '        } else {\n', '            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\n', '            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\n', '            //make it easier\n', '            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra));   //by up to 50 %\n', '        }\n', '        latestDifficultyPeriodStarted = block.number;\n', '        if (difficulty < _MINIMUM_TARGET) { //very dificult\n', '            difficulty = _MINIMUM_TARGET;\n', '        }\n', '        if (difficulty > _MAXIMUM_TARGET) { //very easy\n', '            difficulty = _MAXIMUM_TARGET;\n', '        }\n', '\n', '        return difficulty;\n', '    }\n', '\n', '}']
