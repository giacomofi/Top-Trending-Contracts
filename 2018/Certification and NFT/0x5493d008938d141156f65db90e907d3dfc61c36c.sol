['pragma solidity 0.4.24;\n', 'pragma experimental "v0.5.0";\n', '\n', '/*\n', '\n', '    Copyright 2018 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '\n', '  function max256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) internal balances;\n', '\n', '  uint256 internal totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_value <= balances[msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    require(_to != address(0));\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue >= oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/lib/AccessControlledBase.sol\n', '\n', '/**\n', ' * @title AccessControlledBase\n', ' * @author dYdX\n', ' *\n', ' * Base functionality for access control. Requires an implementation to\n', ' * provide a way to grant and optionally revoke access\n', ' */\n', 'contract AccessControlledBase {\n', '    // ============ State Variables ============\n', '\n', '    mapping (address => bool) public authorized;\n', '\n', '    // ============ Events ============\n', '\n', '    event AccessGranted(\n', '        address who\n', '    );\n', '\n', '    event AccessRevoked(\n', '        address who\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier requiresAuthorization() {\n', '        require(\n', '            authorized[msg.sender],\n', '            "AccessControlledBase#requiresAuthorization: Sender not authorized"\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/StaticAccessControlled.sol\n', '\n', '/**\n', ' * @title StaticAccessControlled\n', ' * @author dYdX\n', ' *\n', ' * Allows for functions to be access controled\n', ' * Permissions cannot be changed after a grace period\n', ' */\n', 'contract StaticAccessControlled is AccessControlledBase, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Timestamp after which no additional access can be granted\n', '    uint256 public GRACE_PERIOD_EXPIRATION;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        Ownable()\n', '    {\n', '        GRACE_PERIOD_EXPIRATION = block.timestamp.add(gracePeriod);\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function grantAccess(\n', '        address who\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            block.timestamp < GRACE_PERIOD_EXPIRATION,\n', '            "StaticAccessControlled#grantAccess: Cannot grant access after grace period"\n', '        );\n', '\n', '        emit AccessGranted(who);\n', '        authorized[who] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/GeneralERC20.sol\n', '\n', '/**\n', ' * @title GeneralERC20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', ' * that we dont automatically revert when calling non-compliant tokens that have no return value for\n', ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface GeneralERC20 {\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/TokenInteract.sol\n', '\n', '/**\n', ' * @title TokenInteract\n', ' * @author dYdX\n', ' *\n', ' * This library contains basic functions for interacting with ERC20 tokens\n', ' */\n', 'library TokenInteract {\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        GeneralERC20(token).approve(spender, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#approve: Approval failed"\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        address from = address(this);\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transfer(to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transfer: Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transferFrom(from, to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transferFrom: TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/TokenProxy.sol\n', '\n', '/**\n', ' * @title TokenProxy\n', ' * @author dYdX\n', ' *\n', ' * Used to transfer tokens between addresses which have set allowance on this contract.\n', ' */\n', 'contract TokenProxy is StaticAccessControlled {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {}\n', '\n', '    // ============ Authorized-Only State Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy) to another address.\n', '     *\n', '     * @param  token  The address of the ERC20 token\n', '     * @param  from   The address to transfer token from\n', '     * @param  to     The address to transfer tokens to\n', '     * @param  value  The number of tokens to transfer\n', '     */\n', '    function transferTokens(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        TokenInteract.transferFrom(\n', '            token,\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Getter function to get the amount of token that the proxy is able to move for a particular\n', '     * address. The minimum of 1) the balance of that address and 2) the allowance given to proxy.\n', '     *\n', '     * @param  who    The owner of the tokens\n', '     * @param  token  The address of the ERC20 token\n', '     * @return        The number of tokens able to be moved by the proxy from the address specified\n', '     */\n', '    function available(\n', '        address who,\n', '        address token\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return Math.min256(\n', '            TokenInteract.allowance(token, who, address(this)),\n', '            TokenInteract.balanceOf(token, who)\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Vault.sol\n', '\n', '/**\n', ' * @title Vault\n', ' * @author dYdX\n', ' *\n', ' * Holds and transfers tokens in vaults denominated by id\n', ' *\n', ' * Vault only supports ERC20 tokens, and will not accept any tokens that require\n', ' * a tokenFallback or equivalent function (See ERC223, ERC777, etc.)\n', ' */\n', 'contract Vault is StaticAccessControlled\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event ExcessTokensWithdrawn(\n', '        address indexed token,\n', '        address indexed to,\n', '        address caller\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Address of the TokenProxy contract. Used for moving tokens.\n', '    address public TOKEN_PROXY;\n', '\n', '    // Map from vault ID to map from token address to amount of that token attributed to the\n', '    // particular vault ID.\n', '    mapping (bytes32 => mapping (address => uint256)) public balances;\n', '\n', '    // Map from token address to total amount of that token attributed to some account.\n', '    mapping (address => uint256) public totalBalances;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address proxy,\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {\n', '        TOKEN_PROXY = proxy;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n', '     * including (but not limited-to) token airdrops. Any tokens moved to the vault by TOKEN_PROXY\n', '     * will be accounted for and will not be withdrawable by this function.\n', '     *\n', '     * @param  token  ERC20 token address\n', '     * @param  to     Address to transfer tokens to\n', '     * @return        Amount of tokens withdrawn\n', '     */\n', '    function withdrawExcessToken(\n', '        address token,\n', '        address to\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        uint256 actualBalance = TokenInteract.balanceOf(token, address(this));\n', '        uint256 accountedBalance = totalBalances[token];\n', '        uint256 withdrawableBalance = actualBalance.sub(accountedBalance);\n', '\n', '        require(\n', '            withdrawableBalance != 0,\n', '            "Vault#withdrawExcessToken: Withdrawable token amount must be non-zero"\n', '        );\n', '\n', '        TokenInteract.transfer(token, to, withdrawableBalance);\n', '\n', '        emit ExcessTokensWithdrawn(token, to, msg.sender);\n', '\n', '        return withdrawableBalance;\n', '    }\n', '\n', '    // ============ Authorized-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has approved the proxy) to the vault.\n', '     *\n', '     * @param  id      The vault which will receive the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  from    Address from which the tokens will be taken\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferToVault(\n', '        bytes32 id,\n', '        address token,\n', '        address from,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // First send tokens to this contract\n', '        TokenProxy(TOKEN_PROXY).transferTokens(\n', '            token,\n', '            from,\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        // Then increment balances\n', '        balances[id][token] = balances[id][token].add(amount);\n', '        totalBalances[token] = totalBalances[token].add(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        validateBalance(token);\n', '    }\n', '\n', '    /**\n', '     * Transfers a certain amount of funds to an address.\n', '     *\n', '     * @param  id      The vault from which to send the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  to      Address to transfer tokens to\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferFromVault(\n', '        bytes32 id,\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // Next line also asserts that (balances[id][token] >= amount);\n', '        balances[id][token] = balances[id][token].sub(amount);\n', '\n', '        // Next line also asserts that (totalBalances[token] >= amount);\n', '        totalBalances[token] = totalBalances[token].sub(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        // Do the sending\n', '        TokenInteract.transfer(token, to, amount); // asserts transfer succeeded\n', '\n', '        // Final validation\n', '        validateBalance(token);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Verifies that this contract is in control of at least as many tokens as accounted for\n', '     *\n', '     * @param  token  Address of ERC20 token\n', '     */\n', '    function validateBalance(\n', '        address token\n', '    )\n', '        private\n', '        view\n', '    {\n', '        // The actual balance could be greater than totalBalances[token] because anyone\n', "        // can send tokens to the contract's address which cannot be accounted for\n", '        assert(TokenInteract.balanceOf(token, address(this)) >= totalBalances[token]);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author dYdX\n', ' *\n', ' * Optimized version of the well-known ReentrancyGuard contract\n', ' */\n', 'contract ReentrancyGuard {\n', '    uint256 private _guardCounter = 1;\n', '\n', '    modifier nonReentrant() {\n', '        uint256 localCounter = _guardCounter + 1;\n', '        _guardCounter = localCounter;\n', '        _;\n', '        require(\n', '            _guardCounter == localCounter,\n', '            "Reentrancy check failure"\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/lib/Fraction.sol\n', '\n', '/**\n', ' * @title Fraction\n', ' * @author dYdX\n', ' *\n', ' * This library contains implementations for fraction structs.\n', ' */\n', 'library Fraction {\n', '    struct Fraction128 {\n', '        uint128 num;\n', '        uint128 den;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FractionMath.sol\n', '\n', '/**\n', ' * @title FractionMath\n', ' * @author dYdX\n', ' *\n', ' * This library contains safe math functions for manipulating fractions.\n', ' */\n', 'library FractionMath {\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint128;\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a + b\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (sum)\n', '     */\n', '    function add(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 left = a.num.mul(b.den);\n', '        uint256 right = b.num.mul(a.den);\n', '        uint256 denominator = a.den.mul(b.den);\n', '\n', '        // if left + right overflows, prevent overflow\n', '        if (left + right < left) {\n', '            left = left.div(2);\n', '            right = right.div(2);\n', '            denominator = denominator.div(2);\n', '        }\n', '\n', '        return bound(left.add(right), denominator);\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a - (1/2)^d\n', '     *\n', '     * @param  a  The Fraction128\n', '     * @param  d  The power of (1/2)\n', '     * @return    The result\n', '     */\n', '    function sub1Over(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.den % d == 0) {\n', '            return bound(\n', '                a.num.sub(a.den.div(d)),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num.mul(d).sub(a.den),\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a / d\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  d  The divisor\n', '     * @return    The result (quotient)\n', '     */\n', '    function div(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.num % d == 0) {\n', '            return bound(\n', '                a.num.div(d),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num,\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a * b.\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (product)\n', '     */\n', '    function mul(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return bound(\n', '            a.num.mul(b.num),\n', '            a.den.mul(b.den)\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Returns a fraction from two uint256's. Fits them into uint128 if necessary.\n", '     *\n', '     * @param  num  The numerator\n', '     * @param  den  The denominator\n', '     * @return      The Fraction128 that matches num/den most closely\n', '     */\n', '    /* solium-disable-next-line security/no-assign-params */\n', '    function bound(\n', '        uint256 num,\n', '        uint256 den\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 max = num > den ? num : den;\n', '        uint256 first128Bits = (max >> 128);\n', '        if (first128Bits != 0) {\n', '            first128Bits += 1;\n', '            num /= first128Bits;\n', '            den /= first128Bits;\n', '        }\n', '\n', '        assert(den != 0); // coverage-enable-line\n', '        assert(den < 2**128);\n', '        assert(num < 2**128);\n', '\n', '        return Fraction.Fraction128({\n', '            num: uint128(num),\n', '            den: uint128(den)\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns an in-memory copy of a Fraction128\n', '     *\n', '     * @param  a  The Fraction128 to copy\n', '     * @return    A copy of the Fraction128\n', '     */\n', '    function copy(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        validate(a);\n', '        return Fraction.Fraction128({ num: a.num, den: a.den });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\n', '     *\n', '     * @param  a  The Fraction128 to validate\n', '     */\n', '    function validate(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        assert(a.den != 0); // coverage-enable-line\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Exponent.sol\n', '\n', '/**\n', ' * @title Exponent\n', ' * @author dYdX\n', ' *\n', ' * This library contains an implementation for calculating e^X for arbitrary fraction X\n', ' */\n', 'library Exponent {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    // 2**128 - 1\n', '    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\n', '\n', '    // Number of precomputed integers, X, for E^((1/2)^X)\n', '    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\n', '\n', '    // Number of precomputed integers, X, for E^X\n', '    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns e^X for any fraction X\n', '     *\n', '     * @param  X                    The exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function exp(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        require(\n', '            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\n', '            "Exponent#exp: Precompute precision over maximum"\n', '        );\n', '\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\n', '        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\n', '\n', '        // if X is less than 1, then just calculate X\n', '        if (integerX == 0) {\n', '            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\n', '        }\n', '\n', '        // get e^integerX\n', '        Fraction.Fraction128 memory expOfInt =\n', '            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\n', '        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\n', '            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\n', '            integerX -= NUM_PRECOMPUTED_INTEGERS;\n', '        }\n', '\n', '        // multiply e^integerX by e^decimalX\n', '        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\n', '            num: Xcopy.num % Xcopy.den,\n', '            den: Xcopy.den\n', '        });\n', '        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\n', '     * Maclaurin Series approximation to reduce error.\n', '     *\n', '     * @param  X                    Exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function expHybrid(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\n', '        assert(X.num < X.den);\n', '        // will also throw if precomputePrecision is larger than the array length in getDenominator\n', '\n', '        Fraction.Fraction128 memory Xtemp = X.copy();\n', '        if (Xtemp.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '\n', '        uint256 d = 1; // 2^i\n', '        for (uint256 i = 1; i <= precomputePrecision; i++) {\n', '            d *= 2;\n', '\n', '            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\n', '            if (d.mul(Xtemp.num) >= Xtemp.den) {\n', '                Xtemp = Xtemp.sub1Over(uint128(d));\n', '                result = result.mul(getPrecomputedEToTheHalfToThe(i));\n', '            }\n', '        }\n', '        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X, using Maclaurin Series approximation\n', '     *\n', '     * e^X = SUM(X^n / n!) for n >= 0\n', '     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\n', '     *\n', '     * @param  X           Exponent\n', '     * @param  precision   Accuracy of Maclaurin terms\n', '     * @return             e^X\n', '     */\n', '    function expMaclaurin(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '        Fraction.Fraction128 memory Xtemp = ONE();\n', '        for (uint256 i = 1; i <= precision; i++) {\n', '            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\n', '            result = result.add(Xtemp);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\n', '     */\n', '    function getPrecomputedEToTheHalfToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= MAX_PRECOMPUTE_PRECISION);\n', '\n', '        uint128 denominator = [\n', '            125182886983370532117250726298150828301,\n', '            206391688497133195273760705512282642279,\n', '            265012173823417992016237332255925138361,\n', '            300298134811882980317033350418940119802,\n', '            319665700530617779809390163992561606014,\n', '            329812979126047300897653247035862915816,\n', '            335006777809430963166468914297166288162,\n', '            337634268532609249517744113622081347950,\n', '            338955731696479810470146282672867036734,\n', '            339618401537809365075354109784799900812,\n', '            339950222128463181389559457827561204959,\n', '            340116253979683015278260491021941090650,\n', '            340199300311581465057079429423749235412,\n', '            340240831081268226777032180141478221816,\n', '            340261598367316729254995498374473399540,\n', '            340271982485676106947851156443492415142,\n', '            340277174663693808406010255284800906112,\n', '            340279770782412691177936847400746725466,\n', '            340281068849199706686796915841848278311,\n', '            340281717884450116236033378667952410919,\n', '            340282042402539547492367191008339680733,\n', '            340282204661700319870089970029119685699,\n', '            340282285791309720262481214385569134454,\n', '            340282326356121674011576912006427792656,\n', '            340282346638529464274601981200276914173,\n', '            340282356779733812753265346086924801364,\n', '            340282361850336100329388676752133324799,\n', '            340282364385637272451648746721404212564,\n', '            340282365653287865596328444437856608255,\n', '            340282366287113163939555716675618384724,\n', '            340282366604025813553891209601455838559,\n', '            340282366762482138471739420386372790954,\n', '            340282366841710300958333641874363209044\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^(x) for integer x\n', '     */\n', '    function getPrecomputedEToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= NUM_PRECOMPUTED_INTEGERS);\n', '\n', '        uint128 denominator = [\n', '            340282366920938463463374607431768211455,\n', '            125182886983370532117250726298150828301,\n', '            46052210507670172419625860892627118820,\n', '            16941661466271327126146327822211253888,\n', '            6232488952727653950957829210887653621,\n', '            2292804553036637136093891217529878878,\n', '            843475657686456657683449904934172134,\n', '            310297353591408453462393329342695980,\n', '            114152017036184782947077973323212575,\n', '            41994180235864621538772677139808695,\n', '            15448795557622704876497742989562086,\n', '            5683294276510101335127414470015662,\n', '            2090767122455392675095471286328463,\n', '            769150240628514374138961856925097,\n', '            282954560699298259527814398449860,\n', '            104093165666968799599694528310221,\n', '            38293735615330848145349245349513,\n', '            14087478058534870382224480725096,\n', '            5182493555688763339001418388912,\n', '            1906532833141383353974257736699,\n', '            701374233231058797338605168652,\n', '            258021160973090761055471434334,\n', '            94920680509187392077350434438,\n', '            34919366901332874995585576427,\n', '            12846117181722897538509298435,\n', '            4725822410035083116489797150,\n', '            1738532907279185132707372378,\n', '            639570514388029575350057932,\n', '            235284843422800231081973821,\n', '            86556456714490055457751527,\n', '            31842340925906738090071268,\n', '            11714142585413118080082437,\n', '            4309392228124372433711936\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function ONE()\n', '        private\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return Fraction.Fraction128({ num: 1, den: 1 });\n', '    }\n', '}\n', '\n', '// File: contracts/lib/MathHelpers.sol\n', '\n', '/**\n', ' * @title MathHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with common math functions in Solidity\n', ' */\n', 'library MathHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              target * numerator / denominator\n', '     */\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              Rounded-up result of target * numerator / denominator\n', '     */\n', '    function getPartialAmountRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return divisionRoundedUp(numerator.mul(target), denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates division given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator.\n', '     * @param  denominator  Denominator.\n', '     * @return              Rounded-up result of numerator / denominator\n', '     */\n', '    function divisionRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(denominator != 0); // coverage-enable-line\n', '        if (numerator == 0) {\n', '            return 0;\n', '        }\n', '        return numerator.sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint256(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint32(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        return 2 ** 32 - 1;\n', '    }\n', '\n', '    /**\n', '     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n', '     *\n', '     * @param  n  The uint256 to get the number of bits in\n', '     * @return    The number of bits in n\n', '     */\n', '    function getNumBits(\n', '        uint256 n\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 first = 0;\n', '        uint256 last = 256;\n', '        while (first < last) {\n', '            uint256 check = (first + last) / 2;\n', '            if ((n >> check) == 0) {\n', '                last = check;\n', '            } else {\n', '                first = check + 1;\n', '            }\n', '        }\n', '        assert(first <= 256);\n', '        return first;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/InterestImpl.sol\n', '\n', '/**\n', ' * @title InterestImpl\n', ' * @author dYdX\n', ' *\n', ' * A library that calculates continuously compounded interest for principal, time period, and\n', ' * interest rate.\n', ' */\n', 'library InterestImpl {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\n', '\n', '    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\n', '\n', '    uint256 constant MAXIMUM_EXPONENT = 80;\n', '\n', '    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\n', '     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\n', '     * I = P * e^(R*T)\n', '     *\n', '     * @param  principal           Principal of the interest calculation\n', '     * @param  interestRate        Annual nominal interest percentage times 10**6.\n', '     *                             (example: 5% = 5e6)\n', '     * @param  secondsOfInterest   Number of seconds that interest has been accruing\n', '     * @return                     Total amount of tokens owed. Greater than tokenAmount.\n', '     */\n', '    function getCompoundedInterest(\n', '        uint256 principal,\n', '        uint256 interestRate,\n', '        uint256 secondsOfInterest\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 numerator = interestRate.mul(secondsOfInterest);\n', '        uint128 denominator = (10**8) * (365 * 1 days);\n', '\n', '        // interestRate and secondsOfInterest should both be uint32\n', '        assert(numerator < 2**128);\n', '\n', '        // fraction representing (Rate * Time)\n', '        Fraction.Fraction128 memory rt = Fraction.Fraction128({\n', '            num: uint128(numerator),\n', '            den: denominator\n', '        });\n', '\n', '        // calculate e^(RT)\n', '        Fraction.Fraction128 memory eToRT;\n', '        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\n', '            // degenerate case: cap calculation\n', '            eToRT = Fraction.Fraction128({\n', '                num: E_TO_MAXIUMUM_EXPONENT,\n', '                den: 1\n', '            });\n', '        } else {\n', '            // normal case: calculate e^(RT)\n', '            eToRT = Exponent.exp(\n', '                rt,\n', '                DEFAULT_PRECOMPUTE_PRECISION,\n', '                DEFAULT_MACLAURIN_PRECISION\n', '            );\n', '        }\n', '\n', '        // e^X for positive X should be greater-than or equal to 1\n', '        assert(eToRT.num >= eToRT.den);\n', '\n', '        return safeMultiplyUint256ByFraction(principal, eToRT);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\n', '     * and denominator of f are less than 2**128.\n', '     */\n', '    function safeMultiplyUint256ByFraction(\n', '        uint256 n,\n', '        Fraction.Fraction128 memory f\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 term1 = n.div(2 ** 128); // first 128 bits\n', '        uint256 term2 = n % (2 ** 128); // second 128 bits\n', '\n', '        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\n', '        if (term1 > 0) {\n', '            term1 = term1.mul(f.num);\n', '            uint256 numBits = MathHelpers.getNumBits(term1);\n', '\n', '            // reduce rounding error by shifting all the way to the left before dividing\n', '            term1 = MathHelpers.divisionRoundedUp(\n', '                term1 << (uint256(256).sub(numBits)),\n', '                f.den);\n', '\n', '            // continue shifting or reduce shifting to get the right number\n', '            if (numBits > 128) {\n', '                term1 = term1 << (numBits.sub(128));\n', '            } else if (numBits < 128) {\n', '                term1 = term1 >> (uint256(128).sub(numBits));\n', '            }\n', '        }\n', '\n', '        // calculates term2 = term2 * f\n', '        term2 = MathHelpers.getPartialAmountRoundedUp(\n', '            f.num,\n', '            f.den,\n', '            term2\n', '        );\n', '\n', '        return term1.add(term2);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginState.sol\n', '\n', '/**\n', ' * @title MarginState\n', ' * @author dYdX\n', ' *\n', ' * Contains state for the Margin contract. Also used by libraries that implement Margin functions.\n', ' */\n', 'library MarginState {\n', '    struct State {\n', '        // Address of the Vault contract\n', '        address VAULT;\n', '\n', '        // Address of the TokenProxy contract\n', '        address TOKEN_PROXY;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been filled.\n', '        mapping (bytes32 => uint256) loanFills;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been canceled.\n', '        mapping (bytes32 => uint256) loanCancels;\n', '\n', '        // Mapping from positionId -> Position, which stores all the open margin positions.\n', '        mapping (bytes32 => MarginCommon.Position) positions;\n', '\n', '        // Mapping from positionId -> bool, which stores whether the position has previously been\n', '        // open, but is now closed.\n', '        mapping (bytes32 => bool) closedPositions;\n', '\n', '        // Mapping from positionId -> uint256, which stores the total amount of owedToken that has\n', '        // ever been repaid to the lender for each position. Does not reset.\n', '        mapping (bytes32 => uint256) totalOwedTokenRepaidToLender;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/LoanOwner.sol\n', '\n', '/**\n', ' * @title LoanOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a loan sell via the\n', '     * transferLoan function or the atomic-assign to the "owner" field in a loan offering.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receiveLoanOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/PositionOwner.sol\n', '\n', '/**\n', ' * @title PositionOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PositionOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a position via the\n', '     * transferPosition function or the atomic-assign to the "owner" field when opening a position.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receivePositionOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/TransferInternal.sol\n', '\n', '/**\n', ' * @title TransferInternal\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for transferring ownership of loans and positions.\n', ' */\n', 'library TransferInternal {\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a postion was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Returns either the address of the new loan owner, or the address to which they wish to\n', '     * pass ownership of the loan. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the loan\n', '     * @param  newOwner    The intended owner of the loan\n', '     * @return             The address that the intended owner wishes to assign the loan to (may be\n', '     *                     the same as the intended owner).\n', '     */\n', '    function grantLoanOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit LoanTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                LoanOwner(newOwner).receiveLoanOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantLoanOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantLoanOwnership: New owner did not consent to owning loan"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '\n', '    /**\n', '     * Returns either the address of the new position owner, or the address to which they wish to\n', '     * pass ownership of the position. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the position\n', '     * @param  newOwner    The intended owner of the position\n', '     * @return             The address that the intended owner wishes to assign the position to (may\n', '     *                     be the same as the intended owner).\n', '     */\n', '    function grantPositionOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit PositionTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                PositionOwner(newOwner).receivePositionOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantPositionOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantPositionOwnership: New owner did not consent to owning position"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TimestampHelper.sol\n', '\n', '/**\n', ' * @title TimestampHelper\n', ' * @author dYdX\n', ' *\n', ' * Helper to get block timestamps in other formats\n', ' */\n', 'library TimestampHelper {\n', '    function getBlockTimestamp32()\n', '        internal\n', '        view\n', '        returns (uint32)\n', '    {\n', '        // Should not still be in-use in the year 2106\n', '        assert(uint256(uint32(block.timestamp)) == block.timestamp);\n', '\n', '        assert(block.timestamp > 0);\n', '\n', '        return uint32(block.timestamp);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginCommon.sol\n', '\n', '/**\n', ' * @title MarginCommon\n', ' * @author dYdX\n', ' *\n', ' * This library contains common functions for implementations of public facing Margin functions\n', ' */\n', 'library MarginCommon {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Position {\n', '        address owedToken;       // Immutable\n', '        address heldToken;       // Immutable\n', '        address lender;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 requiredDeposit;\n', '        uint32  callTimeLimit;   // Immutable\n', '        uint32  startTimestamp;  // Immutable, cannot be 0\n', '        uint32  callTimestamp;\n', '        uint32  maxDuration;     // Immutable\n', '        uint32  interestRate;    // Immutable\n', '        uint32  interestPeriod;  // Immutable\n', '    }\n', '\n', '    struct LoanOffering {\n', '        address   owedToken;\n', '        address   heldToken;\n', '        address   payer;\n', '        address   owner;\n', '        address   taker;\n', '        address   positionOwner;\n', '        address   feeRecipient;\n', '        address   lenderFeeToken;\n', '        address   takerFeeToken;\n', '        LoanRates rates;\n', '        uint256   expirationTimestamp;\n', '        uint32    callTimeLimit;\n', '        uint32    maxDuration;\n', '        uint256   salt;\n', '        bytes32   loanHash;\n', '        bytes     signature;\n', '    }\n', '\n', '    struct LoanRates {\n', '        uint256 maxAmount;\n', '        uint256 minAmount;\n', '        uint256 minHeldToken;\n', '        uint256 lenderFee;\n', '        uint256 takerFee;\n', '        uint32  interestRate;\n', '        uint32  interestPeriod;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function storeNewPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        Position memory position,\n', '        address loanPayer\n', '    )\n', '        internal\n', '    {\n', '        assert(!positionHasExisted(state, positionId));\n', '        assert(position.owedToken != address(0));\n', '        assert(position.heldToken != address(0));\n', '        assert(position.owedToken != position.heldToken);\n', '        assert(position.owner != address(0));\n', '        assert(position.lender != address(0));\n', '        assert(position.maxDuration != 0);\n', '        assert(position.interestPeriod <= position.maxDuration);\n', '        assert(position.callTimestamp == 0);\n', '        assert(position.requiredDeposit == 0);\n', '\n', '        state.positions[positionId].owedToken = position.owedToken;\n', '        state.positions[positionId].heldToken = position.heldToken;\n', '        state.positions[positionId].principal = position.principal;\n', '        state.positions[positionId].callTimeLimit = position.callTimeLimit;\n', '        state.positions[positionId].startTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        state.positions[positionId].maxDuration = position.maxDuration;\n', '        state.positions[positionId].interestRate = position.interestRate;\n', '        state.positions[positionId].interestPeriod = position.interestPeriod;\n', '\n', '        state.positions[positionId].owner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            (position.owner != msg.sender) ? msg.sender : address(0),\n', '            position.owner\n', '        );\n', '\n', '        state.positions[positionId].lender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            (position.lender != loanPayer) ? loanPayer : address(0),\n', '            position.lender\n', '        );\n', '    }\n', '\n', '    function getPositionIdFromNonce(\n', '        uint256 nonce\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked(msg.sender, nonce));\n', '    }\n', '\n', '    function getUnavailableLoanOfferingAmountImpl(\n', '        MarginState.State storage state,\n', '        bytes32 loanHash\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash].add(state.loanCancels[loanHash]);\n', '    }\n', '\n', '    function cleanupPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '    {\n', '        delete state.positions[positionId];\n', '        state.closedPositions[positionId] = true;\n', '    }\n', '\n', '    function calculateOwedAmount(\n', '        Position storage position,\n', '        uint256 closeAmount,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsed(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            closeAmount,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Calculates time elapsed rounded up to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsed(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round up to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = MathHelpers.divisionRoundedUp(elapsed, period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function calculateLenderAmountForIncreasePosition(\n', '        Position storage position,\n', '        uint256 principalToAdd,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsedForNewLender(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            principalToAdd,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    function getLoanOfferingHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                loanOffering.owedToken,\n', '                loanOffering.heldToken,\n', '                loanOffering.payer,\n', '                loanOffering.owner,\n', '                loanOffering.taker,\n', '                loanOffering.positionOwner,\n', '                loanOffering.feeRecipient,\n', '                loanOffering.lenderFeeToken,\n', '                loanOffering.takerFeeToken,\n', '                getValuesHash(loanOffering)\n', '            )\n', '        );\n', '    }\n', '\n', '    function getPositionBalanceImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Vault(state.VAULT).balances(positionId, state.positions[positionId].heldToken);\n', '    }\n', '\n', '    function containsPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.positions[positionId].startTimestamp != 0;\n', '    }\n', '\n', '    function positionHasExisted(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return containsPositionImpl(state, positionId) || state.closedPositions[positionId];\n', '    }\n', '\n', '    function getPositionFromStorage(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (Position storage)\n', '    {\n', '        Position storage position = state.positions[positionId];\n', '\n', '        require(\n', '            position.startTimestamp != 0,\n', '            "MarginCommon#getPositionFromStorage: The position does not exist"\n', '        );\n', '\n', '        return position;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Calculates time elapsed rounded down to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsedForNewLender(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round down to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = elapsed.div(period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function getValuesHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                loanOffering.rates.maxAmount,\n', '                loanOffering.rates.minAmount,\n', '                loanOffering.rates.minHeldToken,\n', '                loanOffering.rates.lenderFee,\n', '                loanOffering.rates.takerFee,\n', '                loanOffering.expirationTimestamp,\n', '                loanOffering.salt,\n', '                loanOffering.callTimeLimit,\n', '                loanOffering.maxDuration,\n', '                loanOffering.rates.interestRate,\n', '                loanOffering.rates.interestPeriod\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/PayoutRecipient.sol\n', '\n', '/**\n', ' * @title PayoutRecipient\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to be the payoutRecipient in a\n', ' * closePosition transaction.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PayoutRecipient {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive payout from being the payoutRecipient\n', '     * in a closePosition transaction. May redistribute any payout as necessary. Throws on error.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  closeAmount        Amount of the position that was closed\n', '     * @param  closer             Address of the account or contract that closed the position\n', '     * @param  positionOwner      Address of the owner of the position\n', '     * @param  heldToken          Address of the ERC20 heldToken\n', '     * @param  payout             Number of tokens received from the payout\n', '     * @param  totalHeldToken     Total amount of heldToken removed from vault during close\n', '     * @param  payoutInHeldToken  True if payout is in heldToken, false if in owedToken\n', '     * @return                    True if approved by the receiver\n', '     */\n', '    function receiveClosePositionPayout(\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address closer,\n', '        address positionOwner,\n', '        address heldToken,\n', '        uint256 payout,\n', '        uint256 totalHeldToken,\n', '        bool    payoutInHeldToken\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CloseLoanDelegator.sol\n', '\n', '/**\n', ' * @title CloseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CloseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * closeWithoutCounterparty().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at most) the specified amount of the loan was\n', '     * successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of closeWithoutCounterparty()\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the loan to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeLoanOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/ClosePositionDelegator.sol\n', '\n', '/**\n', ' * @title ClosePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a position\n', ' * owned by the smart contract, allowing more complex logic to control positions.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ClosePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call closePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at-most) the specified amount of the position\n', '     * was successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of the closePosition() function\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the position to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionShared.sol\n', '\n', '/**\n', ' * @title ClosePositionShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between ClosePositionImpl and\n', ' * CloseWithoutCounterpartyImpl\n', ' */\n', 'library ClosePositionShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct CloseTx {\n', '        bytes32 positionId;\n', '        uint256 originalPrincipal;\n', '        uint256 closeAmount;\n', '        uint256 owedTokenOwed;\n', '        uint256 startingHeldTokenBalance;\n', '        uint256 availableHeldToken;\n', '        address payoutRecipient;\n', '        address owedToken;\n', '        address heldToken;\n', '        address positionOwner;\n', '        address positionLender;\n', '        address exchangeWrapper;\n', '        bool    payoutInHeldToken;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function closePositionStateUpdate(\n', '        MarginState.State storage state,\n', '        CloseTx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        // Delete the position, or just decrease the principal\n', '        if (transaction.closeAmount == transaction.originalPrincipal) {\n', '            MarginCommon.cleanupPosition(state, transaction.positionId);\n', '        } else {\n', '            assert(\n', '                transaction.originalPrincipal == state.positions[transaction.positionId].principal\n', '            );\n', '            state.positions[transaction.positionId].principal =\n', '                transaction.originalPrincipal.sub(transaction.closeAmount);\n', '        }\n', '    }\n', '\n', '    function sendTokensToPayoutRecipient(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 receivedOwedToken\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 payout;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            // Send remaining heldToken to payoutRecipient\n', '            payout = transaction.availableHeldToken.sub(buybackCostInHeldToken);\n', '\n', '            Vault(state.VAULT).transferFromVault(\n', '                transaction.positionId,\n', '                transaction.heldToken,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        } else {\n', '            assert(transaction.exchangeWrapper != address(0));\n', '\n', '            payout = receivedOwedToken.sub(transaction.owedTokenOwed);\n', '\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        }\n', '\n', '        if (AddressUtils.isContract(transaction.payoutRecipient)) {\n', '            require(\n', '                PayoutRecipient(transaction.payoutRecipient).receiveClosePositionPayout(\n', '                    transaction.positionId,\n', '                    transaction.closeAmount,\n', '                    msg.sender,\n', '                    transaction.positionOwner,\n', '                    transaction.heldToken,\n', '                    payout,\n', '                    transaction.availableHeldToken,\n', '                    transaction.payoutInHeldToken\n', '                ),\n', '                "ClosePositionShared#sendTokensToPayoutRecipient: Payout recipient does not consent"\n', '            );\n', '        }\n', '\n', '        // The ending heldToken balance of the vault should be the starting heldToken balance\n', '        // minus the available heldToken amount\n', '        assert(\n', '            MarginCommon.getPositionBalanceImpl(state, transaction.positionId)\n', '            == transaction.startingHeldTokenBalance.sub(transaction.availableHeldToken)\n', '        );\n', '\n', '        return payout;\n', '    }\n', '\n', '    function createCloseTx(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        internal\n', '        returns (CloseTx memory)\n', '    {\n', '        // Validate\n', '        require(\n', '            payoutRecipient != address(0),\n', '            "ClosePositionShared#createCloseTx: Payout recipient cannot be 0"\n', '        );\n', '        require(\n', '            requestedAmount > 0,\n', '            "ClosePositionShared#createCloseTx: Requested close amount cannot be 0"\n', '        );\n', '\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 closeAmount = getApprovedAmount(\n', '            position,\n', '            positionId,\n', '            requestedAmount,\n', '            payoutRecipient,\n', '            isWithoutCounterparty\n', '        );\n', '\n', '        return parseCloseTx(\n', '            state,\n', '            position,\n', '            positionId,\n', '            closeAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            isWithoutCounterparty\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function getApprovedAmount(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        bool requireLenderApproval\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // Ensure enough principal\n', '        uint256 allowedAmount = Math.min256(requestedAmount, position.principal);\n', '\n', '        // Ensure owner consent\n', '        allowedAmount = closePositionOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            payoutRecipient,\n', '            positionId,\n', '            allowedAmount\n', '        );\n', '\n', '        // Ensure lender consent\n', '        if (requireLenderApproval) {\n', '            allowedAmount = closeLoanOnBehalfOfRecurse(\n', '                position.lender,\n', '                msg.sender,\n', '                payoutRecipient,\n', '                positionId,\n', '                allowedAmount\n', '            );\n', '        }\n', '\n', '        assert(allowedAmount > 0);\n', '        assert(allowedAmount <= position.principal);\n', '        assert(allowedAmount <= requestedAmount);\n', '\n', '        return allowedAmount;\n', '    }\n', '\n', '    function closePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = ClosePositionDelegator(contractAddr).closeOnBehalfOf(\n', '            closer,\n', '            payoutRecipient,\n', '            positionId,\n', '            closeAmount\n', '        );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    function closeLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = CloseLoanDelegator(contractAddr).closeLoanOnBehalfOf(\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                closeAmount\n', '            );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closeLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseCloseTx(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        private\n', '        view\n', '        returns (CloseTx memory)\n', '    {\n', '        uint256 startingHeldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        uint256 availableHeldToken = MathHelpers.getPartialAmount(\n', '            closeAmount,\n', '            position.principal,\n', '            startingHeldTokenBalance\n', '        );\n', '        uint256 owedTokenOwed = 0;\n', '\n', '        if (!isWithoutCounterparty) {\n', '            owedTokenOwed = MarginCommon.calculateOwedAmount(\n', '                position,\n', '                closeAmount,\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        return CloseTx({\n', '            positionId: positionId,\n', '            originalPrincipal: position.principal,\n', '            closeAmount: closeAmount,\n', '            owedTokenOwed: owedTokenOwed,\n', '            startingHeldTokenBalance: startingHeldTokenBalance,\n', '            availableHeldToken: availableHeldToken,\n', '            payoutRecipient: payoutRecipient,\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            positionOwner: position.owner,\n', '            positionLender: position.lender,\n', '            exchangeWrapper: exchangeWrapper,\n', '            payoutInHeldToken: payoutInHeldToken\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n', ' * with other smart contracts through a common interface.\n', ' */\n', 'interface ExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the transaction\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionImpl.sol\n', '\n', '/**\n', ' * @title ClosePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closePosition function of Margin\n', ' */\n', 'library ClosePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool    payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bytes memory orderData\n', '    )\n', '        public\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            false\n', '        );\n', '\n', '        (\n', '            uint256 buybackCostInHeldToken,\n', '            uint256 receivedOwedToken\n', '        ) = returnOwedTokensToLender(\n', '            state,\n', '            transaction,\n', '            orderData\n', '        );\n', '\n', '        uint256 payout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            receivedOwedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnClose(\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            payout\n', '        );\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            payout,\n', '            transaction.owedTokenOwed\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function returnOwedTokensToLender(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 buybackCostInHeldToken = 0;\n', '        uint256 receivedOwedToken = 0;\n', '        uint256 lenderOwedToken = transaction.owedTokenOwed;\n', '\n', '        // Setting exchangeWrapper to 0x000... indicates owedToken should be taken directly\n', '        // from msg.sender\n', '        if (transaction.exchangeWrapper == address(0)) {\n', '            require(\n', '                transaction.payoutInHeldToken,\n', '                "ClosePositionImpl#returnOwedTokensToLender: Cannot payout in owedToken"\n', '            );\n', '\n', '            // No DEX Order; send owedTokens directly from the closer to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                msg.sender,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        } else {\n', '            // Buy back owedTokens using DEX Order and send to lender\n', '            (buybackCostInHeldToken, receivedOwedToken) = buyBackOwedToken(\n', '                state,\n', '                transaction,\n', '                orderData\n', '            );\n', '\n', '            // If no owedToken needed for payout: give lender all owedToken, even if more than owed\n', '            if (transaction.payoutInHeldToken) {\n', '                assert(receivedOwedToken >= lenderOwedToken);\n', '                lenderOwedToken = receivedOwedToken;\n', '            }\n', '\n', '            // Transfer owedToken from the exchange wrapper to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        }\n', '\n', '        state.totalOwedTokenRepaidToLender[transaction.positionId] =\n', '            state.totalOwedTokenRepaidToLender[transaction.positionId].add(lenderOwedToken);\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function buyBackOwedToken(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        // Ask the exchange wrapper the cost in heldToken to buy back the close\n', '        // amount of owedToken\n', '        uint256 buybackCostInHeldToken;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            buybackCostInHeldToken = ExchangeWrapper(transaction.exchangeWrapper)\n', '                .getExchangeCost(\n', '                    transaction.owedToken,\n', '                    transaction.heldToken,\n', '                    transaction.owedTokenOwed,\n', '                    orderData\n', '                );\n', '\n', '            // Require enough available heldToken to pay for the buyback\n', '            require(\n', '                buybackCostInHeldToken <= transaction.availableHeldToken,\n', '                "ClosePositionImpl#buyBackOwedToken: Not enough available heldToken"\n', '            );\n', '        } else {\n', '            buybackCostInHeldToken = transaction.availableHeldToken;\n', '        }\n', '\n', '        // Send the requisite heldToken to do the buyback from vault to exchange wrapper\n', '        Vault(state.VAULT).transferFromVault(\n', '            transaction.positionId,\n', '            transaction.heldToken,\n', '            transaction.exchangeWrapper,\n', '            buybackCostInHeldToken\n', '        );\n', '\n', '        // Trade the heldToken for the owedToken\n', '        uint256 receivedOwedToken = ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '            msg.sender,\n', '            state.TOKEN_PROXY,\n', '            transaction.owedToken,\n', '            transaction.heldToken,\n', '            buybackCostInHeldToken,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            receivedOwedToken >= transaction.owedTokenOwed,\n', '            "ClosePositionImpl#buyBackOwedToken: Did not receive enough owedToken"\n', '        );\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function logEventOnClose(\n', '        ClosePositionShared.CloseTx transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 payout\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            transaction.owedTokenOwed,\n', '            payout,\n', '            buybackCostInHeldToken,\n', '            transaction.payoutInHeldToken\n', '        );\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/CloseWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title CloseWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closeWithoutCounterpartyImpl function of\n', ' * Margin\n', ' */\n', 'library CloseWithoutCounterpartyImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closeWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        public\n', '        returns (uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            true\n', '        );\n', '\n', '        uint256 heldTokenPayout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            0, // No buyback cost\n', '            0  // Did not receive any owedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnCloseWithoutCounterparty(transaction);\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            heldTokenPayout\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function logEventOnCloseWithoutCounterparty(\n', '        ClosePositionShared.CloseTx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            0,\n', '            transaction.availableHeldToken,\n', '            0,\n', '            true\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/DepositCollateralDelegator.sol\n', '\n', '/**\n', ' * @title DepositCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses deposit heldTokens\n', ' * into a position owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface DepositCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call depositCollateral().\n', '     *\n', '     * @param  depositor   Address of the caller of the depositCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  amount      Requested deposit amount\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function depositCollateralOnBehalfOf(\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/DepositCollateralImpl.sol\n', '\n', '/**\n', ' * @title DepositCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the deposit function of Margin\n', ' */\n', 'library DepositCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function depositCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            depositAmount > 0,\n', '            "DepositCollateralImpl#depositCollateralImpl: Deposit amount cannot be 0"\n', '        );\n', '\n', '        // Ensure owner consent\n', '        depositCollateralOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            depositAmount\n', '        );\n', '\n', '        // cancel margin call if applicable\n', '        bool marginCallCanceled = false;\n', '        uint256 requiredDeposit = position.requiredDeposit;\n', '        if (position.callTimestamp > 0 && requiredDeposit > 0) {\n', '            if (depositAmount >= requiredDeposit) {\n', '                position.requiredDeposit = 0;\n', '                position.callTimestamp = 0;\n', '                marginCallCanceled = true;\n', '            } else {\n', '                position.requiredDeposit = position.requiredDeposit.sub(depositAmount);\n', '            }\n', '        }\n', '\n', '        emit AdditionalCollateralDeposited(\n', '            positionId,\n', '            depositAmount,\n', '            msg.sender\n', '        );\n', '\n', '        if (marginCallCanceled) {\n', '            emit MarginCallCanceled(\n', '                positionId,\n', '                position.lender,\n', '                msg.sender,\n', '                depositAmount\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function depositCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (depositor == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            DepositCollateralDelegator(contractAddr).depositCollateralOnBehalfOf(\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '\n', '        // if not equal, recurse\n', '        if (newContractAddr != contractAddr) {\n', '            depositCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/ForceRecoverCollateralDelegator.sol\n', '\n', '/**\n', ' * @title ForceRecoverCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses\n', ' * forceRecoverCollateral() a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ForceRecoverCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * forceRecoverCollateral().\n', '     *\n', '     * NOTE: If not returning zero address (or not reverting), this contract must assume that Margin\n', '     * will either revert the entire transaction or that the collateral was forcibly recovered.\n', '     *\n', '     * @param  recoverer   Address of the caller of the forceRecoverCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function forceRecoverCollateralOnBehalfOf(\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/ForceRecoverCollateralImpl.sol\n', '\n', '/* solium-disable-next-line max-len*/\n', '\n', '/**\n', ' * @title ForceRecoverCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the forceRecoverCollateral function of Margin\n', ' */\n', 'library ForceRecoverCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function forceRecoverCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Can only force recover after either:\n', '        // 1) The loan was called and the call period has elapsed\n', '        // 2) The maxDuration of the position has elapsed\n', '        require( /* solium-disable-next-line */\n', '            (\n', '                position.callTimestamp > 0\n', '                && block.timestamp >= uint256(position.callTimestamp).add(position.callTimeLimit)\n', '            ) || (\n', '                block.timestamp >= uint256(position.startTimestamp).add(position.maxDuration)\n', '            ),\n', '            "ForceRecoverCollateralImpl#forceRecoverCollateralImpl: Cannot recover yet"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        forceRecoverCollateralOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            recipient\n', '        );\n', '\n', '        // Send the tokens\n', '        uint256 heldTokenRecovered = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '        Vault(state.VAULT).transferFromVault(\n', '            positionId,\n', '            position.heldToken,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        // Delete the position\n', '        // NOTE: Since position is a storage pointer, this will also set all fields on\n', '        //       the position variable to 0\n', '        MarginCommon.cleanupPosition(\n', '            state,\n', '            positionId\n', '        );\n', '\n', '        // Log an event\n', '        emit CollateralForceRecovered(\n', '            positionId,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        return heldTokenRecovered;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function forceRecoverCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (recoverer == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            ForceRecoverCollateralDelegator(contractAddr).forceRecoverCollateralOnBehalfOf(\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            forceRecoverCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TypedSignature.sol\n', '\n', '/**\n', ' * @title TypedSignature\n', ' * @author dYdX\n', ' *\n', ' * Allows for ecrecovery of signed hashes with three different prepended messages:\n', ' * 1) ""\n', ' * 2) "\\x19Ethereum Signed Message:\\n32"\n', ' * 3) "\\x19Ethereum Signed Message:\\n\\x20"\n', ' */\n', 'library TypedSignature {\n', '\n', '    // Solidity does not offer guarantees about enum values, so we define them explicitly\n', '    uint8 private constant SIGTYPE_INVALID = 0;\n', '    uint8 private constant SIGTYPE_ECRECOVER_DEC = 1;\n', '    uint8 private constant SIGTYPE_ECRECOVER_HEX = 2;\n', '    uint8 private constant SIGTYPE_UNSUPPORTED = 3;\n', '\n', '    // prepended message with the length of the signed hash in hexadecimal\n', '    bytes constant private PREPEND_HEX = "\\x19Ethereum Signed Message:\\n\\x20";\n', '\n', '    // prepended message with the length of the signed hash in decimal\n', '    bytes constant private PREPEND_DEC = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    /**\n', '     * Gives the address of the signer of a hash. Allows for three common prepended strings.\n', '     *\n', '     * @param  hash               Hash that was signed (does not include prepended message)\n', '     * @param  signatureWithType  Type and ECDSA signature with structure: {1:type}{1:v}{32:r}{32:s}\n', '     * @return                    address of the signer of the hash\n', '     */\n', '    function recover(\n', '        bytes32 hash,\n', '        bytes signatureWithType\n', '    )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(\n', '            signatureWithType.length == 66,\n', '            "SignatureValidator#validateSignature: invalid signature length"\n', '        );\n', '\n', '        uint8 sigType = uint8(signatureWithType[0]);\n', '\n', '        require(\n', '            sigType > uint8(SIGTYPE_INVALID),\n', '            "SignatureValidator#validateSignature: invalid signature type"\n', '        );\n', '        require(\n', '            sigType < uint8(SIGTYPE_UNSUPPORTED),\n', '            "SignatureValidator#validateSignature: unsupported signature type"\n', '        );\n', '\n', '        uint8 v = uint8(signatureWithType[1]);\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            r := mload(add(signatureWithType, 34))\n', '            s := mload(add(signatureWithType, 66))\n', '        }\n', '\n', '        bytes32 signedHash;\n', '        if (sigType == SIGTYPE_ECRECOVER_DEC) {\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\n', '        } else {\n', '            assert(sigType == SIGTYPE_ECRECOVER_HEX);\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\n', '        }\n', '\n', '        return ecrecover(\n', '            signedHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/LoanOfferingVerifier.sol\n', '\n', '/**\n', ' * @title LoanOfferingVerifier\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement to be able to make off-chain generated\n', ' * loan offerings.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOfferingVerifier {\n', '\n', '    /**\n', '     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n', '     * will be generated off-chain. The "loan owner" address will own the loan-side of the resulting\n', '     * position.\n', '     *\n', '     * If true is returned, and no errors are thrown by the Margin contract, the loan will have\n', '     * occurred. This means that verifyLoanOffering can also be used to update internal contract\n', '     * state on a loan.\n', '     *\n', '     * @param  addresses    Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan positionOwner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  positionId   Unique ID of the position\n', '     * @param  signature    Arbitrary bytes; may or may not be an ECDSA signature\n', '     * @return              This address to accept, a different address to ask that contract\n', '     */\n', '    function verifyLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/BorrowShared.sol\n', '\n', '/**\n', ' * @title BorrowShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between OpenPositionImpl and IncreasePositionImpl.\n', ' * Both use a Loan Offering and a DEX Order to open or increase a position.\n', ' */\n', 'library BorrowShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 lenderAmount;\n', '        MarginCommon.LoanOffering loanOffering;\n', '        address exchangeWrapper;\n', '        bool depositInHeldToken;\n', '        uint256 depositAmount;\n', '        uint256 collateralAmount;\n', '        uint256 heldTokenFromSell;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Validate the transaction before exchanging heldToken for owedToken\n', '     */\n', '    function validateTxPreSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        assert(transaction.lenderAmount >= transaction.principal);\n', '\n', '        require(\n', '            transaction.principal > 0,\n', '            "BorrowShared#validateTxPreSell: Positions with 0 principal are not allowed"\n', '        );\n', '\n', '        // If the taker is 0x0 then any address can take it. Otherwise only the taker can use it.\n', '        if (transaction.loanOffering.taker != address(0)) {\n', '            require(\n', '                msg.sender == transaction.loanOffering.taker,\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering taker"\n', '            );\n', '        }\n', '\n', '        // If the positionOwner is 0x0 then any address can be set as the position owner.\n', '        // Otherwise only the specified positionOwner can be set as the position owner.\n', '        if (transaction.loanOffering.positionOwner != address(0)) {\n', '            require(\n', '                transaction.owner == transaction.loanOffering.positionOwner,\n', '                "BorrowShared#validateTxPreSell: Invalid position owner"\n', '            );\n', '        }\n', '\n', '        // Require the loan offering to be approved by the payer\n', '        if (AddressUtils.isContract(transaction.loanOffering.payer)) {\n', '            getConsentFromSmartContractLender(transaction);\n', '        } else {\n', '            require(\n', '                transaction.loanOffering.payer == TypedSignature.recover(\n', '                    transaction.loanOffering.loanHash,\n', '                    transaction.loanOffering.signature\n', '                ),\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering signature"\n', '            );\n', '        }\n', '\n', '        // Validate the amount is <= than max and >= min\n', '        uint256 unavailable = MarginCommon.getUnavailableLoanOfferingAmountImpl(\n', '            state,\n', '            transaction.loanOffering.loanHash\n', '        );\n', '        require(\n', '            transaction.lenderAmount.add(unavailable) <= transaction.loanOffering.rates.maxAmount,\n', '            "BorrowShared#validateTxPreSell: Loan offering does not have enough available"\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount >= transaction.loanOffering.rates.minAmount,\n', '            "BorrowShared#validateTxPreSell: Lender amount is below loan offering minimum amount"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owedToken != transaction.loanOffering.heldToken,\n', '            "BorrowShared#validateTxPreSell: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            transaction.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Position owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Loan owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.expirationTimestamp > block.timestamp,\n', '            "BorrowShared#validateTxPreSell: Loan offering is expired"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.maxDuration > 0,\n', '            "BorrowShared#validateTxPreSell: Loan offering has 0 maximum duration"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.rates.interestPeriod <= transaction.loanOffering.maxDuration,\n', '            "BorrowShared#validateTxPreSell: Loan offering interestPeriod > maxDuration"\n', '        );\n', '\n', '        // The minimum heldToken is validated after executing the sell\n', '        // Position and loan ownership is validated in TransferInternal\n', '    }\n', '\n', '    /**\n', '     * Validate the transaction after exchanging heldToken for owedToken, pay out fees, and store\n', '     * how much of the loan was used.\n', '     */\n', '    function doPostSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        validateTxPostSell(transaction);\n', '\n', '        // Transfer feeTokens from trader and lender\n', '        transferLoanFees(state, transaction);\n', '\n', '        // Update global amounts for the loan\n', '        state.loanFills[transaction.loanOffering.loanHash] =\n', '            state.loanFills[transaction.loanOffering.loanHash].add(transaction.lenderAmount);\n', '    }\n', '\n', '    /**\n', '     * Sells the owedToken from the lender (and from the deposit if in owedToken) using the\n', '     * exchangeWrapper, then puts the resulting heldToken into the vault. Only trades for\n', '     * maxHeldTokenToBuy of heldTokens at most.\n', '     */\n', '    function doSell(\n', '        MarginState.State storage state,\n', '        Tx transaction,\n', '        bytes orderData,\n', '        uint256 maxHeldTokenToBuy\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Move owedTokens from lender to exchange wrapper\n', '        pullOwedTokensFromLender(state, transaction);\n', '\n', "        // Sell just the lender's owedToken (if trader deposit is in heldToken)\n", "        // Otherwise sell both the lender's owedToken and the trader's deposit in owedToken\n", '        uint256 sellAmount = transaction.depositInHeldToken ?\n', '            transaction.lenderAmount :\n', '            transaction.lenderAmount.add(transaction.depositAmount);\n', '\n', '        // Do the trade, taking only the maxHeldTokenToBuy if more is returned\n', '        uint256 heldTokenFromSell = Math.min256(\n', '            maxHeldTokenToBuy,\n', '            ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '                msg.sender,\n', '                state.TOKEN_PROXY,\n', '                transaction.loanOffering.heldToken,\n', '                transaction.loanOffering.owedToken,\n', '                sellAmount,\n', '                orderData\n', '            )\n', '        );\n', '\n', '        // Move the tokens to the vault\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.exchangeWrapper,\n', '            heldTokenFromSell\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(heldTokenFromSell);\n', '\n', '        return heldTokenFromSell;\n', '    }\n', '\n', '    /**\n', '     * Take the owedToken deposit from the trader and give it to the exchange wrapper so that it can\n', '     * be sold for heldToken.\n', '     */\n', '    function doDepositOwedToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            msg.sender,\n', '            transaction.exchangeWrapper,\n', '            transaction.depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Take the heldToken deposit from the trader and move it to the vault.\n', '     */\n', '    function doDepositHeldToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            msg.sender,\n', '            transaction.depositAmount\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(transaction.depositAmount);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function validateTxPostSell(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        uint256 expectedCollateral = transaction.depositInHeldToken ?\n', '            transaction.heldTokenFromSell.add(transaction.depositAmount) :\n', '            transaction.heldTokenFromSell;\n', '        assert(transaction.collateralAmount == expectedCollateral);\n', '\n', '        uint256 loanOfferingMinimumHeldToken = MathHelpers.getPartialAmountRoundedUp(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minHeldToken\n', '        );\n', '        require(\n', '            transaction.collateralAmount >= loanOfferingMinimumHeldToken,\n', '            "BorrowShared#validateTxPostSell: Loan offering minimum held token not met"\n', '        );\n', '    }\n', '\n', '    function getConsentFromSmartContractLender(\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        verifyLoanOfferingRecurse(\n', '            transaction.loanOffering.payer,\n', '            getLoanOfferingAddresses(transaction),\n', '            getLoanOfferingValues256(transaction),\n', '            getLoanOfferingValues32(transaction),\n', '            transaction.positionId,\n', '            transaction.loanOffering.signature\n', '        );\n', '    }\n', '\n', '    function verifyLoanOfferingRecurse(\n', '        address contractAddr,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        private\n', '    {\n', '        address newContractAddr = LoanOfferingVerifier(contractAddr).verifyLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            positionId,\n', '            signature\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            verifyLoanOfferingRecurse(\n', '                newContractAddr,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                positionId,\n', '                signature\n', '            );\n', '        }\n', '    }\n', '\n', '    function pullOwedTokensFromLender(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // Transfer owedToken to the exchange wrapper\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.exchangeWrapper,\n', '            transaction.lenderAmount\n', '        );\n', '    }\n', '\n', '    function transferLoanFees(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // 0 fee address indicates no fees\n', '        if (transaction.loanOffering.feeRecipient == address(0)) {\n', '            return;\n', '        }\n', '\n', '        TokenProxy proxy = TokenProxy(state.TOKEN_PROXY);\n', '\n', '        uint256 lenderFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.lenderFee\n', '        );\n', '        uint256 takerFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.takerFee\n', '        );\n', '\n', '        if (lenderFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.lenderFeeToken,\n', '                transaction.loanOffering.payer,\n', '                transaction.loanOffering.feeRecipient,\n', '                lenderFee\n', '            );\n', '        }\n', '\n', '        if (takerFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.takerFeeToken,\n', '                msg.sender,\n', '                transaction.loanOffering.feeRecipient,\n', '                takerFee\n', '            );\n', '        }\n', '    }\n', '\n', '    function getLoanOfferingAddresses(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (address[9])\n', '    {\n', '        return [\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.owner,\n', '            transaction.loanOffering.taker,\n', '            transaction.loanOffering.positionOwner,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.loanOffering.lenderFeeToken,\n', '            transaction.loanOffering.takerFeeToken\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues256(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256[7])\n', '    {\n', '        return [\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minAmount,\n', '            transaction.loanOffering.rates.minHeldToken,\n', '            transaction.loanOffering.rates.lenderFee,\n', '            transaction.loanOffering.rates.takerFee,\n', '            transaction.loanOffering.expirationTimestamp,\n', '            transaction.loanOffering.salt\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues32(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint32[4])\n', '    {\n', '        return [\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.rates.interestPeriod\n', '        ];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/IncreaseLoanDelegator.sol\n', '\n', '/**\n', ' * @title IncreaseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreaseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned loan. Margin will call this on the owner of a loan during increasePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan size was successfully increased.\n', '     *\n', '     * @param  payer           Lender adding additional funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Principal amount to be added to the position\n', '     * @param  lentAmount      Amount of owedToken lent by the lender (principal plus interest, or\n', '     *                         zero if increaseWithoutCounterparty() is used).\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increaseLoanOnBehalfOf(\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/IncreasePositionDelegator.sol\n', '\n', '/**\n', ' * @title IncreasePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreasePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned position. Margin will call this on the owner of a position during increasePosition()\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the position size was successfully increased.\n', '     *\n', '     * @param  trader          Address initiating the addition of funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount of principal to be added to the position\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increasePositionOnBehalfOf(\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/IncreasePositionImpl.sol\n', '\n', '/**\n', ' * @title IncreasePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the increasePosition function of Margin\n', ' */\n', 'library IncreasePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function increasePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        // Also ensures that the position exists\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        BorrowShared.Tx memory transaction = parseIncreasePositionTx(\n', '            position,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        validateIncrease(state, transaction, position);\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        updateState(\n', '            position,\n', '            transaction.positionId,\n', '            transaction.principal,\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.payer\n', '        );\n', '\n', '        // LOG EVENT\n', '        recordPositionIncreased(transaction, position);\n', '\n', '        return transaction.lenderAmount;\n', '    }\n', '\n', '    function increaseWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Disallow adding 0 principal\n', '        require(\n', '            principalToAdd > 0,\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot add 0 principal"\n', '        );\n', '\n', '        // Disallow additions after maximum duration\n', '        require(\n', '            block.timestamp < uint256(position.startTimestamp).add(position.maxDuration),\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot increase after maxDuration"\n', '        );\n', '\n', '        uint256 heldTokenAmount = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            position,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            heldTokenAmount\n', '        );\n', '\n', '        updateState(\n', '            position,\n', '            positionId,\n', '            principalToAdd,\n', '            0, // lent amount\n', '            msg.sender\n', '        );\n', '\n', '        emit PositionIncreased(\n', '            positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            position.owner,\n', '            position.lender,\n', '            "",\n', '            address(0),\n', '            0,\n', '            principalToAdd,\n', '            0,\n', '            heldTokenAmount,\n', '            true\n', '        );\n', '\n', '        return heldTokenAmount;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        // Calculate the number of heldTokens to add\n', '        uint256 collateralToAdd = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            state.positions[transaction.positionId],\n', '            transaction.positionId,\n', '            transaction.principal\n', '        );\n', '\n', '        // Do pre-exchange validations\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        // Calculate and deposit owedToken\n', '        uint256 maxHeldTokenFromSell = MathHelpers.maxUint256();\n', '        if (!transaction.depositInHeldToken) {\n', '            transaction.depositAmount =\n', '                getOwedTokenDeposit(transaction, collateralToAdd, orderData);\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '            maxHeldTokenFromSell = collateralToAdd;\n', '        }\n', '\n', '        // Sell owedToken for heldToken using the exchange wrapper\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            maxHeldTokenFromSell\n', '        );\n', '\n', '        // Calculate and deposit heldToken\n', '        if (transaction.depositInHeldToken) {\n', '            require(\n', '                transaction.heldTokenFromSell <= collateralToAdd,\n', '                "IncreasePositionImpl#doBorrowAndSell: DEX order gives too much heldToken"\n', '            );\n', '            transaction.depositAmount = collateralToAdd.sub(transaction.heldTokenFromSell);\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        }\n', '\n', '        // Make sure the actual added collateral is what is expected\n', '        assert(transaction.collateralAmount == collateralToAdd);\n', '\n', '        // Do post-exchange validations\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function getOwedTokenDeposit(\n', '        BorrowShared.Tx transaction,\n', '        uint256 collateralToAdd,\n', '        bytes orderData\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalOwedToken = ExchangeWrapper(transaction.exchangeWrapper).getExchangeCost(\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.owedToken,\n', '            collateralToAdd,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount <= totalOwedToken,\n', '            "IncreasePositionImpl#getOwedTokenDeposit: Lender amount is more than required"\n', '        );\n', '\n', '        return totalOwedToken.sub(transaction.lenderAmount);\n', '    }\n', '\n', '    function validateIncrease(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '        view\n', '    {\n', '        assert(MarginCommon.containsPositionImpl(state, transaction.positionId));\n', '\n', '        require(\n', '            position.callTimeLimit <= transaction.loanOffering.callTimeLimit,\n', '            "IncreasePositionImpl#validateIncrease: Loan callTimeLimit is less than the position"\n', '        );\n', '\n', "        // require the position to end no later than the loanOffering's maximum acceptable end time\n", '        uint256 positionEndTimestamp = uint256(position.startTimestamp).add(position.maxDuration);\n', '        uint256 offeringEndTimestamp = block.timestamp.add(transaction.loanOffering.maxDuration);\n', '        require(\n', '            positionEndTimestamp <= offeringEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Loan end timestamp is less than the position"\n', '        );\n', '\n', '        require(\n', '            block.timestamp < positionEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Position has passed its maximum duration"\n', '        );\n', '    }\n', '\n', '    function getCollateralNeededForAddedPrincipal(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 heldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        return MathHelpers.getPartialAmountRoundedUp(\n', '            principalToAdd,\n', '            position.principal,\n', '            heldTokenBalance\n', '        );\n', '    }\n', '\n', '    function updateState(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 owedTokenLent,\n', '        address loanPayer\n', '    )\n', '        private\n', '    {\n', '        position.principal = position.principal.add(principalAdded);\n', '\n', '        address owner = position.owner;\n', '        address lender = position.lender;\n', '\n', '        // Ensure owner consent\n', '        increasePositionOnBehalfOfRecurse(\n', '            owner,\n', '            msg.sender,\n', '            positionId,\n', '            principalAdded\n', '        );\n', '\n', '        // Ensure lender consent\n', '        increaseLoanOnBehalfOfRecurse(\n', '            lender,\n', '            loanPayer,\n', '            positionId,\n', '            principalAdded,\n', '            owedTokenLent\n', '        );\n', '    }\n', '\n', '    function increasePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        private\n', '    {\n', '        // Assume owner approval if not a smart contract and they increased their own position\n', '        if (trader == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreasePositionDelegator(contractAddr).increasePositionOnBehalfOf(\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increasePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '        }\n', '    }\n', '\n', '    function increaseLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 amountLent\n', '    )\n', '        private\n', '    {\n', '        // Assume lender approval if not a smart contract and they increased their own loan\n', '        if (payer == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreaseLoanDelegator(contractAddr).increaseLoanOnBehalfOf(\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increaseLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '        }\n', '    }\n', '\n', '    function recordPositionIncreased(\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '    {\n', '        emit PositionIncreased(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            position.owner,\n', '            position.lender,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.lenderAmount,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        uint256 principal = values256[7];\n', '\n', '        uint256 lenderAmount = MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principal,\n', '            block.timestamp\n', '        );\n', '        assert(lenderAmount >= principal);\n', '\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: positionId,\n', '            owner: position.owner,\n', '            principal: principal,\n', '            lenderAmount: lenderAmount,\n', '            loanOffering: parseLoanOfferingFromIncreasePositionTx(\n', '                position,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[6],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: 0, // set later\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOfferingFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            payer: addresses[0],\n', '            owner: position.lender,\n', '            taker: addresses[1],\n', '            positionOwner: addresses[2],\n', '            feeRecipient: addresses[3],\n', '            lenderFeeToken: addresses[4],\n', '            takerFeeToken: addresses[5],\n', '            rates: parseLoanOfferingRatesFromIncreasePositionTx(position, values256),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferingRatesFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        uint256[8] values256\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: position.interestRate,\n', '            interestPeriod: position.interestPeriod\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginStorage.sol\n', '\n', '/**\n', ' * @title MarginStorage\n', ' * @author dYdX\n', ' *\n', ' * This contract serves as the storage for the entire state of MarginStorage\n', ' */\n', 'contract MarginStorage {\n', '\n', '    MarginState.State state;\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/LoanGetters.sol\n', '\n', '/**\n', ' * @title LoanGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any loan\n', ' * offering stored in the dYdX protocol.\n', ' */\n', 'contract LoanGetters is MarginStorage {\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the principal amount of a loan offering that is no longer available.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total unavailable amount of the loan offering, which is equal to the\n', '     *                   filled amount plus the canceled amount.\n', '     */\n', '    function getLoanUnavailableAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanHash);\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owed token lent for a loan.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total filled amount of the loan offering.\n', '     */\n', '    function getLoanFilledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of a loan offering that has been canceled.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total canceled amount of the loan offering.\n', '     */\n', '    function getLoanCanceledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanCancels[loanHash];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CancelMarginCallDelegator.sol\n', '\n', '/**\n', ' * @title CancelMarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses cancel a\n', ' * margin-call for a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CancelMarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the margin-call was successfully canceled.\n', '     *\n', '     * @param  canceler    Address of the caller of the cancelMarginCall function\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function cancelMarginCallOnBehalfOf(\n', '        address canceler,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/MarginCallDelegator.sol\n', '\n', '/**\n', ' * @title MarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses margin-call a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface MarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call marginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan was successfully margin-called.\n', '     *\n', '     * @param  caller         Address of the caller of the marginCall function\n', '     * @param  positionId     Unique ID of the position\n', '     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n', '     * @return                This address to accept, a different address to ask that contract\n', '     */\n', '    function marginCallOnBehalfOf(\n', '        address caller,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/LoanImpl.sol\n', '\n', '/**\n', ' * @title LoanImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the following functions of Margin:\n', ' *\n', ' *      - marginCall\n', ' *      - cancelMarginCallImpl\n', ' *      - cancelLoanOffering\n', ' */\n', 'library LoanImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function marginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp == 0,\n', '            "LoanImpl#marginCallImpl: The position has already been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        marginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '\n', '        position.callTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        position.requiredDeposit = requiredDeposit;\n', '\n', '        emit MarginCallInitiated(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    function cancelMarginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp > 0,\n', '            "LoanImpl#cancelMarginCallImpl: Position has not been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        cancelMarginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId\n', '        );\n', '\n', '        state.positions[positionId].callTimestamp = 0;\n', '        state.positions[positionId].requiredDeposit = 0;\n', '\n', '        emit MarginCallCanceled(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            0\n', '        );\n', '    }\n', '\n', '    function cancelLoanOfferingImpl(\n', '        MarginState.State storage state,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32,\n', '        uint256    cancelAmount\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        require(\n', '            msg.sender == loanOffering.payer,\n', '            "LoanImpl#cancelLoanOfferingImpl: Only loan offering payer can cancel"\n', '        );\n', '        require(\n', '            loanOffering.expirationTimestamp > block.timestamp,\n', '            "LoanImpl#cancelLoanOfferingImpl: Loan offering has already expired"\n', '        );\n', '\n', '        uint256 remainingAmount = loanOffering.rates.maxAmount.sub(\n', '            MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanOffering.loanHash)\n', '        );\n', '        uint256 amountToCancel = Math.min256(remainingAmount, cancelAmount);\n', '\n', '        // If the loan was already fully canceled, then just return 0 amount was canceled\n', '        if (amountToCancel == 0) {\n', '            return 0;\n', '        }\n', '\n', '        state.loanCancels[loanOffering.loanHash] =\n', '            state.loanCancels[loanOffering.loanHash].add(amountToCancel);\n', '\n', '        emit LoanOfferingCanceled(\n', '            loanOffering.loanHash,\n', '            loanOffering.payer,\n', '            loanOffering.feeRecipient,\n', '            amountToCancel\n', '        );\n', '\n', '        return amountToCancel;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function marginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            MarginCallDelegator(contractAddr).marginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            marginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '        }\n', '    }\n', '\n', '    function cancelMarginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            CancelMarginCallDelegator(contractAddr).cancelMarginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            cancelMarginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            payer: addresses[2],\n', '            owner: addresses[3],\n', '            taker: addresses[4],\n', '            positionOwner: addresses[5],\n', '            feeRecipient: addresses[6],\n', '            lenderFeeToken: addresses[7],\n', '            takerFeeToken: addresses[8],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: new bytes(0)\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[7] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            interestRate: values32[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginAdmin.sol\n', '\n', '/**\n', ' * @title MarginAdmin\n', ' * @author dYdX\n', ' *\n', ' * Contains admin functions for the Margin contract\n', ' * The owner can put Margin into various close-only modes, which will disallow new position creation\n', ' */\n', 'contract MarginAdmin is Ownable {\n', '    // ============ Enums ============\n', '\n', '    // All functionality enabled\n', '    uint8 private constant OPERATION_STATE_OPERATIONAL = 0;\n', '\n', '    // Only closing functions + cancelLoanOffering allowed (marginCall, closePosition,\n', '    // cancelLoanOffering, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY = 1;\n', '\n', '    // Only closing functions allowed (marginCall, closePosition, closePositionDirectly,\n', '    // forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_ONLY = 2;\n', '\n', '    // Only closing functions allowed (marginCall, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_DIRECTLY_ONLY = 3;\n', '\n', '    // This operation state (and any higher) is invalid\n', '    uint8 private constant OPERATION_STATE_INVALID = 4;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Event indicating the operation state has changed\n', '     */\n', '    event OperationStateChanged(\n', '        uint8 from,\n', '        uint8 to\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    uint8 public operationState;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor()\n', '        public\n', '        Ownable()\n', '    {\n', '        operationState = OPERATION_STATE_OPERATIONAL;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyWhileOperational() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL,\n', '            "MarginAdmin#onlyWhileOperational: Can only call while operational"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier cancelLoanOfferingStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY,\n', '            "MarginAdmin#cancelLoanOfferingStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY\n', '            || operationState == OPERATION_STATE_CLOSE_ONLY,\n', '            "MarginAdmin#closePositionStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionDirectlyStateControl() {\n', '        _;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function setOperationState(\n', '        uint8 newState\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newState < OPERATION_STATE_INVALID,\n', '            "MarginAdmin#setOperationState: newState is not a valid operation state"\n', '        );\n', '\n', '        if (newState != operationState) {\n', '            emit OperationStateChanged(\n', '                operationState,\n', '                newState\n', '            );\n', '            operationState = newState;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginEvents.sol\n', '\n', '/**\n', ' * @title MarginEvents\n', ' * @author dYdX\n', ' *\n', ' * Contains events for the Margin contract.\n', ' *\n', ' * NOTE: Any Margin function libraries that use events will need to both define the event here\n', " *       and copy the event into the library itself as libraries don't support sharing events\n", ' */\n', 'contract MarginEvents {\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a position was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '}\n', '\n', '// File: contracts/margin/impl/OpenPositionImpl.sol\n', '\n', '/**\n', ' * @title OpenPositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openPosition function of Margin\n', ' */\n', 'library OpenPositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openPositionImpl(\n', '        MarginState.State storage state,\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        BorrowShared.Tx memory transaction = parseOpenTx(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, transaction.positionId),\n', '            "OpenPositionImpl#openPositionImpl: positionId already exists"\n', '        );\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        // Before doStoreNewPosition() so that PositionOpened event is before Transferred events\n', '        recordPositionOpened(\n', '            transaction\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            transaction\n', '        );\n', '\n', '        return transaction.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        if (transaction.depositInHeldToken) {\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        } else {\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '        }\n', '\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            MathHelpers.maxUint256()\n', '        );\n', '\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            transaction.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: transaction.loanOffering.owedToken,\n', '                heldToken: transaction.loanOffering.heldToken,\n', '                lender: transaction.loanOffering.owner,\n', '                owner: transaction.owner,\n', '                principal: transaction.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: transaction.loanOffering.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: transaction.loanOffering.maxDuration,\n', '                interestRate: transaction.loanOffering.rates.interestRate,\n', '                interestPeriod: transaction.loanOffering.rates.interestPeriod\n', '            }),\n', '            transaction.loanOffering.payer\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        BorrowShared.Tx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseOpenTx(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[9]),\n', '            owner: addresses[0],\n', '            principal: values256[7],\n', '            lenderAmount: values256[7],\n', '            loanOffering: parseLoanOffering(\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[10],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: values256[8],\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOffering(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bytes       signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            payer: addresses[3],\n', '            owner: addresses[4],\n', '            taker: addresses[5],\n', '            positionOwner: addresses[6],\n', '            feeRecipient: addresses[7],\n', '            lenderFeeToken: addresses[8],\n', '            takerFeeToken: addresses[9],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[10] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/OpenWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title OpenWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openWithoutCounterparty\n', ' * function of Margin\n', ' */\n', 'library OpenWithoutCounterpartyImpl {\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address positionOwner;\n', '        address owedToken;\n', '        address heldToken;\n', '        address loanOwner;\n', '        uint256 principal;\n', '        uint256 deposit;\n', '        uint32 callTimeLimit;\n', '        uint32 maxDuration;\n', '        uint32 interestRate;\n', '        uint32 interestPeriod;\n', '    }\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        Tx memory openTx = parseTx(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        validate(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            openTx.positionId,\n', '            openTx.heldToken,\n', '            msg.sender,\n', '            openTx.deposit\n', '        );\n', '\n', '        recordPositionOpened(\n', '            openTx\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        return openTx.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            openTx.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: openTx.owedToken,\n', '                heldToken: openTx.heldToken,\n', '                lender: openTx.loanOwner,\n', '                owner: openTx.positionOwner,\n', '                principal: openTx.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: openTx.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: openTx.maxDuration,\n', '                interestRate: openTx.interestRate,\n', '                interestPeriod: openTx.interestPeriod\n', '            }),\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    function validate(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '        view\n', '    {\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, openTx.positionId),\n', '            "openWithoutCounterpartyImpl#validate: positionId already exists"\n', '        );\n', '\n', '        require(\n', '            openTx.principal > 0,\n', '            "openWithoutCounterpartyImpl#validate: principal cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != address(0),\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != openTx.heldToken,\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            openTx.positionOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: positionOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.loanOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: loanOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.maxDuration > 0,\n', '            "openWithoutCounterpartyImpl#validate: maxDuration cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.interestPeriod <= openTx.maxDuration,\n', '            "openWithoutCounterpartyImpl#validate: interestPeriod must be <= maxDuration"\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            openTx.positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            bytes32(0),\n', '            openTx.owedToken,\n', '            openTx.heldToken,\n', '            address(0),\n', '            openTx.principal,\n', '            0,\n', '            openTx.deposit,\n', '            openTx.interestRate,\n', '            openTx.callTimeLimit,\n', '            openTx.maxDuration,\n', '            true\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseTx(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (Tx memory)\n', '    {\n', '        Tx memory openTx = Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[2]),\n', '            positionOwner: addresses[0],\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            loanOwner: addresses[3],\n', '            principal: values256[0],\n', '            deposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return openTx;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/PositionGetters.sol\n', '\n', '/**\n', ' * @title PositionGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any position\n', ' * stored in the dYdX protocol.\n', ' */\n', 'contract PositionGetters is MarginStorage {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets if a position is currently open.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is exists and is open\n', '     */\n', '    function containsPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return MarginCommon.containsPositionImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position is currently margin-called.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is margin-called\n', '     */\n', '    function isPositionCalled(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (state.positions[positionId].callTimestamp > 0);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position was previously open and is now closed.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is now closed\n', '     */\n', '    function isPositionClosed(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.closedPositions[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owedToken ever repaid to the lender for a position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Total amount of owedToken ever repaid\n', '     */\n', '    function getTotalOwedTokenRepaidToLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.totalOwedTokenRepaidToLender[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of heldToken currently locked up in Vault for a particular position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The amount of heldToken\n', '     */\n', '    function getPositionBalance(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getPositionBalanceImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets the time until the interest fee charged for the position will increase.\n', '     * Returns 1 if the interest fee increases every second.\n', '     * Returns 0 if the interest fee will never increase again.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of seconds until the interest fee will increase\n', '     */\n', '    function getTimeUntilInterestIncrease(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 effectiveTimeElapsed = MarginCommon.calculateEffectiveTimeElapsed(\n', '            position,\n', '            block.timestamp\n', '        );\n', '\n', '        uint256 absoluteTimeElapsed = block.timestamp.sub(position.startTimestamp);\n', '        if (absoluteTimeElapsed > effectiveTimeElapsed) { // past maxDuration\n', '            return 0;\n', '        } else {\n', '            // nextStep is the final second at which the calculated interest fee is the same as it\n', '            // is currently, so add 1 to get the correct value\n', '            return effectiveTimeElapsed.add(1).sub(absoluteTimeElapsed);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens currently needed to close the position completely, including\n', '     * interest fees.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of owedTokens\n', '     */\n', '    function getPositionOwedAmount(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            position.principal,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens needed to close a given principal amount of the position at a\n', '     * given time, including interest fees.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  principalToClose   Amount of principal being closed\n', '     * @param  timestamp          Block timestamp in seconds of close\n', '     * @return                    The number of owedTokens owed\n', '     */\n', '    function getPositionOwedAmountAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToClose,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getPositionOwedAmountAtTime: Requested time before position started"\n', '        );\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            principalToClose,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens that can be borrowed from a lender to add a given principal\n', '     * amount to the position at a given time.\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Amount being added to principal\n', '     * @param  timestamp       Block timestamp in seconds of addition\n', '     * @return                 The number of owedTokens that will be borrowed\n', '     */\n', '    function getLenderAmountForIncreasePositionAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getLenderAmountForIncreasePositionAtTime: timestamp < position start"\n', '        );\n', '\n', '        return MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principalToAdd,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    // ============ All Properties ============\n', '\n', '    /**\n', '     * Get a Position by id. This does not validate the position exists. If the position does not\n', "     * exist, all 0's will be returned.\n", '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Addresses corresponding to:\n', '     *\n', '     *                     [0] = owedToken\n', '     *                     [1] = heldToken\n', '     *                     [2] = lender\n', '     *                     [3] = owner\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = principal\n', '     *                     [1] = requiredDeposit\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = callTimeLimit\n', '     *                     [1] = startTimestamp\n', '     *                     [2] = callTimestamp\n', '     *                     [3] = maxDuration\n', '     *                     [4] = interestRate\n', '     *                     [5] = interestPeriod\n', '     */\n', '    function getPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            address[4],\n', '            uint256[2],\n', '            uint32[6]\n', '        )\n', '    {\n', '        MarginCommon.Position storage position = state.positions[positionId];\n', '\n', '        return (\n', '            [\n', '                position.owedToken,\n', '                position.heldToken,\n', '                position.lender,\n', '                position.owner\n', '            ],\n', '            [\n', '                position.principal,\n', '                position.requiredDeposit\n', '            ],\n', '            [\n', '                position.callTimeLimit,\n', '                position.startTimestamp,\n', '                position.callTimestamp,\n', '                position.maxDuration,\n', '                position.interestRate,\n', '                position.interestPeriod\n', '            ]\n', '        );\n', '    }\n', '\n', '    // ============ Individual Properties ============\n', '\n', '    function getPositionLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].lender;\n', '    }\n', '\n', '    function getPositionOwner(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owner;\n', '    }\n', '\n', '    function getPositionHeldToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].heldToken;\n', '    }\n', '\n', '    function getPositionOwedToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owedToken;\n', '    }\n', '\n', '    function getPositionPrincipal(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].principal;\n', '    }\n', '\n', '    function getPositionInterestRate(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].interestRate;\n', '    }\n', '\n', '    function getPositionRequiredDeposit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].requiredDeposit;\n', '    }\n', '\n', '    function getPositionStartTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].startTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimeLimit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimeLimit;\n', '    }\n', '\n', '    function getPositionMaxDuration(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].maxDuration;\n', '    }\n', '\n', '    function getPositioninterestPeriod(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].interestPeriod;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/TransferImpl.sol\n', '\n', '/**\n', ' * @title TransferImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the transferPosition and transferLoan functions of\n', ' * Margin\n', ' */\n', 'library TransferImpl {\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function transferLoanImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newLender\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferLoanImpl: Position does not exist"\n', '        );\n', '\n', '        address originalLender = state.positions[positionId].lender;\n', '\n', '        require(\n', '            msg.sender == originalLender,\n', '            "TransferImpl#transferLoanImpl: Only lender can transfer ownership"\n', '        );\n', '        require(\n', '            newLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', "        // Doesn't change the state of positionId; figures out the final owner of loan.\n", '        // That is, newLender may pass ownership to a different address.\n', '        address finalLender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            originalLender,\n', '            newLender);\n', '\n', '        require(\n', '            finalLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].lender = finalLender;\n', '    }\n', '\n', '    function transferPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newOwner\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferPositionImpl: Position does not exist"\n', '        );\n', '\n', '        address originalOwner = state.positions[positionId].owner;\n', '\n', '        require(\n', '            msg.sender == originalOwner,\n', '            "TransferImpl#transferPositionImpl: Only position owner can transfer ownership"\n', '        );\n', '        require(\n', '            newOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', "        // Doesn't change the state of positionId; figures out the final owner of position.\n", '        // That is, newOwner may pass ownership to a different address.\n', '        address finalOwner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            originalOwner,\n', '            newOwner);\n', '\n', '        require(\n', '            finalOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].owner = finalOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Margin.sol\n', '\n', '/**\n', ' * @title Margin\n', ' * @author dYdX\n', ' *\n', ' * This contract is used to facilitate margin trading as per the dYdX protocol\n', ' */\n', 'contract Margin is\n', '    ReentrancyGuard,\n', '    MarginStorage,\n', '    MarginEvents,\n', '    MarginAdmin,\n', '    LoanGetters,\n', '    PositionGetters\n', '{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address vault,\n', '        address proxy\n', '    )\n', '        public\n', '        MarginAdmin()\n', '    {\n', '        state = MarginState.State({\n', '            VAULT: vault,\n', '            TOKEN_PROXY: proxy\n', '        });\n', '    }\n', '\n', '    // ============ Public State Changing Functions ============\n', '\n', '    /**\n', '     * Open a margin position. Called by the margin trader who must provide both a\n', '     * signed loan offering as well as a DEX Order with which to sell the owedToken.\n', '     *\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan payer\n', '     *  [4]  = loan owner\n', '     *  [5]  = loan taker\n', '     *  [6]  = loan position owner\n', '     *  [7]  = loan fee recipient\n', '     *  [8]  = loan lender fee token\n', '     *  [9]  = loan taker fee token\n', '     *  [10]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = position amount of principal\n', '     *  [8]  = deposit amount\n', '     *  [9]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Unique ID for the new position\n', '     */\n', '    function openPosition(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bool        depositInHeldToken,\n', '        bytes       signature,\n', '        bytes       order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenPositionImpl.openPositionImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Open a margin position without a counterparty. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  addresses    Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan owner\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0]  = principal\n', '     *  [1]  = deposit amount\n', '     *  [2]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = call time limit (in seconds)\n', '     *  [1] = maxDuration (in seconds)\n', '     *  [2] = interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = interest update period (in seconds)\n', '     *\n', '     * @return              Unique ID for the new position\n', '     */\n', '    function openWithoutCounterparty(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenWithoutCounterpartyImpl.openWithoutCounterpartyImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase the size of a position. Funds will be borrowed from the loan payer and sold as per\n', '     * the position. The amount of owedToken borrowed from the lender will be >= the amount of\n', '     * principal added, as it will incorporate interest already earned by the position so far.\n', '     *\n', '     * @param  positionId          Unique ID of the position\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = loan payer\n', '     *  [1]  = loan taker\n', '     *  [2]  = loan position owner\n', '     *  [3]  = loan fee recipient\n', '     *  [4]  = loan lender fee token\n', '     *  [5]  = loan taker fee token\n', '     *  [6]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = amount of principal to add to the position (NOTE: the amount pulled from the lender\n', '     *                                                           will be >= this amount)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be pulled in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Amount of owedTokens pulled from the lender\n', '     */\n', '    function increasePosition(\n', '        bytes32    positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2]  values32,\n', '        bool       depositInHeldToken,\n', '        bytes      signature,\n', '        bytes      order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increasePositionImpl(\n', '            state,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase a position directly by putting up heldToken. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Principal amount to add to the position\n', '     * @return                 Amount of heldToken pulled from the msg.sender\n', '     */\n', '    function increaseWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increaseWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Close a position. May be called by the owner or with the approval of the owner. May provide\n', '     * an order and exchangeWrapper to facilitate the closing of the position. The payoutRecipient\n', '     * is sent the resulting payout.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @param  exchangeWrapper       Address of the exchange wrapper\n', '     * @param  payoutInHeldToken     True to pay out the payoutRecipient in heldToken,\n', '     *                               False to pay out the payoutRecipient in owedToken\n', '     * @param  order                 Order object to be passed to the exchange wrapper\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal of position closed\n', '     *                               2) Amount of tokens (heldToken if payoutInHeldtoken is true,\n', '     *                                  owedToken otherwise) received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePosition(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool    payoutInHeldToken,\n', '        bytes   order\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Helper to close a position by paying owedToken directly rather than using an exchangeWrapper.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePositionDirectly(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionDirectlyStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            new bytes(0)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Reduce the size of a position and withdraw a proportional amount of heldToken from the vault.\n', '     * Must be approved by both the position owner and lender.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     *                               3) The amount allowed by the lender if closer != lender\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the msg.sender\n', '     */\n', '    function closeWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256)\n', '    {\n', '        return CloseWithoutCounterpartyImpl.closeWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Margin-call a position. Only callable with the approval of the position lender. After the\n', '     * call, the position owner will have time equal to the callTimeLimit of the position to close\n', '     * the position. If the owner does not close the position, the lender can recover the collateral\n', '     * in the position.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requiredDeposit  Amount of deposit the position owner will have to put up to cancel\n', '     *                          the margin-call. Passing in 0 means the margin call cannot be\n', '     *                          canceled by depositing\n', '     */\n', '    function marginCall(\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        LoanImpl.marginCallImpl(\n', '            state,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Cancel a margin-call. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     */\n', '    function cancelMarginCall(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        LoanImpl.cancelMarginCallImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Used to recover the heldTokens held as collateral. Is callable after the maximum duration of\n', '     * the loan has expired or the loan has been margin-called for the duration of the callTimeLimit\n', '     * but remains unclosed. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             Amount of heldToken recovered\n', '     */\n', '    function forceRecoverCollateral(\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return ForceRecoverCollateralImpl.forceRecoverCollateralImpl(\n', '            state,\n', '            positionId,\n', '            recipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Deposit additional heldToken as collateral for a position. Cancels margin-call if:\n', '     * 0 < position.requiredDeposit < depositAmount. Only callable by the position owner.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  depositAmount    Additional amount in heldToken to deposit\n', '     */\n', '    function depositCollateral(\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        DepositCollateralImpl.depositCollateralImpl(\n', '            state,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Cancel an amount of a loan offering. Only callable by the loan offering's payer.\n", '     *\n', '     * @param  addresses     Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan position owner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256     Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32      Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  cancelAmount  Amount to cancel\n', '     * @return               Amount that was canceled\n', '     */\n', '    function cancelLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7]  values256,\n', '        uint32[4]   values32,\n', '        uint256     cancelAmount\n', '    )\n', '        external\n', '        cancelLoanOfferingStateControl\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return LoanImpl.cancelLoanOfferingImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            cancelAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a loan to a new address. This new address will be entitled to all\n', '     * payouts for this loan. Only callable by the lender for a position. If "who" is a contract, it\n', '     * must implement the LoanOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the loan\n', '     */\n', '    function transferLoan(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferLoanImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a position to a new address. This new address will be entitled to all\n', '     * payouts. Only callable by the owner of a position. If "who" is a contract, it must implement\n', '     * the PositionOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the position\n', '     */\n', '    function transferPosition(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferPositionImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the address of the Vault contract that holds and accounts for tokens.\n', '     *\n', '     * @return  The address of the Vault contract\n', '     */\n', '    function getVaultAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.VAULT;\n', '    }\n', '\n', '    /**\n', '     * Gets the address of the TokenProxy contract that accounts must set allowance on in order to\n', '     * make loans or open/close positions.\n', '     *\n', '     * @return  The address of the TokenProxy contract\n', '     */\n', '    function getTokenProxyAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.TOKEN_PROXY;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/OnlyMargin.sol\n', '\n', '/**\n', ' * @title OnlyMargin\n', ' * @author dYdX\n', ' *\n', ' * Contract to store the address of the main Margin contract and trust only that address to call\n', ' * certain functions.\n', ' */\n', 'contract OnlyMargin {\n', '\n', '    // ============ Constants ============\n', '\n', '    // Address of the known and trusted Margin contract on the blockchain\n', '    address public DYDX_MARGIN;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address margin\n', '    )\n', '        public\n', '    {\n', '        DYDX_MARGIN = margin;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyMargin()\n', '    {\n', '        require(\n', '            msg.sender == DYDX_MARGIN,\n', '            "OnlyMargin#onlyMargin: Only Margin can call"\n', '        );\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/interfaces/PositionCustodian.sol\n', '\n', '/**\n', ' * @title PositionCustodian\n', ' * @author dYdX\n', ' *\n', ' * Interface to interact with other second-layer contracts. For contracts that own positions as a\n', ' * proxy for other addresses.\n', ' */\n', 'interface PositionCustodian {\n', '\n', '    /**\n', '     * Function that is intended to be called by external contracts to see where to pay any fees or\n', '     * tokens as a result of closing a position on behalf of another contract.\n', '     *\n', '     * @param  positionId   Unique ID of the position\n', '     * @return              Address of the true owner of the position\n', '     */\n', '    function getPositionDeedHolder(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/external/lib/MarginHelper.sol\n', '\n', '/**\n', ' * @title MarginHelper\n', ' * @author dYdX\n', ' *\n', ' * This library contains helper functions for interacting with Margin\n', ' */\n', 'library MarginHelper {\n', '    function getPosition(\n', '        address DYDX_MARGIN,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (MarginCommon.Position memory)\n', '    {\n', '        (\n', '            address[4] memory addresses,\n', '            uint256[2] memory values256,\n', '            uint32[6]  memory values32\n', '        ) = Margin(DYDX_MARGIN).getPosition(positionId);\n', '\n', '        return MarginCommon.Position({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            lender: addresses[2],\n', '            owner: addresses[3],\n', '            principal: values256[0],\n', '            requiredDeposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            startTimestamp: values32[1],\n', '            callTimestamp: values32[2],\n', '            maxDuration: values32[3],\n', '            interestRate: values32[4],\n', '            interestPeriod: values32[5]\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/ERC20/ERC20Position.sol\n', '\n', '/**\n', ' * @title ERC20Position\n', ' * @author dYdX\n', ' *\n', ' * Shared code for ERC20Short and ERC20Long\n', ' */\n', 'contract ERC20Position is\n', '    ReentrancyGuard,\n', '    StandardToken,\n', '    OnlyMargin,\n', '    PositionOwner,\n', '    IncreasePositionDelegator,\n', '    ClosePositionDelegator,\n', '    PositionCustodian\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Enums ============\n', '\n', '    enum State {\n', '        UNINITIALIZED,\n', '        OPEN,\n', '        CLOSED\n', '    }\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * This ERC20 was successfully initialized\n', '     */\n', '    event Initialized(\n', '        bytes32 positionId,\n', '        uint256 initialSupply\n', '    );\n', '\n', '    /**\n', '     * The position was completely closed by a trusted third-party and tokens can be withdrawn\n', '     */\n', '    event ClosedByTrustedParty(\n', '        address closer,\n', '        uint256 tokenAmount,\n', '        address payoutRecipient\n', '    );\n', '\n', '    /**\n', '     * The position was completely closed and tokens can be withdrawn\n', '     */\n', '    event CompletelyClosed();\n', '\n', '    /**\n', '     * A user burned tokens to withdraw heldTokens from this contract after the position was closed\n', '     */\n', '    event Withdraw(\n', '        address indexed redeemer,\n', '        uint256 tokensRedeemed,\n', '        uint256 heldTokenPayout\n', '    );\n', '\n', '    /**\n', '     * A user burned tokens in order to partially close the position\n', '     */\n', '    event Close(\n', '        address indexed redeemer,\n', '        uint256 closeAmount\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    // All tokens will initially be allocated to this address\n', '    address public INITIAL_TOKEN_HOLDER;\n', '\n', '    // Unique ID of the position this contract is tokenizing\n', '    bytes32 public POSITION_ID;\n', '\n', '    // Recipients that will fairly verify and redistribute funds from closing the position\n', '    mapping (address => bool) public TRUSTED_RECIPIENTS;\n', '\n', '    // Withdrawers that will fairly withdraw funds after the position has been closed\n', '    mapping (address => bool) public TRUSTED_WITHDRAWERS;\n', '\n', '    // Current State of this contract. See State enum\n', '    State public state;\n', '\n', "    // Address of the position's heldToken. Cached for convenience and lower-cost withdrawals\n", '    address public heldToken;\n', '\n', '    // Position has been closed using a trusted recipient\n', '    bool public closedUsingTrustedRecipient;\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyPosition(bytes32 positionId) {\n', '        require(\n', '            POSITION_ID == positionId,\n', '            "ERC20Position#onlyPosition: Incorrect position"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyState(State specificState) {\n', '        require(\n', '            state == specificState,\n', '            "ERC20Position#onlyState: Incorrect State"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        bytes32 positionId,\n', '        address margin,\n', '        address initialTokenHolder,\n', '        address[] trustedRecipients,\n', '        address[] trustedWithdrawers\n', '    )\n', '        public\n', '        OnlyMargin(margin)\n', '    {\n', '        POSITION_ID = positionId;\n', '        state = State.UNINITIALIZED;\n', '        INITIAL_TOKEN_HOLDER = initialTokenHolder;\n', '        closedUsingTrustedRecipient = false;\n', '\n', '        uint256 i;\n', '        for (i = 0; i < trustedRecipients.length; i++) {\n', '            TRUSTED_RECIPIENTS[trustedRecipients[i]] = true;\n', '        }\n', '        for (i = 0; i < trustedWithdrawers.length; i++) {\n', '            TRUSTED_WITHDRAWERS[trustedWithdrawers[i]] = true;\n', '        }\n', '    }\n', '\n', '    // ============ Margin-Only Functions ============\n', '\n', '    /**\n', '     * Called by Margin when anyone transfers ownership of a position to this contract.\n', '     * This function initializes the tokenization of the position given and returns this address to\n', '     * indicate to Margin that it is willing to take ownership of the position.\n', '     *\n', '     *  param  (unused)\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address on success, throw otherwise\n', '     */\n', '    function receivePositionOwnership(\n', '        address /* from */,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyState(State.UNINITIALIZED)\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, POSITION_ID);\n', '        assert(position.principal > 0);\n', '\n', '        // set relevant constants\n', '        state = State.OPEN;\n', '        heldToken = position.heldToken;\n', '\n', '        uint256 tokenAmount = getTokenAmountOnAdd(position.principal);\n', '\n', '        emit Initialized(POSITION_ID, tokenAmount);\n', '\n', '        mint(INITIAL_TOKEN_HOLDER, tokenAmount);\n', '\n', '        return address(this); // returning own address retains ownership of position\n', '    }\n', '\n', '    /**\n', '     * Called by Margin when additional value is added onto the position this contract\n', '     * owns. Tokens are minted and assigned to the address that added the value.\n', '     *\n', '     * @param  trader          Address that added the value to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount that was added to the position\n', '     * @return                 This address on success, throw otherwise\n', '     */\n', '    function increasePositionOnBehalfOf(\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyState(State.OPEN)\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            !Margin(DYDX_MARGIN).isPositionCalled(POSITION_ID),\n', '            "ERC20Position#increasePositionOnBehalfOf: Position is margin-called"\n', '        );\n', '        require(\n', '            !closedUsingTrustedRecipient,\n', '            "ERC20Position#increasePositionOnBehalfOf: Position closed using trusted recipient"\n', '        );\n', '\n', '        uint256 tokenAmount = getTokenAmountOnAdd(principalAdded);\n', '\n', '        mint(trader, tokenAmount);\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Called by Margin when an owner of this token is attempting to close some of the\n', '     * position. Implementation is required per PositionOwner contract in order to be used by\n', '     * Margin to approve closing parts of a position.\n', '     *\n', '     * @param  closer           Address of the caller of the close function\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Amount (in principal) of the position being closed\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyState(State.OPEN)\n', '        onlyPosition(positionId)\n', '        returns (address, uint256)\n', '    {\n', '        uint256 positionPrincipal = Margin(DYDX_MARGIN).getPositionPrincipal(positionId);\n', '\n', '        assert(requestedAmount <= positionPrincipal);\n', '\n', '        uint256 allowedAmount;\n', '        if (TRUSTED_RECIPIENTS[payoutRecipient]) {\n', '            allowedAmount = closeUsingTrustedRecipient(\n', '                closer,\n', '                payoutRecipient,\n', '                requestedAmount\n', '            );\n', '        } else {\n', '            allowedAmount = close(\n', '                closer,\n', '                requestedAmount,\n', '                positionPrincipal\n', '            );\n', '        }\n', '\n', '        assert(allowedAmount > 0);\n', '        assert(allowedAmount <= requestedAmount);\n', '\n', '        if (allowedAmount == positionPrincipal) {\n', '            state = State.CLOSED;\n', '            emit CompletelyClosed();\n', '        }\n', '\n', '        return (address(this), allowedAmount);\n', '    }\n', '\n', '    // ============ Public State Changing Functions ============\n', '\n', '    /**\n', '     * Withdraw heldTokens from this contract for any of the position that was closed via external\n', '     * means (such as an auction-closing mechanism)\n', '     *\n', '     * NOTE: It is possible that this contract could be sent heldToken by external sources\n', '     * other than from the Margin contract. In this case the payout for token holders\n', '     * would be greater than just that from the normal payout. This is fine because\n', "     * nobody has incentive to send this contract extra funds, and if they do then it's\n", '     * also fine just to let the token holders have it.\n', '     *\n', '     * NOTE: If there are significant rounding errors, then it is possible that withdrawing later is\n', '     * more advantageous. An "attack" could involve withdrawing for others before withdrawing for\n', '     * yourself. Likely, rounding error will be small enough to not properly incentivize people to\n', '     * carry out such an attack.\n', '     *\n', '     * @param  onBehalfOf  Address of the account to withdraw for\n', '     * @return             The amount of heldToken withdrawn\n', '     */\n', '    function withdraw(\n', '        address onBehalfOf\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        setStateClosedIfClosed();\n', '        require(\n', '            state == State.CLOSED,\n', '            "ERC20Position#withdraw: Position has not yet been closed"\n', '        );\n', '\n', '        if (msg.sender != onBehalfOf) {\n', '            require(\n', '                TRUSTED_WITHDRAWERS[msg.sender],\n', '                "ERC20Position#withdraw: Only trusted withdrawers can withdraw on behalf of others"\n', '            );\n', '        }\n', '\n', '        return withdrawImpl(msg.sender, onBehalfOf);\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', "     * ERC20 decimals function. Returns the same number of decimals as the position's owedToken\n", '     *\n', '     * @return  The number of decimal places, or revert if the baseToken has no such function.\n', '     */\n', '    function decimals()\n', '        external\n', '        view\n', '        returns (uint8);\n', '\n', '    /**\n', '     * ERC20 symbol function.\n', '     *\n', '     * @return  The symbol of the Margin Token\n', '     */\n', '    function symbol()\n', '        external\n', '        view\n', '        returns (string);\n', '\n', '    /**\n', '     * Implements PositionCustodian functionality. Called by external contracts to see where to pay\n', '     * tokens as a result of closing a position on behalf of this contract\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Address of this contract. Indicates funds should be sent to this contract\n', '     */\n', '    function getPositionDeedHolder(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        // Claim ownership of deed and allow token holders to withdraw funds from this contract\n', '        return address(this);\n', '    }\n', '\n', '    // ============ Internal Helper-Functions ============\n', '\n', '    /**\n', '     * Tokens are not burned when a trusted recipient is used, but we require the position to be\n', '     * completely closed. All token holders are then entitled to the heldTokens in the contract\n', '     */\n', '    function closeUsingTrustedRecipient(\n', '        address closer,\n', '        address payoutRecipient,\n', '        uint256 requestedAmount\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        assert(requestedAmount > 0);\n', '\n', '        // remember that a trusted recipient was used\n', '        if (!closedUsingTrustedRecipient) {\n', '            closedUsingTrustedRecipient = true;\n', '        }\n', '\n', '        emit ClosedByTrustedParty(closer, requestedAmount, payoutRecipient);\n', '\n', '        return requestedAmount;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function withdrawImpl(\n', '        address receiver,\n', '        address onBehalfOf\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        uint256 value = balanceOf(onBehalfOf);\n', '\n', '        if (value == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 heldTokenBalance = TokenInteract.balanceOf(heldToken, address(this));\n', '\n', '        // NOTE the payout must be calculated before decrementing the totalSupply below\n', '        uint256 heldTokenPayout = MathHelpers.getPartialAmount(\n', '            value,\n', '            totalSupply_,\n', '            heldTokenBalance\n', '        );\n', '\n', '        // Destroy the margin tokens\n', '        burn(onBehalfOf, value);\n', '        emit Withdraw(onBehalfOf, value, heldTokenPayout);\n', '\n', '        // Send the redeemer their proportion of heldToken\n', '        TokenInteract.transfer(heldToken, receiver, heldTokenPayout);\n', '\n', '        return heldTokenPayout;\n', '    }\n', '\n', '    function setStateClosedIfClosed(\n', '    )\n', '        private\n', '    {\n', '        // If in OPEN state, but the position is closed, set to CLOSED state\n', '        if (state == State.OPEN && Margin(DYDX_MARGIN).isPositionClosed(POSITION_ID)) {\n', '            state = State.CLOSED;\n', '            emit CompletelyClosed();\n', '        }\n', '    }\n', '\n', '    function close(\n', '        address closer,\n', '        uint256 requestedAmount,\n', '        uint256 positionPrincipal\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        uint256 balance = balances[closer];\n', '\n', '        (\n', '            uint256 tokenAmount,\n', '            uint256 allowedCloseAmount\n', '        ) = getCloseAmounts(\n', '            requestedAmount,\n', '            balance,\n', '            positionPrincipal\n', '        );\n', '\n', '        require(\n', '            tokenAmount > 0 && allowedCloseAmount > 0,\n', '            "ERC20Position#close: Cannot close 0 amount"\n', '        );\n', '\n', '        assert(allowedCloseAmount <= requestedAmount);\n', '\n', '        burn(closer, tokenAmount);\n', '\n', '        emit Close(closer, tokenAmount);\n', '\n', '        return allowedCloseAmount;\n', '    }\n', '\n', '    function burn(\n', '        address from,\n', '        uint256 amount\n', '    )\n', '        private\n', '    {\n', '        assert(from != address(0));\n', '        totalSupply_ = totalSupply_.sub(amount);\n', '        balances[from] = balances[from].sub(amount);\n', '        emit Transfer(from, address(0), amount);\n', '    }\n', '\n', '    function mint(\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        private\n', '    {\n', '        assert(to != address(0));\n', '        totalSupply_ = totalSupply_.add(amount);\n', '        balances[to] = balances[to].add(amount);\n', '        emit Transfer(address(0), to, amount);\n', '    }\n', '\n', '    // ============ Private Abstract Functions ============\n', '\n', '    function getTokenAmountOnAdd(\n', '        uint256 principalAdded\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256);\n', '\n', '    function getCloseAmounts(\n', '        uint256 requestedCloseAmount,\n', '        uint256 balance,\n', '        uint256 positionPrincipal\n', '    )\n', '        private\n', '        view\n', '        returns (\n', '            uint256 /* tokenAmount */,\n', '            uint256 /* allowedCloseAmount */\n', '        );\n', '}\n', '\n', '// File: contracts/margin/external/ERC20/ERC20CappedPosition.sol\n', '\n', '/**\n', ' * @title ERC20CappedPosition\n', ' * @author dYdX\n', ' *\n', ' * ERC20 Position with a limit on the number of tokens that can be minted, and a restriction on\n', ' * which addreses can close the position after it is force-recoverable.\n', ' */\n', 'contract ERC20CappedPosition is\n', '    ERC20Position,\n', '    Ownable\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event TokenCapSet(\n', '        uint256 tokenCap\n', '    );\n', '\n', '    event TrustedCloserSet(\n', '        address closer,\n', '        bool allowed\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    mapping(address => bool) public TRUSTED_LATE_CLOSERS;\n', '\n', '    uint256 public tokenCap;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address[] trustedLateClosers,\n', '        uint256 cap\n', '    )\n', '        public\n', '        Ownable()\n', '    {\n', '        for (uint256 i = 0; i < trustedLateClosers.length; i++) {\n', '            TRUSTED_LATE_CLOSERS[trustedLateClosers[i]] = true;\n', '        }\n', '        tokenCap = cap;\n', '    }\n', '\n', '    // ============ Owner-Only Functions ============\n', '\n', '    function setTokenCap(\n', '        uint256 newCap\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        // We do not need to require that the tokenCap is >= totalSupply_ because the cap is only\n', '        // checked when increasing the position. It does not prevent any other functionality\n', '        tokenCap = newCap;\n', '        emit TokenCapSet(newCap);\n', '    }\n', '\n', '    function setTrustedLateCloser(\n', '        address closer,\n', '        bool allowed\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        TRUSTED_LATE_CLOSERS[closer] = allowed;\n', '        emit TrustedCloserSet(closer, allowed);\n', '    }\n', '\n', '    // ============ Internal Overriding Functions ============\n', '\n', '    // overrides the function in ERC20Position\n', '    function closeUsingTrustedRecipient(\n', '        address closer,\n', '        address payoutRecipient,\n', '        uint256 requestedAmount\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, POSITION_ID);\n', '\n', '        bool afterEnd =\n', '            block.timestamp > uint256(position.startTimestamp).add(position.maxDuration);\n', '        bool afterCall =\n', '            position.callTimestamp > 0 &&\n', '            block.timestamp > uint256(position.callTimestamp).add(position.callTimeLimit);\n', '\n', '        if (afterCall || afterEnd) {\n', '            require (\n', '                TRUSTED_LATE_CLOSERS[closer],\n', '                "ERC20CappedPosition#closeUsingTrustedRecipient: closer not in TRUSTED_LATE_CLOSERS"\n', '            );\n', '        }\n', '\n', '        return super.closeUsingTrustedRecipient(closer, payoutRecipient, requestedAmount);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: contracts/lib/StringHelpers.sol\n', '\n', '/**\n', ' * @title StringHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with string manipulation in Solidity\n', ' */\n', 'library StringHelpers {\n', '\n', '    /**\n', '     * Concatenates two byte arrays and return the result\n', '     *\n', '     * @param  stringA  The string that goes first\n', '     * @param  stringB  The string that goes second\n', '     * @return          The two strings concatenated\n', '     */\n', '    function strcat(\n', '        bytes stringA,\n', '        bytes stringB\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes)\n', '    {\n', '        uint256 lengthA = stringA.length;\n', '        uint256 lengthB = stringB.length;\n', '        bytes memory result = new bytes(lengthA + lengthB);\n', '\n', '        uint256 i = 0;\n', '        for (i = 0; i < lengthA; i++) {\n', '            result[i] = stringA[i];\n', '        }\n', '        for (i = 0; i < lengthB; i++) {\n', '            result[lengthA + i] = stringB[i];\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Translates a bytes32 to an ascii hexadecimal representation starting with "0x"\n', '     *\n', '     * @param  input  The bytes to convert to hexadecimal\n', '     * @return        A representation of the bytes in ascii hexadecimal\n', '     */\n', '    function bytes32ToHex(\n', '        bytes32 input\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes)\n', '    {\n', '        uint256 number = uint256(input);\n', '        bytes memory numberAsString = new bytes(66); // "0x" and then 2 chars per byte\n', "        numberAsString[0] = byte(48);  // '0'\n", "        numberAsString[1] = byte(120); // 'x'\n", '\n', '        for (uint256 n = 0; n < 32; n++) {\n', '            uint256 nthByte = number / uint256(uint256(2) ** uint256(248 - 8 * n));\n', '\n', '            // 1 byte to 2 hexadecimal numbers\n', '            uint8 hex1 = uint8(nthByte) / uint8(16);\n', '            uint8 hex2 = uint8(nthByte) % uint8(16);\n', '\n', "            // 87 is ascii for '0', 48 is ascii for 'a'\n", '            hex1 += (hex1 > 9) ? 87 : 48; // shift into proper ascii value\n', '            hex2 += (hex2 > 9) ? 87 : 48; // shift into proper ascii value\n', '            numberAsString[2 * n + 2] = byte(hex1);\n', '            numberAsString[2 * n + 3] = byte(hex2);\n', '        }\n', '        return numberAsString;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/ERC20/ERC20Short.sol\n', '\n', '/**\n', ' * @title ERC20Short\n', ' * @author dYdX\n', ' *\n', ' * Contract used to tokenize short positions and allow them to be used as ERC20-compliant\n', ' * tokens. Holding the tokens allows the holder to close a piece of the short position, or be\n', ' * entitled to some amount of heldTokens after settlement.\n', ' *\n', ' * The total supply of short tokens is always exactly equal to the amount of principal in\n', ' * the backing position\n', ' */\n', 'contract ERC20Short is ERC20Position {\n', '    constructor(\n', '        bytes32 positionId,\n', '        address margin,\n', '        address initialTokenHolder,\n', '        address[] trustedRecipients,\n', '        address[] trustedWithdrawers\n', '    )\n', '        public\n', '        ERC20Position(\n', '            positionId,\n', '            margin,\n', '            initialTokenHolder,\n', '            trustedRecipients,\n', '            trustedWithdrawers\n', '        )\n', '    {}\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    function decimals()\n', '        external\n', '        view\n', '        returns (uint8)\n', '    {\n', '        address owedToken = Margin(DYDX_MARGIN).getPositionOwedToken(POSITION_ID);\n', '        return DetailedERC20(owedToken).decimals();\n', '    }\n', '\n', '    function symbol()\n', '        external\n', '        view\n', '        returns (string)\n', '    {\n', '        if (state == State.UNINITIALIZED) {\n', '            return "s[UNINITIALIZED]";\n', '        }\n', '        address owedToken = Margin(DYDX_MARGIN).getPositionOwedToken(POSITION_ID);\n', '        return string(\n', '            StringHelpers.strcat(\n', '                "s",\n', '                bytes(DetailedERC20(owedToken).symbol())\n', '            )\n', '        );\n', '    }\n', '\n', '    function name()\n', '        external\n', '        view\n', '        returns (string)\n', '    {\n', '        if (state == State.UNINITIALIZED) {\n', '            return "dYdX Short Token [UNINITIALIZED]";\n', '        }\n', '        return string(\n', '            StringHelpers.strcat(\n', '                "dYdX Short Token ",\n', '                StringHelpers.bytes32ToHex(POSITION_ID)\n', '            )\n', '        );\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function getTokenAmountOnAdd(\n', '        uint256 principalAdded\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return principalAdded;\n', '    }\n', '\n', '    function getCloseAmounts(\n', '        uint256 requestedCloseAmount,\n', '        uint256 balance,\n', '        uint256 positionPrincipal\n', '    )\n', '        private\n', '        view\n', '        returns (\n', '            uint256 /* tokenAmount */,\n', '            uint256 /* allowedCloseAmount */\n', '        )\n', '    {\n', '        // positionPrincipal < totalSupply_ if position was closed by a trusted closer\n', '        assert(positionPrincipal <= totalSupply_);\n', '\n', '        uint256 amount = Math.min256(balance, requestedCloseAmount);\n', '\n', '        return (amount, amount);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/ERC20/ERC20CappedShort.sol\n', '\n', '/**\n', ' * @title ERC20CappedShort\n', ' * @author dYdX\n', ' *\n', ' * ERC20Short with a limit on the number of tokens that can be minted, and a restriction on\n', ' * which addreses can close the position after it is force-recoverable.\n', ' */\n', 'contract ERC20CappedShort is\n', '    ERC20Short,\n', '    ERC20CappedPosition\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        bytes32 positionId,\n', '        address margin,\n', '        address initialTokenHolder,\n', '        address[] trustedRecipients,\n', '        address[] trustedWithdrawers,\n', '        address[] trustedLateClosers,\n', '        uint256 cap\n', '    )\n', '        public\n', '        ERC20Short(\n', '            positionId,\n', '            margin,\n', '            initialTokenHolder,\n', '            trustedRecipients,\n', '            trustedWithdrawers\n', '        )\n', '        ERC20CappedPosition(\n', '            trustedLateClosers,\n', '            cap\n', '        )\n', '    {\n', '    }\n', '\n', '    // ============ Internal Overriding Functions ============\n', '\n', '    function getTokenAmountOnAdd(\n', '        uint256 principalAdded\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 tokenAmount = super.getTokenAmountOnAdd(principalAdded);\n', '\n', '        require(\n', '            totalSupply_.add(tokenAmount) <= tokenCap,\n', '            "ERC20CappedShort#getTokenAmountOnAdd: Adding tokenAmount would exceed cap"\n', '        );\n', '\n', '        return tokenAmount;\n', '    }\n', '}']