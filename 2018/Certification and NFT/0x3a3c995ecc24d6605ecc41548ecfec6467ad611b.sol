['/**\n', ' * ▒█▀▀█ ░▀░ █▀▀█ █▀▀▄ █▀▄▀█ █▀▀█ █▀▀▄ \n', ' * ▒█▀▀▄ ▀█▀ █▄▄▀ █░░█ █░▀░█ █▄▄█ █░░█ \n', ' * ▒█▄▄█ ▀▀▀ ▀░▀▀ ▀▀▀░ ▀░░░▀ ▀░░▀ ▀░░▀ \n', ' *\n', ' * Birdman helps grow the Microverse community,\n', ' * which is considered the premature version of Mutual Constructor.\n', ' */\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title AdminUtils\n', ' * @dev customized admin control panel\n', ' * @dev just want to keep everything safe\n', ' */\n', 'contract AdminUtils is Ownable {\n', '\n', '    mapping (address => uint256) adminContracts;\n', '\n', '    address internal root;\n', '\n', '    /* modifiers */\n', '    modifier OnlyContract() {\n', '        require(isSuperContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier OwnerOrContract() {\n', '        require(msg.sender == owner || isSuperContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoot() {\n', '        require(msg.sender == root);\n', '        _;\n', '    }\n', '\n', '    /* constructor */\n', '    constructor() public {\n', '        // This is a safe key stored offline\n', '        root = 0xe07faf5B0e91007183b76F37AC54d38f90111D40;\n', '    }\n', '\n', '    /**\n', '     * @dev this is the kickass idea from @dan\n', '     * and well we will see how it works\n', '     */\n', '    function claimOwnership()\n', '        external\n', '        onlyRoot\n', '        returns (bool) {\n', '        owner = root;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev function to address a super contract address\n', '     * some functions are meant to be called from another contract\n', '     * but not from any contracts\n', '     * @param _address A contract address\n', '     */\n', '    function addContractAddress(address _address)\n', '        public\n', '        onlyOwner\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        adminContracts[_address] = 1;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove the contract address as a super user role\n', '     * have it here just in case\n', '     * @param _address A contract address\n', '     */\n', '    function removeContractAddress(address _address)\n', '        public\n', '        onlyOwner\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        adminContracts[_address] = 0;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev check contract eligibility\n', '     * @param _address A contract address\n', '     */\n', '    function isSuperContract(address _address)\n', '        public\n', '        view\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (adminContracts[_address] == 1) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Contract that will work with ERC223 tokens.\n', ' */\n', 'contract ERC223ReceivingContract { \n', '/**\n', ' * @dev Standard ERC223 function that will handle incoming token transfers.\n', ' *\n', ' * @param _from  Token sender address.\n', ' * @param _value Amount of tokens.\n', ' * @param _data  Transaction metadata.\n', ' */\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', '/**\n', ' * @title EvilMortyTokenInterface\n', ' */\n', 'contract EvilMortyTokenInterface {\n', '\n', '    /**\n', '     * @dev Check balance of a given address\n', '     * @param sender address\n', '     */\n', '    function balanceOf(address sender) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Birdman\n', ' */\n', 'contract Birdman is AdminUtils, ERC223ReceivingContract {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event MCApplied(address sender);\n', '    event MCAdded(address sender);\n', '    event MCRemoved(address sender);\n', '    event ShareSent(address indexed receiver, uint256 value);\n', '    event SystemChangeValidMCAmount(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeMaxNumMC(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeShareTimeGap(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeVettingTime(uint256 oldValue, uint256 newValue);\n', '\n', '    EvilMortyTokenInterface internal EvilMortyInstance;\n', '\n', '    uint256 public validMCAmount = 5000000e18;\n', '    uint256 public maxNumMC = 20;\n', '    uint256 public vettingTime = 86400; // in block height, roughly 15 days\n', '    uint256 public shareTimeGap = 86400; // in block height, roughly 15 days\n', '    uint256 public numMC;\n', '    uint256 public numMCApplied;\n', '    uint256 public nextShareTime = 6213990; // around UTC 01:00, 8/26/2018\n', '    uint256 public weiAmountShare;\n', '\n', '    mapping (uint256 => MC) constructors;\n', '    mapping (address => uint256) addressToIndex;\n', '\n', '    struct MC {\n', '      address playerAddress;\n', '      uint256 timeSince;\n', '      uint256 nextSharedSentTime;\n', '      bool passed;\n', '    }\n', '    \n', '    uint256[] emptyIndexes;\n', '\n', '    modifier isValidMC() {\n', '        require (EvilMortyInstance.balanceOf(msg.sender) >= validMCAmount);\n', '        _;\n', '    }\n', '\n', '    modifier canAddMC() {\n', '      require (numMCApplied < maxNumMC);\n', '      // make sure no one cheats\n', '      require (addressToIndex[msg.sender] == 0);\n', '      \n', '      _; \n', '    }\n', '\n', '    modifier isEvilMortyToken() {\n', '        require(msg.sender == address(EvilMortyInstance));\n', '        _;\n', '    }\n', '\n', '    /* constructor */\n', '    constructor(address EvilMortyAddress)\n', '        public {\n', '        EvilMortyInstance = EvilMortyTokenInterface(EvilMortyAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Allow funds to be sent to this contract\n', '     * if the sender is the owner or a super contract\n', '     * then it will do nothing\n', '     */\n', '    function ()\n', '        public\n', '        payable {\n', '        if (msg.sender == owner || isSuperContract(msg.sender)) {\n', '            return;\n', '        }\n', '        applyMC();\n', '    }\n', '\n', '    /**\n', '     * @dev Allow morty token to be sent to this contract\n', '     * if the sender is the owner it will do nothing\n', '     */\n', '    function tokenFallback(address _from, uint256 _value, bytes)\n', '        public\n', '        isEvilMortyToken {\n', '        if (_from == owner) {\n', '            return;\n', '        }\n', '        claimShare(addressToIndex[_from]);\n', '    }\n', '\n', '    /**\n', '     * @dev Apply for becoming a MC\n', '     */\n', '    function applyMC()\n', '        public\n', '        payable\n', '        canAddMC {\n', '\n', '        require (EvilMortyInstance.balanceOf(msg.sender) >= validMCAmount);\n', '\n', '        numMCApplied = numMCApplied.add(1);\n', '        uint256 newIndex = numMCApplied;\n', '\n', '        if (emptyIndexes.length > 0) {\n', '            newIndex = emptyIndexes[emptyIndexes.length-1];\n', '            delete emptyIndexes[emptyIndexes.length-1];\n', '            emptyIndexes.length--;\n', '        }\n', '\n', '        constructors[newIndex] = MC({\n', '            playerAddress: msg.sender,\n', '            timeSince: block.number.add(vettingTime),\n', '            nextSharedSentTime: nextShareTime,\n', '            passed: false\n', '        });\n', '\n', '        addressToIndex[msg.sender] = newIndex;\n', '\n', '        emit MCApplied(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Get a MC&#39;s info given index\n', '     * @param _index the MC&#39;s index\n', '     */\n', '    function getMC(uint256 _index)\n', '        public\n', '        view\n', '        returns (address, uint256, uint256, bool) {\n', '        MC storage mc = constructors[_index];\n', '        return (\n', '            mc.playerAddress,\n', '            mc.timeSince,\n', '            mc.nextSharedSentTime,\n', '            mc.passed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Get number of empty indexes\n', '     */\n', '    function numEmptyIndexes()\n', '        public\n', '        view\n', '        returns (uint256) {\n', '        return emptyIndexes.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the MC index given address\n', '     * @param _address MC&#39;s address\n', '     */\n', '    function getIndex(address _address)\n', '        public\n', '        view\n', '        returns (uint256) {\n', '        return addressToIndex[_address];\n', '    }\n', '\n', '    /**\n', '     * @dev Update all MC&#39;s status\n', '     */\n', '    function updateMCs()\n', '        public {\n', '\n', '        if (numMCApplied == 0) {\n', '            return;\n', '        }\n', '\n', '        for (uint256 i = 0; i < maxNumMC; i ++) {\n', '            updateMC(i);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update a MC&#39;s status, if\n', '     * - the MC&#39;s balance is below min requirement, it will be deleted;\n', '     * - the MC&#39;s vetting time is passed, it will be added\n', '     * @param _index the MC&#39;s index\n', '     */\n', '    function updateMC(uint256 _index)\n', '        public {\n', '        MC storage mc = constructors[_index];\n', '\n', '        // skip empty index\n', '        if (mc.playerAddress == 0) {\n', '            return;\n', '        }\n', '\n', '        if (EvilMortyInstance.balanceOf(mc.playerAddress) < validMCAmount) {\n', '            // remove MC\n', '            numMCApplied = numMCApplied.sub(1);\n', '            if (mc.passed == true) {\n', '                numMC = numMC.sub(1);\n', '            }\n', '            emptyIndexes.push(_index);\n', '            emit MCRemoved(mc.playerAddress);\n', '            delete addressToIndex[mc.playerAddress];\n', '            delete constructors[_index];\n', '            return;\n', '        }\n', '\n', '        if (mc.passed == false && mc.timeSince < block.number) {\n', '             mc.passed = true;\n', '             numMC = numMC.add(1);\n', '             emit MCAdded(mc.playerAddress);\n', '             return;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update funds to be sent in this shares period\n', '     */\n', '    function updateWeiAmountShare()\n', '        public {\n', '        if (numMC == 0) {\n', '            return;\n', '        }\n', '        if (nextShareTime < block.number) {\n', '            weiAmountShare = address(this).balance.div(numMC);\n', '\n', '            // make height accurate\n', '            uint256 timeGap = block.number.sub(nextShareTime);\n', '            uint256 gap = timeGap.div(shareTimeGap).add(1);\n', '            nextShareTime = nextShareTime.add(shareTimeGap.mul(gap));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Ask for funds for a MC\n', '     * @param _index the Mc&#39;s index\n', '     */\n', '    function claimShare(uint256 _index)\n', '        public {\n', '\n', '        // need update all MCs first\n', '        updateMCs();\n', '\n', '        MC storage mc = constructors[_index];\n', '\n', '        // skip empty index\n', '        if (mc.playerAddress == 0) {\n', '            return;\n', '        }\n', '\n', '        if (mc.passed == false) {\n', '            return;\n', '        }\n', '\n', '        if (mc.nextSharedSentTime < block.number) {\n', '            // update next share time\n', '            updateWeiAmountShare();\n', '            mc.nextSharedSentTime = nextShareTime;\n', '            // every mc gets equal share\n', '            mc.playerAddress.transfer(weiAmountShare);\n', '            emit ShareSent(mc.playerAddress, weiAmountShare);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade evil morty\n', '     * in case of upgrade needed\n', '     */\n', '    function upgradeEvilMorty(address _address)\n', '        external\n', '        onlyOwner {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return;\n', '        }\n', '\n', '        EvilMortyInstance = EvilMortyTokenInterface(_address);\n', '    }\n', '\n', '    /**\n', '     * @dev Update min requirement for being a MC\n', '     * a system event is emitted to capture the change\n', '     * @param _amount new amount\n', '     */\n', '    function updateValidMCAmount(uint256 _amount)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeValidMCAmount(validMCAmount, _amount);\n', '        validMCAmount = _amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Update max number of MCs\n', '     * a system event is emitted to capture the change\n', '     */\n', '    function updateMaxNumMC(uint256 _num)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeMaxNumMC(maxNumMC, _num);\n', '        maxNumMC = _num;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the length of a share period\n', '     * a system event is emitted to capture the change\n', '     * @param _height bloch heights\n', '     */\n', '    function updateShareTimeGap(uint256 _height)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeShareTimeGap(shareTimeGap, _height);\n', '        shareTimeGap = _height;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the length of vetting time\n', '     * a system event is emitted to capture the change\n', '     * @param _height bloch heights\n', '     */\n', '    function updateVettingTime(uint256 _height)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeVettingTime(vettingTime, _height);\n', '        vettingTime = _height;\n', '    }\n', '}']
['/**\n', ' * ▒█▀▀█ ░▀░ █▀▀█ █▀▀▄ █▀▄▀█ █▀▀█ █▀▀▄ \n', ' * ▒█▀▀▄ ▀█▀ █▄▄▀ █░░█ █░▀░█ █▄▄█ █░░█ \n', ' * ▒█▄▄█ ▀▀▀ ▀░▀▀ ▀▀▀░ ▀░░░▀ ▀░░▀ ▀░░▀ \n', ' *\n', ' * Birdman helps grow the Microverse community,\n', ' * which is considered the premature version of Mutual Constructor.\n', ' */\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title AdminUtils\n', ' * @dev customized admin control panel\n', ' * @dev just want to keep everything safe\n', ' */\n', 'contract AdminUtils is Ownable {\n', '\n', '    mapping (address => uint256) adminContracts;\n', '\n', '    address internal root;\n', '\n', '    /* modifiers */\n', '    modifier OnlyContract() {\n', '        require(isSuperContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier OwnerOrContract() {\n', '        require(msg.sender == owner || isSuperContract(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoot() {\n', '        require(msg.sender == root);\n', '        _;\n', '    }\n', '\n', '    /* constructor */\n', '    constructor() public {\n', '        // This is a safe key stored offline\n', '        root = 0xe07faf5B0e91007183b76F37AC54d38f90111D40;\n', '    }\n', '\n', '    /**\n', '     * @dev this is the kickass idea from @dan\n', '     * and well we will see how it works\n', '     */\n', '    function claimOwnership()\n', '        external\n', '        onlyRoot\n', '        returns (bool) {\n', '        owner = root;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev function to address a super contract address\n', '     * some functions are meant to be called from another contract\n', '     * but not from any contracts\n', '     * @param _address A contract address\n', '     */\n', '    function addContractAddress(address _address)\n', '        public\n', '        onlyOwner\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        adminContracts[_address] = 1;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove the contract address as a super user role\n', '     * have it here just in case\n', '     * @param _address A contract address\n', '     */\n', '    function removeContractAddress(address _address)\n', '        public\n', '        onlyOwner\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        adminContracts[_address] = 0;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev check contract eligibility\n', '     * @param _address A contract address\n', '     */\n', '    function isSuperContract(address _address)\n', '        public\n', '        view\n', '        returns (bool) {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (adminContracts[_address] == 1) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Contract that will work with ERC223 tokens.\n', ' */\n', 'contract ERC223ReceivingContract { \n', '/**\n', ' * @dev Standard ERC223 function that will handle incoming token transfers.\n', ' *\n', ' * @param _from  Token sender address.\n', ' * @param _value Amount of tokens.\n', ' * @param _data  Transaction metadata.\n', ' */\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', '/**\n', ' * @title EvilMortyTokenInterface\n', ' */\n', 'contract EvilMortyTokenInterface {\n', '\n', '    /**\n', '     * @dev Check balance of a given address\n', '     * @param sender address\n', '     */\n', '    function balanceOf(address sender) public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Birdman\n', ' */\n', 'contract Birdman is AdminUtils, ERC223ReceivingContract {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event MCApplied(address sender);\n', '    event MCAdded(address sender);\n', '    event MCRemoved(address sender);\n', '    event ShareSent(address indexed receiver, uint256 value);\n', '    event SystemChangeValidMCAmount(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeMaxNumMC(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeShareTimeGap(uint256 oldValue, uint256 newValue);\n', '    event SystemChangeVettingTime(uint256 oldValue, uint256 newValue);\n', '\n', '    EvilMortyTokenInterface internal EvilMortyInstance;\n', '\n', '    uint256 public validMCAmount = 5000000e18;\n', '    uint256 public maxNumMC = 20;\n', '    uint256 public vettingTime = 86400; // in block height, roughly 15 days\n', '    uint256 public shareTimeGap = 86400; // in block height, roughly 15 days\n', '    uint256 public numMC;\n', '    uint256 public numMCApplied;\n', '    uint256 public nextShareTime = 6213990; // around UTC 01:00, 8/26/2018\n', '    uint256 public weiAmountShare;\n', '\n', '    mapping (uint256 => MC) constructors;\n', '    mapping (address => uint256) addressToIndex;\n', '\n', '    struct MC {\n', '      address playerAddress;\n', '      uint256 timeSince;\n', '      uint256 nextSharedSentTime;\n', '      bool passed;\n', '    }\n', '    \n', '    uint256[] emptyIndexes;\n', '\n', '    modifier isValidMC() {\n', '        require (EvilMortyInstance.balanceOf(msg.sender) >= validMCAmount);\n', '        _;\n', '    }\n', '\n', '    modifier canAddMC() {\n', '      require (numMCApplied < maxNumMC);\n', '      // make sure no one cheats\n', '      require (addressToIndex[msg.sender] == 0);\n', '      \n', '      _; \n', '    }\n', '\n', '    modifier isEvilMortyToken() {\n', '        require(msg.sender == address(EvilMortyInstance));\n', '        _;\n', '    }\n', '\n', '    /* constructor */\n', '    constructor(address EvilMortyAddress)\n', '        public {\n', '        EvilMortyInstance = EvilMortyTokenInterface(EvilMortyAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Allow funds to be sent to this contract\n', '     * if the sender is the owner or a super contract\n', '     * then it will do nothing\n', '     */\n', '    function ()\n', '        public\n', '        payable {\n', '        if (msg.sender == owner || isSuperContract(msg.sender)) {\n', '            return;\n', '        }\n', '        applyMC();\n', '    }\n', '\n', '    /**\n', '     * @dev Allow morty token to be sent to this contract\n', '     * if the sender is the owner it will do nothing\n', '     */\n', '    function tokenFallback(address _from, uint256 _value, bytes)\n', '        public\n', '        isEvilMortyToken {\n', '        if (_from == owner) {\n', '            return;\n', '        }\n', '        claimShare(addressToIndex[_from]);\n', '    }\n', '\n', '    /**\n', '     * @dev Apply for becoming a MC\n', '     */\n', '    function applyMC()\n', '        public\n', '        payable\n', '        canAddMC {\n', '\n', '        require (EvilMortyInstance.balanceOf(msg.sender) >= validMCAmount);\n', '\n', '        numMCApplied = numMCApplied.add(1);\n', '        uint256 newIndex = numMCApplied;\n', '\n', '        if (emptyIndexes.length > 0) {\n', '            newIndex = emptyIndexes[emptyIndexes.length-1];\n', '            delete emptyIndexes[emptyIndexes.length-1];\n', '            emptyIndexes.length--;\n', '        }\n', '\n', '        constructors[newIndex] = MC({\n', '            playerAddress: msg.sender,\n', '            timeSince: block.number.add(vettingTime),\n', '            nextSharedSentTime: nextShareTime,\n', '            passed: false\n', '        });\n', '\n', '        addressToIndex[msg.sender] = newIndex;\n', '\n', '        emit MCApplied(msg.sender);\n', '    }\n', '\n', '    /**\n', "     * @dev Get a MC's info given index\n", "     * @param _index the MC's index\n", '     */\n', '    function getMC(uint256 _index)\n', '        public\n', '        view\n', '        returns (address, uint256, uint256, bool) {\n', '        MC storage mc = constructors[_index];\n', '        return (\n', '            mc.playerAddress,\n', '            mc.timeSince,\n', '            mc.nextSharedSentTime,\n', '            mc.passed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Get number of empty indexes\n', '     */\n', '    function numEmptyIndexes()\n', '        public\n', '        view\n', '        returns (uint256) {\n', '        return emptyIndexes.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the MC index given address\n', "     * @param _address MC's address\n", '     */\n', '    function getIndex(address _address)\n', '        public\n', '        view\n', '        returns (uint256) {\n', '        return addressToIndex[_address];\n', '    }\n', '\n', '    /**\n', "     * @dev Update all MC's status\n", '     */\n', '    function updateMCs()\n', '        public {\n', '\n', '        if (numMCApplied == 0) {\n', '            return;\n', '        }\n', '\n', '        for (uint256 i = 0; i < maxNumMC; i ++) {\n', '            updateMC(i);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Update a MC's status, if\n", "     * - the MC's balance is below min requirement, it will be deleted;\n", "     * - the MC's vetting time is passed, it will be added\n", "     * @param _index the MC's index\n", '     */\n', '    function updateMC(uint256 _index)\n', '        public {\n', '        MC storage mc = constructors[_index];\n', '\n', '        // skip empty index\n', '        if (mc.playerAddress == 0) {\n', '            return;\n', '        }\n', '\n', '        if (EvilMortyInstance.balanceOf(mc.playerAddress) < validMCAmount) {\n', '            // remove MC\n', '            numMCApplied = numMCApplied.sub(1);\n', '            if (mc.passed == true) {\n', '                numMC = numMC.sub(1);\n', '            }\n', '            emptyIndexes.push(_index);\n', '            emit MCRemoved(mc.playerAddress);\n', '            delete addressToIndex[mc.playerAddress];\n', '            delete constructors[_index];\n', '            return;\n', '        }\n', '\n', '        if (mc.passed == false && mc.timeSince < block.number) {\n', '             mc.passed = true;\n', '             numMC = numMC.add(1);\n', '             emit MCAdded(mc.playerAddress);\n', '             return;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update funds to be sent in this shares period\n', '     */\n', '    function updateWeiAmountShare()\n', '        public {\n', '        if (numMC == 0) {\n', '            return;\n', '        }\n', '        if (nextShareTime < block.number) {\n', '            weiAmountShare = address(this).balance.div(numMC);\n', '\n', '            // make height accurate\n', '            uint256 timeGap = block.number.sub(nextShareTime);\n', '            uint256 gap = timeGap.div(shareTimeGap).add(1);\n', '            nextShareTime = nextShareTime.add(shareTimeGap.mul(gap));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Ask for funds for a MC\n', "     * @param _index the Mc's index\n", '     */\n', '    function claimShare(uint256 _index)\n', '        public {\n', '\n', '        // need update all MCs first\n', '        updateMCs();\n', '\n', '        MC storage mc = constructors[_index];\n', '\n', '        // skip empty index\n', '        if (mc.playerAddress == 0) {\n', '            return;\n', '        }\n', '\n', '        if (mc.passed == false) {\n', '            return;\n', '        }\n', '\n', '        if (mc.nextSharedSentTime < block.number) {\n', '            // update next share time\n', '            updateWeiAmountShare();\n', '            mc.nextSharedSentTime = nextShareTime;\n', '            // every mc gets equal share\n', '            mc.playerAddress.transfer(weiAmountShare);\n', '            emit ShareSent(mc.playerAddress, weiAmountShare);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade evil morty\n', '     * in case of upgrade needed\n', '     */\n', '    function upgradeEvilMorty(address _address)\n', '        external\n', '        onlyOwner {\n', '\n', '        uint256 codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\n', '        if (codeLength == 0) {\n', '            return;\n', '        }\n', '\n', '        EvilMortyInstance = EvilMortyTokenInterface(_address);\n', '    }\n', '\n', '    /**\n', '     * @dev Update min requirement for being a MC\n', '     * a system event is emitted to capture the change\n', '     * @param _amount new amount\n', '     */\n', '    function updateValidMCAmount(uint256 _amount)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeValidMCAmount(validMCAmount, _amount);\n', '        validMCAmount = _amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Update max number of MCs\n', '     * a system event is emitted to capture the change\n', '     */\n', '    function updateMaxNumMC(uint256 _num)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeMaxNumMC(maxNumMC, _num);\n', '        maxNumMC = _num;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the length of a share period\n', '     * a system event is emitted to capture the change\n', '     * @param _height bloch heights\n', '     */\n', '    function updateShareTimeGap(uint256 _height)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeShareTimeGap(shareTimeGap, _height);\n', '        shareTimeGap = _height;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the length of vetting time\n', '     * a system event is emitted to capture the change\n', '     * @param _height bloch heights\n', '     */\n', '    function updateVettingTime(uint256 _height)\n', '        external\n', '        onlyOwner {\n', '        emit SystemChangeVettingTime(vettingTime, _height);\n', '        vettingTime = _height;\n', '    }\n', '}']
