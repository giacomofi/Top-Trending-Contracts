['pragma solidity ^0.4.21;\n', '\n', 'interface insChainTokenInterface{\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf( address who ) public view returns (uint value);\n', '    function allowance( address owner, address spender ) public view returns (uint _allowance);\n', '\n', '    function transfer( address to, uint value) public returns (bool ok);\n', '    function transferFrom( address from, address to, uint value) public returns (bool ok);\n', '    function approve( address spender, uint value ) public returns (bool ok);\n', '\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Owned{\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still need to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '    \n', '    event Pause();\n', '    event Unpause();\n', '    bool public paused = false;\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '/*\n', '    Overflow protected math functions\n', '*/\n', 'contract SafeMath {\n', '    /**\n', '        constructor\n', '    */\n', '    function SafeMath() public{\n', '    }\n', '\n', '       // Check if it is safe to add two numbers\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    // Check if it is safe to subtract two numbers\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a - b;\n', '        assert(b <= a && c <= a);\n', '        return c;\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint c = a * b;\n', '        assert(a == 0 || (c / a) == b);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '// a ledger recording policy participants\n', '// kill() property is limited to the officially-released policies, which must be removed in the later template versions.\n', 'contract PolicyPool is SafeMath, Owned{\n', '\n', '    \n', '    insChainTokenInterface public insChainTokenLedger;\n', '    address public agent;\n', '\n', '    uint256 public policyTokenBalance=0;\n', '    uint256 public policyTokenBalanceFromEther=0;\n', '    //might turn to private in production\n', '    uint256 public policyFeeCollector=0;\n', '    \n', '    uint256 public policyCandyBalance=0;\n', '    \n', '    uint256 public policyActiveNum=0;\n', '\n', '\n', '    mapping (uint256 => uint256) policyInternalID;\n', '\n', '    struct Policy {\n', '        uint256 since;\n', '        uint256 accumulatedIn;\n', '    }\n', '\n', '    // policies[policyInternalID[extraData]]\n', '    Policy[] public policies;\n', '\n', '    struct Proposal {\n', '        uint256 policyPayload;\n', '        address recipient;\n', '        uint256 amount;\n', '        string description;\n', '        bool executed;\n', '        bool proposalPassed;\n', '        // bytes32 proposalHash;\n', '    }\n', '    \n', '    // struct array to store user claims\n', '    Proposal[] public proposals;\n', '    uint256 public numProposals;\n', '    \n', '    uint256 public updated_policy_payload;\n', '\n', '    event PolicyIn(address indexed backer, uint256 indexed amount, uint256 indexed policyExternalID);\n', '\n', '    event PolicyOut(address indexed backer, uint256 indexed amount, uint256 indexed policyExternalID);\n', '\n', '    event PolicyValueIn(address indexed backer, uint256 indexed amount,uint256 indexed policyExternalID);\n', '\n', '\n', '    // event log for user claims(admin)\n', '    event ProposalAdded(uint indexed proposalID, uint256 indexed policyExternalID, uint256 indexed amount, string description);\n', '    event ProposalTallied(uint indexed proposalId, uint256 indexed amount, bool indexed proposalPassed);\n', '\n', '    // external agent for candy policies\n', '    modifier onlyAgent {\n', '        assert(msg.sender == agent);\n', '        _;\n', '    }\n', '    \n', '    function PolicyPool(address tokenLedger) public {\n', '        insChainTokenLedger=insChainTokenInterface(tokenLedger);\n', '        // temp agent only, will be changed to the contract later\n', '        agent=msg.sender;\n', '        addPolicy(0,0);\n', '    }\n', '\n', '    //user must perform the following opertions before calling this function\n', '    //approveAndCall() to activate the policy account in this policy contract\n', '    //this function works as a policy registering and deposit handler\n', '\n', '   function receiveApproval(address from,uint256 weiAmount,address tokenLedger, bytes extraData) whenNotPaused public returns (bool success){\n', '\n', '        require(insChainTokenInterface(tokenLedger)==insChainTokenLedger);\n', '\n', '\n', '        require(insChainTokenLedger.transferFrom(from, this, weiAmount));\n', '        \n', '        //convert msg.data bytes to uint\n', '        uint payload=0;\n', '        \n', '        for (uint i = 0; i < 32; i++) {\n', '            uint b = uint(msg.data[131 - i]);\n', '            payload += b * 256**i;\n', '        }\n', '        updated_policy_payload = payload;\n', '        \n', '        if(!getx2Policy(from, payload, now, weiAmount)){revert();}\n', '        policyTokenBalance=safeAdd(policyTokenBalance,weiAmount);\n', '\n', '        return true;\n', '    }\n', '    \n', '    function policyID(uint256 payload) public view returns (uint id){\n', '        return policyInternalID[payload];\n', '    }\n', '    \n', '\n', '    function accumulatedBalanceOf(uint id) public view returns (uint256 balance) {\n', '        return policies[id].accumulatedIn;\n', '    }\n', '    \n', '    function joinSinceOf(uint id) public view returns (uint256 balance) {\n', '        return policies[id].since;\n', '    }\n', '\n', '\n', '    function addPolicy(uint256 ticker, uint256 weiAmount) internal returns(uint) {\n', '        policies.length++;\n', '        policies[policies.length-1].since = ticker;\n', '        policies[policies.length-1].accumulatedIn = weiAmount;\n', '        return policies.length;\n', '    }\n', '    \n', '    function getx2Policy(address from, uint256 payload, uint256 timeStamp, uint256 weiAmount) internal returns(bool success){\n', '        uint id = policyInternalID[payload];\n', '  \n', '        if (id == 0) {\n', '            id = policies.length;\n', '            policyInternalID[payload] = id;\n', '            addPolicy(timeStamp,weiAmount);\n', '            emit PolicyIn(from, weiAmount, payload);\n', '            policyActiveNum++;\n', '        }else if (policies[id].accumulatedIn==0){\n', '\n', '            policies[id].since=timeStamp;\n', '            policies[id].accumulatedIn=weiAmount;\n', '            emit PolicyIn(from, weiAmount, payload);\n', '            policyActiveNum++;\n', '\n', '        }else{\n', '\n', '            policies[id].accumulatedIn=safeAdd(policies[id].accumulatedIn,weiAmount);\n', '            emit PolicyValueIn(from, weiAmount, payload);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //the policy balance ledger will be updated either\n', '    // onlyOwner might be changed to onlyManager later\n', '    function withdrawPolicy(uint256 payload, uint256 weiAmount, uint256 fees, address to) public onlyOwner returns (bool success) {\n', '\n', '        uint id=policyInternalID[payload];\n', '        require(id>0);\n', '        require(policies[id].accumulatedIn>0);\n', '        require(policies[id].since<now);\n', '        require(weiAmount<policyTokenBalance);\n', '\n', '        if(!insChainTokenLedger.transfer(to,weiAmount)){revert();}\n', '        policyTokenBalance=safeSub(policyTokenBalance,weiAmount);\n', '        policyTokenBalance=safeSub(policyTokenBalance,fees);\n', '        policyFeeCollector=safeAdd(policyFeeCollector,fees);\n', '\n', '\n', '        policies[id].accumulatedIn=0;\n', '        policies[id].since=now;\n', '\n', '        emit PolicyOut(to, weiAmount, payload);\n', '        policyActiveNum--;\n', '        return true;\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        if(policyTokenBalance>0){\n', '            if(!insChainTokenLedger.transfer(owner,policyTokenBalance)){revert();}\n', '            policyTokenBalance=0;\n', '            policyTokenBalanceFromEther=0;\n', '        }\n', '        if(policyFeeCollector>0){\n', '            if(!insChainTokenLedger.transfer(owner,policyFeeCollector)){revert();}\n', '            policyFeeCollector=0;\n', '        }\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     * Add Proposal\n', '     *\n', '     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `ClaimDescription`. `transactionBytecode ? Contains : Does not contain` code.\n', '     *\n', '     * param payload the policy id\n', '     * param beneficiary who to send the ether to\n', '     * param weiAmount amount of token to send, in wei(18 decimals)\n', '     * param claimDescription Description of claim\n', '     */\n', '    function newProposal(uint256 payload, address beneficiary, uint256 weiAmount,string claimDescription) onlyOwner public returns(uint256 proposalID){\n', '\n', '        require(policyTokenBalance>weiAmount);\n', '\n', '        proposals.length++;\n', '        proposalID = proposals.length-1;\n', '        Proposal storage p = proposals[proposalID];\n', '        p.policyPayload=payload;\n', '        p.recipient = beneficiary;\n', '        p.amount = weiAmount;\n', '        p.description = claimDescription;\n', '        p.executed = false;\n', '        p.proposalPassed = false;\n', '        emit ProposalAdded(proposalID, p.policyPayload, p.amount, p.description);\n', '        numProposals = proposalID+1;\n', '\n', '        return proposalID;\n', '    }\n', '\n', '    /**\n', '     *\n', '     * param proposalNumber proposal number\n', '     * param refundAmount the money should pay back\n', '     * param fees to be paid by claimer\n', '     */\n', '    function executeProposal(uint proposalNumber, uint256 refundAmount, uint256 fees) onlyOwner public returns (bool success){\n', '        Proposal storage p = proposals[proposalNumber];\n', '\n', '        require(!p.executed);                               //it has not already been executed\n', '        require(p.amount>=refundAmount);                  \n', '\n', '        // ...then execute result\n', '        \n', '        uint256 totalReduce = safeAdd(refundAmount,fees);\n', '        if ( totalReduce<=policyTokenBalance ) {\n', '            // Proposal passed; execute the transaction\n', '\n', '            p.executed = true; // Avoid recursive calling\n', '\n', '            \n', '            policyTokenBalance=safeSub(policyTokenBalance,totalReduce);\n', '            policyFeeCollector=safeAdd(policyFeeCollector,fees);\n', '            // refund the GETX\n', '            if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();}\n', '            // clear the data inside\n', '            uint id = policyInternalID[p.policyPayload];\n', '            policies[id].accumulatedIn=0;\n', '            policies[id].since=now;\n', '            p.proposalPassed = true;\n', '\n', '            emit ProposalTallied(proposalNumber, refundAmount, p.proposalPassed);\n', '\n', '            emit PolicyOut(p.recipient, refundAmount, p.policyPayload);\n', '            policyActiveNum--;\n', '\n', '            \n', '        } else {\n', '            // Proposal failed\n', '            p.proposalPassed = false;\n', '        }\n', '\n', '        return p.proposalPassed;\n', '    }\n', '    \n', '    // This function is controlled by agent\n', '    function joinWithCandy(address signer, uint256 payload, uint256 timeStamp) onlyAgent public returns (bool success){\n', '        require(signer!=address(0));\n', '        require(timeStamp<now);\n', '        require(policyInternalID[payload] == 0);\n', '        \n', '        if(!getx2Policy(signer, payload, timeStamp, 0)){revert();}\n', '        return true;\n', '    }\n', '    \n', '    function updateAgent(address newAgent) onlyOwner public returns(bool success){\n', '        agent=newAgent;\n', '        return true;\n', '    }\n', '\n', '    // admin function to transfer in the GETX according to the rate\n', '    // the admin should transfer "policyTokenBalanceFromEther" to this pool later\n', '    function settleEtherPolicy(address[] froms, uint256[] payloads, uint256[] timeStamps, uint256[] weiAmounts) onlyOwner public returns(bool success){\n', '        require(froms.length == payloads.length);\n', '        require(payloads.length == weiAmounts.length);\n', '        uint i;\n', '\n', '        for (i=0;i<froms.length;i++){\n', '            if(!getx2Policy(froms[i], payloads[i], timeStamps[i], weiAmounts[i])){revert();}\n', '            // this GETX value must be the same as the ether collector account\n', '            policyTokenBalanceFromEther=safeAdd(policyTokenBalanceFromEther,weiAmounts[i]);\n', '            policyTokenBalance=safeAdd(policyTokenBalance,weiAmounts[i]);\n', '            if(!insChainTokenLedger.transferFrom(msg.sender, this, weiAmounts[i])){revert();}\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function settleCandyGetx(uint256 weiAmount) onlyOwner public returns (bool success){\n', '        policyCandyBalance=safeAdd(policyCandyBalance,weiAmount);\n', '        return true;\n', '    }\n', '\n', '    function retrievePoolFee(uint256 weiAmount) onlyOwner public returns (bool success){\n', '        policyFeeCollector=safeSub(policyFeeCollector,weiAmount);\n', '        if(!insChainTokenLedger.transfer(msg.sender,weiAmount)){revert();}\n', '        return true;\n', '    }\n', '    \n', '    function claimTokens(address _token) onlyOwner public {\n', '        require(_token != address(0));\n', '        require(_token != address(insChainTokenLedger));\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(owner, balance);\n', '    }\n', '    \n', '}']