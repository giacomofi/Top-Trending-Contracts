['pragma solidity ^0.4.24;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Sender is not the owner");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _to Address of the new owner\n', '    */\n', '    function transferTo(address _to) public onlyOwner returns (bool) {\n', '        require(_to != address(0), "Can&#39;t transfer to 0x0");\n', '        owner = _to;\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    @dev Defines the interface of a standard RCN oracle.\n', '\n', '    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n', '    it&#39;s primarily used by the exchange but could be used by any other agent.\n', '*/\n', 'contract Oracle is Ownable {\n', '    uint256 public constant VERSION = 4;\n', '\n', '    event NewSymbol(bytes32 _currency);\n', '\n', '    mapping(bytes32 => bool) public supported;\n', '    bytes32[] public currencies;\n', '\n', '    /**\n', '        @dev Returns the url where the oracle exposes a valid "oracleData" if needed\n', '    */\n', '    function url() public view returns (string);\n', '\n', '    /**\n', '        @dev Returns a valid convertion rate from the currency given to RCN\n', '\n', '        @param symbol Symbol of the currency\n', '        @param data Generic data field, could be used for off-chain signing\n', '    */\n', '    function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);\n', '\n', '    /**\n', '        @dev Adds a currency to the oracle, once added it cannot be removed\n', '\n', '        @param ticker Symbol of the currency\n', '\n', '        @return if the creation was done successfully\n', '    */\n', '    function addCurrency(string ticker) public onlyOwner returns (bool) {\n', '        bytes32 currency = encodeCurrency(ticker);\n', '        NewSymbol(currency);\n', '        supported[currency] = true;\n', '        currencies.push(currency);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @return the currency encoded as a bytes32\n', '    */\n', '    function encodeCurrency(string currency) public pure returns (bytes32 o) {\n', '        require(bytes(currency).length <= 32);\n', '        assembly {\n', '            o := mload(add(currency, 32))\n', '        }\n', '    }\n', '    \n', '    /**\n', '        @return the currency string from a encoded bytes32\n', '    */\n', '    function decodeCurrency(bytes32 b) public pure returns (string o) {\n', '        uint256 ns = 256;\n', '        while (true) { if (ns == 0 || (b<<ns-8) != 0) break; ns -= 8; }\n', '        assembly {\n', '            ns := div(ns, 8)\n', '            o := mload(0x40)\n', '            mstore(0x40, add(o, and(add(add(ns, 0x20), 0x1f), not(0x1f))))\n', '            mstore(o, ns)\n', '            mstore(add(o, 32), b)\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'contract Engine {\n', '    uint256 public VERSION;\n', '    string public VERSION_NAME;\n', '\n', '    enum Status { initial, lent, paid, destroyed }\n', '    struct Approbation {\n', '        bool approved;\n', '        bytes data;\n', '        bytes32 checksum;\n', '    }\n', '\n', '    function getTotalLoans() public view returns (uint256);\n', '    function getOracle(uint index) public view returns (Oracle);\n', '    function getBorrower(uint index) public view returns (address);\n', '    function getCosigner(uint index) public view returns (address);\n', '    function ownerOf(uint256) public view returns (address owner);\n', '    function getCreator(uint index) public view returns (address);\n', '    function getAmount(uint index) public view returns (uint256);\n', '    function getPaid(uint index) public view returns (uint256);\n', '    function getDueTime(uint index) public view returns (uint256);\n', '    function getApprobation(uint index, address _address) public view returns (bool);\n', '    function getStatus(uint index) public view returns (Status);\n', '    function isApproved(uint index) public view returns (bool);\n', '    function getPendingAmount(uint index) public returns (uint256);\n', '    function getCurrency(uint index) public view returns (bytes32);\n', '    function cosign(uint index, uint256 cost) external returns (bool);\n', '    function approveLoan(uint index) public returns (bool);\n', '    function transfer(address to, uint256 index) public returns (bool);\n', '    function takeOwnership(uint256 index) public returns (bool);\n', '    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n', '    function identifierToIndex(bytes32 signature) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', '    @dev Defines the interface of a standard RCN cosigner.\n', '\n', '    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n', '    of the insurance and the cost of the given are defined by the cosigner. \n', '\n', '    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n', '    agent should be passed as params when the lender calls the "lend" method on the engine.\n', '    \n', '    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n', '    should be able to call the "claim" method to receive the benefit; the cosigner can define aditional requirements to\n', '    call this method, like the transfer of the ownership of the loan.\n', '*/\n', 'contract Cosigner {\n', '    uint256 public constant VERSION = 2;\n', '    \n', '    /**\n', '        @return the url of the endpoint that exposes the insurance offers.\n', '    */\n', '    function url() external view returns (string);\n', '    \n', '    /**\n', '        @dev Retrieves the cost of a given insurance, this amount should be exact.\n', '\n', '        @return the cost of the cosign, in RCN wei\n', '    */\n', '    function cost(address engine, uint256 index, bytes data, bytes oracleData) external view returns (uint256);\n', '    \n', '    /**\n', '        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n', '        the insurance it must call the method "cosign" of the engine. If the cosigner does not call that method, or\n', '        does not return true to this method, the operation fails.\n', '\n', '        @return true if the cosigner accepts the liability\n', '    */\n', '    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n', '    \n', '    /**\n', '        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n', '        current lender of the loan.\n', '\n', '        @return true if the claim was done correctly.\n', '    */\n', '    function claim(address engine, uint256 index, bytes oracleData) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        require((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        require(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function mult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        require((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', 'contract SafeWithdraw is Ownable {\n', '    /**\n', '        @dev Withdraws tokens from the contract.\n', '\n', '        @param token Token to withdraw\n', '        @param to Destination of the tokens\n', '        @param amountOrId Amount/ID to withdraw \n', '    */\n', '    function withdrawTokens(Token token, address to, uint256 amountOrId) external onlyOwner returns (bool) {\n', '        require(to != address(0));\n', '        return token.transfer(to, amountOrId);\n', '    }\n', '}\n', '\n', 'contract BytesUtils {\n', '    function readBytes32(bytes data, uint256 index) internal pure returns (bytes32 o) {\n', '        require(data.length / 32 > index);\n', '        assembly {\n', '            o := mload(add(data, add(32, mul(32, index))))\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenConverter {\n', '    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n', '    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\n', '    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\n', '}\n', '\n', '\n', '\n', 'interface IERC721Receiver {\n', '    function onERC721Received(\n', '        address _oldOwner,\n', '        uint256 _tokenId,\n', '        bytes   _userData\n', '    ) external returns (bytes4);\n', '}\n', '\n', 'contract ERC721Base {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private _count;\n', '\n', '    mapping(uint256 => address) private _holderOf;\n', '    mapping(address => uint256[]) private _assetsOf;\n', '    mapping(address => mapping(address => bool)) private _operators;\n', '    mapping(uint256 => address) private _approval;\n', '    mapping(uint256 => uint256) private _indexOfAsset;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    //\n', '    // Global Getters\n', '    //\n', '\n', '    /**\n', '     * @dev Gets the total amount of assets stored by the contract\n', '     * @return uint256 representing the total amount of assets\n', '     */\n', '    function totalSupply() external view returns (uint256) {\n', '        return _totalSupply();\n', '    }\n', '    function _totalSupply() internal view returns (uint256) {\n', '        return _count;\n', '    }\n', '\n', '    //\n', '    // Asset-centric getter functions\n', '    //\n', '\n', '    /**\n', '     * @dev Queries what address owns an asset. This method does not throw.\n', '     * In order to check if the asset exists, use the `exists` function or check if the\n', '     * return value of this call is `0`.\n', '     * @return uint256 the assetId\n', '     */\n', '    function ownerOf(uint256 assetId) external view returns (address) {\n', '        return _ownerOf(assetId);\n', '    }\n', '    function _ownerOf(uint256 assetId) internal view returns (address) {\n', '        return _holderOf[assetId];\n', '    }\n', '\n', '    //\n', '    // Holder-centric getter functions\n', '    //\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256) {\n', '        return _balanceOf(owner);\n', '    }\n', '    function _balanceOf(address owner) internal view returns (uint256) {\n', '        return _assetsOf[owner].length;\n', '    }\n', '\n', '    //\n', '    // Authorization getters\n', '    //\n', '\n', '    /**\n', '     * @dev Query whether an address has been authorized to move any assets on behalf of someone else\n', '     * @param operator the address that might be authorized\n', '     * @param assetHolder the address that provided the authorization\n', '     * @return bool true if the operator has been authorized to move any assets\n', '     */\n', '    function isApprovedForAll(address operator, address assetHolder)\n', '        external view returns (bool)\n', '    {\n', '        return _isApprovedForAll(operator, assetHolder);\n', '    }\n', '    function _isApprovedForAll(address operator, address assetHolder)\n', '        internal view returns (bool)\n', '    {\n', '        return _operators[assetHolder][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Query what address has been particularly authorized to move an asset\n', '     * @param assetId the asset to be queried for\n', '     * @return bool true if the asset has been approved by the holder\n', '     */\n', '    function getApprovedAddress(uint256 assetId) external view returns (address) {\n', '        return _getApprovedAddress(assetId);\n', '    }\n', '    function _getApprovedAddress(uint256 assetId) internal view returns (address) {\n', '        return _approval[assetId];\n', '    }\n', '\n', '    /**\n', '     * @dev Query if an operator can move an asset.\n', '     * @param operator the address that might be authorized\n', '     * @param assetId the asset that has been `approved` for transfer\n', '     * @return bool true if the asset has been approved by the holder\n', '     */\n', '    function isAuthorized(address operator, uint256 assetId) external view returns (bool) {\n', '        return _isAuthorized(operator, assetId);\n', '    }\n', '    function _isAuthorized(address operator, uint256 assetId) internal view returns (bool)\n', '    {\n', '        require(operator != 0, "Operator can&#39;t be 0");\n', '        address owner = _ownerOf(assetId);\n', '        if (operator == owner) {\n', '            return true;\n', '        }\n', '        return _isApprovedForAll(operator, owner) || _getApprovedAddress(assetId) == operator;\n', '    }\n', '\n', '    //\n', '    // Authorization\n', '    //\n', '\n', '    /**\n', '     * @dev Authorize a third party operator to manage (send) msg.sender&#39;s asset\n', '     * @param operator address to be approved\n', '     * @param authorized bool set to true to authorize, false to withdraw authorization\n', '     */\n', '    function setApprovalForAll(address operator, bool authorized) external {\n', '        return _setApprovalForAll(operator, authorized);\n', '    }\n', '    function _setApprovalForAll(address operator, bool authorized) internal {\n', '        if (authorized) {\n', '            _addAuthorization(operator, msg.sender);\n', '        } else {\n', '            _clearAuthorization(operator, msg.sender);\n', '        }\n', '        emit ApprovalForAll(operator, msg.sender, authorized);\n', '    }\n', '\n', '    /**\n', '     * @dev Authorize a third party operator to manage one particular asset\n', '     * @param operator address to be approved\n', '     * @param assetId asset to approve\n', '     */\n', '    function approve(address operator, uint256 assetId) external {\n', '        address holder = _ownerOf(assetId);\n', '        require(msg.sender == holder || _isApprovedForAll(msg.sender, holder));\n', '        require(operator != holder);\n', '        if (_getApprovedAddress(assetId) != operator) {\n', '            _approval[assetId] = operator;\n', '            emit Approval(holder, operator, assetId);\n', '        }\n', '    }\n', '\n', '    function _addAuthorization(address operator, address holder) private {\n', '        _operators[holder][operator] = true;\n', '    }\n', '\n', '    function _clearAuthorization(address operator, address holder) private {\n', '        _operators[holder][operator] = false;\n', '    }\n', '\n', '    //\n', '    // Internal Operations\n', '    //\n', '\n', '    function _addAssetTo(address to, uint256 assetId) internal {\n', '        _holderOf[assetId] = to;\n', '\n', '        uint256 length = _balanceOf(to);\n', '\n', '        _assetsOf[to].push(assetId);\n', '\n', '        _indexOfAsset[assetId] = length;\n', '\n', '        _count = _count.add(1);\n', '    }\n', '\n', '    function _removeAssetFrom(address from, uint256 assetId) internal {\n', '        uint256 assetIndex = _indexOfAsset[assetId];\n', '        uint256 lastAssetIndex = _balanceOf(from).sub(1);\n', '        uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\n', '\n', '        _holderOf[assetId] = 0;\n', '\n', '        // Insert the last asset into the position previously occupied by the asset to be removed\n', '        _assetsOf[from][assetIndex] = lastAssetId;\n', '\n', '        // Resize the array\n', '        _assetsOf[from][lastAssetIndex] = 0;\n', '        _assetsOf[from].length--;\n', '\n', '        // Remove the array if no more assets are owned to prevent pollution\n', '        if (_assetsOf[from].length == 0) {\n', '            delete _assetsOf[from];\n', '        }\n', '\n', '        // Update the index of positions for the asset\n', '        _indexOfAsset[assetId] = 0;\n', '        _indexOfAsset[lastAssetId] = assetIndex;\n', '\n', '        _count = _count.sub(1);\n', '    }\n', '\n', '    function _clearApproval(address holder, uint256 assetId) internal {\n', '        if (_ownerOf(assetId) == holder && _approval[assetId] != 0) {\n', '            _approval[assetId] = 0;\n', '            emit Approval(holder, 0, assetId);\n', '        }\n', '    }\n', '\n', '    //\n', '    // Supply-altering functions\n', '    //\n', '\n', '    function _generate(uint256 assetId, address beneficiary) internal {\n', '        require(_holderOf[assetId] == 0);\n', '\n', '        _addAssetTo(beneficiary, assetId);\n', '\n', '        emit Transfer(0x0, beneficiary, assetId);\n', '    }\n', '\n', '    function _destroy(uint256 assetId) internal {\n', '        address holder = _holderOf[assetId];\n', '        require(holder != 0);\n', '\n', '        _removeAssetFrom(holder, assetId);\n', '\n', '        emit Transfer(holder, 0x0, assetId);\n', '    }\n', '\n', '    //\n', '    // Transaction related operations\n', '    //\n', '\n', '    modifier onlyHolder(uint256 assetId) {\n', '        require(_ownerOf(assetId) == msg.sender, "Not holder");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized(uint256 assetId) {\n', '        require(_isAuthorized(msg.sender, assetId), "Not authorized");\n', '        _;\n', '    }\n', '\n', '    modifier isCurrentOwner(address from, uint256 assetId) {\n', '        require(_ownerOf(assetId) == from, "Not current owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Alias of `safeTransferFrom(from, to, assetId, &#39;&#39;)`\n', '     *\n', '     * @param from address that currently owns an asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 assetId) external {\n', '        return _doTransferFrom(from, to, assetId, "", true);\n', '    }\n', '\n', '    /**\n', '     * @dev Securely transfers the ownership of a given asset from one address to\n', '     * another address, calling the method `onNFTReceived` on the target address if\n', '     * there&#39;s code associated with it\n', '     *\n', '     * @param from address that currently owns an asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     * @param userData bytes arbitrary user information to attach to this transfer\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external {\n', '        return _doTransferFrom(from, to, assetId, userData, true);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given asset from one address to another address\n', '     * Warning! This function does not attempt to verify that the target address can send\n', '     * tokens.\n', '     *\n', '     * @param from address sending the asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 assetId) external {\n', '        return _doTransferFrom(from, to, assetId, "", false);\n', '    }\n', '\n', '    function _doTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 assetId,\n', '        bytes userData,\n', '        bool doCheck\n', '    )\n', '        onlyAuthorized(assetId)\n', '        internal\n', '    {\n', '        _moveToken(from, to, assetId, userData, doCheck);\n', '    }\n', '\n', '    function _moveToken(\n', '        address from,\n', '        address to,\n', '        uint256 assetId,\n', '        bytes userData,\n', '        bool doCheck\n', '    )\n', '        isCurrentOwner(from, assetId)\n', '        internal\n', '    {\n', '        address holder = _holderOf[assetId];\n', '        _removeAssetFrom(holder, assetId);\n', '        _clearApproval(holder, assetId);\n', '        _addAssetTo(to, assetId);\n', '\n', '        if (doCheck && _isContract(to)) {\n', '            // Equals to bytes4(keccak256("onERC721Received(address,uint256,bytes)"))\n', '            bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);\n', '            require(\n', '                IERC721Receiver(to).onERC721Received(\n', '                    holder, assetId, userData\n', '                ) == ERC721_RECEIVED\n', '            , "Contract onERC721Received failed");\n', '        }\n', '\n', '        emit Transfer(holder, to, assetId);\n', '    }\n', '\n', '    /**\n', '     * Internal function that moves an asset from one holder to another\n', '     */\n', '\n', '    /**\n', '     * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\n', '     * @param    _interfaceID The interface identifier, as specified in ERC-165\n', '     */\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '\n', '        if (_interfaceID == 0xffffffff) {\n', '            return false;\n', '        }\n', '        return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x80ac58cd;\n', '    }\n', '\n', '    //\n', '    // Utilities\n', '    //\n', '\n', '    function _isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', 'contract LandMarket {\n', '    struct Auction {\n', '        // Auction ID\n', '        bytes32 id;\n', '        // Owner of the NFT\n', '        address seller;\n', '        // Price (in wei) for the published item\n', '        uint256 price;\n', '        // Time when this sale ends\n', '        uint256 expiresAt;\n', '    }\n', '\n', '    mapping (uint256 => Auction) public auctionByAssetId;\n', '    function executeOrder(uint256 assetId, uint256 price) public;\n', '}\n', '\n', 'contract Land {\n', '    function updateLandData(int x, int y, string data) public;\n', '    function decodeTokenId(uint value) view public returns (int, int);\n', '    function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '    function ownerOf(uint256 landID) public view returns (address);\n', '}\n', '\n', '/**\n', '    @notice The contract is used to handle all the lifetime of a mortgage, uses RCN for the Loan and Decentraland for the parcels. \n', '\n', '    Implements the Cosigner interface of RCN, and when is tied to a loan it creates a new ERC721 to handle the ownership of the mortgage.\n', '\n', '    When the loan is resolved (paid, pardoned or defaulted), the mortgaged parcel can be recovered. \n', '\n', '    Uses a token converter to buy the Decentraland parcel with MANA using the RCN tokens received.\n', '*/\n', 'contract MortgageManager is Cosigner, ERC721Base, SafeWithdraw, BytesUtils {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal RCN_DECIMALS = 18;\n', '\n', '    bytes32 public constant MANA_CURRENCY = 0x4d414e4100000000000000000000000000000000000000000000000000000000;\n', '    uint256 public constant REQUIRED_ALLOWANCE = 1000000000 * 10**18;\n', '\n', '    function name() public pure returns (string _name) {\n', '        _name = "Decentraland RCN Mortgage";\n', '    }\n', '\n', '    function symbol() public pure returns (string _symbol) {\n', '        _symbol = "LAND-RCN-Mortgage";\n', '    }\n', '\n', '    event RequestedMortgage(uint256 _id, address _borrower, address _engine, uint256 _loanId, uint256 _landId, uint256 _deposit, address _tokenConverter);\n', '    event StartedMortgage(uint256 _id);\n', '    event CanceledMortgage(address _from, uint256 _id);\n', '    event PaidMortgage(address _from, uint256 _id);\n', '    event DefaultedMortgage(uint256 _id);\n', '    event UpdatedLandData(address _updater, uint256 _parcel, string _data);\n', '    event SetCreator(address _creator, bool _status);\n', '\n', '    Token public rcn;\n', '    Token public mana;\n', '    Land public land;\n', '    LandMarket public landMarket;\n', '    \n', '    constructor(Token _rcn, Token _mana, Land _land, LandMarket _landMarket) public {\n', '        rcn = _rcn;\n', '        mana = _mana;\n', '        land = _land;\n', '        landMarket = _landMarket;\n', '        mortgages.length++;\n', '    }\n', '\n', '    enum Status { Pending, Ongoing, Canceled, Paid, Defaulted }\n', '\n', '    struct Mortgage {\n', '        address owner;\n', '        Engine engine;\n', '        uint256 loanId;\n', '        uint256 deposit;\n', '        uint256 landId;\n', '        uint256 landCost;\n', '        Status status;\n', '        // ERC-721\n', '        TokenConverter tokenConverter;\n', '    }\n', '\n', '    uint256 internal flagReceiveLand;\n', '\n', '    Mortgage[] public mortgages;\n', '\n', '    mapping(address => bool) public creators;\n', '\n', '    mapping(uint256 => uint256) public mortgageByLandId;\n', '    mapping(address => mapping(uint256 => uint256)) public loanToLiability;\n', '\n', '    function url() external view returns (string) {\n', '        return "";\n', '    }\n', '\n', '    /**\n', '        @notice Sets a new third party creator\n', '        \n', '        The third party creator can request loans for other borrowers. The creator should be a trusted contract, it could potentially take funds.\n', '    \n', '        @param creator Address of the creator\n', '        @param authorized Enables or disables the permission\n', '\n', '        @return true If the operation was executed\n', '    */\n', '    function setCreator(address creator, bool authorized) external onlyOwner returns (bool) {\n', '        emit SetCreator(creator, authorized);\n', '        creators[creator] = authorized;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Returns the cost of the cosigner\n', '\n', '        This cosigner does not have any risk or maintenance cost, so its free.\n', '\n', '        @return 0, because it&#39;s free\n', '    */\n', '    function cost(address, uint256, bytes, bytes) external view returns (uint256) {\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '        @notice Requests a mortgage with a loan identifier\n', '\n', '        @dev The loan should exist in the designated engine\n', '\n', '        @param engine RCN Engine\n', '        @param loanIdentifier Identifier of the loan asociated with the mortgage\n', '        @param deposit MANA to cover part of the cost of the parcel\n', '        @param landId ID of the parcel to buy with the mortgage\n', '        @param tokenConverter Token converter used to exchange RCN - MANA\n', '\n', '        @return id The id of the mortgage\n', '    */\n', '    function requestMortgage(\n', '        Engine engine,\n', '        bytes32 loanIdentifier,\n', '        uint256 deposit,\n', '        uint256 landId,\n', '        TokenConverter tokenConverter\n', '    ) external returns (uint256 id) {\n', '        return requestMortgageId(engine, engine.identifierToIndex(loanIdentifier), deposit, landId, tokenConverter);\n', '    }\n', '\n', '    /**\n', '        @notice Request a mortgage with a loan id\n', '\n', '        @dev The loan should exist in the designated engine\n', '\n', '        @param engine RCN Engine\n', '        @param loanId Id of the loan asociated with the mortgage\n', '        @param deposit MANA to cover part of the cost of the parcel\n', '        @param landId ID of the parcel to buy with the mortgage\n', '        @param tokenConverter Token converter used to exchange RCN - MANA\n', '\n', '        @return id The id of the mortgage\n', '    */\n', '    function requestMortgageId(\n', '        Engine engine,\n', '        uint256 loanId,\n', '        uint256 deposit,\n', '        uint256 landId,\n', '        TokenConverter tokenConverter\n', '    ) public returns (uint256 id) {\n', '        // Validate the associated loan\n', '        require(engine.getCurrency(loanId) == MANA_CURRENCY, "Loan currency is not MANA");\n', '        address borrower = engine.getBorrower(loanId);\n', '        require(engine.getStatus(loanId) == Engine.Status.initial, "Loan status is not inital");\n', '        require(msg.sender == engine.getBorrower(loanId) ||\n', '               (msg.sender == engine.getCreator(loanId) && creators[msg.sender]),\n', '            "Creator should be borrower or authorized");\n', '        require(engine.isApproved(loanId), "Loan is not approved");\n', '        require(rcn.allowance(borrower, this) >= REQUIRED_ALLOWANCE, "Manager cannot handle borrower&#39;s funds");\n', '        require(tokenConverter != address(0), "Token converter not defined");\n', '        require(loanToLiability[engine][loanId] == 0, "Liability for loan already exists");\n', '\n', '        // Get the current parcel cost\n', '        uint256 landCost;\n', '        (, , landCost, ) = landMarket.auctionByAssetId(landId);\n', '        uint256 loanAmount = engine.getAmount(loanId);\n', '\n', '        // We expect a 10% extra for convertion losses\n', '        // the remaining will be sent to the borrower\n', '        require((loanAmount + deposit) >= ((landCost / 10) * 11), "Not enought total amount");\n', '\n', '        // Pull the deposit and lock the tokens\n', '        require(mana.transferFrom(msg.sender, this, deposit), "Error pulling mana");\n', '\n', '        // Create the liability\n', '        id = mortgages.push(Mortgage({\n', '            owner: borrower,\n', '            engine: engine,\n', '            loanId: loanId,\n', '            deposit: deposit,\n', '            landId: landId,\n', '            landCost: landCost,\n', '            status: Status.Pending,\n', '            tokenConverter: tokenConverter\n', '        })) - 1;\n', '\n', '        loanToLiability[engine][loanId] = id;\n', '\n', '        emit RequestedMortgage({\n', '            _id: id,\n', '            _borrower: borrower,\n', '            _engine: engine,\n', '            _loanId: loanId,\n', '            _landId: landId,\n', '            _deposit: deposit,\n', '            _tokenConverter: tokenConverter\n', '        });\n', '    }\n', '\n', '    /**\n', '        @notice Cancels an existing mortgage\n', '        @dev The mortgage status should be pending\n', '        @param id Id of the mortgage\n', '        @return true If the operation was executed\n', '\n', '    */\n', '    function cancelMortgage(uint256 id) external returns (bool) {\n', '        Mortgage storage mortgage = mortgages[id];\n', '        \n', '        // Only the owner of the mortgage and if the mortgage is pending\n', '        require(msg.sender == mortgage.owner, "Only the owner can cancel the mortgage");\n', '        require(mortgage.status == Status.Pending, "The mortgage is not pending");\n', '        \n', '        mortgage.status = Status.Canceled;\n', '\n', '        // Transfer the deposit back to the borrower\n', '        require(mana.transfer(msg.sender, mortgage.deposit), "Error returning MANA");\n', '\n', '        emit CanceledMortgage(msg.sender, id);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Request the cosign of a loan\n', '\n', '        Buys the parcel and locks its ownership until the loan status is resolved.\n', '        Emits an ERC721 to manage the ownership of the mortgaged property.\n', '    \n', '        @param engine Engine of the loan\n', '        @param index Index of the loan\n', '        @param data Data with the mortgage id\n', '        @param oracleData Oracle data to calculate the loan amount\n', '\n', '        @return true If the cosign was performed\n', '    */\n', '    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool) {\n', '        // The first word of the data MUST contain the index of the target mortgage\n', '        Mortgage storage mortgage = mortgages[uint256(readBytes32(data, 0))];\n', '        \n', '        // Validate that the loan matches with the mortgage\n', '        // and the mortgage is still pending\n', '        require(mortgage.engine == engine, "Engine does not match");\n', '        require(mortgage.loanId == index, "Loan id does not match");\n', '        require(mortgage.status == Status.Pending, "Mortgage is not pending");\n', '\n', '        // Update the status of the mortgage to avoid reentrancy\n', '        mortgage.status = Status.Ongoing;\n', '\n', '        // Mint mortgage ERC721 Token\n', '        _generate(uint256(readBytes32(data, 0)), mortgage.owner);\n', '\n', '        // Transfer the amount of the loan in RCN to this contract\n', '        uint256 loanAmount = convertRate(engine.getOracle(index), engine.getCurrency(index), oracleData, engine.getAmount(index));\n', '        require(rcn.transferFrom(mortgage.owner, this, loanAmount), "Error pulling RCN from borrower");\n', '        \n', '        // Convert the RCN into MANA using the designated\n', '        // and save the received MANA\n', '        uint256 boughtMana = convertSafe(mortgage.tokenConverter, rcn, mana, loanAmount);\n', '        delete mortgage.tokenConverter;\n', '\n', '        // Load the new cost of the parcel, it may be changed\n', '        uint256 currentLandCost;\n', '        (, , currentLandCost, ) = landMarket.auctionByAssetId(mortgage.landId);\n', '        require(currentLandCost <= mortgage.landCost, "Parcel is more expensive than expected");\n', '        \n', '        // Buy the land and lock it into the mortgage contract\n', '        require(mana.approve(landMarket, currentLandCost));\n', '        flagReceiveLand = mortgage.landId;\n', '        landMarket.executeOrder(mortgage.landId, currentLandCost);\n', '        require(mana.approve(landMarket, 0));\n', '        require(flagReceiveLand == 0, "ERC721 callback not called");\n', '        require(land.ownerOf(mortgage.landId) == address(this), "Error buying parcel");\n', '\n', '        // Calculate the remaining amount to send to the borrower and \n', '        // check that we didn&#39;t expend any contract funds.\n', '        uint256 totalMana = boughtMana.add(mortgage.deposit);        \n', '\n', '        // Return rest of MANA to the owner\n', '        require(mana.transfer(mortgage.owner, totalMana.sub(currentLandCost)), "Error returning MANA");\n', '        \n', '        // Cosign contract, 0 is the RCN required\n', '        require(mortgage.engine.cosign(index, 0), "Error performing cosign");\n', '        \n', '        // Save mortgage id registry\n', '        mortgageByLandId[mortgage.landId] = uint256(readBytes32(data, 0));\n', '\n', '        // Emit mortgage event\n', '        emit StartedMortgage(uint256(readBytes32(data, 0)));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Converts tokens using a token converter\n', '        @dev Does not trust the token converter, validates the return amount\n', '        @param converter Token converter used\n', '        @param from Tokens to sell\n', '        @param to Tokens to buy\n', '        @param amount Amount to sell\n', '        @return bought Bought amount\n', '    */\n', '    function convertSafe(\n', '        TokenConverter converter,\n', '        Token from,\n', '        Token to,\n', '        uint256 amount\n', '    ) internal returns (uint256 bought) {\n', '        require(from.approve(converter, amount));\n', '        uint256 prevBalance = to.balanceOf(this);\n', '        bought = converter.convert(from, to, amount, 1);\n', '        require(to.balanceOf(this).sub(prevBalance) >= bought, "Bought amount incorrect");\n', '        require(from.approve(converter, 0));\n', '    }\n', '\n', '    /**\n', '        @notice Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds.\n', '\n', '        @dev Deletes the mortgage ERC721\n', '\n', '        @param engine RCN Engine\n', '        @param loanId Loan ID\n', '        \n', '        @return true If the claim succeded\n', '    */\n', '    function claim(address engine, uint256 loanId, bytes) external returns (bool) {\n', '        uint256 mortgageId = loanToLiability[engine][loanId];\n', '        Mortgage storage mortgage = mortgages[mortgageId];\n', '\n', '        // Validate that the mortgage wasn&#39;t claimed\n', '        require(mortgage.status == Status.Ongoing, "Mortgage not ongoing");\n', '        require(mortgage.loanId == loanId, "Mortgage don&#39;t match loan id");\n', '\n', '        if (mortgage.engine.getStatus(loanId) == Engine.Status.paid || mortgage.engine.getStatus(loanId) == Engine.Status.destroyed) {\n', '            // The mortgage is paid\n', '            require(_isAuthorized(msg.sender, mortgageId), "Sender not authorized");\n', '\n', '            mortgage.status = Status.Paid;\n', '            // Transfer the parcel to the borrower\n', '            land.safeTransferFrom(this, msg.sender, mortgage.landId);\n', '            emit PaidMortgage(msg.sender, mortgageId);\n', '        } else if (isDefaulted(mortgage.engine, loanId)) {\n', '            // The mortgage is defaulted\n', '            require(msg.sender == mortgage.engine.ownerOf(loanId), "Sender not lender");\n', '            \n', '            mortgage.status = Status.Defaulted;\n', '            // Transfer the parcel to the lender\n', '            land.safeTransferFrom(this, msg.sender, mortgage.landId);\n', '            emit DefaultedMortgage(mortgageId);\n', '        } else {\n', '            revert("Mortgage not defaulted/paid");\n', '        }\n', '\n', '        // ERC721 Delete asset\n', '        _destroy(mortgageId);\n', '\n', '        // Delete mortgage id registry\n', '        delete mortgageByLandId[mortgage.landId];\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Defines a custom logic that determines if a loan is defaulted or not.\n', '\n', '        @param engine RCN Engines\n', '        @param index Index of the loan\n', '\n', '        @return true if the loan is considered defaulted\n', '    */\n', '    function isDefaulted(Engine engine, uint256 index) public view returns (bool) {\n', '        return engine.getStatus(index) == Engine.Status.lent &&\n', '            engine.getDueTime(index).add(7 days) <= block.timestamp;\n', '    }\n', '\n', '    /**\n', '        @dev An alternative version of the ERC721 callback, required by a bug in the parcels contract\n', '    */\n', '    function onERC721Received(uint256 _tokenId, address, bytes) external returns (bytes4) {\n', '        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {\n', '            flagReceiveLand = 0;\n', '            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice Callback used to accept the ERC721 parcel tokens\n', '\n', '        @dev Only accepts tokens if flag is set to tokenId, resets the flag when called\n', '    */\n', '    function onERC721Received(address, uint256 _tokenId, bytes) external returns (bytes4) {\n', '        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {\n', '            flagReceiveLand = 0;\n', '            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev Reads data from a bytes array\n', '    */\n', '    function getData(uint256 id) public pure returns (bytes o) {\n', '        assembly {\n', '            o := mload(0x40)\n', '            mstore(0x40, add(o, and(add(add(32, 0x20), 0x1f), not(0x1f))))\n', '            mstore(o, 32)\n', '            mstore(add(o, 32), id)\n', '        }\n', '    }\n', '    \n', '    /**\n', '        @notice Enables the owner of a parcel to update the data field\n', '\n', '        @param id Id of the mortgage\n', '        @param data New data\n', '\n', '        @return true If data was updated\n', '    */\n', '    function updateLandData(uint256 id, string data) external returns (bool) {\n', '        Mortgage memory mortgage = mortgages[id];\n', '        require(_isAuthorized(msg.sender, id), "Sender not authorized");\n', '        int256 x;\n', '        int256 y;\n', '        (x, y) = land.decodeTokenId(mortgage.landId);\n', '        land.updateLandData(x, y, data);\n', '        emit UpdatedLandData(msg.sender, id, data);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev Replica of the convertRate function of the RCN Engine, used to apply the oracle rate\n', '    */\n', '    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) internal returns (uint256) {\n', '        if (oracle == address(0)) {\n', '            return amount;\n', '        } else {\n', '            uint256 rate;\n', '            uint256 decimals;\n', '            \n', '            (rate, decimals) = oracle.getRate(currency, data);\n', '\n', '            require(decimals <= RCN_DECIMALS, "Decimals exceeds max decimals");\n', '            return (amount.mult(rate).mult((10**(RCN_DECIMALS-decimals)))) / PRECISION;\n', '        }\n', '    }\n', '}\n', '\n', 'interface NanoLoanEngine {\n', '    function createLoan(address _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n', '        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256);\n', '    function getIdentifier(uint256 index) public view returns (bytes32);\n', '    function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool);\n', '    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool);\n', '    function rcn() public view returns (Token);\n', '    function getOracle(uint256 index) public view returns (Oracle);\n', '    function getAmount(uint256 index) public view returns (uint256);\n', '    function getCurrency(uint256 index) public view returns (bytes32);\n', '    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public view returns (uint256);\n', '    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool);\n', '    function transfer(address to, uint256 index) public returns (bool);\n', '}\n', '\n', '/**\n', '    @notice Set of functions to operate the mortgage manager in less transactions\n', '*/\n', 'contract MortgageHelper is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    MortgageManager public mortgageManager;\n', '    NanoLoanEngine public nanoLoanEngine;\n', '    Token public rcn;\n', '    Token public mana;\n', '    LandMarket public landMarket;\n', '    TokenConverter public tokenConverter;\n', '    address public converterRamp;\n', '\n', '    address public manaOracle;\n', '    uint256 public requiredTotal = 110;\n', '\n', '    uint256 public rebuyThreshold = 0.001 ether;\n', '    uint256 public marginSpend = 100;\n', '    uint256 public maxSpend = 100;\n', '\n', '    bytes32 public constant MANA_CURRENCY = 0x4d414e4100000000000000000000000000000000000000000000000000000000;\n', '\n', '    event NewMortgage(address borrower, uint256 loanId, uint256 landId, uint256 mortgageId);\n', '    event PaidLoan(address engine, uint256 loanId, uint256 amount);\n', '    event SetConverterRamp(address _prev, address _new);\n', '    event SetTokenConverter(address _prev, address _new);\n', '    event SetRebuyThreshold(uint256 _prev, uint256 _new);\n', '    event SetMarginSpend(uint256 _prev, uint256 _new);\n', '    event SetMaxSpend(uint256 _prev, uint256 _new);\n', '    event SetRequiredTotal(uint256 _prev, uint256 _new);\n', '\n', '    constructor(\n', '        MortgageManager _mortgageManager,\n', '        NanoLoanEngine _nanoLoanEngine,\n', '        Token _rcn,\n', '        Token _mana,\n', '        LandMarket _landMarket,\n', '        address _manaOracle,\n', '        TokenConverter _tokenConverter,\n', '        address _converterRamp\n', '    ) public {\n', '        mortgageManager = _mortgageManager;\n', '        nanoLoanEngine = _nanoLoanEngine;\n', '        rcn = _rcn;\n', '        mana = _mana;\n', '        landMarket = _landMarket;\n', '        manaOracle = _manaOracle;\n', '        tokenConverter = _tokenConverter;\n', '        converterRamp = _converterRamp;\n', '\n', '        emit SetConverterRamp(converterRamp, _converterRamp);\n', '        emit SetTokenConverter(tokenConverter, _tokenConverter);\n', '    }\n', '\n', '    /**\n', '        @dev Creates a loan using an array of parameters\n', '\n', '        @param params 0 - Ammount\n', '                      1 - Interest rate\n', '                      2 - Interest rate punitory\n', '                      3 - Dues in\n', '                      4 - Cancelable at\n', '                      5 - Expiration of request\n', '\n', '        @param metadata Loan metadata\n', '\n', '        @return Id of the loan\n', '\n', '    */\n', '    function createLoan(uint256[6] memory params, string metadata) internal returns (uint256) {\n', '        return nanoLoanEngine.createLoan(\n', '            manaOracle,\n', '            msg.sender,\n', '            MANA_CURRENCY,\n', '            params[0],\n', '            params[1],\n', '            params[2],\n', '            params[3],\n', '            params[4],\n', '            params[5],\n', '            metadata\n', '        );\n', '    }\n', '\n', '    /**\n', '        @notice Sets a max amount to expend when performing the payment\n', '        @dev Only owner\n', '        @param _maxSpend New maxSPend value\n', '        @return true If the change was made\n', '    */\n', '    function setMaxSpend(uint256 _maxSpend) external onlyOwner returns (bool) {\n', '        emit SetMaxSpend(maxSpend, _maxSpend);\n', '        maxSpend = _maxSpend;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets required total of the mortgage\n', '        @dev Only owner\n', '        @param _requiredTotal New requiredTotal value\n', '        @return true If the change was made\n', '    */\n', '    function setRequiredTotal(uint256 _requiredTotal) external onlyOwner returns (bool) {\n', '        emit SetRequiredTotal(requiredTotal, _requiredTotal);\n', '        requiredTotal = _requiredTotal;\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '        @notice Sets a new converter ramp to delegate the pay of the loan\n', '        @dev Only owner\n', '        @param _converterRamp Address of the converter ramp contract\n', '        @return true If the change was made\n', '    */\n', '    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {\n', '        emit SetConverterRamp(converterRamp, _converterRamp);\n', '        converterRamp = _converterRamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets a new min of tokens to rebuy when paying a loan\n', '        @dev Only owner\n', '        @param _rebuyThreshold New rebuyThreshold value\n', '        @return true If the change was made\n', '    */\n', '    function setRebuyThreshold(uint256 _rebuyThreshold) external onlyOwner returns (bool) {\n', '        emit SetRebuyThreshold(rebuyThreshold, _rebuyThreshold);\n', '        rebuyThreshold = _rebuyThreshold;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets how much the converter ramp is going to oversell to cover fees and gaps\n', '        @dev Only owner\n', '        @param _marginSpend New marginSpend value\n', '        @return true If the change was made\n', '    */\n', '    function setMarginSpend(uint256 _marginSpend) external onlyOwner returns (bool) {\n', '        emit SetMarginSpend(marginSpend, _marginSpend);\n', '        marginSpend = _marginSpend;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets the token converter used to convert the MANA into RCN when performing the payment\n', '        @dev Only owner\n', '        @param _tokenConverter Address of the tokenConverter contract\n', '        @return true If the change was made\n', '    */\n', '    function setTokenConverter(TokenConverter _tokenConverter) external onlyOwner returns (bool) {\n', '        emit SetTokenConverter(tokenConverter, _tokenConverter);\n', '        tokenConverter = _tokenConverter;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Request a loan and attachs a mortgage request\n', '\n', '        @dev Requires the loan signed by the borrower\n', '\n', '        @param loanParams   0 - Ammount\n', '                            1 - Interest rate\n', '                            2 - Interest rate punitory\n', '                            3 - Dues in\n', '                            4 - Cancelable at\n', '                            5 - Expiration of request\n', '        @param metadata Loan metadata\n', '        @param landId Land to buy with the mortgage\n', '        @param v Loan signature by the borrower\n', '        @param r Loan signature by the borrower\n', '        @param s Loan signature by the borrower\n', '\n', '        @return The id of the mortgage\n', '    */\n', '    function requestMortgage(\n', '        uint256[6] loanParams,\n', '        string metadata,\n', '        uint256 landId,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256) {\n', '        // Create a loan with the loanParams and metadata\n', '        uint256 loanId = createLoan(loanParams, metadata);\n', '\n', '        // Approve the created loan with the provided signature\n', '        require(nanoLoanEngine.registerApprove(nanoLoanEngine.getIdentifier(loanId), v, r, s), "Signature not valid");\n', '\n', '        // Calculate the requested amount for the mortgage deposit\n', '        uint256 landCost;\n', '        (, , landCost, ) = landMarket.auctionByAssetId(landId);\n', '        uint256 requiredDeposit = ((landCost * requiredTotal) / 100) - nanoLoanEngine.getAmount(loanId);\n', '        \n', '        // Pull the required deposit amount\n', '        require(mana.transferFrom(msg.sender, this, requiredDeposit), "Error pulling MANA");\n', '        require(mana.approve(mortgageManager, requiredDeposit));\n', '\n', '        // Create the mortgage request\n', '        uint256 mortgageId = mortgageManager.requestMortgageId(Engine(nanoLoanEngine), loanId, requiredDeposit, landId, tokenConverter);\n', '        emit NewMortgage(msg.sender, loanId, landId, mortgageId);\n', '        \n', '        return mortgageId;\n', '    }\n', '\n', '    /**\n', '        @notice Pays a loan using mana\n', '\n', '        @dev The amount to pay must be set on mana\n', '\n', '        @param engine RCN Engine\n', '        @param loan Loan id to pay\n', '        @param amount Amount in MANA to pay\n', '\n', '        @return True if the payment was performed\n', '    */\n', '    function pay(address engine, uint256 loan, uint256 amount) external returns (bool) {\n', '        emit PaidLoan(engine, loan, amount);\n', '\n', '        bytes32[4] memory loanParams = [\n', '            bytes32(engine),\n', '            bytes32(loan),\n', '            bytes32(amount),\n', '            bytes32(msg.sender)\n', '        ];\n', '\n', '        uint256[3] memory converterParams = [\n', '            marginSpend,\n', '            amount.mult(uint256(100000).add(maxSpend)) / 100000,\n', '            rebuyThreshold\n', '        ];\n', '\n', '        require(address(converterRamp).delegatecall(\n', '            bytes4(0x86ee863d),\n', '            address(tokenConverter),\n', '            address(mana),\n', '            loanParams,\n', '            0x140,\n', '            converterParams,\n', '            0x0\n', '        ), "Error delegate pay call");\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Token {\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Sender is not the owner");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender; \n', '    }\n', '\n', '    /**\n', '        @dev Transfers the ownership of the contract.\n', '\n', '        @param _to Address of the new owner\n', '    */\n', '    function transferTo(address _to) public onlyOwner returns (bool) {\n', '        require(_to != address(0), "Can\'t transfer to 0x0");\n', '        owner = _to;\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    @dev Defines the interface of a standard RCN oracle.\n', '\n', '    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n', "    it's primarily used by the exchange but could be used by any other agent.\n", '*/\n', 'contract Oracle is Ownable {\n', '    uint256 public constant VERSION = 4;\n', '\n', '    event NewSymbol(bytes32 _currency);\n', '\n', '    mapping(bytes32 => bool) public supported;\n', '    bytes32[] public currencies;\n', '\n', '    /**\n', '        @dev Returns the url where the oracle exposes a valid "oracleData" if needed\n', '    */\n', '    function url() public view returns (string);\n', '\n', '    /**\n', '        @dev Returns a valid convertion rate from the currency given to RCN\n', '\n', '        @param symbol Symbol of the currency\n', '        @param data Generic data field, could be used for off-chain signing\n', '    */\n', '    function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);\n', '\n', '    /**\n', '        @dev Adds a currency to the oracle, once added it cannot be removed\n', '\n', '        @param ticker Symbol of the currency\n', '\n', '        @return if the creation was done successfully\n', '    */\n', '    function addCurrency(string ticker) public onlyOwner returns (bool) {\n', '        bytes32 currency = encodeCurrency(ticker);\n', '        NewSymbol(currency);\n', '        supported[currency] = true;\n', '        currencies.push(currency);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @return the currency encoded as a bytes32\n', '    */\n', '    function encodeCurrency(string currency) public pure returns (bytes32 o) {\n', '        require(bytes(currency).length <= 32);\n', '        assembly {\n', '            o := mload(add(currency, 32))\n', '        }\n', '    }\n', '    \n', '    /**\n', '        @return the currency string from a encoded bytes32\n', '    */\n', '    function decodeCurrency(bytes32 b) public pure returns (string o) {\n', '        uint256 ns = 256;\n', '        while (true) { if (ns == 0 || (b<<ns-8) != 0) break; ns -= 8; }\n', '        assembly {\n', '            ns := div(ns, 8)\n', '            o := mload(0x40)\n', '            mstore(0x40, add(o, and(add(add(ns, 0x20), 0x1f), not(0x1f))))\n', '            mstore(o, ns)\n', '            mstore(add(o, 32), b)\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'contract Engine {\n', '    uint256 public VERSION;\n', '    string public VERSION_NAME;\n', '\n', '    enum Status { initial, lent, paid, destroyed }\n', '    struct Approbation {\n', '        bool approved;\n', '        bytes data;\n', '        bytes32 checksum;\n', '    }\n', '\n', '    function getTotalLoans() public view returns (uint256);\n', '    function getOracle(uint index) public view returns (Oracle);\n', '    function getBorrower(uint index) public view returns (address);\n', '    function getCosigner(uint index) public view returns (address);\n', '    function ownerOf(uint256) public view returns (address owner);\n', '    function getCreator(uint index) public view returns (address);\n', '    function getAmount(uint index) public view returns (uint256);\n', '    function getPaid(uint index) public view returns (uint256);\n', '    function getDueTime(uint index) public view returns (uint256);\n', '    function getApprobation(uint index, address _address) public view returns (bool);\n', '    function getStatus(uint index) public view returns (Status);\n', '    function isApproved(uint index) public view returns (bool);\n', '    function getPendingAmount(uint index) public returns (uint256);\n', '    function getCurrency(uint index) public view returns (bytes32);\n', '    function cosign(uint index, uint256 cost) external returns (bool);\n', '    function approveLoan(uint index) public returns (bool);\n', '    function transfer(address to, uint256 index) public returns (bool);\n', '    function takeOwnership(uint256 index) public returns (bool);\n', '    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n', '    function identifierToIndex(bytes32 signature) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', '    @dev Defines the interface of a standard RCN cosigner.\n', '\n', '    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n', '    of the insurance and the cost of the given are defined by the cosigner. \n', '\n', '    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n', '    agent should be passed as params when the lender calls the "lend" method on the engine.\n', '    \n', '    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n', '    should be able to call the "claim" method to receive the benefit; the cosigner can define aditional requirements to\n', '    call this method, like the transfer of the ownership of the loan.\n', '*/\n', 'contract Cosigner {\n', '    uint256 public constant VERSION = 2;\n', '    \n', '    /**\n', '        @return the url of the endpoint that exposes the insurance offers.\n', '    */\n', '    function url() external view returns (string);\n', '    \n', '    /**\n', '        @dev Retrieves the cost of a given insurance, this amount should be exact.\n', '\n', '        @return the cost of the cosign, in RCN wei\n', '    */\n', '    function cost(address engine, uint256 index, bytes data, bytes oracleData) external view returns (uint256);\n', '    \n', '    /**\n', '        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n', '        the insurance it must call the method "cosign" of the engine. If the cosigner does not call that method, or\n', '        does not return true to this method, the operation fails.\n', '\n', '        @return true if the cosigner accepts the liability\n', '    */\n', '    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n', '    \n', '    /**\n', '        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n', '        current lender of the loan.\n', '\n', '        @return true if the claim was done correctly.\n', '    */\n', '    function claim(address engine, uint256 index, bytes oracleData) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        require((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        require(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function mult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        require((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', 'contract SafeWithdraw is Ownable {\n', '    /**\n', '        @dev Withdraws tokens from the contract.\n', '\n', '        @param token Token to withdraw\n', '        @param to Destination of the tokens\n', '        @param amountOrId Amount/ID to withdraw \n', '    */\n', '    function withdrawTokens(Token token, address to, uint256 amountOrId) external onlyOwner returns (bool) {\n', '        require(to != address(0));\n', '        return token.transfer(to, amountOrId);\n', '    }\n', '}\n', '\n', 'contract BytesUtils {\n', '    function readBytes32(bytes data, uint256 index) internal pure returns (bytes32 o) {\n', '        require(data.length / 32 > index);\n', '        assembly {\n', '            o := mload(add(data, add(32, mul(32, index))))\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenConverter {\n', '    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n', '    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\n', '    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\n', '}\n', '\n', '\n', '\n', 'interface IERC721Receiver {\n', '    function onERC721Received(\n', '        address _oldOwner,\n', '        uint256 _tokenId,\n', '        bytes   _userData\n', '    ) external returns (bytes4);\n', '}\n', '\n', 'contract ERC721Base {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private _count;\n', '\n', '    mapping(uint256 => address) private _holderOf;\n', '    mapping(address => uint256[]) private _assetsOf;\n', '    mapping(address => mapping(address => bool)) private _operators;\n', '    mapping(uint256 => address) private _approval;\n', '    mapping(uint256 => uint256) private _indexOfAsset;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    //\n', '    // Global Getters\n', '    //\n', '\n', '    /**\n', '     * @dev Gets the total amount of assets stored by the contract\n', '     * @return uint256 representing the total amount of assets\n', '     */\n', '    function totalSupply() external view returns (uint256) {\n', '        return _totalSupply();\n', '    }\n', '    function _totalSupply() internal view returns (uint256) {\n', '        return _count;\n', '    }\n', '\n', '    //\n', '    // Asset-centric getter functions\n', '    //\n', '\n', '    /**\n', '     * @dev Queries what address owns an asset. This method does not throw.\n', '     * In order to check if the asset exists, use the `exists` function or check if the\n', '     * return value of this call is `0`.\n', '     * @return uint256 the assetId\n', '     */\n', '    function ownerOf(uint256 assetId) external view returns (address) {\n', '        return _ownerOf(assetId);\n', '    }\n', '    function _ownerOf(uint256 assetId) internal view returns (address) {\n', '        return _holderOf[assetId];\n', '    }\n', '\n', '    //\n', '    // Holder-centric getter functions\n', '    //\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256) {\n', '        return _balanceOf(owner);\n', '    }\n', '    function _balanceOf(address owner) internal view returns (uint256) {\n', '        return _assetsOf[owner].length;\n', '    }\n', '\n', '    //\n', '    // Authorization getters\n', '    //\n', '\n', '    /**\n', '     * @dev Query whether an address has been authorized to move any assets on behalf of someone else\n', '     * @param operator the address that might be authorized\n', '     * @param assetHolder the address that provided the authorization\n', '     * @return bool true if the operator has been authorized to move any assets\n', '     */\n', '    function isApprovedForAll(address operator, address assetHolder)\n', '        external view returns (bool)\n', '    {\n', '        return _isApprovedForAll(operator, assetHolder);\n', '    }\n', '    function _isApprovedForAll(address operator, address assetHolder)\n', '        internal view returns (bool)\n', '    {\n', '        return _operators[assetHolder][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Query what address has been particularly authorized to move an asset\n', '     * @param assetId the asset to be queried for\n', '     * @return bool true if the asset has been approved by the holder\n', '     */\n', '    function getApprovedAddress(uint256 assetId) external view returns (address) {\n', '        return _getApprovedAddress(assetId);\n', '    }\n', '    function _getApprovedAddress(uint256 assetId) internal view returns (address) {\n', '        return _approval[assetId];\n', '    }\n', '\n', '    /**\n', '     * @dev Query if an operator can move an asset.\n', '     * @param operator the address that might be authorized\n', '     * @param assetId the asset that has been `approved` for transfer\n', '     * @return bool true if the asset has been approved by the holder\n', '     */\n', '    function isAuthorized(address operator, uint256 assetId) external view returns (bool) {\n', '        return _isAuthorized(operator, assetId);\n', '    }\n', '    function _isAuthorized(address operator, uint256 assetId) internal view returns (bool)\n', '    {\n', '        require(operator != 0, "Operator can\'t be 0");\n', '        address owner = _ownerOf(assetId);\n', '        if (operator == owner) {\n', '            return true;\n', '        }\n', '        return _isApprovedForAll(operator, owner) || _getApprovedAddress(assetId) == operator;\n', '    }\n', '\n', '    //\n', '    // Authorization\n', '    //\n', '\n', '    /**\n', "     * @dev Authorize a third party operator to manage (send) msg.sender's asset\n", '     * @param operator address to be approved\n', '     * @param authorized bool set to true to authorize, false to withdraw authorization\n', '     */\n', '    function setApprovalForAll(address operator, bool authorized) external {\n', '        return _setApprovalForAll(operator, authorized);\n', '    }\n', '    function _setApprovalForAll(address operator, bool authorized) internal {\n', '        if (authorized) {\n', '            _addAuthorization(operator, msg.sender);\n', '        } else {\n', '            _clearAuthorization(operator, msg.sender);\n', '        }\n', '        emit ApprovalForAll(operator, msg.sender, authorized);\n', '    }\n', '\n', '    /**\n', '     * @dev Authorize a third party operator to manage one particular asset\n', '     * @param operator address to be approved\n', '     * @param assetId asset to approve\n', '     */\n', '    function approve(address operator, uint256 assetId) external {\n', '        address holder = _ownerOf(assetId);\n', '        require(msg.sender == holder || _isApprovedForAll(msg.sender, holder));\n', '        require(operator != holder);\n', '        if (_getApprovedAddress(assetId) != operator) {\n', '            _approval[assetId] = operator;\n', '            emit Approval(holder, operator, assetId);\n', '        }\n', '    }\n', '\n', '    function _addAuthorization(address operator, address holder) private {\n', '        _operators[holder][operator] = true;\n', '    }\n', '\n', '    function _clearAuthorization(address operator, address holder) private {\n', '        _operators[holder][operator] = false;\n', '    }\n', '\n', '    //\n', '    // Internal Operations\n', '    //\n', '\n', '    function _addAssetTo(address to, uint256 assetId) internal {\n', '        _holderOf[assetId] = to;\n', '\n', '        uint256 length = _balanceOf(to);\n', '\n', '        _assetsOf[to].push(assetId);\n', '\n', '        _indexOfAsset[assetId] = length;\n', '\n', '        _count = _count.add(1);\n', '    }\n', '\n', '    function _removeAssetFrom(address from, uint256 assetId) internal {\n', '        uint256 assetIndex = _indexOfAsset[assetId];\n', '        uint256 lastAssetIndex = _balanceOf(from).sub(1);\n', '        uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\n', '\n', '        _holderOf[assetId] = 0;\n', '\n', '        // Insert the last asset into the position previously occupied by the asset to be removed\n', '        _assetsOf[from][assetIndex] = lastAssetId;\n', '\n', '        // Resize the array\n', '        _assetsOf[from][lastAssetIndex] = 0;\n', '        _assetsOf[from].length--;\n', '\n', '        // Remove the array if no more assets are owned to prevent pollution\n', '        if (_assetsOf[from].length == 0) {\n', '            delete _assetsOf[from];\n', '        }\n', '\n', '        // Update the index of positions for the asset\n', '        _indexOfAsset[assetId] = 0;\n', '        _indexOfAsset[lastAssetId] = assetIndex;\n', '\n', '        _count = _count.sub(1);\n', '    }\n', '\n', '    function _clearApproval(address holder, uint256 assetId) internal {\n', '        if (_ownerOf(assetId) == holder && _approval[assetId] != 0) {\n', '            _approval[assetId] = 0;\n', '            emit Approval(holder, 0, assetId);\n', '        }\n', '    }\n', '\n', '    //\n', '    // Supply-altering functions\n', '    //\n', '\n', '    function _generate(uint256 assetId, address beneficiary) internal {\n', '        require(_holderOf[assetId] == 0);\n', '\n', '        _addAssetTo(beneficiary, assetId);\n', '\n', '        emit Transfer(0x0, beneficiary, assetId);\n', '    }\n', '\n', '    function _destroy(uint256 assetId) internal {\n', '        address holder = _holderOf[assetId];\n', '        require(holder != 0);\n', '\n', '        _removeAssetFrom(holder, assetId);\n', '\n', '        emit Transfer(holder, 0x0, assetId);\n', '    }\n', '\n', '    //\n', '    // Transaction related operations\n', '    //\n', '\n', '    modifier onlyHolder(uint256 assetId) {\n', '        require(_ownerOf(assetId) == msg.sender, "Not holder");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorized(uint256 assetId) {\n', '        require(_isAuthorized(msg.sender, assetId), "Not authorized");\n', '        _;\n', '    }\n', '\n', '    modifier isCurrentOwner(address from, uint256 assetId) {\n', '        require(_ownerOf(assetId) == from, "Not current owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', "     * @dev Alias of `safeTransferFrom(from, to, assetId, '')`\n", '     *\n', '     * @param from address that currently owns an asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 assetId) external {\n', '        return _doTransferFrom(from, to, assetId, "", true);\n', '    }\n', '\n', '    /**\n', '     * @dev Securely transfers the ownership of a given asset from one address to\n', '     * another address, calling the method `onNFTReceived` on the target address if\n', "     * there's code associated with it\n", '     *\n', '     * @param from address that currently owns an asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     * @param userData bytes arbitrary user information to attach to this transfer\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 assetId, bytes userData) external {\n', '        return _doTransferFrom(from, to, assetId, userData, true);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given asset from one address to another address\n', '     * Warning! This function does not attempt to verify that the target address can send\n', '     * tokens.\n', '     *\n', '     * @param from address sending the asset\n', '     * @param to address to receive the ownership of the asset\n', '     * @param assetId uint256 ID of the asset to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 assetId) external {\n', '        return _doTransferFrom(from, to, assetId, "", false);\n', '    }\n', '\n', '    function _doTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 assetId,\n', '        bytes userData,\n', '        bool doCheck\n', '    )\n', '        onlyAuthorized(assetId)\n', '        internal\n', '    {\n', '        _moveToken(from, to, assetId, userData, doCheck);\n', '    }\n', '\n', '    function _moveToken(\n', '        address from,\n', '        address to,\n', '        uint256 assetId,\n', '        bytes userData,\n', '        bool doCheck\n', '    )\n', '        isCurrentOwner(from, assetId)\n', '        internal\n', '    {\n', '        address holder = _holderOf[assetId];\n', '        _removeAssetFrom(holder, assetId);\n', '        _clearApproval(holder, assetId);\n', '        _addAssetTo(to, assetId);\n', '\n', '        if (doCheck && _isContract(to)) {\n', '            // Equals to bytes4(keccak256("onERC721Received(address,uint256,bytes)"))\n', '            bytes4 ERC721_RECEIVED = bytes4(0xf0b9e5ba);\n', '            require(\n', '                IERC721Receiver(to).onERC721Received(\n', '                    holder, assetId, userData\n', '                ) == ERC721_RECEIVED\n', '            , "Contract onERC721Received failed");\n', '        }\n', '\n', '        emit Transfer(holder, to, assetId);\n', '    }\n', '\n', '    /**\n', '     * Internal function that moves an asset from one holder to another\n', '     */\n', '\n', '    /**\n', '     * @dev Returns `true` if the contract implements `interfaceID` and `interfaceID` is not 0xffffffff, `false` otherwise\n', '     * @param    _interfaceID The interface identifier, as specified in ERC-165\n', '     */\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '\n', '        if (_interfaceID == 0xffffffff) {\n', '            return false;\n', '        }\n', '        return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x80ac58cd;\n', '    }\n', '\n', '    //\n', '    // Utilities\n', '    //\n', '\n', '    function _isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', 'contract LandMarket {\n', '    struct Auction {\n', '        // Auction ID\n', '        bytes32 id;\n', '        // Owner of the NFT\n', '        address seller;\n', '        // Price (in wei) for the published item\n', '        uint256 price;\n', '        // Time when this sale ends\n', '        uint256 expiresAt;\n', '    }\n', '\n', '    mapping (uint256 => Auction) public auctionByAssetId;\n', '    function executeOrder(uint256 assetId, uint256 price) public;\n', '}\n', '\n', 'contract Land {\n', '    function updateLandData(int x, int y, string data) public;\n', '    function decodeTokenId(uint value) view public returns (int, int);\n', '    function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '    function ownerOf(uint256 landID) public view returns (address);\n', '}\n', '\n', '/**\n', '    @notice The contract is used to handle all the lifetime of a mortgage, uses RCN for the Loan and Decentraland for the parcels. \n', '\n', '    Implements the Cosigner interface of RCN, and when is tied to a loan it creates a new ERC721 to handle the ownership of the mortgage.\n', '\n', '    When the loan is resolved (paid, pardoned or defaulted), the mortgaged parcel can be recovered. \n', '\n', '    Uses a token converter to buy the Decentraland parcel with MANA using the RCN tokens received.\n', '*/\n', 'contract MortgageManager is Cosigner, ERC721Base, SafeWithdraw, BytesUtils {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant internal PRECISION = (10**18);\n', '    uint256 constant internal RCN_DECIMALS = 18;\n', '\n', '    bytes32 public constant MANA_CURRENCY = 0x4d414e4100000000000000000000000000000000000000000000000000000000;\n', '    uint256 public constant REQUIRED_ALLOWANCE = 1000000000 * 10**18;\n', '\n', '    function name() public pure returns (string _name) {\n', '        _name = "Decentraland RCN Mortgage";\n', '    }\n', '\n', '    function symbol() public pure returns (string _symbol) {\n', '        _symbol = "LAND-RCN-Mortgage";\n', '    }\n', '\n', '    event RequestedMortgage(uint256 _id, address _borrower, address _engine, uint256 _loanId, uint256 _landId, uint256 _deposit, address _tokenConverter);\n', '    event StartedMortgage(uint256 _id);\n', '    event CanceledMortgage(address _from, uint256 _id);\n', '    event PaidMortgage(address _from, uint256 _id);\n', '    event DefaultedMortgage(uint256 _id);\n', '    event UpdatedLandData(address _updater, uint256 _parcel, string _data);\n', '    event SetCreator(address _creator, bool _status);\n', '\n', '    Token public rcn;\n', '    Token public mana;\n', '    Land public land;\n', '    LandMarket public landMarket;\n', '    \n', '    constructor(Token _rcn, Token _mana, Land _land, LandMarket _landMarket) public {\n', '        rcn = _rcn;\n', '        mana = _mana;\n', '        land = _land;\n', '        landMarket = _landMarket;\n', '        mortgages.length++;\n', '    }\n', '\n', '    enum Status { Pending, Ongoing, Canceled, Paid, Defaulted }\n', '\n', '    struct Mortgage {\n', '        address owner;\n', '        Engine engine;\n', '        uint256 loanId;\n', '        uint256 deposit;\n', '        uint256 landId;\n', '        uint256 landCost;\n', '        Status status;\n', '        // ERC-721\n', '        TokenConverter tokenConverter;\n', '    }\n', '\n', '    uint256 internal flagReceiveLand;\n', '\n', '    Mortgage[] public mortgages;\n', '\n', '    mapping(address => bool) public creators;\n', '\n', '    mapping(uint256 => uint256) public mortgageByLandId;\n', '    mapping(address => mapping(uint256 => uint256)) public loanToLiability;\n', '\n', '    function url() external view returns (string) {\n', '        return "";\n', '    }\n', '\n', '    /**\n', '        @notice Sets a new third party creator\n', '        \n', '        The third party creator can request loans for other borrowers. The creator should be a trusted contract, it could potentially take funds.\n', '    \n', '        @param creator Address of the creator\n', '        @param authorized Enables or disables the permission\n', '\n', '        @return true If the operation was executed\n', '    */\n', '    function setCreator(address creator, bool authorized) external onlyOwner returns (bool) {\n', '        emit SetCreator(creator, authorized);\n', '        creators[creator] = authorized;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Returns the cost of the cosigner\n', '\n', '        This cosigner does not have any risk or maintenance cost, so its free.\n', '\n', "        @return 0, because it's free\n", '    */\n', '    function cost(address, uint256, bytes, bytes) external view returns (uint256) {\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '        @notice Requests a mortgage with a loan identifier\n', '\n', '        @dev The loan should exist in the designated engine\n', '\n', '        @param engine RCN Engine\n', '        @param loanIdentifier Identifier of the loan asociated with the mortgage\n', '        @param deposit MANA to cover part of the cost of the parcel\n', '        @param landId ID of the parcel to buy with the mortgage\n', '        @param tokenConverter Token converter used to exchange RCN - MANA\n', '\n', '        @return id The id of the mortgage\n', '    */\n', '    function requestMortgage(\n', '        Engine engine,\n', '        bytes32 loanIdentifier,\n', '        uint256 deposit,\n', '        uint256 landId,\n', '        TokenConverter tokenConverter\n', '    ) external returns (uint256 id) {\n', '        return requestMortgageId(engine, engine.identifierToIndex(loanIdentifier), deposit, landId, tokenConverter);\n', '    }\n', '\n', '    /**\n', '        @notice Request a mortgage with a loan id\n', '\n', '        @dev The loan should exist in the designated engine\n', '\n', '        @param engine RCN Engine\n', '        @param loanId Id of the loan asociated with the mortgage\n', '        @param deposit MANA to cover part of the cost of the parcel\n', '        @param landId ID of the parcel to buy with the mortgage\n', '        @param tokenConverter Token converter used to exchange RCN - MANA\n', '\n', '        @return id The id of the mortgage\n', '    */\n', '    function requestMortgageId(\n', '        Engine engine,\n', '        uint256 loanId,\n', '        uint256 deposit,\n', '        uint256 landId,\n', '        TokenConverter tokenConverter\n', '    ) public returns (uint256 id) {\n', '        // Validate the associated loan\n', '        require(engine.getCurrency(loanId) == MANA_CURRENCY, "Loan currency is not MANA");\n', '        address borrower = engine.getBorrower(loanId);\n', '        require(engine.getStatus(loanId) == Engine.Status.initial, "Loan status is not inital");\n', '        require(msg.sender == engine.getBorrower(loanId) ||\n', '               (msg.sender == engine.getCreator(loanId) && creators[msg.sender]),\n', '            "Creator should be borrower or authorized");\n', '        require(engine.isApproved(loanId), "Loan is not approved");\n', '        require(rcn.allowance(borrower, this) >= REQUIRED_ALLOWANCE, "Manager cannot handle borrower\'s funds");\n', '        require(tokenConverter != address(0), "Token converter not defined");\n', '        require(loanToLiability[engine][loanId] == 0, "Liability for loan already exists");\n', '\n', '        // Get the current parcel cost\n', '        uint256 landCost;\n', '        (, , landCost, ) = landMarket.auctionByAssetId(landId);\n', '        uint256 loanAmount = engine.getAmount(loanId);\n', '\n', '        // We expect a 10% extra for convertion losses\n', '        // the remaining will be sent to the borrower\n', '        require((loanAmount + deposit) >= ((landCost / 10) * 11), "Not enought total amount");\n', '\n', '        // Pull the deposit and lock the tokens\n', '        require(mana.transferFrom(msg.sender, this, deposit), "Error pulling mana");\n', '\n', '        // Create the liability\n', '        id = mortgages.push(Mortgage({\n', '            owner: borrower,\n', '            engine: engine,\n', '            loanId: loanId,\n', '            deposit: deposit,\n', '            landId: landId,\n', '            landCost: landCost,\n', '            status: Status.Pending,\n', '            tokenConverter: tokenConverter\n', '        })) - 1;\n', '\n', '        loanToLiability[engine][loanId] = id;\n', '\n', '        emit RequestedMortgage({\n', '            _id: id,\n', '            _borrower: borrower,\n', '            _engine: engine,\n', '            _loanId: loanId,\n', '            _landId: landId,\n', '            _deposit: deposit,\n', '            _tokenConverter: tokenConverter\n', '        });\n', '    }\n', '\n', '    /**\n', '        @notice Cancels an existing mortgage\n', '        @dev The mortgage status should be pending\n', '        @param id Id of the mortgage\n', '        @return true If the operation was executed\n', '\n', '    */\n', '    function cancelMortgage(uint256 id) external returns (bool) {\n', '        Mortgage storage mortgage = mortgages[id];\n', '        \n', '        // Only the owner of the mortgage and if the mortgage is pending\n', '        require(msg.sender == mortgage.owner, "Only the owner can cancel the mortgage");\n', '        require(mortgage.status == Status.Pending, "The mortgage is not pending");\n', '        \n', '        mortgage.status = Status.Canceled;\n', '\n', '        // Transfer the deposit back to the borrower\n', '        require(mana.transfer(msg.sender, mortgage.deposit), "Error returning MANA");\n', '\n', '        emit CanceledMortgage(msg.sender, id);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Request the cosign of a loan\n', '\n', '        Buys the parcel and locks its ownership until the loan status is resolved.\n', '        Emits an ERC721 to manage the ownership of the mortgaged property.\n', '    \n', '        @param engine Engine of the loan\n', '        @param index Index of the loan\n', '        @param data Data with the mortgage id\n', '        @param oracleData Oracle data to calculate the loan amount\n', '\n', '        @return true If the cosign was performed\n', '    */\n', '    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool) {\n', '        // The first word of the data MUST contain the index of the target mortgage\n', '        Mortgage storage mortgage = mortgages[uint256(readBytes32(data, 0))];\n', '        \n', '        // Validate that the loan matches with the mortgage\n', '        // and the mortgage is still pending\n', '        require(mortgage.engine == engine, "Engine does not match");\n', '        require(mortgage.loanId == index, "Loan id does not match");\n', '        require(mortgage.status == Status.Pending, "Mortgage is not pending");\n', '\n', '        // Update the status of the mortgage to avoid reentrancy\n', '        mortgage.status = Status.Ongoing;\n', '\n', '        // Mint mortgage ERC721 Token\n', '        _generate(uint256(readBytes32(data, 0)), mortgage.owner);\n', '\n', '        // Transfer the amount of the loan in RCN to this contract\n', '        uint256 loanAmount = convertRate(engine.getOracle(index), engine.getCurrency(index), oracleData, engine.getAmount(index));\n', '        require(rcn.transferFrom(mortgage.owner, this, loanAmount), "Error pulling RCN from borrower");\n', '        \n', '        // Convert the RCN into MANA using the designated\n', '        // and save the received MANA\n', '        uint256 boughtMana = convertSafe(mortgage.tokenConverter, rcn, mana, loanAmount);\n', '        delete mortgage.tokenConverter;\n', '\n', '        // Load the new cost of the parcel, it may be changed\n', '        uint256 currentLandCost;\n', '        (, , currentLandCost, ) = landMarket.auctionByAssetId(mortgage.landId);\n', '        require(currentLandCost <= mortgage.landCost, "Parcel is more expensive than expected");\n', '        \n', '        // Buy the land and lock it into the mortgage contract\n', '        require(mana.approve(landMarket, currentLandCost));\n', '        flagReceiveLand = mortgage.landId;\n', '        landMarket.executeOrder(mortgage.landId, currentLandCost);\n', '        require(mana.approve(landMarket, 0));\n', '        require(flagReceiveLand == 0, "ERC721 callback not called");\n', '        require(land.ownerOf(mortgage.landId) == address(this), "Error buying parcel");\n', '\n', '        // Calculate the remaining amount to send to the borrower and \n', "        // check that we didn't expend any contract funds.\n", '        uint256 totalMana = boughtMana.add(mortgage.deposit);        \n', '\n', '        // Return rest of MANA to the owner\n', '        require(mana.transfer(mortgage.owner, totalMana.sub(currentLandCost)), "Error returning MANA");\n', '        \n', '        // Cosign contract, 0 is the RCN required\n', '        require(mortgage.engine.cosign(index, 0), "Error performing cosign");\n', '        \n', '        // Save mortgage id registry\n', '        mortgageByLandId[mortgage.landId] = uint256(readBytes32(data, 0));\n', '\n', '        // Emit mortgage event\n', '        emit StartedMortgage(uint256(readBytes32(data, 0)));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Converts tokens using a token converter\n', '        @dev Does not trust the token converter, validates the return amount\n', '        @param converter Token converter used\n', '        @param from Tokens to sell\n', '        @param to Tokens to buy\n', '        @param amount Amount to sell\n', '        @return bought Bought amount\n', '    */\n', '    function convertSafe(\n', '        TokenConverter converter,\n', '        Token from,\n', '        Token to,\n', '        uint256 amount\n', '    ) internal returns (uint256 bought) {\n', '        require(from.approve(converter, amount));\n', '        uint256 prevBalance = to.balanceOf(this);\n', '        bought = converter.convert(from, to, amount, 1);\n', '        require(to.balanceOf(this).sub(prevBalance) >= bought, "Bought amount incorrect");\n', '        require(from.approve(converter, 0));\n', '    }\n', '\n', '    /**\n', '        @notice Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds.\n', '\n', '        @dev Deletes the mortgage ERC721\n', '\n', '        @param engine RCN Engine\n', '        @param loanId Loan ID\n', '        \n', '        @return true If the claim succeded\n', '    */\n', '    function claim(address engine, uint256 loanId, bytes) external returns (bool) {\n', '        uint256 mortgageId = loanToLiability[engine][loanId];\n', '        Mortgage storage mortgage = mortgages[mortgageId];\n', '\n', "        // Validate that the mortgage wasn't claimed\n", '        require(mortgage.status == Status.Ongoing, "Mortgage not ongoing");\n', '        require(mortgage.loanId == loanId, "Mortgage don\'t match loan id");\n', '\n', '        if (mortgage.engine.getStatus(loanId) == Engine.Status.paid || mortgage.engine.getStatus(loanId) == Engine.Status.destroyed) {\n', '            // The mortgage is paid\n', '            require(_isAuthorized(msg.sender, mortgageId), "Sender not authorized");\n', '\n', '            mortgage.status = Status.Paid;\n', '            // Transfer the parcel to the borrower\n', '            land.safeTransferFrom(this, msg.sender, mortgage.landId);\n', '            emit PaidMortgage(msg.sender, mortgageId);\n', '        } else if (isDefaulted(mortgage.engine, loanId)) {\n', '            // The mortgage is defaulted\n', '            require(msg.sender == mortgage.engine.ownerOf(loanId), "Sender not lender");\n', '            \n', '            mortgage.status = Status.Defaulted;\n', '            // Transfer the parcel to the lender\n', '            land.safeTransferFrom(this, msg.sender, mortgage.landId);\n', '            emit DefaultedMortgage(mortgageId);\n', '        } else {\n', '            revert("Mortgage not defaulted/paid");\n', '        }\n', '\n', '        // ERC721 Delete asset\n', '        _destroy(mortgageId);\n', '\n', '        // Delete mortgage id registry\n', '        delete mortgageByLandId[mortgage.landId];\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Defines a custom logic that determines if a loan is defaulted or not.\n', '\n', '        @param engine RCN Engines\n', '        @param index Index of the loan\n', '\n', '        @return true if the loan is considered defaulted\n', '    */\n', '    function isDefaulted(Engine engine, uint256 index) public view returns (bool) {\n', '        return engine.getStatus(index) == Engine.Status.lent &&\n', '            engine.getDueTime(index).add(7 days) <= block.timestamp;\n', '    }\n', '\n', '    /**\n', '        @dev An alternative version of the ERC721 callback, required by a bug in the parcels contract\n', '    */\n', '    function onERC721Received(uint256 _tokenId, address, bytes) external returns (bytes4) {\n', '        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {\n', '            flagReceiveLand = 0;\n', '            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice Callback used to accept the ERC721 parcel tokens\n', '\n', '        @dev Only accepts tokens if flag is set to tokenId, resets the flag when called\n', '    */\n', '    function onERC721Received(address, uint256 _tokenId, bytes) external returns (bytes4) {\n', '        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {\n', '            flagReceiveLand = 0;\n', '            return bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '        }\n', '    }\n', '\n', '    /**\n', '        @dev Reads data from a bytes array\n', '    */\n', '    function getData(uint256 id) public pure returns (bytes o) {\n', '        assembly {\n', '            o := mload(0x40)\n', '            mstore(0x40, add(o, and(add(add(32, 0x20), 0x1f), not(0x1f))))\n', '            mstore(o, 32)\n', '            mstore(add(o, 32), id)\n', '        }\n', '    }\n', '    \n', '    /**\n', '        @notice Enables the owner of a parcel to update the data field\n', '\n', '        @param id Id of the mortgage\n', '        @param data New data\n', '\n', '        @return true If data was updated\n', '    */\n', '    function updateLandData(uint256 id, string data) external returns (bool) {\n', '        Mortgage memory mortgage = mortgages[id];\n', '        require(_isAuthorized(msg.sender, id), "Sender not authorized");\n', '        int256 x;\n', '        int256 y;\n', '        (x, y) = land.decodeTokenId(mortgage.landId);\n', '        land.updateLandData(x, y, data);\n', '        emit UpdatedLandData(msg.sender, id, data);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev Replica of the convertRate function of the RCN Engine, used to apply the oracle rate\n', '    */\n', '    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) internal returns (uint256) {\n', '        if (oracle == address(0)) {\n', '            return amount;\n', '        } else {\n', '            uint256 rate;\n', '            uint256 decimals;\n', '            \n', '            (rate, decimals) = oracle.getRate(currency, data);\n', '\n', '            require(decimals <= RCN_DECIMALS, "Decimals exceeds max decimals");\n', '            return (amount.mult(rate).mult((10**(RCN_DECIMALS-decimals)))) / PRECISION;\n', '        }\n', '    }\n', '}\n', '\n', 'interface NanoLoanEngine {\n', '    function createLoan(address _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n', '        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256);\n', '    function getIdentifier(uint256 index) public view returns (bytes32);\n', '    function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool);\n', '    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool);\n', '    function rcn() public view returns (Token);\n', '    function getOracle(uint256 index) public view returns (Oracle);\n', '    function getAmount(uint256 index) public view returns (uint256);\n', '    function getCurrency(uint256 index) public view returns (bytes32);\n', '    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public view returns (uint256);\n', '    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool);\n', '    function transfer(address to, uint256 index) public returns (bool);\n', '}\n', '\n', '/**\n', '    @notice Set of functions to operate the mortgage manager in less transactions\n', '*/\n', 'contract MortgageHelper is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    MortgageManager public mortgageManager;\n', '    NanoLoanEngine public nanoLoanEngine;\n', '    Token public rcn;\n', '    Token public mana;\n', '    LandMarket public landMarket;\n', '    TokenConverter public tokenConverter;\n', '    address public converterRamp;\n', '\n', '    address public manaOracle;\n', '    uint256 public requiredTotal = 110;\n', '\n', '    uint256 public rebuyThreshold = 0.001 ether;\n', '    uint256 public marginSpend = 100;\n', '    uint256 public maxSpend = 100;\n', '\n', '    bytes32 public constant MANA_CURRENCY = 0x4d414e4100000000000000000000000000000000000000000000000000000000;\n', '\n', '    event NewMortgage(address borrower, uint256 loanId, uint256 landId, uint256 mortgageId);\n', '    event PaidLoan(address engine, uint256 loanId, uint256 amount);\n', '    event SetConverterRamp(address _prev, address _new);\n', '    event SetTokenConverter(address _prev, address _new);\n', '    event SetRebuyThreshold(uint256 _prev, uint256 _new);\n', '    event SetMarginSpend(uint256 _prev, uint256 _new);\n', '    event SetMaxSpend(uint256 _prev, uint256 _new);\n', '    event SetRequiredTotal(uint256 _prev, uint256 _new);\n', '\n', '    constructor(\n', '        MortgageManager _mortgageManager,\n', '        NanoLoanEngine _nanoLoanEngine,\n', '        Token _rcn,\n', '        Token _mana,\n', '        LandMarket _landMarket,\n', '        address _manaOracle,\n', '        TokenConverter _tokenConverter,\n', '        address _converterRamp\n', '    ) public {\n', '        mortgageManager = _mortgageManager;\n', '        nanoLoanEngine = _nanoLoanEngine;\n', '        rcn = _rcn;\n', '        mana = _mana;\n', '        landMarket = _landMarket;\n', '        manaOracle = _manaOracle;\n', '        tokenConverter = _tokenConverter;\n', '        converterRamp = _converterRamp;\n', '\n', '        emit SetConverterRamp(converterRamp, _converterRamp);\n', '        emit SetTokenConverter(tokenConverter, _tokenConverter);\n', '    }\n', '\n', '    /**\n', '        @dev Creates a loan using an array of parameters\n', '\n', '        @param params 0 - Ammount\n', '                      1 - Interest rate\n', '                      2 - Interest rate punitory\n', '                      3 - Dues in\n', '                      4 - Cancelable at\n', '                      5 - Expiration of request\n', '\n', '        @param metadata Loan metadata\n', '\n', '        @return Id of the loan\n', '\n', '    */\n', '    function createLoan(uint256[6] memory params, string metadata) internal returns (uint256) {\n', '        return nanoLoanEngine.createLoan(\n', '            manaOracle,\n', '            msg.sender,\n', '            MANA_CURRENCY,\n', '            params[0],\n', '            params[1],\n', '            params[2],\n', '            params[3],\n', '            params[4],\n', '            params[5],\n', '            metadata\n', '        );\n', '    }\n', '\n', '    /**\n', '        @notice Sets a max amount to expend when performing the payment\n', '        @dev Only owner\n', '        @param _maxSpend New maxSPend value\n', '        @return true If the change was made\n', '    */\n', '    function setMaxSpend(uint256 _maxSpend) external onlyOwner returns (bool) {\n', '        emit SetMaxSpend(maxSpend, _maxSpend);\n', '        maxSpend = _maxSpend;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets required total of the mortgage\n', '        @dev Only owner\n', '        @param _requiredTotal New requiredTotal value\n', '        @return true If the change was made\n', '    */\n', '    function setRequiredTotal(uint256 _requiredTotal) external onlyOwner returns (bool) {\n', '        emit SetRequiredTotal(requiredTotal, _requiredTotal);\n', '        requiredTotal = _requiredTotal;\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '        @notice Sets a new converter ramp to delegate the pay of the loan\n', '        @dev Only owner\n', '        @param _converterRamp Address of the converter ramp contract\n', '        @return true If the change was made\n', '    */\n', '    function setConverterRamp(address _converterRamp) external onlyOwner returns (bool) {\n', '        emit SetConverterRamp(converterRamp, _converterRamp);\n', '        converterRamp = _converterRamp;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets a new min of tokens to rebuy when paying a loan\n', '        @dev Only owner\n', '        @param _rebuyThreshold New rebuyThreshold value\n', '        @return true If the change was made\n', '    */\n', '    function setRebuyThreshold(uint256 _rebuyThreshold) external onlyOwner returns (bool) {\n', '        emit SetRebuyThreshold(rebuyThreshold, _rebuyThreshold);\n', '        rebuyThreshold = _rebuyThreshold;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets how much the converter ramp is going to oversell to cover fees and gaps\n', '        @dev Only owner\n', '        @param _marginSpend New marginSpend value\n', '        @return true If the change was made\n', '    */\n', '    function setMarginSpend(uint256 _marginSpend) external onlyOwner returns (bool) {\n', '        emit SetMarginSpend(marginSpend, _marginSpend);\n', '        marginSpend = _marginSpend;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Sets the token converter used to convert the MANA into RCN when performing the payment\n', '        @dev Only owner\n', '        @param _tokenConverter Address of the tokenConverter contract\n', '        @return true If the change was made\n', '    */\n', '    function setTokenConverter(TokenConverter _tokenConverter) external onlyOwner returns (bool) {\n', '        emit SetTokenConverter(tokenConverter, _tokenConverter);\n', '        tokenConverter = _tokenConverter;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice Request a loan and attachs a mortgage request\n', '\n', '        @dev Requires the loan signed by the borrower\n', '\n', '        @param loanParams   0 - Ammount\n', '                            1 - Interest rate\n', '                            2 - Interest rate punitory\n', '                            3 - Dues in\n', '                            4 - Cancelable at\n', '                            5 - Expiration of request\n', '        @param metadata Loan metadata\n', '        @param landId Land to buy with the mortgage\n', '        @param v Loan signature by the borrower\n', '        @param r Loan signature by the borrower\n', '        @param s Loan signature by the borrower\n', '\n', '        @return The id of the mortgage\n', '    */\n', '    function requestMortgage(\n', '        uint256[6] loanParams,\n', '        string metadata,\n', '        uint256 landId,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256) {\n', '        // Create a loan with the loanParams and metadata\n', '        uint256 loanId = createLoan(loanParams, metadata);\n', '\n', '        // Approve the created loan with the provided signature\n', '        require(nanoLoanEngine.registerApprove(nanoLoanEngine.getIdentifier(loanId), v, r, s), "Signature not valid");\n', '\n', '        // Calculate the requested amount for the mortgage deposit\n', '        uint256 landCost;\n', '        (, , landCost, ) = landMarket.auctionByAssetId(landId);\n', '        uint256 requiredDeposit = ((landCost * requiredTotal) / 100) - nanoLoanEngine.getAmount(loanId);\n', '        \n', '        // Pull the required deposit amount\n', '        require(mana.transferFrom(msg.sender, this, requiredDeposit), "Error pulling MANA");\n', '        require(mana.approve(mortgageManager, requiredDeposit));\n', '\n', '        // Create the mortgage request\n', '        uint256 mortgageId = mortgageManager.requestMortgageId(Engine(nanoLoanEngine), loanId, requiredDeposit, landId, tokenConverter);\n', '        emit NewMortgage(msg.sender, loanId, landId, mortgageId);\n', '        \n', '        return mortgageId;\n', '    }\n', '\n', '    /**\n', '        @notice Pays a loan using mana\n', '\n', '        @dev The amount to pay must be set on mana\n', '\n', '        @param engine RCN Engine\n', '        @param loan Loan id to pay\n', '        @param amount Amount in MANA to pay\n', '\n', '        @return True if the payment was performed\n', '    */\n', '    function pay(address engine, uint256 loan, uint256 amount) external returns (bool) {\n', '        emit PaidLoan(engine, loan, amount);\n', '\n', '        bytes32[4] memory loanParams = [\n', '            bytes32(engine),\n', '            bytes32(loan),\n', '            bytes32(amount),\n', '            bytes32(msg.sender)\n', '        ];\n', '\n', '        uint256[3] memory converterParams = [\n', '            marginSpend,\n', '            amount.mult(uint256(100000).add(maxSpend)) / 100000,\n', '            rebuyThreshold\n', '        ];\n', '\n', '        require(address(converterRamp).delegatecall(\n', '            bytes4(0x86ee863d),\n', '            address(tokenConverter),\n', '            address(mana),\n', '            loanParams,\n', '            0x140,\n', '            converterParams,\n', '            0x0\n', '        ), "Error delegate pay call");\n', '    }\n', '}']
