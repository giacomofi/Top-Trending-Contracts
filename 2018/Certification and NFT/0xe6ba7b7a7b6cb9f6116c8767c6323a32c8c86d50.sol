['pragma solidity ^0.4.25;\n', '\n', 'contract Token{\n', '    using SafeMath for *;\n', '    uint256 public totalSupply;\n', '    string public name;                 //name of token\n', '    string public symbol;               //symbol of token\n', '    uint256 public decimals;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) public view returns\n', '    (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256  _value);\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '    bool public paused;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier normal {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    function upgradeOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '\n', '    function setPaused(bool _paused) onlyOwner public {\n', '        paused = _paused;\n', '    }\n', '}\n', '\n', 'contract BonusState{\n', '    constructor(address _tokenAddress) public{\n', '        tokenAddress = _tokenAddress;\n', '        settlementTime = 10 days + now;\n', '    }\n', '\n', '    //balance for bonus compute withdraw, when withdraw and balance is zero means\n', '    //1. no balance for owner\n', '    //2. nerver update state\n', '    //so when withdraw, check balance state, when state is zero, check token balance\n', '    mapping(address=>uint256) balanceState;\n', '    //state is true while withdrawed\n', '    mapping(address=>bool) withdrawState;\n', '    //computedTotalBalance means this amount has been locked for withdraw, so when computing lockBonus,base amount will exclude this amount\n', '    uint256 computedTotalBalance = 0;\n', '    //price for token holder use this to compute withdrawable bonus for unit amount(unit amount means one exclude decimals)\n', '    uint256 computedUnitPrice = 0;\n', '    //while times up, next transaction for contract will auto settle bonus\n', '    uint256 settlementTime = 0;\n', '\n', '\n', '    //token contract address, only contract can operate this state contract\n', '    address public tokenAddress;\n', '    modifier onlyToken {\n', '        require(msg.sender == tokenAddress);\n', '        _;\n', '    }\n', '\n', '    function getSettlementTime() public view returns(uint256 _time){\n', '        return settlementTime;\n', '    }\n', '\n', '    function setBalanceState(address _target,uint256 _amount) public onlyToken{\n', '        balanceState[_target] = _amount;\n', '    }\n', '\n', '    function getBalanceState(address _target) public view returns (uint256 _balance) {\n', '        return balanceState[_target];\n', '    }\n', '\n', '\n', '    function setWithdrawState(address _target,bool _state) public onlyToken{\n', '        withdrawState[_target] = _state;\n', '    }\n', '\n', '    function getWithdrawState(address _target) public view returns (bool _state) {\n', '        return withdrawState[_target];\n', '    }\n', '\n', '\n', '    function setComputedTotalBalance(uint256 _amount) public onlyToken{\n', '        computedTotalBalance = _amount;\n', '    }\n', '\n', '    function setComputedUnitPrice(uint256 _amount) public onlyToken{\n', '        computedUnitPrice = _amount;\n', '    }\n', '\n', '    function getComputedTotalBalance() public view returns(uint256){\n', '        return computedTotalBalance;\n', '    }\n', '\n', '    function getComputedUnitPrice() public view returns(uint256){\n', '        return computedUnitPrice;\n', '    }\n', '\n', '}\n', '\n', 'contract EssToken is Token,owned {\n', '\n', '    //bonus state never change for withdraw;\n', '    address public bonusState_fixed;\n', '\n', '    //bonus state change while balance modified by transfer\n', '    address public bonusState;\n', '\n', '    //transfer eth to contract means incharge the bonus\n', '    function() public payable normal{\n', '        computeBonus(msg.value);\n', '    }\n', '    function incharge() public payable normal{\n', '        computeBonus(msg.value);\n', '    }\n', '\n', '    uint256 public icoTotal;\n', '\n', '    uint256 public airdropTotal;\n', '\n', '    //empty token while deploy the contract, token will minted by ico or minted by owner after ico\n', '    constructor() public {\n', '        decimals = 18;\n', '        name = "Ether Sesame";\n', '        symbol = "ESS";\n', '        totalSupply = 100000000 * 10 ** decimals;\n', '        icoTotal = totalSupply * 30 / 100; //30% for ico\n', '        airdropTotal = totalSupply * 20 / 100;  //20% for airdrop\n', '        uint256 _initAmount = totalSupply - icoTotal - airdropTotal;\n', '        bonusState = new BonusState(address(this));\n', '        _mintToken(msg.sender,_initAmount);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public normal returns (bool success) {\n', '        computeBonus(0);\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public normal returns\n', '    (bool success) {\n', '        computeBonus(0);\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowed\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public normal returns (bool success)\n', '    {\n', '        computeBonus(0);\n', '        allowed[tx.origin][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];//允许_spender从_owner中转出的token数\n', '    }\n', '    //end for ERC20 Token standard\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[_from] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '        // Subtract from the sender\n', '        balances[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balances[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '\n', '        //update bonus state when balance changed\n', '        BonusState(bonusState).setBalanceState(_from,balances[_from]);\n', '        BonusState(bonusState).setBalanceState(_to,balances[_to]);\n', '    }\n', '\n', '    //mint token for ico purchase or airdrop\n', '    function _mintToken(address _target, uint256 _mintAmount) internal {\n', '        require(_mintAmount>0);\n', '        balances[this] = (balances[this]).add(_mintAmount);\n', '        //update bonus state when balance changed\n', '        BonusState(bonusState).setBalanceState(address(this),balances[this]);\n', '        _transfer(this,_target,_mintAmount);\n', '    }\n', '\n', '    //check lockbonus for target\n', '    function lockedBonus(address _target) public view returns(uint256 bonus){\n', '        if(BonusState(bonusState).getSettlementTime()<=now)\n', '\t    {\n', '\t        return 0;\n', '\t    }\n', '\t    else{\n', '\t        uint256 _balance = balances[_target];\n', '            uint256 _fixedBonusTotal = lockBonusTotal();\n', '\n', '            uint256 _unitPrice = ((address(this).balance).sub(_fixedBonusTotal)).div(totalSupply.div(10**decimals));\n', '            return _balance.mul(_unitPrice).div(10**decimals);\n', '\t    }\n', '    }\n', '\n', '\tfunction lockBonusTotal() public view returns(uint256 bonus){\n', '\t    if(BonusState(bonusState).getSettlementTime()<=now)\n', '\t    {\n', '\t        return address(this).balance;\n', '\t    }\n', '\t    else{\n', '\t        uint256 _fixedBonusTotal = 0;\n', '            if(bonusState_fixed!=address(0x0))\n', '            {\n', '                _fixedBonusTotal = BonusState(bonusState_fixed).getComputedTotalBalance();\n', '            }\n', '    \t\treturn _fixedBonusTotal;\n', '\t    }\n', '\t}\n', '\n', '    function _withdrawableBonus(address _target) internal view returns(uint256 bonus){\n', '        uint256 _unitPrice;\n', '        uint256 _bonusBalance;\n', '        if(BonusState(bonusState).getSettlementTime()<=now){\n', '            _unitPrice = (address(this).balance).div(totalSupply.div(10**decimals));\n', '            _bonusBalance = balances[_target];\n', '            return _bonusBalance.mul(_unitPrice).div(10**decimals);\n', '        }\n', '        else{\n', '            if(bonusState_fixed==address(0x0))\n', '            {\n', '                return 0;\n', '            }\n', '            else{\n', '                bool _withdrawState = BonusState(bonusState_fixed).getWithdrawState(_target);\n', '        \t\t//withdraw only once for each bonus compute\n', '        \t\tif(_withdrawState)\n', '        \t\t\treturn 0;\n', '        \t\telse\n', '        \t\t{\n', '        \t\t\t_unitPrice = BonusState(bonusState_fixed).getComputedUnitPrice();\n', '        \t\t\t_bonusBalance = BonusState(bonusState_fixed).getBalanceState(_target);\n', '        \t\t\t//when bonus balance is zero and withdraw state is false means possibly state never changed after last compute bonus\n', '        \t\t\t//so try to check token balance,if balance has token means never change state\n', '        \t\t\tif(_bonusBalance==0){\n', '        \t\t\t\t_bonusBalance = balances[_target];\n', '        \t\t\t}\n', '        \t\t\treturn _bonusBalance.mul(_unitPrice).div(10**decimals);\n', '        \t\t}\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdrawableBonus(address _target)  public view returns(uint256 bonus){\n', '        return _withdrawableBonus(_target);\n', '    }\n', '\n', '    //compute bonus for withdraw and reset bonus state\n', '    function computeBonus(uint256 _incharge) internal {\n', '        if(BonusState(bonusState).getSettlementTime()<=now){\n', '            BonusState(bonusState).setComputedTotalBalance((address(this).balance).sub(_incharge));\n', '            BonusState(bonusState).setComputedUnitPrice((address(this).balance).sub(_incharge).div(totalSupply.div(10**decimals)));\n', '            bonusState_fixed = bonusState; //set current bonus as fixed bonus state\n', '            bonusState = new BonusState(address(this)); //deploy a new bonus state contract\n', '        }\n', '    }\n', '\n', '    function getSettlementTime() public view returns(uint256 _time){\n', '        return BonusState(bonusState).getSettlementTime();\n', '    }\n', '\n', '    //withdraw the bonus\n', '    function withdraw() public normal{\n', '        computeBonus(0);\n', '        //calc the withdrawable amount\n', '        uint256 _bonusAmount = _withdrawableBonus(msg.sender);\n', '        msg.sender.transfer(_bonusAmount);\n', '\n', '        //set withdraw state to true,means bonus has withdrawed\n', '        BonusState(bonusState_fixed).setWithdrawState(msg.sender,true);\n', '        uint256 _fixedBonusTotal = 0;\n', '        if(bonusState_fixed!=address(0x0))\n', '        {\n', '            _fixedBonusTotal = BonusState(bonusState_fixed).getComputedTotalBalance();\n', '        }\n', '        BonusState(bonusState_fixed).setComputedTotalBalance(_fixedBonusTotal.sub(_bonusAmount));\n', '    }\n', '\n', '}\n', '\n', 'contract EtherSesame is EssToken{\n', '\n', '    //about ico\n', '    uint256 public icoCount;\n', '\n', '\n', '    uint256 public beginTime;\n', '    uint256 public endTime;\n', '\n', '    uint256 public offeredAmount;\n', '\n', '    //the eth price(wei) of one ess(one ess means number exclude the decimals)\n', '    uint256 public icoPrice;\n', '\n', '    function isOffering() public view returns(bool){\n', '        return beginTime>0&&now>beginTime&&now<endTime&&icoTotal>0;\n', '    }\n', '\n', '    function startIco(uint256 _beginTime,uint256 _endTime,uint256 _icoPrice) public onlyOwner{\n', '        require(_beginTime>0&&_endTime>_beginTime&&_icoPrice>0);\n', '        beginTime  = _beginTime;\n', '        endTime  = _endTime;\n', '        icoPrice = _icoPrice;\n', '        icoCount++;\n', '    }\n', '\n', '    function buy() public payable normal{\n', '        computeBonus(msg.value);\n', '        //ico activity is started and must buy one ess at least\n', '        require(isOffering()&&msg.value>=icoPrice);\n', '        uint256 _amount = (msg.value).div(icoPrice).mul(10**decimals);\n', '        offeredAmount = offeredAmount.add(_amount);  //increase the offeredAmount for this round\n', '        icoTotal = icoTotal.sub(_amount);\n', '        owner.transfer(msg.value);\n', '        _mintToken(msg.sender,_amount);\n', '    }\n', '    //end ico\n', '\n', '    //about airdrop\n', '    //authed address for airdrop\n', '    address public airdropAuthAddress;\n', '    //update airdrop auth\n', '    function upgradeAirdropAuthAddress(address newAirdropAuthAddress) onlyOwner public {\n', '        airdropAuthAddress = newAirdropAuthAddress;\n', '    }\n', '    modifier airdropAuthed {\n', '        require(msg.sender == airdropAuthAddress);\n', '        _;\n', '    }\n', '\n', '    //airdrop to player amount: (_ethPayment/_airdropPrice)\n', '    function airdrop(uint256 _airdropPrice,uint256 _ethPayment) public airdropAuthed normal returns(uint256){\n', '        computeBonus(0);\n', '        if(_airdropPrice>0&&_ethPayment/_airdropPrice>0&&airdropTotal>0){\n', '            uint256 _airdropAmount = _ethPayment.div(_airdropPrice);\n', '            if(_airdropAmount>=airdropTotal){\n', '                _airdropAmount = airdropTotal;\n', '            }\n', '            if(_airdropAmount>0)\n', '            {\n', '                _airdropAmount = _airdropAmount.mul(10 ** decimals);\n', '                airdropTotal-=_airdropAmount;\n', '                _mintToken(tx.origin,_airdropAmount);\n', '            }\n', '            return _airdropAmount;\n', '        }\n', '        else{\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev divide two numbers, throws on overflow.\n', '    */\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        require(b > 0);\n', '        c = a / b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}']