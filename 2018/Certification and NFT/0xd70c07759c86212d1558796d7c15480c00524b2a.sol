['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/******* USING MONARCHYFACTORY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getPaf(): returns current IPaf instance\n', '    [modifier] .fromPaf(): requires the sender is current Paf.\n', '\n', '*************************************************/\n', '// Returned by .getMonarchyFactory()\n', 'interface IMonarchyFactory {\n', '    function lastCreatedGame() external view returns (address _game);\n', '    function getCollector() external view returns (address _collector);\n', '}\n', '\n', 'contract UsingMonarchyFactory is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromMonarchyFactory(){ \n', '        require(msg.sender == address(getMonarchyFactory()));\n', '        _;\n', '    }\n', '\n', '    function getMonarchyFactory()\n', '        public\n', '        view\n', '        returns (IMonarchyFactory)\n', '    {\n', '        return IMonarchyFactory(addressOf("MONARCHY_FACTORY"));\n', '    }\n', '}\n', '\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    Exposes the following internal methods:\n', '        - _useFromDailyLimit(uint)\n', '        - _setDailyLimit(uint)\n', '        - getDailyLimit()\n', '        - getDailyLimitUsed()\n', '        - getDailyLimitUnused()\n', '*/\n', 'contract HasDailyLimit {\n', '    // squeeze all vars into one storage slot.\n', '    struct DailyLimitVars {\n', '        uint112 dailyLimit; // Up to 5e15 * 1e18.\n', '        uint112 usedToday;  // Up to 5e15 * 1e18.\n', '        uint32 lastDay;     // Up to the year 11,000,000 AD\n', '    }\n', '    DailyLimitVars private vars;\n', '    uint constant MAX_ALLOWED = 2**112 - 1;\n', '\n', '    constructor(uint _limit) public {\n', '        _setDailyLimit(_limit);\n', '    }\n', '\n', '    // Sets the daily limit.\n', '    function _setDailyLimit(uint _limit) internal {\n', '        require(_limit <= MAX_ALLOWED);\n', '        vars.dailyLimit = uint112(_limit);\n', '    }\n', '\n', '    // Uses the requested amount if its within limit. Or throws.\n', '    // You should use getDailyLimitRemaining() before calling this.\n', '    function _useFromDailyLimit(uint _amount) internal {\n', '        uint _remaining = updateAndGetRemaining();\n', '        require(_amount <= _remaining);\n', '        vars.usedToday += uint112(_amount);\n', '    }\n', '\n', '    // If necessary, resets the day&#39;s usage.\n', '    // Then returns the amount remaining for today.\n', '    function updateAndGetRemaining() private returns (uint _amtRemaining) {\n', '        if (today() > vars.lastDay) {\n', '            vars.usedToday = 0;\n', '            vars.lastDay = today();\n', '        }\n', '        uint112 _usedToday = vars.usedToday;\n', '        uint112 _dailyLimit = vars.dailyLimit;\n', '        // This could be negative if _dailyLimit was reduced.\n', '        return uint(_usedToday >= _dailyLimit ? 0 : _dailyLimit - _usedToday);\n', '    }\n', '\n', '    // Returns the current day.\n', '    function today() private view returns (uint32) {\n', '        return uint32(block.timestamp / 1 days);\n', '    }\n', '\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    ////////////// PUBLIC VIEWS /////////////////////////////////////\n', '    /////////////////////////////////////////////////////////////////\n', '\n', '    function getDailyLimit() public view returns (uint) {\n', '        return uint(vars.dailyLimit);\n', '    }\n', '    function getDailyLimitUsed() public view returns (uint) {\n', '        return uint(today() > vars.lastDay ? 0 : vars.usedToday);\n', '    }\n', '    function getDailyLimitRemaining() public view returns (uint) {\n', '        uint _used = getDailyLimitUsed();\n', '        return uint(_used >= vars.dailyLimit ? 0 : vars.dailyLimit - _used);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', '    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it&#39;s safe to\n', '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If it doesn&#39;t exist already, there is nothing to do.\n', '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '// An interface to MonarchyGame instances.\n', 'interface IMonarchyGame {\n', '    function sendPrize(uint _gasLimit) external returns (bool _success, uint _prizeSent);\n', '    function sendFees() external returns (uint _feesSent);\n', '    function prize() external view returns(uint);\n', '    function numOverthrows() external view returns(uint);\n', '    function fees() external view returns (uint _fees);\n', '    function monarch() external view returns (address _addr);\n', '    function isEnded() external view returns (bool _bool);\n', '    function isPaid() external view returns (bool _bool);\n', '}\n', '\n', '/*\n', '\n', '  MonarchyController manages a list of PredefinedGames.\n', '  PredefinedGames&#39; parameters are definable by the Admin.\n', '  These gamess can be started, ended, or refreshed by anyone.\n', '\n', '  Starting games uses the funds in this contract, unless called via\n', '  .startDefinedGameManually(), in which case it uses the funds sent.\n', '\n', '  All revenues of any started games will come back to this contract.\n', '\n', '  Since this contract inherits Bankrollable, it is able to be funded\n', '  via the Registry (or by anyone whitelisted). Profits will go to the\n', '  Treasury, and can be triggered by anyone.\n', '\n', '*/\n', 'contract MonarchyController is\n', '    HasDailyLimit,\n', '    Bankrollable,\n', '    UsingAdmin,\n', '    UsingMonarchyFactory\n', '{\n', '    uint constant public version = 1;\n', '\n', '    // just some accounting/stats stuff to keep track of\n', '    uint public totalFees;\n', '    uint public totalPrizes;\n', '    uint public totalOverthrows;\n', '    IMonarchyGame[] public endedGames;\n', '\n', '    // An admin-controlled index of available games.\n', '    // Note: Index starts at 1, and is limited to 20.\n', '    uint public numDefinedGames;\n', '    mapping (uint => DefinedGame) public definedGames;\n', '    struct DefinedGame {\n', '        IMonarchyGame game;     // address of ongoing game (or 0)\n', '        bool isEnabled;         // if true, can be started\n', '        string summary;         // definable via editDefinedGame\n', '        uint initialPrize;      // definable via editDefinedGame\n', '        uint fee;               // definable via editDefinedGame\n', '        int prizeIncr;          // definable via editDefinedGame\n', '        uint reignBlocks;       // definable via editDefinedGame\n', '        uint initialBlocks;     // definable via editDefinedGame\n', '    }\n', '\n', '    event Created(uint time);\n', '    event DailyLimitChanged(uint time, address indexed owner, uint newValue);\n', '    event Error(uint time, string msg);\n', '    event DefinedGameEdited(uint time, uint index);\n', '    event DefinedGameEnabled(uint time, uint index, bool isEnabled);\n', '    event DefinedGameFailedCreation(uint time, uint index);\n', '    event GameStarted(uint time, uint indexed index, address indexed addr, uint initialPrize);\n', '    event GameEnded(uint time, uint indexed index, address indexed addr, address indexed winner);\n', '    event FeesCollected(uint time, uint amount);\n', '\n', '\n', '    constructor(address _registry) \n', '        HasDailyLimit(10 ether)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        UsingMonarchyFactory(_registry)\n', '        public\n', '    {\n', '        emit Created(now);\n', '    }\n', '\n', '    /*************************************************************/\n', '    /******** OWNER FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    function setDailyLimit(uint _amount)\n', '        public\n', '        fromOwner\n', '    {\n', '        _setDailyLimit(_amount);\n', '        emit DailyLimitChanged(now, msg.sender, _amount);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******** ADMIN FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    // allows admin to edit or add an available game\n', '    function editDefinedGame(\n', '        uint _index,\n', '        string _summary,\n', '        uint _initialPrize,\n', '        uint _fee,\n', '        int _prizeIncr,\n', '        uint _reignBlocks,\n', '        uint _initialBlocks\n', '    )\n', '        public\n', '        fromAdmin\n', '        returns (bool _success)\n', '    {\n', '        if (_index-1 > numDefinedGames || _index > 20) {\n', '            emit Error(now, "Index out of bounds.");\n', '            return;\n', '        }\n', '\n', '        if (_index-1 == numDefinedGames) numDefinedGames++;\n', '        definedGames[_index].summary = _summary;\n', '        definedGames[_index].initialPrize = _initialPrize;\n', '        definedGames[_index].fee = _fee;\n', '        definedGames[_index].prizeIncr = _prizeIncr;\n', '        definedGames[_index].reignBlocks = _reignBlocks;\n', '        definedGames[_index].initialBlocks = _initialBlocks;\n', '        emit DefinedGameEdited(now, _index);\n', '        return true;\n', '    }\n', '\n', '    function enableDefinedGame(uint _index, bool _bool)\n', '        public\n', '        fromAdmin\n', '        returns (bool _success)\n', '    {\n', '        if (_index-1 >= numDefinedGames) {\n', '            emit Error(now, "Index out of bounds.");\n', '            return;\n', '        }\n', '        definedGames[_index].isEnabled = _bool;\n', '        emit DefinedGameEnabled(now, _index, _bool);\n', '        return true;\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******* PUBLIC FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    function () public payable {\n', '         totalFees += msg.value;\n', '    }\n', '\n', '    // This is called by anyone when a new MonarchyGame should be started.\n', '    // In reality will only be called by TaskManager.\n', '    //\n', '    // Errors if:\n', '    //      - isEnabled is false (or doesnt exist)\n', '    //      - game is already started\n', '    //      - not enough funds\n', '    //      - PAF.getCollector() points to another address\n', '    //      - unable to create game\n', '    function startDefinedGame(uint _index)\n', '        public\n', '        returns (address _game)\n', '    {\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (_index-1 >= numDefinedGames) {\n', '            _error("Index out of bounds.");\n', '            return;\n', '        }\n', '        if (dGame.isEnabled == false) {\n', '            _error("DefinedGame is not enabled.");\n', '            return;\n', '        }\n', '        if (dGame.game != IMonarchyGame(0)) {\n', '            _error("Game is already started.");\n', '            return;\n', '        }\n', '        if (address(this).balance < dGame.initialPrize) {\n', '            _error("Not enough funds to start this game.");\n', '            return;\n', '        }\n', '        if (getDailyLimitRemaining() < dGame.initialPrize) {\n', '            _error("Starting game would exceed daily limit.");\n', '            return;\n', '        }\n', '\n', '        // Ensure that if this game is started, revenue comes back to this contract.\n', '        IMonarchyFactory _mf = getMonarchyFactory();\n', '        if (_mf.getCollector() != address(this)){\n', '            _error("MonarchyFactory.getCollector() points to a different contract.");\n', '            return;\n', '        }\n', '\n', '        // Try to create game via factory.\n', '        bool _success = address(_mf).call.value(dGame.initialPrize)(\n', '            bytes4(keccak256("createGame(uint256,uint256,int256,uint256,uint256)")),\n', '            dGame.initialPrize,\n', '            dGame.fee,\n', '            dGame.prizeIncr,\n', '            dGame.reignBlocks,\n', '            dGame.initialBlocks\n', '        );\n', '        if (!_success) {\n', '            emit DefinedGameFailedCreation(now, _index);\n', '            _error("MonarchyFactory could not create game (invalid params?)");\n', '            return;\n', '        }\n', '\n', '        // Get the game, add it to definedGames, and return.\n', '        _useFromDailyLimit(dGame.initialPrize);\n', '        _game = _mf.lastCreatedGame();\n', '        definedGames[_index].game = IMonarchyGame(_game);\n', '        emit GameStarted(now, _index, _game, dGame.initialPrize);\n', '        return _game;\n', '    }\n', '        // Emits an error with a given message\n', '        function _error(string _msg)\n', '            private\n', '        {\n', '            emit Error(now, _msg);\n', '        }\n', '\n', '    function startDefinedGameManually(uint _index)\n', '        public\n', '        payable\n', '        returns (address _game)\n', '    {\n', '        // refund if invalid value sent.\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (msg.value != dGame.initialPrize) {\n', '            _error("Value sent does not match initialPrize.");\n', '            require(msg.sender.call.value(msg.value)());\n', '            return;\n', '        }\n', '\n', '        // refund if .startDefinedGame fails\n', '        _game = startDefinedGame(_index);\n', '        if (_game == address(0)) {\n', '            require(msg.sender.call.value(msg.value)());\n', '        }\n', '    }\n', '\n', '    // Looks at all active defined games and:\n', '    //  - tells each game to send fees to collector (us)\n', '    //  - if ended: tries to pay winner, moves to endedGames\n', '    function refreshGames()\n', '        public\n', '        returns (uint _numGamesEnded, uint _feesCollected)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            IMonarchyGame _game = definedGames[_i].game;\n', '            if (_game == IMonarchyGame(0)) continue;\n', '\n', '            // redeem the fees\n', '            uint _fees = _game.sendFees();\n', '            _feesCollected += _fees;\n', '\n', '            // attempt to pay winner, update stats, and set game to empty.\n', '            if (_game.isEnded()) {\n', '                // paying the winner can error if the winner uses too much gas\n', '                // in that case, they can call .sendPrize() themselves later.\n', '                if (!_game.isPaid()) _game.sendPrize(2300);\n', '                \n', '                // update stats\n', '                totalPrizes += _game.prize();\n', '                totalOverthrows += _game.numOverthrows();\n', '\n', '                // clear game, move to endedGames, update return\n', '                definedGames[_i].game = IMonarchyGame(0);\n', '                endedGames.push(_game);\n', '                _numGamesEnded++;\n', '\n', '                emit GameEnded(now, _i, address(_game), _game.monarch());\n', '            }\n', '        }\n', '        if (_feesCollected > 0) emit FeesCollected(now, _feesCollected);\n', '        return (_numGamesEnded, _feesCollected);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*********** PUBLIC VIEWS ************************************/\n', '    /*************************************************************/\n', '    // IMPLEMENTS: Bankrollable.getCollateral()\n', '    function getCollateral() public view returns (uint) { return 0; }\n', '    function getWhitelistOwner() public view returns (address){ return getAdmin(); }\n', '\n', '    function numEndedGames()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return endedGames.length;\n', '    }\n', '\n', '    function numActiveGames()\n', '        public\n', '        view\n', '        returns (uint _count)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (definedGames[_i].game != IMonarchyGame(0)) _count++;\n', '        }\n', '    }\n', '\n', '    function getNumEndableGames()\n', '        public\n', '        view\n', '        returns (uint _count)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            IMonarchyGame _game = definedGames[_i].game;\n', '            if (_game == IMonarchyGame(0)) continue;\n', '            if (_game.isEnded()) _count++;\n', '        }\n', '        return _count;\n', '    }\n', '\n', '    function getFirstStartableIndex()\n', '        public\n', '        view\n', '        returns (uint _index)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (getIsStartable(_i)) return _i;\n', '        }\n', '    }\n', '\n', '    // Gets total amount of fees that are redeemable if refreshGames() is called.\n', '    function getAvailableFees()\n', '        public\n', '        view\n', '        returns (uint _feesAvailable)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (definedGames[_i].game == IMonarchyGame(0)) continue;\n', '            _feesAvailable += definedGames[_i].game.fees();\n', '        }\n', '        return _feesAvailable;\n', '    }\n', '\n', '    function recentlyEndedGames(uint _num)\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // set _num to Min(_num, _len), initialize the array\n', '        uint _len = endedGames.length;\n', '        if (_num > _len) _num = _len;\n', '        _addresses = new address[](_num);\n', '\n', '        // Loop _num times, adding from end of endedGames.\n', '        uint _i = 1;\n', '        while (_i <= _num) {\n', '            _addresses[_i - 1] = endedGames[_len - _i];\n', '            _i++;\n', '        }\n', '    }\n', '\n', '    /******** Shorthand access to definedGames **************************/\n', '    function getGame(uint _index)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return address(definedGames[_index].game);\n', '    }\n', '\n', '    function getIsEnabled(uint _index)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return definedGames[_index].isEnabled;\n', '    }\n', '\n', '    function getInitialPrize(uint _index)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return definedGames[_index].initialPrize;\n', '    }\n', '\n', '    function getIsStartable(uint _index)\n', '        public\n', '        view\n', '        returns (bool _isStartable)\n', '    {\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (_index >= numDefinedGames) return;\n', '        if (dGame.isEnabled == false) return;\n', '        if (dGame.game != IMonarchyGame(0)) return;\n', '        if (dGame.initialPrize > address(this).balance) return;\n', '        if (dGame.initialPrize > getDailyLimitRemaining()) return;\n', '        return true;\n', '    }\n', '    /******** Shorthand access to definedGames **************************/\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/******* USING MONARCHYFACTORY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getPaf(): returns current IPaf instance\n', '    [modifier] .fromPaf(): requires the sender is current Paf.\n', '\n', '*************************************************/\n', '// Returned by .getMonarchyFactory()\n', 'interface IMonarchyFactory {\n', '    function lastCreatedGame() external view returns (address _game);\n', '    function getCollector() external view returns (address _collector);\n', '}\n', '\n', 'contract UsingMonarchyFactory is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromMonarchyFactory(){ \n', '        require(msg.sender == address(getMonarchyFactory()));\n', '        _;\n', '    }\n', '\n', '    function getMonarchyFactory()\n', '        public\n', '        view\n', '        returns (IMonarchyFactory)\n', '    {\n', '        return IMonarchyFactory(addressOf("MONARCHY_FACTORY"));\n', '    }\n', '}\n', '\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '\n', '/*\n', '    Exposes the following internal methods:\n', '        - _useFromDailyLimit(uint)\n', '        - _setDailyLimit(uint)\n', '        - getDailyLimit()\n', '        - getDailyLimitUsed()\n', '        - getDailyLimitUnused()\n', '*/\n', 'contract HasDailyLimit {\n', '    // squeeze all vars into one storage slot.\n', '    struct DailyLimitVars {\n', '        uint112 dailyLimit; // Up to 5e15 * 1e18.\n', '        uint112 usedToday;  // Up to 5e15 * 1e18.\n', '        uint32 lastDay;     // Up to the year 11,000,000 AD\n', '    }\n', '    DailyLimitVars private vars;\n', '    uint constant MAX_ALLOWED = 2**112 - 1;\n', '\n', '    constructor(uint _limit) public {\n', '        _setDailyLimit(_limit);\n', '    }\n', '\n', '    // Sets the daily limit.\n', '    function _setDailyLimit(uint _limit) internal {\n', '        require(_limit <= MAX_ALLOWED);\n', '        vars.dailyLimit = uint112(_limit);\n', '    }\n', '\n', '    // Uses the requested amount if its within limit. Or throws.\n', '    // You should use getDailyLimitRemaining() before calling this.\n', '    function _useFromDailyLimit(uint _amount) internal {\n', '        uint _remaining = updateAndGetRemaining();\n', '        require(_amount <= _remaining);\n', '        vars.usedToday += uint112(_amount);\n', '    }\n', '\n', "    // If necessary, resets the day's usage.\n", '    // Then returns the amount remaining for today.\n', '    function updateAndGetRemaining() private returns (uint _amtRemaining) {\n', '        if (today() > vars.lastDay) {\n', '            vars.usedToday = 0;\n', '            vars.lastDay = today();\n', '        }\n', '        uint112 _usedToday = vars.usedToday;\n', '        uint112 _dailyLimit = vars.dailyLimit;\n', '        // This could be negative if _dailyLimit was reduced.\n', '        return uint(_usedToday >= _dailyLimit ? 0 : _dailyLimit - _usedToday);\n', '    }\n', '\n', '    // Returns the current day.\n', '    function today() private view returns (uint32) {\n', '        return uint32(block.timestamp / 1 days);\n', '    }\n', '\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    ////////////// PUBLIC VIEWS /////////////////////////////////////\n', '    /////////////////////////////////////////////////////////////////\n', '\n', '    function getDailyLimit() public view returns (uint) {\n', '        return uint(vars.dailyLimit);\n', '    }\n', '    function getDailyLimitUsed() public view returns (uint) {\n', '        return uint(today() > vars.lastDay ? 0 : vars.usedToday);\n', '    }\n', '    function getDailyLimitRemaining() public view returns (uint) {\n', '        uint _used = getDailyLimitUsed();\n', '        return uint(_used >= vars.dailyLimit ? 0 : vars.dailyLimit - _used);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', "    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\n", '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', "        // If it doesn't exist already, there is nothing to do.\n", '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '// An interface to MonarchyGame instances.\n', 'interface IMonarchyGame {\n', '    function sendPrize(uint _gasLimit) external returns (bool _success, uint _prizeSent);\n', '    function sendFees() external returns (uint _feesSent);\n', '    function prize() external view returns(uint);\n', '    function numOverthrows() external view returns(uint);\n', '    function fees() external view returns (uint _fees);\n', '    function monarch() external view returns (address _addr);\n', '    function isEnded() external view returns (bool _bool);\n', '    function isPaid() external view returns (bool _bool);\n', '}\n', '\n', '/*\n', '\n', '  MonarchyController manages a list of PredefinedGames.\n', "  PredefinedGames' parameters are definable by the Admin.\n", '  These gamess can be started, ended, or refreshed by anyone.\n', '\n', '  Starting games uses the funds in this contract, unless called via\n', '  .startDefinedGameManually(), in which case it uses the funds sent.\n', '\n', '  All revenues of any started games will come back to this contract.\n', '\n', '  Since this contract inherits Bankrollable, it is able to be funded\n', '  via the Registry (or by anyone whitelisted). Profits will go to the\n', '  Treasury, and can be triggered by anyone.\n', '\n', '*/\n', 'contract MonarchyController is\n', '    HasDailyLimit,\n', '    Bankrollable,\n', '    UsingAdmin,\n', '    UsingMonarchyFactory\n', '{\n', '    uint constant public version = 1;\n', '\n', '    // just some accounting/stats stuff to keep track of\n', '    uint public totalFees;\n', '    uint public totalPrizes;\n', '    uint public totalOverthrows;\n', '    IMonarchyGame[] public endedGames;\n', '\n', '    // An admin-controlled index of available games.\n', '    // Note: Index starts at 1, and is limited to 20.\n', '    uint public numDefinedGames;\n', '    mapping (uint => DefinedGame) public definedGames;\n', '    struct DefinedGame {\n', '        IMonarchyGame game;     // address of ongoing game (or 0)\n', '        bool isEnabled;         // if true, can be started\n', '        string summary;         // definable via editDefinedGame\n', '        uint initialPrize;      // definable via editDefinedGame\n', '        uint fee;               // definable via editDefinedGame\n', '        int prizeIncr;          // definable via editDefinedGame\n', '        uint reignBlocks;       // definable via editDefinedGame\n', '        uint initialBlocks;     // definable via editDefinedGame\n', '    }\n', '\n', '    event Created(uint time);\n', '    event DailyLimitChanged(uint time, address indexed owner, uint newValue);\n', '    event Error(uint time, string msg);\n', '    event DefinedGameEdited(uint time, uint index);\n', '    event DefinedGameEnabled(uint time, uint index, bool isEnabled);\n', '    event DefinedGameFailedCreation(uint time, uint index);\n', '    event GameStarted(uint time, uint indexed index, address indexed addr, uint initialPrize);\n', '    event GameEnded(uint time, uint indexed index, address indexed addr, address indexed winner);\n', '    event FeesCollected(uint time, uint amount);\n', '\n', '\n', '    constructor(address _registry) \n', '        HasDailyLimit(10 ether)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        UsingMonarchyFactory(_registry)\n', '        public\n', '    {\n', '        emit Created(now);\n', '    }\n', '\n', '    /*************************************************************/\n', '    /******** OWNER FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    function setDailyLimit(uint _amount)\n', '        public\n', '        fromOwner\n', '    {\n', '        _setDailyLimit(_amount);\n', '        emit DailyLimitChanged(now, msg.sender, _amount);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******** ADMIN FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    // allows admin to edit or add an available game\n', '    function editDefinedGame(\n', '        uint _index,\n', '        string _summary,\n', '        uint _initialPrize,\n', '        uint _fee,\n', '        int _prizeIncr,\n', '        uint _reignBlocks,\n', '        uint _initialBlocks\n', '    )\n', '        public\n', '        fromAdmin\n', '        returns (bool _success)\n', '    {\n', '        if (_index-1 > numDefinedGames || _index > 20) {\n', '            emit Error(now, "Index out of bounds.");\n', '            return;\n', '        }\n', '\n', '        if (_index-1 == numDefinedGames) numDefinedGames++;\n', '        definedGames[_index].summary = _summary;\n', '        definedGames[_index].initialPrize = _initialPrize;\n', '        definedGames[_index].fee = _fee;\n', '        definedGames[_index].prizeIncr = _prizeIncr;\n', '        definedGames[_index].reignBlocks = _reignBlocks;\n', '        definedGames[_index].initialBlocks = _initialBlocks;\n', '        emit DefinedGameEdited(now, _index);\n', '        return true;\n', '    }\n', '\n', '    function enableDefinedGame(uint _index, bool _bool)\n', '        public\n', '        fromAdmin\n', '        returns (bool _success)\n', '    {\n', '        if (_index-1 >= numDefinedGames) {\n', '            emit Error(now, "Index out of bounds.");\n', '            return;\n', '        }\n', '        definedGames[_index].isEnabled = _bool;\n', '        emit DefinedGameEnabled(now, _index, _bool);\n', '        return true;\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******* PUBLIC FUNCTIONS ************************************/\n', '    /*************************************************************/\n', '\n', '    function () public payable {\n', '         totalFees += msg.value;\n', '    }\n', '\n', '    // This is called by anyone when a new MonarchyGame should be started.\n', '    // In reality will only be called by TaskManager.\n', '    //\n', '    // Errors if:\n', '    //      - isEnabled is false (or doesnt exist)\n', '    //      - game is already started\n', '    //      - not enough funds\n', '    //      - PAF.getCollector() points to another address\n', '    //      - unable to create game\n', '    function startDefinedGame(uint _index)\n', '        public\n', '        returns (address _game)\n', '    {\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (_index-1 >= numDefinedGames) {\n', '            _error("Index out of bounds.");\n', '            return;\n', '        }\n', '        if (dGame.isEnabled == false) {\n', '            _error("DefinedGame is not enabled.");\n', '            return;\n', '        }\n', '        if (dGame.game != IMonarchyGame(0)) {\n', '            _error("Game is already started.");\n', '            return;\n', '        }\n', '        if (address(this).balance < dGame.initialPrize) {\n', '            _error("Not enough funds to start this game.");\n', '            return;\n', '        }\n', '        if (getDailyLimitRemaining() < dGame.initialPrize) {\n', '            _error("Starting game would exceed daily limit.");\n', '            return;\n', '        }\n', '\n', '        // Ensure that if this game is started, revenue comes back to this contract.\n', '        IMonarchyFactory _mf = getMonarchyFactory();\n', '        if (_mf.getCollector() != address(this)){\n', '            _error("MonarchyFactory.getCollector() points to a different contract.");\n', '            return;\n', '        }\n', '\n', '        // Try to create game via factory.\n', '        bool _success = address(_mf).call.value(dGame.initialPrize)(\n', '            bytes4(keccak256("createGame(uint256,uint256,int256,uint256,uint256)")),\n', '            dGame.initialPrize,\n', '            dGame.fee,\n', '            dGame.prizeIncr,\n', '            dGame.reignBlocks,\n', '            dGame.initialBlocks\n', '        );\n', '        if (!_success) {\n', '            emit DefinedGameFailedCreation(now, _index);\n', '            _error("MonarchyFactory could not create game (invalid params?)");\n', '            return;\n', '        }\n', '\n', '        // Get the game, add it to definedGames, and return.\n', '        _useFromDailyLimit(dGame.initialPrize);\n', '        _game = _mf.lastCreatedGame();\n', '        definedGames[_index].game = IMonarchyGame(_game);\n', '        emit GameStarted(now, _index, _game, dGame.initialPrize);\n', '        return _game;\n', '    }\n', '        // Emits an error with a given message\n', '        function _error(string _msg)\n', '            private\n', '        {\n', '            emit Error(now, _msg);\n', '        }\n', '\n', '    function startDefinedGameManually(uint _index)\n', '        public\n', '        payable\n', '        returns (address _game)\n', '    {\n', '        // refund if invalid value sent.\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (msg.value != dGame.initialPrize) {\n', '            _error("Value sent does not match initialPrize.");\n', '            require(msg.sender.call.value(msg.value)());\n', '            return;\n', '        }\n', '\n', '        // refund if .startDefinedGame fails\n', '        _game = startDefinedGame(_index);\n', '        if (_game == address(0)) {\n', '            require(msg.sender.call.value(msg.value)());\n', '        }\n', '    }\n', '\n', '    // Looks at all active defined games and:\n', '    //  - tells each game to send fees to collector (us)\n', '    //  - if ended: tries to pay winner, moves to endedGames\n', '    function refreshGames()\n', '        public\n', '        returns (uint _numGamesEnded, uint _feesCollected)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            IMonarchyGame _game = definedGames[_i].game;\n', '            if (_game == IMonarchyGame(0)) continue;\n', '\n', '            // redeem the fees\n', '            uint _fees = _game.sendFees();\n', '            _feesCollected += _fees;\n', '\n', '            // attempt to pay winner, update stats, and set game to empty.\n', '            if (_game.isEnded()) {\n', '                // paying the winner can error if the winner uses too much gas\n', '                // in that case, they can call .sendPrize() themselves later.\n', '                if (!_game.isPaid()) _game.sendPrize(2300);\n', '                \n', '                // update stats\n', '                totalPrizes += _game.prize();\n', '                totalOverthrows += _game.numOverthrows();\n', '\n', '                // clear game, move to endedGames, update return\n', '                definedGames[_i].game = IMonarchyGame(0);\n', '                endedGames.push(_game);\n', '                _numGamesEnded++;\n', '\n', '                emit GameEnded(now, _i, address(_game), _game.monarch());\n', '            }\n', '        }\n', '        if (_feesCollected > 0) emit FeesCollected(now, _feesCollected);\n', '        return (_numGamesEnded, _feesCollected);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*********** PUBLIC VIEWS ************************************/\n', '    /*************************************************************/\n', '    // IMPLEMENTS: Bankrollable.getCollateral()\n', '    function getCollateral() public view returns (uint) { return 0; }\n', '    function getWhitelistOwner() public view returns (address){ return getAdmin(); }\n', '\n', '    function numEndedGames()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return endedGames.length;\n', '    }\n', '\n', '    function numActiveGames()\n', '        public\n', '        view\n', '        returns (uint _count)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (definedGames[_i].game != IMonarchyGame(0)) _count++;\n', '        }\n', '    }\n', '\n', '    function getNumEndableGames()\n', '        public\n', '        view\n', '        returns (uint _count)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            IMonarchyGame _game = definedGames[_i].game;\n', '            if (_game == IMonarchyGame(0)) continue;\n', '            if (_game.isEnded()) _count++;\n', '        }\n', '        return _count;\n', '    }\n', '\n', '    function getFirstStartableIndex()\n', '        public\n', '        view\n', '        returns (uint _index)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (getIsStartable(_i)) return _i;\n', '        }\n', '    }\n', '\n', '    // Gets total amount of fees that are redeemable if refreshGames() is called.\n', '    function getAvailableFees()\n', '        public\n', '        view\n', '        returns (uint _feesAvailable)\n', '    {\n', '        for (uint _i = 1; _i <= numDefinedGames; _i++) {\n', '            if (definedGames[_i].game == IMonarchyGame(0)) continue;\n', '            _feesAvailable += definedGames[_i].game.fees();\n', '        }\n', '        return _feesAvailable;\n', '    }\n', '\n', '    function recentlyEndedGames(uint _num)\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // set _num to Min(_num, _len), initialize the array\n', '        uint _len = endedGames.length;\n', '        if (_num > _len) _num = _len;\n', '        _addresses = new address[](_num);\n', '\n', '        // Loop _num times, adding from end of endedGames.\n', '        uint _i = 1;\n', '        while (_i <= _num) {\n', '            _addresses[_i - 1] = endedGames[_len - _i];\n', '            _i++;\n', '        }\n', '    }\n', '\n', '    /******** Shorthand access to definedGames **************************/\n', '    function getGame(uint _index)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return address(definedGames[_index].game);\n', '    }\n', '\n', '    function getIsEnabled(uint _index)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return definedGames[_index].isEnabled;\n', '    }\n', '\n', '    function getInitialPrize(uint _index)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return definedGames[_index].initialPrize;\n', '    }\n', '\n', '    function getIsStartable(uint _index)\n', '        public\n', '        view\n', '        returns (bool _isStartable)\n', '    {\n', '        DefinedGame memory dGame = definedGames[_index];\n', '        if (_index >= numDefinedGames) return;\n', '        if (dGame.isEnabled == false) return;\n', '        if (dGame.game != IMonarchyGame(0)) return;\n', '        if (dGame.initialPrize > address(this).balance) return;\n', '        if (dGame.initialPrize > getDailyLimitRemaining()) return;\n', '        return true;\n', '    }\n', '    /******** Shorthand access to definedGames **************************/\n', '}']
