['pragma solidity ^0.4.19; // solhint-disable-line\n', '\n', '/**\n', '  * Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '  * @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f397968796b3928b9a9c9e89969ddd909c">[email&#160;protected]</a>> (https://github.com/dete)\n', '  */\n', 'contract ERC721 {\n', '  // Required methods\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint256 _tokenId) public;\n', '  function totalSupply() public view returns (uint256 total);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract LibraryToken is ERC721 {\n', '  using SafeMath for uint256;\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /**\n', '    * @dev The Created event is fired whenever a new library comes into existence.\n', '    */\n', '  event Created(uint256 indexed _tokenId, string _language, string _name, address indexed _owner);\n', '\n', '  /**\n', '    * @dev The Sold event is fired whenever a token is sold.\n', '    */\n', '  event Sold(uint256 indexed _tokenId, address indexed _owner, uint256 indexed _price);\n', '\n', '  /**\n', '    * @dev The Bought event is fired whenever a token is bought.\n', '    */\n', '  event Bought(uint256 indexed _tokenId, address indexed _owner, uint256 indexed _price);\n', '\n', '  /**\n', '    * @dev Transfer event as defined in current draft of ERC721.\n', '    */\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '\n', '  /**\n', '    * @dev Approval event as defined in current draft of ERC721.\n', '    */\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '  /**\n', '    * @dev FounderSet event fired when founder is set.\n', '    */\n', '  event FounderSet(address indexed _founder, uint256 indexed _tokenId);\n', '\n', '\n', '\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /**\n', '    * @notice Name and symbol of the non-fungible token, as defined in ERC721.\n', '    */\n', '  string public constant NAME = "CryptoLibraries"; // solhint-disable-line\n', '  string public constant SYMBOL = "CL"; // solhint-disable-line\n', '\n', '  /**\n', '    * @dev Increase tiers to deterine how much price have to be changed\n', '    */\n', '  uint256 private startingPrice = 0.002 ether;\n', '  uint256 private developersCut = 0 ether;\n', '  uint256 private TIER1 = 0.02 ether;\n', '  uint256 private TIER2 = 0.5 ether;\n', '  uint256 private TIER3 = 2.0 ether;\n', '  uint256 private TIER4 = 5.0 ether;\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /**\n', '    * @dev A mapping from library IDs to the address that owns them.\n', '    * All libraries have some valid owner address.\n', '    */\n', '  mapping (uint256 => address) public libraryIndexToOwner;\n', '\n', '  /**\n', '    * @dev A mapping from library IDs to the address that founder of library.\n', '    */\n', '  mapping (uint256 => address) public libraryIndexToFounder;\n', '\n', '  /**\n', '    * @dev A mapping from founder address to token count.\n', '  */\n', '  mapping (address => uint256) public libraryIndexToFounderCount;\n', '\n', '  /**\n', '    * @dev A mapping from owner address to count of tokens that address owns.\n', '    * Used internally inside balanceOf() to resolve ownership count.\n', '    */\n', '  mapping (address => uint256) private ownershipTokenCount;\n', '\n', '  /**\n', '    * @dev A mapping from LibraryIDs to an address that has been approved to call\n', '    * transferFrom(). Each Library can only have one approved address for transfer\n', '    * at any time. A zero value means no approval is outstanding.\n', '    */\n', '  mapping (uint256 => address) public libraryIndexToApproved;\n', '\n', '  /**\n', '    * @dev A mapping from LibraryIDs to the price of the token.\n', '    */\n', '  mapping (uint256 => uint256) private libraryIndexToPrice;\n', '\n', '  /**\n', '    * @dev A mapping from LibraryIDs to the funds avaialble for founder.\n', '    */\n', '  mapping (uint256 => uint256) private libraryIndexToFunds;\n', '\n', '  /**\n', '    * The addresses of the owner that can execute actions within each roles.\n', '    */\n', '  address public owner;\n', '\n', '\n', '\n', '  /*** DATATYPES ***/\n', '  struct Library {\n', '    string language;\n', '    string name;\n', '  }\n', '\n', '  Library[] private libraries;\n', '\n', '\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '\n', '  /**\n', '    * @dev Access modifier for owner functionality.\n', '    */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '    * @dev Access modifier for founder of library.\n', '    */\n', '  modifier onlyFounder(uint256 _tokenId) {\n', '    require(msg.sender == founderOf(_tokenId));\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  /*** CONSTRUCTOR ***/\n', '\n', '  function LibraryToken() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '\n', '  /*** PUBLIC FUNCTIONS ERC-721 COMPILANCE ***/\n', '\n', '  /**\n', '    * @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '    * @param _to The address to be granted transfer approval. Pass address(0) to\n', '    * clear all approvals.\n', '    * @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '    */\n', '  function approve(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '  {\n', '    // Caller can&#39;t be approver of request\n', '    require(msg.sender != _to);\n', '\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    libraryIndexToApproved[_tokenId] = _to;\n', '\n', '    Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '    * For querying balance of a particular account\n', '    * @param _owner The address for balance query\n', '    * @return balance The number of tokens owned by owner\n', '    */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  /**\n', '    * @dev Required for ERC-721 compliance.\n', '    * @return bool\n', '    */\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * For querying owner of token\n', '    * @dev Required for ERC-721 compliance.\n', '    * @param _tokenId The tokenID for owner inquiry\n', '    * @return tokenOwner address of token owner\n', '    */\n', '  function ownerOf(uint256 _tokenId) public view returns (address tokenOwner) {\n', '    tokenOwner = libraryIndexToOwner[_tokenId];\n', '    require(tokenOwner != address(0));\n', '  }\n', '\n', '  /**\n', '    * @notice Allow pre-approved user to take ownership of a token\n', '    * @dev Required for ERC-721 compliance.\n', '    * @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '    */\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _tokenId));\n', '\n', '    address newOwner = msg.sender;\n', '    address oldOwner = libraryIndexToOwner[_tokenId];\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '\n', '  /**\n', '    * totalSupply\n', '    * For querying total numbers of tokens\n', '    * @return total The total supply of tokens\n', '    */\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return libraries.length;\n', '  }\n', '\n', '  /**\n', '    * transferFro\n', '    * Third-party initiates transfer of token from address _from to address _to\n', '    * @param _from The address for the token to be transferred from.\n', '    * @param _to The address for the token to be transferred to.\n', '    * @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '    */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '  {\n', '    require(_owns(_from, _tokenId));\n', '    require(_approved(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '    * Owner initates the transfer of the token to another account\n', '    * @param _to The address for the token to be transferred to.\n', '    * @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '    */\n', '  function transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '  {\n', '    require(_owns(msg.sender, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '    * @dev Required for ERC-721 compliance.\n', '    */\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /**\n', '    * @dev Required for ERC-721 compliance.\n', '    */\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '\n', '  /**\n', '    * @dev Creates a new Library with the given language and name.\n', '    * @param _language The library language\n', '    * @param _name The name of library/framework\n', '    */\n', '  function createLibrary(string _language, string _name) public onlyOwner {\n', '    _createLibrary(_language, _name, address(this), address(0), 0, startingPrice);\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new Library with the given language and name and founder address.\n', '    * @param _language The library language\n', '    * @param _name The name of library/framework\n', '    * @param _founder The founder of library/framework\n', '    */\n', '  function createLibraryWithFounder(string _language, string _name, address _founder) public onlyOwner {\n', '    require(_addressNotNull(_founder));\n', '    _createLibrary(_language, _name, address(this), _founder, 0, startingPrice);\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new Library with the given language and name and owner address and starting price.\n', '    * Itd be used for various bounties prize.\n', '    * @param _language The library language\n', '    * @param _name The name of library/framework\n', '    * @param _owner The owner of library token\n', '    * @param _startingPrice The starting price of library token\n', '    */\n', '  function createLibraryBounty(string _language, string _name, address _owner, uint256 _startingPrice) public onlyOwner {\n', '    require(_addressNotNull(_owner));\n', '    _createLibrary(_language, _name, _owner, address(0), 0, _startingPrice);\n', '  }\n', '\n', '  /**\n', '    * @notice Returns all the relevant information about a specific library.\n', '    * @param _tokenId The tokenId of the library of interest.\n', '    */\n', '  function getLibrary(uint256 _tokenId) public view returns (\n', '    string language,\n', '    string libraryName,\n', '    uint256 tokenPrice,\n', '    uint256 funds,\n', '    address tokenOwner,\n', '    address founder\n', '  ) {\n', '    Library storage x = libraries[_tokenId];\n', '    libraryName = x.name;\n', '    language = x.language;\n', '    founder = libraryIndexToFounder[_tokenId];\n', '    funds = libraryIndexToFunds[_tokenId];\n', '    tokenPrice = libraryIndexToPrice[_tokenId];\n', '    tokenOwner = libraryIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '    * For querying price of token\n', '    * @param _tokenId The tokenID for owner inquiry\n', '    * @return _price The current price of token\n', '    */\n', '  function priceOf(uint256 _tokenId) public view returns (uint256 _price) {\n', '    return libraryIndexToPrice[_tokenId];\n', '  }\n', '\n', '  /**\n', '    * For querying next price of token\n', '    * @param _tokenId The tokenID for owner inquiry\n', '    * @return _nextPrice The next price of token\n', '    */\n', '  function nextPriceOf(uint256 _tokenId) public view returns (uint256 _nextPrice) {\n', '    return calculateNextPrice(priceOf(_tokenId));\n', '  }\n', '\n', '  /**\n', '    * For querying founder of library\n', '    * @param _tokenId The tokenID for founder inquiry\n', '    * @return _founder The address of library founder\n', '    */\n', '  function founderOf(uint256 _tokenId) public view returns (address _founder) {\n', '    _founder = libraryIndexToFounder[_tokenId];\n', '    require(_founder != address(0));\n', '  }\n', '\n', '  /**\n', '    * For querying founder funds of library\n', '    * @param _tokenId The tokenID for founder inquiry\n', '    * @return _funds The funds availale for a fo\n', '    */\n', '  function fundsOf(uint256 _tokenId) public view returns (uint256 _funds) {\n', '    _funds = libraryIndexToFunds[_tokenId];\n', '  }\n', '\n', '  /**\n', '    * For querying next price of token\n', '    * @param _price The token actual price\n', '    * @return _nextPrice The next price\n', '    */\n', '  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n', '    if (_price < TIER1) {\n', '      return _price.mul(200).div(95);\n', '    } else if (_price < TIER2) {\n', '      return _price.mul(135).div(96);\n', '    } else if (_price < TIER3) {\n', '      return _price.mul(125).div(97);\n', '    } else if (_price < TIER4) {\n', '      return _price.mul(117).div(97);\n', '    } else {\n', '      return _price.mul(115).div(98);\n', '    }\n', '  }\n', '\n', '  /**\n', '    * For querying developer&#39;s cut which is left in the contract by `purchase`\n', '    * @param _price The token actual price\n', '    * @return _devCut The developer&#39;s cut\n', '    */\n', '  function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) {\n', '    if (_price < TIER1) {\n', '      return _price.mul(5).div(100); // 5%\n', '    } else if (_price < TIER2) {\n', '      return _price.mul(4).div(100); // 4%\n', '    } else if (_price < TIER3) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else if (_price < TIER4) {\n', '      return _price.mul(3).div(100); // 3%\n', '    } else {\n', '      return _price.mul(2).div(100); // 2%\n', '    }\n', '  }\n', '\n', '  /**\n', '    * For querying founder cut which is left in the contract by `purchase`\n', '    * @param _price The token actual price\n', '    */\n', '  function calculateFounderCut (uint256 _price) public pure returns (uint256 _founderCut) {\n', '    return _price.mul(1).div(100);\n', '  }\n', '\n', '  /**\n', '    * @dev This function withdrawing all of developer&#39;s cut which is left in the contract by `purchase`.\n', '    * User funds are immediately sent to the old owner in `purchase`, no user funds are left in the contract\n', '    * expect funds that stay in the contract that are waiting to be sent to a founder of a library when we would assign him.\n', '    */\n', '  function withdrawAll () onlyOwner() public {\n', '    owner.transfer(developersCut);\n', '    // Set developersCut to 0 to reset counter of possible funds\n', '    developersCut = 0;\n', '  }\n', '\n', '  /**\n', '    * @dev This function withdrawing selected amount of developer&#39;s cut which is left in the contract by `purchase`.\n', '    * User funds are immediately sent to the old owner in `purchase`, no user funds are left in the contract\n', '    * expect funds that stay in the contract that are waiting to be sent to a founder of a library when we would assign him.\n', '    * @param _amount The amount to withdraw\n', '    */\n', '  function withdrawAmount (uint256 _amount) onlyOwner() public {\n', '    require(_amount >= developersCut);\n', '\n', '    owner.transfer(_amount);\n', '    developersCut = developersCut.sub(_amount);\n', '  }\n', '\n', '    /**\n', '    * @dev This function withdrawing selected amount of developer&#39;s cut which is left in the contract by `purchase`.\n', '    * User funds are immediately sent to the old owner in `purchase`, no user funds are left in the contract\n', '    * expect funds that stay in the contract that are waiting to be sent to a founder of a library when we would assign him.\n', '    */\n', '  function withdrawFounderFunds (uint256 _tokenId) onlyFounder(_tokenId) public {\n', '    address founder = founderOf(_tokenId);\n', '    uint256 funds = fundsOf(_tokenId);\n', '    founder.transfer(funds);\n', '\n', '    // Set funds to 0 after transfer since founder can only withdraw all funts\n', '    libraryIndexToFunds[_tokenId] = 0;\n', '  }\n', '\n', '  /*\n', '     Purchase a library directly from the contract for the calculated price\n', '     which ensures that the owner gets a profit.  All libraries that\n', '     have been listed can be bought by this method. User funds are sent\n', '     directly to the previous owner and are never stored in the contract.\n', '  */\n', '  function purchase(uint256 _tokenId) public payable {\n', '    address oldOwner = libraryIndexToOwner[_tokenId];\n', '    address newOwner = msg.sender;\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    uint256 price = libraryIndexToPrice[_tokenId];\n', '    require(msg.value >= price);\n', '\n', '    uint256 excess = msg.value.sub(price);\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '    libraryIndexToPrice[_tokenId] = nextPriceOf(_tokenId);\n', '\n', '    Bought(_tokenId, newOwner, price);\n', '    Sold(_tokenId, oldOwner, price);\n', '\n', '    // Devevloper&#39;s cut which is left in contract and accesed by\n', '    // `withdrawAll` and `withdrawAmount` methods.\n', '    uint256 devCut = calculateDevCut(price);\n', '    developersCut = developersCut.add(devCut);\n', '\n', '    // Founders cut which is left in contract and accesed by\n', '    // `withdrawFounderFunds` methods.\n', '    uint256 founderCut = calculateFounderCut(price);\n', '    libraryIndexToFunds[_tokenId] = libraryIndexToFunds[_tokenId].add(founderCut);\n', '\n', '    // Pay previous tokenOwner if owner is not contract\n', '    if (oldOwner != address(this)) {\n', '      oldOwner.transfer(price.sub(devCut.add(founderCut)));\n', '    }\n', '\n', '    if (excess > 0) {\n', '      newOwner.transfer(excess);\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '    * expensive (it walks the entire Cities array looking for cities belonging to owner),\n', '    * but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    * not contract-to-contract calls.\n', '    * @param _owner The owner whose library tokens we are interested in.\n', '    * @return []ownerTokens The tokens of owner\n', '    */\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalLibraries = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 libraryId;\n', '      for (libraryId = 0; libraryId <= totalLibraries; libraryId++) {\n', '        if (libraryIndexToOwner[libraryId] == _owner) {\n', '          result[resultIndex] = libraryId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '    /**\n', '    * @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '    * expensive (it walks the entire Cities array looking for cities belonging to owner),\n', '    * but it also returns a dynamic array, which is only supported for web3 calls, and\n', '    * not contract-to-contract calls.\n', '    * @param _founder The owner whose library tokens we are interested in.\n', '    * @return []founderTokens The tokens of owner\n', '    */\n', '  function tokensOfFounder(address _founder) public view returns(uint256[] founderTokens) {\n', '    uint256 tokenCount = libraryIndexToFounderCount[_founder];\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalLibraries = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 libraryId;\n', '      for (libraryId = 0; libraryId <= totalLibraries; libraryId++) {\n', '        if (libraryIndexToFounder[libraryId] == _founder) {\n', '          result[resultIndex] = libraryId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '\n', '    /**\n', '    * @dev \n', '    * @return []_libraries All tokens\n', '    */\n', '  function allTokens() public pure returns(Library[] _libraries) {\n', '    return _libraries;\n', '  }\n', '\n', '  /**\n', '    * @dev Assigns a new address to act as the Owner. Only available to the current Owner.\n', '    * @param _newOwner The address of the new owner\n', '    */\n', '  function setOwner(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '\n', '    owner = _newOwner;\n', '  }\n', '\n', '    /**\n', '    * @dev Assigns a new address to act as the founder of library to let him withdraw collected funds of his library.\n', '    * @param _tokenId The id of a Token\n', '    * @param _newFounder The address of the new owner\n', '    */\n', '  function setFounder(uint256 _tokenId, address _newFounder) public onlyOwner {\n', '    require(_newFounder != address(0));\n', '\n', '    address oldFounder = founderOf(_tokenId);\n', '\n', '    libraryIndexToFounder[_tokenId] = _newFounder;\n', '    FounderSet(_newFounder, _tokenId);\n', '\n', '    libraryIndexToFounderCount[_newFounder] = libraryIndexToFounderCount[_newFounder].add(1);\n', '    libraryIndexToFounderCount[oldFounder] = libraryIndexToFounderCount[oldFounder].sub(1);\n', '  }\n', '\n', '\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '\n', '  /**\n', '    * Safety check on _to address to prevent against an unexpected 0x0 default.\n', '    * @param _to The address to validate if not null\n', '    * @return bool The result of check\n', '    */\n', '  function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /**\n', '    * For checking approval of transfer for address _to\n', '    * @param _to The address to validate if approved\n', '    * @param _tokenId The token id to validate if approved\n', '    * @return bool The result of validation\n', '    */\n', '  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return libraryIndexToApproved[_tokenId] == _to;\n', '  }\n', '\n', '  /**\n', '    * Function to create a new Library\n', '    * @param _language The language (etc. Python, JavaScript) of library\n', '    * @param _name The name of library/framework (etc. Anguar, Redux, Flask)\n', '    * @param _owner The current owner of Token\n', '    * @param _founder The founder of library/framework\n', '    * @param _funds The funds available to founder of library/framework\n', '    * @param _price The current price of a Token\n', '    */\n', '  function _createLibrary(\n', '    string _language,\n', '    string _name,\n', '    address _owner,\n', '    address _founder,\n', '    uint256 _funds,\n', '    uint256 _price\n', '  )\n', '    private\n', '  {\n', '    Library memory _library = Library({\n', '      name: _name,\n', '      language: _language\n', '    });\n', '    uint256 newLibraryId = libraries.push(_library) - 1;\n', '\n', '    Created(newLibraryId, _language, _name, _owner);\n', '\n', '    libraryIndexToPrice[newLibraryId] = _price;\n', '    libraryIndexToFounder[newLibraryId] = _founder;\n', '    libraryIndexToFunds[newLibraryId] = _funds;\n', '\n', '    // This will assign ownership, and also emit the Transfer event as per ERC721 draft\n', '    _transfer(address(0), _owner, newLibraryId);\n', '  }\n', '\n', '  /**\n', '    * Check for token ownership\n', '    * @param claimant The claimant\n', '    * @param _tokenId The token id to check claim\n', '    * @return bool The result of validation\n', '    */\n', '  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '    return claimant == libraryIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '    * @dev Assigns ownership of a specific Library to an address.\n', '    * @param _from The old owner of token\n', '    * @param _to The new owner of token\n', '    * @param _tokenId The id of token to change owner\n', '    */\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '    // Since the number of library is capped to 2^32 we can&#39;t overflow this\n', '    ownershipTokenCount[_to] = ownershipTokenCount[_to].add(1);\n', '\n', '    //transfer ownership\n', '    libraryIndexToOwner[_tokenId] = _to;\n', '\n', '    // When creating new libraries _from is 0x0, but we can&#39;t account that address.\n', '    if (_from != address(0)) {\n', '      ownershipTokenCount[_from] = ownershipTokenCount[_from].sub(1);\n', '\n', '      // clear any previously approved ownership exchange\n', '      delete libraryIndexToApproved[_tokenId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '}']