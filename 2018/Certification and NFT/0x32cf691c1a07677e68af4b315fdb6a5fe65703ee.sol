['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' *\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // A hashmap to help keep track of list of all owners\n', '    mapping(address => uint) public allOwnersMap;\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () public {\n', '        owner = msg.sender;\n', '        allOwnersMap[msg.sender] = 1;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "You&#39;re not the owner!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the all owners in the history of\n', '     * the smart contract.\n', '     */\n', '    modifier onlyAnyOwners() {\n', '        require(allOwnersMap[msg.sender] == 1, "You&#39;re not the owner or never were the owner!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '\n', '        // Keep track of list of owners\n', '        allOwnersMap[newOwner] = 1;\n', '    }\n', '\n', '\n', '    // transfer ownership event\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Suicidable\n', ' *\n', ' * @dev Suicidable is special contract with functions to suicide. This is a security measure added in\n', ' * incase Bitwords gets hacked.\n', ' */\n', 'contract Suicidable is Ownable {\n', '    bool public hasSuicided = false;\n', '\n', '\n', '    /**\n', '     * @dev Throws if called the contract has not yet suicided\n', '     */\n', '    modifier hasNotSuicided() {\n', '        require(hasSuicided == false, "Contract has suicided!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Suicides the entire smart contract\n', '     */\n', '    function suicideContract() public onlyAnyOwners {\n', '        hasSuicided = true;\n', '        emit SuicideContract(msg.sender);\n', '    }\n', '\n', '\n', '    // suicide contract event\n', '    event SuicideContract(address indexed owner);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Migratable\n', ' *\n', ' * @dev Migratable is special contract which allows the funds of a smart-contact to be migrated\n', ' * to a new smart contract.\n', ' */\n', 'contract Migratable is Suicidable {\n', '    bool public hasRequestedForMigration = false;\n', '    uint public requestedForMigrationAt = 0;\n', '    address public migrationDestination;\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows for a migration request to be created, all migrations requests\n', '     * are timelocked by 7 days.\n', '     *\n', '     * @param destination   The destination to send the ether to.\n', '     */\n', '    function requestForMigration(address destination) public onlyOwner {\n', '        hasRequestedForMigration = true;\n', '        requestedForMigrationAt = now;\n', '        migrationDestination = destination;\n', '\n', '        emit MigrateFundsRequested(msg.sender, destination);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancels a migration\n', '     */\n', '    function cancelMigration() public onlyOwner hasNotSuicided {\n', '        hasRequestedForMigration = false;\n', '        requestedForMigrationAt = 0;\n', '\n', '        emit MigrateFundsCancelled(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approves a migration and suicides the entire smart contract\n', '     */\n', '    function approveMigration(uint gasCostInGwei) public onlyOwner hasNotSuicided {\n', '        require(hasRequestedForMigration, "please make a migration request");\n', '        require(requestedForMigrationAt + 604800 < now, "migration is timelocked for 7 days");\n', '        require(gasCostInGwei > 0, "gas cost must be more than 0");\n', '        require(gasCostInGwei < 20, "gas cost can&#39;t be more than 20");\n', '\n', '        // Figure out how much ether to send\n', '        uint gasLimit = 21000;\n', '        uint gasPrice = gasCostInGwei * 1000000000;\n', '        uint gasCost = gasLimit * gasPrice;\n', '        uint etherToSend = address(this).balance - gasCost;\n', '\n', '        require(etherToSend > 0, "not enough balance in smart contract");\n', '\n', '        // Send the funds to the new smart contract\n', '        emit MigrateFundsApproved(msg.sender, etherToSend);\n', '        migrationDestination.transfer(etherToSend);\n', '\n', '        // suicide the contract so that no more funds/actions can take place\n', '        suicideContract();\n', '    }\n', '\n', '    // events\n', '    event MigrateFundsCancelled(address indexed by);\n', '    event MigrateFundsRequested(address indexed by, address indexed newSmartContract);\n', '    event MigrateFundsApproved(address indexed by, uint amount);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Bitwords\n', ' *\n', ' * @dev The Bitwords smart contract that allows advertisers and publishers to\n', ' * safetly deposit/receive ether and interact with the Bitwords platform.\n', ' *\n', ' * TODO:\n', ' *  - timelock all chargeAdvertiser requests\n', ' *  - if suicide is called, then all timelocked requests need to be stopped and then later reversed\n', ' */\n', 'contract Bitwords is Migratable {\n', '    mapping(address => uint) public advertiserBalances;\n', '\n', '    // This mapping overrides the default bitwords cut for a specific publisher.\n', '    mapping(address => uint) public bitwordsCutOverride;\n', '\n', '    // The bitwords address, where all the 30% cut is received ETH\n', '    address public bitwordsWithdrawlAddress;\n', '\n', '    // How much cut out of 100 Bitwords takes. By default 10%\n', '    uint public bitwordsCutOutof100 = 10;\n', '\n', '    // To store the advertiserChargeRequests\n', '    // TODO: this needs to be used for the timelock\n', '    struct advertiserChargeRequest {\n', '        address advertiser;\n', '        address publisher;\n', '        uint amount;\n', '        uint requestedAt;\n', '        uint processAfter;\n', '    }\n', '\n', '    // How much days should each refund request be timelocked for\n', '    uint public refundRequestTimelock = 7 days;\n', '\n', '    // To store refund request\n', '    struct refundRequest {\n', '        address advertiser;\n', '        uint amount;\n', '        uint requestedAt;\n', '        uint processAfter;\n', '    }\n', '\n', '    // An array of all the refund requests submitted by advertisers.\n', '    refundRequest[] public refundQueue;\n', '\n', '    // variables that help track where in the refund loop we are in.\n', '    mapping(address => uint) private advertiserRefundRequestsIndex;\n', '    uint private lastProccessedIndex = 0;\n', '\n', '\n', '    /**\n', '     * @dev The Bitwords constructor sets the address where all the withdrawals will\n', '     * happen.\n', '     */\n', '    constructor () public {\n', '        bitwordsWithdrawlAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Anybody who deposits ether to the smart contract will be considered as an\n', '     * advertiser and will get that much ether debitted into his account.\n', '     */\n', '    function() public payable {\n', '        advertiserBalances[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /**\n', '     * Used by the owner to set the withdrawal address for Bitwords. This address\n', '     * is where Bitwords will receive all the cut from the advertisements.\n', '     *\n', '     * @param newAddress    the new withdrawal address\n', '     */\n', '    function setBitwordsWithdrawlAddress (address newAddress) hasNotSuicided onlyOwner public {\n', '        bitwordsWithdrawlAddress = newAddress;\n', '\n', '        emit BitwordsWithdrawlAddressChanged(msg.sender, newAddress);\n', '    }\n', '\n', '    /**\n', '     * Change the cut that Bitwords takes.\n', '     *\n', '     * @param cut   the amount of cut that Bitwords takes.\n', '     */\n', '    function setBitwordsCut (uint cut) hasNotSuicided onlyOwner public {\n', '        require(cut <= 30, "cut cannot be more than 30%");\n', '        require(cut >= 0, "cut should be greater than 0%");\n', '        bitwordsCutOutof100 = cut;\n', '\n', '        emit BitwordsCutChanged(msg.sender, cut);\n', '    }\n', '\n', '    /**\n', '     * Set the new timelock for refund reuqests\n', '     *\n', '     * @param newTimelock   the new timelock\n', '     */\n', '    function setRefundTimelock (uint newTimelock) hasNotSuicided onlyOwner public {\n', '        require(newTimelock >= 0, "timelock has to be greater than 0");\n', '        refundRequestTimelock = newTimelock;\n', '\n', '        emit TimelockChanged(msg.sender, newTimelock);\n', '    }\n', '\n', '    /**\n', '     * Process all the refund requests in the queue. This is called by the Bitwords\n', '     * server ideally right after chargeAdvertisers has been called.\n', '     *\n', '     * This function will only process refunds that have passed it&#39;s timelock and\n', '     * it will only refund maximum to how much the advertiser currently has in\n', '     * his balance.\n', '     */\n', '    bool private inProcessRefunds = false;\n', '    function processRefunds () onlyAnyOwners public {\n', '        // prevent reentry bug\n', '        require(!inProcessRefunds, "prevent reentry bug");\n', '        inProcessRefunds = true;\n', '\n', '        for (uint j = lastProccessedIndex; j < refundQueue.length; j++) {\n', '            // If we haven&#39;t passed the timelock for this refund request, then\n', '            // we stop the loop. Reaching here means that all the requests\n', '            // in next iterations have also not reached their timelocks.\n', '            if (refundQueue[j].processAfter > now) break;\n', '\n', '            // Find the minimum that needs to be withdrawn. This is important\n', '            // because since every call to chargeAdvertisers might update the\n', '            // advertiser&#39;s balance, it is possible that the amount that the\n', '            // advertiser requests for is small.\n', '            uint cappedAmount = refundQueue[j].amount;\n', '            if (advertiserBalances[refundQueue[j].advertiser] < cappedAmount)\n', '                cappedAmount = advertiserBalances[refundQueue[j].advertiser];\n', '\n', '            // This refund is now invalid, skip it\n', '            if (cappedAmount <= 0) {\n', '                lastProccessedIndex++;\n', '                continue;\n', '            }\n', '\n', '            // deduct advertiser&#39;s balance and send the ether\n', '            advertiserBalances[refundQueue[j].advertiser] -= cappedAmount;\n', '            refundQueue[j].advertiser.transfer(cappedAmount);\n', '            refundQueue[j].amount = 0;\n', '\n', '            // Emit events\n', '            emit RefundAdvertiserProcessed(refundQueue[j].advertiser, cappedAmount, advertiserBalances[refundQueue[j].advertiser]);\n', '\n', '            // Increment the last proccessed index, effectively marking this\n', '            // refund request as completed.\n', '            lastProccessedIndex++;\n', '        }\n', '\n', '        inProcessRefunds = false;\n', '    }\n', '\n', '    /**\n', '     * Anybody can credit ether on behalf of an advertiser\n', '     *\n', '     * @param advertiser    The advertiser to credit ether to\n', '     */\n', '    function creditAdvertiser (address advertiser) hasNotSuicided public payable {\n', '        advertiserBalances[advertiser] += msg.value;\n', '        emit Deposit(advertiser, msg.value, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /**\n', '     * Anybody can credit ether on behalf of an advertiser\n', '     *\n', '     * @param publisher    The address of the publisher\n', '     * @param cut          How much cut should be taken from this publisher\n', '     */\n', '    function setPublisherCut (address publisher, uint cut) hasNotSuicided onlyOwner public {\n', '        require(cut <= 30, "cut cannot be more than 30%");\n', '        require(cut >= 0, "cut should be greater than 0%");\n', '\n', '        bitwordsCutOverride[publisher] = cut;\n', '        emit SetPublisherCut(publisher, cut);\n', '    }\n', '\n', '    /**\n', '     * Charge the advertiser with whatever clicks have been served by the ad engine.\n', '     *\n', '     * @param advertisers           Array of address of the advertiser from whom we should debit ether\n', '     * @param costs                 Array of the cost to be paid to publisher by advertisers\n', '     * @param publishers            Array of address of the publisher from whom we should credit ether\n', '     * @param publishersToCredit    Array of indices of publishers that need to be credited than debited.\n', '     */\n', '    bool private inChargeAdvertisers = false;\n', '    function chargeAdvertisers (address[] advertisers, uint[] costs, address[] publishers, uint[] publishersToCredit) hasNotSuicided onlyOwner public {\n', '        // Prevent re-entry bug\n', '        require(!inChargeAdvertisers, "avoid rentry bug");\n', '        inChargeAdvertisers = true;\n', '\n', '        uint creditArrayIndex = 0;\n', '\n', '        for (uint i = 0; i < advertisers.length; i++) {\n', '            uint toWithdraw = costs[i];\n', '\n', '            // First check if all advertisers have enough balance and cap it if needed\n', '            if (advertiserBalances[advertisers[i]] <= 0) {\n', '                emit InsufficientBalance(advertisers[i], advertiserBalances[advertisers[i]], costs[i]);\n', '                continue;\n', '            }\n', '            if (advertiserBalances[advertisers[i]] < toWithdraw) toWithdraw = advertiserBalances[advertisers[i]];\n', '\n', '            // Update the advertiser&#39;s balance\n', '            advertiserBalances[advertisers[i]] -= toWithdraw;\n', '            emit DeductFromAdvertiser(advertisers[i], toWithdraw, advertiserBalances[advertisers[i]]);\n', '\n', '            // Calculate how much cut Bitwords should take\n', '            uint bitwordsCut = bitwordsCutOutof100;\n', '            if (bitwordsCutOverride[publishers[i]] > 0 && bitwordsCutOverride[publishers[i]] <= 30) {\n', '                bitwordsCut = bitwordsCutOverride[publishers[i]];\n', '            }\n', '\n', '            // Figure out how much should go to Bitwords and to the publishers.\n', '            uint publisherNetCut = toWithdraw * (100 - bitwordsCut) / 100;\n', '            uint bitwordsNetCut = toWithdraw - publisherNetCut;\n', '\n', '            // Send the ether to the publisher and to Bitwords\n', '            // Either decide to credit the ether as an advertiser\n', '            if (publishersToCredit.length > creditArrayIndex && publishersToCredit[creditArrayIndex] == i) {\n', '                creditArrayIndex++;\n', '                advertiserBalances[publishers[i]] += publisherNetCut;\n', '                emit CreditPublisher(publishers[i], publisherNetCut, advertisers[i], advertiserBalances[publishers[i]]);\n', '            } else { // or send it to the publisher.\n', '                publishers[i].transfer(publisherNetCut);\n', '                emit PayoutToPublisher(publishers[i], publisherNetCut, advertisers[i]);\n', '            }\n', '\n', '            // send bitwords it&#39;s cut\n', '            bitwordsWithdrawlAddress.transfer(bitwordsNetCut);\n', '            emit PayoutToBitwords(bitwordsWithdrawlAddress, bitwordsNetCut, advertisers[i]);\n', '        }\n', '\n', '        inChargeAdvertisers = false;\n', '    }\n', '\n', '    /**\n', '     * Called by Bitwords to manually refund an advertiser.\n', '     *\n', '     * @param advertiser    The advertiser address to be refunded\n', '     * @param amount        The amount the advertiser would like to withdraw\n', '     */\n', '    bool private inRefundAdvertiser = false;\n', '    function refundAdvertiser (address advertiser, uint amount) onlyAnyOwners public {\n', '        // Ensure that the advertiser has enough balance to refund the smart\n', '        // contract\n', '        require(amount > 0, "Amount should be greater than 0");\n', '        require(advertiserBalances[advertiser] > 0, "Advertiser has no balance");\n', '        require(advertiserBalances[advertiser] >= amount, "Insufficient balance to refund");\n', '\n', '        // Prevent re-entry bug\n', '        require(!inRefundAdvertiser, "avoid rentry bug");\n', '        inRefundAdvertiser = true;\n', '\n', '        // deduct balance and send the ether\n', '        advertiserBalances[advertiser] -= amount;\n', '        advertiser.transfer(amount);\n', '\n', '        // Emit events\n', '        emit RefundAdvertiserProcessed(advertiser, amount, advertiserBalances[advertiser]);\n', '\n', '        inRefundAdvertiser = false;\n', '    }\n', '\n', '    /**\n', '     * Called by Bitwords to invalidate a refund sent by an advertiser.\n', '     */\n', '    function invalidateAdvertiserRefund (uint refundIndex) hasNotSuicided onlyOwner public {\n', '        require(refundIndex >= 0, "index should be greater than 0");\n', '        require(refundQueue.length >=  refundIndex, "index is out of bounds");\n', '        refundQueue[refundIndex].amount = 0;\n', '\n', '        emit RefundAdvertiserCancelled(refundQueue[refundIndex].advertiser);\n', '    }\n', '\n', '    /**\n', '     * Called by an advertiser when he/she would like to make a refund request.\n', '     *\n', '     * @param amount    The amount the advertiser would like to withdraw\n', '     */\n', '    function requestForRefund (uint amount) public {\n', '        // Make sure that advertisers are requesting a refund for how much ever\n', '        // ether they have.\n', '        require(amount > 0, "Amount should be greater than 0");\n', '        require(advertiserBalances[msg.sender] > 0, "You have no balance");\n', '        require(advertiserBalances[msg.sender] >= amount, "Insufficient balance to refund");\n', '\n', '        // push the refund request in a refundQueue so that it can be processed\n', '        // later.\n', '        refundQueue.push(refundRequest(msg.sender, amount, now, now + refundRequestTimelock));\n', '\n', '        // Add the index into a hashmap for later use\n', '        advertiserRefundRequestsIndex[msg.sender] = refundQueue.length - 1;\n', '\n', '        // Emit events\n', '        emit RefundAdvertiserRequested(msg.sender, amount, refundQueue.length - 1);\n', '    }\n', '\n', '    /**\n', '     * Called by an advertiser when he/she wants to manually process a refund\n', '     * that he/she has requested for earlier.\n', '     *\n', '     * This function will first find a refund request, check if it&#39;s valid (as\n', '     * in, has it passed it&#39;s timelock?, is there enough balance? etc.) and\n', '     * then process it, updating the advertiser&#39;s balance along the way.\n', '     */\n', '    mapping(address => bool) private inProcessMyRefund;\n', '    function processMyRefund () public {\n', '        // Check if a refund request even exists for this advertiser?\n', '        require(advertiserRefundRequestsIndex[msg.sender] >= 0, "no refund request found");\n', '\n', '        // Get the refund request details\n', '        uint refundRequestIndex = advertiserRefundRequestsIndex[msg.sender];\n', '\n', '        // Check if the refund has been proccessed\n', '        require(refundQueue[refundRequestIndex].amount > 0, "refund already proccessed");\n', '\n', '        // Check if the advertiser has enough balance to request for this refund?\n', '        require(\n', '            advertiserBalances[msg.sender] >= refundQueue[refundRequestIndex].amount,\n', '            "advertiser balance is low; refund amount is invalid."\n', '        );\n', '\n', '        // Check the timelock\n', '        require(\n', '            now > refundQueue[refundRequestIndex].processAfter,\n', '            "timelock for this request has not passed"\n', '        );\n', '\n', '        // Prevent reentry bug\n', '        require(!inProcessMyRefund[msg.sender], "prevent re-entry bug");\n', '        inProcessMyRefund[msg.sender] = true;\n', '\n', '        // Send the amount\n', '        uint amount = refundQueue[refundRequestIndex].amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        // update the new balance and void this request.\n', '        refundQueue[refundRequestIndex].amount = 0;\n', '        advertiserBalances[msg.sender] -= amount;\n', '\n', '        // reset the reentry flag\n', '        inProcessMyRefund[msg.sender] = false;\n', '\n', '        // Emit events\n', '        emit SelfRefundAdvertiser(msg.sender, amount, advertiserBalances[msg.sender]);\n', '        emit RefundAdvertiserProcessed(msg.sender, amount, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /** Events */\n', '    event BitwordsCutChanged(address indexed _to, uint _value);\n', '    event BitwordsWithdrawlAddressChanged(address indexed _to, address indexed _from);\n', '    event CreditPublisher(address indexed _to, uint _value, address indexed _from, uint _newBalance);\n', '    event DeductFromAdvertiser(address indexed _to, uint _value, uint _newBalance);\n', '    event Deposit(address indexed _to, uint _value, uint _newBalance);\n', '    event InsufficientBalance(address indexed _to, uint _balance, uint _valueToDeduct);\n', '    event PayoutToBitwords(address indexed _to, uint _value, address indexed _from);\n', '    event PayoutToPublisher(address indexed _to, uint _value, address indexed _from);\n', '    event RefundAdvertiserCancelled(address indexed _to);\n', '    event RefundAdvertiserProcessed(address indexed _to, uint _value, uint _newBalance);\n', '    event RefundAdvertiserRequested(address indexed _to, uint _value, uint requestIndex);\n', '    event SelfRefundAdvertiser(address indexed _to, uint _value, uint _newBalance);\n', '    event SetPublisherCut(address indexed _to, uint _value);\n', '    event TimelockChanged(address indexed _to, uint _value);\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' *\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    // A hashmap to help keep track of list of all owners\n', '    mapping(address => uint) public allOwnersMap;\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () public {\n', '        owner = msg.sender;\n', '        allOwnersMap[msg.sender] = 1;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "You\'re not the owner!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the all owners in the history of\n', '     * the smart contract.\n', '     */\n', '    modifier onlyAnyOwners() {\n', '        require(allOwnersMap[msg.sender] == 1, "You\'re not the owner or never were the owner!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '\n', '        // Keep track of list of owners\n', '        allOwnersMap[newOwner] = 1;\n', '    }\n', '\n', '\n', '    // transfer ownership event\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Suicidable\n', ' *\n', ' * @dev Suicidable is special contract with functions to suicide. This is a security measure added in\n', ' * incase Bitwords gets hacked.\n', ' */\n', 'contract Suicidable is Ownable {\n', '    bool public hasSuicided = false;\n', '\n', '\n', '    /**\n', '     * @dev Throws if called the contract has not yet suicided\n', '     */\n', '    modifier hasNotSuicided() {\n', '        require(hasSuicided == false, "Contract has suicided!");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Suicides the entire smart contract\n', '     */\n', '    function suicideContract() public onlyAnyOwners {\n', '        hasSuicided = true;\n', '        emit SuicideContract(msg.sender);\n', '    }\n', '\n', '\n', '    // suicide contract event\n', '    event SuicideContract(address indexed owner);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Migratable\n', ' *\n', ' * @dev Migratable is special contract which allows the funds of a smart-contact to be migrated\n', ' * to a new smart contract.\n', ' */\n', 'contract Migratable is Suicidable {\n', '    bool public hasRequestedForMigration = false;\n', '    uint public requestedForMigrationAt = 0;\n', '    address public migrationDestination;\n', '\n', '    function() public payable {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows for a migration request to be created, all migrations requests\n', '     * are timelocked by 7 days.\n', '     *\n', '     * @param destination   The destination to send the ether to.\n', '     */\n', '    function requestForMigration(address destination) public onlyOwner {\n', '        hasRequestedForMigration = true;\n', '        requestedForMigrationAt = now;\n', '        migrationDestination = destination;\n', '\n', '        emit MigrateFundsRequested(msg.sender, destination);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancels a migration\n', '     */\n', '    function cancelMigration() public onlyOwner hasNotSuicided {\n', '        hasRequestedForMigration = false;\n', '        requestedForMigrationAt = 0;\n', '\n', '        emit MigrateFundsCancelled(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approves a migration and suicides the entire smart contract\n', '     */\n', '    function approveMigration(uint gasCostInGwei) public onlyOwner hasNotSuicided {\n', '        require(hasRequestedForMigration, "please make a migration request");\n', '        require(requestedForMigrationAt + 604800 < now, "migration is timelocked for 7 days");\n', '        require(gasCostInGwei > 0, "gas cost must be more than 0");\n', '        require(gasCostInGwei < 20, "gas cost can\'t be more than 20");\n', '\n', '        // Figure out how much ether to send\n', '        uint gasLimit = 21000;\n', '        uint gasPrice = gasCostInGwei * 1000000000;\n', '        uint gasCost = gasLimit * gasPrice;\n', '        uint etherToSend = address(this).balance - gasCost;\n', '\n', '        require(etherToSend > 0, "not enough balance in smart contract");\n', '\n', '        // Send the funds to the new smart contract\n', '        emit MigrateFundsApproved(msg.sender, etherToSend);\n', '        migrationDestination.transfer(etherToSend);\n', '\n', '        // suicide the contract so that no more funds/actions can take place\n', '        suicideContract();\n', '    }\n', '\n', '    // events\n', '    event MigrateFundsCancelled(address indexed by);\n', '    event MigrateFundsRequested(address indexed by, address indexed newSmartContract);\n', '    event MigrateFundsApproved(address indexed by, uint amount);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Bitwords\n', ' *\n', ' * @dev The Bitwords smart contract that allows advertisers and publishers to\n', ' * safetly deposit/receive ether and interact with the Bitwords platform.\n', ' *\n', ' * TODO:\n', ' *  - timelock all chargeAdvertiser requests\n', ' *  - if suicide is called, then all timelocked requests need to be stopped and then later reversed\n', ' */\n', 'contract Bitwords is Migratable {\n', '    mapping(address => uint) public advertiserBalances;\n', '\n', '    // This mapping overrides the default bitwords cut for a specific publisher.\n', '    mapping(address => uint) public bitwordsCutOverride;\n', '\n', '    // The bitwords address, where all the 30% cut is received ETH\n', '    address public bitwordsWithdrawlAddress;\n', '\n', '    // How much cut out of 100 Bitwords takes. By default 10%\n', '    uint public bitwordsCutOutof100 = 10;\n', '\n', '    // To store the advertiserChargeRequests\n', '    // TODO: this needs to be used for the timelock\n', '    struct advertiserChargeRequest {\n', '        address advertiser;\n', '        address publisher;\n', '        uint amount;\n', '        uint requestedAt;\n', '        uint processAfter;\n', '    }\n', '\n', '    // How much days should each refund request be timelocked for\n', '    uint public refundRequestTimelock = 7 days;\n', '\n', '    // To store refund request\n', '    struct refundRequest {\n', '        address advertiser;\n', '        uint amount;\n', '        uint requestedAt;\n', '        uint processAfter;\n', '    }\n', '\n', '    // An array of all the refund requests submitted by advertisers.\n', '    refundRequest[] public refundQueue;\n', '\n', '    // variables that help track where in the refund loop we are in.\n', '    mapping(address => uint) private advertiserRefundRequestsIndex;\n', '    uint private lastProccessedIndex = 0;\n', '\n', '\n', '    /**\n', '     * @dev The Bitwords constructor sets the address where all the withdrawals will\n', '     * happen.\n', '     */\n', '    constructor () public {\n', '        bitwordsWithdrawlAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Anybody who deposits ether to the smart contract will be considered as an\n', '     * advertiser and will get that much ether debitted into his account.\n', '     */\n', '    function() public payable {\n', '        advertiserBalances[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /**\n', '     * Used by the owner to set the withdrawal address for Bitwords. This address\n', '     * is where Bitwords will receive all the cut from the advertisements.\n', '     *\n', '     * @param newAddress    the new withdrawal address\n', '     */\n', '    function setBitwordsWithdrawlAddress (address newAddress) hasNotSuicided onlyOwner public {\n', '        bitwordsWithdrawlAddress = newAddress;\n', '\n', '        emit BitwordsWithdrawlAddressChanged(msg.sender, newAddress);\n', '    }\n', '\n', '    /**\n', '     * Change the cut that Bitwords takes.\n', '     *\n', '     * @param cut   the amount of cut that Bitwords takes.\n', '     */\n', '    function setBitwordsCut (uint cut) hasNotSuicided onlyOwner public {\n', '        require(cut <= 30, "cut cannot be more than 30%");\n', '        require(cut >= 0, "cut should be greater than 0%");\n', '        bitwordsCutOutof100 = cut;\n', '\n', '        emit BitwordsCutChanged(msg.sender, cut);\n', '    }\n', '\n', '    /**\n', '     * Set the new timelock for refund reuqests\n', '     *\n', '     * @param newTimelock   the new timelock\n', '     */\n', '    function setRefundTimelock (uint newTimelock) hasNotSuicided onlyOwner public {\n', '        require(newTimelock >= 0, "timelock has to be greater than 0");\n', '        refundRequestTimelock = newTimelock;\n', '\n', '        emit TimelockChanged(msg.sender, newTimelock);\n', '    }\n', '\n', '    /**\n', '     * Process all the refund requests in the queue. This is called by the Bitwords\n', '     * server ideally right after chargeAdvertisers has been called.\n', '     *\n', "     * This function will only process refunds that have passed it's timelock and\n", '     * it will only refund maximum to how much the advertiser currently has in\n', '     * his balance.\n', '     */\n', '    bool private inProcessRefunds = false;\n', '    function processRefunds () onlyAnyOwners public {\n', '        // prevent reentry bug\n', '        require(!inProcessRefunds, "prevent reentry bug");\n', '        inProcessRefunds = true;\n', '\n', '        for (uint j = lastProccessedIndex; j < refundQueue.length; j++) {\n', "            // If we haven't passed the timelock for this refund request, then\n", '            // we stop the loop. Reaching here means that all the requests\n', '            // in next iterations have also not reached their timelocks.\n', '            if (refundQueue[j].processAfter > now) break;\n', '\n', '            // Find the minimum that needs to be withdrawn. This is important\n', '            // because since every call to chargeAdvertisers might update the\n', "            // advertiser's balance, it is possible that the amount that the\n", '            // advertiser requests for is small.\n', '            uint cappedAmount = refundQueue[j].amount;\n', '            if (advertiserBalances[refundQueue[j].advertiser] < cappedAmount)\n', '                cappedAmount = advertiserBalances[refundQueue[j].advertiser];\n', '\n', '            // This refund is now invalid, skip it\n', '            if (cappedAmount <= 0) {\n', '                lastProccessedIndex++;\n', '                continue;\n', '            }\n', '\n', "            // deduct advertiser's balance and send the ether\n", '            advertiserBalances[refundQueue[j].advertiser] -= cappedAmount;\n', '            refundQueue[j].advertiser.transfer(cappedAmount);\n', '            refundQueue[j].amount = 0;\n', '\n', '            // Emit events\n', '            emit RefundAdvertiserProcessed(refundQueue[j].advertiser, cappedAmount, advertiserBalances[refundQueue[j].advertiser]);\n', '\n', '            // Increment the last proccessed index, effectively marking this\n', '            // refund request as completed.\n', '            lastProccessedIndex++;\n', '        }\n', '\n', '        inProcessRefunds = false;\n', '    }\n', '\n', '    /**\n', '     * Anybody can credit ether on behalf of an advertiser\n', '     *\n', '     * @param advertiser    The advertiser to credit ether to\n', '     */\n', '    function creditAdvertiser (address advertiser) hasNotSuicided public payable {\n', '        advertiserBalances[advertiser] += msg.value;\n', '        emit Deposit(advertiser, msg.value, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /**\n', '     * Anybody can credit ether on behalf of an advertiser\n', '     *\n', '     * @param publisher    The address of the publisher\n', '     * @param cut          How much cut should be taken from this publisher\n', '     */\n', '    function setPublisherCut (address publisher, uint cut) hasNotSuicided onlyOwner public {\n', '        require(cut <= 30, "cut cannot be more than 30%");\n', '        require(cut >= 0, "cut should be greater than 0%");\n', '\n', '        bitwordsCutOverride[publisher] = cut;\n', '        emit SetPublisherCut(publisher, cut);\n', '    }\n', '\n', '    /**\n', '     * Charge the advertiser with whatever clicks have been served by the ad engine.\n', '     *\n', '     * @param advertisers           Array of address of the advertiser from whom we should debit ether\n', '     * @param costs                 Array of the cost to be paid to publisher by advertisers\n', '     * @param publishers            Array of address of the publisher from whom we should credit ether\n', '     * @param publishersToCredit    Array of indices of publishers that need to be credited than debited.\n', '     */\n', '    bool private inChargeAdvertisers = false;\n', '    function chargeAdvertisers (address[] advertisers, uint[] costs, address[] publishers, uint[] publishersToCredit) hasNotSuicided onlyOwner public {\n', '        // Prevent re-entry bug\n', '        require(!inChargeAdvertisers, "avoid rentry bug");\n', '        inChargeAdvertisers = true;\n', '\n', '        uint creditArrayIndex = 0;\n', '\n', '        for (uint i = 0; i < advertisers.length; i++) {\n', '            uint toWithdraw = costs[i];\n', '\n', '            // First check if all advertisers have enough balance and cap it if needed\n', '            if (advertiserBalances[advertisers[i]] <= 0) {\n', '                emit InsufficientBalance(advertisers[i], advertiserBalances[advertisers[i]], costs[i]);\n', '                continue;\n', '            }\n', '            if (advertiserBalances[advertisers[i]] < toWithdraw) toWithdraw = advertiserBalances[advertisers[i]];\n', '\n', "            // Update the advertiser's balance\n", '            advertiserBalances[advertisers[i]] -= toWithdraw;\n', '            emit DeductFromAdvertiser(advertisers[i], toWithdraw, advertiserBalances[advertisers[i]]);\n', '\n', '            // Calculate how much cut Bitwords should take\n', '            uint bitwordsCut = bitwordsCutOutof100;\n', '            if (bitwordsCutOverride[publishers[i]] > 0 && bitwordsCutOverride[publishers[i]] <= 30) {\n', '                bitwordsCut = bitwordsCutOverride[publishers[i]];\n', '            }\n', '\n', '            // Figure out how much should go to Bitwords and to the publishers.\n', '            uint publisherNetCut = toWithdraw * (100 - bitwordsCut) / 100;\n', '            uint bitwordsNetCut = toWithdraw - publisherNetCut;\n', '\n', '            // Send the ether to the publisher and to Bitwords\n', '            // Either decide to credit the ether as an advertiser\n', '            if (publishersToCredit.length > creditArrayIndex && publishersToCredit[creditArrayIndex] == i) {\n', '                creditArrayIndex++;\n', '                advertiserBalances[publishers[i]] += publisherNetCut;\n', '                emit CreditPublisher(publishers[i], publisherNetCut, advertisers[i], advertiserBalances[publishers[i]]);\n', '            } else { // or send it to the publisher.\n', '                publishers[i].transfer(publisherNetCut);\n', '                emit PayoutToPublisher(publishers[i], publisherNetCut, advertisers[i]);\n', '            }\n', '\n', "            // send bitwords it's cut\n", '            bitwordsWithdrawlAddress.transfer(bitwordsNetCut);\n', '            emit PayoutToBitwords(bitwordsWithdrawlAddress, bitwordsNetCut, advertisers[i]);\n', '        }\n', '\n', '        inChargeAdvertisers = false;\n', '    }\n', '\n', '    /**\n', '     * Called by Bitwords to manually refund an advertiser.\n', '     *\n', '     * @param advertiser    The advertiser address to be refunded\n', '     * @param amount        The amount the advertiser would like to withdraw\n', '     */\n', '    bool private inRefundAdvertiser = false;\n', '    function refundAdvertiser (address advertiser, uint amount) onlyAnyOwners public {\n', '        // Ensure that the advertiser has enough balance to refund the smart\n', '        // contract\n', '        require(amount > 0, "Amount should be greater than 0");\n', '        require(advertiserBalances[advertiser] > 0, "Advertiser has no balance");\n', '        require(advertiserBalances[advertiser] >= amount, "Insufficient balance to refund");\n', '\n', '        // Prevent re-entry bug\n', '        require(!inRefundAdvertiser, "avoid rentry bug");\n', '        inRefundAdvertiser = true;\n', '\n', '        // deduct balance and send the ether\n', '        advertiserBalances[advertiser] -= amount;\n', '        advertiser.transfer(amount);\n', '\n', '        // Emit events\n', '        emit RefundAdvertiserProcessed(advertiser, amount, advertiserBalances[advertiser]);\n', '\n', '        inRefundAdvertiser = false;\n', '    }\n', '\n', '    /**\n', '     * Called by Bitwords to invalidate a refund sent by an advertiser.\n', '     */\n', '    function invalidateAdvertiserRefund (uint refundIndex) hasNotSuicided onlyOwner public {\n', '        require(refundIndex >= 0, "index should be greater than 0");\n', '        require(refundQueue.length >=  refundIndex, "index is out of bounds");\n', '        refundQueue[refundIndex].amount = 0;\n', '\n', '        emit RefundAdvertiserCancelled(refundQueue[refundIndex].advertiser);\n', '    }\n', '\n', '    /**\n', '     * Called by an advertiser when he/she would like to make a refund request.\n', '     *\n', '     * @param amount    The amount the advertiser would like to withdraw\n', '     */\n', '    function requestForRefund (uint amount) public {\n', '        // Make sure that advertisers are requesting a refund for how much ever\n', '        // ether they have.\n', '        require(amount > 0, "Amount should be greater than 0");\n', '        require(advertiserBalances[msg.sender] > 0, "You have no balance");\n', '        require(advertiserBalances[msg.sender] >= amount, "Insufficient balance to refund");\n', '\n', '        // push the refund request in a refundQueue so that it can be processed\n', '        // later.\n', '        refundQueue.push(refundRequest(msg.sender, amount, now, now + refundRequestTimelock));\n', '\n', '        // Add the index into a hashmap for later use\n', '        advertiserRefundRequestsIndex[msg.sender] = refundQueue.length - 1;\n', '\n', '        // Emit events\n', '        emit RefundAdvertiserRequested(msg.sender, amount, refundQueue.length - 1);\n', '    }\n', '\n', '    /**\n', '     * Called by an advertiser when he/she wants to manually process a refund\n', '     * that he/she has requested for earlier.\n', '     *\n', "     * This function will first find a refund request, check if it's valid (as\n", "     * in, has it passed it's timelock?, is there enough balance? etc.) and\n", "     * then process it, updating the advertiser's balance along the way.\n", '     */\n', '    mapping(address => bool) private inProcessMyRefund;\n', '    function processMyRefund () public {\n', '        // Check if a refund request even exists for this advertiser?\n', '        require(advertiserRefundRequestsIndex[msg.sender] >= 0, "no refund request found");\n', '\n', '        // Get the refund request details\n', '        uint refundRequestIndex = advertiserRefundRequestsIndex[msg.sender];\n', '\n', '        // Check if the refund has been proccessed\n', '        require(refundQueue[refundRequestIndex].amount > 0, "refund already proccessed");\n', '\n', '        // Check if the advertiser has enough balance to request for this refund?\n', '        require(\n', '            advertiserBalances[msg.sender] >= refundQueue[refundRequestIndex].amount,\n', '            "advertiser balance is low; refund amount is invalid."\n', '        );\n', '\n', '        // Check the timelock\n', '        require(\n', '            now > refundQueue[refundRequestIndex].processAfter,\n', '            "timelock for this request has not passed"\n', '        );\n', '\n', '        // Prevent reentry bug\n', '        require(!inProcessMyRefund[msg.sender], "prevent re-entry bug");\n', '        inProcessMyRefund[msg.sender] = true;\n', '\n', '        // Send the amount\n', '        uint amount = refundQueue[refundRequestIndex].amount;\n', '        msg.sender.transfer(amount);\n', '\n', '        // update the new balance and void this request.\n', '        refundQueue[refundRequestIndex].amount = 0;\n', '        advertiserBalances[msg.sender] -= amount;\n', '\n', '        // reset the reentry flag\n', '        inProcessMyRefund[msg.sender] = false;\n', '\n', '        // Emit events\n', '        emit SelfRefundAdvertiser(msg.sender, amount, advertiserBalances[msg.sender]);\n', '        emit RefundAdvertiserProcessed(msg.sender, amount, advertiserBalances[msg.sender]);\n', '    }\n', '\n', '    /** Events */\n', '    event BitwordsCutChanged(address indexed _to, uint _value);\n', '    event BitwordsWithdrawlAddressChanged(address indexed _to, address indexed _from);\n', '    event CreditPublisher(address indexed _to, uint _value, address indexed _from, uint _newBalance);\n', '    event DeductFromAdvertiser(address indexed _to, uint _value, uint _newBalance);\n', '    event Deposit(address indexed _to, uint _value, uint _newBalance);\n', '    event InsufficientBalance(address indexed _to, uint _balance, uint _valueToDeduct);\n', '    event PayoutToBitwords(address indexed _to, uint _value, address indexed _from);\n', '    event PayoutToPublisher(address indexed _to, uint _value, address indexed _from);\n', '    event RefundAdvertiserCancelled(address indexed _to);\n', '    event RefundAdvertiserProcessed(address indexed _to, uint _value, uint _newBalance);\n', '    event RefundAdvertiserRequested(address indexed _to, uint _value, uint requestIndex);\n', '    event SelfRefundAdvertiser(address indexed _to, uint _value, uint _newBalance);\n', '    event SetPublisherCut(address indexed _to, uint _value);\n', '    event TimelockChanged(address indexed _to, uint _value);\n', '}']
