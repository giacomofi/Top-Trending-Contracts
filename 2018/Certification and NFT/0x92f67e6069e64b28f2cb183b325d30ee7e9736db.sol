['pragma solidity ^0.4.20;\n', '    \n', 'contract LocusOne {\n', '\n', '    \taddress devAcct;\n', '    \taddress potAcct;\n', '    \tuint fee;\n', '    \tuint pot;\n', '\n', '    function() public payable {\n', '        \n', '    _split(msg.value); \n', '    }\n', '\n', '    function _split(uint _stake) internal {\n', '        if (msg.value < 0.05 ether || msg.value > 1000000 ether)\n', '            revert();\n', '        // Define the Locus dev account\n', '        devAcct = 0x1daa0BFDEDfB133ec6aEd2F66D64cA88BeC3f0B4;\n', '        // Define the Locus Pot account (what you&#39;re all playing for)      \n', '        potAcct = 0x708294833AEF21a305200b3463A832Ac97852f2e;        \n', '        // msg.sender is the address of the caller.\n', '\n', '        // 20% of the total Ether sent will be used to pay devs/support project.\n', '        fee = div(_stake, 5);\n', '        \n', '        // The remaining amount of Ether wll be sent to fund/stake the pot.\n', '        pot = sub(_stake, fee);\n', '\n', '        devAcct.transfer(fee);\n', '        potAcct.transfer(pot);\n', '\n', '    }\n', '\n', '            // The below are safemath implementations of the four arithmetic operators\n', '    // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    // not needed until later\n', '    //function sumproduct(uint256 sn, uint256 %cl) internal pure returns (uint256) {\n', '    //    uint256 c = a * b;\n', '    //    assert(c / a == b);\n', '    //    return c;\n', '    //}\n', ' }']
['pragma solidity ^0.4.20;\n', '    \n', 'contract LocusOne {\n', '\n', '    \taddress devAcct;\n', '    \taddress potAcct;\n', '    \tuint fee;\n', '    \tuint pot;\n', '\n', '    function() public payable {\n', '        \n', '    _split(msg.value); \n', '    }\n', '\n', '    function _split(uint _stake) internal {\n', '        if (msg.value < 0.05 ether || msg.value > 1000000 ether)\n', '            revert();\n', '        // Define the Locus dev account\n', '        devAcct = 0x1daa0BFDEDfB133ec6aEd2F66D64cA88BeC3f0B4;\n', "        // Define the Locus Pot account (what you're all playing for)      \n", '        potAcct = 0x708294833AEF21a305200b3463A832Ac97852f2e;        \n', '        // msg.sender is the address of the caller.\n', '\n', '        // 20% of the total Ether sent will be used to pay devs/support project.\n', '        fee = div(_stake, 5);\n', '        \n', '        // The remaining amount of Ether wll be sent to fund/stake the pot.\n', '        pot = sub(_stake, fee);\n', '\n', '        devAcct.transfer(fee);\n', '        potAcct.transfer(pot);\n', '\n', '    }\n', '\n', '            // The below are safemath implementations of the four arithmetic operators\n', '    // designed to explicitly prevent over- and under-flows of integer values.\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    // not needed until later\n', '    //function sumproduct(uint256 sn, uint256 %cl) internal pure returns (uint256) {\n', '    //    uint256 c = a * b;\n', '    //    assert(c / a == b);\n', '    //    return c;\n', '    //}\n', ' }']
