['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '  ERC20 public token;\n', '  address public wallet;\n', '  uint256 public rate;\n', '  uint256 public weiRaised;\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    rate = _rate;\n', '    wallet = _wallet;\n', '    token = _token;\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {\n', '    uint256 weiAmount = msg.value;\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    _processPurchase(_beneficiary, tokens);\n', '    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '    _updatePurchasingState(_beneficiary, weiAmount);\n', '    _forwardFunds();\n', '    _postValidatePurchase(_beneficiary, weiAmount);\n', '  }\n', '\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '\n', '  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n', '  }\n', '\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    token.transfer(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n', '  }\n', '\n', '  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '    return _weiAmount.mul(rate);\n', '  }\n', '\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '}\n', '\n', 'contract TimedCrowdsale is Crowdsale {\n', '  using SafeMath for uint256;\n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '\n', '  modifier onlyWhileOpen {\n', '    require(now >= openingTime && now <= closingTime);\n', '    _;\n', '  }\n', '\n', '  function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n', '    require(_openingTime >= now);\n', '    require(_closingTime >= _openingTime);\n', '    openingTime = _openingTime;\n', '    closingTime = _closingTime;\n', '  }\n', '\n', '  function hasClosed() public view returns (bool) {\n', '    return now > closingTime;\n', '  }\n', '  \n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n', '    super._preValidatePurchase(_beneficiary, _weiAmount);\n', '  }\n', '}\n', '\n', 'contract CappedCrowdsale is Crowdsale {\n', '  using SafeMath for uint256;\n', '  uint256 public cap;\n', '\n', '  function CappedCrowdsale(uint256 _cap) public {\n', '    require(_cap > 0);\n', '    cap = _cap;\n', '  }\n', '\n', '  function capReached() public view returns (bool) {\n', '    return weiRaised >= cap;\n', '  }\n', '\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n', '    super._preValidatePurchase(_beneficiary, _weiAmount);\n', '    require(weiRaised.add(_weiAmount) <= cap);\n', '  }\n', '}\n', '\n', 'contract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n', '  using SafeMath for uint256;\n', '  bool public isFinalized = false;\n', '  event Finalized();\n', '\n', '  function finalize() onlyOwner public {\n', '    require(!isFinalized);\n', '    require(hasClosed());\n', '    finalization();\n', '    Finalized();\n', '    isFinalized = true;\n', '  }\n', '\n', '  function finalization() internal {\n', '  }\n', '}\n', '\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '  enum State { Active, Refunding, Closed }\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '  function RefundVault(address _wallet) public {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    Closed();\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    RefundsEnabled();\n', '  }\n', '\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    Refunded(investor, depositedValue);\n', '  }\n', '}\n', '\n', 'contract RefundableCrowdsale is FinalizableCrowdsale {\n', '  using SafeMath for uint256;\n', '  uint256 public goal;\n', '  RefundVault public vault;\n', '\n', '  function RefundableCrowdsale(uint256 _goal) public {\n', '    require(_goal > 0);\n', '    vault = new RefundVault(wallet);\n', '    goal = _goal;\n', '  }\n', '\n', '  function claimRefund() public {\n', '    require(isFinalized);\n', '    require(!goalReached());\n', '    vault.refund(msg.sender);\n', '  }\n', '\n', '  function goalReached() public view returns (bool) {\n', '    return weiRaised >= goal;\n', '  }\n', '\n', '  function finalization() internal {\n', '    if (goalReached()) {\n', '      vault.close();\n', '    } else {\n', '      vault.enableRefunds();\n', '    }\n', '    super.finalization();\n', '  }\n', '\n', '  function _forwardFunds() internal {\n', '    vault.deposit.value(msg.value)(msg.sender);\n', '  }\n', '}\n', '\n', 'contract EladCrowdsale is RefundableCrowdsale, CappedCrowdsale {\n', '  uint8 public constant decimals = 18;\n', '  \n', '  uint256 private constant _goal = 200 * 10 ** uint256(decimals);\n', '  uint256 private constant _openingTime = 1524470400;\n', '  uint256 private constant _closingTime = 1527494400;\n', '  uint256 private constant _cap = 3000 * 10 ** uint256(decimals);\n', '  uint256 private constant _rate = 5000;\n', '  address private constant _wallet = 0x58d313d393fb5e3f729047768ce7a81b115509f1;\n', '  ERC20 private _token = ERC20(0x81176f21249aAE53b4de4d507A847F33c26fa794);\n', '\n', '  function EladCrowdsale() public\n', '    Crowdsale(_rate, _wallet, _token)\n', '    CappedCrowdsale(_cap)\n', '    TimedCrowdsale(_openingTime, _closingTime)\n', '    RefundableCrowdsale(_goal) {\n', '    require(_goal <= _cap);\n', '  }\n', '\n', '  function isOpen() public view returns (bool) {\n', '    return now >= openingTime && now <= closingTime;\n', '  }\n', '\n', '  function allocateRemainingTokens() onlyOwner public {\n', '    require(isFinalized);\n', '    uint256 remaining = token.balanceOf(this);\n', '    token.transfer(owner, remaining);\n', '  }\n', '}']