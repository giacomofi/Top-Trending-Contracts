['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owned {\n', '     address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', ' \n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EthExploder is Owned { \n', '    uint256 public jackpotSmall;\n', '    uint256 public jackpotMedium; \n', '    uint256 public jackpotLarge; \n', '    \n', '    uint256 public houseEarnings; \n', '    uint256 public houseTotal; \n', '    \n', '    uint256 public gameCount; \n', '    \n', '    uint16 public smallCount; \n', '    uint16 public mediumCount; \n', '    uint16 public largeCount; \n', '    \n', '    uint16 public smallSize; \n', '    uint16 public mediumSize;\n', '    uint16 public largeSize; \n', '    \n', '    uint256 public seed; \n', '    \n', '    mapping (uint16 => address) playersSmall; \n', '    mapping (uint16 => address) playersMedium; \n', '    mapping (uint16 => address) playersLarge; \n', '    \n', '    function enterSmall() payable {\n', '        require(msg.value > 0);\n', '        \n', '        jackpotSmall += msg.value; \n', '        playersSmall[smallCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '        \n', '        if (smallCount < smallSize-1) { \n', '            smallCount++;\n', '        } else { \n', '            seed += gameCount + mediumCount + largeCount;\n', '            houseEarnings += (jackpotSmall*3)/100;\n', '            jackpotSmall -= (jackpotSmall*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % smallSize); \n', '            address winning = playersSmall[winner]; \n', '           \n', '            \n', '            //Reset the game: \n', '            smallCount = 0; \n', '            uint256 amt = jackpotSmall;\n', '            jackpotSmall = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(0,winning,amt); \n', '        }\n', '    }\n', '    \n', '    function enterMedium() payable { \n', '        require(msg.value > 0); \n', '        \n', '        jackpotMedium += msg.value; \n', '        playersMedium[mediumCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '         \n', '        if (mediumCount < mediumSize-1) { \n', '            mediumCount++;\n', '        } else { \n', '            seed += gameCount + smallCount + largeCount;\n', '            houseEarnings += (jackpotMedium*3)/100;\n', '            jackpotMedium -= (jackpotMedium*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % mediumSize); \n', '            address winning = playersMedium[winner];\n', '            //winning.transfer(jackpotMedium); \n', '            \n', '            //Reset the game \n', '            mediumCount = 0; \n', '            uint256 amt = jackpotMedium;\n', '            jackpotMedium = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(1,winning,amt); \n', '\n', '        }\n', '    }\n', '    \n', '    function enterLarge() payable { \n', '        require(msg.value > 0); \n', '        \n', '        jackpotLarge += msg.value; \n', '        playersLarge[largeCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '        \n', '        if (largeCount < largeSize-1) { \n', '            largeCount++; \n', '        } else { \n', '            seed += gameCount + mediumCount + largeCount; \n', '            houseEarnings += (jackpotLarge*3)/100;\n', '            jackpotLarge -= (jackpotLarge*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % largeSize); \n', '            address winning = playersLarge[winner];\n', '            \n', '            //Reset the game \n', '            largeCount = 0; \n', '            uint256 amt = jackpotLarge;\n', '            jackpotLarge = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(2,winning,amt); \n', '\n', '        }\n', '        \n', '    }\n', '    \n', '    function setPools(uint16 sm, uint16 med, uint16 lrg) onlyOwner { \n', '        smallSize = sm; \n', '        mediumSize = med; \n', '        largeSize = lrg; \n', '    }\n', '    \n', '    function claim(address payment) onlyOwner { \n', '        payment.transfer(houseEarnings); \n', '        houseTotal += houseEarnings; \n', '        houseEarnings = 0; \n', '    }\n', '    \n', '    //Prevent accidental ether sending \n', '    function () payable { \n', '     revert(); \n', ' }\n', '\n', ' event GameWon(uint8 gameType, address winner, uint256 winnings); \n', '    \n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owned {\n', '     address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', ' \n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '        }\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EthExploder is Owned { \n', '    uint256 public jackpotSmall;\n', '    uint256 public jackpotMedium; \n', '    uint256 public jackpotLarge; \n', '    \n', '    uint256 public houseEarnings; \n', '    uint256 public houseTotal; \n', '    \n', '    uint256 public gameCount; \n', '    \n', '    uint16 public smallCount; \n', '    uint16 public mediumCount; \n', '    uint16 public largeCount; \n', '    \n', '    uint16 public smallSize; \n', '    uint16 public mediumSize;\n', '    uint16 public largeSize; \n', '    \n', '    uint256 public seed; \n', '    \n', '    mapping (uint16 => address) playersSmall; \n', '    mapping (uint16 => address) playersMedium; \n', '    mapping (uint16 => address) playersLarge; \n', '    \n', '    function enterSmall() payable {\n', '        require(msg.value > 0);\n', '        \n', '        jackpotSmall += msg.value; \n', '        playersSmall[smallCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '        \n', '        if (smallCount < smallSize-1) { \n', '            smallCount++;\n', '        } else { \n', '            seed += gameCount + mediumCount + largeCount;\n', '            houseEarnings += (jackpotSmall*3)/100;\n', '            jackpotSmall -= (jackpotSmall*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % smallSize); \n', '            address winning = playersSmall[winner]; \n', '           \n', '            \n', '            //Reset the game: \n', '            smallCount = 0; \n', '            uint256 amt = jackpotSmall;\n', '            jackpotSmall = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(0,winning,amt); \n', '        }\n', '    }\n', '    \n', '    function enterMedium() payable { \n', '        require(msg.value > 0); \n', '        \n', '        jackpotMedium += msg.value; \n', '        playersMedium[mediumCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '         \n', '        if (mediumCount < mediumSize-1) { \n', '            mediumCount++;\n', '        } else { \n', '            seed += gameCount + smallCount + largeCount;\n', '            houseEarnings += (jackpotMedium*3)/100;\n', '            jackpotMedium -= (jackpotMedium*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % mediumSize); \n', '            address winning = playersMedium[winner];\n', '            //winning.transfer(jackpotMedium); \n', '            \n', '            //Reset the game \n', '            mediumCount = 0; \n', '            uint256 amt = jackpotMedium;\n', '            jackpotMedium = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(1,winning,amt); \n', '\n', '        }\n', '    }\n', '    \n', '    function enterLarge() payable { \n', '        require(msg.value > 0); \n', '        \n', '        jackpotLarge += msg.value; \n', '        playersLarge[largeCount] = msg.sender; \n', '        seed += uint256(msg.sender);\n', '        \n', '        if (largeCount < largeSize-1) { \n', '            largeCount++; \n', '        } else { \n', '            seed += gameCount + mediumCount + largeCount; \n', '            houseEarnings += (jackpotLarge*3)/100;\n', '            jackpotLarge -= (jackpotLarge*3)/100;\n', '            \n', '            uint16 winner = uint16(seed % largeSize); \n', '            address winning = playersLarge[winner];\n', '            \n', '            //Reset the game \n', '            largeCount = 0; \n', '            uint256 amt = jackpotLarge;\n', '            jackpotLarge = 0; \n', '            winning.transfer(amt);\n', '            gameCount++;\n', '            emit GameWon(2,winning,amt); \n', '\n', '        }\n', '        \n', '    }\n', '    \n', '    function setPools(uint16 sm, uint16 med, uint16 lrg) onlyOwner { \n', '        smallSize = sm; \n', '        mediumSize = med; \n', '        largeSize = lrg; \n', '    }\n', '    \n', '    function claim(address payment) onlyOwner { \n', '        payment.transfer(houseEarnings); \n', '        houseTotal += houseEarnings; \n', '        houseEarnings = 0; \n', '    }\n', '    \n', '    //Prevent accidental ether sending \n', '    function () payable { \n', '     revert(); \n', ' }\n', '\n', ' event GameWon(uint8 gameType, address winner, uint256 winnings); \n', '    \n', '}']
