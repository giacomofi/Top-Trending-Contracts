['pragma solidity 0.4.18;\n', '\n', 'contract Token { // ERC20 standard\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '  function safeMul(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function safeSub(uint a, uint b) pure internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function safeAdd(uint a, uint b) pure internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '  function safeNumDigits(uint number) pure internal returns (uint8) {\n', '    uint8 digits = 0;\n', '    while (number != 0) {\n', '        number /= 10;\n', '        digits++;\n', '    }\n', '    return digits;\n', '}\n', '\n', '  // mitigate short address attack\n', '  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '  // TODO: doublecheck implication of >= compared to ==\n', '  modifier onlyPayloadSize(uint numWords) {\n', '     assert(msg.data.length >= numWords * 32 + 4);\n', '     _;\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value && _value > 0);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // To change the approve amount you first have to reduce the addresses'\n", "    //  allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    function approve(address _spender, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) public onlyPayloadSize(3) returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _oldValue);\n', '        allowed[msg.sender][_spender] = _newValue;\n', '        Approval(msg.sender, _spender, _newValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '}\n', '\n', 'contract GRO is StandardToken {\n', '    // FIELDS\n', '    string public name = "Gron Digital";\n', '    string public symbol = "GRO";\n', '    uint256 public decimals = 18;\n', '    string public version = "11.0";\n', '\n', '    // Nine Hundred and Fifty million with support for 18 decimals\n', '    uint256 public tokenCap = 950000000 * 10**18;\n', '\n', '    // crowdsale parameters\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingEndBlock;\n', '\n', '    // vesting fields\n', '    address public vestingContract;\n', '    bool private vestingSet = false;\n', '\n', '    // root control\n', '    address public fundWallet;\n', '    // control of liquidity and limited control of updatePrice\n', '    address public controlWallet;\n', '    // time to wait between controlWallet price updates\n', '    uint256 public waitTime = 5 hours;\n', '\n', '    // fundWallet controlled state variables\n', '    // halted: halt buying due to emergency, tradeable: signal that GRON platform is up and running\n', '    bool public halted = false;\n', '    bool public tradeable = false;\n', '\n', '    // -- totalSupply defined in StandardToken\n', '    // -- mapping to token balances done in StandardToken\n', '\n', '    uint256 public previousUpdateTime = 0;\n', '    Price public currentPrice;\n', '    uint256 public minAmount; // Minimum amount of ether to accept for GRO purchases\n', '\n', '    // map participant address to a withdrawal request\n', '    mapping (address => Withdrawal) public withdrawals;\n', '    // maps previousUpdateTime to the next price\n', '    mapping (uint256 => Price) public prices;\n', '    // maps addresses\n', '    mapping (address => bool) public whitelist;\n', '\n', '    // TYPES\n', '\n', '    struct Price { // tokensPerEth\n', '        uint256 numerator;\n', '    }\n', '\n', '    struct Withdrawal {\n', '        uint256 tokens;\n', '        uint256 time; // time for each withdrawal is set to the previousUpdateTime\n', '    }\n', '\n', '    // EVENTS\n', '\n', '    event Buy(address indexed participant, address indexed beneficiary, uint256 weiValue, uint256 amountTokens);\n', '    event AllocatePresale(address indexed participant, uint256 amountTokens);\n', '    event BonusAllocation(address indexed participant, string participant_addr, string txnHash, uint256 bonusTokens);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Whitelist(address indexed participant);\n', '    event PriceUpdate(uint256 numerator);\n', '    event AddLiquidity(uint256 ethAmount);\n', '    event RemoveLiquidity(uint256 ethAmount);\n', '    event WithdrawRequest(address indexed participant, uint256 amountTokens);\n', '    event Withdraw(address indexed participant, uint256 amountTokens, uint256 etherAmount);\n', '\n', '    // MODIFIERS\n', '\n', '    modifier isTradeable { // exempt vestingContract and fundWallet to allow dev allocations\n', '        require(tradeable || msg.sender == fundWallet || msg.sender == vestingContract);\n', '        _;\n', '    }\n', '\n', '    modifier onlyWhitelist {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyFundWallet {\n', '        require(msg.sender == fundWallet);\n', '        _;\n', '    }\n', '\n', '    modifier onlyManagingWallets {\n', '        require(msg.sender == controlWallet || msg.sender == fundWallet);\n', '        _;\n', '    }\n', '\n', '    modifier only_if_controlWallet {\n', '        if (msg.sender == controlWallet) _;\n', '    }\n', '    modifier require_waited {\n', '      require(safeSub(currentTime(), waitTime) >= previousUpdateTime);\n', '        _;\n', '    }\n', '    modifier only_if_decrease (uint256 newNumerator) {\n', '        if (newNumerator < currentPrice.numerator) _;\n', '    }\n', '\n', '    // CONSTRUCTOR\n', '    function GRO() public {\n', '        fundWallet = msg.sender;\n', '        whitelist[fundWallet] = true;\n', '        previousUpdateTime = currentTime();\n', '    }\n', '\n', '    // Called after deployment\n', '    // Not all deployment clients support constructor arguments.\n', '    // This function is provided for maximum compatibility. \n', '    function initialiseContract(address controlWalletInput, uint256 priceNumeratorInput, uint256 startBlockInput, uint256 endBlockInput) external onlyFundWallet {\n', '      require(controlWalletInput != address(0));\n', '      require(priceNumeratorInput > 0);\n', '      require(endBlockInput > startBlockInput);\n', '      controlWallet = controlWalletInput;\n', '      whitelist[controlWallet] = true;\n', '      currentPrice = Price(priceNumeratorInput);\n', '      fundingStartBlock = startBlockInput;\n', '      fundingEndBlock = endBlockInput;\n', '      previousUpdateTime = currentTime();\n', '      minAmount = 0.05 ether; // 500 GRO\n', '    }\n', '\n', '    // METHODS\n', '\n', '    function setVestingContract(address vestingContractInput) external onlyFundWallet {\n', '        require(vestingContractInput != address(0));\n', '        vestingContract = vestingContractInput;\n', '        whitelist[vestingContract] = true;\n', '        vestingSet = true;\n', '    }\n', '\n', '    // allows controlWallet to update the price within a time contstraint, allows fundWallet complete control\n', '    function updatePrice(uint256 newNumerator) external onlyManagingWallets {\n', '        require(newNumerator > 0);\n', '        require_limited_change(newNumerator);\n', '        // either controlWallet command is compliant or transaction came from fundWallet\n', '        currentPrice.numerator = newNumerator;\n', '        // maps time to new Price (if not during ICO)\n', '        prices[previousUpdateTime] = currentPrice;\n', '        previousUpdateTime = currentTime();\n', '        PriceUpdate(newNumerator);\n', '    }\n', '\n', '    function require_limited_change (uint256 newNumerator)\n', '      private\n', '      view\n', '      only_if_controlWallet\n', '      require_waited\n', '      only_if_decrease(newNumerator)\n', '    {\n', '        uint256 percentage_diff = 0;\n', '        percentage_diff = safeMul(newNumerator, 100) / currentPrice.numerator;\n', '        percentage_diff = safeSub(100, percentage_diff);\n', '        // controlWallet can only increase price by max 20% and only every waitTime\n', '        require(percentage_diff <= 20);\n', '    }\n', '\n', '    function mint(address participant, uint256 amountTokens) private {\n', '        require(vestingSet);\n', '        // 40% of total allocated for Founders, Team incentives & Bonuses.\n', '\n', '\t// Solidity v0.4.18 - floating point is not fully supported,\n', '\t// integer division results in truncated values\n', '\t// Therefore we are multiplying out by 1000000... for\n', '\t// precision. This allows ratios values up to 0.0000x or 0.00x percent\n', '\tuint256 precision = 10**18;\n', '\tuint256 allocationRatio = safeMul(amountTokens, precision) / safeMul(570000000, precision);\n', '        uint256 developmentAllocation = safeMul(allocationRatio, safeMul(380000000, precision)) / precision;\n', '        // check that token cap is not exceeded\n', '        uint256 newTokens = safeAdd(amountTokens, developmentAllocation);\n', '        require(safeAdd(totalSupply, newTokens) <= tokenCap);\n', '        // increase token supply, assign tokens to participant\n', '        totalSupply = safeAdd(totalSupply, newTokens);\n', '        balances[participant] = safeAdd(balances[participant], amountTokens);\n', '        balances[vestingContract] = safeAdd(balances[vestingContract], developmentAllocation);\n', '\n', '\tMint(fundWallet, newTokens);\n', '\tTransfer(fundWallet, participant, amountTokens);\n', '\tTransfer(fundWallet, vestingContract, developmentAllocation);\n', '    }\n', '\n', '    // amountTokens is supplied in major units, not subunits / decimal\n', '    // units.\n', '    function allocatePresaleTokens(\n', '\t\t\t       address participant_address,\n', '\t\t\t       string participant_str,\n', '\t\t\t       uint256 amountTokens,\n', '\t\t\t       string txnHash\n', '\t\t\t       )\n', '      external onlyFundWallet {\n', '\n', '      require(currentBlock() < fundingEndBlock);\n', '      require(participant_address != address(0));\n', '     \n', '      uint256 bonusTokens = 0;\n', '      uint256 totalTokens = safeMul(amountTokens, 10**18); // scale to subunit\n', '\n', '      if (firstDigit(txnHash) == firstDigit(participant_str)) {\n', '\t  // Calculate 10% bonus\n', '\t  bonusTokens = safeMul(totalTokens, 10) / 100;\n', '\t  totalTokens = safeAdd(totalTokens, bonusTokens);\n', '      }\n', '        \n', '        mint(participant_address, totalTokens);\n', '\t// Events        \n', '        AllocatePresale(participant_address, totalTokens);\n', '\tBonusAllocation(participant_address, participant_str, txnHash, bonusTokens);\n', '    }\n', '\n', '    // returns the first character as a byte in a given hex string\n', '    // address Given 0x1abcd... returns 1\n', '    function firstDigit(string s) pure public returns(byte){\n', '\tbytes memory strBytes = bytes(s);\n', '\treturn strBytes[2];\n', '      }\n', '\n', '    function verifyParticipant(address participant) external onlyManagingWallets {\n', '        whitelist[participant] = true;\n', '        Whitelist(participant);\n', '    }\n', '\n', '    // fallback function\n', '    function() payable public {\n', '      require(tx.origin == msg.sender);\n', '      buyTo(msg.sender);\n', '    }\n', '\n', '    function buy() external payable {\n', '        buyTo(msg.sender);\n', '    }\n', '\n', '    function buyTo(address participant) public payable {\n', '      require(!halted);\n', '      require(participant != address(0));\n', '      require(msg.value >= minAmount);\n', '      require(currentBlock() < fundingEndBlock);\n', '      // msg.value in wei - scale to GRO\n', '      uint256 baseAmountTokens = safeMul(msg.value, currentPrice.numerator);\n', '      // calc lottery amount excluding potential ico bonus\n', '      uint256 lotteryAmount = blockLottery(baseAmountTokens);\n', '      uint256 icoAmount = safeMul(msg.value, icoNumeratorPrice());\n', '\n', '      uint256 tokensToBuy = safeAdd(icoAmount, lotteryAmount);\n', '      mint(participant, tokensToBuy);\n', '      // send ether to fundWallet\n', '      fundWallet.transfer(msg.value);\n', '      // Events\n', '      Buy(msg.sender, participant, msg.value, tokensToBuy);\n', '    }\n', '\n', '    // time based on blocknumbers, assuming a blocktime of 15s\n', '    function icoNumeratorPrice() public constant returns (uint256) {\n', '\n', '      if (currentBlock() < fundingStartBlock){\n', '\treturn 14000;\n', '      }\n', '      \n', '      uint256 icoDuration = safeSub(currentBlock(), fundingStartBlock);\n', '\n', '      uint256 firstBlockPhase = 80640; // #blocks = 2*7*24*60*60/15 = 80640\n', '      uint256 secondBlockPhase = 161280; // // #blocks = 4*7*24*60*60/15 = 161280\n', '      uint256 thirdBlockPhase = 241920; // // #blocks = 6*7*24*60*60/15 = 241920\n', '\n', '      if (icoDuration < firstBlockPhase ) {\n', '\treturn  13000;\t  \n', '      } else if (icoDuration < secondBlockPhase ) { \n', '\treturn  12000;\t    \n', '      } else if (icoDuration < thirdBlockPhase ) { \n', '\treturn 11000;\t    \n', '      } else {\n', '\treturn 10000;\n', '      }\n', '    }\n', '\n', '    function currentBlock() private constant returns(uint256 _currentBlock) {\n', '      return block.number;\n', '    }\n', '\n', '    function currentTime() private constant returns(uint256 _currentTime) {\n', '      return now;\n', '    }\n', '\n', '    function blockLottery(uint256 _amountTokens) private constant returns(uint256) {\n', '      uint256 divisor = 10;\n', '      uint256 winning_digit = 0;\n', '      uint256 tokenWinnings = 0;\n', '\n', '      if (currentBlock() % divisor == winning_digit) {\n', '\ttokenWinnings = safeMul(_amountTokens, 10) / 100;\n', '      }\n', '      \n', '      return tokenWinnings;\t\n', '    }\n', '\n', '    function requestWithdrawal(uint256 amountTokensToWithdraw) external isTradeable onlyWhitelist {\n', '      require(currentBlock() > fundingEndBlock);\n', '        require(amountTokensToWithdraw > 0);\n', '        address participant = msg.sender;\n', '        require(balanceOf(participant) >= amountTokensToWithdraw);\n', '        require(withdrawals[participant].tokens == 0); // participant cannot have outstanding withdrawals\n', '        balances[participant] = safeSub(balances[participant], amountTokensToWithdraw);\n', '        withdrawals[participant] = Withdrawal({tokens: amountTokensToWithdraw, time: previousUpdateTime});\n', '        WithdrawRequest(participant, amountTokensToWithdraw);\n', '    }\n', '\n', '    function withdraw() external {\n', '        address participant = msg.sender;\n', '        uint256 tokens = withdrawals[participant].tokens;\n', '        require(tokens > 0); // participant must have requested a withdrawal\n', '        uint256 requestTime = withdrawals[participant].time;\n', '        // obtain the next price that was set after the request\n', '        Price price = prices[requestTime];\n', '        require(price.numerator > 0); // price must have been set\n', '        uint256 withdrawValue = tokens / price.numerator;\n', '        // if contract ethbal > then send + transfer tokens to fundWallet, otherwise give tokens back\n', '        withdrawals[participant].tokens = 0;\n', '        if (this.balance >= withdrawValue) {\n', '            enact_withdrawal_greater_equal(participant, withdrawValue, tokens);\n', '\t}\n', '        else {\n', '            enact_withdrawal_less(participant, withdrawValue, tokens);\n', '\t}\n', '    }\n', '\n', '    function enact_withdrawal_greater_equal(address participant, uint256 withdrawValue, uint256 tokens)\n', '        private\n', '    {\n', '        assert(this.balance >= withdrawValue);\n', '        balances[fundWallet] = safeAdd(balances[fundWallet], tokens);\n', '        participant.transfer(withdrawValue);\n', '        Withdraw(participant, tokens, withdrawValue);\n', '    }\n', '    function enact_withdrawal_less(address participant, uint256 withdrawValue, uint256 tokens)\n', '        private\n', '    {\n', '        assert(this.balance < withdrawValue);\n', '        balances[participant] = safeAdd(balances[participant], tokens);\n', '        Withdraw(participant, tokens, 0); // indicate a failed withdrawal\n', '    }\n', '\n', '    // Returns the ether value (in wei units) for the amount of tokens\n', '    // in subunits for decimal support, at the current GRO exchange\n', '    // rate\n', '    function checkWithdrawValue(uint256 amountTokensInSubunit) public constant returns (uint256 weiValue) {\n', '        require(amountTokensInSubunit > 0);\n', '        require(balanceOf(msg.sender) >= amountTokensInSubunit);\n', '        uint256 withdrawValue = amountTokensInSubunit / currentPrice.numerator;\n', '        require(this.balance >= withdrawValue);\n', '        return withdrawValue;\n', '    }\n', '\n', '    // allow fundWallet or controlWallet to add ether to contract\n', '    function addLiquidity() external onlyManagingWallets payable {\n', '        require(msg.value > 0);\n', '        AddLiquidity(msg.value);\n', '    }\n', '\n', '    // allow fundWallet to remove ether from contract\n', '    function removeLiquidity(uint256 amount) external onlyManagingWallets {\n', '        require(amount <= this.balance);\n', '        fundWallet.transfer(amount);\n', '        RemoveLiquidity(amount);\n', '    }\n', '\n', '    function changeFundWallet(address newFundWallet) external onlyFundWallet {\n', '        require(newFundWallet != address(0));\n', '        fundWallet = newFundWallet;\n', '    }\n', '\n', '    function changeControlWallet(address newControlWallet) external onlyFundWallet {\n', '        require(newControlWallet != address(0));\n', '        controlWallet = newControlWallet;\n', '    }\n', '\n', '    function changeWaitTime(uint256 newWaitTime) external onlyFundWallet {\n', '        waitTime = newWaitTime;\n', '    }\n', '\n', '    // specified in wei\n', '    function changeMinAmount(uint256 newMinAmount) external onlyFundWallet {\n', '      minAmount = newMinAmount;\n', '    }\n', '\n', '    function updateFundingStartBlock(uint256 newFundingStartBlock) external onlyFundWallet {\n', '      require(currentBlock() < fundingStartBlock);\n', '        require(currentBlock() < newFundingStartBlock);\n', '        fundingStartBlock = newFundingStartBlock;\n', '    }\n', '\n', '    function updateFundingEndBlock(uint256 newFundingEndBlock) external onlyFundWallet {\n', '        require(currentBlock() < fundingEndBlock);\n', '        require(currentBlock() < newFundingEndBlock);\n', '        fundingEndBlock = newFundingEndBlock;\n', '    }\n', '\n', '    function halt() external onlyFundWallet {\n', '        halted = true;\n', '    }\n', '    function unhalt() external onlyFundWallet {\n', '        halted = false;\n', '    }\n', '\n', '    function enableTrading() external onlyFundWallet {\n', '        require(currentBlock() > fundingEndBlock);\n', '        tradeable = true;\n', '    }\n', '\n', '    function claimTokens(address _token) external onlyFundWallet {\n', '        require(_token != address(0));\n', '        Token token = Token(_token);\n', '        uint256 balance = token.balanceOf(this);\n', '        token.transfer(fundWallet, balance);\n', '     }\n', '\n', '    // prevent transfers until trading allowed\n', '    function transfer(address _to, uint256 _value) public isTradeable returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) public isTradeable returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}']