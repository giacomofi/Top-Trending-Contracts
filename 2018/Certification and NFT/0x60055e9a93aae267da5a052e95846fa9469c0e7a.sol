['pragma solidity ^0.4.24;\n', '\n', 'interface IOracle {\n', '\n', '    /**\n', '    * @notice Returns address of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencyAddress() external view returns(address);\n', '\n', '    /**\n', '    * @notice Returns symbol of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencySymbol() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns denomination of price\n', '    */\n', '    function getCurrencyDenominated() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns price - should throw if not valid\n', '    */\n', '    function getPrice() external view returns(uint256);\n', '\n', '}\n', '\n', '/// return median value of feeds\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) constant returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        assert(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    modifier authorized(bytes4 sig) {\n', '        assert(isAuthorized(msg.sender, sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '\n', '    function assert(bool x) internal {\n', '        if (!x) throw;\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '\tuint\t \t  wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', '        // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '}\n', '\n', 'contract DSValue is DSThing {\n', '    bool    has;\n', '    bytes32 val;\n', '    function peek() constant returns (bytes32, bool) {\n', '        return (val,has);\n', '    }\n', '    function read() constant returns (bytes32) {\n', '        var (wut, has) = peek();\n', '        assert(has);\n', '        return wut;\n', '    }\n', '    function poke(bytes32 wut) note auth {\n', '        val = wut;\n', '        has = true;\n', '    }\n', '    function void() note auth { // unset the value\n', '        has = false;\n', '    }\n', '}\n', '\n', 'contract Medianizer is DSValue {\n', '    mapping (bytes12 => address) public values;\n', '    mapping (address => bytes12) public indexes;\n', '    bytes12 public next = 0x1;\n', '\n', '    uint96 public min = 0x1;\n', '\n', '    function set(address wat) auth {\n', '        bytes12 nextId = bytes12(uint96(next) + 1);\n', '        assert(nextId != 0x0);\n', '        set(next, wat);\n', '        next = nextId;\n', '    }\n', '\n', '    function set(bytes12 pos, address wat) note auth {\n', '        if (pos == 0x0) throw;\n', '\n', '        if (wat != 0 && indexes[wat] != 0) throw;\n', '\n', '        indexes[values[pos]] = 0; // Making sure to remove a possible existing address in that position\n', '\n', '        if (wat != 0) {\n', '            indexes[wat] = pos;\n', '        }\n', '\n', '        values[pos] = wat;\n', '    }\n', '\n', '    function setMin(uint96 min_) note auth {\n', '        if (min_ == 0x0) throw;\n', '        min = min_;\n', '    }\n', '\n', '    function setNext(bytes12 next_) note auth {\n', '        if (next_ == 0x0) throw;\n', '        next = next_;\n', '    }\n', '\n', '    function unset(bytes12 pos) {\n', '        set(pos, 0);\n', '    }\n', '\n', '    function unset(address wat) {\n', '        set(indexes[wat], 0);\n', '    }\n', '\n', '    function poke() {\n', '        poke(0);\n', '    }\n', '\n', '    function poke(bytes32) note {\n', '        (val, has) = compute();\n', '    }\n', '\n', '    function compute() constant returns (bytes32, bool) {\n', '        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n', '        uint96 ctr = 0;\n', '        for (uint96 i = 1; i < uint96(next); i++) {\n', '            if (values[bytes12(i)] != 0) {\n', '                var (wut, wuz) = DSValue(values[bytes12(i)]).peek();\n', '                if (wuz) {\n', '                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n', '                        wuts[ctr] = wut;\n', '                    } else {\n', '                        uint96 j = 0;\n', '                        while (wut >= wuts[j]) {\n', '                            j++;\n', '                        }\n', '                        for (uint96 k = ctr; k > j; k--) {\n', '                            wuts[k] = wuts[k - 1];\n', '                        }\n', '                        wuts[j] = wut;\n', '                    }\n', '                    ctr++;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (ctr < min) return (val, false);\n', '\n', '        bytes32 value;\n', '        if (ctr % 2 == 0) {\n', '            uint128 val1 = uint128(wuts[(ctr / 2) - 1]);\n', '            uint128 val2 = uint128(wuts[ctr / 2]);\n', '            value = bytes32(wdiv(hadd(val1, val2), 2 ether));\n', '        } else {\n', '            value = wuts[(ctr - 1) / 2];\n', '        }\n', '\n', '        return (value, true);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract MakerDAOOracle is IOracle, Ownable {\n', '\n', '    address public makerDAO = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\n', '\n', '    bool public manualOverride;\n', '\n', '    uint256 public manualPrice;\n', '\n', '    event LogChangeMakerDAO(address _newMakerDAO, address _oldMakerDAO, uint256 _now);\n', '    event LogSetManualPrice(uint256 _oldPrice, uint256 _newPrice, uint256 _time);\n', '    event LogSetManualOverride(bool _override, uint256 _time);\n', '\n', '    function changeMakerDAO(address _makerDAO) public onlyOwner {\n', '        emit LogChangeMakerDAO(_makerDAO, makerDAO, now);\n', '        makerDAO = _makerDAO;\n', '    }\n', '\n', '    /**\n', '    * @notice Returns address of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencyAddress() external view returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    /**\n', '    * @notice Returns symbol of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencySymbol() external view returns(bytes32) {\n', '        return bytes32("ETH");\n', '    }\n', '\n', '    /**\n', '    * @notice Returns denomination of price\n', '    */\n', '    function getCurrencyDenominated() external view returns(bytes32) {\n', '        return bytes32("USD");\n', '    }\n', '\n', '    /**\n', '    * @notice Returns price - should throw if not valid\n', '    */\n', '    function getPrice() external view returns(uint256) {\n', '        if (manualOverride) {\n', '            return manualPrice;\n', '        }\n', '        (bytes32 price, bool valid) = Medianizer(makerDAO).peek();\n', '        require(valid, "MakerDAO Oracle returning invalid value");\n', '        return uint256(price);\n', '    }\n', '\n', '    /**\n', '      * @notice Set a manual price. NA - this will only be used if manualOverride == true\n', '      * @param _price Price to set\n', '      */\n', '    function setManualPrice(uint256 _price) public onlyOwner {\n', '        emit LogSetManualPrice(manualPrice, _price, now);\n', '        manualPrice = _price;\n', '    }\n', '\n', '    /**\n', '      * @notice Determine whether manual price is used or not\n', '      * @param _override Whether to use the manual override price or not\n', '      */\n', '    function setManualOverride(bool _override) public onlyOwner {\n', '        manualOverride = _override;\n', '        emit LogSetManualOverride(_override, now);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface IOracle {\n', '\n', '    /**\n', '    * @notice Returns address of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencyAddress() external view returns(address);\n', '\n', '    /**\n', '    * @notice Returns symbol of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencySymbol() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns denomination of price\n', '    */\n', '    function getCurrencyDenominated() external view returns(bytes32);\n', '\n', '    /**\n', '    * @notice Returns price - should throw if not valid\n', '    */\n', '    function getPrice() external view returns(uint256);\n', '\n', '}\n', '\n', '/// return median value of feeds\n', '\n', '// Copyright (C) 2017  DappHub, LLC\n', '\n', '// Licensed under the Apache License, Version 2.0 (the "License").\n', '// You may not use this file except in compliance with the License.\n', '\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '\n', '\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) constant returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        assert(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    modifier authorized(bytes4 sig) {\n', '        assert(isAuthorized(msg.sender, sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '\n', '    function assert(bool x) internal {\n', '        if (!x) throw;\n', '    }\n', '}\n', '\n', 'contract DSNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  guy,\n', '        bytes32  indexed  foo,\n', '        bytes32  indexed  bar,\n', '\tuint\t \t  wad,\n', '        bytes             fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    uint128 functions (h is for half)\n', '     */\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '    /*\n', '    int256 functions\n', '     */\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        // This famous algorithm is called "exponentiation by squaring"\n', '        // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '        //\n', "        // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '        //\n', '        // These facts are why it works:\n', '        //\n', '        //  If n is even, then x^n = (x^2)^(n/2).\n', '        //  If n is odd,  then x^n = x * x^(n-1),\n', '        //   and applying the equation for even x gives\n', '        //    x^n = x * (x^2)^((n-1) / 2).\n', '        //\n', '        //  Also, EVM division is flooring and\n', '        //    floor[(n-1) / 2] = floor[n / 2].\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', 'contract DSThing is DSAuth, DSNote, DSMath {\n', '}\n', '\n', 'contract DSValue is DSThing {\n', '    bool    has;\n', '    bytes32 val;\n', '    function peek() constant returns (bytes32, bool) {\n', '        return (val,has);\n', '    }\n', '    function read() constant returns (bytes32) {\n', '        var (wut, has) = peek();\n', '        assert(has);\n', '        return wut;\n', '    }\n', '    function poke(bytes32 wut) note auth {\n', '        val = wut;\n', '        has = true;\n', '    }\n', '    function void() note auth { // unset the value\n', '        has = false;\n', '    }\n', '}\n', '\n', 'contract Medianizer is DSValue {\n', '    mapping (bytes12 => address) public values;\n', '    mapping (address => bytes12) public indexes;\n', '    bytes12 public next = 0x1;\n', '\n', '    uint96 public min = 0x1;\n', '\n', '    function set(address wat) auth {\n', '        bytes12 nextId = bytes12(uint96(next) + 1);\n', '        assert(nextId != 0x0);\n', '        set(next, wat);\n', '        next = nextId;\n', '    }\n', '\n', '    function set(bytes12 pos, address wat) note auth {\n', '        if (pos == 0x0) throw;\n', '\n', '        if (wat != 0 && indexes[wat] != 0) throw;\n', '\n', '        indexes[values[pos]] = 0; // Making sure to remove a possible existing address in that position\n', '\n', '        if (wat != 0) {\n', '            indexes[wat] = pos;\n', '        }\n', '\n', '        values[pos] = wat;\n', '    }\n', '\n', '    function setMin(uint96 min_) note auth {\n', '        if (min_ == 0x0) throw;\n', '        min = min_;\n', '    }\n', '\n', '    function setNext(bytes12 next_) note auth {\n', '        if (next_ == 0x0) throw;\n', '        next = next_;\n', '    }\n', '\n', '    function unset(bytes12 pos) {\n', '        set(pos, 0);\n', '    }\n', '\n', '    function unset(address wat) {\n', '        set(indexes[wat], 0);\n', '    }\n', '\n', '    function poke() {\n', '        poke(0);\n', '    }\n', '\n', '    function poke(bytes32) note {\n', '        (val, has) = compute();\n', '    }\n', '\n', '    function compute() constant returns (bytes32, bool) {\n', '        bytes32[] memory wuts = new bytes32[](uint96(next) - 1);\n', '        uint96 ctr = 0;\n', '        for (uint96 i = 1; i < uint96(next); i++) {\n', '            if (values[bytes12(i)] != 0) {\n', '                var (wut, wuz) = DSValue(values[bytes12(i)]).peek();\n', '                if (wuz) {\n', '                    if (ctr == 0 || wut >= wuts[ctr - 1]) {\n', '                        wuts[ctr] = wut;\n', '                    } else {\n', '                        uint96 j = 0;\n', '                        while (wut >= wuts[j]) {\n', '                            j++;\n', '                        }\n', '                        for (uint96 k = ctr; k > j; k--) {\n', '                            wuts[k] = wuts[k - 1];\n', '                        }\n', '                        wuts[j] = wut;\n', '                    }\n', '                    ctr++;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (ctr < min) return (val, false);\n', '\n', '        bytes32 value;\n', '        if (ctr % 2 == 0) {\n', '            uint128 val1 = uint128(wuts[(ctr / 2) - 1]);\n', '            uint128 val2 = uint128(wuts[ctr / 2]);\n', '            value = bytes32(wdiv(hadd(val1, val2), 2 ether));\n', '        } else {\n', '            value = wuts[(ctr - 1) / 2];\n', '        }\n', '\n', '        return (value, true);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract MakerDAOOracle is IOracle, Ownable {\n', '\n', '    address public makerDAO = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\n', '\n', '    bool public manualOverride;\n', '\n', '    uint256 public manualPrice;\n', '\n', '    event LogChangeMakerDAO(address _newMakerDAO, address _oldMakerDAO, uint256 _now);\n', '    event LogSetManualPrice(uint256 _oldPrice, uint256 _newPrice, uint256 _time);\n', '    event LogSetManualOverride(bool _override, uint256 _time);\n', '\n', '    function changeMakerDAO(address _makerDAO) public onlyOwner {\n', '        emit LogChangeMakerDAO(_makerDAO, makerDAO, now);\n', '        makerDAO = _makerDAO;\n', '    }\n', '\n', '    /**\n', '    * @notice Returns address of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencyAddress() external view returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    /**\n', '    * @notice Returns symbol of oracle currency (0x0 for ETH)\n', '    */\n', '    function getCurrencySymbol() external view returns(bytes32) {\n', '        return bytes32("ETH");\n', '    }\n', '\n', '    /**\n', '    * @notice Returns denomination of price\n', '    */\n', '    function getCurrencyDenominated() external view returns(bytes32) {\n', '        return bytes32("USD");\n', '    }\n', '\n', '    /**\n', '    * @notice Returns price - should throw if not valid\n', '    */\n', '    function getPrice() external view returns(uint256) {\n', '        if (manualOverride) {\n', '            return manualPrice;\n', '        }\n', '        (bytes32 price, bool valid) = Medianizer(makerDAO).peek();\n', '        require(valid, "MakerDAO Oracle returning invalid value");\n', '        return uint256(price);\n', '    }\n', '\n', '    /**\n', '      * @notice Set a manual price. NA - this will only be used if manualOverride == true\n', '      * @param _price Price to set\n', '      */\n', '    function setManualPrice(uint256 _price) public onlyOwner {\n', '        emit LogSetManualPrice(manualPrice, _price, now);\n', '        manualPrice = _price;\n', '    }\n', '\n', '    /**\n', '      * @notice Determine whether manual price is used or not\n', '      * @param _override Whether to use the manual override price or not\n', '      */\n', '    function setManualOverride(bool _override) public onlyOwner {\n', '        manualOverride = _override;\n', '        emit LogSetManualOverride(_override, now);\n', '    }\n', '\n', '}']
