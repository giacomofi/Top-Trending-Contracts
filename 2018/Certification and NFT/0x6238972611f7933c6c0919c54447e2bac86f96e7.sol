['pragma solidity 0.4.24;\n', '\n', 'contract CopaDelCrypto\n', '{\n', '  address public owner;\n', '  constructor() public\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner\n', '  {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  struct Forecast\n', '  {\n', '    bytes32 part1;\n', '    bytes32 part2;\n', '    bytes32 part3;\n', '    bytes12 part4;\n', '    bool hasPaidOrWon;\n', '  }\n', '\n', '  uint256 public prizeValue;\n', '  uint256 public resultsPublishedTime;\n', '\n', '  bytes32 public worldCupResultPart1;\n', '  bytes32 public worldCupResultPart2;\n', '  bytes32 public worldCupResultPart3;\n', '  bytes12 public worldCupResultPart4;\n', '\n', '  bool public forecastingClosed;\n', '  bool public resultsPublished;\n', '\n', '  uint32 public resultsValidationStep;\n', '  uint32 public verifiedWinnersCount;\n', '  uint32 public verifiedWinnersLastCount;\n', '\n', '  uint16 public publishedWinningScoreThreshold;\n', '  uint16 public expectedWinnersCount;\n', '\n', '  address[] public players;\n', '\n', '  mapping(address => Forecast) public forecasts;\n', '\n', '  function PlaceNewForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\n', '  public payable\n', '  {\n', '    require(!forecastingClosed && msg.value == 50000000000000000 && !forecasts[msg.sender].hasPaidOrWon);\n', '\n', '    forecasts[msg.sender].part1 = f1;\n', '    forecasts[msg.sender].part2 = f2;\n', '    forecasts[msg.sender].part3 = f3;\n', '    forecasts[msg.sender].part4 = f4;\n', '    forecasts[msg.sender].hasPaidOrWon = true;\n', '\n', '    players.push(msg.sender);\n', '  }\n', '\n', '  function UpdateForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\n', '  public\n', '  {\n', '    require(!forecastingClosed && forecasts[msg.sender].hasPaidOrWon);\n', '\n', '    forecasts[msg.sender].part1 = f1;\n', '    forecasts[msg.sender].part2 = f2;\n', '    forecasts[msg.sender].part3 = f3;\n', '    forecasts[msg.sender].part4 = f4;\n', '  }\n', '\n', '  function CloseForecasting(uint16 exWinCount)\n', '  public onlyOwner\n', '  {\n', '    require(!forecastingClosed);\n', '    require((exWinCount == 0 && players.length > 10000)\n', '             || (exWinCount > 0 && (uint32(exWinCount) * uint32(exWinCount) >= players.length\n', '                 && uint32(exWinCount - 1) * uint32(exWinCount - 1) < players.length)));\n', '    expectedWinnersCount = (players.length) > 10000 ? uint16(players.length / 100) : exWinCount;\n', '\n', '    forecastingClosed = true;\n', '  }\n', '\n', '  function PublishWorldCupResults(bytes32 res1, bytes32 res2, bytes32 res3, bytes12 res4)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '\n', '    worldCupResultPart1 = res1;\n', '    worldCupResultPart2 = res2;\n', '    worldCupResultPart3 = res3;\n', '    worldCupResultPart4 = res4;\n', '\n', '    resultsValidationStep = 0;\n', '    verifiedWinnersCount = 0;\n', '    verifiedWinnersLastCount = 0;\n', '    resultsPublishedTime = block.timestamp;\n', '  }\n', '\n', '  function PublishWinnersScoreThres(uint16 scoreThres)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '\n', '    publishedWinningScoreThreshold = scoreThres;\n', '  }\n', '\n', '  function VerifyPublishedResults(uint16 stepSize)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '    require(stepSize > 0 && resultsValidationStep + stepSize <= players.length);\n', '\n', '    uint32 wins;\n', '    uint32 lasts;\n', '\n', '    for (uint32 i = resultsValidationStep; i < resultsValidationStep + stepSize; i++) {\n', '\n', '      Forecast memory fc = forecasts[players[i]];\n', '\n', '      uint16 score = scoreGroups(fc.part1, fc.part2, worldCupResultPart1, worldCupResultPart2)\n', '                     + scoreKnockouts(fc.part2, fc.part3, fc.part4);\n', '\n', '      if (score >= publishedWinningScoreThreshold) {\n', '        wins++;\n', '        if (score == publishedWinningScoreThreshold) {\n', '          lasts++;\n', '        }\n', '        forecasts[players[i]].hasPaidOrWon = true;\n', '      } else {\n', '        forecasts[players[i]].hasPaidOrWon = false;\n', '      }\n', '    }\n', '\n', '    resultsValidationStep += stepSize;\n', '    verifiedWinnersCount += wins;\n', '    verifiedWinnersLastCount += lasts;\n', '\n', '    if (resultsValidationStep == players.length) {\n', '      verifiedWinnersCount = validateWinnersCount(verifiedWinnersCount, verifiedWinnersLastCount, expectedWinnersCount);\n', '      verifiedWinnersLastCount = 0;\n', '      expectedWinnersCount = 0;\n', '\n', '      if (verifiedWinnersCount > 0) {\n', '        prizeValue = address(this).balance / verifiedWinnersCount;\n', '        resultsPublished = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  function WithdrawPrize()\n', '  public\n', '  returns(bool)\n', '  {\n', '    require(prizeValue > 0);\n', '\n', '    if (forecasts[msg.sender].hasPaidOrWon) {\n', '      forecasts[msg.sender].hasPaidOrWon = false;\n', '      if (!msg.sender.send(prizeValue)) {\n', '        forecasts[msg.sender].hasPaidOrWon = true;\n', '        return false;\n', '      }\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function CancelGame()\n', '  public onlyOwner\n', '  {\n', '    forecastingClosed = true;\n', '    resultsPublished = true;\n', '    resultsPublishedTime = block.timestamp;\n', '    prizeValue = address(this).balance / players.length;\n', '  }\n', '\n', '  function CancelGameAfterResultsPublished()\n', '  public onlyOwner\n', '  {\n', '    CancelGame();\n', '    for (uint32 i = 0; i < players.length; i++) {\n', '    \tforecasts[players[i]].hasPaidOrWon = true;\n', '    }\n', '  }\n', '\n', '  function WithdrawUnclaimed()\n', '  public onlyOwner\n', '  returns(bool)\n', '  {\n', '    require(resultsPublished && block.timestamp >= (resultsPublishedTime + 10 weeks));\n', '\n', '    uint256 amount = address(this).balance;\n', '    if (amount > 0) {\n', '      if (!msg.sender.send(amount)) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function getForecastData(bytes32 pred2, bytes32 pred3, bytes12 pred4, uint8 index)\n', '  public pure\n', '  returns(uint8)\n', '  {\n', '    assert(index >= 32 && index < 108);\n', '    if (index < 64) {\n', '      return uint8(pred2[index - 32]);\n', '    } else if (index < 96) {\n', '      return uint8(pred3[index - 64]);\n', '    } else {\n', '      return uint8(pred4[index - 96]);\n', '    }\n', '  }\n', '\n', '  function getResultData(uint8 index)\n', '  public view\n', '  returns(uint8)\n', '  {\n', '    assert(index >= 32 && index < 108);\n', '    if (index < 64) {\n', '      return uint8(worldCupResultPart2[index - 32]);\n', '    } else if (index < 96) {\n', '      return uint8(worldCupResultPart3[index - 64]);\n', '    } else {\n', '      return uint8(worldCupResultPart4[index - 96]);\n', '    }\n', '  }\n', '\n', '  function computeGroupPhasePoints(uint8 pred, uint8 result)\n', '  public pure\n', '  returns(uint8)\n', '  {\n', '    uint8 gamePoint = 0;\n', '\n', '    int8 predLeft = int8(pred % 16);\n', '    int8 predRight = int8(pred >> 4);\n', '    int8 resultLeft = int8(result % 16);\n', '    int8 resultRight = int8(result >> 4);\n', '\n', '    int8 outcome = resultLeft - resultRight;\n', '    int8 predOutcome = predLeft - predRight;\n', '\n', '    if ((outcome > 0 && predOutcome > 0)\n', '        || (outcome < 0 && predOutcome < 0)\n', '        || (outcome == 0 && predOutcome == 0)) {\n', '      gamePoint += 4;\n', '    }\n', '\n', '    if (predLeft == resultLeft) {\n', '      gamePoint += 2;\n', '    }\n', '\n', '    if (predRight == resultRight) {\n', '      gamePoint += 2;\n', '    }\n', '    return gamePoint;\n', '  }\n', '\n', '  function computeKnockoutPoints(uint8 pred, uint8 result, uint8 shootPred, uint8 shootResult,\n', '                                 uint8 roundFactorLeft, uint8 roundFactorRight, bool isInverted)\n', '  public pure\n', '  returns (uint16)\n', '  {\n', '    uint16 gamePoint = 0;\n', '    int8 predLeft = int8(pred % 16);\n', '    int8 predRight = int8(pred >> 4);\n', '    int8 resultLeft = int8(result % 16);\n', '    int8 resultRight = int8(result >> 4);\n', '\n', '    int8 predOutcome = predLeft - predRight;\n', '    int8 outcome = resultLeft - resultRight;\n', '\n', '    if (predOutcome == 0) {\n', '       predOutcome = int8(shootPred % 16) - int8(shootPred >> 4);\n', '    }\n', '    if (outcome == 0) { \n', '       outcome = int8(shootResult % 16) - int8(shootResult >> 4);\n', '    }\n', '\n', '    if (isInverted) {\n', '      resultLeft = resultLeft + resultRight;\n', '      resultRight = resultLeft - resultRight;\n', '      resultLeft = resultLeft - resultRight;\n', '      outcome = -outcome;\n', '    }\n', '\n', '    if ((outcome > 0 && predOutcome > 0) || (outcome < 0 && predOutcome < 0)) {\n', '      gamePoint += 4 * (roundFactorLeft + roundFactorRight);\n', '    }\n', '\n', '    gamePoint += 4 * ((predLeft == resultLeft ? roundFactorLeft : 0)\n', '                      + (predRight == resultRight ? roundFactorRight: 0));\n', '\n', '    return gamePoint;\n', '  }\n', '\n', '  function scoreGroups(bytes32 pred1, bytes32 pred2, bytes32 res1, bytes32 res2)\n', '  public pure\n', '  returns(uint16)\n', '  {\n', '    uint16 points = 0;\n', '    for (uint8 f = 0; f < 48; f++) {\n', '      if (f < 32) {\n', '        points += computeGroupPhasePoints(uint8(pred1[f]), uint8(res1[f]));\n', '      } else {\n', '        points += computeGroupPhasePoints(uint8(pred2[f - 32]), uint8(res2[f - 32]));\n', '      }\n', '    }\n', '    return points;\n', '  }\n', '\n', '  function scoreKnockouts(bytes32 pred2, bytes32 pred3, bytes12 pred4)\n', '  public view\n', '  returns(uint16)\n', '  {\n', '    uint8 f = 48;\n', '    uint16 points = 0;\n', '\n', '    int8[15] memory twinShift = [int8(16), 16, 16, 16, -16, -16, -16, -16, 8, 8, -8, -8, 4, -4, 0];\n', '    uint8[15] memory roundFactor = [uint8(2), 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 8, 8, 16];\n', '\n', '    for (uint8 i = 0; i < 15; i++) {\n', '\n', '      bool teamLeftOK = getForecastData(pred2, pred3, pred4, f) == getResultData(f);\n', '      bool teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) == getResultData(f + 1);\n', '\n', '      if (teamLeftOK || teamRightOK) {\n', '        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2), getResultData(f + 2),\n', '                                        getForecastData(pred2, pred3, pred4, f + 3), getResultData(f + 3),\n', '                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\n', '                                        false);\n', '        if (i < 8) {\n', '          points += (teamLeftOK ? 4 : 0) + (teamRightOK ? 4 : 0);\n', '        }\n', '      }\n', '\n', '      bool isInverted = (i < 8) || i == 14;\n', '      teamLeftOK = getForecastData(pred2, pred3, pred4, f) ==\n', '                   (getResultData(uint8(int8(f + (isInverted ? 1 : 0)) + twinShift[i])));\n', '      teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) ==\n', '                   (getResultData(uint8(int8(f + (isInverted ? 0 : 1)) + twinShift[i])));\n', '\n', '      if (teamLeftOK || teamRightOK) {\n', '        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2),\n', '                                        getResultData(uint8(int8(f + 2) + twinShift[i])),\n', '                                        getForecastData(pred2, pred3, pred4, f + 3),\n', '                                        getResultData(uint8(int8(f + 3) + twinShift[i])),\n', '                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\n', '                                        isInverted);\n', '        if (i < 8) {\n', '          points += (teamLeftOK ? 2 : 0) + (teamRightOK ? 2 : 0);\n', '        }\n', '      }\n', '      f = f + 4;\n', '    }\n', '    return points;\n', '  }\n', '\n', '  function validateWinnersCount(uint32 winners, uint32 last, uint32 expected)\n', '  public pure\n', '  returns(uint32)\n', '  {\n', '    if (winners < expected) {\n', '      return 0;\n', '    } else if ((winners == expected && last >= 1)\n', '                || (last > 1 && (winners - last) < expected)) {\n', '      return winners;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract CopaDelCrypto\n', '{\n', '  address public owner;\n', '  constructor() public\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '  modifier onlyOwner\n', '  {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  struct Forecast\n', '  {\n', '    bytes32 part1;\n', '    bytes32 part2;\n', '    bytes32 part3;\n', '    bytes12 part4;\n', '    bool hasPaidOrWon;\n', '  }\n', '\n', '  uint256 public prizeValue;\n', '  uint256 public resultsPublishedTime;\n', '\n', '  bytes32 public worldCupResultPart1;\n', '  bytes32 public worldCupResultPart2;\n', '  bytes32 public worldCupResultPart3;\n', '  bytes12 public worldCupResultPart4;\n', '\n', '  bool public forecastingClosed;\n', '  bool public resultsPublished;\n', '\n', '  uint32 public resultsValidationStep;\n', '  uint32 public verifiedWinnersCount;\n', '  uint32 public verifiedWinnersLastCount;\n', '\n', '  uint16 public publishedWinningScoreThreshold;\n', '  uint16 public expectedWinnersCount;\n', '\n', '  address[] public players;\n', '\n', '  mapping(address => Forecast) public forecasts;\n', '\n', '  function PlaceNewForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\n', '  public payable\n', '  {\n', '    require(!forecastingClosed && msg.value == 50000000000000000 && !forecasts[msg.sender].hasPaidOrWon);\n', '\n', '    forecasts[msg.sender].part1 = f1;\n', '    forecasts[msg.sender].part2 = f2;\n', '    forecasts[msg.sender].part3 = f3;\n', '    forecasts[msg.sender].part4 = f4;\n', '    forecasts[msg.sender].hasPaidOrWon = true;\n', '\n', '    players.push(msg.sender);\n', '  }\n', '\n', '  function UpdateForecast(bytes32 f1, bytes32 f2, bytes32 f3, bytes12 f4)\n', '  public\n', '  {\n', '    require(!forecastingClosed && forecasts[msg.sender].hasPaidOrWon);\n', '\n', '    forecasts[msg.sender].part1 = f1;\n', '    forecasts[msg.sender].part2 = f2;\n', '    forecasts[msg.sender].part3 = f3;\n', '    forecasts[msg.sender].part4 = f4;\n', '  }\n', '\n', '  function CloseForecasting(uint16 exWinCount)\n', '  public onlyOwner\n', '  {\n', '    require(!forecastingClosed);\n', '    require((exWinCount == 0 && players.length > 10000)\n', '             || (exWinCount > 0 && (uint32(exWinCount) * uint32(exWinCount) >= players.length\n', '                 && uint32(exWinCount - 1) * uint32(exWinCount - 1) < players.length)));\n', '    expectedWinnersCount = (players.length) > 10000 ? uint16(players.length / 100) : exWinCount;\n', '\n', '    forecastingClosed = true;\n', '  }\n', '\n', '  function PublishWorldCupResults(bytes32 res1, bytes32 res2, bytes32 res3, bytes12 res4)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '\n', '    worldCupResultPart1 = res1;\n', '    worldCupResultPart2 = res2;\n', '    worldCupResultPart3 = res3;\n', '    worldCupResultPart4 = res4;\n', '\n', '    resultsValidationStep = 0;\n', '    verifiedWinnersCount = 0;\n', '    verifiedWinnersLastCount = 0;\n', '    resultsPublishedTime = block.timestamp;\n', '  }\n', '\n', '  function PublishWinnersScoreThres(uint16 scoreThres)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '\n', '    publishedWinningScoreThreshold = scoreThres;\n', '  }\n', '\n', '  function VerifyPublishedResults(uint16 stepSize)\n', '  public onlyOwner\n', '  {\n', '    require(forecastingClosed && !resultsPublished);\n', '    require(stepSize > 0 && resultsValidationStep + stepSize <= players.length);\n', '\n', '    uint32 wins;\n', '    uint32 lasts;\n', '\n', '    for (uint32 i = resultsValidationStep; i < resultsValidationStep + stepSize; i++) {\n', '\n', '      Forecast memory fc = forecasts[players[i]];\n', '\n', '      uint16 score = scoreGroups(fc.part1, fc.part2, worldCupResultPart1, worldCupResultPart2)\n', '                     + scoreKnockouts(fc.part2, fc.part3, fc.part4);\n', '\n', '      if (score >= publishedWinningScoreThreshold) {\n', '        wins++;\n', '        if (score == publishedWinningScoreThreshold) {\n', '          lasts++;\n', '        }\n', '        forecasts[players[i]].hasPaidOrWon = true;\n', '      } else {\n', '        forecasts[players[i]].hasPaidOrWon = false;\n', '      }\n', '    }\n', '\n', '    resultsValidationStep += stepSize;\n', '    verifiedWinnersCount += wins;\n', '    verifiedWinnersLastCount += lasts;\n', '\n', '    if (resultsValidationStep == players.length) {\n', '      verifiedWinnersCount = validateWinnersCount(verifiedWinnersCount, verifiedWinnersLastCount, expectedWinnersCount);\n', '      verifiedWinnersLastCount = 0;\n', '      expectedWinnersCount = 0;\n', '\n', '      if (verifiedWinnersCount > 0) {\n', '        prizeValue = address(this).balance / verifiedWinnersCount;\n', '        resultsPublished = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  function WithdrawPrize()\n', '  public\n', '  returns(bool)\n', '  {\n', '    require(prizeValue > 0);\n', '\n', '    if (forecasts[msg.sender].hasPaidOrWon) {\n', '      forecasts[msg.sender].hasPaidOrWon = false;\n', '      if (!msg.sender.send(prizeValue)) {\n', '        forecasts[msg.sender].hasPaidOrWon = true;\n', '        return false;\n', '      }\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function CancelGame()\n', '  public onlyOwner\n', '  {\n', '    forecastingClosed = true;\n', '    resultsPublished = true;\n', '    resultsPublishedTime = block.timestamp;\n', '    prizeValue = address(this).balance / players.length;\n', '  }\n', '\n', '  function CancelGameAfterResultsPublished()\n', '  public onlyOwner\n', '  {\n', '    CancelGame();\n', '    for (uint32 i = 0; i < players.length; i++) {\n', '    \tforecasts[players[i]].hasPaidOrWon = true;\n', '    }\n', '  }\n', '\n', '  function WithdrawUnclaimed()\n', '  public onlyOwner\n', '  returns(bool)\n', '  {\n', '    require(resultsPublished && block.timestamp >= (resultsPublishedTime + 10 weeks));\n', '\n', '    uint256 amount = address(this).balance;\n', '    if (amount > 0) {\n', '      if (!msg.sender.send(amount)) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function getForecastData(bytes32 pred2, bytes32 pred3, bytes12 pred4, uint8 index)\n', '  public pure\n', '  returns(uint8)\n', '  {\n', '    assert(index >= 32 && index < 108);\n', '    if (index < 64) {\n', '      return uint8(pred2[index - 32]);\n', '    } else if (index < 96) {\n', '      return uint8(pred3[index - 64]);\n', '    } else {\n', '      return uint8(pred4[index - 96]);\n', '    }\n', '  }\n', '\n', '  function getResultData(uint8 index)\n', '  public view\n', '  returns(uint8)\n', '  {\n', '    assert(index >= 32 && index < 108);\n', '    if (index < 64) {\n', '      return uint8(worldCupResultPart2[index - 32]);\n', '    } else if (index < 96) {\n', '      return uint8(worldCupResultPart3[index - 64]);\n', '    } else {\n', '      return uint8(worldCupResultPart4[index - 96]);\n', '    }\n', '  }\n', '\n', '  function computeGroupPhasePoints(uint8 pred, uint8 result)\n', '  public pure\n', '  returns(uint8)\n', '  {\n', '    uint8 gamePoint = 0;\n', '\n', '    int8 predLeft = int8(pred % 16);\n', '    int8 predRight = int8(pred >> 4);\n', '    int8 resultLeft = int8(result % 16);\n', '    int8 resultRight = int8(result >> 4);\n', '\n', '    int8 outcome = resultLeft - resultRight;\n', '    int8 predOutcome = predLeft - predRight;\n', '\n', '    if ((outcome > 0 && predOutcome > 0)\n', '        || (outcome < 0 && predOutcome < 0)\n', '        || (outcome == 0 && predOutcome == 0)) {\n', '      gamePoint += 4;\n', '    }\n', '\n', '    if (predLeft == resultLeft) {\n', '      gamePoint += 2;\n', '    }\n', '\n', '    if (predRight == resultRight) {\n', '      gamePoint += 2;\n', '    }\n', '    return gamePoint;\n', '  }\n', '\n', '  function computeKnockoutPoints(uint8 pred, uint8 result, uint8 shootPred, uint8 shootResult,\n', '                                 uint8 roundFactorLeft, uint8 roundFactorRight, bool isInverted)\n', '  public pure\n', '  returns (uint16)\n', '  {\n', '    uint16 gamePoint = 0;\n', '    int8 predLeft = int8(pred % 16);\n', '    int8 predRight = int8(pred >> 4);\n', '    int8 resultLeft = int8(result % 16);\n', '    int8 resultRight = int8(result >> 4);\n', '\n', '    int8 predOutcome = predLeft - predRight;\n', '    int8 outcome = resultLeft - resultRight;\n', '\n', '    if (predOutcome == 0) {\n', '       predOutcome = int8(shootPred % 16) - int8(shootPred >> 4);\n', '    }\n', '    if (outcome == 0) { \n', '       outcome = int8(shootResult % 16) - int8(shootResult >> 4);\n', '    }\n', '\n', '    if (isInverted) {\n', '      resultLeft = resultLeft + resultRight;\n', '      resultRight = resultLeft - resultRight;\n', '      resultLeft = resultLeft - resultRight;\n', '      outcome = -outcome;\n', '    }\n', '\n', '    if ((outcome > 0 && predOutcome > 0) || (outcome < 0 && predOutcome < 0)) {\n', '      gamePoint += 4 * (roundFactorLeft + roundFactorRight);\n', '    }\n', '\n', '    gamePoint += 4 * ((predLeft == resultLeft ? roundFactorLeft : 0)\n', '                      + (predRight == resultRight ? roundFactorRight: 0));\n', '\n', '    return gamePoint;\n', '  }\n', '\n', '  function scoreGroups(bytes32 pred1, bytes32 pred2, bytes32 res1, bytes32 res2)\n', '  public pure\n', '  returns(uint16)\n', '  {\n', '    uint16 points = 0;\n', '    for (uint8 f = 0; f < 48; f++) {\n', '      if (f < 32) {\n', '        points += computeGroupPhasePoints(uint8(pred1[f]), uint8(res1[f]));\n', '      } else {\n', '        points += computeGroupPhasePoints(uint8(pred2[f - 32]), uint8(res2[f - 32]));\n', '      }\n', '    }\n', '    return points;\n', '  }\n', '\n', '  function scoreKnockouts(bytes32 pred2, bytes32 pred3, bytes12 pred4)\n', '  public view\n', '  returns(uint16)\n', '  {\n', '    uint8 f = 48;\n', '    uint16 points = 0;\n', '\n', '    int8[15] memory twinShift = [int8(16), 16, 16, 16, -16, -16, -16, -16, 8, 8, -8, -8, 4, -4, 0];\n', '    uint8[15] memory roundFactor = [uint8(2), 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 8, 8, 16];\n', '\n', '    for (uint8 i = 0; i < 15; i++) {\n', '\n', '      bool teamLeftOK = getForecastData(pred2, pred3, pred4, f) == getResultData(f);\n', '      bool teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) == getResultData(f + 1);\n', '\n', '      if (teamLeftOK || teamRightOK) {\n', '        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2), getResultData(f + 2),\n', '                                        getForecastData(pred2, pred3, pred4, f + 3), getResultData(f + 3),\n', '                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\n', '                                        false);\n', '        if (i < 8) {\n', '          points += (teamLeftOK ? 4 : 0) + (teamRightOK ? 4 : 0);\n', '        }\n', '      }\n', '\n', '      bool isInverted = (i < 8) || i == 14;\n', '      teamLeftOK = getForecastData(pred2, pred3, pred4, f) ==\n', '                   (getResultData(uint8(int8(f + (isInverted ? 1 : 0)) + twinShift[i])));\n', '      teamRightOK = getForecastData(pred2, pred3, pred4, f + 1) ==\n', '                   (getResultData(uint8(int8(f + (isInverted ? 0 : 1)) + twinShift[i])));\n', '\n', '      if (teamLeftOK || teamRightOK) {\n', '        points += computeKnockoutPoints(getForecastData(pred2, pred3, pred4, f + 2),\n', '                                        getResultData(uint8(int8(f + 2) + twinShift[i])),\n', '                                        getForecastData(pred2, pred3, pred4, f + 3),\n', '                                        getResultData(uint8(int8(f + 3) + twinShift[i])),\n', '                                        teamLeftOK ? roundFactor[i] : 0, teamRightOK ? roundFactor[i] : 0,\n', '                                        isInverted);\n', '        if (i < 8) {\n', '          points += (teamLeftOK ? 2 : 0) + (teamRightOK ? 2 : 0);\n', '        }\n', '      }\n', '      f = f + 4;\n', '    }\n', '    return points;\n', '  }\n', '\n', '  function validateWinnersCount(uint32 winners, uint32 last, uint32 expected)\n', '  public pure\n', '  returns(uint32)\n', '  {\n', '    if (winners < expected) {\n', '      return 0;\n', '    } else if ((winners == expected && last >= 1)\n', '                || (last > 1 && (winners - last) < expected)) {\n', '      return winners;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '}']
