['pragma solidity ^0.4.20; \n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address owner) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', '\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token) external;\n', '}\n', '\n', 'contract TRLCoinSale is ApproveAndCallFallBack {\n', '    // Information about a single period\n', '    struct Period {\n', '        uint start;\n', '        uint end;\n', '        uint priceInWei;\n', '        uint tokens;\n', '    }\n', '\n', '    // Information about payment contribution\n', '    struct PaymentContribution {\n', '        uint weiContributed;\n', '        uint timeContribution;\n', '        uint receiveTokens;\n', '    }\n', '\n', '    struct TotalContribution {\n', '        // total value of contribution;\n', '        // for empty address it will be zero\n', '        uint totalReceiveTokens;\n', '        // Only necessary if users want to be able to see contribution history. \n', '        // Otherwise, technically not necessary for the purposes of the sale\n', '        PaymentContribution[] paymentHistory; \n', '    }\n', '\n', '    // Some constant about our expected token distribution\n', '    uint public constant TRLCOIN_DECIMALS = 0;\n', '    uint public constant TOTAL_TOKENS_TO_DISTRIBUTE = 800000000 * (10 ** TRLCOIN_DECIMALS); // 800000000  TRL Token for distribution\n', '    uint public constant TOTAL_TOKENS_AVAILABLE = 1000000000 * (10 ** TRLCOIN_DECIMALS);    // 1000000000 TRL Token totals\n', '\n', '    // ERC20 Contract address.\n', '    ERC20Interface private tokenWallet; // The token wallet contract used for this crowdsale\n', '    \n', '    address private owner;  // The owner of the crowdsale\n', '    \n', '    uint private smallBonus; //The small bonus for presale\n', '    uint private largeBonus; //The large bonus for presale\n', '    uint private largeBonusStopTime; //The stop time for Large bonus\n', '\n', '    uint private tokensRemainingForSale; //Remaining total amout of tokens  \n', '    uint private tokensAwardedForSale;   // total awarded tokens\n', '\n', '    uint private distributionTime; // time after we could start distribution tokens\n', '    \n', '    Period private preSale; // The configured periods for this crowdsale\n', '    Period private sale;    // The configured periods for this crowdsale\n', '    \n', '    \n', '    // pair fo variables one for mapping one for iteration\n', '    mapping(address => TotalContribution) public payments; // Track contributions by each address \n', '    address[] public paymentAddresses;\n', '\n', '    bool private hasStarted; // Has the crowdsale started?\n', '    \n', '    // Fired once the transfer tokens to contract was successfull\n', '    event Transfer(address indexed to, uint amount);\n', '\n', '    // Fired once the sale starts\n', '    event Start(uint timestamp);\n', '\n', '    // Fired whenever a contribution is made\n', '    event Contribute(address indexed from, uint weiContributed, uint tokensReceived);\n', '\n', '    // Fires whenever we send token to contributor\n', '    event Distribute( address indexed to, uint tokensSend );\n', '\n', '    function addContribution(address from, uint weiContributed, uint tokensReceived) private returns(bool) {\n', '        //new contibutor\n', '        require(weiContributed > 0);\n', '        require(tokensReceived > 0);\n', '        require(tokensRemainingForSale >= tokensReceived);\n', '        \n', '        PaymentContribution memory newContribution;\n', '        newContribution.timeContribution = block.timestamp;\n', '        newContribution.weiContributed = weiContributed;\n', '        newContribution.receiveTokens = tokensReceived;\n', '\n', '        // Since we cannot contribute zero tokens, if totalReceiveTokens is zero,\n', '        // then this is the first contribution for this address\n', '        if (payments[from].totalReceiveTokens == 0) {\n', '            // new total contribution           \n', '            payments[from].totalReceiveTokens = tokensReceived;\n', '            payments[from].paymentHistory.push(newContribution);\n', '            \n', '             // push new address to array for iteration by address  during distirbution process\n', '            paymentAddresses.push(from);\n', '        } else {\n', '            payments[from].totalReceiveTokens += tokensReceived;\n', '            payments[from].paymentHistory.push(newContribution);\n', '        }\n', '        tokensRemainingForSale -= tokensReceived;\n', '        tokensAwardedForSale += tokensReceived;\n', '        return true;\n', '    }\n', '\n', '    // public getters for private state variables\n', '    function getOwner() public view returns (address) { return owner; }\n', '    function getHasStartedState() public view  returns(bool) { return hasStarted; }\n', '    function getPresale() public view returns(uint, uint, uint, uint) { \n', '        return (preSale.start, preSale.end, preSale.priceInWei, preSale.tokens);\n', '    }\n', '    function getSale() public view returns(uint, uint, uint, uint) { \n', '        return (sale.start, sale.end, sale.priceInWei, sale.tokens);\n', '    }\n', '    function getDistributionTime() public view returns(uint) { return distributionTime; }\n', '    \n', '    function getSmallBonus() public view returns(uint) { return smallBonus; }\n', '    function getLargeBonus() public view returns(uint) { return largeBonus; }\n', '    function getLargeBonusStopTime() public view returns(uint) { return  largeBonusStopTime; }\n', '    function getTokenRemaining() public view returns(uint) { return tokensRemainingForSale; }\n', '    function getTokenAwarded() public view returns(uint) { return tokensAwardedForSale; }\n', '\n', '    // After create sale contract first function should be approveAndCall on Token contract\n', '    // with this contract as spender and TOTAL_TOKENS_TO_DISTRIBUTE for approval\n', '    // this callback function called form Token contract after approve on Token contract\n', '    // eventually tokensRemainingForSale = TOTAL_TOKENS_TO_DISTRIBUTE\n', '    function receiveApproval(address from, uint256 tokens, address token) external {\n', '        // make sure the sales was not started\n', '        require(hasStarted == false);\n', '        \n', '        // make sure this token address matches our configured tokenWallet address\n', '        require(token == address(tokenWallet)); \n', '        \n', '        tokensRemainingForSale += tokens;\n', '        bool result = tokenWallet.transferFrom(from, this, tokens);\n', '        // Make sure transfer succeeded\n', '        require(result == true);\n', '        \n', '        Transfer(address(this), tokens);\n', '    }\n', '\n', '    // contract constructor\n', '    function TRLCoinSale(address walletAddress) public {\n', '        // Setup the owner and wallet\n', '        owner = msg.sender;\n', '        tokenWallet = ERC20Interface(walletAddress);\n', '\n', '        // Make sure the provided token has the expected number of tokens to distribute\n', '        require(tokenWallet.totalSupply() == TOTAL_TOKENS_AVAILABLE);\n', '\n', '        // Make sure the owner actually controls all the tokens\n', '        require(tokenWallet.balanceOf(owner) >= TOTAL_TOKENS_TO_DISTRIBUTE);\n', '\n', '        // The multiplier necessary to change a coin amount to the token amount\n', '        uint coinToTokenFactor = 10 ** TRLCOIN_DECIMALS;\n', '\n', '        preSale.start = 1520812800; // 00:00:00, March 12, 2018 UTC use next site https://www.epochconverter.com/\n', '        preSale.end = 1523491199; // 23:59:59, July 11, 2018 UTC\n', '        preSale.priceInWei = (1 ether) / (20000 * coinToTokenFactor); // 1 ETH = 20000 TRL\n', '        preSale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\n', '       \n', '        smallBonus = 10;\n', '        largeBonus = 20;\n', '        largeBonusStopTime = 1521504000;\n', '    \n', '        sale.start = 1523491200; // 00:00:00, July 12, 2018 UTC use next site https://www.epochconverter.com/\n', '        sale.end = 1531378799; // 23:59:59, July 11, 2018 UTC\n', '        sale.priceInWei = (1 ether) / (10000 * coinToTokenFactor); // 1 ETH = 10000 TRL\n', '        sale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\n', '        \n', '        distributionTime = 1531378800; // 00:00:00, June 12, 2018 UTC\n', '\n', '        tokensRemainingForSale = 0;\n', '        tokensAwardedForSale = 0;\n', '    }\n', '\n', '    // change default presale dates \n', '    function setPresaleDates(uint startDate, uint stopDate) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        //insanity check start < stop and stop resale < start of sale\n', '        require(startDate < stopDate && stopDate < sale.start);\n', '        \n', '        preSale.start = startDate;\n', '        preSale.end = stopDate;\n', '    }\n', '    \n', '    // change default presale dates \n', '    function setlargeBonusStopTime(uint bonusStopTime) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        //insanity check start < stop and stop resale < start of sale\n', '        require(preSale.start <= bonusStopTime && bonusStopTime <= preSale.end);\n', '        \n', '        largeBonusStopTime = bonusStopTime;\n', '    }\n', '    \n', '    // change default sale dates \n', '    function setSale(uint startDate, uint stopDate) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        // insanity check start < stop and stop resale < start of sale\n', '        require(startDate < stopDate && startDate > preSale.end);\n', '        // insanity check sale.end < distirbution token time\n', '        require(sale.end < distributionTime);\n', '        \n', '        sale.start = startDate;\n', '        sale.end = stopDate;\n', '    }\n', '\n', '    // change default distibution time\n', '    function setDistributionTime(uint timeOfDistribution) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        // insanity check sale.end < distirbution token time\n', '        require(sale.end < timeOfDistribution);\n', '        \n', '        distributionTime = timeOfDistribution;\n', '    }\n', '\n', '    // this function added Contributor that already made contribution before presale started \n', '    // should be called only after token was transfered to Sale contract\n', '    function addContributorManually( address who, uint contributionWei, uint tokens) public returns(bool) {\n', '        // only owner\n', '        require(msg.sender == owner);   \n', '        //contract must be not active\n', '        require(hasStarted == false);\n', '        // all entried must be added before presale started\n', '        require(block.timestamp < preSale.start);\n', '        // contract mush have total == TOTAL_TOKENS_TO_DISTRIBUTE\n', '        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '        \n', '        // decrement presale - token for manual contibution should be taken from presale\n', '        preSale.tokens -= tokens;\n', '\n', '        addContribution(who, contributionWei, tokens);\n', '        Contribute(who, contributionWei, tokens);\n', '        return true;\n', '    }\n', '\n', '    // Start the crowdsale\n', '    function startSale() public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot start if already started\n', '        require(hasStarted == false);\n', '        // Make sure the timestamps all make sense\n', '        require(preSale.end > preSale.start);\n', '        require(sale.end > sale.start);\n', '        require(sale.start > preSale.end);\n', '        require(distributionTime > sale.end);\n', '\n', '        // Make sure the owner actually controls all the tokens for sales\n', '        require(tokenWallet.balanceOf(address(this)) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '\n', '        // Make sure we allocated all sale tokens\n', '        require((preSale.tokens + sale.tokens) == tokensRemainingForSale);          \n', '\n', '        // The sale can begin\n', '        hasStarted = true;\n', '\n', '        // Fire event that the sale has begun\n', '        Start(block.timestamp);\n', '    }    \n', '\n', '    // Allow the current owner to change the owner of the crowdsale\n', '    function changeOwner(address newOwner) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '\n', '        // Change the owner\n', '        owner = newOwner;\n', '    }\n', '\n', '    function preSaleFinishedProcess( uint timeOfRequest) private returns(bool) {\n', '        // if we have Sales event and tokens of presale is not 0 move them to sales\n', '        require(timeOfRequest >= sale.start && timeOfRequest <= sale.end);\n', '        if (preSale.tokens != 0) {\n', '            uint savePreSaleTomens = preSale.tokens;\n', '            preSale.tokens = 0;\n', '            sale.tokens += savePreSaleTomens;\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // Calculate how many tokens can be distributed for the given contribution\n', '    function getTokensForContribution(uint weiContribution) private returns(uint timeOfRequest, uint tokenAmount, uint weiRemainder, uint bonus) { \n', '        // Get curent time\n', '        timeOfRequest = block.timestamp;\n', '        // just for sure that bonus is initialized\n', '        bonus = 0;\n', '                 \n', '        // checking what period are we\n', '        if (timeOfRequest <= preSale.end) {\n', '            // Return the amount of tokens that can be purchased\n', '            // And the amount of wei that would be left over\n', '            tokenAmount = weiContribution / preSale.priceInWei;\n', '            weiRemainder = weiContribution % preSale.priceInWei;\n', '            // if presale - checking bonuses\n', '            if (timeOfRequest < largeBonusStopTime) {\n', '                bonus = ( tokenAmount * largeBonus ) / 100;\n', '            } else {\n', '                bonus = ( tokenAmount * smallBonus ) / 100;\n', '            }             \n', '        } else {\n', '            // if sales period just started - transfer all remaining tokens from presale to sale\n', '            preSaleFinishedProcess(timeOfRequest);\n', '            // Return the amount of tokens that can be purchased\n', '            // And the amount of wei that would be left over\n', '            tokenAmount = weiContribution / sale.priceInWei;\n', '            weiRemainder = weiContribution % sale.priceInWei;\n', '        } \n', '        return(timeOfRequest, tokenAmount, weiRemainder, bonus);\n', '    }\n', '    \n', '    function()public payable {\n', '        // Cannot contribute if the sale hasn&#39;t started\n', '        require(hasStarted == true);\n', '        // Cannot contribute if sale is not in this time range\n', '        require((block.timestamp >= preSale.start && block.timestamp <= preSale.end)\n', '            || (block.timestamp >= sale.start && block.timestamp <= sale.end)\n', '        ); \n', '\n', '        // Cannot contribute if amount of money send is les then 0.1 ETH\n', '        require(msg.value >= 100 finney);\n', '        \n', '        uint timeOfRequest;\n', '        uint tokenAmount;\n', '        uint weiRemainder;\n', '        uint bonus;\n', '        // Calculate the tokens to be distributed based on the contribution amount\n', '        (timeOfRequest, tokenAmount, weiRemainder, bonus) = getTokensForContribution(msg.value);\n', '\n', '        // Make sure there are enough tokens left to buy\n', '        require(tokensRemainingForSale >= tokenAmount + bonus);\n', '        \n', '        // Need to contribute enough for at least 1 token\n', '        require(tokenAmount > 0);\n', '        \n', '        // Sanity check: make sure the remainder is less or equal to what was sent to us\n', '        require(weiRemainder <= msg.value);\n', '\n', '        // Check whether in presale or sale\n', '        if (timeOfRequest <= preSale.end) {\n', '            require(tokenAmount <= preSale.tokens);\n', '            require(bonus <= sale.tokens);\n', '            preSale.tokens -= tokenAmount;\n', '            sale.tokens -= bonus;\n', '        } else {\n', '            require(tokenAmount <= sale.tokens);\n', '            // there should be no bonus available after presale\n', '            require(bonus == 0); \n', '            sale.tokens -= tokenAmount;\n', '        }\n', '\n', '        // setup new contribution\n', '        addContribution(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\n', '\n', '        /// Transfer contribution amount to owner\n', '        owner.transfer(msg.value - weiRemainder);\n', '        // Return the remainder to the sender\n', '        msg.sender.transfer(weiRemainder);\n', '\n', '        // Since we refunded the remainder, the actual contribution is the amount sent\n', '        // minus the remainder\n', '        \n', '        // Record the event\n', '        Contribute(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\n', '    } \n', '\n', '    \n', '    // Allow the owner to withdraw all the tokens remaining after the\n', '    // crowdsale is over\n', '    function withdrawTokensRemaining() public returns (bool) {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '        // The crowsale must be over to perform this operation\n', '        require(block.timestamp > sale.end);\n', '        // Get the remaining tokens owned by the crowdsale\n', '        uint tokenToSend = tokensRemainingForSale;\n', '        // Set available tokens to Zero\n', '        tokensRemainingForSale = 0;\n', '        sale.tokens = 0;\n', '        // Transfer them all to the owner\n', '        bool result = tokenWallet.transfer(owner, tokenToSend);\n', '        // Be sure that transfer was successfull\n', '        require(result == true);\n', '        Distribute(owner, tokenToSend);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to withdraw all ether from the contract after the crowdsale is over.\n', '    // We don&#39;t need this function( we transfer ether immediately to owner - just in case\n', '    function withdrawEtherRemaining() public returns (bool) {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '        // The crowsale must be over to perform this operation\n', '        require(block.timestamp > sale.end);\n', '\n', '        // Transfer them all to the owner\n', '        owner.transfer(this.balance);\n', '        return true;\n', '    }\n', '\n', '    // this function is intentionally internal because we do not check conditions here\n', '    function transferTokensToContributor(uint idx) private returns (bool) {\n', '        if (payments[paymentAddresses[idx]].totalReceiveTokens > 0) {\n', '            // this is for race conditions               \n', '            uint tokenToSend = payments[paymentAddresses[idx]].totalReceiveTokens;\n', '            payments[paymentAddresses[idx]].totalReceiveTokens = 0;\n', '            \n', '            //decrement awarded token\n', '            require(tokensAwardedForSale >= tokenToSend);\n', '            tokensAwardedForSale -= tokenToSend;\n', '            // Transfer them all to the owner\n', '            bool result = tokenWallet.transfer(paymentAddresses[idx], tokenToSend);\n', '            // Be sure that transfer was successfull\n', '            require(result == true);\n', '            Distribute(paymentAddresses[idx], tokenToSend);\n', '        }\n', '        return true;\n', '\n', '    }\n', '    \n', '    // get number of real contributors\n', '    function getNumberOfContributors( ) public view returns (uint) {\n', '        return paymentAddresses.length;\n', '    }\n', '    \n', '    // This function for transfer tokens one by one\n', '    function distributeTokensToContributorByIndex( uint indexVal) public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        require(indexVal < paymentAddresses.length);\n', '        \n', '        transferTokensToContributor(indexVal);                    \n', '        return true;        \n', '    }\n', '\n', '    function distributeTokensToContributor( uint startIndex, uint numberOfContributors )public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        require(startIndex < paymentAddresses.length);\n', '        \n', '        uint len = paymentAddresses.length < startIndex + numberOfContributors? paymentAddresses.length : startIndex + numberOfContributors;\n', '        for (uint i = startIndex; i < len; i++) {\n', '            transferTokensToContributor(i);                    \n', '        }\n', '        return true;        \n', '    }\n', '\n', '    function distributeAllTokensToContributor( )public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        \n', '        for (uint i = 0; i < paymentAddresses.length; i++) {\n', '            transferTokensToContributor(i); \n', '        }\n', '        return true;        \n', '    }\n', '    \n', '    // Owner can transfer out any accidentally sent ERC20 tokens as long as they are not the sale tokens\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool) {\n', '        require(msg.sender == owner);\n', '        require(tokenAddress != address(tokenWallet));\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
['pragma solidity ^0.4.20; \n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address owner) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', '\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token) external;\n', '}\n', '\n', 'contract TRLCoinSale is ApproveAndCallFallBack {\n', '    // Information about a single period\n', '    struct Period {\n', '        uint start;\n', '        uint end;\n', '        uint priceInWei;\n', '        uint tokens;\n', '    }\n', '\n', '    // Information about payment contribution\n', '    struct PaymentContribution {\n', '        uint weiContributed;\n', '        uint timeContribution;\n', '        uint receiveTokens;\n', '    }\n', '\n', '    struct TotalContribution {\n', '        // total value of contribution;\n', '        // for empty address it will be zero\n', '        uint totalReceiveTokens;\n', '        // Only necessary if users want to be able to see contribution history. \n', '        // Otherwise, technically not necessary for the purposes of the sale\n', '        PaymentContribution[] paymentHistory; \n', '    }\n', '\n', '    // Some constant about our expected token distribution\n', '    uint public constant TRLCOIN_DECIMALS = 0;\n', '    uint public constant TOTAL_TOKENS_TO_DISTRIBUTE = 800000000 * (10 ** TRLCOIN_DECIMALS); // 800000000  TRL Token for distribution\n', '    uint public constant TOTAL_TOKENS_AVAILABLE = 1000000000 * (10 ** TRLCOIN_DECIMALS);    // 1000000000 TRL Token totals\n', '\n', '    // ERC20 Contract address.\n', '    ERC20Interface private tokenWallet; // The token wallet contract used for this crowdsale\n', '    \n', '    address private owner;  // The owner of the crowdsale\n', '    \n', '    uint private smallBonus; //The small bonus for presale\n', '    uint private largeBonus; //The large bonus for presale\n', '    uint private largeBonusStopTime; //The stop time for Large bonus\n', '\n', '    uint private tokensRemainingForSale; //Remaining total amout of tokens  \n', '    uint private tokensAwardedForSale;   // total awarded tokens\n', '\n', '    uint private distributionTime; // time after we could start distribution tokens\n', '    \n', '    Period private preSale; // The configured periods for this crowdsale\n', '    Period private sale;    // The configured periods for this crowdsale\n', '    \n', '    \n', '    // pair fo variables one for mapping one for iteration\n', '    mapping(address => TotalContribution) public payments; // Track contributions by each address \n', '    address[] public paymentAddresses;\n', '\n', '    bool private hasStarted; // Has the crowdsale started?\n', '    \n', '    // Fired once the transfer tokens to contract was successfull\n', '    event Transfer(address indexed to, uint amount);\n', '\n', '    // Fired once the sale starts\n', '    event Start(uint timestamp);\n', '\n', '    // Fired whenever a contribution is made\n', '    event Contribute(address indexed from, uint weiContributed, uint tokensReceived);\n', '\n', '    // Fires whenever we send token to contributor\n', '    event Distribute( address indexed to, uint tokensSend );\n', '\n', '    function addContribution(address from, uint weiContributed, uint tokensReceived) private returns(bool) {\n', '        //new contibutor\n', '        require(weiContributed > 0);\n', '        require(tokensReceived > 0);\n', '        require(tokensRemainingForSale >= tokensReceived);\n', '        \n', '        PaymentContribution memory newContribution;\n', '        newContribution.timeContribution = block.timestamp;\n', '        newContribution.weiContributed = weiContributed;\n', '        newContribution.receiveTokens = tokensReceived;\n', '\n', '        // Since we cannot contribute zero tokens, if totalReceiveTokens is zero,\n', '        // then this is the first contribution for this address\n', '        if (payments[from].totalReceiveTokens == 0) {\n', '            // new total contribution           \n', '            payments[from].totalReceiveTokens = tokensReceived;\n', '            payments[from].paymentHistory.push(newContribution);\n', '            \n', '             // push new address to array for iteration by address  during distirbution process\n', '            paymentAddresses.push(from);\n', '        } else {\n', '            payments[from].totalReceiveTokens += tokensReceived;\n', '            payments[from].paymentHistory.push(newContribution);\n', '        }\n', '        tokensRemainingForSale -= tokensReceived;\n', '        tokensAwardedForSale += tokensReceived;\n', '        return true;\n', '    }\n', '\n', '    // public getters for private state variables\n', '    function getOwner() public view returns (address) { return owner; }\n', '    function getHasStartedState() public view  returns(bool) { return hasStarted; }\n', '    function getPresale() public view returns(uint, uint, uint, uint) { \n', '        return (preSale.start, preSale.end, preSale.priceInWei, preSale.tokens);\n', '    }\n', '    function getSale() public view returns(uint, uint, uint, uint) { \n', '        return (sale.start, sale.end, sale.priceInWei, sale.tokens);\n', '    }\n', '    function getDistributionTime() public view returns(uint) { return distributionTime; }\n', '    \n', '    function getSmallBonus() public view returns(uint) { return smallBonus; }\n', '    function getLargeBonus() public view returns(uint) { return largeBonus; }\n', '    function getLargeBonusStopTime() public view returns(uint) { return  largeBonusStopTime; }\n', '    function getTokenRemaining() public view returns(uint) { return tokensRemainingForSale; }\n', '    function getTokenAwarded() public view returns(uint) { return tokensAwardedForSale; }\n', '\n', '    // After create sale contract first function should be approveAndCall on Token contract\n', '    // with this contract as spender and TOTAL_TOKENS_TO_DISTRIBUTE for approval\n', '    // this callback function called form Token contract after approve on Token contract\n', '    // eventually tokensRemainingForSale = TOTAL_TOKENS_TO_DISTRIBUTE\n', '    function receiveApproval(address from, uint256 tokens, address token) external {\n', '        // make sure the sales was not started\n', '        require(hasStarted == false);\n', '        \n', '        // make sure this token address matches our configured tokenWallet address\n', '        require(token == address(tokenWallet)); \n', '        \n', '        tokensRemainingForSale += tokens;\n', '        bool result = tokenWallet.transferFrom(from, this, tokens);\n', '        // Make sure transfer succeeded\n', '        require(result == true);\n', '        \n', '        Transfer(address(this), tokens);\n', '    }\n', '\n', '    // contract constructor\n', '    function TRLCoinSale(address walletAddress) public {\n', '        // Setup the owner and wallet\n', '        owner = msg.sender;\n', '        tokenWallet = ERC20Interface(walletAddress);\n', '\n', '        // Make sure the provided token has the expected number of tokens to distribute\n', '        require(tokenWallet.totalSupply() == TOTAL_TOKENS_AVAILABLE);\n', '\n', '        // Make sure the owner actually controls all the tokens\n', '        require(tokenWallet.balanceOf(owner) >= TOTAL_TOKENS_TO_DISTRIBUTE);\n', '\n', '        // The multiplier necessary to change a coin amount to the token amount\n', '        uint coinToTokenFactor = 10 ** TRLCOIN_DECIMALS;\n', '\n', '        preSale.start = 1520812800; // 00:00:00, March 12, 2018 UTC use next site https://www.epochconverter.com/\n', '        preSale.end = 1523491199; // 23:59:59, July 11, 2018 UTC\n', '        preSale.priceInWei = (1 ether) / (20000 * coinToTokenFactor); // 1 ETH = 20000 TRL\n', '        preSale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\n', '       \n', '        smallBonus = 10;\n', '        largeBonus = 20;\n', '        largeBonusStopTime = 1521504000;\n', '    \n', '        sale.start = 1523491200; // 00:00:00, July 12, 2018 UTC use next site https://www.epochconverter.com/\n', '        sale.end = 1531378799; // 23:59:59, July 11, 2018 UTC\n', '        sale.priceInWei = (1 ether) / (10000 * coinToTokenFactor); // 1 ETH = 10000 TRL\n', '        sale.tokens = TOTAL_TOKENS_TO_DISTRIBUTE / 2;\n', '        \n', '        distributionTime = 1531378800; // 00:00:00, June 12, 2018 UTC\n', '\n', '        tokensRemainingForSale = 0;\n', '        tokensAwardedForSale = 0;\n', '    }\n', '\n', '    // change default presale dates \n', '    function setPresaleDates(uint startDate, uint stopDate) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        //insanity check start < stop and stop resale < start of sale\n', '        require(startDate < stopDate && stopDate < sale.start);\n', '        \n', '        preSale.start = startDate;\n', '        preSale.end = stopDate;\n', '    }\n', '    \n', '    // change default presale dates \n', '    function setlargeBonusStopTime(uint bonusStopTime) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        //insanity check start < stop and stop resale < start of sale\n', '        require(preSale.start <= bonusStopTime && bonusStopTime <= preSale.end);\n', '        \n', '        largeBonusStopTime = bonusStopTime;\n', '    }\n', '    \n', '    // change default sale dates \n', '    function setSale(uint startDate, uint stopDate) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        // insanity check start < stop and stop resale < start of sale\n', '        require(startDate < stopDate && startDate > preSale.end);\n', '        // insanity check sale.end < distirbution token time\n', '        require(sale.end < distributionTime);\n', '        \n', '        sale.start = startDate;\n', '        sale.end = stopDate;\n', '    }\n', '\n', '    // change default distibution time\n', '    function setDistributionTime(uint timeOfDistribution) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot change if already started\n', '        require(hasStarted == false);\n', '        // insanity check sale.end < distirbution token time\n', '        require(sale.end < timeOfDistribution);\n', '        \n', '        distributionTime = timeOfDistribution;\n', '    }\n', '\n', '    // this function added Contributor that already made contribution before presale started \n', '    // should be called only after token was transfered to Sale contract\n', '    function addContributorManually( address who, uint contributionWei, uint tokens) public returns(bool) {\n', '        // only owner\n', '        require(msg.sender == owner);   \n', '        //contract must be not active\n', '        require(hasStarted == false);\n', '        // all entried must be added before presale started\n', '        require(block.timestamp < preSale.start);\n', '        // contract mush have total == TOTAL_TOKENS_TO_DISTRIBUTE\n', '        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '        \n', '        // decrement presale - token for manual contibution should be taken from presale\n', '        preSale.tokens -= tokens;\n', '\n', '        addContribution(who, contributionWei, tokens);\n', '        Contribute(who, contributionWei, tokens);\n', '        return true;\n', '    }\n', '\n', '    // Start the crowdsale\n', '    function startSale() public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner); \n', '        // Cannot start if already started\n', '        require(hasStarted == false);\n', '        // Make sure the timestamps all make sense\n', '        require(preSale.end > preSale.start);\n', '        require(sale.end > sale.start);\n', '        require(sale.start > preSale.end);\n', '        require(distributionTime > sale.end);\n', '\n', '        // Make sure the owner actually controls all the tokens for sales\n', '        require(tokenWallet.balanceOf(address(this)) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '        require((tokensRemainingForSale + tokensAwardedForSale) == TOTAL_TOKENS_TO_DISTRIBUTE);\n', '\n', '        // Make sure we allocated all sale tokens\n', '        require((preSale.tokens + sale.tokens) == tokensRemainingForSale);          \n', '\n', '        // The sale can begin\n', '        hasStarted = true;\n', '\n', '        // Fire event that the sale has begun\n', '        Start(block.timestamp);\n', '    }    \n', '\n', '    // Allow the current owner to change the owner of the crowdsale\n', '    function changeOwner(address newOwner) public {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '\n', '        // Change the owner\n', '        owner = newOwner;\n', '    }\n', '\n', '    function preSaleFinishedProcess( uint timeOfRequest) private returns(bool) {\n', '        // if we have Sales event and tokens of presale is not 0 move them to sales\n', '        require(timeOfRequest >= sale.start && timeOfRequest <= sale.end);\n', '        if (preSale.tokens != 0) {\n', '            uint savePreSaleTomens = preSale.tokens;\n', '            preSale.tokens = 0;\n', '            sale.tokens += savePreSaleTomens;\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // Calculate how many tokens can be distributed for the given contribution\n', '    function getTokensForContribution(uint weiContribution) private returns(uint timeOfRequest, uint tokenAmount, uint weiRemainder, uint bonus) { \n', '        // Get curent time\n', '        timeOfRequest = block.timestamp;\n', '        // just for sure that bonus is initialized\n', '        bonus = 0;\n', '                 \n', '        // checking what period are we\n', '        if (timeOfRequest <= preSale.end) {\n', '            // Return the amount of tokens that can be purchased\n', '            // And the amount of wei that would be left over\n', '            tokenAmount = weiContribution / preSale.priceInWei;\n', '            weiRemainder = weiContribution % preSale.priceInWei;\n', '            // if presale - checking bonuses\n', '            if (timeOfRequest < largeBonusStopTime) {\n', '                bonus = ( tokenAmount * largeBonus ) / 100;\n', '            } else {\n', '                bonus = ( tokenAmount * smallBonus ) / 100;\n', '            }             \n', '        } else {\n', '            // if sales period just started - transfer all remaining tokens from presale to sale\n', '            preSaleFinishedProcess(timeOfRequest);\n', '            // Return the amount of tokens that can be purchased\n', '            // And the amount of wei that would be left over\n', '            tokenAmount = weiContribution / sale.priceInWei;\n', '            weiRemainder = weiContribution % sale.priceInWei;\n', '        } \n', '        return(timeOfRequest, tokenAmount, weiRemainder, bonus);\n', '    }\n', '    \n', '    function()public payable {\n', "        // Cannot contribute if the sale hasn't started\n", '        require(hasStarted == true);\n', '        // Cannot contribute if sale is not in this time range\n', '        require((block.timestamp >= preSale.start && block.timestamp <= preSale.end)\n', '            || (block.timestamp >= sale.start && block.timestamp <= sale.end)\n', '        ); \n', '\n', '        // Cannot contribute if amount of money send is les then 0.1 ETH\n', '        require(msg.value >= 100 finney);\n', '        \n', '        uint timeOfRequest;\n', '        uint tokenAmount;\n', '        uint weiRemainder;\n', '        uint bonus;\n', '        // Calculate the tokens to be distributed based on the contribution amount\n', '        (timeOfRequest, tokenAmount, weiRemainder, bonus) = getTokensForContribution(msg.value);\n', '\n', '        // Make sure there are enough tokens left to buy\n', '        require(tokensRemainingForSale >= tokenAmount + bonus);\n', '        \n', '        // Need to contribute enough for at least 1 token\n', '        require(tokenAmount > 0);\n', '        \n', '        // Sanity check: make sure the remainder is less or equal to what was sent to us\n', '        require(weiRemainder <= msg.value);\n', '\n', '        // Check whether in presale or sale\n', '        if (timeOfRequest <= preSale.end) {\n', '            require(tokenAmount <= preSale.tokens);\n', '            require(bonus <= sale.tokens);\n', '            preSale.tokens -= tokenAmount;\n', '            sale.tokens -= bonus;\n', '        } else {\n', '            require(tokenAmount <= sale.tokens);\n', '            // there should be no bonus available after presale\n', '            require(bonus == 0); \n', '            sale.tokens -= tokenAmount;\n', '        }\n', '\n', '        // setup new contribution\n', '        addContribution(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\n', '\n', '        /// Transfer contribution amount to owner\n', '        owner.transfer(msg.value - weiRemainder);\n', '        // Return the remainder to the sender\n', '        msg.sender.transfer(weiRemainder);\n', '\n', '        // Since we refunded the remainder, the actual contribution is the amount sent\n', '        // minus the remainder\n', '        \n', '        // Record the event\n', '        Contribute(msg.sender, msg.value - weiRemainder, tokenAmount + bonus);\n', '    } \n', '\n', '    \n', '    // Allow the owner to withdraw all the tokens remaining after the\n', '    // crowdsale is over\n', '    function withdrawTokensRemaining() public returns (bool) {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '        // The crowsale must be over to perform this operation\n', '        require(block.timestamp > sale.end);\n', '        // Get the remaining tokens owned by the crowdsale\n', '        uint tokenToSend = tokensRemainingForSale;\n', '        // Set available tokens to Zero\n', '        tokensRemainingForSale = 0;\n', '        sale.tokens = 0;\n', '        // Transfer them all to the owner\n', '        bool result = tokenWallet.transfer(owner, tokenToSend);\n', '        // Be sure that transfer was successfull\n', '        require(result == true);\n', '        Distribute(owner, tokenToSend);\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to withdraw all ether from the contract after the crowdsale is over.\n', "    // We don't need this function( we transfer ether immediately to owner - just in case\n", '    function withdrawEtherRemaining() public returns (bool) {\n', '        // Only the owner can do this\n', '        require(msg.sender == owner);\n', '        // The crowsale must be over to perform this operation\n', '        require(block.timestamp > sale.end);\n', '\n', '        // Transfer them all to the owner\n', '        owner.transfer(this.balance);\n', '        return true;\n', '    }\n', '\n', '    // this function is intentionally internal because we do not check conditions here\n', '    function transferTokensToContributor(uint idx) private returns (bool) {\n', '        if (payments[paymentAddresses[idx]].totalReceiveTokens > 0) {\n', '            // this is for race conditions               \n', '            uint tokenToSend = payments[paymentAddresses[idx]].totalReceiveTokens;\n', '            payments[paymentAddresses[idx]].totalReceiveTokens = 0;\n', '            \n', '            //decrement awarded token\n', '            require(tokensAwardedForSale >= tokenToSend);\n', '            tokensAwardedForSale -= tokenToSend;\n', '            // Transfer them all to the owner\n', '            bool result = tokenWallet.transfer(paymentAddresses[idx], tokenToSend);\n', '            // Be sure that transfer was successfull\n', '            require(result == true);\n', '            Distribute(paymentAddresses[idx], tokenToSend);\n', '        }\n', '        return true;\n', '\n', '    }\n', '    \n', '    // get number of real contributors\n', '    function getNumberOfContributors( ) public view returns (uint) {\n', '        return paymentAddresses.length;\n', '    }\n', '    \n', '    // This function for transfer tokens one by one\n', '    function distributeTokensToContributorByIndex( uint indexVal) public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        require(indexVal < paymentAddresses.length);\n', '        \n', '        transferTokensToContributor(indexVal);                    \n', '        return true;        \n', '    }\n', '\n', '    function distributeTokensToContributor( uint startIndex, uint numberOfContributors )public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        require(startIndex < paymentAddresses.length);\n', '        \n', '        uint len = paymentAddresses.length < startIndex + numberOfContributors? paymentAddresses.length : startIndex + numberOfContributors;\n', '        for (uint i = startIndex; i < len; i++) {\n', '            transferTokensToContributor(i);                    \n', '        }\n', '        return true;        \n', '    }\n', '\n', '    function distributeAllTokensToContributor( )public returns (bool) {\n', '        // this is regular check for this function\n', '        require(msg.sender == owner);\n', '        require(block.timestamp >= distributionTime);\n', '        \n', '        for (uint i = 0; i < paymentAddresses.length; i++) {\n', '            transferTokensToContributor(i); \n', '        }\n', '        return true;        \n', '    }\n', '    \n', '    // Owner can transfer out any accidentally sent ERC20 tokens as long as they are not the sale tokens\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool) {\n', '        require(msg.sender == owner);\n', '        require(tokenAddress != address(tokenWallet));\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']
