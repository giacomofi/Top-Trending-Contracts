['pragma solidity ^0.4.24;\n', '\n', '\n', 'contract fortunes {\n', '    \n', '    string public standard = &#39;Fortunes&#39;;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    \n', '    address owner;\n', '    uint public max_fortunes;\n', '    uint public unopened_bid;\n', '    bytes32[] public ur_luck;                      // store lucky say\n', '    \n', '    struct fortune {\n', '        address original_owner;                     // one who opened\n', '        address original_minter;                    // one who marked\n', '        address current_owner;\n', '        uint32 number;\n', '        uint8 level;\n', '        bytes32[144] img;\n', '        bytes32 str_luck;                           // 32 char max luck\n', '        bytes32 str_name;                           // 32 char max name\n', '        bool has_img;   \n', '        bool opened;                                // opened has set the lvl and luck\n', '        bool forsale;                       \n', '        uint current_bid;\n', '        address current_bidder;\n', '        uint bid_cnt;                               // times bid on this sale\n', '        uint auction_end;                           // time to end the auction\n', '    }\n', '    \n', '    fortune[] public fortune_arr;                   // fortunes cannot be deleted\n', '    mapping(uint8 => uint8) public lvl_count;       // cnt each lvl fortunes\n', '    mapping(address => uint) public pending_pay;    // pending withdrawals\n', '    \n', '    uint tax;\n', '\tuint public fortune_limitbreak;\t\t\t\t    // current limitbreak ammount\n', '\tuint public fortune_break_current;\t\t\t\t// current ammount of ether for limitbreak\n', '    \n', '    \n', '    modifier only_owner() \n', '        { require(msg.sender == owner, "only owner can call."); _; }\n', '    modifier only_currowner(uint _idx) \n', '        { require(fortune_arr[_idx].current_owner == msg.sender, "you&#39;re not the owner"); _; }\n', '    modifier idx_inrange(uint _idx)\n', '        { require(_idx >= 0 && _idx < fortune_arr.length, "idx out of range"); _; }\n', '        \n', '        \n', '    constructor() public {\n', '        owner = (msg.sender);\n', '        max_fortunes = 5000;\n', '        unopened_bid = 0.014 ether;\n', '        tax = 50; // N/25 = 4% \n', '\t\tfortune_limitbreak = 2 ether;\n', '        \n', '        name = "FORTUNES";\n', '        symbol = "4TN";\n', '        decimals = 0;\n', '        \n', '        // initial luck\n', '        ur_luck.push("The WORST Possible");\n', '        ur_luck.push("Terrible");\n', '        ur_luck.push("Bad");\n', '        ur_luck.push("Exactly Average");\n', '        ur_luck.push("Good");\n', '        ur_luck.push("Excellent");\n', '        ur_luck.push("The BEST Possible");\n', '    }\n', '    \n', '    function is_owned(uint _idx) public view idx_inrange(_idx) returns(bool) \n', '        { return msg.sender == fortune_arr[_idx].current_owner; }\n', '\t\n', '    function ret_len() public view returns(uint) { return fortune_arr.length; }\n', '    \n', '    function ret_luklen () public view returns(uint) { return ur_luck.length; }\n', '    \n', '\tfunction ret_img(uint _idx) public idx_inrange(_idx) view returns(bytes32[144]) {\n', '\t\treturn fortune_arr[_idx].img;\n', '\t}\n', '    \n', '    function fortune_new() public payable {\n', '\t\trequire(msg.value >= unopened_bid || \n', '\t\t        msg.sender == owner || \n', '\t\t        fortune_arr.length <= 500, \n', '\t\t        "ammount below unopened bid");\n', '        require(fortune_arr.length <= max_fortunes,"fortunes max reached");\n', '        fortune memory x;\n', '        x.current_owner = msg.sender;\n', '\t\tx.number = uint32(fortune_arr.length);\n', '\t\tunopened_bid += unopened_bid/1000; // 0.01% increase\n', '        fortune_arr.push(x);\n', '        pending_pay[owner]+= msg.value;\n', '        emit event_new(fortune_arr.length-1);\n', '    }\n', '    \n', '    function fortune_open(uint _idx) public idx_inrange(_idx) only_currowner(_idx) {\n', '        require(!fortune_arr[_idx].opened, "fortune is already open");\n', '        require(!fortune_arr[_idx].forsale, "fortune is selling");\n', '        fortune_arr[_idx].original_owner = msg.sender;\n', '        uint _ran = arand(fortune_arr[_idx].current_owner, now)%1000;\n', '        uint8 clvl = 1;\n', '        if (_ran <= 810) clvl = 2;\n', '        if (_ran <= 648) clvl = 3;\n', '        if (_ran <= 504) clvl = 4;\n', '        if (_ran <= 378) clvl = 5;\n', '        if (_ran <= 270) clvl = 6;\n', '        if (_ran <= 180) clvl = 7;\n', '        if (_ran <= 108) clvl = 8;\n', '        if (_ran <= 54)  clvl = 9;\n', '        if (_ran <= 18)  clvl = 10;\n', '\n', '        fortune_arr[_idx].level = clvl;\n', '        fortune_arr[_idx].opened = true;\n', '        fortune_arr[_idx].str_luck = \n', '            ur_luck[arand(fortune_arr[_idx].current_owner, now)% ur_luck.length];\n', '        \n', '        // first fortune in honor of mai waifu\n', '        if(_idx == 0) {\n', '            fortune_arr[_idx].level = 0;\n', '            fortune_arr[_idx].str_luck = ur_luck[6];\n', '            lvl_count[0] += 1;\n', '        } else lvl_count[clvl] += 1;    \n', '        emit event_open(_idx);\n', '    }\n', '    \n', '    // mint fortune\n', '    function fortune_setimgnme(uint _idx, bytes32[144] _imgarr, bytes32 _nme) \n', '        public idx_inrange(_idx) only_currowner(_idx) {\n', '        require(fortune_arr[_idx].opened, "fortune has to be opened");\n', '        require(!fortune_arr[_idx].has_img, "image cant be reset");\n', '        require(!fortune_arr[_idx].forsale, "fortune is selling");\n', '        fortune_arr[_idx].original_minter = fortune_arr[_idx].current_owner;\n', '        for(uint i = 0; i < 144; i++)\n', '            fortune_arr[_idx].img[i] = _imgarr[i];\n', '        fortune_arr[_idx].str_name = _nme;\n', '        emit event_mint(_idx);\n', '        fortune_arr[_idx].has_img = true;\n', '    }\n', '    \n', '    // start auction\n', '    function fortune_sell(uint _idx, uint basebid, uint endt) \n', '        public idx_inrange(_idx) only_currowner(_idx) {\n', '        require(_idx > 0, "I&#39;ll always be here with you.");\n', '        require(!fortune_arr[_idx].forsale, "already selling");\n', '        require(endt <= 7 days, "auction time too long");\n', '        fortune_arr[_idx].current_bid = basebid;\n', '        fortune_arr[_idx].auction_end = now + endt;\n', '        fortune_arr[_idx].forsale = true;\n', '        emit event_sale(_idx);\n', '    }\n', '    \n', '    // bid auction\n', '    function fortune_bid(uint _idx) public payable idx_inrange(_idx) {\n', '        require(fortune_arr[_idx].forsale, "fortune not for sale");\n', '        require(now < fortune_arr[_idx].auction_end, "auction ended");\n', '        require(msg.value > fortune_arr[_idx].current_bid, \n', '            "new bid has to be higher than current");\n', '\n', '        // return the previous bid        \n', '        if(fortune_arr[_idx].bid_cnt != 0) \n', '            pending_pay[fortune_arr[_idx].current_bidder] += \n', '                fortune_arr[_idx].current_bid;\n', '        \n', '        fortune_arr[_idx].current_bid = msg.value;\n', '        fortune_arr[_idx].current_bidder = msg.sender;\n', '        fortune_arr[_idx].bid_cnt += 1;\n', '        emit event_bids(_idx);\n', '    }\n', '    \n', '    // end auction\n', '    function fortune_endauction(uint _idx) public idx_inrange(_idx) {\n', '        require(now >= fortune_arr[_idx].auction_end,"auction is still going");\n', '        require(fortune_arr[_idx].forsale, "fortune not for sale");\n', '        \n', '        // sale\n', '        if(fortune_arr[_idx].bid_cnt > 0) {\n', '    \t\tuint ntax = fortune_arr[_idx].current_bid/tax;              // 2%\n', '    \t\tuint otax = fortune_arr[_idx].current_bid/tax;               // 2% \n', '    \t\tuint ftax = ntax;\n', '\n', '            pending_pay[owner] += ntax;\n', '    \t\tif(fortune_arr[_idx].opened) { \n', '    \t\t    ftax+= otax; \n', '    \t\t    pending_pay[fortune_arr[_idx].original_owner] += otax; \n', '    \t\t}                  \n', '    \t\tif(fortune_arr[_idx].has_img) { \n', '    \t\t    ftax+= otax; \n', '    \t\t    pending_pay[fortune_arr[_idx].original_minter] += otax; \n', '    \t\t}             \n', '    \t\tpending_pay[fortune_arr[_idx].current_owner] += \n', '                fortune_arr[_idx].current_bid-ftax; \n', '                \n', '            fortune_arr[_idx].current_owner = \n', '                fortune_arr[_idx].current_bidder;\n', '            emit event_sold(_idx, fortune_arr[_idx].current_owner);\n', '        }\n', '        \n', '        // reset bid\n', '        // current bid doesnt reset to save last sold price\n', '        fortune_arr[_idx].forsale = false;\n', '        fortune_arr[_idx].current_bidder = 0;\n', '        fortune_arr[_idx].bid_cnt = 0;\n', '        fortune_arr[_idx].auction_end = 0;\n', '    }\n', '    \n', '    \n', '    function withdraw() public {\n', '        require(pending_pay[msg.sender]>0, "insufficient funds");\n', '        uint _pay = pending_pay[msg.sender];\n', '        pending_pay[msg.sender] = 0;\n', '        msg.sender.transfer(_pay);\n', '        emit event_withdraw(msg.sender, _pay);\n', '    }\n', '    \n', '    function add_luck(bytes32 _nmsg) public payable {\n', '        require(msg.value >= unopened_bid, \n', '            "adding a fortune label costs the unopened_bid eth");\n', '        ur_luck.push(_nmsg);\n', '        pending_pay[owner] += msg.value;\n', '        emit event_addluck(msg.sender);\n', '    } \n', '    \n', '    function limitbreak_contrib() public payable {\n', '\t\tfortune_break_current += msg.value;\n', '\t\temit event_limitbreak_contrib(msg.sender, msg.value);\n', '\t}\n', '\t\n', '    function limitbreak_RELEASE() public {\n', '\t\trequire(fortune_break_current >= fortune_limitbreak, \n', '\t\t\t"limit breaking takes a few hits more");\n', '\t\trequire(fortune_arr.length >= max_fortunes, "limit not reached yet");\n', '        max_fortunes += max_fortunes + 500;\n', '\t\tpending_pay[owner]+= fortune_break_current;\n', '\t\tfortune_break_current = 0;\n', '\t\tif(fortune_limitbreak >= 128 ether) fortune_limitbreak = 32 ether;\n', '\t\telse fortune_limitbreak *= 2;\n', '\t\temit event_limitbreak(fortune_limitbreak);\n', '    }\n', '    \n', '    \n', '    function arand(address _addr, uint seed) internal view returns(uint) {\n', '        return uint\n', '            (keccak256\n', '                (abi.encodePacked(blockhash(block.number-1), seed, uint(_addr))));\n', '    }\n', '    \n', '    // erc20 semi \n', '    function totalSupply() public constant returns (uint) { return max_fortunes; }\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance)\n', '        { return pending_pay[tokenOwner]; }\n', '        \n', '    function giveTo(uint _idx, address _addr) public idx_inrange(_idx) only_currowner(_idx) {\n', '        fortune_arr[_idx].current_owner = _addr;\n', '    }\n', '    \n', '    \n', '    // events\n', '    event event_new(uint _idx);                                     //[x]\n', '    event event_open(uint _idx);                                    //[x]\n', '    event event_mint(uint _idx);                                    //[x]\n', '    event event_sale(uint _idx);                                    //[x]\n', '    event event_bids(uint _idx);                                    //[x]\n', '    event event_sold(uint _idx, address _newowner);                 //[x]\n', '    event event_addluck(address _addr);                             //[x]\n', '    event event_limitbreak(uint newlimit);                          //[x]\n', '    event event_limitbreak_contrib(address _addr, uint _ammount);   //[x]\n', '    event event_withdraw(address _addr, uint _ammount);             //[x]\n', '\n', '}']