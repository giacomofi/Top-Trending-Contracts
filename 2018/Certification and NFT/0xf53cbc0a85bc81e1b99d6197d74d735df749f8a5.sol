['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @dev Crowdsale interface for Etheal Normal Sale, functions needed from outside.\n', 'contract iEthealSale {\n', '    bool public paused;\n', '    uint256 public minContribution;\n', '    uint256 public whitelistThreshold;\n', '    mapping (address => uint256) public stakes;\n', '    function setPromoBonus(address _investor, uint256 _value) public;\n', '    function buyTokens(address _beneficiary) public payable;\n', '    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;\n', '    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;\n', '    function hasEnded() public constant returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title claim accidentally sent tokens\n', ' */\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    /// @notice This method can be used to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    /// @param _claimer Address that tokens will be send to\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title EthealWhitelist\n', ' * @author thesved\n', ' * @notice EthealWhitelist contract which handles KYC\n', ' */\n', 'contract EthealWhitelist is Ownable {\n', '    using ECRecovery for bytes32;\n', '\n', '    // signer address for offchain whitelist signing\n', '    address public signer;\n', '\n', '    // storing whitelisted addresses\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    event WhitelistSet(address indexed _address, bool _state);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '    function EthealWhitelist(address _signer) {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    /// @notice set signing address after deployment\n', '    function setSigner(address _signer) public onlyOwner {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    ////////////////\n', '    // Whitelisting: only owner\n', '    ////////////////\n', '\n', '    ///&#160;@notice Set whitelist state for an address.\n', '    function setWhitelist(address _addr, bool _state) public onlyOwner {\n', '        require(_addr != address(0));\n', '        isWhitelisted[_addr] = _state;\n', '        WhitelistSet(_addr, _state);\n', '    }\n', '\n', '    ///&#160;@notice Set whitelist state for multiple addresses\n', '    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\n', '        for (uint256 i = 0; i < _addr.length; i++) {\n', '            setWhitelist(_addr[i], _state);\n', '        }\n', '    }\n', '\n', '    /// @notice offchain whitelist check\n', '    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\n', '        bytes32 hash = keccak256("\\x19Ethereum Signed Message:\\n20",_addr);\n', '        return hash.recover(_sig) == signer;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title EthealDeposit\n', ' * @author thesved\n', ' * @dev This contract is used for storing funds while doing Whitelist\n', ' */\n', 'contract EthealDeposit is Ownable, HasNoTokens {\n', '    using SafeMath for uint256;\n', '\n', '    // storing deposits: make sure they fit in 2 x 32 byte\n', '    struct Deposit {\n', '        uint256 amount;         // 32 byte\n', '        address beneficiary;    // 20 byte\n', '        uint64 time;            // 8 byte\n', '        bool cleared;           // 1 bit\n', '    }\n', '    uint256 public transactionCount;\n', '    uint256 public pendingCount;\n', '    mapping (uint256 => Deposit) public transactions;    // store transactions\n', '    mapping (address => uint256[]) public addressTransactions;  // store transaction ids for addresses\n', '    \n', '    // sale contract to which we forward funds\n', '    iEthealSale public sale;\n', '    EthealWhitelist public whitelist;\n', '\n', '    event LogDeposited(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '    event LogRefunded(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '    event LogForwarded(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '\n', '    /// @notice Etheal deposit constructor\n', '    /// @param _sale address of sale contract\n', '    /// @param _whitelist address of whitelist contract\n', '    function EthealDeposit(address _sale, address _whitelist) {\n', '        require(_sale != address(0));\n', '        sale = iEthealSale(_sale);\n', '        whitelist = EthealWhitelist(_whitelist);\n', '    }\n', '\n', '    /// @notice Set sale contract address\n', '    function setSale(address _sale) public onlyOwner {\n', '        sale = iEthealSale(_sale);\n', '    }\n', '\n', '    /// @notice Set whitelist contract address\n', '    function setWhitelist(address _whitelist) public onlyOwner {\n', '        whitelist = EthealWhitelist(_whitelist);\n', '    }\n', '\n', '    /// @dev Override HasNoTokens#extractTokens to not be able to extract tokens until saleEnd and everyone got their funds back\n', '    function extractTokens(address _token, address _claimer) public onlyOwner saleEnded {\n', '        require(pendingCount == 0);\n', '\n', '        super.extractTokens(_token, _claimer);\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Deposit, forward, refund\n', '    ////////////////\n', '\n', '    modifier whitelistSet() {\n', '        require(address(whitelist) != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier saleNotEnded() {\n', '        require(address(sale) != address(0) && !sale.hasEnded());\n', '        _;\n', '    }\n', '\n', '    modifier saleNotPaused() {\n', '        require(address(sale) != address(0) && !sale.paused());\n', '        _;\n', '    }\n', '\n', '    modifier saleEnded() {\n', '        require(address(sale) != address(0) && sale.hasEnded());\n', '        _;\n', '    }\n', '\n', '    /// @notice payable fallback calls the deposit function\n', '    function() public payable {\n', '        deposit(msg.sender, "");\n', '    }\n', '\n', '    /// @notice depositing for investor, return transaction Id\n', '    /// @param _investor address of investor\n', '    /// @param _whitelistSign offchain whitelist signiture for address, optional\n', '    function deposit(address _investor, bytes _whitelistSign) public payable whitelistSet saleNotEnded returns (uint256) {\n', '        require(_investor != address(0));\n', '        require(msg.value > 0);\n', '        require(msg.value >= sale.minContribution());\n', '\n', '        uint256 transactionId = addTransaction(_investor, msg.value);\n', '\n', '        // forward transaction automatically if whitelist is okay, so the transaction doesnt revert\n', '        if (whitelist.isWhitelisted(_investor) \n', '            || whitelist.isOffchainWhitelisted(_investor, _whitelistSign) \n', '            || sale.whitelistThreshold() >= sale.stakes(_investor).add(msg.value)\n', '        ) {\n', '            // only forward if sale is not paused\n', '            if (!sale.paused()) {\n', '                forwardTransactionInternal(transactionId, _whitelistSign);\n', '            }\n', '        }\n', '\n', '        return transactionId;\n', '    }\n', '\n', '    /// @notice forwarding a transaction\n', '    function forwardTransaction(uint256 _id, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\n', '        require(forwardTransactionInternal(_id, _whitelistSign));\n', '    }\n', '\n', '    /// @notice forwarding multiple transactions: check whitelist\n', '    function forwardManyTransaction(uint256[] _ids) public whitelistSet saleNotEnded saleNotPaused {\n', '        uint256 _threshold = sale.whitelistThreshold();\n', '\n', '        for (uint256 i=0; i<_ids.length; i++) {\n', '            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\n', '            if ( whitelist.isWhitelisted(transactions[_ids[i]].beneficiary) \n', '                || _threshold >= sale.stakes(transactions[_ids[i]].beneficiary).add(transactions[_ids[i]].amount )\n', '            ) {\n', '                forwardTransactionInternal(_ids[i],"");\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice forwarding transactions for an investor\n', '    function forwardInvestorTransaction(address _investor, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\n', '        bool _whitelisted = whitelist.isWhitelisted(_investor) || whitelist.isOffchainWhitelisted(_investor, _whitelistSign);\n', '        uint256 _amount = sale.stakes(_investor);\n', '        uint256 _threshold = sale.whitelistThreshold();\n', '\n', '        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\n', '            _amount = _amount.add(transactions[ addressTransactions[_investor][i] ].amount);\n', '            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\n', '            if (_whitelisted || _threshold >= _amount) {\n', '                forwardTransactionInternal(addressTransactions[_investor][i], _whitelistSign);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice refunding a transaction\n', '    function refundTransaction(uint256 _id) public saleEnded {\n', '        require(refundTransactionInternal(_id));\n', '    }\n', '\n', '    /// @notice refunding multiple transactions\n', '    function refundManyTransaction(uint256[] _ids) public saleEnded {\n', '        for (uint256 i=0; i<_ids.length; i++) {\n', '            refundTransactionInternal(_ids[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice refunding an investor\n', '    function refundInvestor(address _investor) public saleEnded {\n', '        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\n', '            refundTransactionInternal(addressTransactions[_investor][i]);\n', '        }\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Internal functions\n', '    ////////////////\n', '\n', '    /// @notice add transaction and returns its id\n', '    function addTransaction(address _investor, uint256 _amount) internal returns (uint256) {\n', '        uint256 transactionId = transactionCount;\n', '\n', '        // save transaction\n', '        transactions[transactionId] = Deposit({\n', '            amount: _amount,\n', '            beneficiary: _investor,\n', '            time: uint64(now),\n', '            cleared : false\n', '        });\n', '\n', '        // save transactionId for investor address\n', '        addressTransactions[_investor].push(transactionId);\n', '\n', '        transactionCount = transactionCount.add(1);\n', '        pendingCount = pendingCount.add(1);\n', '        LogDeposited(_investor, _amount, transactionId);\n', '\n', '        return transactionId;\n', '    }\n', '\n', '    /// @notice Forwarding a transaction, internal function, doesn&#39;t check sale status for speed up mass actions.\n', '    /// @return whether forward was successful or not\n', '    function forwardTransactionInternal(uint256 _id, bytes memory _whitelistSign) internal returns (bool) {\n', '        require(_id < transactionCount);\n', '\n', '        // if already cleared then return false\n', '        if (transactions[_id].cleared) {\n', '            return false;\n', '        }\n', '\n', '        // fixing bytes data to argument call data: data -> {data position}{data length}data\n', '        bytes memory _whitelistCall = bytesToArgument(_whitelistSign, 96);\n', '\n', '        // forwarding transaction to sale contract\n', '        if (! sale.call.value(transactions[_id].amount)(bytes4(keccak256(&#39;depositEth(address,uint256,bytes)&#39;)), transactions[_id].beneficiary, uint256(transactions[_id].time), _whitelistCall) ) {\n', '            return false;\n', '        }\n', '        transactions[_id].cleared = true;\n', '\n', '        pendingCount = pendingCount.sub(1);\n', '        LogForwarded(transactions[_id].beneficiary, transactions[_id].amount, _id);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Fixing low level call for providing signature information: create proper padding for bytes information\n', '    function bytesToArgument(bytes memory _sign, uint256 _position) internal pure returns (bytes memory c) {\n', '        uint256 signLength = _sign.length;\n', '        uint256 totalLength = signLength.add(64);\n', '        uint256 loopMax = signLength.add(31).div(32);\n', '        assembly {\n', '            let m := mload(0x40)\n', '            mstore(m, totalLength)          // store the total length\n', '            mstore(add(m,32), _position)    // where does the data start\n', '            mstore(add(m,64), signLength)   // store the length of signature\n', '            for {  let i := 0 } lt(i, loopMax) { i := add(1, i) } { mstore(add(m, mul(32, add(3, i))), mload(add(_sign, mul(32, add(1, i))))) }\n', '            mstore(0x40, add(m, add(32, totalLength)))\n', '            c := m\n', '        }\n', '    }\n', '\n', '    /// @notice Send back non-cleared transactions after sale is over, not checking status for speeding up mass actions\n', '    function refundTransactionInternal(uint256 _id) internal returns (bool) {\n', '        require(_id < transactionCount);\n', '\n', '        // if already cleared then return false\n', '        if (transactions[_id].cleared) {\n', '            return false;\n', '        }\n', '\n', '        // sending back funds\n', '        transactions[_id].cleared = true;\n', '        transactions[_id].beneficiary.transfer(transactions[_id].amount);\n', '\n', '        pendingCount = pendingCount.sub(1);\n', '        LogRefunded(transactions[_id].beneficiary, transactions[_id].amount, _id);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // External functions\n', '    ////////////////\n', '\n', '    /// @notice gives back transaction ids based on filtering\n', '    function getTransactionIds(uint256 from, uint256 to, bool _cleared, bool _nonCleared) view external returns (uint256[] ids) {\n', '        uint256 i = 0;\n', '        uint256 results = 0;\n', '        uint256[] memory _ids = new uint256[](transactionCount);\n', '\n', '        // search in contributors\n', '        for (i = 0; i < transactionCount; i++) {\n', '            if (_cleared && transactions[i].cleared || _nonCleared && !transactions[i].cleared) {\n', '                _ids[results] = i;\n', '                results++;\n', '            }\n', '        }\n', '\n', '        ids = new uint256[](results);\n', '        for (i = from; i <= to && i < results; i++) {\n', '            ids[i] = _ids[i];\n', '        }\n', '\n', '        return ids;\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/// @dev Crowdsale interface for Etheal Normal Sale, functions needed from outside.\n', 'contract iEthealSale {\n', '    bool public paused;\n', '    uint256 public minContribution;\n', '    uint256 public whitelistThreshold;\n', '    mapping (address => uint256) public stakes;\n', '    function setPromoBonus(address _investor, uint256 _value) public;\n', '    function buyTokens(address _beneficiary) public payable;\n', '    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;\n', '    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;\n', '    function hasEnded() public constant returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title claim accidentally sent tokens\n', ' */\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    /// @notice This method can be used to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    /// @param _claimer Address that tokens will be send to\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title EthealWhitelist\n', ' * @author thesved\n', ' * @notice EthealWhitelist contract which handles KYC\n', ' */\n', 'contract EthealWhitelist is Ownable {\n', '    using ECRecovery for bytes32;\n', '\n', '    // signer address for offchain whitelist signing\n', '    address public signer;\n', '\n', '    // storing whitelisted addresses\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    event WhitelistSet(address indexed _address, bool _state);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '    function EthealWhitelist(address _signer) {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    /// @notice set signing address after deployment\n', '    function setSigner(address _signer) public onlyOwner {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    ////////////////\n', '    // Whitelisting: only owner\n', '    ////////////////\n', '\n', '    ///\xa0@notice Set whitelist state for an address.\n', '    function setWhitelist(address _addr, bool _state) public onlyOwner {\n', '        require(_addr != address(0));\n', '        isWhitelisted[_addr] = _state;\n', '        WhitelistSet(_addr, _state);\n', '    }\n', '\n', '    ///\xa0@notice Set whitelist state for multiple addresses\n', '    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\n', '        for (uint256 i = 0; i < _addr.length; i++) {\n', '            setWhitelist(_addr[i], _state);\n', '        }\n', '    }\n', '\n', '    /// @notice offchain whitelist check\n', '    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\n', '        bytes32 hash = keccak256("\\x19Ethereum Signed Message:\\n20",_addr);\n', '        return hash.recover(_sig) == signer;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title EthealDeposit\n', ' * @author thesved\n', ' * @dev This contract is used for storing funds while doing Whitelist\n', ' */\n', 'contract EthealDeposit is Ownable, HasNoTokens {\n', '    using SafeMath for uint256;\n', '\n', '    // storing deposits: make sure they fit in 2 x 32 byte\n', '    struct Deposit {\n', '        uint256 amount;         // 32 byte\n', '        address beneficiary;    // 20 byte\n', '        uint64 time;            // 8 byte\n', '        bool cleared;           // 1 bit\n', '    }\n', '    uint256 public transactionCount;\n', '    uint256 public pendingCount;\n', '    mapping (uint256 => Deposit) public transactions;    // store transactions\n', '    mapping (address => uint256[]) public addressTransactions;  // store transaction ids for addresses\n', '    \n', '    // sale contract to which we forward funds\n', '    iEthealSale public sale;\n', '    EthealWhitelist public whitelist;\n', '\n', '    event LogDeposited(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '    event LogRefunded(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '    event LogForwarded(address indexed beneficiary, uint256 weiAmount, uint256 id);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '\n', '    /// @notice Etheal deposit constructor\n', '    /// @param _sale address of sale contract\n', '    /// @param _whitelist address of whitelist contract\n', '    function EthealDeposit(address _sale, address _whitelist) {\n', '        require(_sale != address(0));\n', '        sale = iEthealSale(_sale);\n', '        whitelist = EthealWhitelist(_whitelist);\n', '    }\n', '\n', '    /// @notice Set sale contract address\n', '    function setSale(address _sale) public onlyOwner {\n', '        sale = iEthealSale(_sale);\n', '    }\n', '\n', '    /// @notice Set whitelist contract address\n', '    function setWhitelist(address _whitelist) public onlyOwner {\n', '        whitelist = EthealWhitelist(_whitelist);\n', '    }\n', '\n', '    /// @dev Override HasNoTokens#extractTokens to not be able to extract tokens until saleEnd and everyone got their funds back\n', '    function extractTokens(address _token, address _claimer) public onlyOwner saleEnded {\n', '        require(pendingCount == 0);\n', '\n', '        super.extractTokens(_token, _claimer);\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Deposit, forward, refund\n', '    ////////////////\n', '\n', '    modifier whitelistSet() {\n', '        require(address(whitelist) != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier saleNotEnded() {\n', '        require(address(sale) != address(0) && !sale.hasEnded());\n', '        _;\n', '    }\n', '\n', '    modifier saleNotPaused() {\n', '        require(address(sale) != address(0) && !sale.paused());\n', '        _;\n', '    }\n', '\n', '    modifier saleEnded() {\n', '        require(address(sale) != address(0) && sale.hasEnded());\n', '        _;\n', '    }\n', '\n', '    /// @notice payable fallback calls the deposit function\n', '    function() public payable {\n', '        deposit(msg.sender, "");\n', '    }\n', '\n', '    /// @notice depositing for investor, return transaction Id\n', '    /// @param _investor address of investor\n', '    /// @param _whitelistSign offchain whitelist signiture for address, optional\n', '    function deposit(address _investor, bytes _whitelistSign) public payable whitelistSet saleNotEnded returns (uint256) {\n', '        require(_investor != address(0));\n', '        require(msg.value > 0);\n', '        require(msg.value >= sale.minContribution());\n', '\n', '        uint256 transactionId = addTransaction(_investor, msg.value);\n', '\n', '        // forward transaction automatically if whitelist is okay, so the transaction doesnt revert\n', '        if (whitelist.isWhitelisted(_investor) \n', '            || whitelist.isOffchainWhitelisted(_investor, _whitelistSign) \n', '            || sale.whitelistThreshold() >= sale.stakes(_investor).add(msg.value)\n', '        ) {\n', '            // only forward if sale is not paused\n', '            if (!sale.paused()) {\n', '                forwardTransactionInternal(transactionId, _whitelistSign);\n', '            }\n', '        }\n', '\n', '        return transactionId;\n', '    }\n', '\n', '    /// @notice forwarding a transaction\n', '    function forwardTransaction(uint256 _id, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\n', '        require(forwardTransactionInternal(_id, _whitelistSign));\n', '    }\n', '\n', '    /// @notice forwarding multiple transactions: check whitelist\n', '    function forwardManyTransaction(uint256[] _ids) public whitelistSet saleNotEnded saleNotPaused {\n', '        uint256 _threshold = sale.whitelistThreshold();\n', '\n', '        for (uint256 i=0; i<_ids.length; i++) {\n', '            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\n', '            if ( whitelist.isWhitelisted(transactions[_ids[i]].beneficiary) \n', '                || _threshold >= sale.stakes(transactions[_ids[i]].beneficiary).add(transactions[_ids[i]].amount )\n', '            ) {\n', '                forwardTransactionInternal(_ids[i],"");\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice forwarding transactions for an investor\n', '    function forwardInvestorTransaction(address _investor, bytes _whitelistSign) public whitelistSet saleNotEnded saleNotPaused {\n', '        bool _whitelisted = whitelist.isWhitelisted(_investor) || whitelist.isOffchainWhitelisted(_investor, _whitelistSign);\n', '        uint256 _amount = sale.stakes(_investor);\n', '        uint256 _threshold = sale.whitelistThreshold();\n', '\n', '        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\n', '            _amount = _amount.add(transactions[ addressTransactions[_investor][i] ].amount);\n', '            // only forward if it is within threshold or whitelisted, so the transaction doesnt revert\n', '            if (_whitelisted || _threshold >= _amount) {\n', '                forwardTransactionInternal(addressTransactions[_investor][i], _whitelistSign);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice refunding a transaction\n', '    function refundTransaction(uint256 _id) public saleEnded {\n', '        require(refundTransactionInternal(_id));\n', '    }\n', '\n', '    /// @notice refunding multiple transactions\n', '    function refundManyTransaction(uint256[] _ids) public saleEnded {\n', '        for (uint256 i=0; i<_ids.length; i++) {\n', '            refundTransactionInternal(_ids[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice refunding an investor\n', '    function refundInvestor(address _investor) public saleEnded {\n', '        for (uint256 i=0; i<addressTransactions[_investor].length; i++) {\n', '            refundTransactionInternal(addressTransactions[_investor][i]);\n', '        }\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Internal functions\n', '    ////////////////\n', '\n', '    /// @notice add transaction and returns its id\n', '    function addTransaction(address _investor, uint256 _amount) internal returns (uint256) {\n', '        uint256 transactionId = transactionCount;\n', '\n', '        // save transaction\n', '        transactions[transactionId] = Deposit({\n', '            amount: _amount,\n', '            beneficiary: _investor,\n', '            time: uint64(now),\n', '            cleared : false\n', '        });\n', '\n', '        // save transactionId for investor address\n', '        addressTransactions[_investor].push(transactionId);\n', '\n', '        transactionCount = transactionCount.add(1);\n', '        pendingCount = pendingCount.add(1);\n', '        LogDeposited(_investor, _amount, transactionId);\n', '\n', '        return transactionId;\n', '    }\n', '\n', "    /// @notice Forwarding a transaction, internal function, doesn't check sale status for speed up mass actions.\n", '    /// @return whether forward was successful or not\n', '    function forwardTransactionInternal(uint256 _id, bytes memory _whitelistSign) internal returns (bool) {\n', '        require(_id < transactionCount);\n', '\n', '        // if already cleared then return false\n', '        if (transactions[_id].cleared) {\n', '            return false;\n', '        }\n', '\n', '        // fixing bytes data to argument call data: data -> {data position}{data length}data\n', '        bytes memory _whitelistCall = bytesToArgument(_whitelistSign, 96);\n', '\n', '        // forwarding transaction to sale contract\n', "        if (! sale.call.value(transactions[_id].amount)(bytes4(keccak256('depositEth(address,uint256,bytes)')), transactions[_id].beneficiary, uint256(transactions[_id].time), _whitelistCall) ) {\n", '            return false;\n', '        }\n', '        transactions[_id].cleared = true;\n', '\n', '        pendingCount = pendingCount.sub(1);\n', '        LogForwarded(transactions[_id].beneficiary, transactions[_id].amount, _id);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Fixing low level call for providing signature information: create proper padding for bytes information\n', '    function bytesToArgument(bytes memory _sign, uint256 _position) internal pure returns (bytes memory c) {\n', '        uint256 signLength = _sign.length;\n', '        uint256 totalLength = signLength.add(64);\n', '        uint256 loopMax = signLength.add(31).div(32);\n', '        assembly {\n', '            let m := mload(0x40)\n', '            mstore(m, totalLength)          // store the total length\n', '            mstore(add(m,32), _position)    // where does the data start\n', '            mstore(add(m,64), signLength)   // store the length of signature\n', '            for {  let i := 0 } lt(i, loopMax) { i := add(1, i) } { mstore(add(m, mul(32, add(3, i))), mload(add(_sign, mul(32, add(1, i))))) }\n', '            mstore(0x40, add(m, add(32, totalLength)))\n', '            c := m\n', '        }\n', '    }\n', '\n', '    /// @notice Send back non-cleared transactions after sale is over, not checking status for speeding up mass actions\n', '    function refundTransactionInternal(uint256 _id) internal returns (bool) {\n', '        require(_id < transactionCount);\n', '\n', '        // if already cleared then return false\n', '        if (transactions[_id].cleared) {\n', '            return false;\n', '        }\n', '\n', '        // sending back funds\n', '        transactions[_id].cleared = true;\n', '        transactions[_id].beneficiary.transfer(transactions[_id].amount);\n', '\n', '        pendingCount = pendingCount.sub(1);\n', '        LogRefunded(transactions[_id].beneficiary, transactions[_id].amount, _id);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // External functions\n', '    ////////////////\n', '\n', '    /// @notice gives back transaction ids based on filtering\n', '    function getTransactionIds(uint256 from, uint256 to, bool _cleared, bool _nonCleared) view external returns (uint256[] ids) {\n', '        uint256 i = 0;\n', '        uint256 results = 0;\n', '        uint256[] memory _ids = new uint256[](transactionCount);\n', '\n', '        // search in contributors\n', '        for (i = 0; i < transactionCount; i++) {\n', '            if (_cleared && transactions[i].cleared || _nonCleared && !transactions[i].cleared) {\n', '                _ids[results] = i;\n', '                results++;\n', '            }\n', '        }\n', '\n', '        ids = new uint256[](results);\n', '        for (i = from; i <= to && i < results; i++) {\n', '            ids[i] = _ids[i];\n', '        }\n', '\n', '        return ids;\n', '    }\n', '}']
