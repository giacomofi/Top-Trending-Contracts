['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', ' // Pause functionality taken from OpenZeppelin. License below.\n', ' /* The MIT License (MIT)\n', ' Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' Permission is hereby granted, free of charge, to any person obtaining\n', ' a copy of this software and associated documentation files (the\n', ' "Software"), to deal in the Software without restriction, including\n', ' without limitation the rights to use, copy, modify, merge, publish,\n', ' distribute, sublicense, and/or sell copies of the Software, and to\n', ' permit persons to whom the Software is furnished to do so, subject to\n', ' the following conditions: */\n', '\n', ' /**\n', '  * @title Pausable\n', '  * @dev Base contract which allows children to implement an emergency stop mechanism.\n', '  */\n', 'contract Pausable is Ownable {\n', '\n', '  event SetPaused(bool paused);\n', '\n', '  // starts unpaused\n', '  bool public paused = false;\n', '\n', '  /* @dev modifier to allow actions only when the contract IS paused */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /* @dev modifier to allow actions only when the contract IS NOT paused */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract EtherbotsPrivileges is Pausable {\n', '  event ContractUpgrade(address newContract);\n', '\n', '}\n', '\n', '\n', '\n', '// This contract implements both the original ERC-721 standard and\n', '// the proposed &#39;deed&#39; standard of 841\n', '// I don&#39;t know which standard will eventually be adopted - support both for now\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Deed Standard\n', '/// @author William Entriken (https://phor.net), et. al.\n', '/// @dev Specification at https://github.com/ethereum/eips/841\n', '/// can read the comments there\n', 'contract ERC721 {\n', '\n', '    // COMPLIANCE WITH ERC-165 (DRAFT)\n', '\n', '    /// @dev ERC-165 (draft) interface signature for itself\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC165 =\n', '        bytes4(keccak256("supportsInterface(bytes4)"));\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721 =\n', '         bytes4(keccak256("ownerOf(uint256)")) ^\n', '         bytes4(keccak256("countOfDeeds()")) ^\n', '         bytes4(keccak256("countOfDeedsByOwner(address)")) ^\n', '         bytes4(keccak256("deedOfOwnerByIndex(address,uint256)")) ^\n', '         bytes4(keccak256("approve(address,uint256)")) ^\n', '         bytes4(keccak256("takeOwnership(uint256)"));\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\n', '\n', '    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\n', '\n', '    function ownerOf(uint256 _deedId) public view returns (address _owner);\n', '    function countOfDeeds() external view returns (uint256 _count);\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\n', '\n', '    // TRANSFER MECHANISM //////////////////////////////////////////////////////\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed deedId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);\n', '\n', '    function approve(address _to, uint256 _deedId) external payable;\n', '    function takeOwnership(uint256 _deedId) external payable;\n', '}\n', '\n', '/// @title Metadata extension to ERC-721 interface\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Specification at https://github.com/ethereum/eips/issues/XXXX\n', 'contract ERC721Metadata is ERC721 {\n', '\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata =\n', '        bytes4(keccak256("name()")) ^\n', '        bytes4(keccak256("symbol()")) ^\n', '        bytes4(keccak256("deedUri(uint256)"));\n', '\n', '    function name() public pure returns (string n);\n', '    function symbol() public pure returns (string s);\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _uri);\n', '}\n', '\n', '/// @title Enumeration extension to ERC-721 interface\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Specification at https://github.com/ethereum/eips/issues/XXXX\n', 'contract ERC721Enumerable is ERC721Metadata {\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Enumerable =\n', '        bytes4(keccak256("deedByIndex()")) ^\n', '        bytes4(keccak256("countOfOwners()")) ^\n', '        bytes4(keccak256("ownerByIndex(uint256)"));\n', '\n', '    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);\n', '    function countOfOwners() external view returns (uint256 _count);\n', '    function ownerByIndex(uint256 _index) external view returns (address _owner);\n', '}\n', '\n', 'contract ERC721Original {\n', '\n', '    bytes4 constant INTERFACE_SIGNATURE_ERC721Original =\n', '        bytes4(keccak256("totalSupply()")) ^\n', '        bytes4(keccak256("balanceOf(address)")) ^\n', '        bytes4(keccak256("ownerOf(uint256)")) ^\n', '        bytes4(keccak256("approve(address,uint256)")) ^\n', '        bytes4(keccak256("takeOwnership(uint256)")) ^\n', '        bytes4(keccak256("transfer(address,uint256)"));\n', '\n', '    // Core functions\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) external payable;\n', '    function transferFrom(address _from, address _to, uint _tokenId) public;\n', '    function transfer(address _to, uint _tokenId) public payable;\n', '\n', '    // Optional functions\n', '    function name() public pure returns (string _name);\n', '    function symbol() public pure returns (string _symbol);\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId);\n', '    function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '\n', '    // Events\n', '    // event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    // event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '}\n', '\n', 'contract ERC721AllImplementations is ERC721Original, ERC721Enumerable {\n', '\n', '}\n', '\n', 'contract EtherbotsBase is EtherbotsPrivileges {\n', '\n', '\n', '    function EtherbotsBase() public {\n', '    //   scrapyard = address(this);\n', '    }\n', '    /*** EVENTS ***/\n', '\n', '    ///  Forge fires when a new part is created - 4 times when a crate is opened,\n', '    /// and once when a battle takes place. Also has fires when\n', '    /// parts are combined in the furnace.\n', '    event Forge(address owner, uint256 partID, Part part);\n', '\n', '    ///  Transfer event as defined in ERC721.\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    /*** DATA TYPES ***/\n', '    ///  The main struct representation of a robot part. Each robot in Etherbots is represented by four copies\n', '    ///  of this structure, one for each of the four parts comprising it:\n', '    /// 1. Right Arm (Melee),\n', '    /// 2. Left Arm (Defence),\n', '    /// 3. Head (Turret),\n', '    /// 4. Body.\n', '    // store token id on this?\n', '     struct Part {\n', '        uint32 tokenId;\n', '        uint8 partType;\n', '        uint8 partSubType;\n', '        uint8 rarity;\n', '        uint8 element;\n', '        uint32 battlesLastDay;\n', '        uint32 experience;\n', '        uint32 forgeTime;\n', '        uint32 battlesLastReset;\n', '    }\n', '\n', '    // Part type - can be shared with other part factories.\n', '    uint8 constant DEFENCE = 1;\n', '    uint8 constant MELEE = 2;\n', '    uint8 constant BODY = 3;\n', '    uint8 constant TURRET = 4;\n', '\n', '    // Rarity - can be shared with other part factories.\n', '    uint8 constant STANDARD = 1;\n', '    uint8 constant SHADOW = 2;\n', '    uint8 constant GOLD = 3;\n', '\n', '\n', '    // Store a user struct\n', '    // in order to keep track of experience and perk choices.\n', '    // This perk tree is a binary tree, efficiently encodable as an array.\n', '    // 0 reflects no perk selected. 1 is first choice. 2 is second. 3 is both.\n', '    // Each choice costs experience (deducted from user struct).\n', '\n', '    /*** ~~~~~ROBOT PERKS~~~~~ ***/\n', '    // PERK 1: ATTACK vs DEFENCE PERK CHOICE.\n', '    // Choose\n', '    // PERK TWO ATTACK/ SHOOT, or DEFEND/DODGE\n', '    // PERK 2: MECH vs ELEMENTAL PERK CHOICE ---\n', '    // Choose steel and electric (Mech path), or water and fire (Elemetal path)\n', '    // (... will the mechs win the war for Ethertopia? or will the androids\n', '    // be deluged in flood and fire? ...)\n', '    // PERK 3: Commit to a specific elemental pathway:\n', '    // 1. the path of steel: the iron sword; the burning frying pan!\n', '    // 2. the path of electricity: the deadly taser, the fearsome forcefield\n', '    // 3. the path of water: high pressure water blasters have never been so cool\n', '    // 4. the path of fire!: we will hunt you down, Aang...\n', '\n', '\n', '    struct User {\n', '        // address userAddress;\n', '        uint32 numShards; //limit shards to upper bound eg 10000\n', '        uint32 experience;\n', '        uint8[32] perks;\n', '    }\n', '\n', '    //Maintain an array of all users.\n', '    // User[] public users;\n', '\n', '    // Store a map of the address to a uint representing index of User within users\n', '    // we check if a user exists at multiple points, every time they acquire\n', '    // via a crate or the market. Users can also manually register their address.\n', '    mapping ( address => User ) public addressToUser;\n', '\n', '    // Array containing the structs of all parts in existence. The ID\n', '    // of each part is an index into this array.\n', '    Part[] parts;\n', '\n', '    // Mapping from part IDs to to owning address. Should always exist.\n', '    mapping (uint256 => address) public partIndexToOwner;\n', '\n', '    //  A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count. REMOVE?\n', '    mapping (address => uint256) addressToTokensOwned;\n', '\n', '    // Mapping from Part ID to an address approved to call transferFrom().\n', '    // maximum of one approved address for transfer at any time.\n', '    mapping (uint256 => address) public partIndexToApproved;\n', '\n', '    address auction;\n', '    // address scrapyard;\n', '\n', '    // Array to store approved battle contracts.\n', '    // Can only ever be added to, not removed from.\n', '    // Once a ruleset is published, you will ALWAYS be able to use that contract\n', '    address[] approvedBattles;\n', '\n', '\n', '    function getUserByAddress(address _user) public view returns (uint32, uint8[32]) {\n', '        return (addressToUser[_user].experience, addressToUser[_user].perks);\n', '    }\n', '\n', '    //  Transfer a part to an address\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        // No cap on number of parts\n', '        // Very unlikely to ever be 2^256 parts owned by one account\n', '        // Shouldn&#39;t waste gas checking for overflow\n', '        // no point making it less than a uint --> mappings don&#39;t pack\n', '        addressToTokensOwned[_to]++;\n', '        // transfer ownership\n', '        partIndexToOwner[_tokenId] = _to;\n', '        // New parts are transferred _from 0x0, but we can&#39;t account that address.\n', '        if (_from != address(0)) {\n', '            addressToTokensOwned[_from]--;\n', '            // clear any previously approved ownership exchange\n', '            delete partIndexToApproved[_tokenId];\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function getPartById(uint _id) external view returns (\n', '        uint32 tokenId,\n', '        uint8 partType,\n', '        uint8 partSubType,\n', '        uint8 rarity,\n', '        uint8 element,\n', '        uint32 battlesLastDay,\n', '        uint32 experience,\n', '        uint32 forgeTime,\n', '        uint32 battlesLastReset\n', '    ) {\n', '        Part memory p = parts[_id];\n', '        return (p.tokenId, p.partType, p.partSubType, p.rarity, p.element, p.battlesLastDay, p.experience, p.forgeTime, p.battlesLastReset);\n', '    }\n', '\n', '\n', '    function substring(string str, uint startIndex, uint endIndex) internal pure returns (string) {\n', '        bytes memory strBytes = bytes(str);\n', '        bytes memory result = new bytes(endIndex-startIndex);\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            result[i-startIndex] = strBytes[i];\n', '        }\n', '        return string(result);\n', '    }\n', '\n', '    // helper functions adapted from  Jossie Calderon on stackexchange\n', '    function stringToUint32(string s) internal pure returns (uint32) {\n', '        bytes memory b = bytes(s);\n', '        uint result = 0;\n', '        for (uint i = 0; i < b.length; i++) { // c = b[i] was not needed\n', '            if (b[i] >= 48 && b[i] <= 57) {\n', '                result = result * 10 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\n', '            }\n', '        }\n', '        return uint32(result);\n', '    }\n', '\n', '    function stringToUint8(string s) internal pure returns (uint8) {\n', '        return uint8(stringToUint32(s));\n', '    }\n', '\n', '    function uintToString(uint v) internal pure returns (string) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i); // i + 1 is inefficient\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n', '        }\n', '        string memory str = string(s);\n', '        return str;\n', '    }\n', '}\n', 'contract EtherbotsNFT is EtherbotsBase, ERC721Enumerable, ERC721Original {\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '        return (_interfaceID == ERC721Original.INTERFACE_SIGNATURE_ERC721Original) ||\n', '            (_interfaceID == ERC721.INTERFACE_SIGNATURE_ERC721) ||\n', '            (_interfaceID == ERC721Metadata.INTERFACE_SIGNATURE_ERC721Metadata) ||\n', '            (_interfaceID == ERC721Enumerable.INTERFACE_SIGNATURE_ERC721Enumerable);\n', '    }\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function name() public pure returns (string _name) {\n', '      return "Etherbots";\n', '    }\n', '\n', '    function symbol() public pure returns (string _smbol) {\n', '      return "ETHBOT";\n', '    }\n', '\n', '    // total supply of parts --> as no parts are ever deleted, this is simply\n', '    // the total supply of parts ever created\n', '    function totalSupply() public view returns (uint) {\n', '        return parts.length;\n', '    }\n', '\n', '    /// @notice Returns the total number of deeds currently in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function countOfDeeds() external view returns (uint256) {\n', '        return parts.length;\n', '    }\n', '\n', '    //--/ internal function    which checks whether the token with id (_tokenId)\n', '    /// is owned by the (_claimant) address\n', '    function owns(address _owner, uint256 _tokenId) public view returns (bool) {\n', '        return (partIndexToOwner[_tokenId] == _owner);\n', '    }\n', '\n', '    /// internal function    which checks whether the token with id (_tokenId)\n', '    /// is owned by the (_claimant) address\n', '    function ownsAll(address _owner, uint256[] _tokenIds) public view returns (bool) {\n', '        require(_tokenIds.length > 0);\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            if (partIndexToOwner[_tokenIds[i]] != _owner) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        partIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    function _approvedFor(address _newOwner, uint256 _tokenId) internal view returns (bool) {\n', '        return (partIndexToApproved[_tokenId] == _newOwner);\n', '    }\n', '\n', '    function ownerByIndex(uint256 _index) external view returns (address _owner){\n', '        return partIndexToOwner[_index];\n', '    }\n', '\n', '    // returns the NUMBER of tokens owned by (_owner)\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return addressToTokensOwned[_owner];\n', '    }\n', '\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256) {\n', '        return balanceOf(_owner);\n', '    }\n', '\n', '    // transfers a part to another account\n', '    function transfer(address _to, uint256 _tokenId) public whenNotPaused payable {\n', '        // payable for ERC721 --> don&#39;t actually send eth @<span class="__cf_email__" data-cfemail="663926">[email&#160;protected]</span>\n', '        require(msg.value == 0);\n', '\n', '        // Safety checks to prevent accidental transfers to common accounts\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        // can&#39;t transfer parts to the auction contract directly\n', '        require(_to != address(auction));\n', '        // can&#39;t transfer parts to any of the battle contracts directly\n', '        for (uint j = 0; j < approvedBattles.length; j++) {\n', '            require(_to != approvedBattles[j]);\n', '        }\n', '\n', '        // Cannot send tokens you don&#39;t own\n', '        require(owns(msg.sender, _tokenId));\n', '\n', '        // perform state changes necessary for transfer\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    // transfers a part to another account\n', '\n', '    function transferAll(address _to, uint256[] _tokenIds) public whenNotPaused payable {\n', '        require(msg.value == 0);\n', '\n', '        // Safety checks to prevent accidental transfers to common accounts\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        // can&#39;t transfer parts to the auction contract directly\n', '        require(_to != address(auction));\n', '        // can&#39;t transfer parts to any of the battle contracts directly\n', '        for (uint j = 0; j < approvedBattles.length; j++) {\n', '            require(_to != approvedBattles[j]);\n', '        }\n', '\n', '        // Cannot send tokens you don&#39;t own\n', '        require(ownsAll(msg.sender, _tokenIds));\n', '\n', '        for (uint k = 0; k < _tokenIds.length; k++) {\n', '            // perform state changes necessary for transfer\n', '            _transfer(msg.sender, _to, _tokenIds[k]);\n', '        }\n', '\n', '\n', '    }\n', '\n', '\n', '    // approves the (_to) address to use the transferFrom function on the token with id (_tokenId)\n', '    // if you want to clear all approvals, simply pass the zero address\n', '    function approve(address _to, uint256 _deedId) external whenNotPaused payable {\n', '        // payable for ERC721 --> don&#39;t actually send eth @<span class="__cf_email__" data-cfemail="d58a95">[email&#160;protected]</span>\n', '        require(msg.value == 0);\n', '// use internal function?\n', '        // Cannot approve the transfer of tokens you don&#39;t own\n', '        require(owns(msg.sender, _deedId));\n', '\n', '        // Store the approval (can only approve one at a time)\n', '        partIndexToApproved[_deedId] = _to;\n', '\n', '        Approval(msg.sender, _to, _deedId);\n', '    }\n', '\n', '    // approves many token ids\n', '    function approveMany(address _to, uint256[] _tokenIds) external whenNotPaused payable {\n', '\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            uint _tokenId = _tokenIds[i];\n', '\n', '            // Cannot approve the transfer of tokens you don&#39;t own\n', '            require(owns(msg.sender, _tokenId));\n', '\n', '            // Store the approval (can only approve one at a time)\n', '            partIndexToApproved[_tokenId] = _to;\n', '            //create event for each approval? _tokenId guaranteed to hold correct value?\n', '            Approval(msg.sender, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    // transfer the part with id (_tokenId) from (_from) to (_to)\n', '    // (_to) must already be approved for this (_tokenId)\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '\n', '        // Safety checks to prevent accidents\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '\n', '        // sender must be approved\n', '        require(partIndexToApproved[_tokenId] == msg.sender);\n', '        // from must currently own the token\n', '        require(owns(_from, _tokenId));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    // returns the current owner of the token with id = _tokenId\n', '    function ownerOf(uint256 _deedId) public view returns (address _owner) {\n', '        _owner = partIndexToOwner[_deedId];\n', '        // must result false if index key not found\n', '        require(_owner != address(0));\n', '    }\n', '\n', '    // returns a dynamic array of the ids of all tokens which are owned by (_owner)\n', '    // Looping through every possible part and checking it against the owner is\n', '    // actually much more efficient than storing a mapping or something, because\n', '    // it won&#39;t be executed as a transaction\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 totalParts = totalSupply();\n', '\n', '        return tokensOfOwnerWithinRange(_owner, 0, totalParts);\n', '  \n', '    }\n', '\n', '    function tokensOfOwnerWithinRange(address _owner, uint _start, uint _numToSearch) public view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint256[] memory tmpResult = new uint256[](tokenCount);\n', '        if (tokenCount == 0) {\n', '            return tmpResult;\n', '        }\n', '\n', '        uint256 resultIndex = 0;\n', '        for (uint partId = _start; partId < _start + _numToSearch; partId++) {\n', '            if (partIndexToOwner[partId] == _owner) {\n', '                tmpResult[resultIndex] = partId;\n', '                resultIndex++;\n', '                if (resultIndex == tokenCount) { //found all tokens accounted for, no need to continue\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        // copy number of tokens found in given range\n', '        uint resultLength = resultIndex;\n', '        uint256[] memory result = new uint256[](resultLength);\n', '        for (uint i=0; i<resultLength; i++) {\n', '            result[i] = tmpResult[i];\n', '        }\n', '        return result;\n', '    }\n', '\n', '\n', '\n', '    //same issues as above\n', '    // Returns an array of all part structs owned by the user. Free to call.\n', '    function getPartsOfOwner(address _owner) external view returns(bytes24[]) {\n', '        uint256 totalParts = totalSupply();\n', '\n', '        return getPartsOfOwnerWithinRange(_owner, 0, totalParts);\n', '    }\n', '    \n', '    // This is public so it can be called by getPartsOfOwner. It should NOT be called by another contract\n', '    // as it is very gas hungry.\n', '    function getPartsOfOwnerWithinRange(address _owner, uint _start, uint _numToSearch) public view returns(bytes24[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint resultIndex = 0;\n', '        bytes24[] memory result = new bytes24[](tokenCount);\n', '        for (uint partId = _start; partId < _start + _numToSearch; partId++) {\n', '            if (partIndexToOwner[partId] == _owner) {\n', '                result[resultIndex] = _partToBytes(parts[partId]);\n', '                resultIndex++;\n', '            }\n', '        }\n', '        return result; // will have 0 elements if tokenCount == 0\n', '    }\n', '\n', '\n', '    function _partToBytes(Part p) internal pure returns (bytes24 b) {\n', '        b = bytes24(p.tokenId);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.partType);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.partSubType);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.rarity);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.element);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.battlesLastDay);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.experience);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.forgeTime);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.battlesLastReset);\n', '    }\n', '\n', '    uint32 constant FIRST_LEVEL = 1000;\n', '    uint32 constant INCREMENT = 1000;\n', '\n', '    // every level, you need 1000 more exp to go up a level\n', '    function getLevel(uint32 _exp) public pure returns(uint32) {\n', '        uint32 c = 0;\n', '        for (uint32 i = FIRST_LEVEL; i <= FIRST_LEVEL + _exp; i += c * INCREMENT) {\n', '            c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    string metadataBase = "https://api.etherbots.io/api/";\n', '\n', '\n', '    function setMetadataBase(string _base) external onlyOwner {\n', '        metadataBase = _base;\n', '    }\n', '\n', '    // part type, subtype,\n', '    // have one internal function which lets us implement the divergent interfaces\n', '    function _metadata(uint256 _id) internal view returns(string) {\n', '        Part memory p = parts[_id];\n', '        return strConcat(strConcat(\n', '            metadataBase,\n', '            uintToString(uint(p.partType)),\n', '            "/",\n', '            uintToString(uint(p.partSubType)),\n', '            "/"\n', '        ), uintToString(uint(p.rarity)), "", "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _uri){\n', '        return _metadata(_deedId);\n', '    }\n', '\n', '    /// returns a metadata URI\n', '    function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl) {\n', '        return _metadata(_tokenId);\n', '    }\n', '\n', '    function takeOwnership(uint256 _deedId) external payable {\n', '        // payable for ERC721 --> don&#39;t actually send eth @<span class="__cf_email__" data-cfemail="b0eff0">[email&#160;protected]</span>\n', '        require(msg.value == 0);\n', '\n', '        address _from = partIndexToOwner[_deedId];\n', '\n', '        require(_approvedFor(msg.sender, _deedId));\n', '\n', '        _transfer(_from, msg.sender, _deedId);\n', '    }\n', '\n', '    // parts are stored sequentially\n', '    function deedByIndex(uint256 _index) external view returns (uint256 _deedId){\n', '        return _index;\n', '    }\n', '\n', '    function countOfOwners() external view returns (uint256 _count){\n', '        // TODO: implement this\n', '        return 0;\n', '    }\n', '\n', '// thirsty function\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId){\n', '        return _tokenOfOwnerByIndex(_owner, _index);\n', '    }\n', '\n', '// code duplicated\n', '    function _tokenOfOwnerByIndex(address _owner, uint _index) private view returns (uint _tokenId){\n', '        // The index should be valid.\n', '        require(_index < balanceOf(_owner));\n', '\n', '        // can loop through all without\n', '        uint256 seen = 0;\n', '        uint256 totalTokens = totalSupply();\n', '\n', '        for (uint i = 0; i < totalTokens; i++) {\n', '            if (partIndexToOwner[i] == _owner) {\n', '                if (seen == _index) {\n', '                    return i;\n', '                }\n', '                seen++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId){\n', '        return _tokenOfOwnerByIndex(_owner, _index);\n', '    }\n', '}\n', '\n', '// the contract which all battles must implement\n', '// allows for different types of battles to take place\n', 'contract PerkTree is EtherbotsNFT {\n', '    // The perktree is represented in a uint8[32] representing a binary tree\n', '    // see the number of perks active\n', '    // buy a new perk\n', '    // 0: Prestige level -> starts at 0;\n', '    // next row of tree\n', '    // 1: offensive moves 2: defensive moves\n', '    // next row of tree\n', '    // 3: melee attack 4: turret shooting 5: defend arm 6: body dodge\n', '    // next row of tree\n', '    // 7: mech melee 8: android melee 9: mech turret 10: android turret\n', '    // 11: mech defence 12: android defence 13: mech body 14: android body\n', '    //next row of tree\n', '    // 15: melee electric 16: melee steel 17: melee fire 18: melee water\n', '    // 19: turret electric 20: turret steel 21: turret fire 22: turret water\n', '    // 23: defend electric 24: defend steel 25: defend fire 26: defend water\n', '    // 27: body electric 28: body steel 29: body fire 30: body water\n', '    function _leftChild(uint8 _i) internal pure returns (uint8) {\n', '        return 2*_i + 1;\n', '    }\n', '    function _rightChild(uint8 _i) internal pure returns (uint8) {\n', '        return 2*_i + 2;\n', '    }\n', '    function _parent(uint8 _i) internal pure returns (uint8) {\n', '        return (_i-1)/2;\n', '    }\n', '\n', '\n', '    uint8 constant PRESTIGE_INDEX = 0;\n', '    uint8 constant PERK_COUNT = 30;\n', '\n', '    event PrintPerk(string,uint8,uint8[32]);\n', '\n', '    function _isValidPerkToAdd(uint8[32] _perks, uint8 _index) internal pure returns (bool) {\n', '        // a previously unlocked perk is not a valid perk to add.\n', '        if ((_index==PRESTIGE_INDEX) || (_perks[_index] > 0)) {\n', '            return false;\n', '        }\n', '        // perk not valid if any ancestor not unlocked\n', '        for (uint8 i = _parent(_index); i > PRESTIGE_INDEX; i = _parent(i)) {\n', '            if (_perks[i] == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // sum of perks (excluding prestige)\n', '    function _sumActivePerks(uint8[32] _perks) internal pure returns (uint256) {\n', '        uint32 sum = 0;\n', '        //sum from after prestige_index, to count+1 (for prestige index).\n', '        for (uint8 i = PRESTIGE_INDEX+1; i < PERK_COUNT+1; i++) {\n', '            sum += _perks[i];\n', '        }\n', '        return sum;\n', '    }\n', '\n', '    // you can unlock a new perk every two levels (including prestige when possible)\n', '    function choosePerk(uint8 _i) external {\n', '        require((_i >= PRESTIGE_INDEX) && (_i < PERK_COUNT+1));\n', '        User storage currentUser = addressToUser[msg.sender];\n', '        uint256 _numActivePerks = _sumActivePerks(currentUser.perks);\n', '        bool canPrestige = (_numActivePerks == PERK_COUNT);\n', '\n', '        //add prestige value to sum of perks\n', '        _numActivePerks += currentUser.perks[PRESTIGE_INDEX] * PERK_COUNT;\n', '        require(_numActivePerks < getLevel(currentUser.experience) / 2);\n', '\n', '        if (_i == PRESTIGE_INDEX) {\n', '            require(canPrestige);\n', '            _prestige();\n', '        } else {\n', '            require(_isValidPerkToAdd(currentUser.perks, _i));\n', '            _addPerk(_i);\n', '        }\n', '        PerkChosen(msg.sender, _i);\n', '    }\n', '\n', '    function _addPerk(uint8 perk) internal {\n', '        addressToUser[msg.sender].perks[perk]++;\n', '    }\n', '\n', '    function _prestige() internal {\n', '        User storage currentUser = addressToUser[msg.sender];\n', '        for (uint8 i = 1; i < currentUser.perks.length; i++) {\n', '            currentUser.perks[i] = 0;\n', '        }\n', '        currentUser.perks[PRESTIGE_INDEX]++;\n', '    }\n', '\n', '    event PerkChosen(address indexed upgradedUser, uint8 indexed perk);\n', '\n', '}\n', '\n', '// Central collection of storage on which all other contracts depend.\n', '// Contains structs for parts, users and functions which control their\n', '// transferrence.\n', '\n', '\n', '// Auction contract, facilitating statically priced sales, as well as \n', '// inflationary and deflationary pricing for items.\n', '// Relies heavily on the ERC721 interface and so most of the methods\n', '// are tightly bound to that implementation\n', 'contract NFTAuctionBase is Pausable {\n', '\n', '    ERC721AllImplementations public nftContract;\n', '    uint256 public ownerCut;\n', '    uint public minDuration;\n', '    uint public maxDuration;\n', '\n', '    // Represents an auction on an NFT (in this case, Robot part)\n', '    struct Auction {\n', '        // address of part owner\n', '        address seller;\n', '        // wei price of listing\n', '        uint256 startPrice;\n', '        // wei price of floor\n', '        uint256 endPrice;\n', '        // duration of sale in seconds.\n', '        uint64 duration;\n', '        // Time when sale started\n', '        // Reset to 0 after sale concluded\n', '        uint64 start;\n', '    }\n', '\n', '    function NFTAuctionBase() public {\n', '        minDuration = 60 minutes;\n', '        maxDuration = 30 days; // arbitrary\n', '    }\n', '\n', '    // map of all tokens and their auctions\n', '    mapping (uint256 => Auction) tokenIdToAuction;\n', '\n', '    event AuctionCreated(uint256 tokenId, uint256 startPrice, uint256 endPrice, uint64 duration, uint64 start);\n', '    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\n', '    event AuctionCancelled(uint256 tokenId);\n', '\n', '    // returns true if the token with id _partId is owned by the _claimant address\n', '    function _owns(address _claimant, uint256 _partId) internal view returns (bool) {\n', '        return nftContract.ownerOf(_partId) == _claimant;\n', '    }\n', '\n', '   // returns false if auction start time is 0, likely from uninitialised struct\n', '    function _isActiveAuction(Auction _auction) internal pure returns (bool) {\n', '        return _auction.start > 0;\n', '    }\n', '    \n', '    // assigns ownership of the token with id = _partId to this contract\n', '    // must have already been approved\n', '    function _escrow(address, uint _partId) internal {\n', '        // throws on transfer fail\n', '        nftContract.takeOwnership(_partId);\n', '    }\n', '\n', '    // transfer the token with id = _partId to buying address\n', '    function _transfer(address _purchasor, uint256 _partId) internal {\n', '        // successful purchaseder must takeOwnership of _partId\n', '        // nftContract.approve(_purchasor, _partId); \n', '               // actual transfer\n', '                nftContract.transfer(_purchasor, _partId);\n', '\n', '    }\n', '\n', '    // creates\n', '    function _newAuction(uint256 _partId, Auction _auction) internal {\n', '\n', '        require(_auction.duration >= minDuration);\n', '        require(_auction.duration <= maxDuration);\n', '\n', '        tokenIdToAuction[_partId] = _auction;\n', '\n', '        AuctionCreated(uint256(_partId),\n', '            uint256(_auction.startPrice),\n', '            uint256(_auction.endPrice),\n', '            uint64(_auction.duration),\n', '            uint64(_auction.start)\n', '        );\n', '    }\n', '\n', '    function setMinDuration(uint _duration) external onlyOwner {\n', '        minDuration = _duration;\n', '    }\n', '\n', '    function setMaxDuration(uint _duration) external onlyOwner {\n', '        maxDuration = _duration;\n', '    }\n', '\n', '    /// Removes auction from public view, returns token to the seller\n', '    function _cancelAuction(uint256 _partId, address _seller) internal {\n', '        _removeAuction(_partId);\n', '        _transfer(_seller, _partId);\n', '        AuctionCancelled(_partId);\n', '    }\n', '\n', '    event PrintEvent(string, address, uint);\n', '\n', '    // Calculates price and transfers purchase to owner. Part is NOT transferred to buyer.\n', '    function _purchase(uint256 _partId, uint256 _purchaseAmount) internal returns (uint256) {\n', '\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '\n', '        // check that this token is being auctioned\n', '        require(_isActiveAuction(auction));\n', '\n', '        // enforce purchase >= the current price\n', '        uint256 price = _currentPrice(auction);\n', '        require(_purchaseAmount >= price);\n', '\n', '        // Store seller before we delete auction.\n', '        address seller = auction.seller;\n', '\n', '        // Valid purchase. Remove auction to prevent reentrancy.\n', '        _removeAuction(_partId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            \n', '            // Calculate and take fee from purchase\n', '\n', '            uint256 auctioneerCut = _computeFee(price);\n', '            uint256 sellerProceeds = price - auctioneerCut;\n', '\n', '            PrintEvent("Seller, proceeds", seller, sellerProceeds);\n', '\n', '            // Pay the seller\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate excess funds and return to buyer.\n', '        uint256 purchaseExcess = _purchaseAmount - price;\n', '\n', '        PrintEvent("Sender, excess", msg.sender, purchaseExcess);\n', '        // Return any excess funds. Reentrancy again prevented by deleting auction.\n', '        msg.sender.transfer(purchaseExcess);\n', '\n', '        AuctionSuccessful(_partId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    // returns the current price of the token being auctioned in _auction\n', '    function _currentPrice(Auction storage _auction) internal view returns (uint256) {\n', '        uint256 secsElapsed = now - _auction.start;\n', '        return _computeCurrentPrice(\n', '            _auction.startPrice,\n', '            _auction.endPrice,\n', '            _auction.duration,\n', '            secsElapsed\n', '        );\n', '    }\n', '\n', '    // Checks if NFTPart is currently being auctioned.\n', '    // function _isBeingAuctioned(Auction storage _auction) internal view returns (bool) {\n', '    //     return (_auction.start > 0);\n', '    // }\n', '\n', '    // removes the auction of the part with id _partId\n', '    function _removeAuction(uint256 _partId) internal {\n', '        delete tokenIdToAuction[_partId];\n', '    }\n', '\n', '    // computes the current price of an deflating-price auction \n', '    function _computeCurrentPrice( uint256 _startPrice, uint256 _endPrice, uint256 _duration, uint256 _secondsPassed ) internal pure returns (uint256 _price) {\n', '        _price = _startPrice;\n', '        if (_secondsPassed >= _duration) {\n', '            // Has been up long enough to hit endPrice.\n', '            // Return this price floor.\n', '            _price = _endPrice;\n', '            // this is a statically price sale. Just return the price.\n', '        }\n', '        else if (_duration > 0) {\n', '            // This auction contract supports auctioning from any valid price to any other valid price.\n', '            // This means the price can dynamically increase upward, or downard.\n', '            int256 priceDifference = int256(_endPrice) - int256(_startPrice);\n', '            int256 currentPriceDifference = priceDifference * int256(_secondsPassed) / int256(_duration);\n', '            int256 currentPrice = int256(_startPrice) + currentPriceDifference;\n', '\n', '            _price = uint256(currentPrice);\n', '        }\n', '        return _price;\n', '    }\n', '\n', '    // Compute percentage fee of transaction\n', '\n', '    function _computeFee (uint256 _price) internal view returns (uint256) {\n', '        return _price * ownerCut / 10000; \n', '    }\n', '\n', '}\n', '\n', '// Clock auction for NFTParts.\n', '// Only timed when pricing is dynamic (i.e. startPrice != endPrice).\n', '// Else, this becomes an infinite duration statically priced sale,\n', '// resolving when succesfully purchase for or cancelled.\n', '\n', 'contract DutchAuction is NFTAuctionBase, EtherbotsPrivileges {\n', '\n', '    // The ERC-165 interface signature for ERC-721.\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0xda671b9b);\n', ' \n', '    function DutchAuction(address _nftAddress, uint256 _fee) public {\n', '        require(_fee <= 10000);\n', '        ownerCut = _fee;\n', '\n', '        ERC721AllImplementations candidateContract = ERC721AllImplementations(_nftAddress);\n', '        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nftContract = candidateContract;\n', '    }\n', '\n', '    // Remove all ether from the contract. This will be marketplace fees.\n', '    // Transfers to the NFT contract. \n', '    // Can be called by owner or NFT contract.\n', '\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nftContract);\n', '\n', '        require(msg.sender == owner || msg.sender == nftAddress);\n', '\n', '        nftAddress.transfer(this.balance);\n', '    }\n', '\n', '    event PrintEvent(string, address, uint);\n', '\n', '    // Creates an auction and lists it.\n', '    function createAuction( uint256 _partId, uint256 _startPrice, uint256 _endPrice, uint256 _duration, address _seller ) external whenNotPaused {\n', '        // Sanity check that no inputs overflow how many bits we&#39;ve allocated\n', '        // to store them in the auction struct.\n', '        require(_startPrice == uint256(uint128(_startPrice)));\n', '        require(_endPrice == uint256(uint128(_endPrice)));\n', '        require(_duration == uint256(uint64(_duration)));\n', '        require(_startPrice >= _endPrice);\n', '\n', '        require(msg.sender == address(nftContract));\n', '        _escrow(_seller, _partId);\n', '        Auction memory auction = Auction(\n', '            _seller,\n', '            uint128(_startPrice),\n', '            uint128(_endPrice),\n', '            uint64(_duration),\n', '            uint64(now) //seconds uint \n', '        );\n', '        PrintEvent("Auction Start", 0x0, auction.start);\n', '        _newAuction(_partId, auction);\n', '    }\n', '\n', '\n', '    // SCRAPYARD PRICING LOGIC\n', '\n', '    uint8 constant LAST_CONSIDERED = 5;\n', '    uint8 public scrapCounter = 0;\n', '    uint[5] public lastScrapPrices;\n', '    \n', '    // Purchases an open auction\n', '    // Will transfer ownership if successful.\n', '    \n', '    function purchase(uint256 _partId) external payable whenNotPaused {\n', '        address seller = tokenIdToAuction[_partId].seller;\n', '\n', '        // _purchase will throw if the purchase or funds transfer fails\n', '        uint256 price = _purchase(_partId, msg.value);\n', '        _transfer(msg.sender, _partId);\n', '        \n', '        // If the seller is the scrapyard, track price information.\n', '        if (seller == address(nftContract)) {\n', '\n', '            lastScrapPrices[scrapCounter] = price;\n', '            if (scrapCounter == LAST_CONSIDERED - 1) {\n', '                scrapCounter = 0;\n', '            } else {\n', '                scrapCounter++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function averageScrapPrice() public view returns (uint) {\n', '        uint sum = 0;\n', '        for (uint8 i = 0; i < LAST_CONSIDERED; i++) {\n', '            sum += lastScrapPrices[i];\n', '        }\n', '        return sum / LAST_CONSIDERED;\n', '    }\n', '\n', '    // Allows a user to cancel an auction before it&#39;s resolved.\n', '    // Returns the part to the seller.\n', '\n', '    function cancelAuction(uint256 _partId) external {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        address seller = auction.seller;\n', '        require(msg.sender == seller);\n', '        _cancelAuction(_partId, seller);\n', '    }\n', '\n', '    // returns the current price of the auction of a token with id _partId\n', '    function getCurrentPrice(uint256 _partId) external view returns (uint256) {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        return _currentPrice(auction);\n', '    }\n', '\n', '    //  Returns the details of an auction from its _partId.\n', '    function getAuction(uint256 _partId) external view returns ( address seller, uint256 startPrice, uint256 endPrice, uint256 duration, uint256 startedAt ) {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        return ( auction.seller, auction.startPrice, auction.endPrice, auction.duration, auction.start);\n', '    }\n', '\n', '    // Allows owner to cancel an auction.\n', '    // ONLY able to be used when contract is paused,\n', '    // in the case of emergencies.\n', '    // Parts returned to seller as it&#39;s equivalent to them \n', '    // calling cancel.\n', '    function cancelAuctionWhenPaused(uint256 _partId) whenPaused onlyOwner external {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        _cancelAuction(_partId, auction.seller);\n', '    }\n', '}\n', '\n', 'contract EtherbotsAuction is PerkTree {\n', '\n', '    // Sets the reference to the sale auction.\n', '\n', '    function setAuctionAddress(address _address) external onlyOwner {\n', '        require(_address != address(0));\n', '        DutchAuction candidateContract = DutchAuction(_address);\n', '\n', '        // Set the new contract address\n', '        auction = candidateContract;\n', '    }\n', '\n', '    // list a part for auction.\n', '\n', '    function createAuction(\n', '        uint256 _partId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _duration ) external whenNotPaused \n', '    {\n', '\n', '\n', '        // user must have current control of the part\n', '        // will lose control if they delegate to the auction\n', '        // therefore no duplicate auctions!\n', '        require(owns(msg.sender, _partId));\n', '\n', '        _approve(_partId, auction);\n', '\n', '        // will throw if inputs are invalid\n', '        // will clear transfer approval\n', '        DutchAuction(auction).createAuction(_partId,_startPrice,_endPrice,_duration,msg.sender);\n', '    }\n', '\n', '    // transfer balance back to core contract\n', '    function withdrawAuctionBalance() external onlyOwner {\n', '        DutchAuction(auction).withdrawBalance();\n', '    }\n', '\n', '    // SCRAP FUNCTION\n', '  \n', '    // This takes scrapped parts and automatically relists them on the market.\n', '    // Provides a good floor for entrance into the game, while keeping supply\n', '    // constant as these parts were already in circulation.\n', '\n', '    // uint public constant SCRAPYARD_STARTING_PRICE = 0.1 ether;\n', '    uint scrapMinStartPrice = 0.05 ether; // settable minimum starting price for sanity\n', '    uint scrapMinEndPrice = 0.005 ether;  // settable minimum ending price for sanity\n', '    uint scrapAuctionDuration = 2 days;\n', '    \n', '    function setScrapMinStartPrice(uint _newMinStartPrice) external onlyOwner {\n', '        scrapMinStartPrice = _newMinStartPrice;\n', '    }\n', '    function setScrapMinEndPrice(uint _newMinEndPrice) external onlyOwner {\n', '        scrapMinEndPrice = _newMinEndPrice;\n', '    }\n', '    function setScrapAuctionDuration(uint _newScrapAuctionDuration) external onlyOwner {\n', '        scrapAuctionDuration = _newScrapAuctionDuration;\n', '    }\n', ' \n', '    function _createScrapPartAuction(uint _scrapPartId) internal {\n', '        // if (scrapyard == address(this)) {\n', '        _approve(_scrapPartId, auction);\n', '        \n', '        DutchAuction(auction).createAuction(\n', '            _scrapPartId,\n', '            _getNextAuctionPrice(), // gen next auction price\n', '            scrapMinEndPrice,\n', '            scrapAuctionDuration,\n', '            address(this)\n', '        );\n', '        // }\n', '    }\n', '\n', '    function _getNextAuctionPrice() internal view returns (uint) {\n', '        uint avg = DutchAuction(auction).averageScrapPrice();\n', '        // add 30% to the average\n', '        // prevent runaway pricing\n', '        uint next = avg + ((30 * avg) / 100);\n', '        if (next < scrapMinStartPrice) {\n', '            next = scrapMinStartPrice;\n', '        }\n', '        return next;\n', '    }\n', '\n', '}\n', '\n', 'contract PerksRewards is EtherbotsAuction {\n', '    ///  An internal method that creates a new part and stores it. This\n', '    ///  method doesn&#39;t do any checking and should only be called when the\n', '    ///  input data is known to be valid. Will generate both a Forge event\n', '    ///  and a Transfer event.\n', '   function _createPart(uint8[4] _partArray, address _owner) internal returns (uint) {\n', '        uint32 newPartId = uint32(parts.length);\n', '        assert(newPartId == parts.length);\n', '\n', '        Part memory _part = Part({\n', '            tokenId: newPartId,\n', '            partType: _partArray[0],\n', '            partSubType: _partArray[1],\n', '            rarity: _partArray[2],\n', '            element: _partArray[3],\n', '            battlesLastDay: 0,\n', '            experience: 0,\n', '            forgeTime: uint32(now),\n', '            battlesLastReset: uint32(now)\n', '        });\n', '        assert(newPartId == parts.push(_part) - 1);\n', '\n', '        // emit the FORGING!!!\n', '        Forge(_owner, newPartId, _part);\n', '\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newPartId);\n', '\n', '        return newPartId;\n', '    }\n', '\n', '    uint public PART_REWARD_CHANCE = 995;\n', '    // Deprecated subtypes contain the subtype IDs of legacy items\n', '    // which are no longer available to be redeemed in game.\n', '    // i.e. subtype ID 14 represents lambo body, presale exclusive.\n', '    // a value of 0 represents that subtype (id within range)\n', '    // as being deprecated for that part type (body, turret, etc)\n', '    uint8[] public defenceElementBySubtypeIndex;\n', '    uint8[] public meleeElementBySubtypeIndex;\n', '    uint8[] public bodyElementBySubtypeIndex;\n', '    uint8[] public turretElementBySubtypeIndex;\n', '    // uint8[] public defenceElementBySubtypeIndex = [1,2,4,3,4,1,3,3,2,1,4];\n', '    // uint8[] public meleeElementBySubtypeIndex = [3,1,3,2,3,4,2,2,1,1,1,1,4,4];\n', '    // uint8[] public bodyElementBySubtypeIndex = [2,1,2,3,4,3,1,1,4,2,3,4,1,0,1]; // no more lambos :&#39;(\n', '    // uint8[] public turretElementBySubtypeIndex = [4,3,2,1,2,1,1,3,4,3,4];\n', '\n', '    function setRewardChance(uint _newChance) external onlyOwner {\n', '        require(_newChance > 980); // not too hot\n', '        require(_newChance <= 1000); // not too cold\n', '        PART_REWARD_CHANCE = _newChance; // just right\n', '        // come at me goldilocks\n', '    }\n', '    // The following functions DON&#39;T create parts, they add new parts\n', '    // as possible rewards from the reward pool.\n', '\n', '\n', '    function addDefenceParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            defenceElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(defenceElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addMeleeParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            meleeElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(meleeElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addBodyParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            bodyElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(bodyElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addTurretParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            turretElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(turretElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    // Deprecate subtypes. Once a subtype has been deprecated it can never be\n', '    // undeprecated. Starting with lambo!\n', '    function deprecateDefenceSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        defenceElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateMeleeSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        meleeElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateBodySubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        bodyElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateTurretSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        turretElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    // function _randomIndex(uint _rand, uint8 _startIx, uint8 _endIx, uint8 _modulo) internal pure returns (uint8) {\n', '    //     require(_startIx < _endIx);\n', '    //     bytes32 randBytes = bytes32(_rand);\n', '    //     uint result = 0;\n', '    //     for (uint8 i=_startIx; i<_endIx; i++) {\n', '    //         result = result | uint8(randBytes[i]);\n', '    //         result << 8;\n', '    //     }\n', '    //     uint8 resultInt = uint8(uint(result) % _modulo);\n', '    //     return resultInt;\n', '    // }\n', '\n', '\n', '    // This function takes a random uint, an owner and randomly generates a valid part.\n', '    // It then transfers that part to the owner.\n', '    function _generateRandomPart(uint _rand, address _owner) internal {\n', '        // random uint 20 in length - MAYBE 20.\n', '        // first randomly gen a part type\n', '        _rand = uint(keccak256(_rand));\n', '        uint8[4] memory randomPart;\n', '        randomPart[0] = uint8(_rand % 4) + 1;\n', '        _rand = uint(keccak256(_rand));\n', '\n', '        // randomPart[0] = _randomIndex(_rand,0,4,4) + 1; // 1, 2, 3, 4, => defence, melee, body, turret\n', '\n', '        if (randomPart[0] == DEFENCE) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,defenceElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(defenceElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == MELEE) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,meleeElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(meleeElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == BODY) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,bodyElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(bodyElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == TURRET) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,turretElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(turretElementBySubtypeIndex, randomPart[1]);\n', '\n', '        }\n', '        _rand = uint(keccak256(_rand));\n', '        randomPart[2] = _getRarity(_rand);\n', '        // randomPart[2] = _getRarity(_randomIndex(_rand,8,12,3)); // rarity\n', '        _createPart(randomPart, _owner);\n', '    }\n', '\n', '    function _getRandomPartSubtype(uint _rand, uint8[] elementBySubtypeIndex) internal pure returns (uint8) {\n', '        require(elementBySubtypeIndex.length < uint(uint8(-1)));\n', '        uint8 subtypeLength = uint8(elementBySubtypeIndex.length);\n', '        require(subtypeLength > 0);\n', '        uint8 subtypeIndex = uint8(_rand % subtypeLength);\n', '        // uint8 subtypeIndex = _randomIndex(_rand,4,8,subtypeLength);\n', '        uint8 count = 0;\n', '        while (elementBySubtypeIndex[subtypeIndex] == 0) {\n', '            subtypeIndex++;\n', '            count++;\n', '            if (subtypeIndex == subtypeLength) {\n', '                subtypeIndex = 0;\n', '            }\n', '            if (count > subtypeLength) {\n', '                break;\n', '            }\n', '        }\n', '        require(elementBySubtypeIndex[subtypeIndex] != 0);\n', '        return subtypeIndex + 1;\n', '    }\n', '\n', '\n', '    function _getRarity(uint rand) pure internal returns (uint8) {\n', '        uint16 rarity = uint16(rand % 1000);\n', '        if (rarity >= 990) {  // 1% chance of gold\n', '          return GOLD;\n', '        } else if (rarity >= 970) { // 2% chance of shadow\n', '          return SHADOW;\n', '        } else {\n', '          return STANDARD;\n', '        }\n', '    }\n', '\n', '    function _getElement(uint8[] elementBySubtypeIndex, uint8 subtype) internal pure returns (uint8) {\n', '        uint8 subtypeIndex = subtype - 1;\n', '        return elementBySubtypeIndex[subtypeIndex];\n', '    }\n', '\n', '    mapping(address => uint[]) pendingPartCrates ;\n', '\n', '    function getPendingPartCrateLength() external view returns (uint) {\n', '        return pendingPartCrates[msg.sender].length;\n', '    }\n', '\n', '    /// Put shards together into a new part-crate\n', '    function redeemShardsIntoPending() external {\n', '        User storage user = addressToUser[msg.sender];\n', '         while (user.numShards >= SHARDS_TO_PART) {\n', '             user.numShards -= SHARDS_TO_PART;\n', '             pendingPartCrates[msg.sender].push(block.number);\n', '             // 256 blocks to redeem\n', '         }\n', '    }\n', '\n', '    function openPendingPartCrates() external {\n', '        uint[] memory crates = pendingPartCrates[msg.sender];\n', '        for (uint i = 0; i < crates.length; i++) {\n', '            uint pendingBlockNumber = crates[i];\n', '            // can&#39;t open on the same timestamp\n', '            require(block.number > pendingBlockNumber);\n', '\n', '            var hash = block.blockhash(pendingBlockNumber);\n', '\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)); // % (10 ** 20);\n', '                _generateRandomPart(rand, msg.sender);\n', '            } else {\n', '                // Do nothing, no second chances to secure integrity of randomness.\n', '            }\n', '        }\n', '        delete pendingPartCrates[msg.sender];\n', '    }\n', '\n', '    uint32 constant SHARDS_MAX = 10000;\n', '\n', '    function _addShardsToUser(User storage _user, uint32 _shards) internal {\n', '        uint32 updatedShards = _user.numShards + _shards;\n', '        if (updatedShards > SHARDS_MAX) {\n', '            updatedShards = SHARDS_MAX;\n', '        }\n', '        _user.numShards = updatedShards;\n', '        ShardsAdded(msg.sender, _shards);\n', '    }\n', '\n', '    // FORGING / SCRAPPING\n', '    event ShardsAdded(address caller, uint32 shards);\n', '    event Scrap(address user, uint partId);\n', '\n', '    uint32 constant SHARDS_TO_PART = 500;\n', '    uint8 public scrapPercent = 60;\n', '    uint8 public burnRate = 60; \n', '\n', '    function setScrapPercent(uint8 _newPercent) external onlyOwner {\n', '        require((_newPercent >= 50) && (_newPercent <= 90));\n', '        scrapPercent = _newPercent;\n', '    }\n', '\n', '    // function setScrapyard(address _scrapyard) external onlyOwner {\n', '    //     scrapyard = _scrapyard;\n', '    // }\n', '\n', '    function setBurnRate(uint8 _rate) external onlyOwner {\n', '        burnRate = _rate;\n', '    }\n', '\n', '\n', '    uint public scrapCount = 0;\n', '\n', '    // scraps a part for shards\n', '    function scrap(uint partId) external {\n', '        require(owns(msg.sender, partId));\n', '        User storage u = addressToUser[msg.sender];\n', '        _addShardsToUser(u, (SHARDS_TO_PART * scrapPercent) / 100);\n', '        Scrap(msg.sender, partId);\n', '        // this doesn&#39;t need to be secure\n', '        // no way to manipulate it apart from guaranteeing your parts are resold\n', '        // or burnt\n', '        if (uint(keccak256(scrapCount)) % 100 >= burnRate) {\n', '            _transfer(msg.sender, address(this), partId);\n', '            _createScrapPartAuction(partId);\n', '        } else {\n', '            _transfer(msg.sender, address(0), partId);\n', '        }\n', '        scrapCount++;\n', '    }\n', '\n', '}\n', '\n', 'contract Mint is PerksRewards {\n', '    \n', '    // Owner only function to give an address new parts.\n', '    // Strictly capped at 5000.\n', '    // This will ONLY be used for promotional purposes (i.e. providing items for Wax/OPSkins partnership)\n', '    // which we don&#39;t benefit financially from, or giving users who win the prize of designing a part \n', '    // for the game, a single copy of that part.\n', '    \n', '    uint16 constant MINT_LIMIT = 5000;\n', '    uint16 public partsMinted = 0;\n', '\n', '    function mintParts(uint16 _count, address _owner) public onlyOwner {\n', '        require(_count > 0 && _count <= 50);\n', '        // check overflow\n', '        require(partsMinted + _count > partsMinted);\n', '        require(partsMinted + _count < MINT_LIMIT);\n', '        \n', '        addressToUser[_owner].numShards += SHARDS_TO_PART * _count;\n', '        \n', '        partsMinted += _count;\n', '    }       \n', '\n', '    function mintParticularPart(uint8[4] _partArray, address _owner) public onlyOwner {\n', '        require(partsMinted < MINT_LIMIT);\n', '        /* cannot create deprecated parts\n', '        for (uint i = 0; i < deprecated.length; i++) {\n', '            if (_partArray[2] == deprecated[i]) {\n', '                revert();\n', '            }\n', '        } */\n', '        _createPart(_partArray, _owner);\n', '        partsMinted++;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract NewCratePreSale {\n', '    \n', '    // migration functions migrate the data from the previous contract in stages\n', '    // all addresses are included for transparency and easy verification\n', '    // however addresses with no robots (i.e. failed transaction and never bought properly) have been commented out.\n', '    // to view the full list of state assignments, go to etherscan.io/address/{address} and you can view the verified\n', '    mapping (address => uint[]) public userToRobots; \n', '\n', '    function _migrate(uint _index) external onlyOwner {\n', '        bytes4 selector = bytes4(keccak256("setData()"));\n', '        address a = migrators[_index];\n', '        require(a.delegatecall(selector));\n', '    }\n', '    // source code - feel free to verify the migration\n', '    address[6] migrators = [\n', '        0x700FeBD9360ac0A0a72F371615427Bec4E4454E5, //0x97AE01893E42d6d33fd9851A28E5627222Af7BBB,\n', '        0x72Cc898de0A4EAC49c46ccb990379099461342f6,\n', '        0xc3cC48da3B8168154e0f14Bf0446C7a93613F0A7,\n', '        0x4cC96f2Ddf6844323ae0d8461d418a4D473b9AC3,\n', '        0xa52bFcb5FF599e29EE2B9130F1575BaBaa27de0A,\n', '        0xe503b42AabdA22974e2A8B75Fa87E010e1B13584\n', '    ];\n', '    \n', '    function NewCratePreSale() public payable {\n', '        \n', '            owner = msg.sender;\n', '        // one time transfer of state from the previous contract\n', '        // var previous = CratePreSale(0x3c7767011C443EfeF2187cf1F2a4c02062da3998); //MAINNET\n', '\n', '        // oldAppreciationRateWei = previous.appreciationRateWei();\n', '        oldAppreciationRateWei = 100000000000000;\n', '        appreciationRateWei = oldAppreciationRateWei;\n', '  \n', '        // oldPrice = previous.currentPrice();\n', '        oldPrice = 232600000000000000;\n', '        currentPrice = oldPrice;\n', '\n', '        // oldCratesSold = previous.cratesSold();\n', '        oldCratesSold = 1075;\n', '        cratesSold = oldCratesSold;\n', '\n', '        // Migration Rationale\n', '        // due to solidity issues with enumerability (contract calls cannot return dynamic arrays etc)\n', '        // no need for trust -> can still use web3 to call the previous contract and check the state\n', '        // will only change in the future if people send more eth\n', '        // and will be obvious due to change in crate count. Any purchases on the old contract\n', '        // after this contract is deployed will be fully refunded, and those robots bought will be voided. \n', '        // feel free to validate any address on the old etherscan:\n', '        // https://etherscan.io/address/0x3c7767011C443EfeF2187cf1F2a4c02062da3998\n', '        // can visit the exact contracts at the addresses listed above\n', '    }\n', '\n', '    // ------ STATE ------\n', '    uint256 constant public MAX_CRATES_TO_SELL = 3900; // Max no. of robot crates to ever be sold\n', '    uint256 constant public PRESALE_END_TIMESTAMP = 1518699600; // End date for the presale - no purchases can be made after this date - Midnight 16 Feb 2018 UTC\n', '\n', '    uint256 public appreciationRateWei;\n', '    uint32 public cratesSold;\n', '    uint256 public currentPrice;\n', '\n', '    // preserve these for later verification\n', '    uint32 public oldCratesSold;\n', '    uint256 public oldPrice;\n', '    uint256 public oldAppreciationRateWei;\n', '    // mapping (address => uint32) public userCrateCount; // replaced with more efficient method\n', '    \n', '\n', '    // store the unopened crates of this user\n', '    // actually stores the blocknumber of each crate \n', '    mapping (address => uint[]) public addressToPurchasedBlocks;\n', '    // store the number of expired crates for each user \n', '    // i.e. crates where the user failed to open the crate within 256 blocks (~1 hour)\n', '    // these crates will be able to be opened post-launch\n', '    mapping (address => uint) public expiredCrates;\n', '    // store the part information of purchased crates\n', '\n', '\n', '\n', '    function openAll() public {\n', '        uint len = addressToPurchasedBlocks[msg.sender].length;\n', '        require(len > 0);\n', '        uint8 count = 0;\n', '        // len > i to stop predicatable wraparound\n', '        for (uint i = len - 1; i >= 0 && len > i; i--) {\n', '            uint crateBlock = addressToPurchasedBlocks[msg.sender][i];\n', '            require(block.number > crateBlock);\n', '            // can&#39;t open on the same timestamp\n', '            var hash = block.blockhash(crateBlock);\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)) % (10 ** 20);\n', '                userToRobots[msg.sender].push(rand);\n', '                count++;\n', '            } else {\n', '                // all others will be expired\n', '                expiredCrates[msg.sender] += (i + 1);\n', '                break;\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete addressToPurchasedBlocks[msg.sender];\n', '    }\n', '\n', '    // ------ EVENTS ------\n', '    event CratesPurchased(address indexed _from, uint8 _quantity);\n', '    event CratesOpened(address indexed _from, uint8 _quantity);\n', '\n', '    // ------ FUNCTIONS ------\n', '    function getPrice() view public returns (uint256) {\n', '        return currentPrice;\n', '    }\n', '\n', '    function getRobotCountForUser(address _user) external view returns(uint256) {\n', '        return userToRobots[_user].length;\n', '    }\n', '\n', '    function getRobotForUserByIndex(address _user, uint _index) external view returns(uint) {\n', '        return userToRobots[_user][_index];\n', '    }\n', '\n', '    function getRobotsForUser(address _user) view public returns (uint[]) {\n', '        return userToRobots[_user];\n', '    }\n', '\n', '    function getPendingCratesForUser(address _user) external view returns(uint[]) {\n', '        return addressToPurchasedBlocks[_user];\n', '    }\n', '\n', '    function getPendingCrateForUserByIndex(address _user, uint _index) external view returns(uint) {\n', '        return addressToPurchasedBlocks[_user][_index];\n', '    }\n', '\n', '    function getExpiredCratesForUser(address _user) external view returns(uint) {\n', '        return expiredCrates[_user];\n', '    }\n', '\n', '    function incrementPrice() private {\n', '        // Decrease the rate of increase of the crate price\n', '        // as the crates become more expensive\n', '        // to avoid runaway pricing\n', '        // (halving rate of increase at 0.1 ETH, 0.2 ETH, 0.3 ETH).\n', '        if ( currentPrice == 100000000000000000 ) {\n', '            appreciationRateWei = 200000000000000;\n', '        } else if ( currentPrice == 200000000000000000) {\n', '            appreciationRateWei = 100000000000000;\n', '        } else if (currentPrice == 300000000000000000) {\n', '            appreciationRateWei = 50000000000000;\n', '        }\n', '        currentPrice += appreciationRateWei;\n', '    }\n', '\n', '    function purchaseCrates(uint8 _cratesToBuy) public payable whenNotPaused {\n', '        require(now < PRESALE_END_TIMESTAMP); // Check presale is still ongoing.\n', '        require(_cratesToBuy <= 10); // Can only buy max 10 crates at a time. Don&#39;t be greedy!\n', '        require(_cratesToBuy >= 1); // Sanity check. Also, you have to buy a crate. \n', '        require(cratesSold + _cratesToBuy <= MAX_CRATES_TO_SELL); // Check max crates sold is less than hard limit\n', '        uint256 priceToPay = _calculatePayment(_cratesToBuy);\n', '         require(msg.value >= priceToPay); // Check buyer sent sufficient funds to purchase\n', '        if (msg.value > priceToPay) { //overpaid, return excess\n', '            msg.sender.transfer(msg.value-priceToPay);\n', '        }\n', '        //all good, payment received. increment number sold, price, and generate crate receipts!\n', '        cratesSold += _cratesToBuy;\n', '      for (uint8 i = 0; i < _cratesToBuy; i++) {\n', '            incrementPrice();\n', '            addressToPurchasedBlocks[msg.sender].push(block.number);\n', '        }\n', '\n', '        CratesPurchased(msg.sender, _cratesToBuy);\n', '    } \n', '\n', '    function _calculatePayment (uint8 _cratesToBuy) private view returns (uint256) {\n', '        \n', '        uint256 tempPrice = currentPrice;\n', '\n', '        for (uint8 i = 1; i < _cratesToBuy; i++) {\n', '            tempPrice += (currentPrice + (appreciationRateWei * i));\n', '        } // for every crate over 1 bought, add current Price and a multiple of the appreciation rate\n', '          // very small edge case of buying 10 when you the appreciation rate is about to halve\n', '          // is compensated by the great reduction in gas by buying N at a time.\n', '        \n', '        return tempPrice;\n', '    }\n', '\n', '\n', '    //owner only withdrawal function for the presale\n', '    function withdraw() onlyOwner public {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function addFunds() onlyOwner external payable {\n', '\n', '    }\n', '\n', '  event SetPaused(bool paused);\n', '\n', '  // starts unpaused\n', '  bool public paused = false;\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() external onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '  function unpause() external onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '    \n', '}\n', 'contract EtherbotsMigrations is Mint {\n', '\n', '    event CratesOpened(address indexed _from, uint8 _quantity);\n', '    event OpenedOldCrates(address indexed _from);\n', '    event MigratedCrates(address indexed _from, uint16 _quantity, bool isMigrationComplete);\n', '\n', '    address presale = 0xc23F76aEa00B775AADC8504CcB22468F4fD2261A;\n', '    mapping(address => bool) public hasMigrated;\n', '    mapping(address => bool) public hasOpenedOldCrates;\n', '    mapping(address => uint[]) pendingCrates;\n', '    mapping(address => uint16) public cratesMigrated;\n', '\n', '  \n', '    // Element: copy for MIGRATIONS ONLY.\n', '    string constant private DEFENCE_ELEMENT_BY_ID = "12434133214";\n', '    string constant private MELEE_ELEMENT_BY_ID = "31323422111144";\n', '    string constant private BODY_ELEMENT_BY_ID = "212343114234111";\n', '    string constant private TURRET_ELEMENT_BY_ID = "43212113434";\n', '\n', '    // Once only function.\n', '    // Transfers all pending and expired crates in the old contract\n', '    // into pending crates in the current one.\n', '    // Users can then open them on the new contract.\n', '    // Should only rarely have to be called.\n', '    // event oldpending(uint old);\n', '\n', '    function openOldCrates() external {\n', '        require(hasOpenedOldCrates[msg.sender] == false);\n', '        // uint oldPendingCrates = NewCratePreSale(presale).getPendingCrateForUserByIndex(msg.sender,0); // getting unrecognised opcode here --!\n', '        // oldpending(oldPendingCrates);\n', '        // require(oldPendingCrates == 0);\n', '        _migrateExpiredCrates();\n', '        hasOpenedOldCrates[msg.sender] = true;\n', '        OpenedOldCrates(msg.sender);\n', '    }\n', '\n', '    function migrate() external whenNotPaused {\n', '        \n', '        // Can&#39;t migrate twice .\n', '        require(hasMigrated[msg.sender] == false);\n', '        \n', '        // require(NewCratePreSale(presale).getPendingCrateForUserByIndex(msg.sender,0) == 0);\n', '        // No pending crates in the new contract allowed. Make sure you open them first.\n', '        require(pendingCrates[msg.sender].length == 0);\n', '        \n', '        // If the user has old expired crates, don&#39;t let them migrate until they&#39;ve\n', '        // converted them to pending crates in the new contract.\n', '        if (NewCratePreSale(presale).getExpiredCratesForUser(msg.sender) > 0) {\n', '            require(hasOpenedOldCrates[msg.sender]); \n', '        }\n', '\n', '        // have to make a ton of calls unfortunately \n', '        uint16 length = uint16(NewCratePreSale(presale).getRobotCountForUser(msg.sender));\n', '\n', '        // gas limit will be exceeded with *whale* etherbot players!\n', '        // let&#39;s migrate their robots in batches of ten.\n', '        // they can afford it\n', '        bool isMigrationComplete = false;\n', '        var max = length - cratesMigrated[msg.sender];\n', '        if (max > 9) {\n', '            max = 9;\n', '        } else { // final call - all robots will be migrated\n', '            isMigrationComplete = true;\n', '            hasMigrated[msg.sender] = true;\n', '        }\n', '        for (uint i = cratesMigrated[msg.sender]; i < cratesMigrated[msg.sender] + max; i++) {\n', '            var robot = NewCratePreSale(presale).getRobotForUserByIndex(msg.sender, i);\n', '            var robotString = uintToString(robot);\n', '            // MigratedBot(robotString);\n', '\n', '            _migrateRobot(robotString);\n', '            \n', '        }\n', '        cratesMigrated[msg.sender] += max;\n', '        MigratedCrates(msg.sender, cratesMigrated[msg.sender], isMigrationComplete);\n', '    }\n', '\n', '    function _migrateRobot(string robot) private {\n', '        var (melee, defence, body, turret) = _convertBlueprint(robot);\n', '        // blueprints event\n', '        // blueprints(body, turret, melee, defence);\n', '        _createPart(melee, msg.sender);\n', '        _createPart(defence, msg.sender);\n', '        _createPart(turret, msg.sender);\n', '        _createPart(body, msg.sender);\n', '    }\n', '\n', '    function _getRarity(string original, uint8 low, uint8 high) pure private returns (uint8) {\n', '        uint32 rarity = stringToUint32(substring(original,low,high));\n', '        if (rarity >= 950) {\n', '          return GOLD; \n', '        } else if (rarity >= 850) {\n', '          return SHADOW;\n', '        } else {\n', '          return STANDARD; \n', '        }\n', '    }\n', '   \n', '    function _getElement(string elementString, uint partId) pure private returns(uint8) {\n', '        return stringToUint8(substring(elementString, partId-1,partId));\n', '    }\n', '\n', '    // Actually part type\n', '    function _getPartId(string original, uint8 start, uint8 end, uint8 partCount) pure private returns(uint8) {\n', '        return (stringToUint8(substring(original,start,end)) % partCount) + 1;\n', '    }\n', '\n', '    function userPendingCrateNumber(address _user) external view returns (uint) {\n', '        return pendingCrates[_user].length;\n', '    }    \n', '    \n', '    // convert old string representation of robot into 4 new ERC721 parts\n', '  \n', '    function _convertBlueprint(string original) pure private returns(uint8[4] body,uint8[4] melee, uint8[4] turret, uint8[4] defence ) {\n', '\n', '        /* ------ CONVERSION TIME ------ */\n', '        \n', '\n', '        body[0] = BODY; \n', '        body[1] = _getPartId(original, 3, 5, 15);\n', '        body[2] = _getRarity(original, 0, 3);\n', '        body[3] = _getElement(BODY_ELEMENT_BY_ID, body[1]);\n', '        \n', '        turret[0] = TURRET;\n', '        turret[1] = _getPartId(original, 8, 10, 11);\n', '        turret[2] = _getRarity(original, 5, 8);\n', '        turret[3] = _getElement(TURRET_ELEMENT_BY_ID, turret[1]);\n', '\n', '        melee[0] = MELEE;\n', '        melee[1] = _getPartId(original, 13, 15, 14);\n', '        melee[2] = _getRarity(original, 10, 13);\n', '        melee[3] = _getElement(MELEE_ELEMENT_BY_ID, melee[1]);\n', '\n', '        defence[0] = DEFENCE;\n', '        var len = bytes(original).length;\n', '        // string of number does not have preceding 0&#39;s\n', '        if (len == 20) {\n', '            defence[1] = _getPartId(original, 18, 20, 11);\n', '        } else if (len == 19) {\n', '            defence[1] = _getPartId(original, 18, 19, 11);\n', '        } else { //unlikely to have length less than 19\n', '            defence[1] = uint8(1);\n', '        }\n', '        defence[2] = _getRarity(original, 15, 18);\n', '        defence[3] = _getElement(DEFENCE_ELEMENT_BY_ID, defence[1]);\n', '\n', '        // implicit return\n', '    }\n', '\n', '    // give one more chance\n', '    function _migrateExpiredCrates() private {\n', '        // get the number of expired crates\n', '        uint expired = NewCratePreSale(presale).getExpiredCratesForUser(msg.sender);\n', '        for (uint i = 0; i < expired; i++) {\n', '            pendingCrates[msg.sender].push(block.number);\n', '        }\n', '    }\n', '    // Users can open pending crates on the new contract.\n', '    function openCrates() public whenNotPaused {\n', '        uint[] memory pc = pendingCrates[msg.sender];\n', '        require(pc.length > 0);\n', '        uint8 count = 0;\n', '        for (uint i = 0; i < pc.length; i++) {\n', '            uint crateBlock = pc[i];\n', '            require(block.number > crateBlock);\n', '            // can&#39;t open on the same timestamp\n', '            var hash = block.blockhash(crateBlock);\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)) % (10 ** 20);\n', '                _migrateRobot(uintToString(rand));\n', '                count++;\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete pendingCrates[msg.sender];\n', '    }\n', '\n', '    \n', '}\n', '\n', 'contract Battle {\n', '    // This struct does not exist outside the context of a battle\n', '\n', '    // the name of the battle type\n', '    function name() external view returns (string);\n', '    // the number of robots currently battling\n', '    function playerCount() external view returns (uint count);\n', '    // creates a new battle, with a submitted user string for initial input/\n', '    function createBattle(address _creator, uint[] _partIds, bytes32 _commit, uint _revealLength) external payable returns (uint);\n', '    // cancels the battle at battleID\n', '    function cancelBattle(uint battleID) external;\n', '    \n', '    function winnerOf(uint battleId, uint index) external view returns (address);\n', '    function loserOf(uint battleId, uint index) external view returns (address);\n', '\n', '    event BattleCreated(uint indexed battleID, address indexed starter);\n', '    event BattleStage(uint indexed battleID, uint8 moveNumber, uint8[2] attackerMovesDefenderMoves, uint16[2] attackerDamageDefenderDamage);\n', '    event BattleEnded(uint indexed battleID, address indexed winner);\n', '    event BattleConcluded(uint indexed battleID);\n', '    event BattlePropertyChanged(string name, uint previous, uint value);\n', '}\n', 'contract EtherbotsBattle is EtherbotsMigrations {\n', '\n', '    // can never remove any of these contracts, can only add\n', '    // once we publish a contract, you&#39;ll always be able to play by that ruleset\n', '    // good for two player games which are non-susceptible to collusion\n', '    // people can be trusted to choose the most beneficial outcome, which in this case\n', '    // is the fairest form of gameplay.\n', '    // fields which are vulnerable to collusion still have to be centrally controlled :(\n', '    function addApprovedBattle(Battle _battle) external onlyOwner {\n', '        approvedBattles.push(_battle);\n', '    }\n', '\n', '    function _isApprovedBattle() internal view returns (bool) {\n', '        for (uint8 i = 0; i < approvedBattles.length; i++) {\n', '            if (msg.sender == address(approvedBattles[i])) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    modifier onlyApprovedBattles(){\n', '        require(_isApprovedBattle());\n', '        _;\n', '    }\n', '\n', '\n', '    function createBattle(uint _battleId, uint[] partIds, bytes32 commit, uint revealLength) external payable {\n', '        // sanity check to make sure _battleId is a valid battle\n', '        require(_battleId < approvedBattles.length);\n', '        //if parts are given, make sure they are owned\n', '        if (partIds.length > 0) {\n', '            require(ownsAll(msg.sender, partIds));\n', '        }\n', '        //battle can decide number of parts required for battle\n', '\n', '        Battle battle = Battle(approvedBattles[_battleId]);\n', '        // Transfer all to selected battle contract.\n', '        for (uint i=0; i<partIds.length; i++) {\n', '            _approve(partIds[i], address(battle));\n', '        }\n', '        uint newDuelId = battle.createBattle.value(msg.value)(msg.sender, partIds, commit, revealLength);\n', '        NewDuel(_battleId, newDuelId);\n', '    }\n', '\n', '    event NewDuel(uint battleId, uint duelId);\n', '\n', '\n', '    mapping(address => Reward[]) public pendingRewards;\n', '    // actually probably just want a length getter here as default public mapping getters\n', '    // are pretty expensive\n', '\n', '    function getPendingBattleRewardsCount(address _user) external view returns (uint) {\n', '        return pendingRewards[_user].length;\n', '    } \n', '\n', '    struct Reward {\n', '        uint blocknumber;\n', '        int32 exp;\n', '    }\n', '\n', '    function addExperience(address _user, uint[] _partIds, int32[] _exps) external onlyApprovedBattles {\n', '        address user = _user;\n', '        require(_partIds.length == _exps.length);\n', '        int32 sum = 0;\n', '        for (uint i = 0; i < _exps.length; i++) {\n', '            sum += _addPartExperience(_partIds[i], _exps[i]);\n', '        }\n', '        _addUserExperience(user, sum);\n', '        _storeReward(user, sum);\n', '    }\n', '\n', '    // store sum.\n', '    function _storeReward(address _user, int32 _battleExp) internal {\n', '        pendingRewards[_user].push(Reward({\n', '            blocknumber: 0,\n', '            exp: _battleExp\n', '        }));\n', '    }\n', '\n', '    /* function _getExpProportion(int _exp) returns(int) {\n', '        // assume max/min of 1k, -1k\n', '        return 1000 + _exp + 1; // makes it between (1, 2001)\n', '    } */\n', '    uint8 bestMultiple = 3;\n', '    uint8 mediumMultiple = 2;\n', '    uint8 worstMultiple = 1;\n', '    uint8 minShards = 1;\n', '    uint8 bestProbability = 97;\n', '    uint8 mediumProbability = 85;\n', '    function _getExpMultiple(int _exp) internal view returns (uint8, uint8) {\n', '        if (_exp > 500) {\n', '            return (bestMultiple,mediumMultiple);\n', '        } else if (_exp > 0) {\n', '            return (mediumMultiple,mediumMultiple);\n', '        } else {\n', '            return (worstMultiple,mediumMultiple);\n', '        }\n', '    }\n', '\n', '    function setBest(uint8 _newBestMultiple) external onlyOwner {\n', '        bestMultiple = _newBestMultiple;\n', '    }\n', '    function setMedium(uint8 _newMediumMultiple) external onlyOwner {\n', '        mediumMultiple = _newMediumMultiple;\n', '    }\n', '    function setWorst(uint8 _newWorstMultiple) external onlyOwner {\n', '        worstMultiple = _newWorstMultiple;\n', '    }\n', '    function setMinShards(uint8 _newMin) external onlyOwner {\n', '        minShards = _newMin;\n', '    }\n', '    function setBestProbability(uint8 _newBestProb) external onlyOwner {\n', '        bestProbability = _newBestProb;\n', '    }\n', '    function setMediumProbability(uint8 _newMinProb) external onlyOwner {\n', '        mediumProbability = _newMinProb;\n', '    }\n', '\n', '\n', '\n', '    function _calculateShards(int _exp, uint rand) internal view returns (uint16) {\n', '        var (a, b) = _getExpMultiple(_exp);\n', '        uint16 shards;\n', '        uint randPercent = rand % 100;\n', '        if (randPercent > bestProbability) {\n', '            shards = uint16(a * ((rand % 20) + 12) / b);\n', '        } else if (randPercent > mediumProbability) {\n', '            shards = uint16(a * ((rand % 10) + 6) / b);  \n', '        } else {\n', '            shards = uint16((a * (rand % 5)) / b);       \n', '        }\n', '\n', '        if (shards < minShards) {\n', '            shards = minShards;\n', '        }\n', '\n', '        return shards;\n', '    }\n', '\n', '    // convert wins into pending battle crates\n', '    // Not to pending old crates (migration), nor pending part crates (redeemShards)\n', '    function convertReward() external {\n', '\n', '        Reward[] storage rewards = pendingRewards[msg.sender];\n', '\n', '        for (uint i = 0; i < rewards.length; i++) {\n', '            if (rewards[i].blocknumber == 0) {\n', '                rewards[i].blocknumber = block.number;\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    // in PerksRewards\n', '    function redeemBattleCrates() external {\n', '        uint8 count = 0;\n', '        uint len = pendingRewards[msg.sender].length;\n', '        require(len > 0);\n', '        for (uint i = 0; i < len; i++) {\n', '            Reward memory rewardStruct = pendingRewards[msg.sender][i];\n', '            // can&#39;t open on the same timestamp\n', '            require(block.number > rewardStruct.blocknumber);\n', '            // ensure user has converted all pendingRewards\n', '            require(rewardStruct.blocknumber != 0);\n', '\n', '            var hash = block.blockhash(rewardStruct.blocknumber);\n', '\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i));\n', '                _generateBattleReward(rand,rewardStruct.exp);\n', '                count++;\n', '            } else {\n', '                // Do nothing, no second chances to secure integrity of randomness.\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete pendingRewards[msg.sender];\n', '    }\n', '\n', '    function _generateBattleReward(uint rand, int32 exp) internal {\n', '        if (((rand % 1000) > PART_REWARD_CHANCE) && (exp > 0)) {\n', '            _generateRandomPart(rand, msg.sender);\n', '        } else {\n', '            _addShardsToUser(addressToUser[msg.sender], _calculateShards(exp, rand));\n', '        }\n', '    }\n', '\n', '    // don&#39;t need to do any scaling\n', '    // should already have been done by previous stages\n', '    function _addUserExperience(address user, int32 exp) internal {\n', '        // never allow exp to drop below 0\n', '        User memory u = addressToUser[user];\n', '        if (exp < 0 && uint32(int32(u.experience) + exp) > u.experience) {\n', '            u.experience = 0;\n', '            return;\n', '        } else if (exp > 0) {\n', '            // check for overflow\n', '            require(uint32(int32(u.experience) + exp) > u.experience);\n', '        }\n', '        addressToUser[user].experience = uint32(int32(u.experience) + exp);\n', '        //_addUserReward(user, exp);\n', '    }\n', '\n', '    function setMinScaled(int8 _min) external onlyOwner {\n', '        minScaled = _min;\n', '    }\n', '\n', '    int8 minScaled = 25;\n', '\n', '    function _scaleExp(uint32 _battleCount, int32 _exp) internal view returns (int32) {\n', '        if (_battleCount <= 10) {\n', '            return _exp; // no drop off\n', '        }\n', '        int32 exp =  (_exp * 10)/int32(_battleCount);\n', '\n', '        if (exp < minScaled) {\n', '            return minScaled;\n', '        }\n', '        return exp;\n', '    }\n', '\n', '    function _addPartExperience(uint _id, int32 _baseExp) internal returns (int32) {\n', '        // never allow exp to drop below 0\n', '        Part storage p = parts[_id];\n', '        if (now - p.battlesLastReset > 24 hours) {\n', '            p.battlesLastReset = uint32(now);\n', '            p.battlesLastDay = 0;\n', '        }\n', '        p.battlesLastDay++;\n', '        int32 exp = _baseExp;\n', '        if (exp > 0) {\n', '            exp = _scaleExp(p.battlesLastDay, _baseExp);\n', '        }\n', '\n', '        if (exp < 0 && uint32(int32(p.experience) + exp) > p.experience) {\n', '            // check for wrap-around\n', '            p.experience = 0;\n', '            return;\n', '        } else if (exp > 0) {\n', '            // check for overflow\n', '            require(uint32(int32(p.experience) + exp) > p.experience);\n', '        }\n', '\n', '        parts[_id].experience = uint32(int32(parts[_id].experience) + exp);\n', '        return exp;\n', '    }\n', '\n', '    function totalLevel(uint[] partIds) public view returns (uint32) {\n', '        uint32 total = 0;\n', '        for (uint i = 0; i < partIds.length; i++) {\n', '            total += getLevel(parts[partIds[i]].experience);\n', '        }\n', '        return total;\n', '    }\n', '\n', '    //requires parts in order\n', '    function hasOrderedRobotParts(uint[] partIds) external view returns(bool) {\n', '        uint len = partIds.length;\n', '        if (len != 4) {\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < len; i++) {\n', '            if (parts[partIds[i]].partType != i+1) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract EtherbotsCore is EtherbotsBattle {\n', '\n', '    // The structure of Etherbots is modelled on CryptoKitties for obvious reasons:\n', '    // ease of implementation, tried + tested etc.\n', '    // it elides some features and includes some others.\n', '\n', '    // The full system is implemented in the following manner:\n', '    //\n', '    // EtherbotsBase    | Storage and base types\n', '    // EtherbotsAccess  | Access Control - who can change which state vars etc.\n', '    // EtherbotsNFT     | ERC721 Implementation\n', '    // EtherbotsBattle  | Battle interface contract: only one implementation currently, but could add more later.\n', '    // EtherbotsAuction | Auction interface contract\n', '\n', '\n', '    function EtherbotsCore() public {\n', '        // Starts paused.\n', '        paused = true;\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    \n', '    function() external payable {\n', '    }\n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', ' // Pause functionality taken from OpenZeppelin. License below.\n', ' /* The MIT License (MIT)\n', ' Copyright (c) 2016 Smart Contract Solutions, Inc.\n', ' Permission is hereby granted, free of charge, to any person obtaining\n', ' a copy of this software and associated documentation files (the\n', ' "Software"), to deal in the Software without restriction, including\n', ' without limitation the rights to use, copy, modify, merge, publish,\n', ' distribute, sublicense, and/or sell copies of the Software, and to\n', ' permit persons to whom the Software is furnished to do so, subject to\n', ' the following conditions: */\n', '\n', ' /**\n', '  * @title Pausable\n', '  * @dev Base contract which allows children to implement an emergency stop mechanism.\n', '  */\n', 'contract Pausable is Ownable {\n', '\n', '  event SetPaused(bool paused);\n', '\n', '  // starts unpaused\n', '  bool public paused = false;\n', '\n', '  /* @dev modifier to allow actions only when the contract IS paused */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /* @dev modifier to allow actions only when the contract IS NOT paused */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '  function unpause() public onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract EtherbotsPrivileges is Pausable {\n', '  event ContractUpgrade(address newContract);\n', '\n', '}\n', '\n', '\n', '\n', '// This contract implements both the original ERC-721 standard and\n', "// the proposed 'deed' standard of 841\n", "// I don't know which standard will eventually be adopted - support both for now\n", '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Deed Standard\n', '/// @author William Entriken (https://phor.net), et. al.\n', '/// @dev Specification at https://github.com/ethereum/eips/841\n', '/// can read the comments there\n', 'contract ERC721 {\n', '\n', '    // COMPLIANCE WITH ERC-165 (DRAFT)\n', '\n', '    /// @dev ERC-165 (draft) interface signature for itself\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC165 =\n', '        bytes4(keccak256("supportsInterface(bytes4)"));\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721 =\n', '         bytes4(keccak256("ownerOf(uint256)")) ^\n', '         bytes4(keccak256("countOfDeeds()")) ^\n', '         bytes4(keccak256("countOfDeedsByOwner(address)")) ^\n', '         bytes4(keccak256("deedOfOwnerByIndex(address,uint256)")) ^\n', '         bytes4(keccak256("approve(address,uint256)")) ^\n', '         bytes4(keccak256("takeOwnership(uint256)"));\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\n', '\n', '    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\n', '\n', '    function ownerOf(uint256 _deedId) public view returns (address _owner);\n', '    function countOfDeeds() external view returns (uint256 _count);\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\n', '\n', '    // TRANSFER MECHANISM //////////////////////////////////////////////////////\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed deedId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);\n', '\n', '    function approve(address _to, uint256 _deedId) external payable;\n', '    function takeOwnership(uint256 _deedId) external payable;\n', '}\n', '\n', '/// @title Metadata extension to ERC-721 interface\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Specification at https://github.com/ethereum/eips/issues/XXXX\n', 'contract ERC721Metadata is ERC721 {\n', '\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Metadata =\n', '        bytes4(keccak256("name()")) ^\n', '        bytes4(keccak256("symbol()")) ^\n', '        bytes4(keccak256("deedUri(uint256)"));\n', '\n', '    function name() public pure returns (string n);\n', '    function symbol() public pure returns (string s);\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _uri);\n', '}\n', '\n', '/// @title Enumeration extension to ERC-721 interface\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Specification at https://github.com/ethereum/eips/issues/XXXX\n', 'contract ERC721Enumerable is ERC721Metadata {\n', '\n', '    /// @dev ERC-165 (draft) interface signature for ERC721\n', '    bytes4 internal constant INTERFACE_SIGNATURE_ERC721Enumerable =\n', '        bytes4(keccak256("deedByIndex()")) ^\n', '        bytes4(keccak256("countOfOwners()")) ^\n', '        bytes4(keccak256("ownerByIndex(uint256)"));\n', '\n', '    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);\n', '    function countOfOwners() external view returns (uint256 _count);\n', '    function ownerByIndex(uint256 _index) external view returns (address _owner);\n', '}\n', '\n', 'contract ERC721Original {\n', '\n', '    bytes4 constant INTERFACE_SIGNATURE_ERC721Original =\n', '        bytes4(keccak256("totalSupply()")) ^\n', '        bytes4(keccak256("balanceOf(address)")) ^\n', '        bytes4(keccak256("ownerOf(uint256)")) ^\n', '        bytes4(keccak256("approve(address,uint256)")) ^\n', '        bytes4(keccak256("takeOwnership(uint256)")) ^\n', '        bytes4(keccak256("transfer(address,uint256)"));\n', '\n', '    // Core functions\n', '    function implementsERC721() public pure returns (bool);\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) external payable;\n', '    function transferFrom(address _from, address _to, uint _tokenId) public;\n', '    function transfer(address _to, uint _tokenId) public payable;\n', '\n', '    // Optional functions\n', '    function name() public pure returns (string _name);\n', '    function symbol() public pure returns (string _symbol);\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId);\n', '    function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '\n', '    // Events\n', '    // event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    // event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '}\n', '\n', 'contract ERC721AllImplementations is ERC721Original, ERC721Enumerable {\n', '\n', '}\n', '\n', 'contract EtherbotsBase is EtherbotsPrivileges {\n', '\n', '\n', '    function EtherbotsBase() public {\n', '    //   scrapyard = address(this);\n', '    }\n', '    /*** EVENTS ***/\n', '\n', '    ///  Forge fires when a new part is created - 4 times when a crate is opened,\n', '    /// and once when a battle takes place. Also has fires when\n', '    /// parts are combined in the furnace.\n', '    event Forge(address owner, uint256 partID, Part part);\n', '\n', '    ///  Transfer event as defined in ERC721.\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    /*** DATA TYPES ***/\n', '    ///  The main struct representation of a robot part. Each robot in Etherbots is represented by four copies\n', '    ///  of this structure, one for each of the four parts comprising it:\n', '    /// 1. Right Arm (Melee),\n', '    /// 2. Left Arm (Defence),\n', '    /// 3. Head (Turret),\n', '    /// 4. Body.\n', '    // store token id on this?\n', '     struct Part {\n', '        uint32 tokenId;\n', '        uint8 partType;\n', '        uint8 partSubType;\n', '        uint8 rarity;\n', '        uint8 element;\n', '        uint32 battlesLastDay;\n', '        uint32 experience;\n', '        uint32 forgeTime;\n', '        uint32 battlesLastReset;\n', '    }\n', '\n', '    // Part type - can be shared with other part factories.\n', '    uint8 constant DEFENCE = 1;\n', '    uint8 constant MELEE = 2;\n', '    uint8 constant BODY = 3;\n', '    uint8 constant TURRET = 4;\n', '\n', '    // Rarity - can be shared with other part factories.\n', '    uint8 constant STANDARD = 1;\n', '    uint8 constant SHADOW = 2;\n', '    uint8 constant GOLD = 3;\n', '\n', '\n', '    // Store a user struct\n', '    // in order to keep track of experience and perk choices.\n', '    // This perk tree is a binary tree, efficiently encodable as an array.\n', '    // 0 reflects no perk selected. 1 is first choice. 2 is second. 3 is both.\n', '    // Each choice costs experience (deducted from user struct).\n', '\n', '    /*** ~~~~~ROBOT PERKS~~~~~ ***/\n', '    // PERK 1: ATTACK vs DEFENCE PERK CHOICE.\n', '    // Choose\n', '    // PERK TWO ATTACK/ SHOOT, or DEFEND/DODGE\n', '    // PERK 2: MECH vs ELEMENTAL PERK CHOICE ---\n', '    // Choose steel and electric (Mech path), or water and fire (Elemetal path)\n', '    // (... will the mechs win the war for Ethertopia? or will the androids\n', '    // be deluged in flood and fire? ...)\n', '    // PERK 3: Commit to a specific elemental pathway:\n', '    // 1. the path of steel: the iron sword; the burning frying pan!\n', '    // 2. the path of electricity: the deadly taser, the fearsome forcefield\n', '    // 3. the path of water: high pressure water blasters have never been so cool\n', '    // 4. the path of fire!: we will hunt you down, Aang...\n', '\n', '\n', '    struct User {\n', '        // address userAddress;\n', '        uint32 numShards; //limit shards to upper bound eg 10000\n', '        uint32 experience;\n', '        uint8[32] perks;\n', '    }\n', '\n', '    //Maintain an array of all users.\n', '    // User[] public users;\n', '\n', '    // Store a map of the address to a uint representing index of User within users\n', '    // we check if a user exists at multiple points, every time they acquire\n', '    // via a crate or the market. Users can also manually register their address.\n', '    mapping ( address => User ) public addressToUser;\n', '\n', '    // Array containing the structs of all parts in existence. The ID\n', '    // of each part is an index into this array.\n', '    Part[] parts;\n', '\n', '    // Mapping from part IDs to to owning address. Should always exist.\n', '    mapping (uint256 => address) public partIndexToOwner;\n', '\n', '    //  A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count. REMOVE?\n', '    mapping (address => uint256) addressToTokensOwned;\n', '\n', '    // Mapping from Part ID to an address approved to call transferFrom().\n', '    // maximum of one approved address for transfer at any time.\n', '    mapping (uint256 => address) public partIndexToApproved;\n', '\n', '    address auction;\n', '    // address scrapyard;\n', '\n', '    // Array to store approved battle contracts.\n', '    // Can only ever be added to, not removed from.\n', '    // Once a ruleset is published, you will ALWAYS be able to use that contract\n', '    address[] approvedBattles;\n', '\n', '\n', '    function getUserByAddress(address _user) public view returns (uint32, uint8[32]) {\n', '        return (addressToUser[_user].experience, addressToUser[_user].perks);\n', '    }\n', '\n', '    //  Transfer a part to an address\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        // No cap on number of parts\n', '        // Very unlikely to ever be 2^256 parts owned by one account\n', "        // Shouldn't waste gas checking for overflow\n", "        // no point making it less than a uint --> mappings don't pack\n", '        addressToTokensOwned[_to]++;\n', '        // transfer ownership\n', '        partIndexToOwner[_tokenId] = _to;\n', "        // New parts are transferred _from 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            addressToTokensOwned[_from]--;\n', '            // clear any previously approved ownership exchange\n', '            delete partIndexToApproved[_tokenId];\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function getPartById(uint _id) external view returns (\n', '        uint32 tokenId,\n', '        uint8 partType,\n', '        uint8 partSubType,\n', '        uint8 rarity,\n', '        uint8 element,\n', '        uint32 battlesLastDay,\n', '        uint32 experience,\n', '        uint32 forgeTime,\n', '        uint32 battlesLastReset\n', '    ) {\n', '        Part memory p = parts[_id];\n', '        return (p.tokenId, p.partType, p.partSubType, p.rarity, p.element, p.battlesLastDay, p.experience, p.forgeTime, p.battlesLastReset);\n', '    }\n', '\n', '\n', '    function substring(string str, uint startIndex, uint endIndex) internal pure returns (string) {\n', '        bytes memory strBytes = bytes(str);\n', '        bytes memory result = new bytes(endIndex-startIndex);\n', '        for (uint i = startIndex; i < endIndex; i++) {\n', '            result[i-startIndex] = strBytes[i];\n', '        }\n', '        return string(result);\n', '    }\n', '\n', '    // helper functions adapted from  Jossie Calderon on stackexchange\n', '    function stringToUint32(string s) internal pure returns (uint32) {\n', '        bytes memory b = bytes(s);\n', '        uint result = 0;\n', '        for (uint i = 0; i < b.length; i++) { // c = b[i] was not needed\n', '            if (b[i] >= 48 && b[i] <= 57) {\n', '                result = result * 10 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\n', '            }\n', '        }\n', '        return uint32(result);\n', '    }\n', '\n', '    function stringToUint8(string s) internal pure returns (uint8) {\n', '        return uint8(stringToUint32(s));\n', '    }\n', '\n', '    function uintToString(uint v) internal pure returns (string) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i); // i + 1 is inefficient\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n', '        }\n', '        string memory str = string(s);\n', '        return str;\n', '    }\n', '}\n', 'contract EtherbotsNFT is EtherbotsBase, ERC721Enumerable, ERC721Original {\n', '    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n', '        return (_interfaceID == ERC721Original.INTERFACE_SIGNATURE_ERC721Original) ||\n', '            (_interfaceID == ERC721.INTERFACE_SIGNATURE_ERC721) ||\n', '            (_interfaceID == ERC721Metadata.INTERFACE_SIGNATURE_ERC721Metadata) ||\n', '            (_interfaceID == ERC721Enumerable.INTERFACE_SIGNATURE_ERC721Enumerable);\n', '    }\n', '    function implementsERC721() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function name() public pure returns (string _name) {\n', '      return "Etherbots";\n', '    }\n', '\n', '    function symbol() public pure returns (string _smbol) {\n', '      return "ETHBOT";\n', '    }\n', '\n', '    // total supply of parts --> as no parts are ever deleted, this is simply\n', '    // the total supply of parts ever created\n', '    function totalSupply() public view returns (uint) {\n', '        return parts.length;\n', '    }\n', '\n', '    /// @notice Returns the total number of deeds currently in existence.\n', '    /// @dev Required for ERC-721 compliance.\n', '    function countOfDeeds() external view returns (uint256) {\n', '        return parts.length;\n', '    }\n', '\n', '    //--/ internal function    which checks whether the token with id (_tokenId)\n', '    /// is owned by the (_claimant) address\n', '    function owns(address _owner, uint256 _tokenId) public view returns (bool) {\n', '        return (partIndexToOwner[_tokenId] == _owner);\n', '    }\n', '\n', '    /// internal function    which checks whether the token with id (_tokenId)\n', '    /// is owned by the (_claimant) address\n', '    function ownsAll(address _owner, uint256[] _tokenIds) public view returns (bool) {\n', '        require(_tokenIds.length > 0);\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            if (partIndexToOwner[_tokenIds[i]] != _owner) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        partIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    function _approvedFor(address _newOwner, uint256 _tokenId) internal view returns (bool) {\n', '        return (partIndexToApproved[_tokenId] == _newOwner);\n', '    }\n', '\n', '    function ownerByIndex(uint256 _index) external view returns (address _owner){\n', '        return partIndexToOwner[_index];\n', '    }\n', '\n', '    // returns the NUMBER of tokens owned by (_owner)\n', '    function balanceOf(address _owner) public view returns (uint256 count) {\n', '        return addressToTokensOwned[_owner];\n', '    }\n', '\n', '    function countOfDeedsByOwner(address _owner) external view returns (uint256) {\n', '        return balanceOf(_owner);\n', '    }\n', '\n', '    // transfers a part to another account\n', '    function transfer(address _to, uint256 _tokenId) public whenNotPaused payable {\n', "        // payable for ERC721 --> don't actually send eth @_@\n", '        require(msg.value == 0);\n', '\n', '        // Safety checks to prevent accidental transfers to common accounts\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', "        // can't transfer parts to the auction contract directly\n", '        require(_to != address(auction));\n', "        // can't transfer parts to any of the battle contracts directly\n", '        for (uint j = 0; j < approvedBattles.length; j++) {\n', '            require(_to != approvedBattles[j]);\n', '        }\n', '\n', "        // Cannot send tokens you don't own\n", '        require(owns(msg.sender, _tokenId));\n', '\n', '        // perform state changes necessary for transfer\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '    // transfers a part to another account\n', '\n', '    function transferAll(address _to, uint256[] _tokenIds) public whenNotPaused payable {\n', '        require(msg.value == 0);\n', '\n', '        // Safety checks to prevent accidental transfers to common accounts\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', "        // can't transfer parts to the auction contract directly\n", '        require(_to != address(auction));\n', "        // can't transfer parts to any of the battle contracts directly\n", '        for (uint j = 0; j < approvedBattles.length; j++) {\n', '            require(_to != approvedBattles[j]);\n', '        }\n', '\n', "        // Cannot send tokens you don't own\n", '        require(ownsAll(msg.sender, _tokenIds));\n', '\n', '        for (uint k = 0; k < _tokenIds.length; k++) {\n', '            // perform state changes necessary for transfer\n', '            _transfer(msg.sender, _to, _tokenIds[k]);\n', '        }\n', '\n', '\n', '    }\n', '\n', '\n', '    // approves the (_to) address to use the transferFrom function on the token with id (_tokenId)\n', '    // if you want to clear all approvals, simply pass the zero address\n', '    function approve(address _to, uint256 _deedId) external whenNotPaused payable {\n', "        // payable for ERC721 --> don't actually send eth @_@\n", '        require(msg.value == 0);\n', '// use internal function?\n', "        // Cannot approve the transfer of tokens you don't own\n", '        require(owns(msg.sender, _deedId));\n', '\n', '        // Store the approval (can only approve one at a time)\n', '        partIndexToApproved[_deedId] = _to;\n', '\n', '        Approval(msg.sender, _to, _deedId);\n', '    }\n', '\n', '    // approves many token ids\n', '    function approveMany(address _to, uint256[] _tokenIds) external whenNotPaused payable {\n', '\n', '        for (uint i = 0; i < _tokenIds.length; i++) {\n', '            uint _tokenId = _tokenIds[i];\n', '\n', "            // Cannot approve the transfer of tokens you don't own\n", '            require(owns(msg.sender, _tokenId));\n', '\n', '            // Store the approval (can only approve one at a time)\n', '            partIndexToApproved[_tokenId] = _to;\n', '            //create event for each approval? _tokenId guaranteed to hold correct value?\n', '            Approval(msg.sender, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    // transfer the part with id (_tokenId) from (_from) to (_to)\n', '    // (_to) must already be approved for this (_tokenId)\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '\n', '        // Safety checks to prevent accidents\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '\n', '        // sender must be approved\n', '        require(partIndexToApproved[_tokenId] == msg.sender);\n', '        // from must currently own the token\n', '        require(owns(_from, _tokenId));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    // returns the current owner of the token with id = _tokenId\n', '    function ownerOf(uint256 _deedId) public view returns (address _owner) {\n', '        _owner = partIndexToOwner[_deedId];\n', '        // must result false if index key not found\n', '        require(_owner != address(0));\n', '    }\n', '\n', '    // returns a dynamic array of the ids of all tokens which are owned by (_owner)\n', '    // Looping through every possible part and checking it against the owner is\n', '    // actually much more efficient than storing a mapping or something, because\n', "    // it won't be executed as a transaction\n", '    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n', '        uint256 totalParts = totalSupply();\n', '\n', '        return tokensOfOwnerWithinRange(_owner, 0, totalParts);\n', '  \n', '    }\n', '\n', '    function tokensOfOwnerWithinRange(address _owner, uint _start, uint _numToSearch) public view returns(uint256[] ownerTokens) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint256[] memory tmpResult = new uint256[](tokenCount);\n', '        if (tokenCount == 0) {\n', '            return tmpResult;\n', '        }\n', '\n', '        uint256 resultIndex = 0;\n', '        for (uint partId = _start; partId < _start + _numToSearch; partId++) {\n', '            if (partIndexToOwner[partId] == _owner) {\n', '                tmpResult[resultIndex] = partId;\n', '                resultIndex++;\n', '                if (resultIndex == tokenCount) { //found all tokens accounted for, no need to continue\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        // copy number of tokens found in given range\n', '        uint resultLength = resultIndex;\n', '        uint256[] memory result = new uint256[](resultLength);\n', '        for (uint i=0; i<resultLength; i++) {\n', '            result[i] = tmpResult[i];\n', '        }\n', '        return result;\n', '    }\n', '\n', '\n', '\n', '    //same issues as above\n', '    // Returns an array of all part structs owned by the user. Free to call.\n', '    function getPartsOfOwner(address _owner) external view returns(bytes24[]) {\n', '        uint256 totalParts = totalSupply();\n', '\n', '        return getPartsOfOwnerWithinRange(_owner, 0, totalParts);\n', '    }\n', '    \n', '    // This is public so it can be called by getPartsOfOwner. It should NOT be called by another contract\n', '    // as it is very gas hungry.\n', '    function getPartsOfOwnerWithinRange(address _owner, uint _start, uint _numToSearch) public view returns(bytes24[]) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '\n', '        uint resultIndex = 0;\n', '        bytes24[] memory result = new bytes24[](tokenCount);\n', '        for (uint partId = _start; partId < _start + _numToSearch; partId++) {\n', '            if (partIndexToOwner[partId] == _owner) {\n', '                result[resultIndex] = _partToBytes(parts[partId]);\n', '                resultIndex++;\n', '            }\n', '        }\n', '        return result; // will have 0 elements if tokenCount == 0\n', '    }\n', '\n', '\n', '    function _partToBytes(Part p) internal pure returns (bytes24 b) {\n', '        b = bytes24(p.tokenId);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.partType);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.partSubType);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.rarity);\n', '\n', '        b = b << 8;\n', '        b = b | bytes24(p.element);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.battlesLastDay);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.experience);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.forgeTime);\n', '\n', '        b = b << 32;\n', '        b = b | bytes24(p.battlesLastReset);\n', '    }\n', '\n', '    uint32 constant FIRST_LEVEL = 1000;\n', '    uint32 constant INCREMENT = 1000;\n', '\n', '    // every level, you need 1000 more exp to go up a level\n', '    function getLevel(uint32 _exp) public pure returns(uint32) {\n', '        uint32 c = 0;\n', '        for (uint32 i = FIRST_LEVEL; i <= FIRST_LEVEL + _exp; i += c * INCREMENT) {\n', '            c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    string metadataBase = "https://api.etherbots.io/api/";\n', '\n', '\n', '    function setMetadataBase(string _base) external onlyOwner {\n', '        metadataBase = _base;\n', '    }\n', '\n', '    // part type, subtype,\n', '    // have one internal function which lets us implement the divergent interfaces\n', '    function _metadata(uint256 _id) internal view returns(string) {\n', '        Part memory p = parts[_id];\n', '        return strConcat(strConcat(\n', '            metadataBase,\n', '            uintToString(uint(p.partType)),\n', '            "/",\n', '            uintToString(uint(p.partSubType)),\n', '            "/"\n', '        ), uintToString(uint(p.rarity)), "", "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '\n', '    /// @notice A distinct URI (RFC 3986) for a given token.\n', '    /// @dev If:\n', '    ///  * The URI is a URL\n', '    ///  * The URL is accessible\n', '    ///  * The URL points to a valid JSON file format (ECMA-404 2nd ed.)\n', '    ///  * The JSON base element is an object\n', '    ///  then these names of the base element SHALL have special meaning:\n', '    ///  * "name": A string identifying the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "description": A string detailing the item to which `_deedId` grants\n', '    ///    ownership\n', '    ///  * "image": A URI pointing to a file of image/* mime type representing\n', '    ///    the item to which `_deedId` grants ownership\n', '    ///  Wallets and exchanges MAY display this to the end user.\n', '    ///  Consider making any images at a width between 320 and 1080 pixels and\n', '    ///  aspect ratio between 1.91:1 and 4:5 inclusive.\n', '    function deedUri(uint256 _deedId) external view returns (string _uri){\n', '        return _metadata(_deedId);\n', '    }\n', '\n', '    /// returns a metadata URI\n', '    function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl) {\n', '        return _metadata(_tokenId);\n', '    }\n', '\n', '    function takeOwnership(uint256 _deedId) external payable {\n', "        // payable for ERC721 --> don't actually send eth @_@\n", '        require(msg.value == 0);\n', '\n', '        address _from = partIndexToOwner[_deedId];\n', '\n', '        require(_approvedFor(msg.sender, _deedId));\n', '\n', '        _transfer(_from, msg.sender, _deedId);\n', '    }\n', '\n', '    // parts are stored sequentially\n', '    function deedByIndex(uint256 _index) external view returns (uint256 _deedId){\n', '        return _index;\n', '    }\n', '\n', '    function countOfOwners() external view returns (uint256 _count){\n', '        // TODO: implement this\n', '        return 0;\n', '    }\n', '\n', '// thirsty function\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint _tokenId){\n', '        return _tokenOfOwnerByIndex(_owner, _index);\n', '    }\n', '\n', '// code duplicated\n', '    function _tokenOfOwnerByIndex(address _owner, uint _index) private view returns (uint _tokenId){\n', '        // The index should be valid.\n', '        require(_index < balanceOf(_owner));\n', '\n', '        // can loop through all without\n', '        uint256 seen = 0;\n', '        uint256 totalTokens = totalSupply();\n', '\n', '        for (uint i = 0; i < totalTokens; i++) {\n', '            if (partIndexToOwner[i] == _owner) {\n', '                if (seen == _index) {\n', '                    return i;\n', '                }\n', '                seen++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId){\n', '        return _tokenOfOwnerByIndex(_owner, _index);\n', '    }\n', '}\n', '\n', '// the contract which all battles must implement\n', '// allows for different types of battles to take place\n', 'contract PerkTree is EtherbotsNFT {\n', '    // The perktree is represented in a uint8[32] representing a binary tree\n', '    // see the number of perks active\n', '    // buy a new perk\n', '    // 0: Prestige level -> starts at 0;\n', '    // next row of tree\n', '    // 1: offensive moves 2: defensive moves\n', '    // next row of tree\n', '    // 3: melee attack 4: turret shooting 5: defend arm 6: body dodge\n', '    // next row of tree\n', '    // 7: mech melee 8: android melee 9: mech turret 10: android turret\n', '    // 11: mech defence 12: android defence 13: mech body 14: android body\n', '    //next row of tree\n', '    // 15: melee electric 16: melee steel 17: melee fire 18: melee water\n', '    // 19: turret electric 20: turret steel 21: turret fire 22: turret water\n', '    // 23: defend electric 24: defend steel 25: defend fire 26: defend water\n', '    // 27: body electric 28: body steel 29: body fire 30: body water\n', '    function _leftChild(uint8 _i) internal pure returns (uint8) {\n', '        return 2*_i + 1;\n', '    }\n', '    function _rightChild(uint8 _i) internal pure returns (uint8) {\n', '        return 2*_i + 2;\n', '    }\n', '    function _parent(uint8 _i) internal pure returns (uint8) {\n', '        return (_i-1)/2;\n', '    }\n', '\n', '\n', '    uint8 constant PRESTIGE_INDEX = 0;\n', '    uint8 constant PERK_COUNT = 30;\n', '\n', '    event PrintPerk(string,uint8,uint8[32]);\n', '\n', '    function _isValidPerkToAdd(uint8[32] _perks, uint8 _index) internal pure returns (bool) {\n', '        // a previously unlocked perk is not a valid perk to add.\n', '        if ((_index==PRESTIGE_INDEX) || (_perks[_index] > 0)) {\n', '            return false;\n', '        }\n', '        // perk not valid if any ancestor not unlocked\n', '        for (uint8 i = _parent(_index); i > PRESTIGE_INDEX; i = _parent(i)) {\n', '            if (_perks[i] == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // sum of perks (excluding prestige)\n', '    function _sumActivePerks(uint8[32] _perks) internal pure returns (uint256) {\n', '        uint32 sum = 0;\n', '        //sum from after prestige_index, to count+1 (for prestige index).\n', '        for (uint8 i = PRESTIGE_INDEX+1; i < PERK_COUNT+1; i++) {\n', '            sum += _perks[i];\n', '        }\n', '        return sum;\n', '    }\n', '\n', '    // you can unlock a new perk every two levels (including prestige when possible)\n', '    function choosePerk(uint8 _i) external {\n', '        require((_i >= PRESTIGE_INDEX) && (_i < PERK_COUNT+1));\n', '        User storage currentUser = addressToUser[msg.sender];\n', '        uint256 _numActivePerks = _sumActivePerks(currentUser.perks);\n', '        bool canPrestige = (_numActivePerks == PERK_COUNT);\n', '\n', '        //add prestige value to sum of perks\n', '        _numActivePerks += currentUser.perks[PRESTIGE_INDEX] * PERK_COUNT;\n', '        require(_numActivePerks < getLevel(currentUser.experience) / 2);\n', '\n', '        if (_i == PRESTIGE_INDEX) {\n', '            require(canPrestige);\n', '            _prestige();\n', '        } else {\n', '            require(_isValidPerkToAdd(currentUser.perks, _i));\n', '            _addPerk(_i);\n', '        }\n', '        PerkChosen(msg.sender, _i);\n', '    }\n', '\n', '    function _addPerk(uint8 perk) internal {\n', '        addressToUser[msg.sender].perks[perk]++;\n', '    }\n', '\n', '    function _prestige() internal {\n', '        User storage currentUser = addressToUser[msg.sender];\n', '        for (uint8 i = 1; i < currentUser.perks.length; i++) {\n', '            currentUser.perks[i] = 0;\n', '        }\n', '        currentUser.perks[PRESTIGE_INDEX]++;\n', '    }\n', '\n', '    event PerkChosen(address indexed upgradedUser, uint8 indexed perk);\n', '\n', '}\n', '\n', '// Central collection of storage on which all other contracts depend.\n', '// Contains structs for parts, users and functions which control their\n', '// transferrence.\n', '\n', '\n', '// Auction contract, facilitating statically priced sales, as well as \n', '// inflationary and deflationary pricing for items.\n', '// Relies heavily on the ERC721 interface and so most of the methods\n', '// are tightly bound to that implementation\n', 'contract NFTAuctionBase is Pausable {\n', '\n', '    ERC721AllImplementations public nftContract;\n', '    uint256 public ownerCut;\n', '    uint public minDuration;\n', '    uint public maxDuration;\n', '\n', '    // Represents an auction on an NFT (in this case, Robot part)\n', '    struct Auction {\n', '        // address of part owner\n', '        address seller;\n', '        // wei price of listing\n', '        uint256 startPrice;\n', '        // wei price of floor\n', '        uint256 endPrice;\n', '        // duration of sale in seconds.\n', '        uint64 duration;\n', '        // Time when sale started\n', '        // Reset to 0 after sale concluded\n', '        uint64 start;\n', '    }\n', '\n', '    function NFTAuctionBase() public {\n', '        minDuration = 60 minutes;\n', '        maxDuration = 30 days; // arbitrary\n', '    }\n', '\n', '    // map of all tokens and their auctions\n', '    mapping (uint256 => Auction) tokenIdToAuction;\n', '\n', '    event AuctionCreated(uint256 tokenId, uint256 startPrice, uint256 endPrice, uint64 duration, uint64 start);\n', '    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\n', '    event AuctionCancelled(uint256 tokenId);\n', '\n', '    // returns true if the token with id _partId is owned by the _claimant address\n', '    function _owns(address _claimant, uint256 _partId) internal view returns (bool) {\n', '        return nftContract.ownerOf(_partId) == _claimant;\n', '    }\n', '\n', '   // returns false if auction start time is 0, likely from uninitialised struct\n', '    function _isActiveAuction(Auction _auction) internal pure returns (bool) {\n', '        return _auction.start > 0;\n', '    }\n', '    \n', '    // assigns ownership of the token with id = _partId to this contract\n', '    // must have already been approved\n', '    function _escrow(address, uint _partId) internal {\n', '        // throws on transfer fail\n', '        nftContract.takeOwnership(_partId);\n', '    }\n', '\n', '    // transfer the token with id = _partId to buying address\n', '    function _transfer(address _purchasor, uint256 _partId) internal {\n', '        // successful purchaseder must takeOwnership of _partId\n', '        // nftContract.approve(_purchasor, _partId); \n', '               // actual transfer\n', '                nftContract.transfer(_purchasor, _partId);\n', '\n', '    }\n', '\n', '    // creates\n', '    function _newAuction(uint256 _partId, Auction _auction) internal {\n', '\n', '        require(_auction.duration >= minDuration);\n', '        require(_auction.duration <= maxDuration);\n', '\n', '        tokenIdToAuction[_partId] = _auction;\n', '\n', '        AuctionCreated(uint256(_partId),\n', '            uint256(_auction.startPrice),\n', '            uint256(_auction.endPrice),\n', '            uint64(_auction.duration),\n', '            uint64(_auction.start)\n', '        );\n', '    }\n', '\n', '    function setMinDuration(uint _duration) external onlyOwner {\n', '        minDuration = _duration;\n', '    }\n', '\n', '    function setMaxDuration(uint _duration) external onlyOwner {\n', '        maxDuration = _duration;\n', '    }\n', '\n', '    /// Removes auction from public view, returns token to the seller\n', '    function _cancelAuction(uint256 _partId, address _seller) internal {\n', '        _removeAuction(_partId);\n', '        _transfer(_seller, _partId);\n', '        AuctionCancelled(_partId);\n', '    }\n', '\n', '    event PrintEvent(string, address, uint);\n', '\n', '    // Calculates price and transfers purchase to owner. Part is NOT transferred to buyer.\n', '    function _purchase(uint256 _partId, uint256 _purchaseAmount) internal returns (uint256) {\n', '\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '\n', '        // check that this token is being auctioned\n', '        require(_isActiveAuction(auction));\n', '\n', '        // enforce purchase >= the current price\n', '        uint256 price = _currentPrice(auction);\n', '        require(_purchaseAmount >= price);\n', '\n', '        // Store seller before we delete auction.\n', '        address seller = auction.seller;\n', '\n', '        // Valid purchase. Remove auction to prevent reentrancy.\n', '        _removeAuction(_partId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            \n', '            // Calculate and take fee from purchase\n', '\n', '            uint256 auctioneerCut = _computeFee(price);\n', '            uint256 sellerProceeds = price - auctioneerCut;\n', '\n', '            PrintEvent("Seller, proceeds", seller, sellerProceeds);\n', '\n', '            // Pay the seller\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate excess funds and return to buyer.\n', '        uint256 purchaseExcess = _purchaseAmount - price;\n', '\n', '        PrintEvent("Sender, excess", msg.sender, purchaseExcess);\n', '        // Return any excess funds. Reentrancy again prevented by deleting auction.\n', '        msg.sender.transfer(purchaseExcess);\n', '\n', '        AuctionSuccessful(_partId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    // returns the current price of the token being auctioned in _auction\n', '    function _currentPrice(Auction storage _auction) internal view returns (uint256) {\n', '        uint256 secsElapsed = now - _auction.start;\n', '        return _computeCurrentPrice(\n', '            _auction.startPrice,\n', '            _auction.endPrice,\n', '            _auction.duration,\n', '            secsElapsed\n', '        );\n', '    }\n', '\n', '    // Checks if NFTPart is currently being auctioned.\n', '    // function _isBeingAuctioned(Auction storage _auction) internal view returns (bool) {\n', '    //     return (_auction.start > 0);\n', '    // }\n', '\n', '    // removes the auction of the part with id _partId\n', '    function _removeAuction(uint256 _partId) internal {\n', '        delete tokenIdToAuction[_partId];\n', '    }\n', '\n', '    // computes the current price of an deflating-price auction \n', '    function _computeCurrentPrice( uint256 _startPrice, uint256 _endPrice, uint256 _duration, uint256 _secondsPassed ) internal pure returns (uint256 _price) {\n', '        _price = _startPrice;\n', '        if (_secondsPassed >= _duration) {\n', '            // Has been up long enough to hit endPrice.\n', '            // Return this price floor.\n', '            _price = _endPrice;\n', '            // this is a statically price sale. Just return the price.\n', '        }\n', '        else if (_duration > 0) {\n', '            // This auction contract supports auctioning from any valid price to any other valid price.\n', '            // This means the price can dynamically increase upward, or downard.\n', '            int256 priceDifference = int256(_endPrice) - int256(_startPrice);\n', '            int256 currentPriceDifference = priceDifference * int256(_secondsPassed) / int256(_duration);\n', '            int256 currentPrice = int256(_startPrice) + currentPriceDifference;\n', '\n', '            _price = uint256(currentPrice);\n', '        }\n', '        return _price;\n', '    }\n', '\n', '    // Compute percentage fee of transaction\n', '\n', '    function _computeFee (uint256 _price) internal view returns (uint256) {\n', '        return _price * ownerCut / 10000; \n', '    }\n', '\n', '}\n', '\n', '// Clock auction for NFTParts.\n', '// Only timed when pricing is dynamic (i.e. startPrice != endPrice).\n', '// Else, this becomes an infinite duration statically priced sale,\n', '// resolving when succesfully purchase for or cancelled.\n', '\n', 'contract DutchAuction is NFTAuctionBase, EtherbotsPrivileges {\n', '\n', '    // The ERC-165 interface signature for ERC-721.\n', '    bytes4 constant InterfaceSignature_ERC721 = bytes4(0xda671b9b);\n', ' \n', '    function DutchAuction(address _nftAddress, uint256 _fee) public {\n', '        require(_fee <= 10000);\n', '        ownerCut = _fee;\n', '\n', '        ERC721AllImplementations candidateContract = ERC721AllImplementations(_nftAddress);\n', '        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n', '        nftContract = candidateContract;\n', '    }\n', '\n', '    // Remove all ether from the contract. This will be marketplace fees.\n', '    // Transfers to the NFT contract. \n', '    // Can be called by owner or NFT contract.\n', '\n', '    function withdrawBalance() external {\n', '        address nftAddress = address(nftContract);\n', '\n', '        require(msg.sender == owner || msg.sender == nftAddress);\n', '\n', '        nftAddress.transfer(this.balance);\n', '    }\n', '\n', '    event PrintEvent(string, address, uint);\n', '\n', '    // Creates an auction and lists it.\n', '    function createAuction( uint256 _partId, uint256 _startPrice, uint256 _endPrice, uint256 _duration, address _seller ) external whenNotPaused {\n', "        // Sanity check that no inputs overflow how many bits we've allocated\n", '        // to store them in the auction struct.\n', '        require(_startPrice == uint256(uint128(_startPrice)));\n', '        require(_endPrice == uint256(uint128(_endPrice)));\n', '        require(_duration == uint256(uint64(_duration)));\n', '        require(_startPrice >= _endPrice);\n', '\n', '        require(msg.sender == address(nftContract));\n', '        _escrow(_seller, _partId);\n', '        Auction memory auction = Auction(\n', '            _seller,\n', '            uint128(_startPrice),\n', '            uint128(_endPrice),\n', '            uint64(_duration),\n', '            uint64(now) //seconds uint \n', '        );\n', '        PrintEvent("Auction Start", 0x0, auction.start);\n', '        _newAuction(_partId, auction);\n', '    }\n', '\n', '\n', '    // SCRAPYARD PRICING LOGIC\n', '\n', '    uint8 constant LAST_CONSIDERED = 5;\n', '    uint8 public scrapCounter = 0;\n', '    uint[5] public lastScrapPrices;\n', '    \n', '    // Purchases an open auction\n', '    // Will transfer ownership if successful.\n', '    \n', '    function purchase(uint256 _partId) external payable whenNotPaused {\n', '        address seller = tokenIdToAuction[_partId].seller;\n', '\n', '        // _purchase will throw if the purchase or funds transfer fails\n', '        uint256 price = _purchase(_partId, msg.value);\n', '        _transfer(msg.sender, _partId);\n', '        \n', '        // If the seller is the scrapyard, track price information.\n', '        if (seller == address(nftContract)) {\n', '\n', '            lastScrapPrices[scrapCounter] = price;\n', '            if (scrapCounter == LAST_CONSIDERED - 1) {\n', '                scrapCounter = 0;\n', '            } else {\n', '                scrapCounter++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function averageScrapPrice() public view returns (uint) {\n', '        uint sum = 0;\n', '        for (uint8 i = 0; i < LAST_CONSIDERED; i++) {\n', '            sum += lastScrapPrices[i];\n', '        }\n', '        return sum / LAST_CONSIDERED;\n', '    }\n', '\n', "    // Allows a user to cancel an auction before it's resolved.\n", '    // Returns the part to the seller.\n', '\n', '    function cancelAuction(uint256 _partId) external {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        address seller = auction.seller;\n', '        require(msg.sender == seller);\n', '        _cancelAuction(_partId, seller);\n', '    }\n', '\n', '    // returns the current price of the auction of a token with id _partId\n', '    function getCurrentPrice(uint256 _partId) external view returns (uint256) {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        return _currentPrice(auction);\n', '    }\n', '\n', '    //  Returns the details of an auction from its _partId.\n', '    function getAuction(uint256 _partId) external view returns ( address seller, uint256 startPrice, uint256 endPrice, uint256 duration, uint256 startedAt ) {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        return ( auction.seller, auction.startPrice, auction.endPrice, auction.duration, auction.start);\n', '    }\n', '\n', '    // Allows owner to cancel an auction.\n', '    // ONLY able to be used when contract is paused,\n', '    // in the case of emergencies.\n', "    // Parts returned to seller as it's equivalent to them \n", '    // calling cancel.\n', '    function cancelAuctionWhenPaused(uint256 _partId) whenPaused onlyOwner external {\n', '        Auction storage auction = tokenIdToAuction[_partId];\n', '        require(_isActiveAuction(auction));\n', '        _cancelAuction(_partId, auction.seller);\n', '    }\n', '}\n', '\n', 'contract EtherbotsAuction is PerkTree {\n', '\n', '    // Sets the reference to the sale auction.\n', '\n', '    function setAuctionAddress(address _address) external onlyOwner {\n', '        require(_address != address(0));\n', '        DutchAuction candidateContract = DutchAuction(_address);\n', '\n', '        // Set the new contract address\n', '        auction = candidateContract;\n', '    }\n', '\n', '    // list a part for auction.\n', '\n', '    function createAuction(\n', '        uint256 _partId,\n', '        uint256 _startPrice,\n', '        uint256 _endPrice,\n', '        uint256 _duration ) external whenNotPaused \n', '    {\n', '\n', '\n', '        // user must have current control of the part\n', '        // will lose control if they delegate to the auction\n', '        // therefore no duplicate auctions!\n', '        require(owns(msg.sender, _partId));\n', '\n', '        _approve(_partId, auction);\n', '\n', '        // will throw if inputs are invalid\n', '        // will clear transfer approval\n', '        DutchAuction(auction).createAuction(_partId,_startPrice,_endPrice,_duration,msg.sender);\n', '    }\n', '\n', '    // transfer balance back to core contract\n', '    function withdrawAuctionBalance() external onlyOwner {\n', '        DutchAuction(auction).withdrawBalance();\n', '    }\n', '\n', '    // SCRAP FUNCTION\n', '  \n', '    // This takes scrapped parts and automatically relists them on the market.\n', '    // Provides a good floor for entrance into the game, while keeping supply\n', '    // constant as these parts were already in circulation.\n', '\n', '    // uint public constant SCRAPYARD_STARTING_PRICE = 0.1 ether;\n', '    uint scrapMinStartPrice = 0.05 ether; // settable minimum starting price for sanity\n', '    uint scrapMinEndPrice = 0.005 ether;  // settable minimum ending price for sanity\n', '    uint scrapAuctionDuration = 2 days;\n', '    \n', '    function setScrapMinStartPrice(uint _newMinStartPrice) external onlyOwner {\n', '        scrapMinStartPrice = _newMinStartPrice;\n', '    }\n', '    function setScrapMinEndPrice(uint _newMinEndPrice) external onlyOwner {\n', '        scrapMinEndPrice = _newMinEndPrice;\n', '    }\n', '    function setScrapAuctionDuration(uint _newScrapAuctionDuration) external onlyOwner {\n', '        scrapAuctionDuration = _newScrapAuctionDuration;\n', '    }\n', ' \n', '    function _createScrapPartAuction(uint _scrapPartId) internal {\n', '        // if (scrapyard == address(this)) {\n', '        _approve(_scrapPartId, auction);\n', '        \n', '        DutchAuction(auction).createAuction(\n', '            _scrapPartId,\n', '            _getNextAuctionPrice(), // gen next auction price\n', '            scrapMinEndPrice,\n', '            scrapAuctionDuration,\n', '            address(this)\n', '        );\n', '        // }\n', '    }\n', '\n', '    function _getNextAuctionPrice() internal view returns (uint) {\n', '        uint avg = DutchAuction(auction).averageScrapPrice();\n', '        // add 30% to the average\n', '        // prevent runaway pricing\n', '        uint next = avg + ((30 * avg) / 100);\n', '        if (next < scrapMinStartPrice) {\n', '            next = scrapMinStartPrice;\n', '        }\n', '        return next;\n', '    }\n', '\n', '}\n', '\n', 'contract PerksRewards is EtherbotsAuction {\n', '    ///  An internal method that creates a new part and stores it. This\n', "    ///  method doesn't do any checking and should only be called when the\n", '    ///  input data is known to be valid. Will generate both a Forge event\n', '    ///  and a Transfer event.\n', '   function _createPart(uint8[4] _partArray, address _owner) internal returns (uint) {\n', '        uint32 newPartId = uint32(parts.length);\n', '        assert(newPartId == parts.length);\n', '\n', '        Part memory _part = Part({\n', '            tokenId: newPartId,\n', '            partType: _partArray[0],\n', '            partSubType: _partArray[1],\n', '            rarity: _partArray[2],\n', '            element: _partArray[3],\n', '            battlesLastDay: 0,\n', '            experience: 0,\n', '            forgeTime: uint32(now),\n', '            battlesLastReset: uint32(now)\n', '        });\n', '        assert(newPartId == parts.push(_part) - 1);\n', '\n', '        // emit the FORGING!!!\n', '        Forge(_owner, newPartId, _part);\n', '\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, _owner, newPartId);\n', '\n', '        return newPartId;\n', '    }\n', '\n', '    uint public PART_REWARD_CHANCE = 995;\n', '    // Deprecated subtypes contain the subtype IDs of legacy items\n', '    // which are no longer available to be redeemed in game.\n', '    // i.e. subtype ID 14 represents lambo body, presale exclusive.\n', '    // a value of 0 represents that subtype (id within range)\n', '    // as being deprecated for that part type (body, turret, etc)\n', '    uint8[] public defenceElementBySubtypeIndex;\n', '    uint8[] public meleeElementBySubtypeIndex;\n', '    uint8[] public bodyElementBySubtypeIndex;\n', '    uint8[] public turretElementBySubtypeIndex;\n', '    // uint8[] public defenceElementBySubtypeIndex = [1,2,4,3,4,1,3,3,2,1,4];\n', '    // uint8[] public meleeElementBySubtypeIndex = [3,1,3,2,3,4,2,2,1,1,1,1,4,4];\n', "    // uint8[] public bodyElementBySubtypeIndex = [2,1,2,3,4,3,1,1,4,2,3,4,1,0,1]; // no more lambos :'(\n", '    // uint8[] public turretElementBySubtypeIndex = [4,3,2,1,2,1,1,3,4,3,4];\n', '\n', '    function setRewardChance(uint _newChance) external onlyOwner {\n', '        require(_newChance > 980); // not too hot\n', '        require(_newChance <= 1000); // not too cold\n', '        PART_REWARD_CHANCE = _newChance; // just right\n', '        // come at me goldilocks\n', '    }\n', "    // The following functions DON'T create parts, they add new parts\n", '    // as possible rewards from the reward pool.\n', '\n', '\n', '    function addDefenceParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            defenceElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(defenceElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addMeleeParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            meleeElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(meleeElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addBodyParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            bodyElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(bodyElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    function addTurretParts(uint8[] _newElement) external onlyOwner {\n', '        for (uint8 i = 0; i < _newElement.length; i++) {\n', '            turretElementBySubtypeIndex.push(_newElement[i]);\n', '        }\n', '        // require(turretElementBySubtypeIndex.length < uint(uint8(-1)));\n', '    }\n', '    // Deprecate subtypes. Once a subtype has been deprecated it can never be\n', '    // undeprecated. Starting with lambo!\n', '    function deprecateDefenceSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        defenceElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateMeleeSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        meleeElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateBodySubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        bodyElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    function deprecateTurretSubtype(uint8 _subtypeIndexToDeprecate) external onlyOwner {\n', '        turretElementBySubtypeIndex[_subtypeIndexToDeprecate] = 0;\n', '    }\n', '\n', '    // function _randomIndex(uint _rand, uint8 _startIx, uint8 _endIx, uint8 _modulo) internal pure returns (uint8) {\n', '    //     require(_startIx < _endIx);\n', '    //     bytes32 randBytes = bytes32(_rand);\n', '    //     uint result = 0;\n', '    //     for (uint8 i=_startIx; i<_endIx; i++) {\n', '    //         result = result | uint8(randBytes[i]);\n', '    //         result << 8;\n', '    //     }\n', '    //     uint8 resultInt = uint8(uint(result) % _modulo);\n', '    //     return resultInt;\n', '    // }\n', '\n', '\n', '    // This function takes a random uint, an owner and randomly generates a valid part.\n', '    // It then transfers that part to the owner.\n', '    function _generateRandomPart(uint _rand, address _owner) internal {\n', '        // random uint 20 in length - MAYBE 20.\n', '        // first randomly gen a part type\n', '        _rand = uint(keccak256(_rand));\n', '        uint8[4] memory randomPart;\n', '        randomPart[0] = uint8(_rand % 4) + 1;\n', '        _rand = uint(keccak256(_rand));\n', '\n', '        // randomPart[0] = _randomIndex(_rand,0,4,4) + 1; // 1, 2, 3, 4, => defence, melee, body, turret\n', '\n', '        if (randomPart[0] == DEFENCE) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,defenceElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(defenceElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == MELEE) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,meleeElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(meleeElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == BODY) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,bodyElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(bodyElementBySubtypeIndex, randomPart[1]);\n', '\n', '        } else if (randomPart[0] == TURRET) {\n', '            randomPart[1] = _getRandomPartSubtype(_rand,turretElementBySubtypeIndex);\n', '            randomPart[3] = _getElement(turretElementBySubtypeIndex, randomPart[1]);\n', '\n', '        }\n', '        _rand = uint(keccak256(_rand));\n', '        randomPart[2] = _getRarity(_rand);\n', '        // randomPart[2] = _getRarity(_randomIndex(_rand,8,12,3)); // rarity\n', '        _createPart(randomPart, _owner);\n', '    }\n', '\n', '    function _getRandomPartSubtype(uint _rand, uint8[] elementBySubtypeIndex) internal pure returns (uint8) {\n', '        require(elementBySubtypeIndex.length < uint(uint8(-1)));\n', '        uint8 subtypeLength = uint8(elementBySubtypeIndex.length);\n', '        require(subtypeLength > 0);\n', '        uint8 subtypeIndex = uint8(_rand % subtypeLength);\n', '        // uint8 subtypeIndex = _randomIndex(_rand,4,8,subtypeLength);\n', '        uint8 count = 0;\n', '        while (elementBySubtypeIndex[subtypeIndex] == 0) {\n', '            subtypeIndex++;\n', '            count++;\n', '            if (subtypeIndex == subtypeLength) {\n', '                subtypeIndex = 0;\n', '            }\n', '            if (count > subtypeLength) {\n', '                break;\n', '            }\n', '        }\n', '        require(elementBySubtypeIndex[subtypeIndex] != 0);\n', '        return subtypeIndex + 1;\n', '    }\n', '\n', '\n', '    function _getRarity(uint rand) pure internal returns (uint8) {\n', '        uint16 rarity = uint16(rand % 1000);\n', '        if (rarity >= 990) {  // 1% chance of gold\n', '          return GOLD;\n', '        } else if (rarity >= 970) { // 2% chance of shadow\n', '          return SHADOW;\n', '        } else {\n', '          return STANDARD;\n', '        }\n', '    }\n', '\n', '    function _getElement(uint8[] elementBySubtypeIndex, uint8 subtype) internal pure returns (uint8) {\n', '        uint8 subtypeIndex = subtype - 1;\n', '        return elementBySubtypeIndex[subtypeIndex];\n', '    }\n', '\n', '    mapping(address => uint[]) pendingPartCrates ;\n', '\n', '    function getPendingPartCrateLength() external view returns (uint) {\n', '        return pendingPartCrates[msg.sender].length;\n', '    }\n', '\n', '    /// Put shards together into a new part-crate\n', '    function redeemShardsIntoPending() external {\n', '        User storage user = addressToUser[msg.sender];\n', '         while (user.numShards >= SHARDS_TO_PART) {\n', '             user.numShards -= SHARDS_TO_PART;\n', '             pendingPartCrates[msg.sender].push(block.number);\n', '             // 256 blocks to redeem\n', '         }\n', '    }\n', '\n', '    function openPendingPartCrates() external {\n', '        uint[] memory crates = pendingPartCrates[msg.sender];\n', '        for (uint i = 0; i < crates.length; i++) {\n', '            uint pendingBlockNumber = crates[i];\n', "            // can't open on the same timestamp\n", '            require(block.number > pendingBlockNumber);\n', '\n', '            var hash = block.blockhash(pendingBlockNumber);\n', '\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)); // % (10 ** 20);\n', '                _generateRandomPart(rand, msg.sender);\n', '            } else {\n', '                // Do nothing, no second chances to secure integrity of randomness.\n', '            }\n', '        }\n', '        delete pendingPartCrates[msg.sender];\n', '    }\n', '\n', '    uint32 constant SHARDS_MAX = 10000;\n', '\n', '    function _addShardsToUser(User storage _user, uint32 _shards) internal {\n', '        uint32 updatedShards = _user.numShards + _shards;\n', '        if (updatedShards > SHARDS_MAX) {\n', '            updatedShards = SHARDS_MAX;\n', '        }\n', '        _user.numShards = updatedShards;\n', '        ShardsAdded(msg.sender, _shards);\n', '    }\n', '\n', '    // FORGING / SCRAPPING\n', '    event ShardsAdded(address caller, uint32 shards);\n', '    event Scrap(address user, uint partId);\n', '\n', '    uint32 constant SHARDS_TO_PART = 500;\n', '    uint8 public scrapPercent = 60;\n', '    uint8 public burnRate = 60; \n', '\n', '    function setScrapPercent(uint8 _newPercent) external onlyOwner {\n', '        require((_newPercent >= 50) && (_newPercent <= 90));\n', '        scrapPercent = _newPercent;\n', '    }\n', '\n', '    // function setScrapyard(address _scrapyard) external onlyOwner {\n', '    //     scrapyard = _scrapyard;\n', '    // }\n', '\n', '    function setBurnRate(uint8 _rate) external onlyOwner {\n', '        burnRate = _rate;\n', '    }\n', '\n', '\n', '    uint public scrapCount = 0;\n', '\n', '    // scraps a part for shards\n', '    function scrap(uint partId) external {\n', '        require(owns(msg.sender, partId));\n', '        User storage u = addressToUser[msg.sender];\n', '        _addShardsToUser(u, (SHARDS_TO_PART * scrapPercent) / 100);\n', '        Scrap(msg.sender, partId);\n', "        // this doesn't need to be secure\n", '        // no way to manipulate it apart from guaranteeing your parts are resold\n', '        // or burnt\n', '        if (uint(keccak256(scrapCount)) % 100 >= burnRate) {\n', '            _transfer(msg.sender, address(this), partId);\n', '            _createScrapPartAuction(partId);\n', '        } else {\n', '            _transfer(msg.sender, address(0), partId);\n', '        }\n', '        scrapCount++;\n', '    }\n', '\n', '}\n', '\n', 'contract Mint is PerksRewards {\n', '    \n', '    // Owner only function to give an address new parts.\n', '    // Strictly capped at 5000.\n', '    // This will ONLY be used for promotional purposes (i.e. providing items for Wax/OPSkins partnership)\n', "    // which we don't benefit financially from, or giving users who win the prize of designing a part \n", '    // for the game, a single copy of that part.\n', '    \n', '    uint16 constant MINT_LIMIT = 5000;\n', '    uint16 public partsMinted = 0;\n', '\n', '    function mintParts(uint16 _count, address _owner) public onlyOwner {\n', '        require(_count > 0 && _count <= 50);\n', '        // check overflow\n', '        require(partsMinted + _count > partsMinted);\n', '        require(partsMinted + _count < MINT_LIMIT);\n', '        \n', '        addressToUser[_owner].numShards += SHARDS_TO_PART * _count;\n', '        \n', '        partsMinted += _count;\n', '    }       \n', '\n', '    function mintParticularPart(uint8[4] _partArray, address _owner) public onlyOwner {\n', '        require(partsMinted < MINT_LIMIT);\n', '        /* cannot create deprecated parts\n', '        for (uint i = 0; i < deprecated.length; i++) {\n', '            if (_partArray[2] == deprecated[i]) {\n', '                revert();\n', '            }\n', '        } */\n', '        _createPart(_partArray, _owner);\n', '        partsMinted++;\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract NewCratePreSale {\n', '    \n', '    // migration functions migrate the data from the previous contract in stages\n', '    // all addresses are included for transparency and easy verification\n', '    // however addresses with no robots (i.e. failed transaction and never bought properly) have been commented out.\n', '    // to view the full list of state assignments, go to etherscan.io/address/{address} and you can view the verified\n', '    mapping (address => uint[]) public userToRobots; \n', '\n', '    function _migrate(uint _index) external onlyOwner {\n', '        bytes4 selector = bytes4(keccak256("setData()"));\n', '        address a = migrators[_index];\n', '        require(a.delegatecall(selector));\n', '    }\n', '    // source code - feel free to verify the migration\n', '    address[6] migrators = [\n', '        0x700FeBD9360ac0A0a72F371615427Bec4E4454E5, //0x97AE01893E42d6d33fd9851A28E5627222Af7BBB,\n', '        0x72Cc898de0A4EAC49c46ccb990379099461342f6,\n', '        0xc3cC48da3B8168154e0f14Bf0446C7a93613F0A7,\n', '        0x4cC96f2Ddf6844323ae0d8461d418a4D473b9AC3,\n', '        0xa52bFcb5FF599e29EE2B9130F1575BaBaa27de0A,\n', '        0xe503b42AabdA22974e2A8B75Fa87E010e1B13584\n', '    ];\n', '    \n', '    function NewCratePreSale() public payable {\n', '        \n', '            owner = msg.sender;\n', '        // one time transfer of state from the previous contract\n', '        // var previous = CratePreSale(0x3c7767011C443EfeF2187cf1F2a4c02062da3998); //MAINNET\n', '\n', '        // oldAppreciationRateWei = previous.appreciationRateWei();\n', '        oldAppreciationRateWei = 100000000000000;\n', '        appreciationRateWei = oldAppreciationRateWei;\n', '  \n', '        // oldPrice = previous.currentPrice();\n', '        oldPrice = 232600000000000000;\n', '        currentPrice = oldPrice;\n', '\n', '        // oldCratesSold = previous.cratesSold();\n', '        oldCratesSold = 1075;\n', '        cratesSold = oldCratesSold;\n', '\n', '        // Migration Rationale\n', '        // due to solidity issues with enumerability (contract calls cannot return dynamic arrays etc)\n', '        // no need for trust -> can still use web3 to call the previous contract and check the state\n', '        // will only change in the future if people send more eth\n', '        // and will be obvious due to change in crate count. Any purchases on the old contract\n', '        // after this contract is deployed will be fully refunded, and those robots bought will be voided. \n', '        // feel free to validate any address on the old etherscan:\n', '        // https://etherscan.io/address/0x3c7767011C443EfeF2187cf1F2a4c02062da3998\n', '        // can visit the exact contracts at the addresses listed above\n', '    }\n', '\n', '    // ------ STATE ------\n', '    uint256 constant public MAX_CRATES_TO_SELL = 3900; // Max no. of robot crates to ever be sold\n', '    uint256 constant public PRESALE_END_TIMESTAMP = 1518699600; // End date for the presale - no purchases can be made after this date - Midnight 16 Feb 2018 UTC\n', '\n', '    uint256 public appreciationRateWei;\n', '    uint32 public cratesSold;\n', '    uint256 public currentPrice;\n', '\n', '    // preserve these for later verification\n', '    uint32 public oldCratesSold;\n', '    uint256 public oldPrice;\n', '    uint256 public oldAppreciationRateWei;\n', '    // mapping (address => uint32) public userCrateCount; // replaced with more efficient method\n', '    \n', '\n', '    // store the unopened crates of this user\n', '    // actually stores the blocknumber of each crate \n', '    mapping (address => uint[]) public addressToPurchasedBlocks;\n', '    // store the number of expired crates for each user \n', '    // i.e. crates where the user failed to open the crate within 256 blocks (~1 hour)\n', '    // these crates will be able to be opened post-launch\n', '    mapping (address => uint) public expiredCrates;\n', '    // store the part information of purchased crates\n', '\n', '\n', '\n', '    function openAll() public {\n', '        uint len = addressToPurchasedBlocks[msg.sender].length;\n', '        require(len > 0);\n', '        uint8 count = 0;\n', '        // len > i to stop predicatable wraparound\n', '        for (uint i = len - 1; i >= 0 && len > i; i--) {\n', '            uint crateBlock = addressToPurchasedBlocks[msg.sender][i];\n', '            require(block.number > crateBlock);\n', "            // can't open on the same timestamp\n", '            var hash = block.blockhash(crateBlock);\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)) % (10 ** 20);\n', '                userToRobots[msg.sender].push(rand);\n', '                count++;\n', '            } else {\n', '                // all others will be expired\n', '                expiredCrates[msg.sender] += (i + 1);\n', '                break;\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete addressToPurchasedBlocks[msg.sender];\n', '    }\n', '\n', '    // ------ EVENTS ------\n', '    event CratesPurchased(address indexed _from, uint8 _quantity);\n', '    event CratesOpened(address indexed _from, uint8 _quantity);\n', '\n', '    // ------ FUNCTIONS ------\n', '    function getPrice() view public returns (uint256) {\n', '        return currentPrice;\n', '    }\n', '\n', '    function getRobotCountForUser(address _user) external view returns(uint256) {\n', '        return userToRobots[_user].length;\n', '    }\n', '\n', '    function getRobotForUserByIndex(address _user, uint _index) external view returns(uint) {\n', '        return userToRobots[_user][_index];\n', '    }\n', '\n', '    function getRobotsForUser(address _user) view public returns (uint[]) {\n', '        return userToRobots[_user];\n', '    }\n', '\n', '    function getPendingCratesForUser(address _user) external view returns(uint[]) {\n', '        return addressToPurchasedBlocks[_user];\n', '    }\n', '\n', '    function getPendingCrateForUserByIndex(address _user, uint _index) external view returns(uint) {\n', '        return addressToPurchasedBlocks[_user][_index];\n', '    }\n', '\n', '    function getExpiredCratesForUser(address _user) external view returns(uint) {\n', '        return expiredCrates[_user];\n', '    }\n', '\n', '    function incrementPrice() private {\n', '        // Decrease the rate of increase of the crate price\n', '        // as the crates become more expensive\n', '        // to avoid runaway pricing\n', '        // (halving rate of increase at 0.1 ETH, 0.2 ETH, 0.3 ETH).\n', '        if ( currentPrice == 100000000000000000 ) {\n', '            appreciationRateWei = 200000000000000;\n', '        } else if ( currentPrice == 200000000000000000) {\n', '            appreciationRateWei = 100000000000000;\n', '        } else if (currentPrice == 300000000000000000) {\n', '            appreciationRateWei = 50000000000000;\n', '        }\n', '        currentPrice += appreciationRateWei;\n', '    }\n', '\n', '    function purchaseCrates(uint8 _cratesToBuy) public payable whenNotPaused {\n', '        require(now < PRESALE_END_TIMESTAMP); // Check presale is still ongoing.\n', "        require(_cratesToBuy <= 10); // Can only buy max 10 crates at a time. Don't be greedy!\n", '        require(_cratesToBuy >= 1); // Sanity check. Also, you have to buy a crate. \n', '        require(cratesSold + _cratesToBuy <= MAX_CRATES_TO_SELL); // Check max crates sold is less than hard limit\n', '        uint256 priceToPay = _calculatePayment(_cratesToBuy);\n', '         require(msg.value >= priceToPay); // Check buyer sent sufficient funds to purchase\n', '        if (msg.value > priceToPay) { //overpaid, return excess\n', '            msg.sender.transfer(msg.value-priceToPay);\n', '        }\n', '        //all good, payment received. increment number sold, price, and generate crate receipts!\n', '        cratesSold += _cratesToBuy;\n', '      for (uint8 i = 0; i < _cratesToBuy; i++) {\n', '            incrementPrice();\n', '            addressToPurchasedBlocks[msg.sender].push(block.number);\n', '        }\n', '\n', '        CratesPurchased(msg.sender, _cratesToBuy);\n', '    } \n', '\n', '    function _calculatePayment (uint8 _cratesToBuy) private view returns (uint256) {\n', '        \n', '        uint256 tempPrice = currentPrice;\n', '\n', '        for (uint8 i = 1; i < _cratesToBuy; i++) {\n', '            tempPrice += (currentPrice + (appreciationRateWei * i));\n', '        } // for every crate over 1 bought, add current Price and a multiple of the appreciation rate\n', '          // very small edge case of buying 10 when you the appreciation rate is about to halve\n', '          // is compensated by the great reduction in gas by buying N at a time.\n', '        \n', '        return tempPrice;\n', '    }\n', '\n', '\n', '    //owner only withdrawal function for the presale\n', '    function withdraw() onlyOwner public {\n', '        owner.transfer(this.balance);\n', '    }\n', '\n', '    function addFunds() onlyOwner external payable {\n', '\n', '    }\n', '\n', '  event SetPaused(bool paused);\n', '\n', '  // starts unpaused\n', '  bool public paused = false;\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() external onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '  function unpause() external onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    SetPaused(paused);\n', '    return true;\n', '  }\n', '\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '    \n', '}\n', 'contract EtherbotsMigrations is Mint {\n', '\n', '    event CratesOpened(address indexed _from, uint8 _quantity);\n', '    event OpenedOldCrates(address indexed _from);\n', '    event MigratedCrates(address indexed _from, uint16 _quantity, bool isMigrationComplete);\n', '\n', '    address presale = 0xc23F76aEa00B775AADC8504CcB22468F4fD2261A;\n', '    mapping(address => bool) public hasMigrated;\n', '    mapping(address => bool) public hasOpenedOldCrates;\n', '    mapping(address => uint[]) pendingCrates;\n', '    mapping(address => uint16) public cratesMigrated;\n', '\n', '  \n', '    // Element: copy for MIGRATIONS ONLY.\n', '    string constant private DEFENCE_ELEMENT_BY_ID = "12434133214";\n', '    string constant private MELEE_ELEMENT_BY_ID = "31323422111144";\n', '    string constant private BODY_ELEMENT_BY_ID = "212343114234111";\n', '    string constant private TURRET_ELEMENT_BY_ID = "43212113434";\n', '\n', '    // Once only function.\n', '    // Transfers all pending and expired crates in the old contract\n', '    // into pending crates in the current one.\n', '    // Users can then open them on the new contract.\n', '    // Should only rarely have to be called.\n', '    // event oldpending(uint old);\n', '\n', '    function openOldCrates() external {\n', '        require(hasOpenedOldCrates[msg.sender] == false);\n', '        // uint oldPendingCrates = NewCratePreSale(presale).getPendingCrateForUserByIndex(msg.sender,0); // getting unrecognised opcode here --!\n', '        // oldpending(oldPendingCrates);\n', '        // require(oldPendingCrates == 0);\n', '        _migrateExpiredCrates();\n', '        hasOpenedOldCrates[msg.sender] = true;\n', '        OpenedOldCrates(msg.sender);\n', '    }\n', '\n', '    function migrate() external whenNotPaused {\n', '        \n', "        // Can't migrate twice .\n", '        require(hasMigrated[msg.sender] == false);\n', '        \n', '        // require(NewCratePreSale(presale).getPendingCrateForUserByIndex(msg.sender,0) == 0);\n', '        // No pending crates in the new contract allowed. Make sure you open them first.\n', '        require(pendingCrates[msg.sender].length == 0);\n', '        \n', "        // If the user has old expired crates, don't let them migrate until they've\n", '        // converted them to pending crates in the new contract.\n', '        if (NewCratePreSale(presale).getExpiredCratesForUser(msg.sender) > 0) {\n', '            require(hasOpenedOldCrates[msg.sender]); \n', '        }\n', '\n', '        // have to make a ton of calls unfortunately \n', '        uint16 length = uint16(NewCratePreSale(presale).getRobotCountForUser(msg.sender));\n', '\n', '        // gas limit will be exceeded with *whale* etherbot players!\n', "        // let's migrate their robots in batches of ten.\n", '        // they can afford it\n', '        bool isMigrationComplete = false;\n', '        var max = length - cratesMigrated[msg.sender];\n', '        if (max > 9) {\n', '            max = 9;\n', '        } else { // final call - all robots will be migrated\n', '            isMigrationComplete = true;\n', '            hasMigrated[msg.sender] = true;\n', '        }\n', '        for (uint i = cratesMigrated[msg.sender]; i < cratesMigrated[msg.sender] + max; i++) {\n', '            var robot = NewCratePreSale(presale).getRobotForUserByIndex(msg.sender, i);\n', '            var robotString = uintToString(robot);\n', '            // MigratedBot(robotString);\n', '\n', '            _migrateRobot(robotString);\n', '            \n', '        }\n', '        cratesMigrated[msg.sender] += max;\n', '        MigratedCrates(msg.sender, cratesMigrated[msg.sender], isMigrationComplete);\n', '    }\n', '\n', '    function _migrateRobot(string robot) private {\n', '        var (melee, defence, body, turret) = _convertBlueprint(robot);\n', '        // blueprints event\n', '        // blueprints(body, turret, melee, defence);\n', '        _createPart(melee, msg.sender);\n', '        _createPart(defence, msg.sender);\n', '        _createPart(turret, msg.sender);\n', '        _createPart(body, msg.sender);\n', '    }\n', '\n', '    function _getRarity(string original, uint8 low, uint8 high) pure private returns (uint8) {\n', '        uint32 rarity = stringToUint32(substring(original,low,high));\n', '        if (rarity >= 950) {\n', '          return GOLD; \n', '        } else if (rarity >= 850) {\n', '          return SHADOW;\n', '        } else {\n', '          return STANDARD; \n', '        }\n', '    }\n', '   \n', '    function _getElement(string elementString, uint partId) pure private returns(uint8) {\n', '        return stringToUint8(substring(elementString, partId-1,partId));\n', '    }\n', '\n', '    // Actually part type\n', '    function _getPartId(string original, uint8 start, uint8 end, uint8 partCount) pure private returns(uint8) {\n', '        return (stringToUint8(substring(original,start,end)) % partCount) + 1;\n', '    }\n', '\n', '    function userPendingCrateNumber(address _user) external view returns (uint) {\n', '        return pendingCrates[_user].length;\n', '    }    \n', '    \n', '    // convert old string representation of robot into 4 new ERC721 parts\n', '  \n', '    function _convertBlueprint(string original) pure private returns(uint8[4] body,uint8[4] melee, uint8[4] turret, uint8[4] defence ) {\n', '\n', '        /* ------ CONVERSION TIME ------ */\n', '        \n', '\n', '        body[0] = BODY; \n', '        body[1] = _getPartId(original, 3, 5, 15);\n', '        body[2] = _getRarity(original, 0, 3);\n', '        body[3] = _getElement(BODY_ELEMENT_BY_ID, body[1]);\n', '        \n', '        turret[0] = TURRET;\n', '        turret[1] = _getPartId(original, 8, 10, 11);\n', '        turret[2] = _getRarity(original, 5, 8);\n', '        turret[3] = _getElement(TURRET_ELEMENT_BY_ID, turret[1]);\n', '\n', '        melee[0] = MELEE;\n', '        melee[1] = _getPartId(original, 13, 15, 14);\n', '        melee[2] = _getRarity(original, 10, 13);\n', '        melee[3] = _getElement(MELEE_ELEMENT_BY_ID, melee[1]);\n', '\n', '        defence[0] = DEFENCE;\n', '        var len = bytes(original).length;\n', "        // string of number does not have preceding 0's\n", '        if (len == 20) {\n', '            defence[1] = _getPartId(original, 18, 20, 11);\n', '        } else if (len == 19) {\n', '            defence[1] = _getPartId(original, 18, 19, 11);\n', '        } else { //unlikely to have length less than 19\n', '            defence[1] = uint8(1);\n', '        }\n', '        defence[2] = _getRarity(original, 15, 18);\n', '        defence[3] = _getElement(DEFENCE_ELEMENT_BY_ID, defence[1]);\n', '\n', '        // implicit return\n', '    }\n', '\n', '    // give one more chance\n', '    function _migrateExpiredCrates() private {\n', '        // get the number of expired crates\n', '        uint expired = NewCratePreSale(presale).getExpiredCratesForUser(msg.sender);\n', '        for (uint i = 0; i < expired; i++) {\n', '            pendingCrates[msg.sender].push(block.number);\n', '        }\n', '    }\n', '    // Users can open pending crates on the new contract.\n', '    function openCrates() public whenNotPaused {\n', '        uint[] memory pc = pendingCrates[msg.sender];\n', '        require(pc.length > 0);\n', '        uint8 count = 0;\n', '        for (uint i = 0; i < pc.length; i++) {\n', '            uint crateBlock = pc[i];\n', '            require(block.number > crateBlock);\n', "            // can't open on the same timestamp\n", '            var hash = block.blockhash(crateBlock);\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i)) % (10 ** 20);\n', '                _migrateRobot(uintToString(rand));\n', '                count++;\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete pendingCrates[msg.sender];\n', '    }\n', '\n', '    \n', '}\n', '\n', 'contract Battle {\n', '    // This struct does not exist outside the context of a battle\n', '\n', '    // the name of the battle type\n', '    function name() external view returns (string);\n', '    // the number of robots currently battling\n', '    function playerCount() external view returns (uint count);\n', '    // creates a new battle, with a submitted user string for initial input/\n', '    function createBattle(address _creator, uint[] _partIds, bytes32 _commit, uint _revealLength) external payable returns (uint);\n', '    // cancels the battle at battleID\n', '    function cancelBattle(uint battleID) external;\n', '    \n', '    function winnerOf(uint battleId, uint index) external view returns (address);\n', '    function loserOf(uint battleId, uint index) external view returns (address);\n', '\n', '    event BattleCreated(uint indexed battleID, address indexed starter);\n', '    event BattleStage(uint indexed battleID, uint8 moveNumber, uint8[2] attackerMovesDefenderMoves, uint16[2] attackerDamageDefenderDamage);\n', '    event BattleEnded(uint indexed battleID, address indexed winner);\n', '    event BattleConcluded(uint indexed battleID);\n', '    event BattlePropertyChanged(string name, uint previous, uint value);\n', '}\n', 'contract EtherbotsBattle is EtherbotsMigrations {\n', '\n', '    // can never remove any of these contracts, can only add\n', "    // once we publish a contract, you'll always be able to play by that ruleset\n", '    // good for two player games which are non-susceptible to collusion\n', '    // people can be trusted to choose the most beneficial outcome, which in this case\n', '    // is the fairest form of gameplay.\n', '    // fields which are vulnerable to collusion still have to be centrally controlled :(\n', '    function addApprovedBattle(Battle _battle) external onlyOwner {\n', '        approvedBattles.push(_battle);\n', '    }\n', '\n', '    function _isApprovedBattle() internal view returns (bool) {\n', '        for (uint8 i = 0; i < approvedBattles.length; i++) {\n', '            if (msg.sender == address(approvedBattles[i])) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    modifier onlyApprovedBattles(){\n', '        require(_isApprovedBattle());\n', '        _;\n', '    }\n', '\n', '\n', '    function createBattle(uint _battleId, uint[] partIds, bytes32 commit, uint revealLength) external payable {\n', '        // sanity check to make sure _battleId is a valid battle\n', '        require(_battleId < approvedBattles.length);\n', '        //if parts are given, make sure they are owned\n', '        if (partIds.length > 0) {\n', '            require(ownsAll(msg.sender, partIds));\n', '        }\n', '        //battle can decide number of parts required for battle\n', '\n', '        Battle battle = Battle(approvedBattles[_battleId]);\n', '        // Transfer all to selected battle contract.\n', '        for (uint i=0; i<partIds.length; i++) {\n', '            _approve(partIds[i], address(battle));\n', '        }\n', '        uint newDuelId = battle.createBattle.value(msg.value)(msg.sender, partIds, commit, revealLength);\n', '        NewDuel(_battleId, newDuelId);\n', '    }\n', '\n', '    event NewDuel(uint battleId, uint duelId);\n', '\n', '\n', '    mapping(address => Reward[]) public pendingRewards;\n', '    // actually probably just want a length getter here as default public mapping getters\n', '    // are pretty expensive\n', '\n', '    function getPendingBattleRewardsCount(address _user) external view returns (uint) {\n', '        return pendingRewards[_user].length;\n', '    } \n', '\n', '    struct Reward {\n', '        uint blocknumber;\n', '        int32 exp;\n', '    }\n', '\n', '    function addExperience(address _user, uint[] _partIds, int32[] _exps) external onlyApprovedBattles {\n', '        address user = _user;\n', '        require(_partIds.length == _exps.length);\n', '        int32 sum = 0;\n', '        for (uint i = 0; i < _exps.length; i++) {\n', '            sum += _addPartExperience(_partIds[i], _exps[i]);\n', '        }\n', '        _addUserExperience(user, sum);\n', '        _storeReward(user, sum);\n', '    }\n', '\n', '    // store sum.\n', '    function _storeReward(address _user, int32 _battleExp) internal {\n', '        pendingRewards[_user].push(Reward({\n', '            blocknumber: 0,\n', '            exp: _battleExp\n', '        }));\n', '    }\n', '\n', '    /* function _getExpProportion(int _exp) returns(int) {\n', '        // assume max/min of 1k, -1k\n', '        return 1000 + _exp + 1; // makes it between (1, 2001)\n', '    } */\n', '    uint8 bestMultiple = 3;\n', '    uint8 mediumMultiple = 2;\n', '    uint8 worstMultiple = 1;\n', '    uint8 minShards = 1;\n', '    uint8 bestProbability = 97;\n', '    uint8 mediumProbability = 85;\n', '    function _getExpMultiple(int _exp) internal view returns (uint8, uint8) {\n', '        if (_exp > 500) {\n', '            return (bestMultiple,mediumMultiple);\n', '        } else if (_exp > 0) {\n', '            return (mediumMultiple,mediumMultiple);\n', '        } else {\n', '            return (worstMultiple,mediumMultiple);\n', '        }\n', '    }\n', '\n', '    function setBest(uint8 _newBestMultiple) external onlyOwner {\n', '        bestMultiple = _newBestMultiple;\n', '    }\n', '    function setMedium(uint8 _newMediumMultiple) external onlyOwner {\n', '        mediumMultiple = _newMediumMultiple;\n', '    }\n', '    function setWorst(uint8 _newWorstMultiple) external onlyOwner {\n', '        worstMultiple = _newWorstMultiple;\n', '    }\n', '    function setMinShards(uint8 _newMin) external onlyOwner {\n', '        minShards = _newMin;\n', '    }\n', '    function setBestProbability(uint8 _newBestProb) external onlyOwner {\n', '        bestProbability = _newBestProb;\n', '    }\n', '    function setMediumProbability(uint8 _newMinProb) external onlyOwner {\n', '        mediumProbability = _newMinProb;\n', '    }\n', '\n', '\n', '\n', '    function _calculateShards(int _exp, uint rand) internal view returns (uint16) {\n', '        var (a, b) = _getExpMultiple(_exp);\n', '        uint16 shards;\n', '        uint randPercent = rand % 100;\n', '        if (randPercent > bestProbability) {\n', '            shards = uint16(a * ((rand % 20) + 12) / b);\n', '        } else if (randPercent > mediumProbability) {\n', '            shards = uint16(a * ((rand % 10) + 6) / b);  \n', '        } else {\n', '            shards = uint16((a * (rand % 5)) / b);       \n', '        }\n', '\n', '        if (shards < minShards) {\n', '            shards = minShards;\n', '        }\n', '\n', '        return shards;\n', '    }\n', '\n', '    // convert wins into pending battle crates\n', '    // Not to pending old crates (migration), nor pending part crates (redeemShards)\n', '    function convertReward() external {\n', '\n', '        Reward[] storage rewards = pendingRewards[msg.sender];\n', '\n', '        for (uint i = 0; i < rewards.length; i++) {\n', '            if (rewards[i].blocknumber == 0) {\n', '                rewards[i].blocknumber = block.number;\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    // in PerksRewards\n', '    function redeemBattleCrates() external {\n', '        uint8 count = 0;\n', '        uint len = pendingRewards[msg.sender].length;\n', '        require(len > 0);\n', '        for (uint i = 0; i < len; i++) {\n', '            Reward memory rewardStruct = pendingRewards[msg.sender][i];\n', "            // can't open on the same timestamp\n", '            require(block.number > rewardStruct.blocknumber);\n', '            // ensure user has converted all pendingRewards\n', '            require(rewardStruct.blocknumber != 0);\n', '\n', '            var hash = block.blockhash(rewardStruct.blocknumber);\n', '\n', '            if (uint(hash) != 0) {\n', '                // different results for all different crates, even on the same block/same user\n', '                // randomness is already taken care of\n', '                uint rand = uint(keccak256(hash, msg.sender, i));\n', '                _generateBattleReward(rand,rewardStruct.exp);\n', '                count++;\n', '            } else {\n', '                // Do nothing, no second chances to secure integrity of randomness.\n', '            }\n', '        }\n', '        CratesOpened(msg.sender, count);\n', '        delete pendingRewards[msg.sender];\n', '    }\n', '\n', '    function _generateBattleReward(uint rand, int32 exp) internal {\n', '        if (((rand % 1000) > PART_REWARD_CHANCE) && (exp > 0)) {\n', '            _generateRandomPart(rand, msg.sender);\n', '        } else {\n', '            _addShardsToUser(addressToUser[msg.sender], _calculateShards(exp, rand));\n', '        }\n', '    }\n', '\n', "    // don't need to do any scaling\n", '    // should already have been done by previous stages\n', '    function _addUserExperience(address user, int32 exp) internal {\n', '        // never allow exp to drop below 0\n', '        User memory u = addressToUser[user];\n', '        if (exp < 0 && uint32(int32(u.experience) + exp) > u.experience) {\n', '            u.experience = 0;\n', '            return;\n', '        } else if (exp > 0) {\n', '            // check for overflow\n', '            require(uint32(int32(u.experience) + exp) > u.experience);\n', '        }\n', '        addressToUser[user].experience = uint32(int32(u.experience) + exp);\n', '        //_addUserReward(user, exp);\n', '    }\n', '\n', '    function setMinScaled(int8 _min) external onlyOwner {\n', '        minScaled = _min;\n', '    }\n', '\n', '    int8 minScaled = 25;\n', '\n', '    function _scaleExp(uint32 _battleCount, int32 _exp) internal view returns (int32) {\n', '        if (_battleCount <= 10) {\n', '            return _exp; // no drop off\n', '        }\n', '        int32 exp =  (_exp * 10)/int32(_battleCount);\n', '\n', '        if (exp < minScaled) {\n', '            return minScaled;\n', '        }\n', '        return exp;\n', '    }\n', '\n', '    function _addPartExperience(uint _id, int32 _baseExp) internal returns (int32) {\n', '        // never allow exp to drop below 0\n', '        Part storage p = parts[_id];\n', '        if (now - p.battlesLastReset > 24 hours) {\n', '            p.battlesLastReset = uint32(now);\n', '            p.battlesLastDay = 0;\n', '        }\n', '        p.battlesLastDay++;\n', '        int32 exp = _baseExp;\n', '        if (exp > 0) {\n', '            exp = _scaleExp(p.battlesLastDay, _baseExp);\n', '        }\n', '\n', '        if (exp < 0 && uint32(int32(p.experience) + exp) > p.experience) {\n', '            // check for wrap-around\n', '            p.experience = 0;\n', '            return;\n', '        } else if (exp > 0) {\n', '            // check for overflow\n', '            require(uint32(int32(p.experience) + exp) > p.experience);\n', '        }\n', '\n', '        parts[_id].experience = uint32(int32(parts[_id].experience) + exp);\n', '        return exp;\n', '    }\n', '\n', '    function totalLevel(uint[] partIds) public view returns (uint32) {\n', '        uint32 total = 0;\n', '        for (uint i = 0; i < partIds.length; i++) {\n', '            total += getLevel(parts[partIds[i]].experience);\n', '        }\n', '        return total;\n', '    }\n', '\n', '    //requires parts in order\n', '    function hasOrderedRobotParts(uint[] partIds) external view returns(bool) {\n', '        uint len = partIds.length;\n', '        if (len != 4) {\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < len; i++) {\n', '            if (parts[partIds[i]].partType != i+1) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract EtherbotsCore is EtherbotsBattle {\n', '\n', '    // The structure of Etherbots is modelled on CryptoKitties for obvious reasons:\n', '    // ease of implementation, tried + tested etc.\n', '    // it elides some features and includes some others.\n', '\n', '    // The full system is implemented in the following manner:\n', '    //\n', '    // EtherbotsBase    | Storage and base types\n', '    // EtherbotsAccess  | Access Control - who can change which state vars etc.\n', '    // EtherbotsNFT     | ERC721 Implementation\n', '    // EtherbotsBattle  | Battle interface contract: only one implementation currently, but could add more later.\n', '    // EtherbotsAuction | Auction interface contract\n', '\n', '\n', '    function EtherbotsCore() public {\n', '        // Starts paused.\n', '        paused = true;\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    \n', '    function() external payable {\n', '    }\n', '\n', '    function withdrawBalance() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '}']
