['/**\n', ' * Token name: KT\n', ' * Interface: ERC721\n', ' * This token is established by Krypital Group, mainly used as a commemorative token for Krypital supporters.\n', ' * Total supply of KTs is limited to 2100.\n', ' * A KT holder can either hold it as a souvenir (leave message on the message board), or play the game by merging/decomposing tokens.\n', ' * Tokens can used to exchange for future holder benefits provided by Krypital. Details coming soon on Krypital&#39;s website: https://krypital.com/  \n', ' * More news about Krypital on Telegram: https://t.me/KrypitalNews\n', ' * @author: https://github.com/1994wyh-WYH\n', ' */\n', 'pragma solidity ^0.4.19;\n', '\n', '\n', '/**\n', ' * @title safemath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library safemath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ownable\n', ' * @dev The ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract erc721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function takeOwnership(uint256 _tokenId) public;\n', '}\n', '\n', '\n', '/**\n', ' *  @title KTaccess\n', ' *  @author https://github.com/1994wyh-WYH\n', ' *  @dev This contract is for regulating the owners&#39; addr.\n', ' *  Inherited by KTfactory.\n', ' */\n', 'contract KTaccess is ownable{\n', '    address public o1Address;\n', '    address public o2Address;\n', '    address public o3Address;\n', '    \n', '    modifier onlyOLevel() {\n', '        require(\n', '            msg.sender == o1Address ||\n', '            msg.sender == o2Address ||\n', '            msg.sender == o3Address ||\n', '            msg.sender == owner\n', '        );\n', '        _;\n', '    }\n', '\n', '    function setO1(address _newAddr) external onlyOLevel {\n', '        require(_newAddr != address(0));\n', '\n', '        o1Address = _newAddr;\n', '    }\n', '\n', '    function setO2(address _newAddr) external onlyOLevel {\n', '        require(_newAddr != address(0));\n', '\n', '        o2Address = _newAddr;\n', '    }\n', '    \n', '    function setO3(address _newAddr) external onlyOLevel {\n', '        require(_newAddr != address(0));\n', '\n', '        o3Address = _newAddr;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title KTfactory\n', ' * @author https://github.com/1994wyh-WYH\n', ' * @dev This main contract for creating KTs.\n', ' * \n', ' * A KT, which is the token issued by Krypital, has the following properties: \n', ' * an officail note that can be created only by the contract owner;\n', ' * a personal note that can be modified by the current owner of the token;\n', ' * a bool value indicating if the token is currently frozen by Krypital;\n', ' * a gene which is a hashed value that changes when mutate (merge or decompose). This is for some future interesting apps :D \n', ' * level, namely, the level of the token. Apparently higher is better :D\n', ' * id, the key used to map to the associated KT.\n', ' * \n', ' */\n', '\n', 'contract KTfactory is ownable, KTaccess {\n', '\n', '  using safemath for uint256;\n', '\n', '  uint256 public maxId;\n', '\n', '  uint256 public initial_supply;\n', '\n', '  uint256 public curr_number;\n', '\n', '  event NewKT(string note, uint256 gene, uint256 level, uint256 tokenId);\n', '  event UpdateNote(string newNote, uint256 tokenId);\n', '  event PauseToken(uint256 tokenId);\n', '  event UnpauseToken(uint256 tokenId);\n', '  event Burn(uint256 tokenId);\n', '\n', '  struct KT {\n', '    string officialNote;\n', '    string personalNote;\n', '    bool paused;\n', '    uint256 gene;\n', '    uint256 level;\n', '    uint256 id;\n', '  }\n', '\n', '  mapping (uint256 => KT) public KTs;\n', '\n', '  mapping (uint => address) public KTToOwner;\n', '  mapping (address => uint) ownerKTCount;\n', '\n', '  modifier onlyOwnerOf(uint token_id) {\n', '    require(msg.sender == KTToOwner[token_id]);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotFrozen(uint token_id) {\n', '    require(KTs[token_id].paused == false);\n', '    _;\n', '  }\n', '\n', '  modifier withinTotal() {\n', '    require(curr_number<= initial_supply);\n', '    _;\n', '  }\n', '\n', '  modifier hasKT(uint token_id) {\n', '    require(KTs[token_id].id != 0);\n', '    _;\n', '  }\n', '    \n', '    /**\n', '     * @dev The constructor. Sets the initial supply and some other global variables.\n', '     * That&#39;s right, Krypital will only issue 2100 tokens in total. It also means the total number of KTs will not exceed this number!\n', '     */\n', '  constructor() public {\n', '    initial_supply = 2100;\n', '    maxId=0;\n', '    curr_number=0;\n', '  }\n', '\n', '    /**\n', '     * @dev The creator of KTs. Only done by Krypital.\n', '     * @param oNote - the official, special note left only by Krypital!\n', '     */\n', '  function _createKT(string oNote) public onlyOLevel withinTotal {\n', '    uint thisId = maxId + 1;\n', '    uint256 thisGene = uint256(keccak256(oNote));\n', '    \n', '    KT memory thisKT = KT({\n', '        officialNote: oNote, \n', '        personalNote: "", \n', '        paused: false, \n', '        gene: thisGene, \n', '        level: 1, \n', '        id: thisId\n', '    });\n', '    \n', '    KTs[thisId] = thisKT;\n', '    maxId = maxId + 1;\n', '    curr_number = curr_number + 1;\n', '    KTToOwner[thisId] = msg.sender;\n', '    ownerKTCount[msg.sender]++;\n', '    emit NewKT(oNote, thisGene, 1, thisId);\n', '  }\n', '    \n', '    /**\n', '     * @dev This method is for editing your personal note!\n', '     * @param note - the note you want the old one to be replaced by\n', '     * @param token_id - just token id\n', '     */\n', '  function _editPersonalNote(string note, uint token_id) public onlyOwnerOf(token_id) hasKT(token_id){\n', '    KT storage currKT = KTs[token_id];\n', '    currKT.personalNote = note;\n', '    emit UpdateNote(note, token_id);\n', '  }\n', '    \n', '    /**\n', '     * @dev Pauses a token, done by Krypital\n', '     * When a token is paused by Krypital, the owner of the token can still update the personal note but the ownership cannot be transferred.\n', '     * @param token_id - just token id\n', '     */\n', '  function pauseToken(uint token_id) public onlyOLevel hasKT(token_id){\n', '    KT storage currKT = KTs[token_id];\n', '    currKT.paused = true;\n', '    emit PauseToken(token_id);\n', '  }\n', '  \n', '  /**\n', '   * @dev Unpauses a token, done by Krypital\n', '   * @param token_id - just token id\n', '   */\n', '  function unpauseToken(uint token_id) public onlyOLevel hasKT(token_id){\n', '    KT storage currKT = KTs[token_id];\n', '    currKT.paused = false;\n', '    emit UnpauseToken(token_id);\n', '  }\n', '  \n', '  /**\n', '   * @dev Burns a token, reduce the current number of KTs by 1.\n', '   * @param token_id - simply token id.\n', '   */\n', '   function burn(uint token_id) public onlyOLevel hasKT(token_id){\n', '       KT storage currKT = KTs[token_id];\n', '       currKT.id=0;\n', '       currKT.level=0;\n', '       currKT.gene=0;\n', '       currKT.officialNote="";\n', '       currKT.personalNote="";\n', '       currKT.paused=true;\n', '       curr_number=curr_number.sub(1);\n', '       emit Burn(token_id);\n', '   } \n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title KT\n', ' * @author https://github.com/1994wyh-WYH\n', ' * @dev This contract is the contract regulating the transfer, decomposition, merging mechanism amaong the tokens.\n', ' */\n', 'contract KT is KTfactory, erc721 {\n', '\n', '  using safemath for uint256;\n', '\n', '  mapping (uint => address) public KTApprovals;\n', '  \n', '  /**\n', '   * @dev The modifer to regulate a KT&#39;s decomposability.\n', '   * A level 1 KT is not decomposable.\n', '   * @param token_id - simply token id.\n', '   */\n', '  modifier decomposeAllowed(uint token_id){\n', '    require(KTs[token_id].level > 1);\n', '    _;\n', '  }\n', '\n', '  event Decompose(uint256 tokenId);\n', '  event Merge(uint256 tokenId1, uint256 tokenId2);\n', '\n', '    /**\n', '     * @dev This is for getting the ether back to the contract owner&#39;s account. Just in case someone generous sends the creator some ethers :P\n', '     */\n', '  function withdraw() external onlyOwner {\n', '    owner.transfer(this.balance);\n', '  }\n', '\n', '    /**\n', '     * @dev For checking how many tokens you own.\n', '     * @param _owner - the owner&#39;s addr\n', '     */\n', '  function balanceOf(address _owner) public view returns(uint256) {\n', '    return ownerKTCount[_owner];\n', '  }\n', '    \n', '    /**\n', '     * @dev For checking the owner of the given token.\n', '     * @param _tokenId - just token id\n', '     */\n', '  function ownerOf(uint256 _tokenId) public view returns(address) {\n', '    return KTToOwner[_tokenId];\n', '  }\n', '\n', '    /**\n', '     * @dev the private helper function for transfering ownership.\n', '     * @param _from - current KT owner\n', '     * @param _to - new KT owner\n', '     * @param _tokenId - just token id\n', '     */\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private hasKT(_tokenId) {\n', '    ownerKTCount[_to] = ownerKTCount[_to].add(1);\n', '    ownerKTCount[msg.sender] = ownerKTCount[msg.sender].sub(1);\n', '    KTToOwner[_tokenId] = _to;\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '    /**\n', '     * @dev This method can be called if you are the token owner and you want to transfer the token to someone else.\n', '     * @param _to - new KT owner\n', '     * @param _tokenId - just token id\n', '     */\n', '  function transfer(address _to, uint256 _tokenId) public whenNotFrozen(_tokenId) onlyOwnerOf(_tokenId) hasKT(_tokenId){\n', '    require(_to != address(0));\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '    \n', '    /**\n', '     * @dev An approved user can &#39;claim&#39; a token of another user.\n', '     * @param _to - new KT owner\n', '     * @param _tokenId - just token id\n', '     */\n', '  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) hasKT(_tokenId) {\n', '    KTApprovals[_tokenId] = _to;\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '    \n', '    /**\n', '     * @dev The user to be approved must be approved by the current token holder.\n', '     * @param _tokenId - just token id\n', '     */\n', '  function takeOwnership(uint256 _tokenId) public whenNotFrozen(_tokenId) hasKT(_tokenId){\n', '    require(KTApprovals[_tokenId] == msg.sender);\n', '    address owner = ownerOf(_tokenId);\n', '    _transfer(owner, msg.sender, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev This method is for decomposing (or split) a token. Only can be done by token holder when token is not frozen.\n', '   * Note: one of the tokens will take the original token&#39;s place, that is, the old ID will actually map to a new token!\n', '   * Level down by 1!!! A level 1 token cannot be decomposed.\n', '   * The genes of the two new born tokens will be both identical to the old token.\n', '   * Notes of the two new tokens are identical to the original token.\n', '   */\n', '  function decompose(uint256 token_id) public whenNotFrozen(token_id) onlyOwnerOf(token_id) decomposeAllowed(token_id) hasKT(token_id) withinTotal{\n', '    KT storage decomposed = KTs[token_id];\n', '    decomposed.level = decomposed.level-1;\n', '    decomposed.gene = decomposed.gene/2;\n', '\n', '    KT memory newKT = KT({\n', '      officialNote: decomposed.officialNote,\n', '      personalNote: decomposed.personalNote,\n', '      paused: false,\n', '      gene: decomposed.gene,\n', '      level: decomposed.level,\n', '      id: maxId.add(1)\n', '    });\n', '    \n', '    maxId=maxId.add(1);\n', '    curr_number=curr_number.add(1);\n', '    KTs[maxId]=newKT;\n', '    KTToOwner[maxId]=KTToOwner[token_id];\n', '    ownerKTCount[msg.sender]=ownerKTCount[msg.sender].add(1);\n', '\n', '    emit Decompose(token_id);\n', '  }\n', '\n', '    /**\n', '     * @dev This function is for merging 2 tokens. Only tokens with the same levels can be merge. A user can only choose to merge from his own tokens.\n', '     * After merging, id and official note are merged to the previous token passed in the args.\n', '     * NOTE that the notes associated with the second token will be wiped out! Use with your caution.\n', '     * Level up by 1!!!\n', '     * New gene = (gene1 + gene2) / 2\n', '     * @param id1 - the ID to the 1st token, this ID will remain after merging.\n', '     * @param id2 - the ID of the 2nd token, this ID will map to nothing after merging!!\n', '     */\n', '  function merge(uint256 id1, uint256 id2) public hasKT(id1) hasKT(id2) whenNotFrozen(id1) whenNotFrozen(id2) onlyOwnerOf(id1) onlyOwnerOf(id2){\n', '    require(KTs[id1].level == KTs[id2].level);\n', '    KT storage token1 = KTs[id1];\n', '    token1.gene = (token1.gene + KTs[id2].gene) / 2;\n', '    token1.level = (token1.level).add(1);\n', '\n', '    KT memory toDelete = KT ({\n', '      officialNote: "",\n', '      personalNote: "",\n', '      paused: false,\n', '      gene: 0,\n', '      level: 0,\n', '      id: 0\n', '    });\n', '\n', '    KTs[id2] = toDelete;\n', '    curr_number = curr_number.sub(1);\n', '    KTToOwner[id2] = address(0);\n', '    ownerKTCount[msg.sender] = ownerKTCount[msg.sender].sub(1);\n', '\n', '    emit Merge(id1, id2);\n', '  }\n', '  \n', '}']