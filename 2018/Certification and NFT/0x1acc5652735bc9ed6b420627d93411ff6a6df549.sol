['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/// @dev Crowdsale interface for Etheal Normal Sale, functions needed from outside.\n', 'contract iEthealSale {\n', '    bool public paused;\n', '    uint256 public minContribution;\n', '    uint256 public whitelistThreshold;\n', '    mapping (address => uint256) public stakes;\n', '    function setPromoBonus(address _investor, uint256 _value) public;\n', '    function buyTokens(address _beneficiary) public payable;\n', '    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;\n', '    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;\n', '    function hasEnded() public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title claim accidentally sent tokens\n', ' */\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    /// @notice This method can be used to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    /// @param _claimer Address that tokens will be send to\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/*\n', ' * ERC-20 Standard Token Smart Contract Interface.\n', ' * Copyright &#169; 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="c5a8acaeada4aca9ebb3a9a4a1aca8acb7aab385a2a8a4aca9eba6aaa8">[email&#160;protected]</span>>\n', ' */\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () view returns (uint256 supply);\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the\n', '     *        owner of\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) view returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred\n', '     *        from the owner of\n', '     * @param _spender address to get number of tokens allowed to be transferred\n', '     *        by the owner of\n', '     * @return number of tokens given spender is currently allowed to transfer\n', '     *         from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) view returns (uint256 remaining);\n', '\n', '    /**\n', '     * Logged when tokens were transferred from one owner to another.\n', '     *\n', '     * @param _from address of the owner, tokens were transferred from\n', '     * @param _to address of the owner, tokens were transferred to\n', '     * @param _value number of tokens transferred\n', '     */\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '     * Logged when owner approved his tokens to be transferred by some spender.\n', '     *\n', '     * @param _owner owner who approved his tokens to be transferred\n', '     * @param _spender spender who were allowed to transfer the tokens belonging\n', '     *        to the owner\n', '     * @param _value number of tokens belonging to the owner, approved to be\n', '     *        transferred by the spender\n', '     */\n', '    event Approval (address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*\n', ' * Abstract Token Smart Contract.  Copyright &#169; 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="8ee3e7e5e6efe7e2a0f8e2efeae7e3e7fce1f8cee9e3efe7e2a0ede1e3">[email&#160;protected]</span>>\n', ' * Modified to use SafeMath library by thesved\n', ' */\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts.\n', ' */\n', 'contract AbstractToken is Token {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Create new Abstract Token contract.\n', '     */\n', '    function AbstractToken () {\n', '        // Do nothing\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the owner\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) view returns (uint256 balance) {\n', '        return accounts[_owner];\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success) {\n', '        uint256 fromBalance = accounts[msg.sender];\n', '        if (fromBalance < _value) return false;\n', '        if (_value > 0 && msg.sender != _to) {\n', '            accounts[msg.sender] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success) {\n', '        uint256 spenderAllowance = allowances[_from][msg.sender];\n', '        if (spenderAllowance < _value) return false;\n', '        uint256 fromBalance = accounts[_from];\n', '        if (fromBalance < _value) return false;\n', '\n', '        allowances[_from][msg.sender] = spenderAllowance.sub(_value);\n', '\n', '        if (_value > 0 && _from != _to) {\n', '            accounts[_from] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(_from, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred from the owner\n', '     * @param _spender address to get number of tokens allowed to be transferred by the owner\n', '     * @return number of tokens given spender is currently allowed to transfer from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) view returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * Mapping from addresses of token holders to the numbers of tokens belonging\n', '     * to these token holders.\n', '     */\n', '    mapping (address => uint256) accounts;\n', '\n', '    /**\n', '     * Mapping from addresses of token holders to the mapping of addresses of\n', '     * spenders to the allowances set by these token holders to these spenders.\n', '     */\n', '    mapping (address => mapping (address => uint256)) private allowances;\n', '}\n', '\n', '\n', '/*\n', ' * Abstract Virtual Token Smart Contract.  Copyright &#169; 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="2b464240434a4247055d474a4f42464259445d6b4c464a424705484446">[email&#160;protected]</span>>\n', ' * Modified to use SafeMath library by thesved\n', ' */\n', '\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts supporting virtual balance.\n', ' */\n', 'contract AbstractVirtualToken is AbstractToken {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Maximum number of real (i.e. non-virtual) tokens in circulation (2^255-1).\n', '     */\n', '    uint256 constant MAXIMUM_TOKENS_COUNT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Mask used to extract real balance of an account (2^255-1).\n', '     */\n', '    uint256 constant BALANCE_MASK = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Mask used to extract "materialized" flag of an account (2^255).\n', '     */\n', '    uint256 constant MATERIALIZED_FLAG_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * Create new Abstract Virtual Token contract.\n', '     */\n', '    function AbstractVirtualToken () {\n', '        // Do nothing\n', '    }\n', '\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () view returns (uint256 supply) {\n', '        return tokensCount;\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the owner\n', '     * @return number of tokens currently belonging to the owner of given address\n', '    */\n', '    function balanceOf (address _owner) constant returns (uint256 balance) { \n', '        return (accounts[_owner] & BALANCE_MASK).add(getVirtualBalance(_owner));\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success) {\n', '        if (_value > balanceOf(msg.sender)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(msg.sender, _value);\n', '            return AbstractToken.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (_value > allowance(_from, msg.sender)) return false;\n', '        if (_value > balanceOf(_from)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(_from, _value);\n', '            return AbstractToken.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Get virtual balance of the owner of given address.\n', '     *\n', '     * @param _owner address to get virtual balance for the owner of\n', '     * @return virtual balance of the owner of given address\n', '     */\n', '    function virtualBalanceOf (address _owner) internal view returns (uint256 _virtualBalance);\n', '\n', '    /**\n', '     * Calculate virtual balance of the owner of given address taking into account\n', '     * materialized flag and total number of real tokens already in circulation.\n', '     */\n', '    function getVirtualBalance (address _owner) private view returns (uint256 _virtualBalance) {\n', '        if (accounts [_owner] & MATERIALIZED_FLAG_MASK != 0) return 0;\n', '        else {\n', '            _virtualBalance = virtualBalanceOf(_owner);\n', '            uint256 maxVirtualBalance = MAXIMUM_TOKENS_COUNT.sub(tokensCount);\n', '            if (_virtualBalance > maxVirtualBalance)\n', '                _virtualBalance = maxVirtualBalance;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Materialize virtual balance of the owner of given address if this will help\n', '     * to transfer given number of tokens from it.\n', '     *\n', '     * @param _owner address to materialize virtual balance of\n', '     * @param _value number of tokens to be transferred\n', '     */\n', '    function materializeBalanceIfNeeded (address _owner, uint256 _value) private {\n', '        uint256 storedBalance = accounts[_owner];\n', '        if (storedBalance & MATERIALIZED_FLAG_MASK == 0) {\n', '            // Virtual balance is not materialized yet\n', '            if (_value > storedBalance) {\n', '                // Real balance is not enough\n', '                uint256 virtualBalance = getVirtualBalance(_owner);\n', '                require (_value.sub(storedBalance) <= virtualBalance);\n', '                accounts[_owner] = MATERIALIZED_FLAG_MASK | storedBalance.add(virtualBalance);\n', '                tokensCount = tokensCount.add(virtualBalance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Number of real (i.e. non-virtual) tokens in circulation.\n', '    */\n', '    uint256 tokensCount;\n', '}\n', '\n', '\n', '/**\n', ' * Etheal Promo ERC-20 contract\n', ' * Author: thesved\n', ' */\n', 'contract EthealPromoToken is HasNoTokens, AbstractVirtualToken {\n', '    // Balance threshold to assign virtual tokens to the owner of higher balances then this threshold.\n', '    uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether;\n', '\n', '    // Number of virtual tokens to assign to the owners of balances higher than virtual threshold.\n', '    uint256 private constant VIRTUAL_COUNT = 911;\n', '\n', '    // crowdsale to set bonus when sending token\n', '    iEthealSale public crowdsale;\n', '\n', '\n', '    ////////////////\n', '    // Basic functions\n', '    ////////////////\n', '\n', '    /// @dev Constructor, crowdsale address can be 0x0\n', '    function EthealPromoToken(address _crowdsale) {\n', '        crowdsale = iEthealSale(_crowdsale);\n', '    }\n', '\n', '    /// @dev Setting crowdsale, crowdsale address can be 0x0\n', '    function setCrowdsale(address _crowdsale) public onlyOwner {\n', '        crowdsale = iEthealSale(_crowdsale);\n', '    }\n', '\n', '    /// @notice Get virtual balance of the owner of given address.\n', '    /// @param _owner address to get virtual balance for the owner\n', '    /// @return virtual balance of the owner of given address\n', '    function virtualBalanceOf(address _owner) internal view returns (uint256) {\n', '        return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0;\n', '    }\n', '\n', '    /// @notice Get name of this token.\n', '    function name() public pure returns (string result) {\n', '        return "An Etheal Promo";\n', '    }\n', '\n', '    /// @notice Get symbol of this token.\n', '    function symbol() public pure returns (string result) {\n', '        return "HEALP";\n', '    }\n', '\n', '    /// @notice Get number of decimals for this token.\n', '    function decimals() public pure returns (uint8 result) {\n', '        return 0;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Set sale bonus\n', '    ////////////////\n', '\n', '    /// @dev Internal function for setting sale bonus\n', '    function setSaleBonus(address _from, address _to, uint256 _value) internal {\n', '        if (address(crowdsale) == address(0)) return;\n', '        if (_value == 0) return;\n', '\n', '        if (_to == address(1) || _to == address(this) || _to == address(crowdsale)) {\n', '            crowdsale.setPromoBonus(_from, _value);\n', '        }\n', '    }\n', '\n', '    /// @dev Override transfer function to set sale bonus\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transfer(_to, _value); \n', '\n', '        if (success) {\n', '            setSaleBonus(msg.sender, _to, _value);\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    /// @dev Override transfer function to set sale bonus\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '\n', '        if (success) {\n', '            setSaleBonus(_from, _to, _value);\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Extra\n', '    ////////////////\n', '\n', '    /// @notice Notify owners about their virtual balances.\n', '    function massNotify(address[] _owners) public onlyOwner {\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            Transfer(address(0), _owners[i], VIRTUAL_COUNT);\n', '        }\n', '    }\n', '\n', '    /// @notice Kill this smart contract.\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    \n', '}']
['pragma solidity ^0.4.17;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev ERC20 interface\n', ' */\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/// @dev Crowdsale interface for Etheal Normal Sale, functions needed from outside.\n', 'contract iEthealSale {\n', '    bool public paused;\n', '    uint256 public minContribution;\n', '    uint256 public whitelistThreshold;\n', '    mapping (address => uint256) public stakes;\n', '    function setPromoBonus(address _investor, uint256 _value) public;\n', '    function buyTokens(address _beneficiary) public payable;\n', '    function depositEth(address _beneficiary, uint256 _time, bytes _whitelistSign) public payable;\n', '    function depositOffchain(address _beneficiary, uint256 _amount, uint256 _time) public;\n', '    function hasEnded() public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title claim accidentally sent tokens\n', ' */\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    /// @notice This method can be used to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    /// @param _claimer Address that tokens will be send to\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/*\n', ' * ERC-20 Standard Token Smart Contract Interface.\n', ' * Copyright Â© 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () view returns (uint256 supply);\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the\n', '     *        owner of\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) view returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred\n', '     *        from the owner of\n', '     * @param _spender address to get number of tokens allowed to be transferred\n', '     *        by the owner of\n', '     * @return number of tokens given spender is currently allowed to transfer\n', '     *         from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) view returns (uint256 remaining);\n', '\n', '    /**\n', '     * Logged when tokens were transferred from one owner to another.\n', '     *\n', '     * @param _from address of the owner, tokens were transferred from\n', '     * @param _to address of the owner, tokens were transferred to\n', '     * @param _value number of tokens transferred\n', '     */\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '     * Logged when owner approved his tokens to be transferred by some spender.\n', '     *\n', '     * @param _owner owner who approved his tokens to be transferred\n', '     * @param _spender spender who were allowed to transfer the tokens belonging\n', '     *        to the owner\n', '     * @param _value number of tokens belonging to the owner, approved to be\n', '     *        transferred by the spender\n', '     */\n', '    event Approval (address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*\n', ' * Abstract Token Smart Contract.  Copyright Â© 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' * Modified to use SafeMath library by thesved\n', ' */\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts.\n', ' */\n', 'contract AbstractToken is Token {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Create new Abstract Token contract.\n', '     */\n', '    function AbstractToken () {\n', '        // Do nothing\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the owner\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) view returns (uint256 balance) {\n', '        return accounts[_owner];\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success) {\n', '        uint256 fromBalance = accounts[msg.sender];\n', '        if (fromBalance < _value) return false;\n', '        if (_value > 0 && msg.sender != _to) {\n', '            accounts[msg.sender] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success) {\n', '        uint256 spenderAllowance = allowances[_from][msg.sender];\n', '        if (spenderAllowance < _value) return false;\n', '        uint256 fromBalance = accounts[_from];\n', '        if (fromBalance < _value) return false;\n', '\n', '        allowances[_from][msg.sender] = spenderAllowance.sub(_value);\n', '\n', '        if (_value > 0 && _from != _to) {\n', '            accounts[_from] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(_from, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred from the owner\n', '     * @param _spender address to get number of tokens allowed to be transferred by the owner\n', '     * @return number of tokens given spender is currently allowed to transfer from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) view returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * Mapping from addresses of token holders to the numbers of tokens belonging\n', '     * to these token holders.\n', '     */\n', '    mapping (address => uint256) accounts;\n', '\n', '    /**\n', '     * Mapping from addresses of token holders to the mapping of addresses of\n', '     * spenders to the allowances set by these token holders to these spenders.\n', '     */\n', '    mapping (address => mapping (address => uint256)) private allowances;\n', '}\n', '\n', '\n', '/*\n', ' * Abstract Virtual Token Smart Contract.  Copyright Â© 2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' * Modified to use SafeMath library by thesved\n', ' */\n', '\n', '/**\n', ' * Abstract Token Smart Contract that could be used as a base contract for\n', ' * ERC-20 token contracts supporting virtual balance.\n', ' */\n', 'contract AbstractVirtualToken is AbstractToken {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Maximum number of real (i.e. non-virtual) tokens in circulation (2^255-1).\n', '     */\n', '    uint256 constant MAXIMUM_TOKENS_COUNT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Mask used to extract real balance of an account (2^255-1).\n', '     */\n', '    uint256 constant BALANCE_MASK = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Mask used to extract "materialized" flag of an account (2^255).\n', '     */\n', '    uint256 constant MATERIALIZED_FLAG_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * Create new Abstract Virtual Token contract.\n', '     */\n', '    function AbstractVirtualToken () {\n', '        // Do nothing\n', '    }\n', '\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () view returns (uint256 supply) {\n', '        return tokensCount;\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the owner\n', '     * @return number of tokens currently belonging to the owner of given address\n', '    */\n', '    function balanceOf (address _owner) constant returns (uint256 balance) { \n', '        return (accounts[_owner] & BALANCE_MASK).add(getVirtualBalance(_owner));\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success) {\n', '        if (_value > balanceOf(msg.sender)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(msg.sender, _value);\n', '            return AbstractToken.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (_value > allowance(_from, msg.sender)) return false;\n', '        if (_value > balanceOf(_from)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(_from, _value);\n', '            return AbstractToken.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Get virtual balance of the owner of given address.\n', '     *\n', '     * @param _owner address to get virtual balance for the owner of\n', '     * @return virtual balance of the owner of given address\n', '     */\n', '    function virtualBalanceOf (address _owner) internal view returns (uint256 _virtualBalance);\n', '\n', '    /**\n', '     * Calculate virtual balance of the owner of given address taking into account\n', '     * materialized flag and total number of real tokens already in circulation.\n', '     */\n', '    function getVirtualBalance (address _owner) private view returns (uint256 _virtualBalance) {\n', '        if (accounts [_owner] & MATERIALIZED_FLAG_MASK != 0) return 0;\n', '        else {\n', '            _virtualBalance = virtualBalanceOf(_owner);\n', '            uint256 maxVirtualBalance = MAXIMUM_TOKENS_COUNT.sub(tokensCount);\n', '            if (_virtualBalance > maxVirtualBalance)\n', '                _virtualBalance = maxVirtualBalance;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Materialize virtual balance of the owner of given address if this will help\n', '     * to transfer given number of tokens from it.\n', '     *\n', '     * @param _owner address to materialize virtual balance of\n', '     * @param _value number of tokens to be transferred\n', '     */\n', '    function materializeBalanceIfNeeded (address _owner, uint256 _value) private {\n', '        uint256 storedBalance = accounts[_owner];\n', '        if (storedBalance & MATERIALIZED_FLAG_MASK == 0) {\n', '            // Virtual balance is not materialized yet\n', '            if (_value > storedBalance) {\n', '                // Real balance is not enough\n', '                uint256 virtualBalance = getVirtualBalance(_owner);\n', '                require (_value.sub(storedBalance) <= virtualBalance);\n', '                accounts[_owner] = MATERIALIZED_FLAG_MASK | storedBalance.add(virtualBalance);\n', '                tokensCount = tokensCount.add(virtualBalance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Number of real (i.e. non-virtual) tokens in circulation.\n', '    */\n', '    uint256 tokensCount;\n', '}\n', '\n', '\n', '/**\n', ' * Etheal Promo ERC-20 contract\n', ' * Author: thesved\n', ' */\n', 'contract EthealPromoToken is HasNoTokens, AbstractVirtualToken {\n', '    // Balance threshold to assign virtual tokens to the owner of higher balances then this threshold.\n', '    uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether;\n', '\n', '    // Number of virtual tokens to assign to the owners of balances higher than virtual threshold.\n', '    uint256 private constant VIRTUAL_COUNT = 911;\n', '\n', '    // crowdsale to set bonus when sending token\n', '    iEthealSale public crowdsale;\n', '\n', '\n', '    ////////////////\n', '    // Basic functions\n', '    ////////////////\n', '\n', '    /// @dev Constructor, crowdsale address can be 0x0\n', '    function EthealPromoToken(address _crowdsale) {\n', '        crowdsale = iEthealSale(_crowdsale);\n', '    }\n', '\n', '    /// @dev Setting crowdsale, crowdsale address can be 0x0\n', '    function setCrowdsale(address _crowdsale) public onlyOwner {\n', '        crowdsale = iEthealSale(_crowdsale);\n', '    }\n', '\n', '    /// @notice Get virtual balance of the owner of given address.\n', '    /// @param _owner address to get virtual balance for the owner\n', '    /// @return virtual balance of the owner of given address\n', '    function virtualBalanceOf(address _owner) internal view returns (uint256) {\n', '        return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0;\n', '    }\n', '\n', '    /// @notice Get name of this token.\n', '    function name() public pure returns (string result) {\n', '        return "An Etheal Promo";\n', '    }\n', '\n', '    /// @notice Get symbol of this token.\n', '    function symbol() public pure returns (string result) {\n', '        return "HEALP";\n', '    }\n', '\n', '    /// @notice Get number of decimals for this token.\n', '    function decimals() public pure returns (uint8 result) {\n', '        return 0;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Set sale bonus\n', '    ////////////////\n', '\n', '    /// @dev Internal function for setting sale bonus\n', '    function setSaleBonus(address _from, address _to, uint256 _value) internal {\n', '        if (address(crowdsale) == address(0)) return;\n', '        if (_value == 0) return;\n', '\n', '        if (_to == address(1) || _to == address(this) || _to == address(crowdsale)) {\n', '            crowdsale.setPromoBonus(_from, _value);\n', '        }\n', '    }\n', '\n', '    /// @dev Override transfer function to set sale bonus\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transfer(_to, _value); \n', '\n', '        if (success) {\n', '            setSaleBonus(msg.sender, _to, _value);\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    /// @dev Override transfer function to set sale bonus\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '\n', '        if (success) {\n', '            setSaleBonus(_from, _to, _value);\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '\n', '    ////////////////\n', '    // Extra\n', '    ////////////////\n', '\n', '    /// @notice Notify owners about their virtual balances.\n', '    function massNotify(address[] _owners) public onlyOwner {\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            Transfer(address(0), _owners[i], VIRTUAL_COUNT);\n', '        }\n', '    }\n', '\n', '    /// @notice Kill this smart contract.\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    \n', '}']
