['pragma solidity ^0.4.24;\n', '\n', 'contract ExchangeAdmin {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyAdmin {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'library StringYokes {\n', '    function zint_bytes32ToString(bytes32 x) public pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '    function zint_convert(string key) public pure returns (bytes32 ret) {\n', '        if (bytes(key).length > 32) revert();\n', '        assembly {\n', '          ret := mload(add(key, 32))\n', '        }\n', '    }\n', '}\n', 'contract Game is ExchangeAdmin {\n', '    bool expired;\n', '    struct Better {\n', '        bool used;\n', '        address betterAddress;\n', '        uint contribAmount;\n', '    }\n', '    struct Side {\n', '        bool isValidSide;\n', '        uint totalPledged;\n', '        bytes32 sideName;\n', '        address[] usedAddresses;\n', '        mapping (address => Better) contribDb;\n', '    }\n', '    string gName;\n', '    address gameMaker;\n', '    address mainContract;\n', '    bytes32[] sides;\n', '    uint allSidesPledged;\n', '    uint expiry;\n', '    mapping (bytes32 => Side) public sideData;\n', '    mapping (bytes32 => uint) public idToNameRef;\n', '    constructor (string gameName, uint gameExpiry, bytes32[] gameSides,address maker, address mainContractAdd) public {\n', '        require(now<gameExpiry);\n', '        gName = gameName;\n', '        gameMaker = maker;\n', '        expiry = gameExpiry;\n', '        mainContract = mainContractAdd;\n', '        for (uint i = 0; i<gameSides.length; i++) {\n', '            sideData[gameSides[i]].sideName=gameSides[i];\n', '            sideData[gameSides[i]].isValidSide=true;\n', '            idToNameRef[gameSides[i]]=i;\n', '            sides.push(gameSides[i]);\n', '        }\n', '        expired = false;\n', '        allSidesPledged = 0;\n', '    }\n', '    function getGameName() view public returns (string) {\n', '        return gName;\n', '    }\n', '    function getGameMaker() view public returns(address){\n', '      return gameMaker;\n', '    }\n', '    function getGameSides() view public returns (bytes32[]) {\n', '        return sides;\n', '    }\n', '    function isNotExpired() view public returns (bool) {\n', '        return ((now < expiry) && !expired);\n', '    }\n', '    function isExpired() view public returns(bool){\n', '        return expired;\n', '    }\n', '    function getNumSides() view public returns (uint) {\n', '        return sides.length;\n', '    }\n', '    function getExpiryTime() view public returns(uint){\n', '      return expiry;\n', '    }\n', '    function getStrFromId(uint toConv) view public returns (string) {\n', '        return StringYokes.zint_bytes32ToString(sides[toConv]);\n', '    }\n', '    function getIdFromStr(string toConv) view public returns (uint) {\n', '        return idToNameRef[StringYokes.zint_convert(toConv)];\n', '    }\n', '    function placeBet(address a, uint value, string betSide) public payable {\n', '        require(isNotExpired() && value!=0 && msg.sender==mainContract && sideData[StringYokes.zint_convert(betSide)].isValidSide);\n', '        bytes32 index = StringYokes.zint_convert(betSide);\n', '        sideData[index].totalPledged+=value;\n', '        allSidesPledged+=value;\n', '        if (!sideData[index].contribDb[a].used) {\n', '            sideData[index].usedAddresses.push(a);\n', '            sideData[index].contribDb[a].used=true;\n', '        }\n', '        sideData[index].contribDb[a].contribAmount+=value;\n', '    }\n', '    function allSidesPledgedAmount() public view returns (uint) {\n', '        return allSidesPledged;\n', '    }\n', '    function checkSidePledge(uint i) public view returns (uint) {\n', '        return sideData[sides[i]].totalPledged;\n', '    }\n', '    function dish(string winner, address profit) public payable {\n', '        require((!expired) && (mainContract==msg.sender));\n', '        expired = true;\n', '        bytes32 winByte = StringYokes.zint_convert(winner);\n', '        uint totalGameContrib = allSidesPledged;\n', '        uint totalSideContrib = (sideData[winByte].totalPledged);\n', '        for (uint i = 0; i<sideData[winByte].usedAddresses.length; i++) {\n', '            address recip = sideData[winByte].usedAddresses[i];\n', '            uint contribAmount = sideData[winByte].contribDb[recip].contribAmount;\n', '            uint winAddition = (950*1000*contribAmount*(totalGameContrib-totalSideContrib))/(1000000*totalSideContrib);\n', '            recip.transfer(contribAmount+winAddition);\n', '        }\n', '        profit.transfer(2*(address(this).balance/5));\n', '        gameMaker.transfer(address(this).balance);\n', '    }\n', '    function refund(address sentBy) public payable {\n', '        require(!expired && (mainContract==msg.sender) && ((sentBy==gameMaker) || now > getExpiryTime() + 259200));\n', '        for (uint i = 0; i<sides.length; i++) {\n', '            for (uint j = 0; j<sideData[sides[i]].usedAddresses.length; j++) {\n', '                address recip = sideData[sides[i]].usedAddresses[j];\n', '                uint contribAmount = sideData[sides[i]].contribDb[recip].contribAmount;\n', '                recip.transfer(contribAmount);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract MUBet is ExchangeAdmin {\n', '    Game[] current;\n', '    constructor () public {    }\n', '\n', '    function numGames() view public returns (uint nGames) {\n', '        return current.length;\n', '    }\n', '    function getName(uint i) view public returns (string gameName, bool isNotExpired, uint totalPledgedETH, bool wasFinalised, uint gameEndTime, address gameMakerAddress, uint gameNumSides, uint gameId) {\n', '       return (current[i].getGameName(), current[i].isNotExpired(), current[i].allSidesPledgedAmount(),current[i].isExpired(),current[i].getExpiryTime(), current[i].getGameMaker(), current[i].getNumSides(), i);\n', '    }\n', '    function getSidesArray(uint i) view public returns (bytes32[] sideNameBytes) {\n', '        return current[i].getGameSides();\n', '    }\n', '    function getSidesById(uint i, uint j) view public returns (string sideName, uint sidePledgedETH) {\n', '        return (StringYokes.zint_bytes32ToString(current[i].getGameSides()[j]), current[i].checkSidePledge(j));\n', '    }\n', '    function getGameNumSides(uint i) view public returns (uint gameNumSides) {\n', '        return current[i].getNumSides();\n', '    }\n', '    function getContractBal() public view returns (uint invalidBalanceETH) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function () public payable {    }\n', '    function emergency(uint amount, address recipient) public onlyAdmin payable {\n', '        recipient.transfer(amount);\n', '    }\n', '    function addGame(string gameName, uint gameExpiry, bytes32[] gameSides) public {\n', '        require(gameSides.length > 1);\n', '        current.push(new Game(gameName, gameExpiry, gameSides, msg.sender, address(this)));\n', '    }\n', '    function endGame(uint gameId, string winningSide) public  {\n', '        require(current[gameId].getGameMaker() == msg.sender);\n', '        current[gameId].dish(winningSide,owner);\n', '    }\n', '    function refund(uint gameId) public {\n', '        current[gameId].refund(msg.sender);\n', '    }\n', '    function placeBet(uint gameId, string betSide) payable public {\n', '        current[gameId].placeBet.value(msg.value)(msg.sender, msg.value, betSide);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ExchangeAdmin {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyAdmin {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'library StringYokes {\n', '    function zint_bytes32ToString(bytes32 x) public pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '    function zint_convert(string key) public pure returns (bytes32 ret) {\n', '        if (bytes(key).length > 32) revert();\n', '        assembly {\n', '          ret := mload(add(key, 32))\n', '        }\n', '    }\n', '}\n', 'contract Game is ExchangeAdmin {\n', '    bool expired;\n', '    struct Better {\n', '        bool used;\n', '        address betterAddress;\n', '        uint contribAmount;\n', '    }\n', '    struct Side {\n', '        bool isValidSide;\n', '        uint totalPledged;\n', '        bytes32 sideName;\n', '        address[] usedAddresses;\n', '        mapping (address => Better) contribDb;\n', '    }\n', '    string gName;\n', '    address gameMaker;\n', '    address mainContract;\n', '    bytes32[] sides;\n', '    uint allSidesPledged;\n', '    uint expiry;\n', '    mapping (bytes32 => Side) public sideData;\n', '    mapping (bytes32 => uint) public idToNameRef;\n', '    constructor (string gameName, uint gameExpiry, bytes32[] gameSides,address maker, address mainContractAdd) public {\n', '        require(now<gameExpiry);\n', '        gName = gameName;\n', '        gameMaker = maker;\n', '        expiry = gameExpiry;\n', '        mainContract = mainContractAdd;\n', '        for (uint i = 0; i<gameSides.length; i++) {\n', '            sideData[gameSides[i]].sideName=gameSides[i];\n', '            sideData[gameSides[i]].isValidSide=true;\n', '            idToNameRef[gameSides[i]]=i;\n', '            sides.push(gameSides[i]);\n', '        }\n', '        expired = false;\n', '        allSidesPledged = 0;\n', '    }\n', '    function getGameName() view public returns (string) {\n', '        return gName;\n', '    }\n', '    function getGameMaker() view public returns(address){\n', '      return gameMaker;\n', '    }\n', '    function getGameSides() view public returns (bytes32[]) {\n', '        return sides;\n', '    }\n', '    function isNotExpired() view public returns (bool) {\n', '        return ((now < expiry) && !expired);\n', '    }\n', '    function isExpired() view public returns(bool){\n', '        return expired;\n', '    }\n', '    function getNumSides() view public returns (uint) {\n', '        return sides.length;\n', '    }\n', '    function getExpiryTime() view public returns(uint){\n', '      return expiry;\n', '    }\n', '    function getStrFromId(uint toConv) view public returns (string) {\n', '        return StringYokes.zint_bytes32ToString(sides[toConv]);\n', '    }\n', '    function getIdFromStr(string toConv) view public returns (uint) {\n', '        return idToNameRef[StringYokes.zint_convert(toConv)];\n', '    }\n', '    function placeBet(address a, uint value, string betSide) public payable {\n', '        require(isNotExpired() && value!=0 && msg.sender==mainContract && sideData[StringYokes.zint_convert(betSide)].isValidSide);\n', '        bytes32 index = StringYokes.zint_convert(betSide);\n', '        sideData[index].totalPledged+=value;\n', '        allSidesPledged+=value;\n', '        if (!sideData[index].contribDb[a].used) {\n', '            sideData[index].usedAddresses.push(a);\n', '            sideData[index].contribDb[a].used=true;\n', '        }\n', '        sideData[index].contribDb[a].contribAmount+=value;\n', '    }\n', '    function allSidesPledgedAmount() public view returns (uint) {\n', '        return allSidesPledged;\n', '    }\n', '    function checkSidePledge(uint i) public view returns (uint) {\n', '        return sideData[sides[i]].totalPledged;\n', '    }\n', '    function dish(string winner, address profit) public payable {\n', '        require((!expired) && (mainContract==msg.sender));\n', '        expired = true;\n', '        bytes32 winByte = StringYokes.zint_convert(winner);\n', '        uint totalGameContrib = allSidesPledged;\n', '        uint totalSideContrib = (sideData[winByte].totalPledged);\n', '        for (uint i = 0; i<sideData[winByte].usedAddresses.length; i++) {\n', '            address recip = sideData[winByte].usedAddresses[i];\n', '            uint contribAmount = sideData[winByte].contribDb[recip].contribAmount;\n', '            uint winAddition = (950*1000*contribAmount*(totalGameContrib-totalSideContrib))/(1000000*totalSideContrib);\n', '            recip.transfer(contribAmount+winAddition);\n', '        }\n', '        profit.transfer(2*(address(this).balance/5));\n', '        gameMaker.transfer(address(this).balance);\n', '    }\n', '    function refund(address sentBy) public payable {\n', '        require(!expired && (mainContract==msg.sender) && ((sentBy==gameMaker) || now > getExpiryTime() + 259200));\n', '        for (uint i = 0; i<sides.length; i++) {\n', '            for (uint j = 0; j<sideData[sides[i]].usedAddresses.length; j++) {\n', '                address recip = sideData[sides[i]].usedAddresses[j];\n', '                uint contribAmount = sideData[sides[i]].contribDb[recip].contribAmount;\n', '                recip.transfer(contribAmount);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract MUBet is ExchangeAdmin {\n', '    Game[] current;\n', '    constructor () public {    }\n', '\n', '    function numGames() view public returns (uint nGames) {\n', '        return current.length;\n', '    }\n', '    function getName(uint i) view public returns (string gameName, bool isNotExpired, uint totalPledgedETH, bool wasFinalised, uint gameEndTime, address gameMakerAddress, uint gameNumSides, uint gameId) {\n', '       return (current[i].getGameName(), current[i].isNotExpired(), current[i].allSidesPledgedAmount(),current[i].isExpired(),current[i].getExpiryTime(), current[i].getGameMaker(), current[i].getNumSides(), i);\n', '    }\n', '    function getSidesArray(uint i) view public returns (bytes32[] sideNameBytes) {\n', '        return current[i].getGameSides();\n', '    }\n', '    function getSidesById(uint i, uint j) view public returns (string sideName, uint sidePledgedETH) {\n', '        return (StringYokes.zint_bytes32ToString(current[i].getGameSides()[j]), current[i].checkSidePledge(j));\n', '    }\n', '    function getGameNumSides(uint i) view public returns (uint gameNumSides) {\n', '        return current[i].getNumSides();\n', '    }\n', '    function getContractBal() public view returns (uint invalidBalanceETH) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function () public payable {    }\n', '    function emergency(uint amount, address recipient) public onlyAdmin payable {\n', '        recipient.transfer(amount);\n', '    }\n', '    function addGame(string gameName, uint gameExpiry, bytes32[] gameSides) public {\n', '        require(gameSides.length > 1);\n', '        current.push(new Game(gameName, gameExpiry, gameSides, msg.sender, address(this)));\n', '    }\n', '    function endGame(uint gameId, string winningSide) public  {\n', '        require(current[gameId].getGameMaker() == msg.sender);\n', '        current[gameId].dish(winningSide,owner);\n', '    }\n', '    function refund(uint gameId) public {\n', '        current[gameId].refund(msg.sender);\n', '    }\n', '    function placeBet(uint gameId, string betSide) payable public {\n', '        current[gameId].placeBet.value(msg.value)(msg.sender, msg.value, betSide);\n', '    }\n', '}']
