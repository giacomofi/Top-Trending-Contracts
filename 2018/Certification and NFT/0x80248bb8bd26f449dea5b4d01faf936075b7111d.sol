['pragma solidity ^0.4.23;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n', '}\n', '\n', '/**\n', ' * DreamTeam token contract. It implements the next capabilities:\n', ' * 1. Standard ERC20 functionality. [OK]\n', ' * 2. Additional utility function approveAndCall. [OK]\n', ' * 3. Function to rescue "lost forever" tokens, which were accidentally sent to the contract address. [OK]\n', ' * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n', ' *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [OK]\n', ' * 5. Token sale distribution rules. [OK]\n', ' * \n', ' * Testing DreamTeam Token distribution\n', ' * Solidity contract by Nikita @ https://nikita.tk\n', ' */\n', 'contract Pasadena {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n', '    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n', '    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    bytes public ethSignedMessagePrefix = "\\x19Ethereum Signed Message:\\n";\n', '    enum sigStandard { typed, personal, stringHex }\n', '    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n', '    bytes32 public sigDestinationTransfer = keccak256(\n', '        "address Token Contract Address",\n', '        "address Sender&#39;s Address",\n', '        "address Recipient&#39;s Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationTransferFrom = keccak256(\n', '        "address Token Contract Address",\n', '        "address Address Approved for Withdraw",\n', '        "address Account to Withdraw From",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationApprove = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "bytes Data to Transfer",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n', '\n', '    constructor (string tokenName, string tokenSymbol) public {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        rescueAccount = tokenDistributor = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n', '     */\n', '    function internalTransfer (address from, address to, uint value) internal {\n', '        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n', '        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n', '        balanceOf[from] -= value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n', '     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n', '     * transfers are impossible.\n', '     */\n', '    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n', '        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n', '            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n', '            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n', '        );\n', '        balanceOf[from] -= value1 + value2;\n', '        balanceOf[to1] += value1;\n', '        emit Transfer(from, to1, value1);\n', '        if (value2 > 0) {\n', '            balanceOf[to2] += value2;\n', '            emit Transfer(from, to2, value2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n', '     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n', '     * development there is no single signing standard defined. For example, Metamask and Geth both support\n', '     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support "widely adopted"\n', '     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n', '     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n', '     * third-party wallets must adopt a single standard for signing messages.\n', '     */\n', '    function requireSignature (\n', '        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n', '    ) internal {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        assembly { // solium-disable-line security/no-inline-assembly\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '        if (v < 27)\n', '            v += 27;\n', '        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n', '        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n', '            require(\n', '                signer == ecrecover(\n', '                    keccak256(\n', '                        signDest == sigDestination.transfer\n', '                            ? sigDestinationTransfer\n', '                            : signDest == sigDestination.approve\n', '                                ? sigDestinationApprove\n', '                                : signDest == sigDestination.approveAndCall\n', '                                    ? sigDestinationApproveAndCall\n', '                                    : sigDestinationTransferFrom,\n', '                        data\n', '                    ),\n', '                    v, r, s\n', '                )\n', '            );\n', '        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s) // Geth-adopted\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x20", data), v, r, s) // Trezor-adopted\n', '            );\n', '        } else { // == 2; Signed string hash signature (the most expensive but universal)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s) // Geth\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x40", hexToString(data)), v, r, s) // Trezor\n', '            );\n', '        }\n', '        usedSigIds[signer][sigId] = true;\n', '    }\n', '\n', '    /**\n', '     * Utility costly function to encode bytes HEX representation as string.\n', '     * @param sig - signature to encode.\n', '     */\n', '    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n', '        bytes memory str = new bytes(64);\n', '        for (uint8 i = 0; i < 32; ++i) {\n', '            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n', '            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n', '        }\n', '        return str;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the account of sender.\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transfer (address to, uint256 value) public returns (bool) {\n', '        internalTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n', '     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n', '     * owner.\n', '     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there&#39;s\n', '     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n', '     * with the same sigId, thus ensuring that the previous signature won&#39;t be used if the new one passes.\n', '     * Use case: the user wants to send some tokens to other user or smart contract, but don&#39;t have ether to do so.\n', '     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n', '     * @param to - the account receiving `value` tokens\n', '     * @param value - the value in tokens to transfer\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferViaSignature (\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n', '        );\n', '        internalDoubleTransfer(from, to, value, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow `spender` to take `value` tokens from the transaction sender&#39;s account.\n', '     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender - the address authorized to spend\n', '     * @param value - the maximum amount they can spend\n', '     */\n', '    function approve (address spender, uint256 value) public returns (bool) {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `approve`.\n', '     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n', '     * balance.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n', '     */\n', '    function approveViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approve\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        internalTransfer(from, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n', '        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n', '        allowance[from][msg.sender] -= value;\n', '        internalTransfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `transferFrom`.\n', '     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n', '     * Important note: fee is subtracted from `value` before it reaches `to`.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFromViaSignature (\n', '        address     signer,\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n', '            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n', '        );\n', '        require(value <= allowance[from][signer] && value >= fee);\n', '        allowance[from][signer] -= value;\n', '        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n', '     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n', '     * withdraw tokens from the sender&#39;s account and receive additional `extraData` for processing.\n', '     * @param spender - the address to be authorized to spend tokens\n', '     * @param value - the max amount the `spender` can withdraw\n', '     * @param extraData - some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n', '        approve(spender, value);\n', '        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `approveViaSignature`, but for `approveAndCall`.\n', '     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param extraData - additional data to pass to the `spender` smart contract\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', '     * @param sig - signature made by `from`, which is the proof of `from`&#39;s agreement with the above parameters\n', '     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n', '     */\n', '    function approveAndCallViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        bytes       extraData,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n', '        internalTransfer(from, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n', '     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n', '     * @param recipients - Addresses of token recipients\n', '     * @param amounts - Corresponding amount of each token recipient in `recipients`\n', '     */\n', '    function multiMint (address[] recipients, uint256[] amounts) external {\n', '        \n', '        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n', '        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n', '\n', '        uint total = 0;\n', '\n', '        for (uint i = 0; i < recipients.length; ++i) {\n', '            balanceOf[recipients[i]] += amounts[i];\n', '            total += amounts[i];\n', '            emit Transfer(0x0, recipients[i], amounts[i]);\n', '        }\n', '\n', '        totalSupply += total;\n', '        \n', '    }\n', '\n', '    /**\n', '     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n', '     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n', '     */\n', '    function lastMint () external {\n', '\n', '        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n', '\n', '        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n', '\n', '        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam&#39;s balance\n', '        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n', '        if (fractionalPart <= remaining)\n', '            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n', '\n', '        balanceOf[tokenDistributor] += remaining;\n', '        emit Transfer(0x0, tokenDistributor, remaining);\n', '\n', '        totalSupply += remaining;\n', '        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n', '\n', '    }\n', '\n', '    /**\n', '     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n', '     * to the address of this smart contract.\n', '     * @param tokenContract - ERC-20 compatible token\n', '     * @param value - amount to rescue\n', '     */\n', '    function rescueTokens (Pasadena tokenContract, uint256 value) public {\n', '        require(msg.sender == rescueAccount);\n', '        tokenContract.approve(rescueAccount, value);\n', '    }\n', '\n', '    /**\n', '     * Utility function that allows to change the rescueAccount address.\n', '     * @param newRescueAccount - account which will be authorized to rescue tokens.\n', '     */\n', '    function changeRescueAccount (address newRescueAccount) public {\n', '        require(msg.sender == rescueAccount);\n', '        rescueAccount = newRescueAccount;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n', '}\n', '\n', '/**\n', ' * DreamTeam token contract. It implements the next capabilities:\n', ' * 1. Standard ERC20 functionality. [OK]\n', ' * 2. Additional utility function approveAndCall. [OK]\n', ' * 3. Function to rescue "lost forever" tokens, which were accidentally sent to the contract address. [OK]\n', ' * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n', ' *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [OK]\n', ' * 5. Token sale distribution rules. [OK]\n', ' * \n', ' * Testing DreamTeam Token distribution\n', ' * Solidity contract by Nikita @ https://nikita.tk\n', ' */\n', 'contract Pasadena {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n', '    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n', '    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    bytes public ethSignedMessagePrefix = "\\x19Ethereum Signed Message:\\n";\n', '    enum sigStandard { typed, personal, stringHex }\n', '    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n', '    bytes32 public sigDestinationTransfer = keccak256(\n', '        "address Token Contract Address",\n', '        "address Sender\'s Address",\n', '        "address Recipient\'s Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationTransferFrom = keccak256(\n', '        "address Token Contract Address",\n', '        "address Address Approved for Withdraw",\n', '        "address Account to Withdraw From",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationApprove = keccak256(\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n', '    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n', '        "address Token Contract Address",\n', '        "address Withdrawal Approval Address",\n', '        "address Withdrawal Recipient Address",\n', '        "uint256 Amount to Transfer (last six digits are decimals)",\n', '        "bytes Data to Transfer",\n', '        "uint256 Fee in Tokens Paid to Executor (last six digits are decimals)",\n', '        "uint256 Signature Expiration Timestamp (unix timestamp)",\n', '        "uint256 Signature ID"\n', '    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n', '\n', '    constructor (string tokenName, string tokenSymbol) public {\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        rescueAccount = tokenDistributor = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n', '     */\n', '    function internalTransfer (address from, address to, uint value) internal {\n', '        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n', '        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n', '        balanceOf[from] -= value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n', '     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n', '     * transfers are impossible.\n', '     */\n', '    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n', '        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n', '            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n', '            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n', '        );\n', '        balanceOf[from] -= value1 + value2;\n', '        balanceOf[to1] += value1;\n', '        emit Transfer(from, to1, value1);\n', '        if (value2 > 0) {\n', '            balanceOf[to2] += value2;\n', '            emit Transfer(from, to2, value2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n', '     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n', '     * development there is no single signing standard defined. For example, Metamask and Geth both support\n', '     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support "widely adopted"\n', '     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n', '     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n', '     * third-party wallets must adopt a single standard for signing messages.\n', '     */\n', '    function requireSignature (\n', '        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n', '    ) internal {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '        assembly { // solium-disable-line security/no-inline-assembly\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '        if (v < 27)\n', '            v += 27;\n', '        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n', '        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n', '            require(\n', '                signer == ecrecover(\n', '                    keccak256(\n', '                        signDest == sigDestination.transfer\n', '                            ? sigDestinationTransfer\n', '                            : signDest == sigDestination.approve\n', '                                ? sigDestinationApprove\n', '                                : signDest == sigDestination.approveAndCall\n', '                                    ? sigDestinationApproveAndCall\n', '                                    : sigDestinationTransferFrom,\n', '                        data\n', '                    ),\n', '                    v, r, s\n', '                )\n', '            );\n', '        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s) // Geth-adopted\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x20", data), v, r, s) // Trezor-adopted\n', '            );\n', '        } else { // == 2; Signed string hash signature (the most expensive but universal)\n', '            require(\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s) // Geth\n', '                ||\n', '                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\\x40", hexToString(data)), v, r, s) // Trezor\n', '            );\n', '        }\n', '        usedSigIds[signer][sigId] = true;\n', '    }\n', '\n', '    /**\n', '     * Utility costly function to encode bytes HEX representation as string.\n', '     * @param sig - signature to encode.\n', '     */\n', '    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n', '        bytes memory str = new bytes(64);\n', '        for (uint8 i = 0; i < 32; ++i) {\n', '            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n', '            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n', '        }\n', '        return str;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the account of sender.\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transfer (address to, uint256 value) public returns (bool) {\n', '        internalTransfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n', '     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n', '     * owner.\n', "     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n", '     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n', "     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n", "     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n", '     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n', '     * @param to - the account receiving `value` tokens\n', '     * @param value - the value in tokens to transfer\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n', '     */\n', '    function transferViaSignature (\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, to, value, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n', '        );\n', '        internalDoubleTransfer(from, to, value, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Allow `spender` to take `value` tokens from the transaction sender's account.\n", '     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender - the address authorized to spend\n', '     * @param value - the maximum amount they can spend\n', '     */\n', '    function approve (address spender, uint256 value) public returns (bool) {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `approve`.\n', '     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n', '     * balance.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n', '     */\n', '    function approveViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approve\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        internalTransfer(from, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n', '        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n', '        allowance[from][msg.sender] -= value;\n', '        internalTransfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `transferViaSignature`, but for `transferFrom`.\n', '     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n', '     * Important note: fee is subtracted from `value` before it reaches `to`.\n', '     * @param from - the address to transfer tokens from\n', '     * @param to - the address of the recipient\n', '     * @param value - the amount to send\n', '     */\n', '    function transferFromViaSignature (\n', '        address     signer,\n', '        address     from,\n', '        address     to,\n', '        uint256     value,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n', '            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n', '        );\n', '        require(value <= allowance[from][signer] && value >= fee);\n', '        allowance[from][signer] -= value;\n', '        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n', '     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n', "     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n", '     * @param spender - the address to be authorized to spend tokens\n', '     * @param value - the max amount the `spender` can withdraw\n', '     * @param extraData - some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n', '        approve(spender, value);\n', '        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Same as `approveViaSignature`, but for `approveAndCall`.\n', '     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n', '     * @param from - the account to approve withdrawal from, which signed all below parameters\n', '     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n', '     * @param value - the value in tokens to approve to withdraw\n', '     * @param extraData - additional data to pass to the `spender` smart contract\n', '     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n', '     * @param deadline - until when the signature is valid\n', '     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n', "     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n", '     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n', '     */\n', '    function approveAndCallViaSignature (\n', '        address     from,\n', '        address     spender,\n', '        uint256     value,\n', '        bytes       extraData,\n', '        uint256     fee,\n', '        uint256     deadline,\n', '        uint256     sigId,\n', '        bytes       sig,\n', '        sigStandard sigStd\n', '    ) external returns (bool) {\n', '        requireSignature(\n', '            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n', '            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n', '        );\n', '        allowance[from][spender] = value;\n', '        emit Approval(from, spender, value);\n', '        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n', '        internalTransfer(from, msg.sender, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n', '     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n', '     * @param recipients - Addresses of token recipients\n', '     * @param amounts - Corresponding amount of each token recipient in `recipients`\n', '     */\n', '    function multiMint (address[] recipients, uint256[] amounts) external {\n', '        \n', '        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n', '        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n', '\n', '        uint total = 0;\n', '\n', '        for (uint i = 0; i < recipients.length; ++i) {\n', '            balanceOf[recipients[i]] += amounts[i];\n', '            total += amounts[i];\n', '            emit Transfer(0x0, recipients[i], amounts[i]);\n', '        }\n', '\n', '        totalSupply += total;\n', '        \n', '    }\n', '\n', '    /**\n', '     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n', '     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n', '     */\n', '    function lastMint () external {\n', '\n', '        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n', '\n', '        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n', '\n', "        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n", '        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n', '        if (fractionalPart <= remaining)\n', '            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n', '\n', '        balanceOf[tokenDistributor] += remaining;\n', '        emit Transfer(0x0, tokenDistributor, remaining);\n', '\n', '        totalSupply += remaining;\n', '        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n', '\n', '    }\n', '\n', '    /**\n', '     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n', '     * to the address of this smart contract.\n', '     * @param tokenContract - ERC-20 compatible token\n', '     * @param value - amount to rescue\n', '     */\n', '    function rescueTokens (Pasadena tokenContract, uint256 value) public {\n', '        require(msg.sender == rescueAccount);\n', '        tokenContract.approve(rescueAccount, value);\n', '    }\n', '\n', '    /**\n', '     * Utility function that allows to change the rescueAccount address.\n', '     * @param newRescueAccount - account which will be authorized to rescue tokens.\n', '     */\n', '    function changeRescueAccount (address newRescueAccount) public {\n', '        require(msg.sender == rescueAccount);\n', '        rescueAccount = newRescueAccount;\n', '    }\n', '\n', '}']
