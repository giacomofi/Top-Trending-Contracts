['pragma solidity ^0.4.21;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', '\n', 'contract MintingContractInterface {\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount) public;\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public;\n', '    function doTeamMinting(address _destination) public;\n', '    function setTokenContractAddress(address _newAddress) public;\n', '    function setCrowdsaleContractAddress(address _newAddress) public;\n', '    function killContract() public;\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress = 0x0;\n', '    address public kycAddress = 0x0;\n', '    address public mintingContractAddress = 0x0;\n', '\n', '    uint public startPhaseLength = 720;\n', '    uint public startPhaseMaximumcontribution = 10 * 10**18;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint nextContributorIndex;\n', '    mapping(uint => address) contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokensIssued = 0;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    uint nextContributorToClaim;\n', '    mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '    function() noReentrancy payable public {\n', '        require(msg.value >= 100000000000000000);\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\n', '\n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            return _eth * 8640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            return _eth * 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            return _eth * 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            return _eth * 8160;\n', '        } else {\n', '            return _eth * 8000;\n', '        }\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\n', '        uint tempTokenAmount;\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 1008640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8160;\n', '        } else {\n', '            tempTokenAmount = (_token * 1000) / 8000;\n', '        }\n', '        return tempTokenAmount / 1000;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '\n', '        if (block.number < crowdsaleStartBlock + startPhaseLength) {\n', '            if((_amount + contributorList[_contributor].contributionAmount) > startPhaseMaximumcontribution) {\n', '                if (contributorList[_contributor].contributionAmount < startPhaseMaximumcontribution) {\n', '                    contributionAmount = startPhaseMaximumcontribution - contributorList[_contributor].contributionAmount;\n', '                    returnAmount = _amount - contributionAmount;\n', '                } else {\n', '                    revert();\n', '                }\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '        } else {\n', '            contributionAmount = _amount;\n', '        }\n', '        \n', '        tokensToGive = calculateEthToToken(contributionAmount, block.number);\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive);\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function claimEthIfFailed() public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        require(contributorList[msg.sender].contributionAmount > 0);\n', '        require(!hasClaimedEthWhenFail[msg.sender]);\n', '\n', '        uint ethContributed = contributorList[msg.sender].contributionAmount;\n', '        hasClaimedEthWhenFail[msg.sender] = true;\n', '        if (!msg.sender.send(ethContributed)) {\n', '            emit ErrorSendingETH(msg.sender, ethContributed);\n', '        }\n', '    }\n', '\n', '    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\n', '            if (currentParticipantAddress == 0x0) {\n', '                return;\n', '            }\n', '            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\n', '                contribution = contributorList[currentParticipantAddress].contributionAmount;\n', '                hasClaimedEthWhenFail[currentParticipantAddress] = true;\n', '                if (!currentParticipantAddress.send(contribution)) {\n', '                    emit ErrorSendingETH(currentParticipantAddress, contribution);\n', '                }\n', '            }\n', '            nextContributorToClaim += 1;\n', '        }\n', '    }\n', '\n', '    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(block.number > crowdsaleEndedBlock);\n', '        require(contributorIndexes[nextContributorToClaim] == 0x0);\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function setMultisigAddress(address _newAddress) onlyOwner public {\n', '        multisigAddress = _newAddress;\n', '    }\n', '\n', '    function setMintingContractAddress(address _newAddress) onlyOwner public {\n', '        mintingContractAddress = _newAddress;\n', '    }\n', '\n', '    function setKycAddress(address _newAddress) onlyOwner public {\n', '        kycAddress = _newAddress;\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '}\n', '\n', 'contract EligmaCrowdsaleContract is Crowdsale {\n', '  \n', '    function EligmaCrowdsaleContract() public {\n', '\n', '        crowdsaleStartBlock = 5456462;\n', '        crowdsaleEndedBlock = 5584081; \n', '\n', '        minCap = 0 * 10**18;\n', '        maxCap = 161054117 * 10**18;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', '\n', 'contract MintingContractInterface {\n', '\n', '    address public crowdsaleContractAddress;\n', '    address public tokenContractAddress;\n', '    uint public tokenTotalSupply;\n', '\n', '    event MintMade(address _to, uint _ethAmount, uint _tokensMinted, string _message);\n', '\n', '    function doPresaleMinting(address _destination, uint _tokensAmount) public;\n', '    function doCrowdsaleMinting(address _destination, uint _tokensAmount) public;\n', '    function doTeamMinting(address _destination) public;\n', '    function setTokenContractAddress(address _newAddress) public;\n', '    function setCrowdsaleContractAddress(address _newAddress) public;\n', '    function killContract() public;\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '    \n', '    enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '    struct ContributorData {\n', '        uint contributionAmount;\n', '        uint tokensIssued;\n', '    }\n', '\n', '    state public crowdsaleState = state.pendingStart;\n', '    \n', '    address public multisigAddress = 0x0;\n', '    address public kycAddress = 0x0;\n', '    address public mintingContractAddress = 0x0;\n', '\n', '    uint public startPhaseLength = 720;\n', '    uint public startPhaseMaximumcontribution = 10 * 10**18;\n', '\n', '    uint public crowdsaleStartBlock;\n', '    uint public crowdsaleEndedBlock;\n', '\n', '    mapping(address => ContributorData) public contributorList;\n', '    uint nextContributorIndex;\n', '    mapping(uint => address) contributorIndexes;\n', '\n', '    uint public minCap;\n', '    uint public maxCap;\n', '    uint public ethRaised;\n', '    uint public tokensIssued = 0;\n', '\n', '    event CrowdsaleStarted(uint blockNumber);\n', '    event CrowdsaleEnded(uint blockNumber);\n', '    event ErrorSendingETH(address to, uint amount);\n', '    event MinCapReached(uint blockNumber);\n', '    event MaxCapReached(uint blockNumber);\n', '\n', '    uint nextContributorToClaim;\n', '    mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '    function() noReentrancy payable public {\n', '        require(msg.value >= 100000000000000000);\n', '        require(crowdsaleState != state.crowdsaleEnded);\n', '        require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\n', '\n', '        bool stateChanged = checkCrowdsaleState();\n', '\n', '        if (crowdsaleState == state.crowdsale) {\n', '            processTransaction(msg.sender, msg.value);\n', '        } else {\n', '            refundTransaction(stateChanged);\n', '        }\n', '    }\n', '\n', '    function checkCrowdsaleState() internal returns (bool) {\n', '        if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {\n', '            crowdsaleState = state.crowdsaleEnded;\n', '            emit CrowdsaleEnded(block.number);\n', '            return true;\n', '        }\n', '\n', '        if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {\n', '            if (crowdsaleState != state.crowdsale) {\n', '                crowdsaleState = state.crowdsale;\n', '                emit CrowdsaleStarted(block.number);\n', '                return true;\n', '            }\n', '        } else {\n', '            if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {\n', '                crowdsaleState = state.crowdsaleEnded;\n', '                emit CrowdsaleEnded(block.number);\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function refundTransaction(bool _stateChanged) internal {\n', '        if (_stateChanged) {\n', '            msg.sender.transfer(msg.value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            return _eth * 8640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            return _eth * 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            return _eth * 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            return _eth * 8160;\n', '        } else {\n', '            return _eth * 8000;\n', '        }\n', '    }\n', '\n', '    function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\n', '        uint tempTokenAmount;\n', '        if (tokensIssued <= 20000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 1008640;\n', '        } else if(tokensIssued <= 40000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8480;\n', '        } else if(tokensIssued <= 60000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8320;\n', '        } else if(tokensIssued <= 80000000 * 10**18) {\n', '            tempTokenAmount = (_token * 1000) / 8160;\n', '        } else {\n', '            tempTokenAmount = (_token * 1000) / 8000;\n', '        }\n', '        return tempTokenAmount / 1000;\n', '    }\n', '\n', '    function processTransaction(address _contributor, uint _amount) internal {\n', '        uint contributionAmount = 0;\n', '        uint returnAmount = 0;\n', '        uint tokensToGive = 0;\n', '\n', '        if (block.number < crowdsaleStartBlock + startPhaseLength) {\n', '            if((_amount + contributorList[_contributor].contributionAmount) > startPhaseMaximumcontribution) {\n', '                if (contributorList[_contributor].contributionAmount < startPhaseMaximumcontribution) {\n', '                    contributionAmount = startPhaseMaximumcontribution - contributorList[_contributor].contributionAmount;\n', '                    returnAmount = _amount - contributionAmount;\n', '                } else {\n', '                    revert();\n', '                }\n', '            } else {\n', '                contributionAmount = _amount;\n', '            }\n', '        } else {\n', '            contributionAmount = _amount;\n', '        }\n', '        \n', '        tokensToGive = calculateEthToToken(contributionAmount, block.number);\n', '\n', '        if (tokensToGive > (maxCap - tokensIssued)) {\n', '            contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number);\n', '            returnAmount = _amount - contributionAmount;\n', '            tokensToGive = maxCap - tokensIssued;\n', '            emit MaxCapReached(block.number);\n', '        }\n', '\n', '        if (contributorList[_contributor].contributionAmount == 0) {\n', '            contributorIndexes[nextContributorIndex] = _contributor;\n', '            nextContributorIndex += 1;\n', '        }\n', '\n', '        contributorList[_contributor].contributionAmount += contributionAmount;\n', '        ethRaised += contributionAmount;\n', '\n', '        if (tokensToGive > 0) {\n', '            MintingContractInterface(mintingContractAddress).doCrowdsaleMinting(_contributor, tokensToGive);\n', '            contributorList[_contributor].tokensIssued += tokensToGive;\n', '            tokensIssued += tokensToGive;\n', '        }\n', '        if (returnAmount != 0) {\n', '            _contributor.transfer(returnAmount);\n', '        } \n', '    }\n', '\n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\n', '    function withdrawEth() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(tokensIssued >= minCap);\n', '\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function claimEthIfFailed() public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        require(contributorList[msg.sender].contributionAmount > 0);\n', '        require(!hasClaimedEthWhenFail[msg.sender]);\n', '\n', '        uint ethContributed = contributorList[msg.sender].contributionAmount;\n', '        hasClaimedEthWhenFail[msg.sender] = true;\n', '        if (!msg.sender.send(ethContributed)) {\n', '            emit ErrorSendingETH(msg.sender, ethContributed);\n', '        }\n', '    }\n', '\n', '    function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '        require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);\n', '        address currentParticipantAddress;\n', '        uint contribution;\n', '        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '            currentParticipantAddress = contributorIndexes[nextContributorToClaim];\n', '            if (currentParticipantAddress == 0x0) {\n', '                return;\n', '            }\n', '            if (!hasClaimedEthWhenFail[currentParticipantAddress]) {\n', '                contribution = contributorList[currentParticipantAddress].contributionAmount;\n', '                hasClaimedEthWhenFail[currentParticipantAddress] = true;\n', '                if (!currentParticipantAddress.send(contribution)) {\n', '                    emit ErrorSendingETH(currentParticipantAddress, contribution);\n', '                }\n', '            }\n', '            nextContributorToClaim += 1;\n', '        }\n', '    }\n', '\n', '    function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '        require(address(this).balance != 0);\n', '        require(block.number > crowdsaleEndedBlock);\n', '        require(contributorIndexes[nextContributorToClaim] == 0x0);\n', '        multisigAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    function setMultisigAddress(address _newAddress) onlyOwner public {\n', '        multisigAddress = _newAddress;\n', '    }\n', '\n', '    function setMintingContractAddress(address _newAddress) onlyOwner public {\n', '        mintingContractAddress = _newAddress;\n', '    }\n', '\n', '    function setKycAddress(address _newAddress) onlyOwner public {\n', '        kycAddress = _newAddress;\n', '    }\n', '\n', '    function investorCount() constant public returns(uint) {\n', '        return nextContributorIndex;\n', '    }\n', '\n', '    function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '        crowdsaleStartBlock = _block;\n', '    }\n', '}\n', '\n', 'contract EligmaCrowdsaleContract is Crowdsale {\n', '  \n', '    function EligmaCrowdsaleContract() public {\n', '\n', '        crowdsaleStartBlock = 5456462;\n', '        crowdsaleEndedBlock = 5584081; \n', '\n', '        minCap = 0 * 10**18;\n', '        maxCap = 161054117 * 10**18;\n', '    }\n', '}']
