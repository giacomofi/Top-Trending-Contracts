['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', ' * ownership control to OpenZeppelin&#39;s Ownable class. In this model, the original owner \n', ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  address public pendingOwner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    pendingOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '\n', '}\n', '\n', '/**\n', '* @title CarbonDollarStorage\n', '* @notice Contains necessary storage contracts for CarbonDollar (FeeSheet and StablecoinWhitelist).\n', '*/\n', 'contract CarbonDollarStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /** \n', '        Mappings\n', '    */\n', '    /* fees for withdrawing to stablecoin, in tenths of a percent) */\n', '    mapping (address => uint256) public fees;\n', '    /** @dev Units for fees are always in a tenth of a percent */\n', '    uint256 public defaultFee;\n', '    /* is the token address referring to a stablecoin/whitelisted token? */\n', '    mapping (address => bool) public whitelist;\n', '\n', '\n', '    /** \n', '        Events\n', '    */\n', '    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);\n', '    event FeeChanged(address indexed stablecoin, uint256 oldFee, uint256 newFee);\n', '    event FeeRemoved(address indexed stablecoin, uint256 oldFee);\n', '    event StablecoinAdded(address indexed stablecoin);\n', '    event StablecoinRemoved(address indexed stablecoin);\n', '\n', '    /** @notice Sets the default fee for burning CarbonDollar into a whitelisted stablecoin.\n', '        @param _fee The default fee.\n', '    */\n', '    function setDefaultFee(uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = defaultFee;\n', '        defaultFee = _fee;\n', '        if (oldFee != defaultFee)\n', '            emit DefaultFeeChanged(oldFee, _fee);\n', '    }\n', '    \n', '    /** @notice Set a fee for burning CarbonDollar into a stablecoin.\n', '        @param _stablecoin Address of a whitelisted stablecoin.\n', '        @param _fee the fee.\n', '    */\n', '    function setFee(address _stablecoin, uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = _fee;\n', '        if (oldFee != _fee)\n', '            emit FeeChanged(_stablecoin, oldFee, _fee);\n', '    }\n', '\n', '    /** @notice Remove the fee for burning CarbonDollar into a particular kind of stablecoin.\n', '        @param _stablecoin Address of stablecoin.\n', '    */\n', '    function removeFee(address _stablecoin) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = 0;\n', '        if (oldFee != 0)\n', '            emit FeeRemoved(_stablecoin, oldFee);\n', '    }\n', '\n', '    /** @notice Add a token to the whitelist.\n', '        @param _stablecoin Address of the new stablecoin.\n', '    */\n', '    function addStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = true;\n', '        emit StablecoinAdded(_stablecoin);\n', '    }\n', '\n', '    /** @notice Removes a token from the whitelist.\n', '        @param _stablecoin Address of the ex-stablecoin.\n', '    */\n', '    function removeStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = false;\n', '        emit StablecoinRemoved(_stablecoin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _stablecoin The stablecoin whose fee will be used.\n', '     */\n', '    function computeStablecoinFee(uint256 _amount, address _stablecoin) public view returns (uint256) {\n', '        uint256 fee = fees[_stablecoin];\n', '        return computeFee(_amount, fee);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _fee The fee that will be charged, in tenths of a percent.\n', '     */\n', '    function computeFee(uint256 _amount, uint256 _fee) public pure returns (uint256) {\n', '        return _amount.mul(_fee).div(1000);\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '* @title PermissionedTokenStorage\n', '* @notice a PermissionedTokenStorage is constructed by setting Regulator, BalanceSheet, and AllowanceSheet locations.\n', '* Once the storages are set, they cannot be changed.\n', '*/\n', 'contract PermissionedTokenStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '        Storage\n', '    */\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '    mapping (address => uint256) public balances;\n', '    uint256 public totalSupply;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = _value;\n', '    }\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', '* @title Lockable\n', '* @dev Base contract which allows children to lock certain methods from being called by clients.\n', '* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n', '* some inherited standard, for example. \n', '*/\n', '\n', 'contract Lockable is Ownable {\n', '\n', '\t// Events\n', '\tevent Unlocked();\n', '\tevent Locked();\n', '\n', '\t// Fields\n', '\tbool public isMethodEnabled = false;\n', '\n', '\t// Modifiers\n', '\t/**\n', '\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n', '\t*/\n', '\tmodifier whenUnlocked() {\n', '\t\trequire(isMethodEnabled);\n', '\t\t_;\n', '\t}\n', '\n', '\t// Methods\n', '\t/**\n', '\t* @dev called by the owner to enable method\n', '\t*/\n', '\tfunction unlock() onlyOwner public {\n', '\t\tisMethodEnabled = true;\n', '\t\temit Unlocked();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to disable method, back to normal state\n', '\t*/\n', '\tfunction lock() onlyOwner public {\n', '\t\tisMethodEnabled = false;\n', '\t\temit Locked();\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism. Identical to OpenZeppelin version\n', ' * except that it uses local Ownable contract\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', '*\n', '* @dev Stores permissions and validators and provides setter and getter methods. \n', '* Permissions determine which methods users have access to call. Validators\n', '* are able to mutate permissions at the Regulator level.\n', '*\n', '*/\n', 'contract RegulatorStorage is Ownable {\n', '    \n', '    /** \n', '        Structs \n', '    */\n', '\n', '    /* Contains metadata about a permission to execute a particular method signature. */\n', '    struct Permission {\n', '        string name; // A one-word description for the permission. e.g. "canMint"\n', '        string description; // A longer description for the permission. e.g. "Allows user to mint tokens."\n', '        string contract_name; // e.g. "PermissionedToken"\n', '        bool active; // Permissions can be turned on or off by regulator\n', '    }\n', '\n', '    /** \n', '        Constants: stores method signatures. These are potential permissions that a user can have, \n', '        and each permission gives the user the ability to call the associated PermissionedToken method signature\n', '    */\n', '    bytes4 public constant MINT_SIG = bytes4(keccak256("mint(address,uint256)"));\n', '    bytes4 public constant MINT_CUSD_SIG = bytes4(keccak256("mintCUSD(address,uint256)"));\n', '    bytes4 public constant CONVERT_WT_SIG = bytes4(keccak256("convertWT(uint256)"));\n', '    bytes4 public constant BURN_SIG = bytes4(keccak256("burn(uint256)"));\n', '    bytes4 public constant CONVERT_CARBON_DOLLAR_SIG = bytes4(keccak256("convertCarbonDollar(address,uint256)"));\n', '    bytes4 public constant BURN_CARBON_DOLLAR_SIG = bytes4(keccak256("burnCarbonDollar(address,uint256)"));\n', '    bytes4 public constant DESTROY_BLACKLISTED_TOKENS_SIG = bytes4(keccak256("destroyBlacklistedTokens(address,uint256)"));\n', '    bytes4 public constant APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG = bytes4(keccak256("approveBlacklistedAddressSpender(address)"));\n', '    bytes4 public constant BLACKLISTED_SIG = bytes4(keccak256("blacklisted()"));\n', '\n', '    /** \n', '        Mappings \n', '    */\n', '\n', '    /* each method signature maps to a Permission */\n', '    mapping (bytes4 => Permission) public permissions;\n', '    /* list of validators, either active or inactive */\n', '    mapping (address => bool) public validators;\n', '    /* each user can be given access to a given method signature */\n', '    mapping (address => mapping (bytes4 => bool)) public userPermissions;\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event PermissionAdded(bytes4 methodsignature);\n', '    event PermissionRemoved(bytes4 methodsignature);\n', '    event ValidatorAdded(address indexed validator);\n', '    event ValidatorRemoved(address indexed validator);\n', '\n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets a permission within the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    * @param _permissionName A "slug" name for this permission (e.g. "canMint").\n', '    * @param _permissionDescription A lengthier description for this permission (e.g. "Allows user to mint tokens").\n', '    * @param _contractName Name of the contract that the method belongs to.\n', '    */\n', '    function addPermission(\n', '        bytes4 _methodsignature, \n', '        string _permissionName, \n', '        string _permissionDescription, \n', '        string _contractName) public onlyValidator { \n', '        Permission memory p = Permission(_permissionName, _permissionDescription, _contractName, true);\n', '        permissions[_methodsignature] = p;\n', '        emit PermissionAdded(_methodsignature);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removePermission(bytes4 _methodsignature) public onlyValidator {\n', '        permissions[_methodsignature].active = false;\n', '        emit PermissionRemoved(_methodsignature);\n', '    }\n', '    \n', '    /**\n', '    * @notice Sets a permission in the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function setUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being set must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission from the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removeUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being removed must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = false;\n', '    }\n', '\n', '    /**\n', '    * @notice add a Validator\n', '    * @param _validator Address of validator to add\n', '    */\n', '    function addValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = true;\n', '        emit ValidatorAdded(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice remove a Validator\n', '    * @param _validator Address of validator to remove\n', '    */\n', '    function removeValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = false;\n', '        emit ValidatorRemoved(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice does validator exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isValidator(address _validator) public view returns (bool) {\n', '        return validators[_validator];\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isPermission(bytes4 _methodsignature) public view returns (bool) {\n', '        return permissions[_methodsignature].active;\n', '    }\n', '\n', '    /**\n', '    * @notice get Permission structure\n', '    * @param _methodsignature request to retrieve the Permission struct for this methodsignature\n', '    * @return Permission\n', '    **/\n', '    function getPermission(bytes4 _methodsignature) public view returns \n', '        (string name, \n', '         string description, \n', '         string contract_name,\n', '         bool active) {\n', '        return (permissions[_methodsignature].name,\n', '                permissions[_methodsignature].description,\n', '                permissions[_methodsignature].contract_name,\n', '                permissions[_methodsignature].active);\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function hasUserPermission(address _who, bytes4 _methodsignature) public view returns (bool) {\n', '        return userPermissions[_who][_methodsignature];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Regulator\n', ' * @dev Regulator can be configured to meet relevant securities regulations, KYC policies\n', ' * AML requirements, tax laws, and more. The Regulator ensures that the PermissionedToken\n', ' * makes compliant transfers possible. Contains the userPermissions necessary\n', ' * for regulatory compliance.\n', ' *\n', ' */\n', 'contract Regulator is RegulatorStorage {\n', '    \n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event LogWhitelistedUser(address indexed who);\n', '    event LogBlacklistedUser(address indexed who);\n', '    event LogNonlistedUser(address indexed who);\n', '    event LogSetMinter(address indexed who);\n', '    event LogRemovedMinter(address indexed who);\n', '    event LogSetBlacklistDestroyer(address indexed who);\n', '    event LogRemovedBlacklistDestroyer(address indexed who);\n', '    event LogSetBlacklistSpender(address indexed who);\n', '    event LogRemovedBlacklistSpender(address indexed who);\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setMinter(address _who) public onlyValidator {\n', '        _setMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeMinter(address _who) public onlyValidator {\n', '        _removeMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        setUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogSetBlacklistSpender(_who);\n', '    }\n', '    \n', '    /**\n', '    * @notice Removes the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        removeUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogRemovedBlacklistSpender(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        setUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogSetBlacklistDestroyer(_who);\n', '    }\n', '    \n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogRemovedBlacklistDestroyer(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "whitelisted" user.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setWhitelistedUser(address _who) public onlyValidator {\n', '        _setWhitelistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "blacklisted" user. A blacklisted user has their accounts\n', '    * frozen; they cannot transfer, burn, or withdraw any tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistedUser(address _who) public onlyValidator {\n', '        _setBlacklistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "nonlisted" user. Nonlisted users can trade tokens,\n', '    * but cannot burn them (and therefore cannot convert them into fiat.)\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setNonlistedUser(address _who) public onlyValidator {\n', '        _setNonlistedUser(_who);\n', '    }\n', '\n', '    /** Returns whether or not a user is whitelisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is whitelisted, `false` otherwise.\n', '     */\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is blacklisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is blacklisted, `false` otherwise.\n', '     */\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is nonlisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is nonlisted, `false` otherwise.\n', '     */\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist spender.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist spender, `false` otherwise.\n', '     */\n', '    function isBlacklistSpender(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist destroyer.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist destroyer, `false` otherwise.\n', '     */\n', '    function isBlacklistDestroyer(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a minter.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a minter, `false` otherwise.\n', '     */\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, MINT_SIG);\n', '    }\n', '\n', '    /** Internal Functions **/\n', '\n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        setUserPermission(_who, MINT_SIG);\n', '        emit LogSetMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        removeUserPermission(_who, MINT_SIG);\n', '        emit LogRemovedMinter(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        setUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title PermissionedToken\n', '* @notice A permissioned token that enables transfers, withdrawals, and deposits to occur \n', '* if and only if it is approved by an on-chain Regulator service. PermissionedToken is an\n', '* ERC-20 smart contract representing ownership of securities and overrides the\n', '* transfer, burn, and mint methods to check with the Regulator.\n', '*/\n', 'contract PermissionedToken is ERC20, Pausable, Lockable {\n', '    using SafeMath for uint256;\n', '\n', '    /** Events */\n', '    event DestroyedBlacklistedTokens(address indexed account, uint256 amount);\n', '    event ApprovedBlacklistedAddressSpender(address indexed owner, address indexed spender, uint256 value);\n', '    event Mint(address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event ChangedRegulator(address indexed oldRegulator, address indexed newRegulator );\n', '\n', '    PermissionedTokenStorage public tokenStorage;\n', '    Regulator public regulator;\n', '\n', '    /**\n', '    * @dev create a new PermissionedToken with a brand new data storage\n', '    **/\n', '    constructor (address _regulator) public {\n', '        regulator = Regulator(_regulator);\n', '        tokenStorage = new PermissionedTokenStorage();\n', '    }\n', '\n', '    /** Modifiers **/\n', '\n', '    /** @notice Modifier that allows function access to be restricted based on\n', '    * whether the regulator allows the message sender to execute that function.\n', '    **/\n', '    modifier requiresPermission() {\n', '        require (regulator.hasUserPermission(msg.sender, msg.sig), "User does not have permission to execute function");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether or not a transferFrom operation can\n', '    * succeed with the given _from and _to address. See transferFrom()&#39;s documentation for\n', '    * more details.\n', '    **/\n', '    modifier transferFromConditionsRequired(address _from, address _to) {\n', '        require(!regulator.isBlacklistedUser(_to), "Recipient cannot be blacklisted");\n', '        \n', '        // If the origin user is blacklisted, the transaction can only succeed if \n', '        // the message sender is a user that has been approved to transfer \n', '        // blacklisted tokens out of this address.\n', '        bool is_origin_blacklisted = regulator.isBlacklistedUser(_from);\n', '\n', '        // Is the message sender a person with the ability to transfer tokens out of a blacklisted account?\n', '        bool sender_can_spend_from_blacklisted_address = regulator.isBlacklistSpender(msg.sender);\n', '        require(!is_origin_blacklisted || sender_can_spend_from_blacklisted_address, "Origin cannot be blacklisted if spender is not an approved blacklist spender");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is whitelisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userWhitelisted(address _user) {\n', '        require(regulator.isWhitelistedUser(_user), "User must be whitelisted");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is blacklisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userBlacklisted(address _user) {\n', '        require(regulator.isBlacklistedUser(_user), "User must be blacklisted");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is not blacklisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userNotBlacklisted(address _user) {\n', '        require(!regulator.isBlacklistedUser(_user), "User must not be blacklisted");\n', '        _;\n', '    }\n', '\n', '    /** Functions **/\n', '\n', '    /**\n', '    * @notice Allows user to mint if they have the appropriate permissions. User generally\n', '    * has to be some sort of centralized authority.\n', '    * @dev Should be access-restricted with the &#39;requiresPermission&#39; modifier when implementing.\n', '    * @param _to The address of the receiver\n', '    * @param _amount The number of tokens to mint\n', '    */\n', '    function mint(address _to, uint256 _amount) public requiresPermission whenNotPaused {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Allows user to mint if they have the appropriate permissions. User generally\n', '    * is just a "whitelisted" user (i.e. a user registered with the fiat gateway.)\n', '    * @dev Should be access-restricted with the &#39;requiresPermission&#39; modifier when implementing.\n', '    * @param _amount The number of tokens to burn\n', '    * @return `true` if successful and `false` if unsuccessful\n', '    */\n', '    function burn(uint256 _amount) public requiresPermission whenNotPaused {\n', '        _burn(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Implements ERC-20 standard approve function. Locked or disabled by default to protect against\n', '    * double spend attacks. To modify allowances, clients should call safer increase/decreaseApproval methods.\n', '    * Upon construction, all calls to approve() will revert unless this contract owner explicitly unlocks approve()\n', '    */\n', '    function approve(address _spender, uint256 _value) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused whenUnlocked returns (bool) {\n', '        tokenStorage.setAllowance(msg.sender, _spender, _value);\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * @notice increaseApproval should be used instead of approve when the user&#39;s allowance\n', '     * is greater than 0. Using increaseApproval protects against potential double-spend attacks\n', '     * by moving the check of whether the user has spent their allowance to the time that the transaction \n', '     * is mined, removing the user&#39;s ability to double-spend\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint256 _addedValue) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        _increaseApproval(_spender, _addedValue, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * @notice decreaseApproval should be used instead of approve when the user&#39;s allowance\n', '     * is greater than 0. Using decreaseApproval protects against potential double-spend attacks\n', '     * by moving the check of whether the user has spent their allowance to the time that the transaction \n', '     * is mined, removing the user&#39;s ability to double-spend\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        _decreaseApproval(_spender, _subtractedValue, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Destroy the tokens owned by a blacklisted account. This function can generally\n', '    * only be called by a central authority.\n', '    * @dev Should be access-restricted with the &#39;requiresPermission&#39; modifier when implementing.\n', '    * @param _who Account to destroy tokens from. Must be a blacklisted account.\n', '    */\n', '    function destroyBlacklistedTokens(address _who, uint256 _amount) public userBlacklisted(_who) whenNotPaused requiresPermission {\n', '        tokenStorage.subBalance(_who, _amount);\n', '        tokenStorage.subTotalSupply(_amount);\n', '        emit DestroyedBlacklistedTokens(_who, _amount);\n', '    }\n', '    /**\n', '    * @notice Allows a central authority to approve themselves as a spender on a blacklisted account.\n', '    * By default, the allowance is set to the balance of the blacklisted account, so that the\n', '    * authority has full control over the account balance.\n', '    * @dev Should be access-restricted with the &#39;requiresPermission&#39; modifier when implementing.\n', '    * @param _blacklistedAccount The blacklisted account.\n', '    */\n', '    function approveBlacklistedAddressSpender(address _blacklistedAccount) \n', '    public userBlacklisted(_blacklistedAccount) whenNotPaused requiresPermission {\n', '        tokenStorage.setAllowance(_blacklistedAccount, msg.sender, balanceOf(_blacklistedAccount));\n', '        emit ApprovedBlacklistedAddressSpender(_blacklistedAccount, msg.sender, balanceOf(_blacklistedAccount));\n', '    }\n', '\n', '    /**\n', '    * @notice Initiates a "send" operation towards another user. See `transferFrom` for details.\n', '    * @param _to The address of the receiver. This user must not be blacklisted, or else the tranfer\n', '    * will fail.\n', '    * @param _amount The number of tokens to transfer\n', '    *\n', '    * @return `true` if successful \n', '    */\n', '    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        require(_to != address(0),"to address cannot be 0x0");\n', '        require(_amount <= balanceOf(msg.sender),"not enough balance to transfer");\n', '\n', '        tokenStorage.subBalance(msg.sender, _amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Initiates a transfer operation between address `_from` and `_to`. Requires that the\n', '    * message sender is an approved spender on the _from account.\n', '    * @dev When implemented, it should use the transferFromConditionsRequired() modifier.\n', '    * @param _to The address of the recipient. This address must not be blacklisted.\n', '    * @param _from The address of the origin of funds. This address _could_ be blacklisted, because\n', '    * a regulator may want to transfer tokens out of a blacklisted account, for example.\n', '    * In order to do so, the regulator would have to add themselves as an approved spender\n', '    * on the account via `addBlacklistAddressSpender()`, and would then be able to transfer tokens out of it.\n', '    * @param _amount The number of tokens to transfer\n', '    * @return `true` if successful \n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _amount) \n', '    public whenNotPaused transferFromConditionsRequired(_from, _to) returns (bool) {\n', '        require(_amount <= allowance(_from, msg.sender),"not enough allowance to transfer");\n', '        require(_to != address(0),"to address cannot be 0x0");\n', '        require(_amount <= balanceOf(_from),"not enough balance to transfer");\n', '        \n', '        tokenStorage.subAllowance(_from, msg.sender, _amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        tokenStorage.subBalance(_from, _amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *\n', '    * @dev Only the token owner can change its regulator\n', '    * @param _newRegulator the new Regulator for this token\n', '    *\n', '    */\n', '    function setRegulator(address _newRegulator) public onlyOwner {\n', '        require(_newRegulator != address(regulator), "Must be a new regulator");\n', '        require(AddressUtils.isContract(_newRegulator), "Cannot set a regulator storage to a non-contract address");\n', '        address old = address(regulator);\n', '        regulator = Regulator(_newRegulator);\n', '        emit ChangedRegulator(old, _newRegulator);\n', '    }\n', '\n', '    /**\n', '    * @notice If a user is blacklisted, they will have the permission to \n', '    * execute this dummy function. This function effectively acts as a marker \n', '    * to indicate that a user is blacklisted. We include this function to be consistent with our\n', '    * invariant that every possible userPermission (listed in Regulator) enables access to a single \n', '    * PermissionedToken function. Thus, the &#39;BLACKLISTED&#39; permission gives access to this function\n', '    * @return `true` if successful\n', '    */\n', '    function blacklisted() public view requiresPermission returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * ERC20 standard functions\n', '    */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return tokenStorage.allowances(owner, spender);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenStorage.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _addr) public view returns (uint256) {\n', '        return tokenStorage.balances(_addr);\n', '    }\n', '\n', '\n', '    /** Internal functions **/\n', '    \n', '    function _decreaseApproval(address _spender, uint256 _subtractedValue, address _tokenHolder) internal {\n', '        uint256 oldValue = allowance(_tokenHolder, _spender);\n', '        if (_subtractedValue > oldValue) {\n', '            tokenStorage.setAllowance(_tokenHolder, _spender, 0);\n', '        } else {\n', '            tokenStorage.subAllowance(_tokenHolder, _spender, _subtractedValue);\n', '        }\n', '        emit Approval(_tokenHolder, _spender, allowance(_tokenHolder, _spender));\n', '    }\n', '\n', '    function _increaseApproval(address _spender, uint256 _addedValue, address _tokenHolder) internal {\n', '        tokenStorage.addAllowance(_tokenHolder, _spender, _addedValue);\n', '        emit Approval(_tokenHolder, _spender, allowance(_tokenHolder, _spender));\n', '    }\n', '\n', '    function _burn(address _tokensOf, uint256 _amount) internal {\n', '        require(_amount <= balanceOf(_tokensOf),"not enough balance to burn");\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '        tokenStorage.subBalance(_tokensOf, _amount);\n', '        tokenStorage.subTotalSupply(_amount);\n', '        emit Burn(_tokensOf, _amount);\n', '        emit Transfer(_tokensOf, address(0), _amount);\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal userWhitelisted(_to) {\n', '        tokenStorage.addTotalSupply(_amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title CarbonDollarRegulator\n', ' * @dev CarbonDollarRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A CarbonDollar\n', ' * provides a user the additional ability to convert from CUSD into a whtielisted stablecoin\n', ' *\n', ' */\n', 'contract CarbonDollarRegulator is Regulator {\n', '\n', '    // Getters\n', '    function isWhitelistedUser(address _who) public view returns(bool) {\n', '        return (hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Internal functions **/\n', '    \n', '    // Setters: CarbonDollarRegulator overrides the definitions of whitelisted, nonlisted, and blacklisted setUserPermission\n', '\n', '    // CarbonDollar whitelisted users burn CUSD into a WhitelistedToken. Unlike PermissionedToken \n', '    // whitelisted users, CarbonDollar whitelisted users cannot burn ordinary CUSD without converting into WT\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        setUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollar\n', '* @notice The main functionality for the CarbonUSD metatoken. (CarbonUSD is just a proxy\n', '* that implements this contract&#39;s functionality.) This is a permissioned token, so users have to be \n', '* whitelisted before they can do any mint/burn/convert operation. Every CarbonDollar token is backed by one\n', '* whitelisted stablecoin credited to the balance of this contract address.\n', '*/\n', 'contract CarbonDollar is PermissionedToken {\n', '    \n', '    // Events\n', '\n', '    event ConvertedToWT(address indexed user, uint256 amount);\n', '    event BurnedCUSD(address indexed user, uint256 feedAmount, uint256 chargedFee);\n', '    \n', '    /**\n', '        Modifiers\n', '    */\n', '    modifier requiresWhitelistedToken() {\n', '        require(isWhitelisted(msg.sender), "Sender must be a whitelisted token contract");\n', '        _;\n', '    }\n', '\n', '    CarbonDollarStorage public tokenStorage_CD;\n', '\n', '    /** CONSTRUCTOR\n', '    * @dev Passes along arguments to base class.\n', '    */\n', '    constructor(address _regulator) public PermissionedToken(_regulator) {\n', '\n', '        // base class override\n', '        regulator = CarbonDollarRegulator(_regulator);\n', '\n', '        tokenStorage_CD = new CarbonDollarStorage();\n', '    }\n', '\n', '    /**\n', '     * @notice Add new stablecoin to whitelist.\n', '     * @param _stablecoin Address of stablecoin contract.\n', '     */\n', '    function listToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.addStablecoin(_stablecoin); \n', '    }\n', '\n', '    /**\n', '     * @notice Remove existing stablecoin from whitelist.\n', '     * @param _stablecoin Address of stablecoin contract.\n', '     */\n', '    function unlistToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.removeStablecoin(_stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Change fees associated with going from CarbonUSD to a particular stablecoin.\n', '     * @param stablecoin Address of the stablecoin contract.\n', '     * @param _newFee The new fee rate to set, in tenths of a percent. \n', '     */\n', '    function setFee(address stablecoin, uint256 _newFee) public onlyOwner whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        tokenStorage_CD.setFee(stablecoin, _newFee);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove fees associated with going from CarbonUSD to a particular stablecoin.\n', '     * The default fee still may apply.\n', '     * @param stablecoin Address of the stablecoin contract.\n', '     */\n', '    function removeFee(address stablecoin) public onlyOwner whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '       tokenStorage_CD.removeFee(stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the default fee associated with going from CarbonUSD to a WhitelistedToken.\n', '     * This fee amount is used if the fee for a WhitelistedToken is not specified.\n', '     * @param _newFee The new fee rate to set, in tenths of a percent.\n', '     */\n', '    function setDefaultFee(uint256 _newFee) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.setDefaultFee(_newFee);\n', '    }\n', '\n', '    /**\n', '     * @notice Mints CUSD on behalf of a user. Note the use of the "requiresWhitelistedToken"\n', '     * modifier; this means that minting authority does not belong to any personal account; \n', '     * only whitelisted token contracts can call this function. The intended functionality is that the only\n', '     * way to mint CUSD is for the user to actually burn a whitelisted token to convert into CUSD\n', '     * @param _to User to send CUSD to\n', '     * @param _amount Amount of CarbonUSD to mint.\n', '     */\n', '    function mint(address _to, uint256 _amount) public requiresWhitelistedToken whenNotPaused {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice user can convert CarbonUSD umbrella token into a whitelisted stablecoin. \n', '     * @param stablecoin represents the type of coin the users wishes to receive for burning carbonUSD\n', '     * @param _amount Amount of CarbonUSD to convert.\n', '     * we credit the user&#39;s account at the sender address with the _amount minus the percentage fee we want to charge.\n', '     */\n', '    function convertCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused  {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '        require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn&#39;t have enough tokens for burning");\n', ' \n', '        // Send back WT0 to calling user, but with a fee reduction.\n', '        // Transfer this fee into the whitelisted token&#39;s CarbonDollar account (this contract&#39;s address)\n', '        uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '        uint256 feedAmount = _amount.sub(chargedFee);\n', '        _burn(msg.sender, _amount);\n', '        require(whitelisted.transfer(msg.sender, feedAmount));\n', '        whitelisted.burn(chargedFee);\n', '        _mint(address(this), chargedFee);\n', '        emit ConvertedToWT(msg.sender, _amount);\n', '    }\n', '\n', '     /**\n', '     * @notice burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address\n', '     * @param stablecoin Represents the stablecoin whose fee will be charged.\n', '     * @param _amount Amount of CarbonUSD to burn.\n', '     */\n', '    function burnCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '        require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn&#39;t have enough tokens for burning");\n', ' \n', '        // Burn user&#39;s CUSD, but with a fee reduction.\n', '        uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '        uint256 feedAmount = _amount.sub(chargedFee);\n', '        _burn(msg.sender, _amount);\n', '        whitelisted.burn(_amount);\n', '        _mint(address(this), chargedFee);\n', '        emit BurnedCUSD(msg.sender, feedAmount, chargedFee); // Whitelisted trust account should send user feedAmount USD\n', '    }\n', '\n', '    /** \n', '    * @notice release collected CUSD fees to owner \n', '    * @param _amount Amount of CUSD to release\n', '    * @return `true` if successful \n', '    */\n', '    function releaseCarbonDollar(uint256 _amount) public onlyOwner returns (bool) {\n', '        require(_amount <= balanceOf(address(this)),"not enough balance to transfer");\n', '\n', '        tokenStorage.subBalance(address(this), _amount);\n', '        tokenStorage.addBalance(msg.sender, _amount);\n', '        emit Transfer(address(this), msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /** Computes fee percentage associated with burning into a particular stablecoin.\n', '     * @param stablecoin The stablecoin whose fee will be charged. Precondition: is a whitelisted\n', '     * stablecoin.\n', '     * @return The fee that will be charged. If the stablecoin&#39;s fee is not set, the default\n', '     * fee is returned.\n', '     */\n', '    function computeFeeRate(address stablecoin) public view returns (uint256 feeRate) {\n', '        if (getFee(stablecoin) > 0) \n', '            feeRate = getFee(stablecoin);\n', '        else\n', '            feeRate = getDefaultFee();\n', '    }\n', '\n', '    /**\n', '    * @notice Check if whitelisted token is whitelisted\n', '    * @return bool true if whitelisted, false if not\n', '    **/\n', '    function isWhitelisted(address _stablecoin) public view returns (bool) {\n', '        return tokenStorage_CD.whitelist(_stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '     * @param stablecoin The stablecoin whose fee is being checked.\n', '     * @return The fee associated with the stablecoin.\n', '     */\n', '    function getFee(address stablecoin) public view returns (uint256) {\n', '        return tokenStorage_CD.fees(stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '     * @return The default fee for stablecoin trades.\n', '     */\n', '    function getDefaultFee() public view returns (uint256) {\n', '        return tokenStorage_CD.defaultFee();\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal {\n', '        super._mint(_to, _amount);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title WhitelistedTokenRegulator\n', ' * @dev WhitelistedTokenRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A WhitelistedToken\n', ' * provides a user the additional ability to convert from a whtielisted stablecoin into the\n', ' * meta-token CUSD, or mint CUSD directly through a specific WT.\n', ' *\n', ' */\n', 'contract WhitelistedTokenRegulator is Regulator {\n', '\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return (super.isMinter(_who) && hasUserPermission(_who, MINT_CUSD_SIG));\n', '    }\n', '\n', '    // Getters\n', '\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, CONVERT_WT_SIG) && super.isWhitelistedUser(_who));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, CONVERT_WT_SIG) && super.isBlacklistedUser(_who));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, CONVERT_WT_SIG) && super.isNonlistedUser(_who));\n', '    }   \n', '\n', '    /** Internal functions **/\n', '\n', '    // A WT minter should have option to either mint directly into CUSD via mintCUSD(), or\n', '    // mint the WT via an ordinary mint() \n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_CUSD_SIG), "Minting to CUSD not supported by token");\n', '        setUserPermission(_who, MINT_CUSD_SIG);\n', '        super._setMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_CUSD_SIG), "Minting to CUSD not supported by token");\n', '        removeUserPermission(_who, MINT_CUSD_SIG);\n', '        super._removeMinter(_who);\n', '    }\n', '\n', '    // Setters\n', '\n', '    // A WT whitelisted user should gain ability to convert their WT into CUSD. They can also burn their WT, as a\n', '    // PermissionedToken whitelisted user can do\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        setUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        removeUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        removeUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setNonlistedUser(_who);\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title WhitelistedToken\n', '* @notice A WhitelistedToken can be converted into CUSD and vice versa. Converting a WT into a CUSD\n', '* is the only way for a user to obtain CUSD. This is a permissioned token, so users have to be \n', '* whitelisted before they can do any mint/burn/convert operation.\n', '*/\n', 'contract WhitelistedToken is PermissionedToken {\n', '\n', '\n', '    address public cusdAddress;\n', '\n', '    /**\n', '        Events\n', '     */\n', '    event CUSDAddressChanged(address indexed oldCUSD, address indexed newCUSD);\n', '    event MintedToCUSD(address indexed user, uint256 amount);\n', '    event ConvertedToCUSD(address indexed user, uint256 amount);\n', '\n', '    /**\n', '    * @notice Constructor sets the regulator contract and the address of the\n', '    * CarbonUSD meta-token contract. The latter is necessary in order to make transactions\n', '    * with the CarbonDollar smart contract.\n', '    */\n', '    constructor(address _regulator, address _cusd) public PermissionedToken(_regulator) {\n', '\n', '        // base class fields\n', '        regulator = WhitelistedTokenRegulator(_regulator);\n', '\n', '        cusdAddress = _cusd;\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice Mints CarbonUSD for the user. Stores the WT0 that backs the CarbonUSD\n', '    * into the CarbonUSD contract&#39;s escrow account.\n', '    * @param _to The address of the receiver\n', '    * @param _amount The number of CarbonTokens to mint to user\n', '    */\n', '    function mintCUSD(address _to, uint256 _amount) public requiresPermission whenNotPaused userWhitelisted(_to) {\n', '        return _mintCUSD(_to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Converts WT0 to CarbonUSD for the user. Stores the WT0 that backs the CarbonUSD\n', '    * into the CarbonUSD contract&#39;s escrow account.\n', '    * @param _amount The number of Whitelisted tokens to convert\n', '    */\n', '    function convertWT(uint256 _amount) public requiresPermission whenNotPaused {\n', '        require(balanceOf(msg.sender) >= _amount, "Conversion amount should be less than balance");\n', '        _burn(msg.sender, _amount);\n', '        _mintCUSD(msg.sender, _amount);\n', '        emit ConvertedToCUSD(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the cusd address.\n', '     * @param _cusd the cusd address.\n', '     */\n', '    function setCUSDAddress(address _cusd) public onlyOwner {\n', '        require(_cusd != address(cusdAddress), "Must be a new cusd address");\n', '        require(AddressUtils.isContract(_cusd), "Must be an actual contract");\n', '        address oldCUSD = address(cusdAddress);\n', '        cusdAddress = _cusd;\n', '        emit CUSDAddressChanged(oldCUSD, _cusd);\n', '    }\n', '\n', '    function _mintCUSD(address _to, uint256 _amount) internal {\n', '        require(_to != cusdAddress, "Cannot mint to CarbonUSD contract"); // This is to prevent Carbon Labs from printing money out of thin air!\n', '        CarbonDollar(cusdAddress).mint(_to, _amount);\n', '        _mint(cusdAddress, _amount);\n', '        emit MintedToCUSD(_to, _amount);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollar\n', '* @notice The main functionality for the CarbonUSD metatoken. (CarbonUSD is just a proxy\n', '* that implements this contract&#39;s functionality.) This is a permissioned token, so users have to be \n', '* whitelisted before they can do any mint/burn/convert operation. Every CarbonDollar token is backed by one\n', '* whitelisted stablecoin credited to the balance of this contract address.\n', '*/\n', '// contract CarbonDollar is PermissionedToken {\n', '    \n', '//     // Events\n', '\n', '//     event ConvertedToWT(address indexed user, uint256 amount);\n', '//     event BurnedCUSD(address indexed user, uint256 feedAmount, uint256 chargedFee);\n', '    \n', '//     /**\n', '//         Modifiers\n', '//     */\n', '//     modifier requiresWhitelistedToken() {\n', '//         require(isWhitelisted(msg.sender), "Sender must be a whitelisted token contract");\n', '//         _;\n', '//     }\n', '\n', '//     CarbonDollarStorage public tokenStorage_CD;\n', '\n', '//     /** CONSTRUCTOR\n', '//     * @dev Passes along arguments to base class.\n', '//     */\n', '//     constructor(address _regulator) public PermissionedToken(_regulator) {\n', '\n', '//         // base class override\n', '//         regulator = CarbonDollarRegulator(_regulator);\n', '\n', '//         tokenStorage_CD = new CarbonDollarStorage();\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Add new stablecoin to whitelist.\n', '//      * @param _stablecoin Address of stablecoin contract.\n', '//      */\n', '//     function listToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.addStablecoin(_stablecoin); \n', '//     }\n', '\n', '//     /**\n', '//      * @notice Remove existing stablecoin from whitelist.\n', '//      * @param _stablecoin Address of stablecoin contract.\n', '//      */\n', '//     function unlistToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.removeStablecoin(_stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Change fees associated with going from CarbonUSD to a particular stablecoin.\n', '//      * @param stablecoin Address of the stablecoin contract.\n', '//      * @param _newFee The new fee rate to set, in tenths of a percent. \n', '//      */\n', '//     function setFee(address stablecoin, uint256 _newFee) public onlyOwner whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         tokenStorage_CD.setFee(stablecoin, _newFee);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Remove fees associated with going from CarbonUSD to a particular stablecoin.\n', '//      * The default fee still may apply.\n', '//      * @param stablecoin Address of the stablecoin contract.\n', '//      */\n', '//     function removeFee(address stablecoin) public onlyOwner whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//        tokenStorage_CD.removeFee(stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Change the default fee associated with going from CarbonUSD to a WhitelistedToken.\n', '//      * This fee amount is used if the fee for a WhitelistedToken is not specified.\n', '//      * @param _newFee The new fee rate to set, in tenths of a percent.\n', '//      */\n', '//     function setDefaultFee(uint256 _newFee) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.setDefaultFee(_newFee);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Mints CUSD on behalf of a user. Note the use of the "requiresWhitelistedToken"\n', '//      * modifier; this means that minting authority does not belong to any personal account; \n', '//      * only whitelisted token contracts can call this function. The intended functionality is that the only\n', '//      * way to mint CUSD is for the user to actually burn a whitelisted token to convert into CUSD\n', '//      * @param _to User to send CUSD to\n', '//      * @param _amount Amount of CarbonUSD to mint.\n', '//      */\n', '//     function mint(address _to, uint256 _amount) public requiresWhitelistedToken whenNotPaused {\n', '//         _mint(_to, _amount);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice user can convert CarbonUSD umbrella token into a whitelisted stablecoin. \n', '//      * @param stablecoin represents the type of coin the users wishes to receive for burning carbonUSD\n', '//      * @param _amount Amount of CarbonUSD to convert.\n', '//      * we credit the user&#39;s account at the sender address with the _amount minus the percentage fee we want to charge.\n', '//      */\n', '//     function convertCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused  {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '//         require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn&#39;t have enough tokens for burning");\n', ' \n', '//         // Send back WT0 to calling user, but with a fee reduction.\n', '//         // Transfer this fee into the whitelisted token&#39;s CarbonDollar account (this contract&#39;s address)\n', '//         uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '//         uint256 feedAmount = _amount.sub(chargedFee);\n', '//         _burn(msg.sender, _amount);\n', '//         require(whitelisted.transfer(msg.sender, feedAmount));\n', '//         whitelisted.burn(chargedFee);\n', '//         _mint(address(this), chargedFee);\n', '//         emit ConvertedToWT(msg.sender, _amount);\n', '//     }\n', '\n', '//      /**\n', '//      * @notice burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address\n', '//      * @param stablecoin Represents the stablecoin whose fee will be charged.\n', '//      * @param _amount Amount of CarbonUSD to burn.\n', '//      */\n', '//     function burnCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '//         require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn&#39;t have enough tokens for burning");\n', ' \n', '//         // Burn user&#39;s CUSD, but with a fee reduction.\n', '//         uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '//         uint256 feedAmount = _amount.sub(chargedFee);\n', '//         _burn(msg.sender, _amount);\n', '//         whitelisted.burn(_amount);\n', '//         _mint(address(this), chargedFee);\n', '//         emit BurnedCUSD(msg.sender, feedAmount, chargedFee); // Whitelisted trust account should send user feedAmount USD\n', '//     }\n', '\n', '//     /** \n', '//     * @notice release collected CUSD fees to owner \n', '//     * @param _amount Amount of CUSD to release\n', '//     * @return `true` if successful \n', '//     */\n', '//     function releaseCarbonDollar(uint256 _amount) public onlyOwner returns (bool) {\n', '//         require(_amount <= balanceOf(address(this)),"not enough balance to transfer");\n', '\n', '//         tokenStorage.subBalance(address(this), _amount);\n', '//         tokenStorage.addBalance(msg.sender, _amount);\n', '//         emit Transfer(address(this), msg.sender, _amount);\n', '//         return true;\n', '//     }\n', '\n', '//     /** Computes fee percentage associated with burning into a particular stablecoin.\n', '//      * @param stablecoin The stablecoin whose fee will be charged. Precondition: is a whitelisted\n', '//      * stablecoin.\n', '//      * @return The fee that will be charged. If the stablecoin&#39;s fee is not set, the default\n', '//      * fee is returned.\n', '//      */\n', '//     function computeFeeRate(address stablecoin) public view returns (uint256 feeRate) {\n', '//         if (getFee(stablecoin) > 0) \n', '//             feeRate = getFee(stablecoin);\n', '//         else\n', '//             feeRate = getDefaultFee();\n', '//     }\n', '\n', '//     /**\n', '//     * @notice Check if whitelisted token is whitelisted\n', '//     * @return bool true if whitelisted, false if not\n', '//     **/\n', '//     function isWhitelisted(address _stablecoin) public view returns (bool) {\n', '//         return tokenStorage_CD.whitelist(_stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Get the fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '//      * @param stablecoin The stablecoin whose fee is being checked.\n', '//      * @return The fee associated with the stablecoin.\n', '//      */\n', '//     function getFee(address stablecoin) public view returns (uint256) {\n', '//         return tokenStorage_CD.fees(stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '//      * @return The default fee for stablecoin trades.\n', '//      */\n', '//     function getDefaultFee() public view returns (uint256) {\n', '//         return tokenStorage_CD.defaultFee();\n', '//     }\n', '\n', '//     function _mint(address _to, uint256 _amount) internal {\n', '//         super._mint(_to, _amount);\n', '//     }\n', '\n', '// }']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', " * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n", ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  address public pendingOwner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    pendingOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '\n', '}\n', '\n', '/**\n', '* @title CarbonDollarStorage\n', '* @notice Contains necessary storage contracts for CarbonDollar (FeeSheet and StablecoinWhitelist).\n', '*/\n', 'contract CarbonDollarStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /** \n', '        Mappings\n', '    */\n', '    /* fees for withdrawing to stablecoin, in tenths of a percent) */\n', '    mapping (address => uint256) public fees;\n', '    /** @dev Units for fees are always in a tenth of a percent */\n', '    uint256 public defaultFee;\n', '    /* is the token address referring to a stablecoin/whitelisted token? */\n', '    mapping (address => bool) public whitelist;\n', '\n', '\n', '    /** \n', '        Events\n', '    */\n', '    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);\n', '    event FeeChanged(address indexed stablecoin, uint256 oldFee, uint256 newFee);\n', '    event FeeRemoved(address indexed stablecoin, uint256 oldFee);\n', '    event StablecoinAdded(address indexed stablecoin);\n', '    event StablecoinRemoved(address indexed stablecoin);\n', '\n', '    /** @notice Sets the default fee for burning CarbonDollar into a whitelisted stablecoin.\n', '        @param _fee The default fee.\n', '    */\n', '    function setDefaultFee(uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = defaultFee;\n', '        defaultFee = _fee;\n', '        if (oldFee != defaultFee)\n', '            emit DefaultFeeChanged(oldFee, _fee);\n', '    }\n', '    \n', '    /** @notice Set a fee for burning CarbonDollar into a stablecoin.\n', '        @param _stablecoin Address of a whitelisted stablecoin.\n', '        @param _fee the fee.\n', '    */\n', '    function setFee(address _stablecoin, uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = _fee;\n', '        if (oldFee != _fee)\n', '            emit FeeChanged(_stablecoin, oldFee, _fee);\n', '    }\n', '\n', '    /** @notice Remove the fee for burning CarbonDollar into a particular kind of stablecoin.\n', '        @param _stablecoin Address of stablecoin.\n', '    */\n', '    function removeFee(address _stablecoin) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = 0;\n', '        if (oldFee != 0)\n', '            emit FeeRemoved(_stablecoin, oldFee);\n', '    }\n', '\n', '    /** @notice Add a token to the whitelist.\n', '        @param _stablecoin Address of the new stablecoin.\n', '    */\n', '    function addStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = true;\n', '        emit StablecoinAdded(_stablecoin);\n', '    }\n', '\n', '    /** @notice Removes a token from the whitelist.\n', '        @param _stablecoin Address of the ex-stablecoin.\n', '    */\n', '    function removeStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = false;\n', '        emit StablecoinRemoved(_stablecoin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _stablecoin The stablecoin whose fee will be used.\n', '     */\n', '    function computeStablecoinFee(uint256 _amount, address _stablecoin) public view returns (uint256) {\n', '        uint256 fee = fees[_stablecoin];\n', '        return computeFee(_amount, fee);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _fee The fee that will be charged, in tenths of a percent.\n', '     */\n', '    function computeFee(uint256 _amount, uint256 _fee) public pure returns (uint256) {\n', '        return _amount.mul(_fee).div(1000);\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '* @title PermissionedTokenStorage\n', '* @notice a PermissionedTokenStorage is constructed by setting Regulator, BalanceSheet, and AllowanceSheet locations.\n', '* Once the storages are set, they cannot be changed.\n', '*/\n', 'contract PermissionedTokenStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '        Storage\n', '    */\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '    mapping (address => uint256) public balances;\n', '    uint256 public totalSupply;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = _value;\n', '    }\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', '* @title Lockable\n', '* @dev Base contract which allows children to lock certain methods from being called by clients.\n', '* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n', '* some inherited standard, for example. \n', '*/\n', '\n', 'contract Lockable is Ownable {\n', '\n', '\t// Events\n', '\tevent Unlocked();\n', '\tevent Locked();\n', '\n', '\t// Fields\n', '\tbool public isMethodEnabled = false;\n', '\n', '\t// Modifiers\n', '\t/**\n', '\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n', '\t*/\n', '\tmodifier whenUnlocked() {\n', '\t\trequire(isMethodEnabled);\n', '\t\t_;\n', '\t}\n', '\n', '\t// Methods\n', '\t/**\n', '\t* @dev called by the owner to enable method\n', '\t*/\n', '\tfunction unlock() onlyOwner public {\n', '\t\tisMethodEnabled = true;\n', '\t\temit Unlocked();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to disable method, back to normal state\n', '\t*/\n', '\tfunction lock() onlyOwner public {\n', '\t\tisMethodEnabled = false;\n', '\t\temit Locked();\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism. Identical to OpenZeppelin version\n', ' * except that it uses local Ownable contract\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', '*\n', '* @dev Stores permissions and validators and provides setter and getter methods. \n', '* Permissions determine which methods users have access to call. Validators\n', '* are able to mutate permissions at the Regulator level.\n', '*\n', '*/\n', 'contract RegulatorStorage is Ownable {\n', '    \n', '    /** \n', '        Structs \n', '    */\n', '\n', '    /* Contains metadata about a permission to execute a particular method signature. */\n', '    struct Permission {\n', '        string name; // A one-word description for the permission. e.g. "canMint"\n', '        string description; // A longer description for the permission. e.g. "Allows user to mint tokens."\n', '        string contract_name; // e.g. "PermissionedToken"\n', '        bool active; // Permissions can be turned on or off by regulator\n', '    }\n', '\n', '    /** \n', '        Constants: stores method signatures. These are potential permissions that a user can have, \n', '        and each permission gives the user the ability to call the associated PermissionedToken method signature\n', '    */\n', '    bytes4 public constant MINT_SIG = bytes4(keccak256("mint(address,uint256)"));\n', '    bytes4 public constant MINT_CUSD_SIG = bytes4(keccak256("mintCUSD(address,uint256)"));\n', '    bytes4 public constant CONVERT_WT_SIG = bytes4(keccak256("convertWT(uint256)"));\n', '    bytes4 public constant BURN_SIG = bytes4(keccak256("burn(uint256)"));\n', '    bytes4 public constant CONVERT_CARBON_DOLLAR_SIG = bytes4(keccak256("convertCarbonDollar(address,uint256)"));\n', '    bytes4 public constant BURN_CARBON_DOLLAR_SIG = bytes4(keccak256("burnCarbonDollar(address,uint256)"));\n', '    bytes4 public constant DESTROY_BLACKLISTED_TOKENS_SIG = bytes4(keccak256("destroyBlacklistedTokens(address,uint256)"));\n', '    bytes4 public constant APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG = bytes4(keccak256("approveBlacklistedAddressSpender(address)"));\n', '    bytes4 public constant BLACKLISTED_SIG = bytes4(keccak256("blacklisted()"));\n', '\n', '    /** \n', '        Mappings \n', '    */\n', '\n', '    /* each method signature maps to a Permission */\n', '    mapping (bytes4 => Permission) public permissions;\n', '    /* list of validators, either active or inactive */\n', '    mapping (address => bool) public validators;\n', '    /* each user can be given access to a given method signature */\n', '    mapping (address => mapping (bytes4 => bool)) public userPermissions;\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event PermissionAdded(bytes4 methodsignature);\n', '    event PermissionRemoved(bytes4 methodsignature);\n', '    event ValidatorAdded(address indexed validator);\n', '    event ValidatorRemoved(address indexed validator);\n', '\n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets a permission within the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    * @param _permissionName A "slug" name for this permission (e.g. "canMint").\n', '    * @param _permissionDescription A lengthier description for this permission (e.g. "Allows user to mint tokens").\n', '    * @param _contractName Name of the contract that the method belongs to.\n', '    */\n', '    function addPermission(\n', '        bytes4 _methodsignature, \n', '        string _permissionName, \n', '        string _permissionDescription, \n', '        string _contractName) public onlyValidator { \n', '        Permission memory p = Permission(_permissionName, _permissionDescription, _contractName, true);\n', '        permissions[_methodsignature] = p;\n', '        emit PermissionAdded(_methodsignature);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removePermission(bytes4 _methodsignature) public onlyValidator {\n', '        permissions[_methodsignature].active = false;\n', '        emit PermissionRemoved(_methodsignature);\n', '    }\n', '    \n', '    /**\n', '    * @notice Sets a permission in the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function setUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being set must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission from the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removeUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being removed must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = false;\n', '    }\n', '\n', '    /**\n', '    * @notice add a Validator\n', '    * @param _validator Address of validator to add\n', '    */\n', '    function addValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = true;\n', '        emit ValidatorAdded(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice remove a Validator\n', '    * @param _validator Address of validator to remove\n', '    */\n', '    function removeValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = false;\n', '        emit ValidatorRemoved(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice does validator exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isValidator(address _validator) public view returns (bool) {\n', '        return validators[_validator];\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isPermission(bytes4 _methodsignature) public view returns (bool) {\n', '        return permissions[_methodsignature].active;\n', '    }\n', '\n', '    /**\n', '    * @notice get Permission structure\n', '    * @param _methodsignature request to retrieve the Permission struct for this methodsignature\n', '    * @return Permission\n', '    **/\n', '    function getPermission(bytes4 _methodsignature) public view returns \n', '        (string name, \n', '         string description, \n', '         string contract_name,\n', '         bool active) {\n', '        return (permissions[_methodsignature].name,\n', '                permissions[_methodsignature].description,\n', '                permissions[_methodsignature].contract_name,\n', '                permissions[_methodsignature].active);\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function hasUserPermission(address _who, bytes4 _methodsignature) public view returns (bool) {\n', '        return userPermissions[_who][_methodsignature];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Regulator\n', ' * @dev Regulator can be configured to meet relevant securities regulations, KYC policies\n', ' * AML requirements, tax laws, and more. The Regulator ensures that the PermissionedToken\n', ' * makes compliant transfers possible. Contains the userPermissions necessary\n', ' * for regulatory compliance.\n', ' *\n', ' */\n', 'contract Regulator is RegulatorStorage {\n', '    \n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event LogWhitelistedUser(address indexed who);\n', '    event LogBlacklistedUser(address indexed who);\n', '    event LogNonlistedUser(address indexed who);\n', '    event LogSetMinter(address indexed who);\n', '    event LogRemovedMinter(address indexed who);\n', '    event LogSetBlacklistDestroyer(address indexed who);\n', '    event LogRemovedBlacklistDestroyer(address indexed who);\n', '    event LogSetBlacklistSpender(address indexed who);\n', '    event LogRemovedBlacklistSpender(address indexed who);\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setMinter(address _who) public onlyValidator {\n', '        _setMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeMinter(address _who) public onlyValidator {\n', '        _removeMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        setUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogSetBlacklistSpender(_who);\n', '    }\n', '    \n', '    /**\n', '    * @notice Removes the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        removeUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogRemovedBlacklistSpender(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        setUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogSetBlacklistDestroyer(_who);\n', '    }\n', '    \n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogRemovedBlacklistDestroyer(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "whitelisted" user.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setWhitelistedUser(address _who) public onlyValidator {\n', '        _setWhitelistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "blacklisted" user. A blacklisted user has their accounts\n', '    * frozen; they cannot transfer, burn, or withdraw any tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistedUser(address _who) public onlyValidator {\n', '        _setBlacklistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "nonlisted" user. Nonlisted users can trade tokens,\n', '    * but cannot burn them (and therefore cannot convert them into fiat.)\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setNonlistedUser(address _who) public onlyValidator {\n', '        _setNonlistedUser(_who);\n', '    }\n', '\n', '    /** Returns whether or not a user is whitelisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is whitelisted, `false` otherwise.\n', '     */\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is blacklisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is blacklisted, `false` otherwise.\n', '     */\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is nonlisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is nonlisted, `false` otherwise.\n', '     */\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist spender.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist spender, `false` otherwise.\n', '     */\n', '    function isBlacklistSpender(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist destroyer.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist destroyer, `false` otherwise.\n', '     */\n', '    function isBlacklistDestroyer(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a minter.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a minter, `false` otherwise.\n', '     */\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, MINT_SIG);\n', '    }\n', '\n', '    /** Internal Functions **/\n', '\n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        setUserPermission(_who, MINT_SIG);\n', '        emit LogSetMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        removeUserPermission(_who, MINT_SIG);\n', '        emit LogRemovedMinter(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        setUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title PermissionedToken\n', '* @notice A permissioned token that enables transfers, withdrawals, and deposits to occur \n', '* if and only if it is approved by an on-chain Regulator service. PermissionedToken is an\n', '* ERC-20 smart contract representing ownership of securities and overrides the\n', '* transfer, burn, and mint methods to check with the Regulator.\n', '*/\n', 'contract PermissionedToken is ERC20, Pausable, Lockable {\n', '    using SafeMath for uint256;\n', '\n', '    /** Events */\n', '    event DestroyedBlacklistedTokens(address indexed account, uint256 amount);\n', '    event ApprovedBlacklistedAddressSpender(address indexed owner, address indexed spender, uint256 value);\n', '    event Mint(address indexed to, uint256 value);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event ChangedRegulator(address indexed oldRegulator, address indexed newRegulator );\n', '\n', '    PermissionedTokenStorage public tokenStorage;\n', '    Regulator public regulator;\n', '\n', '    /**\n', '    * @dev create a new PermissionedToken with a brand new data storage\n', '    **/\n', '    constructor (address _regulator) public {\n', '        regulator = Regulator(_regulator);\n', '        tokenStorage = new PermissionedTokenStorage();\n', '    }\n', '\n', '    /** Modifiers **/\n', '\n', '    /** @notice Modifier that allows function access to be restricted based on\n', '    * whether the regulator allows the message sender to execute that function.\n', '    **/\n', '    modifier requiresPermission() {\n', '        require (regulator.hasUserPermission(msg.sender, msg.sig), "User does not have permission to execute function");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether or not a transferFrom operation can\n', "    * succeed with the given _from and _to address. See transferFrom()'s documentation for\n", '    * more details.\n', '    **/\n', '    modifier transferFromConditionsRequired(address _from, address _to) {\n', '        require(!regulator.isBlacklistedUser(_to), "Recipient cannot be blacklisted");\n', '        \n', '        // If the origin user is blacklisted, the transaction can only succeed if \n', '        // the message sender is a user that has been approved to transfer \n', '        // blacklisted tokens out of this address.\n', '        bool is_origin_blacklisted = regulator.isBlacklistedUser(_from);\n', '\n', '        // Is the message sender a person with the ability to transfer tokens out of a blacklisted account?\n', '        bool sender_can_spend_from_blacklisted_address = regulator.isBlacklistSpender(msg.sender);\n', '        require(!is_origin_blacklisted || sender_can_spend_from_blacklisted_address, "Origin cannot be blacklisted if spender is not an approved blacklist spender");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is whitelisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userWhitelisted(address _user) {\n', '        require(regulator.isWhitelistedUser(_user), "User must be whitelisted");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is blacklisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userBlacklisted(address _user) {\n', '        require(regulator.isBlacklistedUser(_user), "User must be blacklisted");\n', '        _;\n', '    }\n', '\n', '    /** @notice Modifier that checks whether a user is not blacklisted.\n', '     * @param _user The address of the user to check.\n', '    **/\n', '    modifier userNotBlacklisted(address _user) {\n', '        require(!regulator.isBlacklistedUser(_user), "User must not be blacklisted");\n', '        _;\n', '    }\n', '\n', '    /** Functions **/\n', '\n', '    /**\n', '    * @notice Allows user to mint if they have the appropriate permissions. User generally\n', '    * has to be some sort of centralized authority.\n', "    * @dev Should be access-restricted with the 'requiresPermission' modifier when implementing.\n", '    * @param _to The address of the receiver\n', '    * @param _amount The number of tokens to mint\n', '    */\n', '    function mint(address _to, uint256 _amount) public requiresPermission whenNotPaused {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Allows user to mint if they have the appropriate permissions. User generally\n', '    * is just a "whitelisted" user (i.e. a user registered with the fiat gateway.)\n', "    * @dev Should be access-restricted with the 'requiresPermission' modifier when implementing.\n", '    * @param _amount The number of tokens to burn\n', '    * @return `true` if successful and `false` if unsuccessful\n', '    */\n', '    function burn(uint256 _amount) public requiresPermission whenNotPaused {\n', '        _burn(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Implements ERC-20 standard approve function. Locked or disabled by default to protect against\n', '    * double spend attacks. To modify allowances, clients should call safer increase/decreaseApproval methods.\n', '    * Upon construction, all calls to approve() will revert unless this contract owner explicitly unlocks approve()\n', '    */\n', '    function approve(address _spender, uint256 _value) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused whenUnlocked returns (bool) {\n', '        tokenStorage.setAllowance(msg.sender, _spender, _value);\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', "     * @notice increaseApproval should be used instead of approve when the user's allowance\n", '     * is greater than 0. Using increaseApproval protects against potential double-spend attacks\n', '     * by moving the check of whether the user has spent their allowance to the time that the transaction \n', "     * is mined, removing the user's ability to double-spend\n", '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(address _spender, uint256 _addedValue) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        _increaseApproval(_spender, _addedValue, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', "     * @notice decreaseApproval should be used instead of approve when the user's allowance\n", '     * is greater than 0. Using decreaseApproval protects against potential double-spend attacks\n', '     * by moving the check of whether the user has spent their allowance to the time that the transaction \n', "     * is mined, removing the user's ability to double-spend\n", '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    public userNotBlacklisted(_spender) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        _decreaseApproval(_spender, _subtractedValue, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Destroy the tokens owned by a blacklisted account. This function can generally\n', '    * only be called by a central authority.\n', "    * @dev Should be access-restricted with the 'requiresPermission' modifier when implementing.\n", '    * @param _who Account to destroy tokens from. Must be a blacklisted account.\n', '    */\n', '    function destroyBlacklistedTokens(address _who, uint256 _amount) public userBlacklisted(_who) whenNotPaused requiresPermission {\n', '        tokenStorage.subBalance(_who, _amount);\n', '        tokenStorage.subTotalSupply(_amount);\n', '        emit DestroyedBlacklistedTokens(_who, _amount);\n', '    }\n', '    /**\n', '    * @notice Allows a central authority to approve themselves as a spender on a blacklisted account.\n', '    * By default, the allowance is set to the balance of the blacklisted account, so that the\n', '    * authority has full control over the account balance.\n', "    * @dev Should be access-restricted with the 'requiresPermission' modifier when implementing.\n", '    * @param _blacklistedAccount The blacklisted account.\n', '    */\n', '    function approveBlacklistedAddressSpender(address _blacklistedAccount) \n', '    public userBlacklisted(_blacklistedAccount) whenNotPaused requiresPermission {\n', '        tokenStorage.setAllowance(_blacklistedAccount, msg.sender, balanceOf(_blacklistedAccount));\n', '        emit ApprovedBlacklistedAddressSpender(_blacklistedAccount, msg.sender, balanceOf(_blacklistedAccount));\n', '    }\n', '\n', '    /**\n', '    * @notice Initiates a "send" operation towards another user. See `transferFrom` for details.\n', '    * @param _to The address of the receiver. This user must not be blacklisted, or else the tranfer\n', '    * will fail.\n', '    * @param _amount The number of tokens to transfer\n', '    *\n', '    * @return `true` if successful \n', '    */\n', '    function transfer(address _to, uint256 _amount) public userNotBlacklisted(_to) userNotBlacklisted(msg.sender) whenNotPaused returns (bool) {\n', '        require(_to != address(0),"to address cannot be 0x0");\n', '        require(_amount <= balanceOf(msg.sender),"not enough balance to transfer");\n', '\n', '        tokenStorage.subBalance(msg.sender, _amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Initiates a transfer operation between address `_from` and `_to`. Requires that the\n', '    * message sender is an approved spender on the _from account.\n', '    * @dev When implemented, it should use the transferFromConditionsRequired() modifier.\n', '    * @param _to The address of the recipient. This address must not be blacklisted.\n', '    * @param _from The address of the origin of funds. This address _could_ be blacklisted, because\n', '    * a regulator may want to transfer tokens out of a blacklisted account, for example.\n', '    * In order to do so, the regulator would have to add themselves as an approved spender\n', '    * on the account via `addBlacklistAddressSpender()`, and would then be able to transfer tokens out of it.\n', '    * @param _amount The number of tokens to transfer\n', '    * @return `true` if successful \n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _amount) \n', '    public whenNotPaused transferFromConditionsRequired(_from, _to) returns (bool) {\n', '        require(_amount <= allowance(_from, msg.sender),"not enough allowance to transfer");\n', '        require(_to != address(0),"to address cannot be 0x0");\n', '        require(_amount <= balanceOf(_from),"not enough balance to transfer");\n', '        \n', '        tokenStorage.subAllowance(_from, msg.sender, _amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        tokenStorage.subBalance(_from, _amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    *\n', '    * @dev Only the token owner can change its regulator\n', '    * @param _newRegulator the new Regulator for this token\n', '    *\n', '    */\n', '    function setRegulator(address _newRegulator) public onlyOwner {\n', '        require(_newRegulator != address(regulator), "Must be a new regulator");\n', '        require(AddressUtils.isContract(_newRegulator), "Cannot set a regulator storage to a non-contract address");\n', '        address old = address(regulator);\n', '        regulator = Regulator(_newRegulator);\n', '        emit ChangedRegulator(old, _newRegulator);\n', '    }\n', '\n', '    /**\n', '    * @notice If a user is blacklisted, they will have the permission to \n', '    * execute this dummy function. This function effectively acts as a marker \n', '    * to indicate that a user is blacklisted. We include this function to be consistent with our\n', '    * invariant that every possible userPermission (listed in Regulator) enables access to a single \n', "    * PermissionedToken function. Thus, the 'BLACKLISTED' permission gives access to this function\n", '    * @return `true` if successful\n', '    */\n', '    function blacklisted() public view requiresPermission returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * ERC20 standard functions\n', '    */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return tokenStorage.allowances(owner, spender);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenStorage.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _addr) public view returns (uint256) {\n', '        return tokenStorage.balances(_addr);\n', '    }\n', '\n', '\n', '    /** Internal functions **/\n', '    \n', '    function _decreaseApproval(address _spender, uint256 _subtractedValue, address _tokenHolder) internal {\n', '        uint256 oldValue = allowance(_tokenHolder, _spender);\n', '        if (_subtractedValue > oldValue) {\n', '            tokenStorage.setAllowance(_tokenHolder, _spender, 0);\n', '        } else {\n', '            tokenStorage.subAllowance(_tokenHolder, _spender, _subtractedValue);\n', '        }\n', '        emit Approval(_tokenHolder, _spender, allowance(_tokenHolder, _spender));\n', '    }\n', '\n', '    function _increaseApproval(address _spender, uint256 _addedValue, address _tokenHolder) internal {\n', '        tokenStorage.addAllowance(_tokenHolder, _spender, _addedValue);\n', '        emit Approval(_tokenHolder, _spender, allowance(_tokenHolder, _spender));\n', '    }\n', '\n', '    function _burn(address _tokensOf, uint256 _amount) internal {\n', '        require(_amount <= balanceOf(_tokensOf),"not enough balance to burn");\n', '        // no need to require value <= totalSupply, since that would imply the\n', "        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '        tokenStorage.subBalance(_tokensOf, _amount);\n', '        tokenStorage.subTotalSupply(_amount);\n', '        emit Burn(_tokensOf, _amount);\n', '        emit Transfer(_tokensOf, address(0), _amount);\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal userWhitelisted(_to) {\n', '        tokenStorage.addTotalSupply(_amount);\n', '        tokenStorage.addBalance(_to, _amount);\n', '        emit Mint(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title CarbonDollarRegulator\n', ' * @dev CarbonDollarRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A CarbonDollar\n', ' * provides a user the additional ability to convert from CUSD into a whtielisted stablecoin\n', ' *\n', ' */\n', 'contract CarbonDollarRegulator is Regulator {\n', '\n', '    // Getters\n', '    function isWhitelistedUser(address _who) public view returns(bool) {\n', '        return (hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Internal functions **/\n', '    \n', '    // Setters: CarbonDollarRegulator overrides the definitions of whitelisted, nonlisted, and blacklisted setUserPermission\n', '\n', '    // CarbonDollar whitelisted users burn CUSD into a WhitelistedToken. Unlike PermissionedToken \n', '    // whitelisted users, CarbonDollar whitelisted users cannot burn ordinary CUSD without converting into WT\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        setUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollar\n', '* @notice The main functionality for the CarbonUSD metatoken. (CarbonUSD is just a proxy\n', "* that implements this contract's functionality.) This is a permissioned token, so users have to be \n", '* whitelisted before they can do any mint/burn/convert operation. Every CarbonDollar token is backed by one\n', '* whitelisted stablecoin credited to the balance of this contract address.\n', '*/\n', 'contract CarbonDollar is PermissionedToken {\n', '    \n', '    // Events\n', '\n', '    event ConvertedToWT(address indexed user, uint256 amount);\n', '    event BurnedCUSD(address indexed user, uint256 feedAmount, uint256 chargedFee);\n', '    \n', '    /**\n', '        Modifiers\n', '    */\n', '    modifier requiresWhitelistedToken() {\n', '        require(isWhitelisted(msg.sender), "Sender must be a whitelisted token contract");\n', '        _;\n', '    }\n', '\n', '    CarbonDollarStorage public tokenStorage_CD;\n', '\n', '    /** CONSTRUCTOR\n', '    * @dev Passes along arguments to base class.\n', '    */\n', '    constructor(address _regulator) public PermissionedToken(_regulator) {\n', '\n', '        // base class override\n', '        regulator = CarbonDollarRegulator(_regulator);\n', '\n', '        tokenStorage_CD = new CarbonDollarStorage();\n', '    }\n', '\n', '    /**\n', '     * @notice Add new stablecoin to whitelist.\n', '     * @param _stablecoin Address of stablecoin contract.\n', '     */\n', '    function listToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.addStablecoin(_stablecoin); \n', '    }\n', '\n', '    /**\n', '     * @notice Remove existing stablecoin from whitelist.\n', '     * @param _stablecoin Address of stablecoin contract.\n', '     */\n', '    function unlistToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.removeStablecoin(_stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Change fees associated with going from CarbonUSD to a particular stablecoin.\n', '     * @param stablecoin Address of the stablecoin contract.\n', '     * @param _newFee The new fee rate to set, in tenths of a percent. \n', '     */\n', '    function setFee(address stablecoin, uint256 _newFee) public onlyOwner whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        tokenStorage_CD.setFee(stablecoin, _newFee);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove fees associated with going from CarbonUSD to a particular stablecoin.\n', '     * The default fee still may apply.\n', '     * @param stablecoin Address of the stablecoin contract.\n', '     */\n', '    function removeFee(address stablecoin) public onlyOwner whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '       tokenStorage_CD.removeFee(stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the default fee associated with going from CarbonUSD to a WhitelistedToken.\n', '     * This fee amount is used if the fee for a WhitelistedToken is not specified.\n', '     * @param _newFee The new fee rate to set, in tenths of a percent.\n', '     */\n', '    function setDefaultFee(uint256 _newFee) public onlyOwner whenNotPaused {\n', '        tokenStorage_CD.setDefaultFee(_newFee);\n', '    }\n', '\n', '    /**\n', '     * @notice Mints CUSD on behalf of a user. Note the use of the "requiresWhitelistedToken"\n', '     * modifier; this means that minting authority does not belong to any personal account; \n', '     * only whitelisted token contracts can call this function. The intended functionality is that the only\n', '     * way to mint CUSD is for the user to actually burn a whitelisted token to convert into CUSD\n', '     * @param _to User to send CUSD to\n', '     * @param _amount Amount of CarbonUSD to mint.\n', '     */\n', '    function mint(address _to, uint256 _amount) public requiresWhitelistedToken whenNotPaused {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice user can convert CarbonUSD umbrella token into a whitelisted stablecoin. \n', '     * @param stablecoin represents the type of coin the users wishes to receive for burning carbonUSD\n', '     * @param _amount Amount of CarbonUSD to convert.\n', "     * we credit the user's account at the sender address with the _amount minus the percentage fee we want to charge.\n", '     */\n', '    function convertCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused  {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '        require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn\'t have enough tokens for burning");\n', ' \n', '        // Send back WT0 to calling user, but with a fee reduction.\n', "        // Transfer this fee into the whitelisted token's CarbonDollar account (this contract's address)\n", '        uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '        uint256 feedAmount = _amount.sub(chargedFee);\n', '        _burn(msg.sender, _amount);\n', '        require(whitelisted.transfer(msg.sender, feedAmount));\n', '        whitelisted.burn(chargedFee);\n', '        _mint(address(this), chargedFee);\n', '        emit ConvertedToWT(msg.sender, _amount);\n', '    }\n', '\n', '     /**\n', '     * @notice burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address\n', '     * @param stablecoin Represents the stablecoin whose fee will be charged.\n', '     * @param _amount Amount of CarbonUSD to burn.\n', '     */\n', '    function burnCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused {\n', '        require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '        WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '        require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn\'t have enough tokens for burning");\n', ' \n', "        // Burn user's CUSD, but with a fee reduction.\n", '        uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '        uint256 feedAmount = _amount.sub(chargedFee);\n', '        _burn(msg.sender, _amount);\n', '        whitelisted.burn(_amount);\n', '        _mint(address(this), chargedFee);\n', '        emit BurnedCUSD(msg.sender, feedAmount, chargedFee); // Whitelisted trust account should send user feedAmount USD\n', '    }\n', '\n', '    /** \n', '    * @notice release collected CUSD fees to owner \n', '    * @param _amount Amount of CUSD to release\n', '    * @return `true` if successful \n', '    */\n', '    function releaseCarbonDollar(uint256 _amount) public onlyOwner returns (bool) {\n', '        require(_amount <= balanceOf(address(this)),"not enough balance to transfer");\n', '\n', '        tokenStorage.subBalance(address(this), _amount);\n', '        tokenStorage.addBalance(msg.sender, _amount);\n', '        emit Transfer(address(this), msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /** Computes fee percentage associated with burning into a particular stablecoin.\n', '     * @param stablecoin The stablecoin whose fee will be charged. Precondition: is a whitelisted\n', '     * stablecoin.\n', "     * @return The fee that will be charged. If the stablecoin's fee is not set, the default\n", '     * fee is returned.\n', '     */\n', '    function computeFeeRate(address stablecoin) public view returns (uint256 feeRate) {\n', '        if (getFee(stablecoin) > 0) \n', '            feeRate = getFee(stablecoin);\n', '        else\n', '            feeRate = getDefaultFee();\n', '    }\n', '\n', '    /**\n', '    * @notice Check if whitelisted token is whitelisted\n', '    * @return bool true if whitelisted, false if not\n', '    **/\n', '    function isWhitelisted(address _stablecoin) public view returns (bool) {\n', '        return tokenStorage_CD.whitelist(_stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '     * @param stablecoin The stablecoin whose fee is being checked.\n', '     * @return The fee associated with the stablecoin.\n', '     */\n', '    function getFee(address stablecoin) public view returns (uint256) {\n', '        return tokenStorage_CD.fees(stablecoin);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '     * @return The default fee for stablecoin trades.\n', '     */\n', '    function getDefaultFee() public view returns (uint256) {\n', '        return tokenStorage_CD.defaultFee();\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal {\n', '        super._mint(_to, _amount);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title WhitelistedTokenRegulator\n', ' * @dev WhitelistedTokenRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A WhitelistedToken\n', ' * provides a user the additional ability to convert from a whtielisted stablecoin into the\n', ' * meta-token CUSD, or mint CUSD directly through a specific WT.\n', ' *\n', ' */\n', 'contract WhitelistedTokenRegulator is Regulator {\n', '\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return (super.isMinter(_who) && hasUserPermission(_who, MINT_CUSD_SIG));\n', '    }\n', '\n', '    // Getters\n', '\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, CONVERT_WT_SIG) && super.isWhitelistedUser(_who));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, CONVERT_WT_SIG) && super.isBlacklistedUser(_who));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, CONVERT_WT_SIG) && super.isNonlistedUser(_who));\n', '    }   \n', '\n', '    /** Internal functions **/\n', '\n', '    // A WT minter should have option to either mint directly into CUSD via mintCUSD(), or\n', '    // mint the WT via an ordinary mint() \n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_CUSD_SIG), "Minting to CUSD not supported by token");\n', '        setUserPermission(_who, MINT_CUSD_SIG);\n', '        super._setMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_CUSD_SIG), "Minting to CUSD not supported by token");\n', '        removeUserPermission(_who, MINT_CUSD_SIG);\n', '        super._removeMinter(_who);\n', '    }\n', '\n', '    // Setters\n', '\n', '    // A WT whitelisted user should gain ability to convert their WT into CUSD. They can also burn their WT, as a\n', '    // PermissionedToken whitelisted user can do\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        setUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        removeUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_WT_SIG), "Converting to CUSD not supported by token");\n', '        removeUserPermission(_who, CONVERT_WT_SIG);\n', '        super._setNonlistedUser(_who);\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title WhitelistedToken\n', '* @notice A WhitelistedToken can be converted into CUSD and vice versa. Converting a WT into a CUSD\n', '* is the only way for a user to obtain CUSD. This is a permissioned token, so users have to be \n', '* whitelisted before they can do any mint/burn/convert operation.\n', '*/\n', 'contract WhitelistedToken is PermissionedToken {\n', '\n', '\n', '    address public cusdAddress;\n', '\n', '    /**\n', '        Events\n', '     */\n', '    event CUSDAddressChanged(address indexed oldCUSD, address indexed newCUSD);\n', '    event MintedToCUSD(address indexed user, uint256 amount);\n', '    event ConvertedToCUSD(address indexed user, uint256 amount);\n', '\n', '    /**\n', '    * @notice Constructor sets the regulator contract and the address of the\n', '    * CarbonUSD meta-token contract. The latter is necessary in order to make transactions\n', '    * with the CarbonDollar smart contract.\n', '    */\n', '    constructor(address _regulator, address _cusd) public PermissionedToken(_regulator) {\n', '\n', '        // base class fields\n', '        regulator = WhitelistedTokenRegulator(_regulator);\n', '\n', '        cusdAddress = _cusd;\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice Mints CarbonUSD for the user. Stores the WT0 that backs the CarbonUSD\n', "    * into the CarbonUSD contract's escrow account.\n", '    * @param _to The address of the receiver\n', '    * @param _amount The number of CarbonTokens to mint to user\n', '    */\n', '    function mintCUSD(address _to, uint256 _amount) public requiresPermission whenNotPaused userWhitelisted(_to) {\n', '        return _mintCUSD(_to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Converts WT0 to CarbonUSD for the user. Stores the WT0 that backs the CarbonUSD\n', "    * into the CarbonUSD contract's escrow account.\n", '    * @param _amount The number of Whitelisted tokens to convert\n', '    */\n', '    function convertWT(uint256 _amount) public requiresPermission whenNotPaused {\n', '        require(balanceOf(msg.sender) >= _amount, "Conversion amount should be less than balance");\n', '        _burn(msg.sender, _amount);\n', '        _mintCUSD(msg.sender, _amount);\n', '        emit ConvertedToCUSD(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Change the cusd address.\n', '     * @param _cusd the cusd address.\n', '     */\n', '    function setCUSDAddress(address _cusd) public onlyOwner {\n', '        require(_cusd != address(cusdAddress), "Must be a new cusd address");\n', '        require(AddressUtils.isContract(_cusd), "Must be an actual contract");\n', '        address oldCUSD = address(cusdAddress);\n', '        cusdAddress = _cusd;\n', '        emit CUSDAddressChanged(oldCUSD, _cusd);\n', '    }\n', '\n', '    function _mintCUSD(address _to, uint256 _amount) internal {\n', '        require(_to != cusdAddress, "Cannot mint to CarbonUSD contract"); // This is to prevent Carbon Labs from printing money out of thin air!\n', '        CarbonDollar(cusdAddress).mint(_to, _amount);\n', '        _mint(cusdAddress, _amount);\n', '        emit MintedToCUSD(_to, _amount);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollar\n', '* @notice The main functionality for the CarbonUSD metatoken. (CarbonUSD is just a proxy\n', "* that implements this contract's functionality.) This is a permissioned token, so users have to be \n", '* whitelisted before they can do any mint/burn/convert operation. Every CarbonDollar token is backed by one\n', '* whitelisted stablecoin credited to the balance of this contract address.\n', '*/\n', '// contract CarbonDollar is PermissionedToken {\n', '    \n', '//     // Events\n', '\n', '//     event ConvertedToWT(address indexed user, uint256 amount);\n', '//     event BurnedCUSD(address indexed user, uint256 feedAmount, uint256 chargedFee);\n', '    \n', '//     /**\n', '//         Modifiers\n', '//     */\n', '//     modifier requiresWhitelistedToken() {\n', '//         require(isWhitelisted(msg.sender), "Sender must be a whitelisted token contract");\n', '//         _;\n', '//     }\n', '\n', '//     CarbonDollarStorage public tokenStorage_CD;\n', '\n', '//     /** CONSTRUCTOR\n', '//     * @dev Passes along arguments to base class.\n', '//     */\n', '//     constructor(address _regulator) public PermissionedToken(_regulator) {\n', '\n', '//         // base class override\n', '//         regulator = CarbonDollarRegulator(_regulator);\n', '\n', '//         tokenStorage_CD = new CarbonDollarStorage();\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Add new stablecoin to whitelist.\n', '//      * @param _stablecoin Address of stablecoin contract.\n', '//      */\n', '//     function listToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.addStablecoin(_stablecoin); \n', '//     }\n', '\n', '//     /**\n', '//      * @notice Remove existing stablecoin from whitelist.\n', '//      * @param _stablecoin Address of stablecoin contract.\n', '//      */\n', '//     function unlistToken(address _stablecoin) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.removeStablecoin(_stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Change fees associated with going from CarbonUSD to a particular stablecoin.\n', '//      * @param stablecoin Address of the stablecoin contract.\n', '//      * @param _newFee The new fee rate to set, in tenths of a percent. \n', '//      */\n', '//     function setFee(address stablecoin, uint256 _newFee) public onlyOwner whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         tokenStorage_CD.setFee(stablecoin, _newFee);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Remove fees associated with going from CarbonUSD to a particular stablecoin.\n', '//      * The default fee still may apply.\n', '//      * @param stablecoin Address of the stablecoin contract.\n', '//      */\n', '//     function removeFee(address stablecoin) public onlyOwner whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//        tokenStorage_CD.removeFee(stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Change the default fee associated with going from CarbonUSD to a WhitelistedToken.\n', '//      * This fee amount is used if the fee for a WhitelistedToken is not specified.\n', '//      * @param _newFee The new fee rate to set, in tenths of a percent.\n', '//      */\n', '//     function setDefaultFee(uint256 _newFee) public onlyOwner whenNotPaused {\n', '//         tokenStorage_CD.setDefaultFee(_newFee);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Mints CUSD on behalf of a user. Note the use of the "requiresWhitelistedToken"\n', '//      * modifier; this means that minting authority does not belong to any personal account; \n', '//      * only whitelisted token contracts can call this function. The intended functionality is that the only\n', '//      * way to mint CUSD is for the user to actually burn a whitelisted token to convert into CUSD\n', '//      * @param _to User to send CUSD to\n', '//      * @param _amount Amount of CarbonUSD to mint.\n', '//      */\n', '//     function mint(address _to, uint256 _amount) public requiresWhitelistedToken whenNotPaused {\n', '//         _mint(_to, _amount);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice user can convert CarbonUSD umbrella token into a whitelisted stablecoin. \n', '//      * @param stablecoin represents the type of coin the users wishes to receive for burning carbonUSD\n', '//      * @param _amount Amount of CarbonUSD to convert.\n', "//      * we credit the user's account at the sender address with the _amount minus the percentage fee we want to charge.\n", '//      */\n', '//     function convertCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused  {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '//         require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn\'t have enough tokens for burning");\n', ' \n', '//         // Send back WT0 to calling user, but with a fee reduction.\n', "//         // Transfer this fee into the whitelisted token's CarbonDollar account (this contract's address)\n", '//         uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '//         uint256 feedAmount = _amount.sub(chargedFee);\n', '//         _burn(msg.sender, _amount);\n', '//         require(whitelisted.transfer(msg.sender, feedAmount));\n', '//         whitelisted.burn(chargedFee);\n', '//         _mint(address(this), chargedFee);\n', '//         emit ConvertedToWT(msg.sender, _amount);\n', '//     }\n', '\n', '//      /**\n', '//      * @notice burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address\n', '//      * @param stablecoin Represents the stablecoin whose fee will be charged.\n', '//      * @param _amount Amount of CarbonUSD to burn.\n', '//      */\n', '//     function burnCarbonDollar(address stablecoin, uint256 _amount) public requiresPermission whenNotPaused {\n', '//         require(isWhitelisted(stablecoin), "Stablecoin must be whitelisted prior to setting conversion fee");\n', '//         WhitelistedToken whitelisted = WhitelistedToken(stablecoin);\n', '//         require(whitelisted.balanceOf(address(this)) >= _amount, "Carbon escrow account in WT0 doesn\'t have enough tokens for burning");\n', ' \n', "//         // Burn user's CUSD, but with a fee reduction.\n", '//         uint256 chargedFee = tokenStorage_CD.computeFee(_amount, computeFeeRate(stablecoin));\n', '//         uint256 feedAmount = _amount.sub(chargedFee);\n', '//         _burn(msg.sender, _amount);\n', '//         whitelisted.burn(_amount);\n', '//         _mint(address(this), chargedFee);\n', '//         emit BurnedCUSD(msg.sender, feedAmount, chargedFee); // Whitelisted trust account should send user feedAmount USD\n', '//     }\n', '\n', '//     /** \n', '//     * @notice release collected CUSD fees to owner \n', '//     * @param _amount Amount of CUSD to release\n', '//     * @return `true` if successful \n', '//     */\n', '//     function releaseCarbonDollar(uint256 _amount) public onlyOwner returns (bool) {\n', '//         require(_amount <= balanceOf(address(this)),"not enough balance to transfer");\n', '\n', '//         tokenStorage.subBalance(address(this), _amount);\n', '//         tokenStorage.addBalance(msg.sender, _amount);\n', '//         emit Transfer(address(this), msg.sender, _amount);\n', '//         return true;\n', '//     }\n', '\n', '//     /** Computes fee percentage associated with burning into a particular stablecoin.\n', '//      * @param stablecoin The stablecoin whose fee will be charged. Precondition: is a whitelisted\n', '//      * stablecoin.\n', "//      * @return The fee that will be charged. If the stablecoin's fee is not set, the default\n", '//      * fee is returned.\n', '//      */\n', '//     function computeFeeRate(address stablecoin) public view returns (uint256 feeRate) {\n', '//         if (getFee(stablecoin) > 0) \n', '//             feeRate = getFee(stablecoin);\n', '//         else\n', '//             feeRate = getDefaultFee();\n', '//     }\n', '\n', '//     /**\n', '//     * @notice Check if whitelisted token is whitelisted\n', '//     * @return bool true if whitelisted, false if not\n', '//     **/\n', '//     function isWhitelisted(address _stablecoin) public view returns (bool) {\n', '//         return tokenStorage_CD.whitelist(_stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Get the fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '//      * @param stablecoin The stablecoin whose fee is being checked.\n', '//      * @return The fee associated with the stablecoin.\n', '//      */\n', '//     function getFee(address stablecoin) public view returns (uint256) {\n', '//         return tokenStorage_CD.fees(stablecoin);\n', '//     }\n', '\n', '//     /**\n', '//      * @notice Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken.\n', '//      * @return The default fee for stablecoin trades.\n', '//      */\n', '//     function getDefaultFee() public view returns (uint256) {\n', '//         return tokenStorage_CD.defaultFee();\n', '//     }\n', '\n', '//     function _mint(address _to, uint256 _amount) internal {\n', '//         super._mint(_to, _amount);\n', '//     }\n', '\n', '// }']
