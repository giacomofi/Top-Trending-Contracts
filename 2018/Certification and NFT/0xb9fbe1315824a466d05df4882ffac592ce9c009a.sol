['pragma solidity ^0.4.21;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/InstantListingV2.sol\n', '\n', 'contract InstantListingV2 is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Proposal {\n', '        address tokenAddress;\n', '        string projectName;\n', '        string websiteUrl;\n', '        string logoUrl;\n', '        string whitepaperUrl;\n', '        string legalDocumentUrl;\n', '        uint256 icoStartDate;\n', '        uint256 icoEndDate;\n', '        uint256 icoRate; // If 4000 COB = 1 ETH, then icoRate = 4000.\n', '        uint256 totalRaised;\n', '    }\n', '\n', '    struct ProposalInfo {\n', '        uint256 totalContributions;\n', '        address sender;\n', '        uint256 round;\n', '    }\n', '\n', '    // Round number\n', '    uint256 public round;\n', '\n', '    // The address of beneficiary.\n', '    address public beneficiary;\n', '\n', '    // Proposals.\n', '    mapping(uint256 => mapping(address => Proposal)) public proposals;\n', '\n', '    // Mapping of tokenAddress to ProposalInfo\n', '    mapping(address => ProposalInfo) public proposalInfos;\n', '\n', '    // Contribution of each round.\n', '    mapping(uint256 => uint256) public roundContribution;\n', '\n', '    // A mapping from token contract address to the last refundable unix\n', '    // timestamp, 0 means not refundable.\n', '    mapping(address => uint256) public refundable;\n', '\n', '    // Configs.\n', '    uint256 public startTime;\n', '    uint256 public hardCap;\n', '    uint256 public duration;\n', '\n', '    // Events.\n', '    event TokenListed(uint256 indexed _round, address _tokenAddress);\n', '    event TokenListingCancelled(address _tokenAddress);\n', '    event RoundFinalized(uint256 _round);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function getCurrentTimestamp() internal view returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    function initialize(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function reset(\n', '        uint256 _startTime,\n', '        uint256 _duration,\n', '        uint256 _hardCap)\n', '        onlyOwner public {\n', '        require(getCurrentTimestamp() >= startTime + duration);\n', '\n', '        // Transfer all balance except for latest round,\n', '        // which is reserved for refund.\n', '        if (round > 0) {\n', '            beneficiary.transfer(address(this).balance - roundContribution[round]);\n', '        }\n', '\n', '        startTime = _startTime;\n', '        duration = _duration;\n', '        hardCap = _hardCap;\n', '\n', '        emit RoundFinalized(round);\n', '        round += 1;\n', '    }\n', '\n', '    function propose(\n', '        address _tokenAddress,\n', '        string _projectName,\n', '        string _websiteUrl,\n', '        string _logoUrl,\n', '        string _whitepaperUrl,\n', '        string _legalDocumentUrl,\n', '        uint256 _icoStartDate,\n', '        uint256 _icoEndDate,\n', '        uint256 _icoRate,\n', '        uint256 _totalRaised) public payable {\n', '\n', '        require(proposalInfos[_tokenAddress].totalContributions == 0);\n', '        require(getCurrentTimestamp() < startTime + duration);\n', '        require(msg.value >= hardCap);\n', '\n', '        proposals[round][_tokenAddress] = Proposal({\n', '            tokenAddress: _tokenAddress,\n', '            projectName: _projectName,\n', '            websiteUrl: _websiteUrl,\n', '            logoUrl: _logoUrl,\n', '            whitepaperUrl: _whitepaperUrl,\n', '            legalDocumentUrl: _legalDocumentUrl,\n', '            icoStartDate: _icoStartDate,\n', '            icoEndDate: _icoEndDate,\n', '            icoRate: _icoRate,\n', '            totalRaised: _totalRaised\n', '        });\n', '\n', '        proposalInfos[_tokenAddress] = ProposalInfo({\n', '            totalContributions: msg.value,\n', '            sender: msg.sender,\n', '            round: round\n', '        });\n', '\n', '        roundContribution[round] = roundContribution[round].add(msg.value);\n', '        emit TokenListed(round, _tokenAddress);\n', '    }\n', '\n', '    function setRefundable(address _tokenAddress, uint256 endTime)\n', '        onlyOwner public {\n', '        refundable[_tokenAddress] = endTime;\n', '    }\n', '\n', '    function refund(address _tokenAddress) public {\n', '        require(refundable[_tokenAddress] > 0 &&\n', '                getCurrentTimestamp() < refundable[_tokenAddress]);\n', '\n', '        uint256 value = proposalInfos[_tokenAddress].totalContributions;\n', '        proposalInfos[_tokenAddress].totalContributions = 0;\n', '        roundContribution[proposalInfos[_tokenAddress].round] =\n', '            roundContribution[proposalInfos[_tokenAddress].round].sub(value);\n', '        proposalInfos[_tokenAddress].sender.transfer(value);\n', '\n', '        emit TokenListingCancelled(_tokenAddress);\n', '    }\n', '\n', '    function getContributions(address _tokenAddress)\n', '        view public returns (uint256) {\n', '        return proposalInfos[_tokenAddress].totalContributions;\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        selfdestruct(beneficiary);\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/InstantListingV2.sol\n', '\n', 'contract InstantListingV2 is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Proposal {\n', '        address tokenAddress;\n', '        string projectName;\n', '        string websiteUrl;\n', '        string logoUrl;\n', '        string whitepaperUrl;\n', '        string legalDocumentUrl;\n', '        uint256 icoStartDate;\n', '        uint256 icoEndDate;\n', '        uint256 icoRate; // If 4000 COB = 1 ETH, then icoRate = 4000.\n', '        uint256 totalRaised;\n', '    }\n', '\n', '    struct ProposalInfo {\n', '        uint256 totalContributions;\n', '        address sender;\n', '        uint256 round;\n', '    }\n', '\n', '    // Round number\n', '    uint256 public round;\n', '\n', '    // The address of beneficiary.\n', '    address public beneficiary;\n', '\n', '    // Proposals.\n', '    mapping(uint256 => mapping(address => Proposal)) public proposals;\n', '\n', '    // Mapping of tokenAddress to ProposalInfo\n', '    mapping(address => ProposalInfo) public proposalInfos;\n', '\n', '    // Contribution of each round.\n', '    mapping(uint256 => uint256) public roundContribution;\n', '\n', '    // A mapping from token contract address to the last refundable unix\n', '    // timestamp, 0 means not refundable.\n', '    mapping(address => uint256) public refundable;\n', '\n', '    // Configs.\n', '    uint256 public startTime;\n', '    uint256 public hardCap;\n', '    uint256 public duration;\n', '\n', '    // Events.\n', '    event TokenListed(uint256 indexed _round, address _tokenAddress);\n', '    event TokenListingCancelled(address _tokenAddress);\n', '    event RoundFinalized(uint256 _round);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function getCurrentTimestamp() internal view returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    function initialize(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function reset(\n', '        uint256 _startTime,\n', '        uint256 _duration,\n', '        uint256 _hardCap)\n', '        onlyOwner public {\n', '        require(getCurrentTimestamp() >= startTime + duration);\n', '\n', '        // Transfer all balance except for latest round,\n', '        // which is reserved for refund.\n', '        if (round > 0) {\n', '            beneficiary.transfer(address(this).balance - roundContribution[round]);\n', '        }\n', '\n', '        startTime = _startTime;\n', '        duration = _duration;\n', '        hardCap = _hardCap;\n', '\n', '        emit RoundFinalized(round);\n', '        round += 1;\n', '    }\n', '\n', '    function propose(\n', '        address _tokenAddress,\n', '        string _projectName,\n', '        string _websiteUrl,\n', '        string _logoUrl,\n', '        string _whitepaperUrl,\n', '        string _legalDocumentUrl,\n', '        uint256 _icoStartDate,\n', '        uint256 _icoEndDate,\n', '        uint256 _icoRate,\n', '        uint256 _totalRaised) public payable {\n', '\n', '        require(proposalInfos[_tokenAddress].totalContributions == 0);\n', '        require(getCurrentTimestamp() < startTime + duration);\n', '        require(msg.value >= hardCap);\n', '\n', '        proposals[round][_tokenAddress] = Proposal({\n', '            tokenAddress: _tokenAddress,\n', '            projectName: _projectName,\n', '            websiteUrl: _websiteUrl,\n', '            logoUrl: _logoUrl,\n', '            whitepaperUrl: _whitepaperUrl,\n', '            legalDocumentUrl: _legalDocumentUrl,\n', '            icoStartDate: _icoStartDate,\n', '            icoEndDate: _icoEndDate,\n', '            icoRate: _icoRate,\n', '            totalRaised: _totalRaised\n', '        });\n', '\n', '        proposalInfos[_tokenAddress] = ProposalInfo({\n', '            totalContributions: msg.value,\n', '            sender: msg.sender,\n', '            round: round\n', '        });\n', '\n', '        roundContribution[round] = roundContribution[round].add(msg.value);\n', '        emit TokenListed(round, _tokenAddress);\n', '    }\n', '\n', '    function setRefundable(address _tokenAddress, uint256 endTime)\n', '        onlyOwner public {\n', '        refundable[_tokenAddress] = endTime;\n', '    }\n', '\n', '    function refund(address _tokenAddress) public {\n', '        require(refundable[_tokenAddress] > 0 &&\n', '                getCurrentTimestamp() < refundable[_tokenAddress]);\n', '\n', '        uint256 value = proposalInfos[_tokenAddress].totalContributions;\n', '        proposalInfos[_tokenAddress].totalContributions = 0;\n', '        roundContribution[proposalInfos[_tokenAddress].round] =\n', '            roundContribution[proposalInfos[_tokenAddress].round].sub(value);\n', '        proposalInfos[_tokenAddress].sender.transfer(value);\n', '\n', '        emit TokenListingCancelled(_tokenAddress);\n', '    }\n', '\n', '    function getContributions(address _tokenAddress)\n', '        view public returns (uint256) {\n', '        return proposalInfos[_tokenAddress].totalContributions;\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        selfdestruct(beneficiary);\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '}']
