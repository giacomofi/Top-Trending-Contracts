['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', 'contract Vote {\n', '  using SafeMath for uint256;\n', '  struct Proposal {\n', '    uint deadline;\n', '    mapping(address => uint) votes;\n', '    uint yeas;\n', '    uint nays;\n', '    string reason;\n', '    bytes data;\n', '    address target;\n', '  }\n', '  struct Deposit {\n', '    uint balance;\n', '    uint lockedUntil;\n', '  }\n', '\n', '  event Proposed(\n', '    uint proposalId,\n', '    uint deadline,\n', '    address target\n', '  );\n', '\n', '  event Executed(\n', '    uint indexed proposalId\n', '  );\n', '\n', '  event Vote(\n', '    uint indexed proposalId,\n', '    address indexed voter,\n', '    uint yeas,\n', '    uint nays,\n', '    uint totalYeas,\n', '    uint totalNays\n', '  );\n', '\n', '  ERC20 public token;\n', '  uint public proposalDuration;\n', '  Proposal[] public proposals;\n', '  mapping(address => Deposit) public deposits;\n', '  mapping(address => bool) public proposers;\n', '\n', '  constructor(address _token) {\n', '    proposers[msg.sender] = true;\n', '    token = ERC20(_token);\n', '    proposalDuration = 5;\n', '    // Start with a passed proposal to increase the duration to 24 hours.\n', '    // Having a short initial proposalDuration makes testing easier, but 24\n', '    // hours is a more reasonable time frame for voting. Having a pre-approved\n', '    // proposal to increase the time means it only has to be executed, and not\n', '    // voted on, as proposing a vote and voting on it within a 5 second\n', '    // duration could be very difficult to accomplish on a main network.\n', '    proposals.push(Proposal({\n', '      deadline: block.timestamp,\n', '      yeas: 1,\n', '      nays: 0,\n', '      reason: "",\n', '      // ABI Encoded setProposalDuration(60*60*24)\n', '      data: hex"7d007ac10000000000000000000000000000000000000000000000000000000000015180",\n', '      target: this\n', '    }));\n', '  }\n', '\n', '  // In order to vote on a proposal, voters must deposit tokens in the contract\n', '  function deposit(uint units) public {\n', '    require(token.transferFrom(msg.sender, address(this), units), "Transfer failed");\n', '    deposits[msg.sender].balance = deposits[msg.sender].balance.add(units);\n', '  }\n', '\n', '  // Once all proposals a user has voted on have completed, they may withdraw\n', '  // their tokens from the contract.\n', '  function withdraw(uint units) external {\n', '    require(deposits[msg.sender].balance >= units, "Insufficient balance");\n', '    require(deposits[msg.sender].lockedUntil < block.timestamp, "Deposit locked");\n', '    deposits[msg.sender].balance = deposits[msg.sender].balance.sub(units);\n', '    token.transfer(msg.sender, units);\n', '  }\n', '\n', '  // A user may cast a number of yea or nay votes equal to the number of tokens\n', '  // they have deposited in the contract. This will lock the user&#39;s deposit\n', '  // until the voting ends for this proposal. Locking deposits ensures the user\n', '  // cannot vote, then transfer tokens away and use them to vote again.\n', '  function vote(uint proposalId, uint yeas, uint nays) public {\n', '\n', '    require(\n', '      proposals[proposalId].deadline > block.timestamp,\n', '      "Voting closed"\n', '    );\n', '    if(proposals[proposalId].deadline > deposits[msg.sender].lockedUntil) {\n', '      // The voter&#39;s deposit is locked until the proposal deadline\n', '      deposits[msg.sender].lockedUntil = proposals[proposalId].deadline;\n', '    }\n', '    // Track vote counts to ensure voters can only vote their deposited tokens\n', '    proposals[proposalId].votes[msg.sender] = proposals[proposalId].votes[msg.sender].add(yeas).add(nays);\n', '    require(proposals[proposalId].votes[msg.sender] <= deposits[msg.sender].balance, "Insufficient balance");\n', '\n', '    // Presumably only one of these will change.\n', '    proposals[proposalId].yeas = proposals[proposalId].yeas.add(yeas);\n', '    proposals[proposalId].nays = proposals[proposalId].nays.add(nays);\n', '\n', '    emit Vote(proposalId, msg.sender, yeas, nays, proposals[proposalId].yeas, proposals[proposalId].nays);\n', '  }\n', '\n', '  // depositAndVote allows users to call deposit() and vote() in a single\n', '  // transaction.\n', '  function depositAndVote(uint proposalId, uint yeas, uint nays) external {\n', '    deposit(yeas.add(nays));\n', '    vote(proposalId, yeas, nays);\n', '  }\n', '\n', '  // Authorized proposers may issue proposals. They must provide the contract\n', '  // data, the target contract, and a reason for the proposal. The reason will\n', '  // probably be a swarm / ipfs URL with a longer explanation.\n', '  function propose(bytes data, address target, string reason) external {\n', '    require(proposers[msg.sender], "Invalid proposer");\n', '    require(data.length > 0, "Invalid proposal");\n', '    uint proposalId = proposals.push(Proposal({\n', '      deadline: block.timestamp + proposalDuration,\n', '      yeas: 0,\n', '      nays: 0,\n', '      reason: reason,\n', '      data: data,\n', '      target: target\n', '    }));\n', '    emit Proposed(\n', '      proposalId - 1,\n', '      block.timestamp + proposalDuration,\n', '      target\n', '    );\n', '  }\n', '\n', '  // If a proposal has passed, it may be executed exactly once. Executed\n', '  // proposals will have the data zeroed out, discounting gas for the submitter\n', '  // and effectively marking the proposal as executed.\n', '  function execute(uint proposalId) external {\n', '    Proposal memory proposal = proposals[proposalId];\n', '    require(\n', '      // Voting is complete when the deadline passes, or a majority of all\n', '      // token holders have voted yea.\n', '      proposal.deadline < block.timestamp || proposal.yeas > (token.totalSupply() / 2),\n', '      "Voting is not complete"\n', '    );\n', '    require(proposal.data.length > 0, "Already executed");\n', '    if(proposal.yeas > proposal.nays) {\n', '      proposal.target.call(proposal.data);\n', '      emit Executed(proposalId);\n', '    }\n', '    // Even if the vote failed, we can still clean out the data\n', '    proposals[proposalId].data = "";\n', '  }\n', '\n', '  // As the result of a vote, proposers may be authorized or deauthorized\n', '  function setProposer(address proposer, bool value) public {\n', '    require(msg.sender == address(this), "Setting a proposer requires a vote");\n', '    proposers[proposer] = value;\n', '  }\n', '\n', '  // As the result of a vote, the duration of voting on a proposal can be\n', '  // changed\n', '  function setProposalDuration(uint value) public {\n', '    require(msg.sender == address(this), "Setting a duration requires a vote");\n', '    proposalDuration = value;\n', '  }\n', '\n', '  function proposalDeadline(uint proposalId) public view returns (uint) {\n', '    return proposals[proposalId].deadline;\n', '  }\n', '\n', '  function proposalData(uint proposalId) public view returns (bytes) {\n', '    return proposals[proposalId].data;\n', '  }\n', '\n', '  function proposalReason(uint proposalId) public view returns (string) {\n', '    return proposals[proposalId].reason;\n', '  }\n', '\n', '  function proposalTarget(uint proposalId) public view returns (address) {\n', '    return proposals[proposalId].target;\n', '  }\n', '\n', '  function proposalVotes(uint proposalId) public view returns (uint[]) {\n', '    uint[] memory votes = new uint[](2);\n', '    votes[0] = proposals[proposalId].yeas;\n', '    votes[1] = proposals[proposalId].nays;\n', '    return votes;\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', 'contract Vote {\n', '  using SafeMath for uint256;\n', '  struct Proposal {\n', '    uint deadline;\n', '    mapping(address => uint) votes;\n', '    uint yeas;\n', '    uint nays;\n', '    string reason;\n', '    bytes data;\n', '    address target;\n', '  }\n', '  struct Deposit {\n', '    uint balance;\n', '    uint lockedUntil;\n', '  }\n', '\n', '  event Proposed(\n', '    uint proposalId,\n', '    uint deadline,\n', '    address target\n', '  );\n', '\n', '  event Executed(\n', '    uint indexed proposalId\n', '  );\n', '\n', '  event Vote(\n', '    uint indexed proposalId,\n', '    address indexed voter,\n', '    uint yeas,\n', '    uint nays,\n', '    uint totalYeas,\n', '    uint totalNays\n', '  );\n', '\n', '  ERC20 public token;\n', '  uint public proposalDuration;\n', '  Proposal[] public proposals;\n', '  mapping(address => Deposit) public deposits;\n', '  mapping(address => bool) public proposers;\n', '\n', '  constructor(address _token) {\n', '    proposers[msg.sender] = true;\n', '    token = ERC20(_token);\n', '    proposalDuration = 5;\n', '    // Start with a passed proposal to increase the duration to 24 hours.\n', '    // Having a short initial proposalDuration makes testing easier, but 24\n', '    // hours is a more reasonable time frame for voting. Having a pre-approved\n', '    // proposal to increase the time means it only has to be executed, and not\n', '    // voted on, as proposing a vote and voting on it within a 5 second\n', '    // duration could be very difficult to accomplish on a main network.\n', '    proposals.push(Proposal({\n', '      deadline: block.timestamp,\n', '      yeas: 1,\n', '      nays: 0,\n', '      reason: "",\n', '      // ABI Encoded setProposalDuration(60*60*24)\n', '      data: hex"7d007ac10000000000000000000000000000000000000000000000000000000000015180",\n', '      target: this\n', '    }));\n', '  }\n', '\n', '  // In order to vote on a proposal, voters must deposit tokens in the contract\n', '  function deposit(uint units) public {\n', '    require(token.transferFrom(msg.sender, address(this), units), "Transfer failed");\n', '    deposits[msg.sender].balance = deposits[msg.sender].balance.add(units);\n', '  }\n', '\n', '  // Once all proposals a user has voted on have completed, they may withdraw\n', '  // their tokens from the contract.\n', '  function withdraw(uint units) external {\n', '    require(deposits[msg.sender].balance >= units, "Insufficient balance");\n', '    require(deposits[msg.sender].lockedUntil < block.timestamp, "Deposit locked");\n', '    deposits[msg.sender].balance = deposits[msg.sender].balance.sub(units);\n', '    token.transfer(msg.sender, units);\n', '  }\n', '\n', '  // A user may cast a number of yea or nay votes equal to the number of tokens\n', "  // they have deposited in the contract. This will lock the user's deposit\n", '  // until the voting ends for this proposal. Locking deposits ensures the user\n', '  // cannot vote, then transfer tokens away and use them to vote again.\n', '  function vote(uint proposalId, uint yeas, uint nays) public {\n', '\n', '    require(\n', '      proposals[proposalId].deadline > block.timestamp,\n', '      "Voting closed"\n', '    );\n', '    if(proposals[proposalId].deadline > deposits[msg.sender].lockedUntil) {\n', "      // The voter's deposit is locked until the proposal deadline\n", '      deposits[msg.sender].lockedUntil = proposals[proposalId].deadline;\n', '    }\n', '    // Track vote counts to ensure voters can only vote their deposited tokens\n', '    proposals[proposalId].votes[msg.sender] = proposals[proposalId].votes[msg.sender].add(yeas).add(nays);\n', '    require(proposals[proposalId].votes[msg.sender] <= deposits[msg.sender].balance, "Insufficient balance");\n', '\n', '    // Presumably only one of these will change.\n', '    proposals[proposalId].yeas = proposals[proposalId].yeas.add(yeas);\n', '    proposals[proposalId].nays = proposals[proposalId].nays.add(nays);\n', '\n', '    emit Vote(proposalId, msg.sender, yeas, nays, proposals[proposalId].yeas, proposals[proposalId].nays);\n', '  }\n', '\n', '  // depositAndVote allows users to call deposit() and vote() in a single\n', '  // transaction.\n', '  function depositAndVote(uint proposalId, uint yeas, uint nays) external {\n', '    deposit(yeas.add(nays));\n', '    vote(proposalId, yeas, nays);\n', '  }\n', '\n', '  // Authorized proposers may issue proposals. They must provide the contract\n', '  // data, the target contract, and a reason for the proposal. The reason will\n', '  // probably be a swarm / ipfs URL with a longer explanation.\n', '  function propose(bytes data, address target, string reason) external {\n', '    require(proposers[msg.sender], "Invalid proposer");\n', '    require(data.length > 0, "Invalid proposal");\n', '    uint proposalId = proposals.push(Proposal({\n', '      deadline: block.timestamp + proposalDuration,\n', '      yeas: 0,\n', '      nays: 0,\n', '      reason: reason,\n', '      data: data,\n', '      target: target\n', '    }));\n', '    emit Proposed(\n', '      proposalId - 1,\n', '      block.timestamp + proposalDuration,\n', '      target\n', '    );\n', '  }\n', '\n', '  // If a proposal has passed, it may be executed exactly once. Executed\n', '  // proposals will have the data zeroed out, discounting gas for the submitter\n', '  // and effectively marking the proposal as executed.\n', '  function execute(uint proposalId) external {\n', '    Proposal memory proposal = proposals[proposalId];\n', '    require(\n', '      // Voting is complete when the deadline passes, or a majority of all\n', '      // token holders have voted yea.\n', '      proposal.deadline < block.timestamp || proposal.yeas > (token.totalSupply() / 2),\n', '      "Voting is not complete"\n', '    );\n', '    require(proposal.data.length > 0, "Already executed");\n', '    if(proposal.yeas > proposal.nays) {\n', '      proposal.target.call(proposal.data);\n', '      emit Executed(proposalId);\n', '    }\n', '    // Even if the vote failed, we can still clean out the data\n', '    proposals[proposalId].data = "";\n', '  }\n', '\n', '  // As the result of a vote, proposers may be authorized or deauthorized\n', '  function setProposer(address proposer, bool value) public {\n', '    require(msg.sender == address(this), "Setting a proposer requires a vote");\n', '    proposers[proposer] = value;\n', '  }\n', '\n', '  // As the result of a vote, the duration of voting on a proposal can be\n', '  // changed\n', '  function setProposalDuration(uint value) public {\n', '    require(msg.sender == address(this), "Setting a duration requires a vote");\n', '    proposalDuration = value;\n', '  }\n', '\n', '  function proposalDeadline(uint proposalId) public view returns (uint) {\n', '    return proposals[proposalId].deadline;\n', '  }\n', '\n', '  function proposalData(uint proposalId) public view returns (bytes) {\n', '    return proposals[proposalId].data;\n', '  }\n', '\n', '  function proposalReason(uint proposalId) public view returns (string) {\n', '    return proposals[proposalId].reason;\n', '  }\n', '\n', '  function proposalTarget(uint proposalId) public view returns (address) {\n', '    return proposals[proposalId].target;\n', '  }\n', '\n', '  function proposalVotes(uint proposalId) public view returns (uint[]) {\n', '    uint[] memory votes = new uint[](2);\n', '    votes[0] = proposals[proposalId].yeas;\n', '    votes[1] = proposals[proposalId].nays;\n', '    return votes;\n', '  }\n', '}']
