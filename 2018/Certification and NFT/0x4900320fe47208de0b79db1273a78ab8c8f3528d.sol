['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Owned {\n', '  address public owner;\n', '  event TransferOwnership(address oldaddr, address newaddr);\n', '  modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '    _;}\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '  function transferOwnership(address _new) onlyOwner public {\n', '    address oldaddr = owner;\n', '    owner = _new;\n', '    TransferOwnership(oldaddr, owner);\n', '  }\n', '}\n', '\n', 'contract MontexToken is Owned{\n', '  string public name;\n', '  string public symbol;\n', '  uint256 public decimals;\n', '  uint256 public totalSupply;\n', '  mapping (address => uint256) public balanceOf;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function MontexToken() public{\n', '    name = "Montex Token";\n', '    symbol = "MON";\n', '    decimals = 8;\n', '    totalSupply = 2e9 * 10**uint256(decimals);\n', '    balanceOf[msg.sender] = totalSupply;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public{\n', '    if (balanceOf[msg.sender] < _value) revert();\n', '    if (balanceOf[_to] + _value < balanceOf[_to]) revert();\n', '      balanceOf[msg.sender] -= _value;\n', '      balanceOf[_to] += _value;\n', '      Transfer(msg.sender, _to, _value);\n', '  }\n', '}\n', '\n', 'contract Crowdsale is Owned {\n', '  using SafeMath for uint256;\n', '  uint256 public fundingGoal;\n', '  uint256 public price;\n', '  uint256 public transferableToken;\n', '  uint256 public soldToken;\n', '  uint256 public deadline;\n', '  uint256 public token_price;\n', '  MontexToken public tokenReward;\n', '  bool public fundingGoalReached = false;\n', '  bool public isOpened;\n', '  mapping (address => Property) public fundersProperty;\n', '\n', '  struct Property {\n', '    uint256 paymentEther;\n', '    uint256 reservedToken;\n', '  }\n', '\n', '  event CrowdsaleStart(uint fundingGoal, uint deadline, uint transferableToken, address beneficiary);\n', '  event ReservedToken(address backer, uint amount, uint token, uint soldToken);\n', '  event WithdrawalToken(address addr, uint amount, bool result);\n', '  event WithdrawalEther(address addr, uint amount, bool result);\n', '  event FinishCrowdSale(address beneficiary, uint fundingGoal, uint amountRaised, bool reached, uint raisedToken);\n', '\n', '  modifier afterDeadline() { if (now >= deadline) _; }\n', '\n', '  function Crowdsale (\n', '    uint _fundingGoalInEthers,\n', '    uint _transferableToken,\n', '    uint _amountOfTokenPerEther,\n', '    MontexToken _addressOfTokenUsedAsReward\n', '  ) public {\n', '    fundingGoal = _fundingGoalInEthers * 1 ether;\n', '    price = 1 ether / _amountOfTokenPerEther;\n', '    tokenReward = MontexToken(_addressOfTokenUsedAsReward);\n', '    transferableToken = _transferableToken * 10 ** uint256(8);\n', '  }\n', '\n', '  function () payable external{\n', '    if (!isOpened || now >= deadline) revert();\n', '\n', '    uint amount = msg.value;\n', '\n', '    uint amont_conv = amount * 1000;\n', '    uint token = (amont_conv / price * token_price / 1000) * 10 ** uint256(8);\n', '\n', '    if (token == 0 || soldToken + token > transferableToken) revert();\n', '    fundersProperty[msg.sender].paymentEther += amount / 10 ** uint256(8);\n', '    fundersProperty[msg.sender].reservedToken += token;\n', '    soldToken += token;\n', '\n', '    tokenReward.transfer(msg.sender, token);\n', '\n', '    ReservedToken(msg.sender, amount, token,soldToken);\n', '  }\n', '\n', '  function start(uint startTime,uint _deadline,uint _token_price) onlyOwner public{\n', '    deadline = _deadline;\n', '    token_price = _token_price;\n', '    if (fundingGoal == 0 || transferableToken == 0 ||\n', '        tokenReward == address(0) ||  startTime >= now)\n', '    {\n', '      revert();\n', '    }\n', '    if (tokenReward.balanceOf(this) >= transferableToken) {\n', '      if(startTime <= now && now <= deadline){\n', '        isOpened = true;\n', '        CrowdsaleStart(fundingGoal, deadline, transferableToken, owner);\n', '      }\n', '    }\n', '  }\n', '\n', '  function getBalance(address _addres) public\n', '  constant returns(uint nowpaymentEther,uint nowbuyToken)\n', '  {\n', '    nowpaymentEther = fundersProperty[_addres].paymentEther * (1 ether) / 10 ** uint256(8);\n', '    nowbuyToken = fundersProperty[_addres].reservedToken;\n', '\n', '  }  \n', '  function valNowRate(uint _amount) public\n', '    view returns(uint get_rate,uint get_token)\n', '    {\n', '    get_rate = token_price;\n', '    get_token = _amount * get_rate;\n', '  }\n', '\n', '\n', '  function getRemainingTimeEthToken() public\n', '    constant returns(\n', '        uint now_time,\n', '        uint now_deadline,\n', '        uint remain_days,\n', '        uint remain_hours,\n', '        uint remain_minutes,\n', '        uint remainEth,\n', '        uint remainToken,\n', '        uint remain_seconds,\n', '        uint getEth,\n', '        uint tokenReward_balance,\n', '        uint transferable_token)\n', '  {\n', '    if(now < deadline) {\n', '      remain_days = (deadline - now) / (1 days);\n', '      remain_hours = (deadline - now) / (1 hours);\n', '      remain_minutes = (deadline - now) / (1 minutes);\n', '      remain_seconds = (deadline - now) / (1 seconds);\n', '      now_time = now;\n', '      now_deadline = deadline;\n', '      \n', '    }\n', '    remainEth = (fundingGoal - this.balance) / (1 ether);\n', '    remainToken = transferableToken - soldToken;\n', '    getEth = this.balance / (1 ether);\n', '    tokenReward_balance = tokenReward.balanceOf(this);\n', '    transferable_token = transferableToken;\n', '  }\n', '\n', '  function finishCrowdSale() onlyOwner public {\n', '    if (this.balance >= fundingGoal) {\n', '      fundingGoalReached = true;\n', '    }\n', '    if(isOpened==true){\n', '      isOpened = false;\n', '\n', '      uint val = transferableToken - soldToken;\n', '      if (val > 0) {\n', '        tokenReward.transfer(msg.sender, transferableToken - soldToken);\n', '        WithdrawalToken(msg.sender, val, true);\n', '      }\n', '    }\n', '      FinishCrowdSale(owner, fundingGoal, this.balance, fundingGoalReached, soldToken);\n', '  }\n', '\n', '  function withdrawalOwner() onlyOwner public{\n', '      uint amount = this.balance;\n', '      if (amount > 0) {\n', '        bool ok = msg.sender.call.value(amount)();\n', '        WithdrawalEther(msg.sender, amount, ok);\n', '      }    \n', '  }\n', '}']