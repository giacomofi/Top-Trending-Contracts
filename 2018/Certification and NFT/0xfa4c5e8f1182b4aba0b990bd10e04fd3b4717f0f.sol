['pragma solidity ^0.4.23;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/grapevine/crowdsale/TokenTimelockController.sol\n', '\n', '/**\n', ' * @title TokenTimelock Controller\n', ' * @dev This contract allows to create/read/revoke TokenTimelock contracts and to claim the amounts vested.\n', ' **/\n', 'contract TokenTimelockController is Ownable {\n', '  using SafeMath for uint;\n', '\n', '  struct TokenTimelock {\n', '    uint256 amount;\n', '    uint256 releaseTime;\n', '    bool released;\n', '    bool revocable;\n', '    bool revoked;\n', '  }\n', '\n', '  event TokenTimelockCreated(\n', '    address indexed beneficiary, \n', '    uint256 releaseTime, \n', '    bool revocable, \n', '    uint256 amount\n', '  );\n', '\n', '  event TokenTimelockRevoked(\n', '    address indexed beneficiary\n', '  );\n', '\n', '  event TokenTimelockBeneficiaryChanged(\n', '    address indexed previousBeneficiary, \n', '    address indexed newBeneficiary\n', '  );\n', '  \n', '  event TokenTimelockReleased(\n', '    address indexed beneficiary,\n', '    uint256 amount\n', '  );\n', '\n', '  uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n', '  uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n', '  uint256 public constant INVESTOR_LOCK_DURATION = 1 hours;\n', '\n', '  mapping (address => TokenTimelock[]) tokenTimeLocks;\n', '  \n', '  ERC20 public token;\n', '  address public crowdsale;\n', '  bool public activated;\n', '\n', '  /// @notice Constructor for TokenTimelock Controller\n', '  constructor(ERC20 _token) public {\n', '    token = _token;\n', '  }\n', '\n', '  modifier onlyCrowdsale() {\n', '    require(msg.sender == crowdsale);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhenActivated() {\n', '    require(activated);\n', '    _;\n', '  }\n', '\n', '  modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n', '    require(_beneficiary != address(0));\n', '    require(_id < tokenTimeLocks[_beneficiary].length);\n', '    require(!tokenTimeLocks[_beneficiary][_id].revoked);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to set the crowdsale address\n', '   * @param _crowdsale address The address of the crowdsale.\n', '   */\n', '  function setCrowdsale(address _crowdsale) external onlyOwner {\n', '    require(_crowdsale != address(0));\n', '    crowdsale = _crowdsale;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to activate the controller.\n', '   * It can be called only by the crowdsale address.\n', '   */\n', '  function activate() external onlyCrowdsale {\n', '    activated = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a lock for the provided _beneficiary with the provided amount\n', '   * The creation can be peformed only if:\n', '   * - the sender is the address of the crowdsale;\n', '   * - the _beneficiary and _tokenHolder are valid addresses;\n', '   * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction.\n', '   * The investors will have a lock with a lock period of 6 months.\n', '   * @param _beneficiary Address that will own the lock.\n', '   * @param _amount the amount of the locked tokens.\n', '   * @param _start when the lock should start.\n', '   * @param _tokenHolder the account that approved the amount for this contract.\n', '   */\n', '  function createInvestorTokenTimeLock(\n', '    address _beneficiary,\n', '    uint256 _amount, \n', '    uint256 _start,\n', '    address _tokenHolder\n', '  ) external onlyCrowdsale returns (bool)\n', '    {\n', '    require(_beneficiary != address(0) && _amount > 0);\n', '    require(_tokenHolder != address(0));\n', '\n', '    TokenTimelock memory tokenLock = TokenTimelock(\n', '      _amount,\n', '      _start.add(INVESTOR_LOCK_DURATION),\n', '      false,\n', '      false,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock);\n', '    require(token.transferFrom(_tokenHolder, this, _amount));\n', '    \n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock.releaseTime,\n', '      false,\n', '      _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates locks for the provided _beneficiary with the provided amount\n', '   * The creation can be peformed only if:\n', '   * - the sender is the owner of the contract;\n', '   * - the _beneficiary and _tokenHolder are valid addresses;\n', '   * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction.\n', '   * The team members will have two locks with 1 and 2 years lock period, each having half of the amount.\n', '   * @param _beneficiary Address that will own the lock.\n', '   * @param _amount the amount of the locked tokens.\n', '   * @param _start when the lock should start.\n', '   * @param _tokenHolder the account that approved the amount for this contract.\n', '   */\n', '  function createTeamTokenTimeLock(\n', '    address _beneficiary,\n', '    uint256 _amount, \n', '    uint256 _start,\n', '    address _tokenHolder\n', '  ) external onlyOwner returns (bool)\n', '    {\n', '    require(_beneficiary != address(0) && _amount > 0);\n', '    require(_tokenHolder != address(0));\n', '\n', '    uint256 amount = _amount.div(2);\n', '    TokenTimelock memory tokenLock1 = TokenTimelock(\n', '      amount,\n', '      _start.add(TEAM_LOCK_DURATION_PART1),\n', '      false,\n', '      true,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock1);\n', '\n', '    TokenTimelock memory tokenLock2 = TokenTimelock(\n', '      amount,\n', '      _start.add(TEAM_LOCK_DURATION_PART2),\n', '      false,\n', '      true,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock2);\n', '\n', '    require(token.transferFrom(_tokenHolder, this, _amount));\n', '    \n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock1.releaseTime,\n', '      true,\n', '      amount);\n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock2.releaseTime,\n', '      true,\n', '      amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Revokes the lock for the provided _beneficiary and _id.\n', '   * The revoke can be peformed only if:\n', '   * - the sender is the owner of the contract;\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the _beneficiary and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock is revokable;\n', '   * - the lock was not released.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function revokeTokenTimelock(\n', '    address _beneficiary,\n', '    uint256 _id) \n', '    external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n', '  {\n', '    require(tokenTimeLocks[_beneficiary][_id].revocable);\n', '    require(!tokenTimeLocks[_beneficiary][_id].released);\n', '    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n', '    tokenLock.revoked = true;\n', '    require(token.transfer(owner, tokenLock.amount));\n', '    emit TokenTimelockRevoked(_beneficiary);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number locks of the provided _beneficiary.\n', '   * @param _beneficiary Address owning the locks.\n', '   */\n', '  function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n', '    return tokenTimeLocks[_beneficiary].length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the details of the lock referenced by the provided _beneficiary and _id.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n', '    uint256 _amount,\n', '    uint256 _releaseTime,\n', '    bool _released,\n', '    bool _revocable,\n', '    bool _revoked) \n', '    {\n', '    require(_id < tokenTimeLocks[_beneficiary].length);\n', '    _amount = tokenTimeLocks[_beneficiary][_id].amount;\n', '    _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n', '    _released = tokenTimeLocks[_beneficiary][_id].released;\n', '    _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n', '    _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n', '  }\n', '\n', '  /**\n', '   * @dev Changes the beneficiary of the _id&#39;th lock of the sender with the provided newBeneficiary.\n', '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the sender and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * @param _id id of the lock.\n', '   * @param _newBeneficiary Address of the new beneficiary.\n', '   */\n', '  function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n', '    tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n', '    if (tokenTimeLocks[msg.sender].length > 1) {\n', '      tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n', '      delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n', '    }\n', '    tokenTimeLocks[msg.sender].length--;\n', '    emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n', '  }\n', '\n', '  /**\n', '   * @dev Releases the tokens for the calling sender and _id.\n', '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the sender and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock was not released before;\n', '   * - the lock period has passed.\n', '   * @param _id id of the lock.\n', '   */\n', '  function release(uint256 _id) external {\n', '    releaseFor(msg.sender, _id);\n', '  }\n', '\n', '   /**\n', '   * @dev Releases the tokens for the provided _beneficiary and _id.\n', '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the _beneficiary and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock was not released before;\n', '   * - the lock period has passed.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n', '    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n', '    require(!tokenLock.released);\n', '    // solium-disable-next-line security/no-block-members\n', '    require(block.timestamp >= tokenLock.releaseTime);\n', '    tokenLock.released = true;\n', '    require(token.transfer(_beneficiary, tokenLock.amount));\n', '    emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/grapevine/crowdsale/TokenTimelockController.sol\n', '\n', '/**\n', ' * @title TokenTimelock Controller\n', ' * @dev This contract allows to create/read/revoke TokenTimelock contracts and to claim the amounts vested.\n', ' **/\n', 'contract TokenTimelockController is Ownable {\n', '  using SafeMath for uint;\n', '\n', '  struct TokenTimelock {\n', '    uint256 amount;\n', '    uint256 releaseTime;\n', '    bool released;\n', '    bool revocable;\n', '    bool revoked;\n', '  }\n', '\n', '  event TokenTimelockCreated(\n', '    address indexed beneficiary, \n', '    uint256 releaseTime, \n', '    bool revocable, \n', '    uint256 amount\n', '  );\n', '\n', '  event TokenTimelockRevoked(\n', '    address indexed beneficiary\n', '  );\n', '\n', '  event TokenTimelockBeneficiaryChanged(\n', '    address indexed previousBeneficiary, \n', '    address indexed newBeneficiary\n', '  );\n', '  \n', '  event TokenTimelockReleased(\n', '    address indexed beneficiary,\n', '    uint256 amount\n', '  );\n', '\n', '  uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n', '  uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n', '  uint256 public constant INVESTOR_LOCK_DURATION = 1 hours;\n', '\n', '  mapping (address => TokenTimelock[]) tokenTimeLocks;\n', '  \n', '  ERC20 public token;\n', '  address public crowdsale;\n', '  bool public activated;\n', '\n', '  /// @notice Constructor for TokenTimelock Controller\n', '  constructor(ERC20 _token) public {\n', '    token = _token;\n', '  }\n', '\n', '  modifier onlyCrowdsale() {\n', '    require(msg.sender == crowdsale);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhenActivated() {\n', '    require(activated);\n', '    _;\n', '  }\n', '\n', '  modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n', '    require(_beneficiary != address(0));\n', '    require(_id < tokenTimeLocks[_beneficiary].length);\n', '    require(!tokenTimeLocks[_beneficiary][_id].revoked);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to set the crowdsale address\n', '   * @param _crowdsale address The address of the crowdsale.\n', '   */\n', '  function setCrowdsale(address _crowdsale) external onlyOwner {\n', '    require(_crowdsale != address(0));\n', '    crowdsale = _crowdsale;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to activate the controller.\n', '   * It can be called only by the crowdsale address.\n', '   */\n', '  function activate() external onlyCrowdsale {\n', '    activated = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a lock for the provided _beneficiary with the provided amount\n', '   * The creation can be peformed only if:\n', '   * - the sender is the address of the crowdsale;\n', '   * - the _beneficiary and _tokenHolder are valid addresses;\n', '   * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction.\n', '   * The investors will have a lock with a lock period of 6 months.\n', '   * @param _beneficiary Address that will own the lock.\n', '   * @param _amount the amount of the locked tokens.\n', '   * @param _start when the lock should start.\n', '   * @param _tokenHolder the account that approved the amount for this contract.\n', '   */\n', '  function createInvestorTokenTimeLock(\n', '    address _beneficiary,\n', '    uint256 _amount, \n', '    uint256 _start,\n', '    address _tokenHolder\n', '  ) external onlyCrowdsale returns (bool)\n', '    {\n', '    require(_beneficiary != address(0) && _amount > 0);\n', '    require(_tokenHolder != address(0));\n', '\n', '    TokenTimelock memory tokenLock = TokenTimelock(\n', '      _amount,\n', '      _start.add(INVESTOR_LOCK_DURATION),\n', '      false,\n', '      false,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock);\n', '    require(token.transferFrom(_tokenHolder, this, _amount));\n', '    \n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock.releaseTime,\n', '      false,\n', '      _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Creates locks for the provided _beneficiary with the provided amount\n', '   * The creation can be peformed only if:\n', '   * - the sender is the owner of the contract;\n', '   * - the _beneficiary and _tokenHolder are valid addresses;\n', '   * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction.\n', '   * The team members will have two locks with 1 and 2 years lock period, each having half of the amount.\n', '   * @param _beneficiary Address that will own the lock.\n', '   * @param _amount the amount of the locked tokens.\n', '   * @param _start when the lock should start.\n', '   * @param _tokenHolder the account that approved the amount for this contract.\n', '   */\n', '  function createTeamTokenTimeLock(\n', '    address _beneficiary,\n', '    uint256 _amount, \n', '    uint256 _start,\n', '    address _tokenHolder\n', '  ) external onlyOwner returns (bool)\n', '    {\n', '    require(_beneficiary != address(0) && _amount > 0);\n', '    require(_tokenHolder != address(0));\n', '\n', '    uint256 amount = _amount.div(2);\n', '    TokenTimelock memory tokenLock1 = TokenTimelock(\n', '      amount,\n', '      _start.add(TEAM_LOCK_DURATION_PART1),\n', '      false,\n', '      true,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock1);\n', '\n', '    TokenTimelock memory tokenLock2 = TokenTimelock(\n', '      amount,\n', '      _start.add(TEAM_LOCK_DURATION_PART2),\n', '      false,\n', '      true,\n', '      false\n', '    );\n', '    tokenTimeLocks[_beneficiary].push(tokenLock2);\n', '\n', '    require(token.transferFrom(_tokenHolder, this, _amount));\n', '    \n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock1.releaseTime,\n', '      true,\n', '      amount);\n', '    emit TokenTimelockCreated(\n', '      _beneficiary,\n', '      tokenLock2.releaseTime,\n', '      true,\n', '      amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Revokes the lock for the provided _beneficiary and _id.\n', '   * The revoke can be peformed only if:\n', '   * - the sender is the owner of the contract;\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the _beneficiary and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock is revokable;\n', '   * - the lock was not released.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function revokeTokenTimelock(\n', '    address _beneficiary,\n', '    uint256 _id) \n', '    external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n', '  {\n', '    require(tokenTimeLocks[_beneficiary][_id].revocable);\n', '    require(!tokenTimeLocks[_beneficiary][_id].released);\n', '    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n', '    tokenLock.revoked = true;\n', '    require(token.transfer(owner, tokenLock.amount));\n', '    emit TokenTimelockRevoked(_beneficiary);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number locks of the provided _beneficiary.\n', '   * @param _beneficiary Address owning the locks.\n', '   */\n', '  function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n', '    return tokenTimeLocks[_beneficiary].length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the details of the lock referenced by the provided _beneficiary and _id.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n', '    uint256 _amount,\n', '    uint256 _releaseTime,\n', '    bool _released,\n', '    bool _revocable,\n', '    bool _revoked) \n', '    {\n', '    require(_id < tokenTimeLocks[_beneficiary].length);\n', '    _amount = tokenTimeLocks[_beneficiary][_id].amount;\n', '    _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n', '    _released = tokenTimeLocks[_beneficiary][_id].released;\n', '    _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n', '    _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n', '  }\n', '\n', '  /**\n', "   * @dev Changes the beneficiary of the _id'th lock of the sender with the provided newBeneficiary.\n", '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the sender and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * @param _id id of the lock.\n', '   * @param _newBeneficiary Address of the new beneficiary.\n', '   */\n', '  function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n', '    tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n', '    if (tokenTimeLocks[msg.sender].length > 1) {\n', '      tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n', '      delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n', '    }\n', '    tokenTimeLocks[msg.sender].length--;\n', '    emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n', '  }\n', '\n', '  /**\n', '   * @dev Releases the tokens for the calling sender and _id.\n', '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the sender and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock was not released before;\n', '   * - the lock period has passed.\n', '   * @param _id id of the lock.\n', '   */\n', '  function release(uint256 _id) external {\n', '    releaseFor(msg.sender, _id);\n', '  }\n', '\n', '   /**\n', '   * @dev Releases the tokens for the provided _beneficiary and _id.\n', '   * The release can be peformed only if:\n', '   * - the controller was activated by the crowdsale contract;\n', '   * - the _beneficiary and _id reference a valid lock;\n', '   * - the lock was not revoked;\n', '   * - the lock was not released before;\n', '   * - the lock period has passed.\n', '   * @param _beneficiary Address owning the lock.\n', '   * @param _id id of the lock.\n', '   */\n', '  function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n', '    TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n', '    require(!tokenLock.released);\n', '    // solium-disable-next-line security/no-block-members\n', '    require(block.timestamp >= tokenLock.releaseTime);\n', '    tokenLock.released = true;\n', '    require(token.transfer(_beneficiary, tokenLock.amount));\n', '    emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n', '  }\n', '}']
