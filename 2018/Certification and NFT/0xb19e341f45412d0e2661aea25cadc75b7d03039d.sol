['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract IERC20 is ERC20 {\n', '\n', '    function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool);\n', '\n', '    function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface for the ST20 token standard\n', ' */\n', 'contract IST20 is StandardToken, DetailedERC20 {\n', '\n', '    // off-chain hash\n', '    string public tokenDetails;\n', '\n', '    //transfer, transferFrom must respect use respect the result of verifyTransfer\n', '    function verifyTransfer(address _from, address _to, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice mints new tokens and assigns them to the target _investor.\n', '     * Can only be called by the STO attached to the token (Or by the ST owner if there&#39;s no STO attached yet)\n', '     */\n', '    function mint(address _investor, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice Burn function used to burn the securityToken\n', '     * @param _value No. of token that get burned\n', '     */\n', '    function burn(uint256 _value) public;\n', '\n', '    event Minted(address indexed to, uint256 amount);\n', '    event Burnt(address indexed _burner, uint256 _value);\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface for all security tokens\n', ' */\n', 'contract ISecurityToken is IST20, Ownable {\n', '\n', '    uint8 public constant PERMISSIONMANAGER_KEY = 1;\n', '    uint8 public constant TRANSFERMANAGER_KEY = 2;\n', '    uint8 public constant STO_KEY = 3;\n', '    uint8 public constant CHECKPOINT_KEY = 4;\n', '    uint256 public granularity;\n', '\n', '    // Value of current checkpoint\n', '    uint256 public currentCheckpointId;\n', '\n', '    // Total number of non-zero token holders\n', '    uint256 public investorCount;\n', '\n', '    // List of token holders\n', '    address[] public investors;\n', '\n', '    // Permissions this to a Permission module, which has a key of 1\n', '    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\n', '    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\n', '\n', '    /**\n', '     * @notice returns module list for a module type\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _moduleIndex is the index of the module within the chosen type\n', '     */\n', '    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice returns module list for a module name - will return first match\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _name is the name of the module within the chosen type\n', '     */\n', '    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice Queries totalSupply as of a defined checkpoint\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Queries balances as of a defined checkpoint\n', '     * @param _investor Investor to query balance for\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n', '     */\n', '    function createCheckpoint() public returns(uint256);\n', '\n', '    /**\n', '     * @notice gets length of investors array\n', '     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\n', '     * @return length\n', '     */\n', '    function getInvestorsLength() public view returns(uint256);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface that any module factory contract should implement\n', ' */\n', 'contract IModuleFactory is Ownable {\n', '\n', '    ERC20 public polyToken;\n', '    uint256 public setupCost;\n', '    uint256 public usageCost;\n', '    uint256 public monthlySubscriptionCost;\n', '\n', '    event LogChangeFactorySetupFee(uint256 _oldSetupcost, uint256 _newSetupCost, address _moduleFactory);\n', '    event LogChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n', '    event LogChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n', '    event LogGenerateModuleFromFactory(address _module, bytes32 indexed _moduleName, address indexed _moduleFactory, address _creator, uint256 _timestamp);\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\n', '      polyToken = ERC20(_polyAddress);\n', '      setupCost = _setupCost;\n', '      usageCost = _usageCost;\n', '      monthlySubscriptionCost = _subscriptionCost;\n', '    }\n', '\n', '    //Should create an instance of the Module, or throw\n', '    function deploy(bytes _data) external returns(address);\n', '\n', '    /**\n', '     * @notice Type of the Module factory\n', '     */\n', '    function getType() public view returns(uint8);\n', '\n', '    /**\n', '     * @notice Get the name of the Module\n', '     */\n', '    function getName() public view returns(bytes32);\n', '\n', '    /**\n', '     * @notice Get the description of the Module\n', '     */\n', '    function getDescription() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the title of the Module\n', '     */\n', '    function getTitle() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the Instructions that helped to used the module\n', '     */\n', '    function getInstructions() public view returns (string);\n', '\n', '    /**\n', '     * @notice Get the tags related to the module factory\n', '     */\n', '    function getTags() public view returns (bytes32[]);\n', '\n', '    //Pull function sig from _data\n', '    function getSig(bytes _data) internal pure returns (bytes4 sig) {\n', '        uint len = _data.length < 4 ? _data.length : 4;\n', '        for (uint i = 0; i < len; i++) {\n', '            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the setup cost\n', '     * @param _newSetupCost new setup cost\n', '     */\n', '    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\n', '        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\n', '        setupCost = _newSetupCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the usage cost\n', '     * @param _newUsageCost new usage cost\n', '     */\n', '    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\n', '        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\n', '        usageCost = _newUsageCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the subscription cost\n', '     * @param _newSubscriptionCost new subscription cost\n', '     */\n', '    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\n', '        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\n', '        monthlySubscriptionCost = _newSubscriptionCost;\n', '        \n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface that any module contract should implement\n', ' */\n', 'contract IModule {\n', '\n', '    address public factory;\n', '\n', '    address public securityToken;\n', '\n', '    bytes32 public constant FEE_ADMIN = "FEE_ADMIN";\n', '\n', '    ERC20 public polyToken;\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _securityToken Address of the security token\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _securityToken, address _polyAddress) public {\n', '        securityToken = _securityToken;\n', '        factory = msg.sender;\n', '        polyToken = ERC20(_polyAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice This function returns the signature of configure function\n', '     */\n', '    function getInitFunction() public pure returns (bytes4);\n', '\n', '    //Allows owner, factory or permissioned delegate\n', '    modifier withPerm(bytes32 _perm) {\n', '        bool isOwner = msg.sender == ISecurityToken(securityToken).owner();\n', '        bool isFactory = msg.sender == factory;\n', '        require(isOwner||isFactory||ISecurityToken(securityToken).checkPermission(msg.sender, address(this), _perm), "Permission check failed");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == ISecurityToken(securityToken).owner(), "Sender is not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFactory {\n', '        require(msg.sender == factory, "Sender is not factory");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFactoryOwner {\n', '        require(msg.sender == IModuleFactory(factory).owner(), "Sender is not factory owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the permissions flag that are associated with Module\n', '     */\n', '    function getPermissions() public view returns(bytes32[]);\n', '\n', '    /**\n', '     * @notice used to withdraw the fee by the factory owner\n', '     */\n', '    function takeFee(uint256 _amount) public withPerm(FEE_ADMIN) returns(bool) {\n', '        require(polyToken.transferFrom(address(this), IModuleFactory(factory).owner(), _amount), "Unable to take fee");\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath module registry contract\n', ' */\n', 'contract IModuleRegistry {\n', '\n', '    /**\n', '     * @notice Called by a security token to notify the registry it is using a module\n', '     * @param _moduleFactory is the address of the relevant module factory\n', '     */\n', '    function useModule(address _moduleFactory) external;\n', '\n', '    /**\n', '     * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\n', '     * @param _moduleFactory is the address of the module factory to be registered\n', '     */\n', '    function registerModule(address _moduleFactory) external returns(bool);\n', '\n', '    /**\n', '     * @notice Use to get all the tags releated to the functionality of the Module Factory.\n', '     * @param _moduleType Type of module\n', '     */\n', '    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]);\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal {\n', '        require(!paused);\n', '        paused = true;\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal {\n', '        require(paused);\n', '        paused = false;\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface to be implemented by all Transfer Manager modules\n', ' */\n', 'contract ITransferManager is IModule, Pausable {\n', '\n', '    //If verifyTransfer returns:\n', '    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\n', '    //  INVALID, then the transfer should not be allowed regardless of other TM results\n', '    //  VALID, then the transfer is valid for this TM\n', '    //  NA, then the result from this TM is ignored\n', '    enum Result {INVALID, NA, VALID, FORCE_VALID}\n', '\n', '    function verifyTransfer(address _from, address _to, uint256 _amount, bool _isTransfer) public returns(Result);\n', '\n', '    function unpause() onlyOwner public {\n', '        super._unpause();\n', '    }\n', '\n', '    function pause() onlyOwner public {\n', '        super._pause();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Interface to be implemented by all permission manager modules\n', ' */\n', 'contract IPermissionManager is IModule {\n', '\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\n', '\n', '    function changePermission(address _delegate, address _module, bytes32 _perm, bool _valid) public returns(bool);\n', '\n', '    function getDelegateDetails(address _delegate) public view returns(bytes32);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for the token burner contract\n', ' */\n', 'interface ITokenBurner {\n', '\n', '    function burn(address _burner, uint256  _value ) external returns(bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0));\n', '        ERC20Basic token = ERC20Basic(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Get the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) view public returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice change the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public tickerRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0));\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() onlyOwner public {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress("TickerRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97e5f2faf4f8d7a5">[email&#160;protected]</a>π.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '* @title Security Token contract\n', '* @notice SecurityToken is an ERC20 token with added capabilities:\n', '* @notice - Implements the ST-20 Interface\n', '* @notice - Transfers are restricted\n', '* @notice - Modules can be attached to it to control its behaviour\n', '* @notice - ST should not be deployed directly, but rather the SecurityTokenRegistry should be used\n', '*/\n', 'contract SecurityToken is ISecurityToken, ReentrancyGuard, RegistryUpdater {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 public constant securityTokenVersion = "0.0.1";\n', '\n', '    // Reference to token burner contract\n', '    ITokenBurner public tokenBurner;\n', '\n', '    // Use to halt all the transactions\n', '    bool public freeze = false;\n', '\n', '    struct ModuleData {\n', '        bytes32 name;\n', '        address moduleAddress;\n', '    }\n', '\n', '    // Structures to maintain checkpoints of balances for governance / dividends\n', '    struct Checkpoint {\n', '        uint256 checkpointId;\n', '        uint256 value;\n', '    }\n', '\n', '    mapping (address => Checkpoint[]) public checkpointBalances;\n', '    Checkpoint[] public checkpointTotalSupply;\n', '\n', '    bool public finishedIssuerMinting = false;\n', '    bool public finishedSTOMinting = false;\n', '\n', '    mapping (bytes4 => bool) transferFunctions;\n', '\n', '    // Module list should be order agnostic!\n', '    mapping (uint8 => ModuleData[]) public modules;\n', '\n', '    uint8 public constant MAX_MODULES = 20;\n', '\n', '    mapping (address => bool) public investorListed;\n', '\n', '    // Emit at the time when module get added\n', '    event LogModuleAdded(\n', '        uint8 indexed _type,\n', '        bytes32 _name,\n', '        address _moduleFactory,\n', '        address _module,\n', '        uint256 _moduleCost,\n', '        uint256 _budget,\n', '        uint256 _timestamp\n', '    );\n', '\n', '    // Emit when the token details get updated\n', '    event LogUpdateTokenDetails(string _oldDetails, string _newDetails);\n', '    // Emit when the granularity get changed\n', '    event LogGranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n', '    // Emit when Module get removed from the securityToken\n', '    event LogModuleRemoved(uint8 indexed _type, address _module, uint256 _timestamp);\n', '    // Emit when the budget allocated to a module is changed\n', '    event LogModuleBudgetChanged(uint8 indexed _moduleType, address _module, uint256 _budget);\n', '    // Emit when all the transfers get freeze\n', '    event LogFreezeTransfers(bool _freeze, uint256 _timestamp);\n', '    // Emit when new checkpoint created\n', '    event LogCheckpointCreated(uint256 indexed _checkpointId, uint256 _timestamp);\n', '    // Emit when the minting get finished for the Issuer\n', '    event LogFinishMintingIssuer(uint256 _timestamp);\n', '    // Emit when the minting get finished for the STOs\n', '    event LogFinishMintingSTO(uint256 _timestamp);\n', '    // Change the STR address in the event of a upgrade\n', '    event LogChangeSTRAddress(address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    // If _fallback is true, then for STO module type we only allow the module if it is set, if it is not set we only allow the owner\n', '    // for other _moduleType we allow both issuer and module.\n', '    modifier onlyModule(uint8 _moduleType, bool _fallback) {\n', '      //Loop over all modules of type _moduleType\n', '        bool isModuleType = false;\n', '        for (uint8 i = 0; i < modules[_moduleType].length; i++) {\n', '            isModuleType = isModuleType || (modules[_moduleType][i].moduleAddress == msg.sender);\n', '        }\n', '        if (_fallback && !isModuleType) {\n', '            if (_moduleType == STO_KEY)\n', '                require(modules[_moduleType].length == 0 && msg.sender == owner, "Sender is not owner or STO module is attached");\n', '            else\n', '                require(msg.sender == owner, "Sender is not owner");\n', '        } else {\n', '            require(isModuleType, "Sender is not correct module type");\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier checkGranularity(uint256 _amount) {\n', '        require(_amount % granularity == 0, "Unable to modify token balances at this granularity");\n', '        _;\n', '    }\n', '\n', '    // Checks whether the minting is allowed or not, check for the owner if owner is no the msg.sender then check\n', '    // for the finishedSTOMinting flag because only STOs and owner are allowed for minting\n', '    modifier isMintingAllowed() {\n', '        if (msg.sender == owner) {\n', '            require(!finishedIssuerMinting, "Minting is finished for Issuer");\n', '        } else {\n', '            require(!finishedSTOMinting, "Minting is finished for STOs");\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _name Name of the SecurityToken\n', '     * @param _symbol Symbol of the Token\n', '     * @param _decimals Decimals for the securityToken\n', '     * @param _granularity granular level of the token\n', '     * @param _tokenDetails Details of the token that are stored off-chain (IPFS hash)\n', '     * @param _polymathRegistry Contract address of the polymath registry\n', '     */\n', '    constructor (\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals,\n', '        uint256 _granularity,\n', '        string _tokenDetails,\n', '        address _polymathRegistry\n', '    )\n', '    public\n', '    DetailedERC20(_name, _symbol, _decimals)\n', '    RegistryUpdater(_polymathRegistry)\n', '    {\n', '        //When it is created, the owner is the STR\n', '        updateFromRegistry();\n', '        tokenDetails = _tokenDetails;\n', '        granularity = _granularity;\n', '        transferFunctions[bytes4(keccak256("transfer(address,uint256)"))] = true;\n', '        transferFunctions[bytes4(keccak256("transferFrom(address,address,uint256)"))] = true;\n', '        transferFunctions[bytes4(keccak256("mint(address,uint256)"))] = true;\n', '        transferFunctions[bytes4(keccak256("burn(uint256)"))] = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Function used to attach the module in security token\n', '     * @param _moduleFactory Contract address of the module factory that needs to be attached\n', '     * @param _data Data used for the intialization of the module factory variables\n', '     * @param _maxCost Maximum cost of the Module factory\n', '     * @param _budget Budget of the Module factory\n', '     */\n', '    function addModule(\n', '        address _moduleFactory,\n', '        bytes _data,\n', '        uint256 _maxCost,\n', '        uint256 _budget\n', '    ) external onlyOwner nonReentrant {\n', '        _addModule(_moduleFactory, _data, _maxCost, _budget);\n', '    }\n', '\n', '    /**\n', '    * @notice _addModule handles the attachment (or replacement) of modules for the ST\n', '    * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n', '    * @dev to control restrictions on transfers.\n', '    * @dev You are allowed to add a new moduleType if:\n', '    * @dev - there is no existing module of that type yet added\n', '    * @dev - the last member of the module list is replacable\n', '    * @param _moduleFactory is the address of the module factory to be added\n', '    * @param _data is data packed into bytes used to further configure the module (See STO usage)\n', '    * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n', '    */\n', '    function _addModule(address _moduleFactory, bytes _data, uint256 _maxCost, uint256 _budget) internal {\n', '        //Check that module exists in registry - will throw otherwise\n', '        IModuleRegistry(moduleRegistry).useModule(_moduleFactory);\n', '        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\n', '        uint8 moduleType = moduleFactory.getType();\n', '        require(modules[moduleType].length < MAX_MODULES, "Limit of MAX MODULES is reached");\n', '        uint256 moduleCost = moduleFactory.setupCost();\n', '        require(moduleCost <= _maxCost, "Max Cost is always be greater than module cost");\n', '        //Approve fee for module\n', '        require(ERC20(polyToken).approve(_moduleFactory, moduleCost), "Not able to approve the module cost");\n', '        //Creates instance of module from factory\n', '        address module = moduleFactory.deploy(_data);\n', '        //Approve ongoing budget\n', '        require(ERC20(polyToken).approve(module, _budget), "Not able to approve the budget");\n', '        //Add to SecurityToken module map\n', '        bytes32 moduleName = moduleFactory.getName();\n', '        modules[moduleType].push(ModuleData(moduleName, module));\n', '        //Emit log event\n', '        emit LogModuleAdded(moduleType, moduleName, _moduleFactory, module, moduleCost, _budget, now);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a module attached to the SecurityToken\n', '    * @param _moduleType is which type of module we are trying to remove\n', '    * @param _moduleIndex is the index of the module within the chosen type\n', '    */\n', '    function removeModule(uint8 _moduleType, uint8 _moduleIndex) external onlyOwner {\n', '        require(_moduleIndex < modules[_moduleType].length,\n', '        "Module index doesn&#39;t exist as per the choosen module type");\n', '        require(modules[_moduleType][_moduleIndex].moduleAddress != address(0),\n', '        "Module contract address should not be 0x");\n', '        //Take the last member of the list, and replace _moduleIndex with this, then shorten the list by one\n', '        emit LogModuleRemoved(_moduleType, modules[_moduleType][_moduleIndex].moduleAddress, now);\n', '        modules[_moduleType][_moduleIndex] = modules[_moduleType][modules[_moduleType].length - 1];\n', '        modules[_moduleType].length = modules[_moduleType].length - 1;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns module list for a module type\n', '     * @param _moduleType is which type of module we are trying to get\n', '     * @param _moduleIndex is the index of the module within the chosen type\n', '     * @return bytes32\n', '     * @return address\n', '     */\n', '    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address) {\n', '        if (modules[_moduleType].length > 0) {\n', '            return (\n', '                modules[_moduleType][_moduleIndex].name,\n', '                modules[_moduleType][_moduleIndex].moduleAddress\n', '            );\n', '        } else {\n', '            return ("", address(0));\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @notice returns module list for a module name - will return first match\n', '     * @param _moduleType is which type of module we are trying to get\n', '     * @param _name is the name of the module within the chosen type\n', '     * @return bytes32\n', '     * @return address\n', '     */\n', '    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address) {\n', '        if (modules[_moduleType].length > 0) {\n', '            for (uint256 i = 0; i < modules[_moduleType].length; i++) {\n', '                if (modules[_moduleType][i].name == _name) {\n', '                  return (\n', '                      modules[_moduleType][i].name,\n', '                      modules[_moduleType][i].moduleAddress\n', '                  );\n', '                }\n', '            }\n', '            return ("", address(0));\n', '        } else {\n', '            return ("", address(0));\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice allows the owner to withdraw unspent POLY stored by them on the ST.\n', '    * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n', '    * @param _amount amount of POLY to withdraw\n', '    */\n', '    function withdrawPoly(uint256 _amount) public onlyOwner {\n', '        require(ERC20(polyToken).transfer(owner, _amount), "In-sufficient balance");\n', '    }\n', '\n', '    /**\n', '    * @notice allows owner to approve more POLY to one of the modules\n', '    * @param _moduleType module type\n', '    * @param _moduleIndex module index\n', '    * @param _budget new budget\n', '    */\n', '    function changeModuleBudget(uint8 _moduleType, uint8 _moduleIndex, uint256 _budget) public onlyOwner {\n', '        require(_moduleType != 0, "Module type cannot be zero");\n', '        require(_moduleIndex < modules[_moduleType].length, "Incorrrect module index");\n', '        uint256 _currentAllowance = IERC20(polyToken).allowance(address(this), modules[_moduleType][_moduleIndex].moduleAddress);\n', '        if (_budget < _currentAllowance) {\n', '            require(IERC20(polyToken).decreaseApproval(modules[_moduleType][_moduleIndex].moduleAddress, _currentAllowance.sub(_budget)), "Insufficient balance to decreaseApproval");\n', '        } else {\n', '            require(IERC20(polyToken).increaseApproval(modules[_moduleType][_moduleIndex].moduleAddress, _budget.sub(_currentAllowance)), "Insufficient balance to increaseApproval");\n', '        }\n', '        emit LogModuleBudgetChanged(_moduleType, modules[_moduleType][_moduleIndex].moduleAddress, _budget);\n', '    }\n', '\n', '    /**\n', '     * @notice change the tokenDetails\n', '     * @param _newTokenDetails New token details\n', '     */\n', '    function updateTokenDetails(string _newTokenDetails) public onlyOwner {\n', '        emit LogUpdateTokenDetails(tokenDetails, _newTokenDetails);\n', '        tokenDetails = _newTokenDetails;\n', '    }\n', '\n', '    /**\n', '    * @notice allows owner to change token granularity\n', '    * @param _granularity granularity level of the token\n', '    */\n', '    function changeGranularity(uint256 _granularity) public onlyOwner {\n', '        require(_granularity != 0, "Granularity can not be 0");\n', '        emit LogGranularityChanged(granularity, _granularity);\n', '        granularity = _granularity;\n', '    }\n', '\n', '    /**\n', '    * @notice keeps track of the number of non-zero token holders\n', '    * @param _from sender of transfer\n', '    * @param _to receiver of transfer\n', '    * @param _value value of transfer\n', '    */\n', '    function adjustInvestorCount(address _from, address _to, uint256 _value) internal {\n', '        if ((_value == 0) || (_from == _to)) {\n', '            return;\n', '        }\n', '        // Check whether receiver is a new token holder\n', '        if ((balanceOf(_to) == 0) && (_to != address(0))) {\n', '            investorCount = investorCount.add(1);\n', '        }\n', '        // Check whether sender is moving all of their tokens\n', '        if (_value == balanceOf(_from)) {\n', '            investorCount = investorCount.sub(1);\n', '        }\n', '        //Also adjust investor list\n', '        if (!investorListed[_to] && (_to != address(0))) {\n', '            investors.push(_to);\n', '            investorListed[_to] = true;\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice removes addresses with zero balances from the investors list\n', '    * @param _start Index in investor list at which to start removing zero balances\n', '    * @param _iters Max number of iterations of the for loop\n', '    * NB - pruning this list will mean you may not be able to iterate over investors on-chain as of a historical checkpoint\n', '    */\n', '    function pruneInvestors(uint256 _start, uint256 _iters) public onlyOwner {\n', '        for (uint256 i = _start; i < Math.min256(_start.add(_iters), investors.length); i++) {\n', '            if ((i < investors.length) && (balanceOf(investors[i]) == 0)) {\n', '                investorListed[investors[i]] = false;\n', '                investors[i] = investors[investors.length - 1];\n', '                investors.length--;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice gets length of investors array\n', '     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\n', '     * @return length\n', '     */\n', '    function getInvestorsLength() public view returns(uint256) {\n', '        return investors.length;\n', '    }\n', '\n', '    /**\n', '     * @notice freeze all the transfers\n', '     */\n', '    function freezeTransfers() public onlyOwner {\n', '        require(!freeze);\n', '        freeze = true;\n', '        emit LogFreezeTransfers(freeze, now);\n', '    }\n', '\n', '    /**\n', '     * @notice un-freeze all the transfers\n', '     */\n', '    function unfreezeTransfers() public onlyOwner {\n', '        require(freeze);\n', '        freeze = false;\n', '        emit LogFreezeTransfers(freeze, now);\n', '    }\n', '\n', '    /**\n', '     * @notice adjust totalsupply at checkpoint after minting or burning tokens\n', '     */\n', '    function adjustTotalSupplyCheckpoints() internal {\n', '        adjustCheckpoints(checkpointTotalSupply, totalSupply());\n', '    }\n', '\n', '    /**\n', '     * @notice adjust token holder balance at checkpoint after a token transfer\n', '     * @param _investor address of the token holder affected\n', '     */\n', '    function adjustBalanceCheckpoints(address _investor) internal {\n', '        adjustCheckpoints(checkpointBalances[_investor], balanceOf(_investor));\n', '    }\n', '\n', '    /**\n', '     * @notice store the changes to the checkpoint objects\n', '     * @param _checkpoints the affected checkpoint object array\n', '     * @param _newValue the new value that needs to be stored\n', '     */\n', '    function adjustCheckpoints(Checkpoint[] storage _checkpoints, uint256 _newValue) internal {\n', '        //No checkpoints set yet\n', '        if (currentCheckpointId == 0) {\n', '            return;\n', '        }\n', '        //No previous checkpoint data - add current balance against checkpoint\n', '        if (_checkpoints.length == 0) {\n', '            _checkpoints.push(\n', '                Checkpoint({\n', '                    checkpointId: currentCheckpointId,\n', '                    value: _newValue\n', '                })\n', '            );\n', '            return;\n', '        }\n', '        //No new checkpoints since last update\n', '        if (_checkpoints[_checkpoints.length - 1].checkpointId == currentCheckpointId) {\n', '            return;\n', '        }\n', '        //New checkpoint, so record balance\n', '        _checkpoints.push(\n', '            Checkpoint({\n', '                checkpointId: currentCheckpointId,\n', '                value: _newValue\n', '            })\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Overloaded version of the transfer function\n', '     * @param _to receiver of transfer\n', '     * @param _value value of transfer\n', '     * @return bool success\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        adjustInvestorCount(msg.sender, _to, _value);\n', '        require(verifyTransfer(msg.sender, _to, _value), "Transfer is not valid");\n', '        adjustBalanceCheckpoints(msg.sender);\n', '        adjustBalanceCheckpoints(_to);\n', '        require(super.transfer(_to, _value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Overloaded version of the transferFrom function\n', '     * @param _from sender of transfer\n', '     * @param _to receiver of transfer\n', '     * @param _value value of transfer\n', '     * @return bool success\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        adjustInvestorCount(_from, _to, _value);\n', '        require(verifyTransfer(_from, _to, _value), "Transfer is not valid");\n', '        adjustBalanceCheckpoints(_from);\n', '        adjustBalanceCheckpoints(_to);\n', '        require(super.transferFrom(_from, _to, _value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice validate transfer with TransferManager module if it exists\n', '     * @dev TransferManager module has a key of 2\n', '     * @param _from sender of transfer\n', '     * @param _to receiver of transfer\n', '     * @param _amount value of transfer\n', '     * @return bool\n', '     */\n', '    function verifyTransfer(address _from, address _to, uint256 _amount) public checkGranularity(_amount) returns (bool) {\n', '        if (!freeze) {\n', '            bool isTransfer = false;\n', '            if (transferFunctions[getSig(msg.data)]) {\n', '              isTransfer = true;\n', '            }\n', '            if (modules[TRANSFERMANAGER_KEY].length == 0) {\n', '                return true;\n', '            }\n', '            bool isInvalid = false;\n', '            bool isValid = false;\n', '            bool isForceValid = false;\n', '            for (uint8 i = 0; i < modules[TRANSFERMANAGER_KEY].length; i++) {\n', '                ITransferManager.Result valid = ITransferManager(modules[TRANSFERMANAGER_KEY][i].moduleAddress).verifyTransfer(_from, _to, _amount, isTransfer);\n', '                if (valid == ITransferManager.Result.INVALID) {\n', '                    isInvalid = true;\n', '                }\n', '                if (valid == ITransferManager.Result.VALID) {\n', '                    isValid = true;\n', '                }\n', '                if (valid == ITransferManager.Result.FORCE_VALID) {\n', '                    isForceValid = true;\n', '                }\n', '            }\n', '            return isForceValid ? true : (isInvalid ? false : isValid);\n', '      }\n', '      return false;\n', '    }\n', '\n', '    /**\n', '     * @notice End token minting period permanently for Issuer\n', '     */\n', '    function finishMintingIssuer() public onlyOwner {\n', '        finishedIssuerMinting = true;\n', '        emit LogFinishMintingIssuer(now);\n', '    }\n', '\n', '    /**\n', '     * @notice End token minting period permanently for STOs\n', '     */\n', '    function finishMintingSTO() public onlyOwner {\n', '        finishedSTOMinting = true;\n', '        emit LogFinishMintingSTO(now);\n', '    }\n', '\n', '    /**\n', '     * @notice mints new tokens and assigns them to the target _investor.\n', '     * @dev Can only be called by the STO attached to the token (Or by the ST owner if there&#39;s no STO attached yet)\n', '     * @param _investor Address to whom the minted tokens will be dilivered\n', '     * @param _amount Number of tokens get minted\n', '     * @return success\n', '     */\n', '    function mint(address _investor, uint256 _amount) public onlyModule(STO_KEY, true) checkGranularity(_amount) isMintingAllowed() returns (bool success) {\n', '        require(_investor != address(0), "Investor address should not be 0x");\n', '        adjustInvestorCount(address(0), _investor, _amount);\n', '        require(verifyTransfer(address(0), _investor, _amount), "Transfer is not valid");\n', '        adjustBalanceCheckpoints(_investor);\n', '        adjustTotalSupplyCheckpoints();\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        balances[_investor] = balances[_investor].add(_amount);\n', '        emit Minted(_investor, _amount);\n', '        emit Transfer(address(0), _investor, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice mints new tokens and assigns them to the target _investor.\n', '     * Can only be called by the STO attached to the token (Or by the ST owner if there&#39;s no STO attached yet)\n', '     * @param _investors A list of addresses to whom the minted tokens will be dilivered\n', '     * @param _amounts A list of number of tokens get minted and transfer to corresponding address of the investor from _investor[] list\n', '     * @return success\n', '     */\n', '    function mintMulti(address[] _investors, uint256[] _amounts) public onlyModule(STO_KEY, true) returns (bool success) {\n', '        require(_investors.length == _amounts.length, "Mis-match in the length of the arrays");\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            mint(_investors[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n', '     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n', '     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n', '     * @param _delegate address of delegate\n', '     * @param _module address of PermissionManager module\n', '     * @param _perm the permissions\n', '     * @return success\n', '     */\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool) {\n', '        if (modules[PERMISSIONMANAGER_KEY].length == 0) {\n', '            return false;\n', '        }\n', '\n', '        for (uint8 i = 0; i < modules[PERMISSIONMANAGER_KEY].length; i++) {\n', '            if (IPermissionManager(modules[PERMISSIONMANAGER_KEY][i].moduleAddress).checkPermission(_delegate, _module, _perm)) {\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice used to set the token Burner address. It only be called by the owner\n', '     * @param _tokenBurner Address of the token burner contract\n', '     */\n', '    function setTokenBurner(address _tokenBurner) public onlyOwner {\n', '        tokenBurner = ITokenBurner(_tokenBurner);\n', '    }\n', '\n', '    /**\n', '     * @notice Burn function used to burn the securityToken\n', '     * @param _value No. of token that get burned\n', '     */\n', '    function burn(uint256 _value) checkGranularity(_value) public {\n', '        adjustInvestorCount(msg.sender, address(0), _value);\n', '        require(tokenBurner != address(0), "Token Burner contract address is not set yet");\n', '        require(verifyTransfer(msg.sender, address(0), _value), "Transfer is not valid");\n', '        require(_value <= balances[msg.sender], "Value should no be greater than the balance of msg.sender");\n', '        adjustBalanceCheckpoints(msg.sender);\n', '        adjustTotalSupplyCheckpoints();\n', '        // no need to require value <= totalSupply, since that would imply the\n', '        // sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        require(tokenBurner.burn(msg.sender, _value), "Token burner process is not validated");\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        emit Burnt(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '    }\n', '\n', '    /**\n', '     * @notice Get function signature from _data\n', '     * @param _data passed data\n', '     * @return bytes4 sig\n', '     */\n', '    function getSig(bytes _data) internal pure returns (bytes4 sig) {\n', '        uint len = _data.length < 4 ? _data.length : 4;\n', '        for (uint i = 0; i < len; i++) {\n', '            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n', '     * @return uint256\n', '     */\n', '    function createCheckpoint() public onlyModule(CHECKPOINT_KEY, true) returns(uint256) {\n', '        require(currentCheckpointId < 2**256 - 1);\n', '        currentCheckpointId = currentCheckpointId + 1;\n', '        emit LogCheckpointCreated(currentCheckpointId, now);\n', '        return currentCheckpointId;\n', '    }\n', '\n', '    /**\n', '     * @notice Queries totalSupply as of a defined checkpoint\n', '     * @param _checkpointId Checkpoint ID to query\n', '     * @return uint256\n', '     */\n', '    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256) {\n', '        return getValueAt(checkpointTotalSupply, _checkpointId, totalSupply());\n', '    }\n', '\n', '    /**\n', '     * @notice Queries value at a defined checkpoint\n', '     * @param checkpoints is array of Checkpoint objects\n', '     * @param _checkpointId Checkpoint ID to query\n', '     * @param _currentValue Current value of checkpoint\n', '     * @return uint256\n', '     */\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint256 _checkpointId, uint256 _currentValue) internal view returns(uint256) {\n', '        require(_checkpointId <= currentCheckpointId);\n', '        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\n', '        if (_checkpointId == 0) {\n', '          return 0;\n', '        }\n', '        if (checkpoints.length == 0) {\n', '            return _currentValue;\n', '        }\n', '        if (checkpoints[0].checkpointId >= _checkpointId) {\n', '            return checkpoints[0].value;\n', '        }\n', '        if (checkpoints[checkpoints.length - 1].checkpointId < _checkpointId) {\n', '            return _currentValue;\n', '        }\n', '        if (checkpoints[checkpoints.length - 1].checkpointId == _checkpointId) {\n', '            return checkpoints[checkpoints.length - 1].value;\n', '        }\n', '        uint256 min = 0;\n', '        uint256 max = checkpoints.length - 1;\n', '        while (max > min) {\n', '            uint256 mid = (max + min) / 2;\n', '            if (checkpoints[mid].checkpointId == _checkpointId) {\n', '                max = mid;\n', '                break;\n', '            }\n', '            if (checkpoints[mid].checkpointId < _checkpointId) {\n', '                min = mid + 1;\n', '            } else {\n', '                max = mid;\n', '            }\n', '        }\n', '        return checkpoints[max].value;\n', '    }\n', '\n', '    /**\n', '     * @notice Queries balances as of a defined checkpoint\n', '     * @param _investor Investor to query balance for\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256) {\n', '        return getValueAt(checkpointBalances[_investor], _checkpointId, balanceOf(_investor));\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath ticker registry contract\n', ' */\n', 'contract ITickerRegistry {\n', '    /**\n', '    * @notice Check the validity of the symbol\n', '    * @param _symbol token symbol\n', '    * @param _owner address of the owner\n', '    * @param _tokenName Name of the token\n', '    * @return bool\n', '    */\n', '    function checkValidity(string _symbol, address _owner, string _tokenName) public returns(bool);\n', '\n', '    /**\n', '    * @notice Returns the owner and timestamp for a given symbol\n', '    * @param _symbol symbol\n', '    */\n', '    function getDetails(string _symbol) public view returns (address, uint256, string, bytes32, bool);\n', '\n', '    /**\n', '     * @notice Check the symbol is reserved or not\n', '     * @param _symbol Symbol of the token\n', '     * @return bool\n', '     */\n', '     function isReserved(string _symbol, address _owner, string _tokenName, bytes32 _swarmHash) public returns(bool);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for security token proxy deployment\n', ' */\n', 'contract ISTProxy {\n', '\n', '    /**\n', '     * @notice deploys the token and adds default modules like permission manager and transfer manager.\n', '     * Future versions of the proxy can attach different modules or pass some other paramters.\n', '     */\n', '    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)\n', '        public returns (address);\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath security token registry contract\n', ' */\n', 'contract ISecurityTokenRegistry {\n', '\n', '    bytes32 public protocolVersion = "0.0.1";\n', '    mapping (bytes32 => address) public protocolVersionST;\n', '\n', '    struct SecurityTokenData {\n', '        string symbol;\n', '        string tokenDetails;\n', '    }\n', '\n', '    mapping(address => SecurityTokenData) securityTokens;\n', '    mapping(string => address) symbols;\n', '\n', '    /**\n', '     * @notice Creates a new Security Token and saves it to the registry\n', '     * @param _name Name of the token\n', '     * @param _symbol Ticker symbol of the security token\n', '     * @param _tokenDetails off-chain details of the token\n', '     */\n', '    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public;\n', '\n', '    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public;\n', '\n', '    /**\n', '     * @notice Get security token address by ticker name\n', '     * @param _symbol Symbol of the Scurity token\n', '     * @return address _symbol\n', '     */\n', '    function getSecurityTokenAddress(string _symbol) public view returns (address);\n', '\n', '     /**\n', '     * @notice Get security token data by its address\n', '     * @param _securityToken Address of the Scurity token\n', '     * @return string, address, bytes32\n', '     */\n', '    function getSecurityTokenData(address _securityToken) public view returns (string, address, string);\n', '\n', '    /**\n', '    * @notice Check that Security Token is registered\n', '    * @param _securityToken Address of the Scurity token\n', '    * @return bool\n', '    */\n', '    function isSecurityToken(address _securityToken) public view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Utility contract for reusable code\n', ' */\n', 'contract Util {\n', '\n', '   /**\n', '    * @notice changes a string to upper case\n', '    * @param _base string to change\n', '    */\n', '    function upper(string _base) internal pure returns (string) {\n', '        bytes memory _baseBytes = bytes(_base);\n', '        for (uint i = 0; i < _baseBytes.length; i++) {\n', '            bytes1 b1 = _baseBytes[i];\n', '            if (b1 >= 0x61 && b1 <= 0x7A) {\n', '                b1 = bytes1(uint8(b1)-32);\n', '            }\n', '            _baseBytes[i] = b1;\n', '        }\n', '        return string(_baseBytes);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Registry contract for issuers to register their security tokens\n', ' */\n', 'contract SecurityTokenRegistry is ISecurityTokenRegistry, Util, Pausable, RegistryUpdater, ReclaimTokens {\n', '\n', '    // Registration fee in POLY base 18 decimals\n', '    uint256 public registrationFee;\n', '    // Emit when changePolyRegisterationFee is called\n', '    event LogChangePolyRegisterationFee(uint256 _oldFee, uint256 _newFee);\n', '\n', '    // Emit at the time of launching of new security token\n', '    event LogNewSecurityToken(string _ticker, address indexed _securityTokenAddress, address indexed _owner);\n', '    event LogAddCustomSecurityToken(string _name, string _symbol, address _securityToken, uint256 _addedAt);\n', '\n', '    constructor (\n', '        address _polymathRegistry,\n', '        address _stVersionProxy,\n', '        uint256 _registrationFee\n', '    )\n', '    public\n', '    RegistryUpdater(_polymathRegistry)\n', '    {\n', '        registrationFee = _registrationFee;\n', '        // By default, the STR version is set to 0.0.1\n', '        setProtocolVersion(_stVersionProxy, "0.0.1");\n', '    }\n', '\n', '    /**\n', '     * @notice Creates a new Security Token and saves it to the registry\n', '     * @param _name Name of the token\n', '     * @param _symbol Ticker symbol of the security token\n', '     * @param _tokenDetails off-chain details of the token\n', '     * @param _divisible Set to true if token is divisible\n', '     */\n', '    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public whenNotPaused {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0, "Name and Symbol string length should be greater than 0");\n', '        require(ITickerRegistry(tickerRegistry).checkValidity(_symbol, msg.sender, _name), "Trying to use non-valid symbol");\n', '        if(registrationFee > 0)\n', '            require(ERC20(polyToken).transferFrom(msg.sender, this, registrationFee), "Failed transferFrom because of sufficent Allowance is not provided");\n', '        string memory symbol = upper(_symbol);\n', '        address newSecurityTokenAddress = ISTProxy(protocolVersionST[protocolVersion]).deployToken(\n', '            _name,\n', '            symbol,\n', '            18,\n', '            _tokenDetails,\n', '            msg.sender,\n', '            _divisible,\n', '            polymathRegistry\n', '        );\n', '\n', '        securityTokens[newSecurityTokenAddress] = SecurityTokenData(symbol, _tokenDetails);\n', '        symbols[symbol] = newSecurityTokenAddress;\n', '        emit LogNewSecurityToken(symbol, newSecurityTokenAddress, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Add a new custom (Token should follow the ISecurityToken interface) Security Token and saves it to the registry\n', '     * @param _name Name of the token\n', '     * @param _symbol Ticker symbol of the security token\n', '     * @param _owner Owner of the token\n', '     * @param _securityToken Address of the securityToken\n', '     * @param _tokenDetails off-chain details of the token\n', '     * @param _swarmHash off-chain details about the issuer company\n', '     */\n', '    function addCustomSecurityToken(string _name, string _symbol, address _owner, address _securityToken, string _tokenDetails, bytes32 _swarmHash) public onlyOwner whenNotPaused {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0, "Name and Symbol string length should be greater than 0");\n', '        string memory symbol = upper(_symbol);\n', '        require(_securityToken != address(0) && symbols[symbol] == address(0), "Symbol is already at the polymath network or entered security token address is 0x");\n', '        require(_owner != address(0));\n', '        require(!(ITickerRegistry(tickerRegistry).isReserved(symbol, _owner, _name, _swarmHash)), "Trying to use non-valid symbol");\n', '        symbols[symbol] = _securityToken;\n', '        securityTokens[_securityToken] = SecurityTokenData(symbol, _tokenDetails);\n', '        emit LogAddCustomSecurityToken(_name, symbol, _securityToken, now);\n', '    }\n', '\n', '    /**\n', '    * @notice Changes the protocol version and the SecurityToken contract\n', '    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\n', '    * @notice Changing versions does not affect existing tokens.\n', '    */\n', '    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public onlyOwner {\n', '        protocolVersion = _version;\n', '        protocolVersionST[_version] = _stVersionProxyAddress;\n', '    }\n', '\n', '    //////////////////////////////\n', '    ///////// Get Functions\n', '    //////////////////////////////\n', '    /**\n', '     * @notice Get security token address by ticker name\n', '     * @param _symbol Symbol of the Scurity token\n', '     * @return address\n', '     */\n', '    function getSecurityTokenAddress(string _symbol) public view returns (address) {\n', '        string memory __symbol = upper(_symbol);\n', '        return symbols[__symbol];\n', '    }\n', '\n', '     /**\n', '     * @notice Get security token data by its address\n', '     * @param _securityToken Address of the Scurity token\n', '     * @return string\n', '     * @return address\n', '     * @return string\n', '     */\n', '    function getSecurityTokenData(address _securityToken) public view returns (string, address, string) {\n', '        return (\n', '            securityTokens[_securityToken].symbol,\n', '            ISecurityToken(_securityToken).owner(),\n', '            securityTokens[_securityToken].tokenDetails\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice Check that Security Token is registered\n', '    * @param _securityToken Address of the Scurity token\n', '    * @return bool\n', '    */\n', '    function isSecurityToken(address _securityToken) public view returns (bool) {\n', '        return (keccak256(bytes(securityTokens[_securityToken].symbol)) != keccak256(""));\n', '    }\n', '\n', '    /**\n', '     * @notice set the ticker registration fee in POLY tokens\n', '     * @param _registrationFee registration fee in POLY tokens (base 18 decimals)\n', '     */\n', '    function changePolyRegisterationFee(uint256 _registrationFee) public onlyOwner {\n', '        require(registrationFee != _registrationFee);\n', '        emit LogChangePolyRegisterationFee(registrationFee, _registrationFee);\n', '        registrationFee = _registrationFee;\n', '    }\n', '\n', '     /**\n', '     * @notice pause registration function\n', '     */\n', '    function unpause() public onlyOwner  {\n', '        _unpause();\n', '    }\n', '\n', '    /**\n', '     * @notice unpause registration function\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Proxy for deploying Security Token v1\n', ' */\n', 'contract STVersionProxy001 is ISTProxy {\n', '\n', '    address public transferManagerFactory;\n', '\n', '    // Should be set to false when we have more TransferManager options\n', '    bool addTransferManager = true;\n', '\n', '    constructor (address _transferManagerFactory) public {\n', '        transferManagerFactory = _transferManagerFactory;\n', '    }\n', '\n', '    /**\n', '     * @notice deploys the token and adds default modules like permission manager and transfer manager.\n', '     * Future versions of the proxy can attach different modules or pass some other paramters.\n', '     */\n', '    function deployToken(string _name, string _symbol, uint8 _decimals, string _tokenDetails, address _issuer, bool _divisible, address _polymathRegistry)\n', '    public returns (address) {\n', '        address newSecurityTokenAddress = new SecurityToken(\n', '        _name,\n', '        _symbol,\n', '        _decimals,\n', '        _divisible ? 1 : uint256(10)**_decimals,\n', '        _tokenDetails,\n', '        _polymathRegistry\n', '        );\n', '\n', '        if (addTransferManager) {\n', '            SecurityToken(newSecurityTokenAddress).addModule(transferManagerFactory, "", 0, 0);\n', '        }\n', '\n', '        SecurityToken(newSecurityTokenAddress).transferOwnership(_issuer);\n', '\n', '        return newSecurityTokenAddress;\n', '    }\n', '}']