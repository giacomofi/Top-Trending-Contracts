['/** @title Onasander Token Contract\n', '*   \n', '*   @author: Andrzej Wegrzyn\n', '*   Contact: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e6828390838a89968b838892a6898887958788828394c885898b">[email&#160;protected]</a>\n', '*   Date: May 5, 2018\n', '*   Location: New York, USA\n', '*   Token: Onasander\n', '*   Symbol: ONA\n', '*   \n', '*   @notice This is a simple contract due to solidity bugs and complications. \n', '*\n', '*   @notice Owner has the option to burn all the remaining tokens after the ICO.  That way Owners will not end up with majority of the tokens.\n', '*   @notice Onasander would love to give every user the option to burn the remaining tokens, but due to Solidity VM bugs and risk, we will process\n', '*   @notice all coin burns and refunds manually.\n', '*   \n', '*   @notice How to run the contract:\n', '*\n', '*   Requires:\n', '*   Wallet Address\n', '*\n', '*   Run:\n', '*   1. Create Contract\n', '*   2. Set Minimum Goal\n', '*   3. Set Tokens Per ETH\n', '*   4. Create PRE ICO Sale (can have multiple PRE-ICOs)\n', '*   5. End PRE ICO Sale\n', '*   6. Create ICO Sale\n', '*   7. End ICO Sale\n', '*   8. END ICO\n', '*   9. Burn Remaining Tokens\n', '*\n', '*   e18 for every value except tokens per ETH\n', '*   \n', '*   @dev This contract allows you to configure as many Pre-ICOs as you need.  It&#39;s a very simple contract written to give contract admin lots of dynamic options.\n', '*   @dev Here, most features except for total supply, max tokens for sale, company reserves, and token standard features, are dynamic.  You can configure your contract\n', '*   @dev however you want to.  \n', '*\n', '*   @dev IDE: Remix with Mist 0.10\n', '*   @dev Token supply numbers are provided in 0e18 format in MIST in order to bypass MIST number format errors.\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract OnasanderToken\n', '{\n', '    using SafeMath for uint;\n', '    \n', '    address private wallet;                                // Address where funds are collected\n', '    address public owner;                                  // contract owner\n', '    string constant public name = "Onasander";\n', '    string constant public symbol = "ONA";\n', '    uint8 constant public decimals = 18;\n', '    uint public totalSupply = 88000000e18;                       \n', '    uint public totalTokensSold = 0e18;                    // total number of tokens sold to date\n', '    uint public totalTokensSoldInThisSale = 0e18;          // total number of tokens sold in this sale\n', '    uint public maxTokensForSale = 79200000e18;            // 90%  max tokens we can ever sale  \n', '    uint public companyReserves = 8800000e18;              // 10%  company reserves. this is what we end up with after eco ends and burns the rest if any  \n', '    uint public minimumGoal = 0e18;                        // hold minimum goal\n', '    uint public tokensForSale = 0e18;                      // total number of tokens we are selling in the current sale (ICO, preICO)\n', '    bool public saleEnabled = false;                       // enables all sales: ICO and tokensPreICO\n', '    bool public ICOEnded = false;                          // flag checking if the ICO has completed\n', '    bool public burned = false;                            // Excess tokens burned flag after ICO ends\n', '    uint public tokensPerETH = 800;                        // amount of Onasander tokens you get for 1 ETH\n', '    bool public wasGoalReached = false;                    // checks if minimum goal was reached\n', '    address private lastBuyer;\n', '    uint private singleToken = 1e18;\n', '\n', '    constructor(address icoWallet) public \n', '    {   \n', '        require(icoWallet != address(0), "ICO Wallet address is required.");\n', '\n', '        owner = msg.sender;\n', '        wallet = icoWallet;\n', '        balances[owner] = totalSupply;  // give initial full balance to contract owner\n', '        emit TokensMinted(owner, totalSupply);        \n', '    }\n', '\n', '    event ICOHasEnded();\n', '    event SaleEnded();\n', '    event OneTokenBugFixed();\n', '    event ICOConfigured(uint minimumGoal);\n', '    event TokenPerETHReset(uint amount);\n', '    event ICOCapReached(uint amount);\n', '    event SaleCapReached(uint amount);\n', '    event GoalReached(uint amount);\n', '    event Burned(uint amount);    \n', '    event BuyTokens(address buyer, uint tokens);\n', '    event SaleStarted(uint tokensForSale);    \n', '    event TokensMinted(address targetAddress, uint tokens);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint tokens);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    mapping(address => uint) balances;\n', '    \n', '    mapping(address => mapping (address => uint)) allowances;\n', '\n', '    function balanceOf(address accountAddress) public constant returns (uint balance)\n', '    {\n', '        return balances[accountAddress];\n', '    }\n', '\n', '    function allowance(address sender, address spender) public constant returns (uint remainingAllowedAmount)\n', '    {\n', '        return allowances[sender][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success)\n', '    {     \n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");\n', '        require (balances[to] + tokens > balances[to], "Overflow is not allowed.");\n', '\n', '        // actual transfer\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        \n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns(bool success) \n', '    {\n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");\n', '        require (balances[to] + tokens > balances[to], "Overflow is not allowed.");\n', '\n', '        // actual transfer\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowances[from][msg.sender] = allowances[from][msg.sender].sub(tokens); // lower the allowance by the amount of tokens \n', '        balances[to] = balances[to].add(tokens);\n', '        \n', '        emit Transfer(from, to, tokens);        \n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns(bool success) \n', '    {          \n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");      \n', '        allowances[msg.sender][spender] = tokens;                \n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '        // in case some investor pays by wire or credit card we will transfer him the tokens manually.\n', '    function wirePurchase(address to, uint numberOfTokenPurchased) onlyOwner public\n', '    {     \n', '        require (saleEnabled, "Sale must be enabled.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (numberOfTokenPurchased > 0, "Tokens must be greater than 0.");\n', '        require (tokensForSale > totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");\n', '                        \n', '        // calculate amount\n', '        uint buyAmount = numberOfTokenPurchased;\n', '        uint tokens = 0e18;\n', '\n', '        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\n', '        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \n', '        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\n', '        {\n', '            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\n', '            // need to program the refund for the rest,or do it manually.  \n', '        }\n', '        else\n', '        {\n', '            tokens = buyAmount;\n', '        }\n', '\n', '        // transfer only as we do not need to take the payment since we already did in wire\n', '        require (balances[to].add(tokens) > balances[to], "Overflow is not allowed.");\n', '        balances[to] = balances[to].add(tokens);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        lastBuyer = to;\n', '\n', '        // update counts\n', '        totalTokensSold = totalTokensSold.add(tokens);\n', '        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\n', '        \n', '        emit BuyTokens(to, tokens);\n', '        emit Transfer(owner, to, tokens);\n', '\n', '        isGoalReached();\n', '        isMaxCapReached();\n', '    }\n', '\n', '    function buyTokens() payable public\n', '    {        \n', '        require (saleEnabled, "Sale must be enabled.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (tokensForSale > totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");\n', '        require (msg.value > 0, "Must send ETH");\n', '\n', '        // calculate amount\n', '        uint buyAmount = SafeMath.mul(msg.value, tokensPerETH);\n', '        uint tokens = 0e18;\n', '\n', '        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\n', '        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \n', '        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\n', '        {\n', '            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\n', '\n', '            // need to program the refund for the rest\n', '        }\n', '        else\n', '        {\n', '            tokens = buyAmount;\n', '        }\n', '\n', '        // buy\n', '        require (balances[msg.sender].add(tokens) > balances[msg.sender], "Overflow is not allowed.");\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        lastBuyer = msg.sender;\n', '\n', '        // take the money out right away\n', '        wallet.transfer(msg.value);\n', '\n', '        // update counts\n', '        totalTokensSold = totalTokensSold.add(tokens);\n', '        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\n', '        \n', '        emit BuyTokens(msg.sender, tokens);\n', '        emit Transfer(owner, msg.sender, tokens);\n', '\n', '        isGoalReached();\n', '        isMaxCapReached();\n', '    }\n', '\n', '    // Fallback function. Used for buying tokens from contract owner by simply\n', '    // sending Ethers to contract.\n', '    function() public payable \n', '    {\n', '        // we buy tokens using whatever ETH was sent in\n', '        buyTokens();\n', '    }\n', '\n', '    // Called when ICO is closed. Burns the remaining tokens except the tokens reserved\n', '    // Must be called by the owner to trigger correct transfer event\n', '    function burnRemainingTokens() public onlyOwner\n', '    {\n', '        require (!burned, "Remaining tokens have been burned already.");\n', '        require (ICOEnded, "ICO has not ended yet.");\n', '\n', '        uint difference = balances[owner].sub(companyReserves); \n', '\n', '        if (wasGoalReached)\n', '        {\n', '            totalSupply = totalSupply.sub(difference);\n', '            balances[owner] = companyReserves;\n', '        }\n', '        else\n', '        {\n', '            // in case we did not reach the goal, we burn all tokens except tokens purchased.\n', '            totalSupply = totalTokensSold;\n', '            balances[owner] = 0e18;\n', '        }\n', '\n', '        burned = true;\n', '\n', '        emit Transfer(owner, address(0), difference);    // this is run in order to update token holders in the website\n', '        emit Burned(difference);        \n', '    }\n', '\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public\n', '    {\n', '        address preOwner = owner;        \n', '        owner = newOwner;\n', '\n', '        uint previousBalance = balances[preOwner];\n', '\n', '        // transfer balance \n', '        balances[newOwner] = balances[newOwner].add(previousBalance);\n', '        balances[preOwner] = 0;\n', '\n', '        //emit Transfer(preOwner, newOwner, previousBalance); // required to update the Token Holders on the network\n', '        emit OwnershipTransferred(preOwner, newOwner, previousBalance);\n', '    }\n', '\n', '    // Set the number of ONAs sold per ETH \n', '    function setTokensPerETH(uint newRate) onlyOwner public\n', '    {\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (newRate > 0, "Rate must be higher than 0.");\n', '        tokensPerETH = newRate;\n', '        emit TokenPerETHReset(newRate);\n', '    }\n', '\n', '    // Minimum goal is based on USD, not on ETH. Since we will have different dynamic prices based on the daily pirce of ETH, we\n', '    // will need to be able to adjust our minimum goal in tokens sold, as our goal is set in tokens, not USD.\n', '    function setMinimumGoal(uint goal) onlyOwner public\n', '    {   \n', '        require(goal > 0e18,"Minimum goal must be greater than 0.");\n', '        minimumGoal = goal;\n', '\n', '        // since we can edit the goal, we want to check if we reached the goal before in case we lowered the goal number.\n', '        isGoalReached();\n', '\n', '        emit ICOConfigured(goal);\n', '    }\n', '\n', '    function createSale(uint numberOfTokens) onlyOwner public\n', '    {\n', '        require (!saleEnabled, "Sale is already going on.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (totalTokensSold < maxTokensForSale, "We already sold all our tokens.");\n', '\n', '        totalTokensSoldInThisSale = 0e18;\n', '        uint tryingToSell = totalTokensSold.add(numberOfTokens);\n', '\n', '        // in case we are trying to create a sale with too many tokens, we subtract and sell only what&#39;s left\n', '        if (tryingToSell > maxTokensForSale)\n', '        {\n', '            tokensForSale = maxTokensForSale.sub(totalTokensSold); \n', '        }\n', '        else\n', '        {\n', '            tokensForSale = numberOfTokens;\n', '        }\n', '\n', '        tryingToSell = 0e18;\n', '        saleEnabled = true;\n', '        emit SaleStarted(tokensForSale);\n', '    }\n', '\n', '    function endSale() public\n', '    {\n', '        if (saleEnabled)\n', '        {\n', '            saleEnabled = false;\n', '            tokensForSale = 0e18;\n', '            emit SaleEnded();\n', '        }\n', '    }\n', '\n', '    function endICO() onlyOwner public\n', '    {\n', '        if (!ICOEnded)\n', '        {\n', '            // run this before end of ICO and end of last sale            \n', '            fixTokenCalcBug();\n', '\n', '            endSale();\n', '\n', '            ICOEnded = true;            \n', '            lastBuyer = address(0);\n', '            \n', '            emit ICOHasEnded();\n', '        }\n', '    }\n', '\n', '    function isGoalReached() internal\n', '    {\n', '        // check if we reached the goal\n', '        if (!wasGoalReached)\n', '        {\n', '            if (totalTokensSold >= minimumGoal)\n', '            {\n', '                wasGoalReached = true;\n', '                emit GoalReached(minimumGoal);\n', '            }\n', '        }\n', '    }\n', '\n', '    function isMaxCapReached() internal\n', '    {\n', '        if (totalTokensSoldInThisSale >= tokensForSale)\n', '        {            \n', '            emit SaleCapReached(totalTokensSoldInThisSale);\n', '            endSale();\n', '        }\n', '\n', '        if (totalTokensSold >= maxTokensForSale)\n', '        {            \n', '            emit ICOCapReached(maxTokensForSale);\n', '            endICO();\n', '        }\n', '    }\n', '\n', '    // This is a hack to add the lost token during final full sale. \n', '    function fixTokenCalcBug() internal\n', '    {        \n', '        require(!burned, "Fix lost token can only run before the burning of the tokens.");        \n', '        \n', '        if (maxTokensForSale.sub(totalTokensSold) == singleToken)\n', '        {\n', '            totalTokensSold = totalTokensSold.add(singleToken);\n', '            totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(singleToken);\n', '            \n', '            balances[lastBuyer] = balances[lastBuyer].add(singleToken);\n', '            balances[owner] = balances[owner].sub(singleToken);\n', '\n', '            emit Transfer(owner, lastBuyer, singleToken);\n', '            emit OneTokenBugFixed();\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['/** @title Onasander Token Contract\n', '*   \n', '*   @author: Andrzej Wegrzyn\n', '*   Contact: development@onasander.com\n', '*   Date: May 5, 2018\n', '*   Location: New York, USA\n', '*   Token: Onasander\n', '*   Symbol: ONA\n', '*   \n', '*   @notice This is a simple contract due to solidity bugs and complications. \n', '*\n', '*   @notice Owner has the option to burn all the remaining tokens after the ICO.  That way Owners will not end up with majority of the tokens.\n', '*   @notice Onasander would love to give every user the option to burn the remaining tokens, but due to Solidity VM bugs and risk, we will process\n', '*   @notice all coin burns and refunds manually.\n', '*   \n', '*   @notice How to run the contract:\n', '*\n', '*   Requires:\n', '*   Wallet Address\n', '*\n', '*   Run:\n', '*   1. Create Contract\n', '*   2. Set Minimum Goal\n', '*   3. Set Tokens Per ETH\n', '*   4. Create PRE ICO Sale (can have multiple PRE-ICOs)\n', '*   5. End PRE ICO Sale\n', '*   6. Create ICO Sale\n', '*   7. End ICO Sale\n', '*   8. END ICO\n', '*   9. Burn Remaining Tokens\n', '*\n', '*   e18 for every value except tokens per ETH\n', '*   \n', "*   @dev This contract allows you to configure as many Pre-ICOs as you need.  It's a very simple contract written to give contract admin lots of dynamic options.\n", '*   @dev Here, most features except for total supply, max tokens for sale, company reserves, and token standard features, are dynamic.  You can configure your contract\n', '*   @dev however you want to.  \n', '*\n', '*   @dev IDE: Remix with Mist 0.10\n', '*   @dev Token supply numbers are provided in 0e18 format in MIST in order to bypass MIST number format errors.\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract OnasanderToken\n', '{\n', '    using SafeMath for uint;\n', '    \n', '    address private wallet;                                // Address where funds are collected\n', '    address public owner;                                  // contract owner\n', '    string constant public name = "Onasander";\n', '    string constant public symbol = "ONA";\n', '    uint8 constant public decimals = 18;\n', '    uint public totalSupply = 88000000e18;                       \n', '    uint public totalTokensSold = 0e18;                    // total number of tokens sold to date\n', '    uint public totalTokensSoldInThisSale = 0e18;          // total number of tokens sold in this sale\n', '    uint public maxTokensForSale = 79200000e18;            // 90%  max tokens we can ever sale  \n', '    uint public companyReserves = 8800000e18;              // 10%  company reserves. this is what we end up with after eco ends and burns the rest if any  \n', '    uint public minimumGoal = 0e18;                        // hold minimum goal\n', '    uint public tokensForSale = 0e18;                      // total number of tokens we are selling in the current sale (ICO, preICO)\n', '    bool public saleEnabled = false;                       // enables all sales: ICO and tokensPreICO\n', '    bool public ICOEnded = false;                          // flag checking if the ICO has completed\n', '    bool public burned = false;                            // Excess tokens burned flag after ICO ends\n', '    uint public tokensPerETH = 800;                        // amount of Onasander tokens you get for 1 ETH\n', '    bool public wasGoalReached = false;                    // checks if minimum goal was reached\n', '    address private lastBuyer;\n', '    uint private singleToken = 1e18;\n', '\n', '    constructor(address icoWallet) public \n', '    {   \n', '        require(icoWallet != address(0), "ICO Wallet address is required.");\n', '\n', '        owner = msg.sender;\n', '        wallet = icoWallet;\n', '        balances[owner] = totalSupply;  // give initial full balance to contract owner\n', '        emit TokensMinted(owner, totalSupply);        \n', '    }\n', '\n', '    event ICOHasEnded();\n', '    event SaleEnded();\n', '    event OneTokenBugFixed();\n', '    event ICOConfigured(uint minimumGoal);\n', '    event TokenPerETHReset(uint amount);\n', '    event ICOCapReached(uint amount);\n', '    event SaleCapReached(uint amount);\n', '    event GoalReached(uint amount);\n', '    event Burned(uint amount);    \n', '    event BuyTokens(address buyer, uint tokens);\n', '    event SaleStarted(uint tokensForSale);    \n', '    event TokensMinted(address targetAddress, uint tokens);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint tokens);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '    mapping(address => uint) balances;\n', '    \n', '    mapping(address => mapping (address => uint)) allowances;\n', '\n', '    function balanceOf(address accountAddress) public constant returns (uint balance)\n', '    {\n', '        return balances[accountAddress];\n', '    }\n', '\n', '    function allowance(address sender, address spender) public constant returns (uint remainingAllowedAmount)\n', '    {\n', '        return allowances[sender][spender];\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success)\n', '    {     \n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");\n', '        require (balances[to] + tokens > balances[to], "Overflow is not allowed.");\n', '\n', '        // actual transfer\n', '        // SafeMath.sub will throw if there is not enough balance.\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        \n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns(bool success) \n', '    {\n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");\n', '        require (balances[to] + tokens > balances[to], "Overflow is not allowed.");\n', '\n', '        // actual transfer\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowances[from][msg.sender] = allowances[from][msg.sender].sub(tokens); // lower the allowance by the amount of tokens \n', '        balances[to] = balances[to].add(tokens);\n', '        \n', '        emit Transfer(from, to, tokens);        \n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint tokens) public returns(bool success) \n', '    {          \n', '        require (ICOEnded, "ICO has not ended.  Can not transfer.");      \n', '        allowances[msg.sender][spender] = tokens;                \n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '        // in case some investor pays by wire or credit card we will transfer him the tokens manually.\n', '    function wirePurchase(address to, uint numberOfTokenPurchased) onlyOwner public\n', '    {     \n', '        require (saleEnabled, "Sale must be enabled.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (numberOfTokenPurchased > 0, "Tokens must be greater than 0.");\n', '        require (tokensForSale > totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");\n', '                        \n', '        // calculate amount\n', '        uint buyAmount = numberOfTokenPurchased;\n', '        uint tokens = 0e18;\n', '\n', '        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\n', '        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \n', '        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\n', '        {\n', '            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\n', '            // need to program the refund for the rest,or do it manually.  \n', '        }\n', '        else\n', '        {\n', '            tokens = buyAmount;\n', '        }\n', '\n', '        // transfer only as we do not need to take the payment since we already did in wire\n', '        require (balances[to].add(tokens) > balances[to], "Overflow is not allowed.");\n', '        balances[to] = balances[to].add(tokens);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        lastBuyer = to;\n', '\n', '        // update counts\n', '        totalTokensSold = totalTokensSold.add(tokens);\n', '        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\n', '        \n', '        emit BuyTokens(to, tokens);\n', '        emit Transfer(owner, to, tokens);\n', '\n', '        isGoalReached();\n', '        isMaxCapReached();\n', '    }\n', '\n', '    function buyTokens() payable public\n', '    {        \n', '        require (saleEnabled, "Sale must be enabled.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (tokensForSale > totalTokensSoldInThisSale, "There is no more tokens for sale in this sale.");\n', '        require (msg.value > 0, "Must send ETH");\n', '\n', '        // calculate amount\n', '        uint buyAmount = SafeMath.mul(msg.value, tokensPerETH);\n', '        uint tokens = 0e18;\n', '\n', '        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\n', '        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \n', '        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\n', '        {\n', '            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\n', '\n', '            // need to program the refund for the rest\n', '        }\n', '        else\n', '        {\n', '            tokens = buyAmount;\n', '        }\n', '\n', '        // buy\n', '        require (balances[msg.sender].add(tokens) > balances[msg.sender], "Overflow is not allowed.");\n', '        balances[msg.sender] = balances[msg.sender].add(tokens);\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        lastBuyer = msg.sender;\n', '\n', '        // take the money out right away\n', '        wallet.transfer(msg.value);\n', '\n', '        // update counts\n', '        totalTokensSold = totalTokensSold.add(tokens);\n', '        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\n', '        \n', '        emit BuyTokens(msg.sender, tokens);\n', '        emit Transfer(owner, msg.sender, tokens);\n', '\n', '        isGoalReached();\n', '        isMaxCapReached();\n', '    }\n', '\n', '    // Fallback function. Used for buying tokens from contract owner by simply\n', '    // sending Ethers to contract.\n', '    function() public payable \n', '    {\n', '        // we buy tokens using whatever ETH was sent in\n', '        buyTokens();\n', '    }\n', '\n', '    // Called when ICO is closed. Burns the remaining tokens except the tokens reserved\n', '    // Must be called by the owner to trigger correct transfer event\n', '    function burnRemainingTokens() public onlyOwner\n', '    {\n', '        require (!burned, "Remaining tokens have been burned already.");\n', '        require (ICOEnded, "ICO has not ended yet.");\n', '\n', '        uint difference = balances[owner].sub(companyReserves); \n', '\n', '        if (wasGoalReached)\n', '        {\n', '            totalSupply = totalSupply.sub(difference);\n', '            balances[owner] = companyReserves;\n', '        }\n', '        else\n', '        {\n', '            // in case we did not reach the goal, we burn all tokens except tokens purchased.\n', '            totalSupply = totalTokensSold;\n', '            balances[owner] = 0e18;\n', '        }\n', '\n', '        burned = true;\n', '\n', '        emit Transfer(owner, address(0), difference);    // this is run in order to update token holders in the website\n', '        emit Burned(difference);        \n', '    }\n', '\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public\n', '    {\n', '        address preOwner = owner;        \n', '        owner = newOwner;\n', '\n', '        uint previousBalance = balances[preOwner];\n', '\n', '        // transfer balance \n', '        balances[newOwner] = balances[newOwner].add(previousBalance);\n', '        balances[preOwner] = 0;\n', '\n', '        //emit Transfer(preOwner, newOwner, previousBalance); // required to update the Token Holders on the network\n', '        emit OwnershipTransferred(preOwner, newOwner, previousBalance);\n', '    }\n', '\n', '    // Set the number of ONAs sold per ETH \n', '    function setTokensPerETH(uint newRate) onlyOwner public\n', '    {\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (newRate > 0, "Rate must be higher than 0.");\n', '        tokensPerETH = newRate;\n', '        emit TokenPerETHReset(newRate);\n', '    }\n', '\n', '    // Minimum goal is based on USD, not on ETH. Since we will have different dynamic prices based on the daily pirce of ETH, we\n', '    // will need to be able to adjust our minimum goal in tokens sold, as our goal is set in tokens, not USD.\n', '    function setMinimumGoal(uint goal) onlyOwner public\n', '    {   \n', '        require(goal > 0e18,"Minimum goal must be greater than 0.");\n', '        minimumGoal = goal;\n', '\n', '        // since we can edit the goal, we want to check if we reached the goal before in case we lowered the goal number.\n', '        isGoalReached();\n', '\n', '        emit ICOConfigured(goal);\n', '    }\n', '\n', '    function createSale(uint numberOfTokens) onlyOwner public\n', '    {\n', '        require (!saleEnabled, "Sale is already going on.");\n', '        require (!ICOEnded, "ICO already ended.");\n', '        require (totalTokensSold < maxTokensForSale, "We already sold all our tokens.");\n', '\n', '        totalTokensSoldInThisSale = 0e18;\n', '        uint tryingToSell = totalTokensSold.add(numberOfTokens);\n', '\n', "        // in case we are trying to create a sale with too many tokens, we subtract and sell only what's left\n", '        if (tryingToSell > maxTokensForSale)\n', '        {\n', '            tokensForSale = maxTokensForSale.sub(totalTokensSold); \n', '        }\n', '        else\n', '        {\n', '            tokensForSale = numberOfTokens;\n', '        }\n', '\n', '        tryingToSell = 0e18;\n', '        saleEnabled = true;\n', '        emit SaleStarted(tokensForSale);\n', '    }\n', '\n', '    function endSale() public\n', '    {\n', '        if (saleEnabled)\n', '        {\n', '            saleEnabled = false;\n', '            tokensForSale = 0e18;\n', '            emit SaleEnded();\n', '        }\n', '    }\n', '\n', '    function endICO() onlyOwner public\n', '    {\n', '        if (!ICOEnded)\n', '        {\n', '            // run this before end of ICO and end of last sale            \n', '            fixTokenCalcBug();\n', '\n', '            endSale();\n', '\n', '            ICOEnded = true;            \n', '            lastBuyer = address(0);\n', '            \n', '            emit ICOHasEnded();\n', '        }\n', '    }\n', '\n', '    function isGoalReached() internal\n', '    {\n', '        // check if we reached the goal\n', '        if (!wasGoalReached)\n', '        {\n', '            if (totalTokensSold >= minimumGoal)\n', '            {\n', '                wasGoalReached = true;\n', '                emit GoalReached(minimumGoal);\n', '            }\n', '        }\n', '    }\n', '\n', '    function isMaxCapReached() internal\n', '    {\n', '        if (totalTokensSoldInThisSale >= tokensForSale)\n', '        {            \n', '            emit SaleCapReached(totalTokensSoldInThisSale);\n', '            endSale();\n', '        }\n', '\n', '        if (totalTokensSold >= maxTokensForSale)\n', '        {            \n', '            emit ICOCapReached(maxTokensForSale);\n', '            endICO();\n', '        }\n', '    }\n', '\n', '    // This is a hack to add the lost token during final full sale. \n', '    function fixTokenCalcBug() internal\n', '    {        \n', '        require(!burned, "Fix lost token can only run before the burning of the tokens.");        \n', '        \n', '        if (maxTokensForSale.sub(totalTokensSold) == singleToken)\n', '        {\n', '            totalTokensSold = totalTokensSold.add(singleToken);\n', '            totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(singleToken);\n', '            \n', '            balances[lastBuyer] = balances[lastBuyer].add(singleToken);\n', '            balances[owner] = balances[owner].sub(singleToken);\n', '\n', '            emit Transfer(owner, lastBuyer, singleToken);\n', '            emit OneTokenBugFixed();\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
