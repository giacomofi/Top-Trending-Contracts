['/**\n', ' * Copyright (C) 2017-2018 Hashfuture Inc. All rights reserved.\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ownable {\n', '    address public owner;\n', '\n', '    function ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * The signature mechanism to enhance the credibility of the token.\n', ' * The sign process is asychronous.\n', ' * After the creation of the contract, one who verifies the contract and\n', ' * is willing to guarantee for it can sign the contract address.\n', ' */\n', 'contract verifiable {\n', '\n', '    struct Signature {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    /**\n', '     * signatures\n', '     * Used to verify that if the contract is protected\n', '     * By hashworld or other publicly verifiable organizations\n', '     */\n', '    mapping(address => Signature) public signatures;\n', '\n', '    /**\n', '     * sign Token\n', '     */\n', '    function sign(uint8 v, bytes32 r, bytes32 s) public {\n', '        signatures[msg.sender] = Signature(v, r, s);\n', '    }\n', '\n', '    /**\n', "     * To verify whether a specific signer has signed this contract's address\n", '     * @param signer address to verify\n', '     */\n', '    function verify(address signer) public constant returns(bool) {\n', '        bytes32 hash = keccak256(abi.encodePacked(address(this)));\n', '        Signature storage sig = signatures[signer];\n', '        return ecrecover(hash, sig.v, sig.r, sig.s) == signer;\n', '    }\n', '}\n', '\n', 'contract AssetHashToken is ownable, verifiable{\n', '    using SafeMath for uint;\n', '\n', '    //Asset Struct\n', '    struct data {\n', '        // link URL of the original information for storing data; null means undisclosed\n', '        string link;\n', '        // The hash type of the original data, such as SHA-256\n', '        string hashType;\n', '        // Hash value of the agreed content.\n', '        string hashValue;\n', '    }\n', '\n', '    data public assetFile;\n', '    data public legalFile;\n', '\n', '    //The token id\n', '    uint id;\n', '\n', '    //The validity of the contract\n', '    bool public isValid;\n', '\n', '    //The splitting status of the asset\n', '    //Set to true if the asset has been splitted to small tokens\n', '    bool public isSplitted;\n', '\n', '    // The tradeable status of asset\n', '    // Leave (together with assetPrice) for auto buy and sell functionality (with Ether).\n', '    bool public isTradable;\n', '\n', '    /**\n', '     * The price of asset\n', '     * if the contract is valid and tradeable,\n', '     * others can get asset by transfer assetPrice ETH to contract\n', '     */\n', '    uint public assetPrice;\n', '\n', '    //Some addtional notes\n', '    string public remark1;\n', '    string public remark2;\n', '\n', '    mapping (address => uint) pendingWithdrawals;\n', '\n', '    /**\n', '     * The asset update events\n', '     */\n', '    event TokenUpdateEvent (\n', '        uint id,\n', '        bool isValid,\n', '        bool isTradable,\n', '        address owner,\n', '        uint assetPrice,\n', '        string assetFileLink,\n', '        string legalFileLink\n', '    );\n', '\n', '    modifier onlyUnsplitted {\n', '        require(isSplitted == false, "This function can be called only under unsplitted status");\n', '        _;\n', '    }\n', '\n', '    modifier onlyValid {\n', '        require(isValid == true, "Contract is invaild!");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * constructor\n', '     * @param _id Token id\n', '     * @param _owner initial owner\n', '     * @param _assetPrice The price of asset\n', '     * @param _assetFileUrl The url of asset file\n', '     * @param _assetFileHashType The hash type of asset file\n', '     * @param _assetFileHashValue The hash value of asset file\n', '     * @param _legalFileUrl The url of legal file\n', '     * @param _legalFileHashType The hash type of legal file\n', '     * @param _legalFileHashValue The hash value of legal file\n', '     */\n', '    constructor(\n', '        uint _id,\n', '        address _owner,\n', '        uint _assetPrice,\n', '        string _assetFileUrl,\n', '        string _assetFileHashType,\n', '        string _assetFileHashValue,\n', '        string _legalFileUrl,\n', '        string _legalFileHashType,\n', '        string _legalFileHashValue\n', '        ) public {\n', '\n', '        id = _id;\n', '        owner = _owner;\n', '\n', '        assetPrice = _assetPrice;\n', '\n', '        initAssetFile(\n', '            _assetFileUrl, _assetFileHashType, _assetFileHashValue, _legalFileUrl, _legalFileHashType, _legalFileHashValue);\n', '\n', '        isValid = true;\n', '        isSplitted = false;\n', '        isTradable = false;\n', '    }\n', '\n', '    /**\n', '     * Initialize asset file and legal file\n', '     * @param _assetFileUrl The url of asset file\n', '     * @param _assetFileHashType The hash type of asset file\n', '     * @param _assetFileHashValue The hash value of asset file\n', '     * @param _legalFileUrl The url of legal file\n', '     * @param _legalFileHashType The hash type of legal file\n', '     * @param _legalFileHashValue The hash value of legal file\n', '     */\n', '    function initAssetFile(\n', '        string _assetFileUrl,\n', '        string _assetFileHashType,\n', '        string _assetFileHashValue,\n', '        string _legalFileUrl,\n', '        string _legalFileHashType,\n', '        string _legalFileHashValue\n', '        ) internal {\n', '        assetFile = data(\n', '            _assetFileUrl, _assetFileHashType, _assetFileHashValue);\n', '        legalFile = data(\n', '            _legalFileUrl, _legalFileHashType, _legalFileHashValue);\n', '    }\n', '\n', '     /**\n', '     * Get base asset info\n', '     */\n', '    function getAssetBaseInfo() public view onlyValid\n', '        returns (\n', '            uint _id,\n', '            uint _assetPrice,\n', '            bool _isTradable,\n', '            string _remark1,\n', '            string _remark2\n', '        )\n', '    {\n', '        _id = id;\n', '        _assetPrice = assetPrice;\n', '        _isTradable = isTradable;\n', '\n', '        _remark1 = remark1;\n', '        _remark2 = remark2;\n', '    }\n', '\n', '    /**\n', '     * set the price of asset\n', '     * @param newAssetPrice new price of asset\n', '     * Only can be called by owner\n', '     */\n', '    function setassetPrice(uint newAssetPrice)\n', '        public\n', '        onlyOwner\n', '        onlyValid\n', '        onlyUnsplitted\n', '    {\n', '        assetPrice = newAssetPrice;\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '    /**\n', '     * set the tradeable status of asset\n', '     * @param status status of isTradable\n', '     * Only can be called by owner\n', '     */\n', '    function setTradeable(bool status) public onlyOwner onlyValid onlyUnsplitted {\n', '        isTradable = status;\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '    /**\n', '     * set the remark1\n', '     * @param content new content of remark1\n', '     * Only can be called by owner\n', '     */\n', '    function setRemark1(string content) public onlyOwner onlyValid onlyUnsplitted {\n', '        remark1 = content;\n', '    }\n', '\n', '    /**\n', '     * set the remark2\n', '     * @param content new content of remark2\n', '     * Only can be called by owner\n', '     */\n', '    function setRemark2(string content) public onlyOwner onlyValid onlyUnsplitted {\n', '        remark2 = content;\n', '    }\n', '\n', '    /**\n', '     * Modify the link of the asset file\n', '     * @param url new link\n', '     * Only can be called by owner\n', '     */\n', '    function setAssetFileLink(string url) public\n', '        onlyOwner\n', '        onlyValid\n', '        onlyUnsplitted\n', '    {\n', '        assetFile.link = url;\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Modify the link of the legal file\n', '     * @param url new link\n', '     * Only can be called by owner\n', '     */\n', '    function setLegalFileLink(string url)\n', '        public\n', '        onlyOwner\n', '        onlyValid\n', '        onlyUnsplitted\n', '    {\n', '        legalFile.link = url;\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '    /**\n', '     * cancel contract\n', '     * Only can be called by owner\n', '     */\n', '    function cancelContract() public onlyOwner onlyValid onlyUnsplitted {\n', '        isValid = false;\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '    /**\n', '     * overwrite the transferOwnership interface in ownable.\n', '     * Only can transfer when the token is not splitted into small keys.\n', '     * After transfer, the token should be set in "no trading" status.\n', '     */\n', '    function transferOwnership(address newowner) public onlyOwner onlyValid onlyUnsplitted {\n', '        owner = newowner;\n', '        isTradable = false;  // set to false for new owner\n', '\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '    }\n', '\n', '\n', '    /**\n', '     * Buy asset\n', '     */\n', '    function buy() public payable onlyValid onlyUnsplitted {\n', '        require(isTradable == true, "contract is tradeable");\n', '        require(msg.value >= assetPrice, "assetPrice not match");\n', '        address origin_owner = owner;\n', '\n', '        owner = msg.sender;\n', '        isTradable = false;  // set to false for new owner\n', '\n', '        emit TokenUpdateEvent (\n', '            id,\n', '            isValid,\n', '            isTradable,\n', '            owner,\n', '            assetPrice,\n', '            assetFile.link,\n', '            legalFile.link\n', '        );\n', '\n', '        uint priviousBalance = pendingWithdrawals[origin_owner];\n', '        pendingWithdrawals[origin_owner] = priviousBalance.add(assetPrice);\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint amount = pendingWithdrawals[msg.sender];\n', '\n', '        // Remember to zero the pending refund before sending to prevent re-entrancy attacks\n', '        pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * Standard ERC 20 interface.\n', ' */\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract DividableAsset is AssetHashToken, ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    ERC20Interface stableToken;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '\n', '    address operator;\n', '\n', '    uint collectPrice;\n', '\n', '    address[] internal allowners;\n', '    mapping (address => uint) public indexOfowner;\n', '\n', '    mapping (address => uint) public balances;\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '\n', '    modifier onlySplitted {\n', '        require(isSplitted == true, "Splitted status required");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator {\n', '        require(operator == msg.sender, "Operation only permited by operator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * The force collect event\n', '     */\n', '    event ForceCollectEvent (\n', '        uint id,\n', '        uint price,\n', '        address operator\n', '    );\n', '\n', '    /**\n', '     * The token split event\n', '     */\n', '    event TokenSplitEvent (\n', '        uint id,\n', '        uint supply,\n', '        uint8 decim,\n', '        uint price\n', '    );\n', '\n', '    /**\n', '     * The merge event\n', '     */\n', '    event TokenMergeEvent (\n', '        uint id,\n', '        address owner\n', '    );\n', '\n', '    constructor(\n', '        string _name,\n', '        string _symbol,\n', '        address _tokenAddress,\n', '        uint _id,\n', '        address _owner,\n', '        uint _assetPrice,\n', '        string _assetFileUrl,\n', '        string _assetFileHashType,\n', '        string _assetFileHashValue,\n', '        string _legalFileUrl,\n', '        string _legalFileHashType,\n', '        string _legalFileHashValue\n', '        ) public\n', '        AssetHashToken(\n', '            _id,\n', '            _owner,\n', '            _assetPrice,\n', '            _assetFileUrl,\n', '            _assetFileHashType,\n', '            _assetFileHashValue,\n', '            _legalFileUrl,\n', '            _legalFileHashType,\n', '            _legalFileHashValue\n', '        )\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        operator = msg.sender; // TODO set to HashFuture owned address\n', '        stableToken = ERC20Interface(_tokenAddress);\n', '    }\n', '\n', '    // ERC 20 Basic Functionality\n', '\n', '    /**\n', '     * Total supply\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '    /**\n', '     * Get the token balance for account `tokenOwner`\n', '     */\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of tokens approved by the owner that can be\n', "     * transferred to the spender's account\n", '     */\n', '    function allowance(address tokenOwner, address spender)\n', '        public view\n', '        returns (uint remaining)\n', '    {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    /**\n', "     * Transfer the balance from token owner's account to `to` account\n", "     * - Owner's account must have sufficient balance to transfer\n", '     * - 0 value transfers are allowed\n', '     */\n', '    function transfer(address to, uint tokens)\n', '        public\n', '        onlySplitted\n', '        returns (bool success)\n', '    {\n', '        require(tokens > 0);\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '\n', '\n', '        // ensure that each address appears only once in allowners list\n', '        // so that distribute divident or force collect only pays one time\n', '        if (indexOfowner[to] == 0) {\n', '            allowners.push(to);\n', '            indexOfowner[to] = allowners.length;\n', '        }\n', '        // could be removed? no\n', '        if (balances[msg.sender] == 0) {\n', '            uint index = indexOfowner[msg.sender].sub(1);\n', '            indexOfowner[msg.sender] = 0;\n', '\n', '            if (index != allowners.length.sub(1)) {\n', '                allowners[index] = allowners[allowners.length.sub(1)];\n', '                indexOfowner[allowners[index]] = index.add(1);\n', '            }\n', '\n', '            //delete allowners[allowners.length.sub(1)];\n', '            allowners.length = allowners.length.sub(1);\n', '        }\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "     * from the token owner's account\n", '     */\n', '    function approve(address spender, uint tokens)\n', '        public\n', '        onlySplitted\n', '        returns (bool success)\n', '    {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer `tokens` from the `from` account to the `to` account\n', '     */\n', '    function transferFrom(address from, address to, uint tokens)\n', '        public\n', '        onlySplitted\n', '        returns (bool success)\n', '    {\n', '        require(tokens > 0);\n', '        balances[from] = balances[from].sub(tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '\n', '        // ensure that each address appears only once in allowners list\n', '        // so that distribute divident or force collect only pays one time\n', '        if (indexOfowner[to] == 0) {\n', '            allowners.push(to);\n', '            indexOfowner[to] = allowners.length;\n', '        }\n', '\n', '        // could be removed? no\n', '        if (balances[from] == 0) {\n', '            uint index = indexOfowner[from].sub(1);\n', '            indexOfowner[from] = 0;\n', '\n', '            if (index != allowners.length.sub(1)) {\n', '                allowners[index] = allowners[allowners.length.sub(1)];\n', '                indexOfowner[allowners[index]] = index.add(1);\n', '            }\n', '            //delete allowners[allowners.length.sub(1)];\n', '            allowners.length = allowners.length.sub(1);\n', '        }\n', '\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * \n', '     * Warning: may fail when number of owners exceeds 100 due to gas limit of a block in Ethereum.\n', '     */\n', '    function distributeDivident(uint amount) public {\n', '        // stableToken.approve(address(this), amount)\n', '        // should be called by the caller to the token contract in previous\n', '        uint value = 0;\n', '        uint length = allowners.length;\n', '        require(stableToken.balanceOf(msg.sender) >= amount, "Insufficient balance for sender");\n', '        require(stableToken.allowance(msg.sender, address(this)) >= amount, "Insufficient allowance for contract");\n', '        for (uint i = 0; i < length; i++) {\n', '            //value = amount * balances[allowners[i]] / _totalSupply;\n', '            value = amount.mul(balances[allowners[i]]);\n', '            value = value.div(_totalSupply);\n', '\n', '            // Always use a require when doing token transfer!\n', '            // Do not think it works like the transfer method for ether,\n', '            // which handles failure and will throw for you.\n', '            require(stableToken.transferFrom(msg.sender, allowners[i], value));\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Collect all small keys in batches.\n', '     * Anyone can force collect all keys if he provides with sufficient stable tokens.\n', '     * However, due to the gas limitation of Ethereum, he can not collect all keys\n', '     * with only one call. Hence an agent that can be trusted is need.\n', '     * The operator is such an agent who will first receive a request to collect all keys,\n', '     * and then collect them with the stable tokens provided by the claimer.\n', '     * @param _address each address in the array means a target address to be collected from.\n', '     */\n', '    function collectAllForce(address[] _address) public onlyOperator {\n', '        // stableToken.approve(address(this), amount)\n', '        // should be called by the caller to the token contract in previous\n', '        uint value = 0;\n', '        uint length = _address.length;\n', '\n', '        uint total_amount = 0;\n', '\n', '        for (uint j = 0; j < length; j++) {\n', '            if (indexOfowner[_address[j]] == 0) {\n', '                continue;\n', '            }\n', '\n', '            total_amount = total_amount.add(collectPrice.mul(balances[_address[j]]));\n', '        }\n', '\n', '        require(stableToken.balanceOf(msg.sender) >= total_amount, "Insufficient balance for sender");\n', '        require(stableToken.allowance(msg.sender, address(this)) >= total_amount, "Insufficient allowance for contract");\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            // Always use a require when doing token transfer!\n', '            // Do not think it works like the transfer method for ether,\n', '            // which handles failure and will throw for you.\n', '            if (indexOfowner[_address[i]] == 0) {\n', '                continue;\n', '            }\n', '\n', '            value = collectPrice.mul(balances[_address[i]]);\n', '\n', '            require(stableToken.transferFrom(msg.sender, _address[i], value));\n', '            balances[msg.sender] = balances[msg.sender].add(balances[_address[i]]);\n', '            emit Transfer(_address[i], msg.sender, balances[_address[i]]);\n', '\n', '            balances[_address[i]] = 0;\n', '\n', '            uint index = indexOfowner[_address[i]].sub(1);\n', '            indexOfowner[_address[i]] = 0;\n', '\n', '            if (index != allowners.length.sub(1)) {\n', '                allowners[index] = allowners[allowners.length.sub(1)];\n', '                indexOfowner[allowners[index]] = index.add(1);\n', '            }\n', '            allowners.length = allowners.length.sub(1);\n', '        }\n', '\n', '        emit ForceCollectEvent(id, collectPrice, operator);\n', '    }\n', '    \n', '    /**\n', '     * key inssurance. Split the whole token into small keys.\n', '     * Only the owner can perform this when the token is still valid and unsplitted.\n', '     * @param _supply Totol supply in ERC20 standard\n', '     * @param _decim  Decimal parameter in ERC20 standard\n', '     * @param _price The force acquisition price. If a claimer is willing to pay more than this value, he can\n', '     * buy the keys forcibly. Notice: the claimer can only buy all keys at one time or buy nothing and the\n', '     * buying process is delegated into a trusted agent. i.e. the operator.\n', '     * @param _address The initial distribution plan for the keys. This parameter contains the addresses.\n', '     * @param _amount  The amount corresponding to the initial distribution addresses.\n', '     */\n', '    function split(uint _supply, uint8 _decim, uint _price, address[] _address, uint[] _amount)\n', '        public\n', '        onlyOwner\n', '        onlyValid\n', '        onlyUnsplitted\n', '    {\n', '        require(_address.length == _amount.length);\n', '\n', '        isSplitted = true;\n', '        _totalSupply = _supply * 10 ** uint(_decim);\n', '        decimals = _decim;\n', '        collectPrice = _price;\n', '\n', '        uint amount = 0;\n', '        uint length = _address.length;\n', '\n', '        balances[msg.sender] = _totalSupply;\n', '        if (indexOfowner[msg.sender] == 0) {\n', '            allowners.push(msg.sender);\n', '            indexOfowner[msg.sender] = allowners.length;\n', '        }\n', '        emit Transfer(address(0), msg.sender, _totalSupply);\n', '\n', '        for (uint i = 0; i < length; i++) {\n', '            amount = _amount[i]; // * 10 ** uint(_decim);\n', '            balances[_address[i]] = amount;\n', '            balances[msg.sender] = balances[msg.sender].sub(amount);\n', '\n', '            // ensure that each address appears only once in allowners list\n', '            // so that distribute divident or force collect only pays one time\n', '            if (indexOfowner[_address[i]] == 0) {\n', '                allowners.push(_address[i]);\n', '                indexOfowner[_address[i]] = allowners.length;\n', '            }\n', '            emit Transfer(msg.sender, _address[i], amount);\n', '        }\n', '\n', '        emit TokenSplitEvent(id, _supply, _decim, _price);\n', '    }\n', '    \n', '    /**\n', '     * Token conversion. Turn the keys to a whole token.\n', '     * Only the sender with all keys in hand can perform this and he will be the new owner.\n', '     */\n', '    function merge() public onlyValid onlySplitted {\n', '        require(balances[msg.sender] == _totalSupply);\n', '        _totalSupply = 0;\n', '        balances[msg.sender] = 0;\n', '        owner = msg.sender;\n', '        isTradable = false;\n', '        isSplitted = false;\n', '        emit Transfer(msg.sender, address(0), _totalSupply);\n', '        emit TokenMergeEvent(id, msg.sender);\n', '    }\n', '}']