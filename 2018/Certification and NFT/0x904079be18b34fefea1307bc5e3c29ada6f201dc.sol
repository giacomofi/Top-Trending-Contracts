['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations that are safe for uint256 against overflow and negative values\n', ' * @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Moderated\n', ' * @dev restricts execution of &#39;onlyModerator&#39; modified functions to the contract moderator\n', ' * @dev restricts execution of &#39;ifUnrestricted&#39; modified functions to when unrestricted \n', ' *      boolean state is true\n', ' * @dev allows for the extraction of ether or other ERC20 tokens mistakenly sent to this address\n', ' */\n', 'contract Moderated {\n', '    \n', '    address public moderator;\n', '    \n', '    bool public unrestricted;\n', '    \n', '    modifier onlyModerator {\n', '        require(msg.sender == moderator);\n', '        _;\n', '    }\n', '    \n', '    modifier ifUnrestricted {\n', '        require(unrestricted);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyPayloadSize(uint256 numWords) {\n', '        assert(msg.data.length >= numWords * 32 + 4);\n', '        _;\n', '    }    \n', '    \n', '    function Moderated() public {\n', '        moderator = msg.sender;\n', '        unrestricted = true;\n', '    }\n', '    \n', '    function reassignModerator(address newModerator) public onlyModerator {\n', '        moderator = newModerator;\n', '    }\n', '    \n', '    function restrict() public onlyModerator {\n', '        unrestricted = false;\n', '    }\n', '    \n', '    function unrestrict() public onlyModerator {\n', '        unrestricted = true;\n', '    }  \n', '    \n', '    /// This method can be used to extract tokens mistakenly sent to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    function extract(address _token) public returns (bool) {\n', '        require(_token != address(0x0));\n', '        Token token = Token(_token);\n', '        uint256 balance = token.balanceOf(this);\n', '        return token.transfer(moderator, balance);\n', '    }\n', '    \n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_addr) }\n', '        return (size > 0);\n', '    }    \n', '} \n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract Token { \n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);    \n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);    \n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Controlled\n', ' * @dev Restricts execution of modified functions to the contract controller alone\n', ' */\n', 'contract Controlled {\n', '    address public controller;\n', '\n', '    function Controlled() public {\n', '        controller = msg.sender;\n', '    }\n', '\n', '    modifier onlyController {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    function transferControl(address newController) public onlyController{\n', '        controller = newController;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Controlled {\n', '    using SafeMath for uint256;\n', '    \n', '    enum State { Active, Refunding, Closed }\n', '    \n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '    \n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '    \n', '    function RefundVault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;        \n', '        state = State.Active;\n', '    }\n', '\n', '\tfunction () external payable {\n', '\t    revert();\n', '\t}\n', '    \n', '    function deposit(address investor) onlyController public payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '    \n', '    function close() onlyController public {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        Closed();\n', '        wallet.transfer(this.balance);\n', '    }\n', '    \n', '    function enableRefunds() onlyController public {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        RefundsEnabled();\n', '    }\n', '    \n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        Refunded(investor, depositedValue);\n', '    }\n', '}\n', '\n', 'contract CrowdSale is Moderated {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t// LEON ERC20 smart contract\n', '\tToken public tokenContract;\n', '\t\n', '    // crowdsale starts 1 March 2018, 00h00 PDT\n', '    uint256 public constant startDate = 1519891200;\n', '    // crowdsale ends 31 December 2018, 23h59 PDT\n', '    uint256 public constant endDate = 1546243140;\n', '    \n', '    // crowdsale aims to sell at least 100 000 LEONS\n', '    uint256 public constant crowdsaleTarget = 100000 * 10**18;\n', '    uint256 public constant margin = 1000 * 10**18;\n', '    // running total of tokens sold\n', '    uint256 public tokensSold;\n', '    \n', '    // ethereum to US Dollar exchange rate\n', '    uint256 public etherToUSDRate;\n', '    \n', '    // address to receive accumulated ether given a successful crowdsale\n', '\taddress public constant etherVault = 0xD8d97E3B5dB13891e082F00ED3fe9A0BC6B7eA01;    \n', '\t// vault contract escrows ether and facilitates refunds given unsuccesful crowdsale\n', '\tRefundVault public refundVault;\n', '    \n', '    // minimum of 0.005 ether to participate in crowdsale\n', '\tuint256 constant purchaseThreshold = 5 finney;\n', '\n', '    // boolean to indicate crowdsale finalized state\t\n', '\tbool public isFinalized = false;\n', '\t\n', '\tbool public active = false;\n', '\t\n', '\t// finalization event\n', '\tevent Finalized();\n', '\t\n', '\t// purchase event\n', '\tevent Purchased(address indexed purchaser, uint256 indexed tokens);\n', '    \n', '    // checks that crowd sale is live\t\n', '    modifier onlyWhileActive {\n', '        require(now >= startDate && now <= endDate && active);\n', '        _;\n', '    }\t\n', '\t\n', '    function CrowdSale(address _tokenAddr, uint256 price) public {\n', '        // the LEON token contract\n', '        tokenContract = Token(_tokenAddr);\n', '        // initiate new refund vault to escrow ether from purchasers\n', '        refundVault = new RefundVault(etherVault);\n', '        \n', '        etherToUSDRate = price;\n', '    }\t\n', '\tfunction setRate(uint256 _rate) public onlyModerator returns (bool) {\n', '\t    etherToUSDRate = _rate;\n', '\t}\n', '\t// fallback function invokes buyTokens method\n', '\tfunction() external payable {\n', '\t    buyTokens(msg.sender);\n', '\t}\n', '\t\n', '\t// forwards ether received to refund vault and generates tokens for purchaser\n', '\tfunction buyTokens(address _purchaser) public payable ifUnrestricted onlyWhileActive returns (bool) {\n', '\t    require(!targetReached());\n', '\t    require(msg.value > purchaseThreshold);\n', '\t    refundVault.deposit.value(msg.value)(_purchaser);\n', '\t    // 1 LEON is priced at 1 USD\n', '\t    // etherToUSDRate is stored in cents, /100 to get USD quantity\n', '\t    // crowdsale offers 100% bonus, purchaser receives (tokens before bonus) * 2\n', '\t    // tokens = (ether * etherToUSDRate in cents) * 2 / 100\n', '\t\tuint256 _tokens = (msg.value).mul(etherToUSDRate).div(50);\t\t\n', '\t\trequire(tokenContract.transferFrom(moderator,_purchaser, _tokens));\n', '        tokensSold = tokensSold.add(_tokens);\n', '        Purchased(_purchaser, _tokens);\n', '        return true;\n', '\t}\t\n', '\t\n', '\tfunction initialize() public onlyModerator returns (bool) {\n', '\t    require(!active && !isFinalized);\n', '\t    require(tokenContract.allowance(moderator,address(this)) == crowdsaleTarget + margin);\n', '\t    active = true;\n', '\t}\n', '\t\n', '\t// activates end of crowdsale state\n', '    function finalize() public onlyModerator {\n', '        // cannot have been invoked before\n', '        require(!isFinalized);\n', '        // can only be invoked after end date or if target has been reached\n', '        require(hasEnded() || targetReached());\n', '        \n', '        // if crowdsale has been successful\n', '        if(targetReached()) {\n', '            // close refund vault and forward ether to etherVault\n', '            refundVault.close();\n', '\n', '        // if the sale was unsuccessful    \n', '        } else {\n', '            // activate refund vault\n', '            refundVault.enableRefunds();\n', '        }\n', '        // emit Finalized event\n', '        Finalized();\n', '        // set isFinalized boolean to true\n', '        isFinalized = true;\n', '        \n', '        active = false;\n', '\n', '    }\n', '    \n', '\t// checks if end date of crowdsale is passed    \n', '    function hasEnded() internal view returns (bool) {\n', '        return (now > endDate);\n', '    }\n', '    \n', '    // checks if crowdsale target is reached\n', '    function targetReached() internal view returns (bool) {\n', '        return (tokensSold >= crowdsaleTarget);\n', '    }\n', '    \n', '    // refunds ether to investors if crowdsale is unsuccessful \n', '    function claimRefund() public {\n', '        // can only be invoked after sale is finalized\n', '        require(isFinalized);\n', '        // can only be invoked if sale target was not reached\n', '        require(!targetReached());\n', '        // if msg.sender invested ether during crowdsale - refund them of their contribution\n', '        refundVault.refund(msg.sender);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations that are safe for uint256 against overflow and negative values\n', ' * @dev https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Moderated\n', " * @dev restricts execution of 'onlyModerator' modified functions to the contract moderator\n", " * @dev restricts execution of 'ifUnrestricted' modified functions to when unrestricted \n", ' *      boolean state is true\n', ' * @dev allows for the extraction of ether or other ERC20 tokens mistakenly sent to this address\n', ' */\n', 'contract Moderated {\n', '    \n', '    address public moderator;\n', '    \n', '    bool public unrestricted;\n', '    \n', '    modifier onlyModerator {\n', '        require(msg.sender == moderator);\n', '        _;\n', '    }\n', '    \n', '    modifier ifUnrestricted {\n', '        require(unrestricted);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyPayloadSize(uint256 numWords) {\n', '        assert(msg.data.length >= numWords * 32 + 4);\n', '        _;\n', '    }    \n', '    \n', '    function Moderated() public {\n', '        moderator = msg.sender;\n', '        unrestricted = true;\n', '    }\n', '    \n', '    function reassignModerator(address newModerator) public onlyModerator {\n', '        moderator = newModerator;\n', '    }\n', '    \n', '    function restrict() public onlyModerator {\n', '        unrestricted = false;\n', '    }\n', '    \n', '    function unrestrict() public onlyModerator {\n', '        unrestricted = true;\n', '    }  \n', '    \n', '    /// This method can be used to extract tokens mistakenly sent to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    function extract(address _token) public returns (bool) {\n', '        require(_token != address(0x0));\n', '        Token token = Token(_token);\n', '        uint256 balance = token.balanceOf(this);\n', '        return token.transfer(moderator, balance);\n', '    }\n', '    \n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_addr) }\n', '        return (size > 0);\n', '    }    \n', '} \n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract Token { \n', '\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);    \n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);    \n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Controlled\n', ' * @dev Restricts execution of modified functions to the contract controller alone\n', ' */\n', 'contract Controlled {\n', '    address public controller;\n', '\n', '    function Controlled() public {\n', '        controller = msg.sender;\n', '    }\n', '\n', '    modifier onlyController {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    function transferControl(address newController) public onlyController{\n', '        controller = newController;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Controlled {\n', '    using SafeMath for uint256;\n', '    \n', '    enum State { Active, Refunding, Closed }\n', '    \n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    State public state;\n', '    \n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '    \n', '    function RefundVault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;        \n', '        state = State.Active;\n', '    }\n', '\n', '\tfunction () external payable {\n', '\t    revert();\n', '\t}\n', '    \n', '    function deposit(address investor) onlyController public payable {\n', '        require(state == State.Active);\n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '    }\n', '    \n', '    function close() onlyController public {\n', '        require(state == State.Active);\n', '        state = State.Closed;\n', '        Closed();\n', '        wallet.transfer(this.balance);\n', '    }\n', '    \n', '    function enableRefunds() onlyController public {\n', '        require(state == State.Active);\n', '        state = State.Refunding;\n', '        RefundsEnabled();\n', '    }\n', '    \n', '    function refund(address investor) public {\n', '        require(state == State.Refunding);\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        Refunded(investor, depositedValue);\n', '    }\n', '}\n', '\n', 'contract CrowdSale is Moderated {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\t// LEON ERC20 smart contract\n', '\tToken public tokenContract;\n', '\t\n', '    // crowdsale starts 1 March 2018, 00h00 PDT\n', '    uint256 public constant startDate = 1519891200;\n', '    // crowdsale ends 31 December 2018, 23h59 PDT\n', '    uint256 public constant endDate = 1546243140;\n', '    \n', '    // crowdsale aims to sell at least 100 000 LEONS\n', '    uint256 public constant crowdsaleTarget = 100000 * 10**18;\n', '    uint256 public constant margin = 1000 * 10**18;\n', '    // running total of tokens sold\n', '    uint256 public tokensSold;\n', '    \n', '    // ethereum to US Dollar exchange rate\n', '    uint256 public etherToUSDRate;\n', '    \n', '    // address to receive accumulated ether given a successful crowdsale\n', '\taddress public constant etherVault = 0xD8d97E3B5dB13891e082F00ED3fe9A0BC6B7eA01;    \n', '\t// vault contract escrows ether and facilitates refunds given unsuccesful crowdsale\n', '\tRefundVault public refundVault;\n', '    \n', '    // minimum of 0.005 ether to participate in crowdsale\n', '\tuint256 constant purchaseThreshold = 5 finney;\n', '\n', '    // boolean to indicate crowdsale finalized state\t\n', '\tbool public isFinalized = false;\n', '\t\n', '\tbool public active = false;\n', '\t\n', '\t// finalization event\n', '\tevent Finalized();\n', '\t\n', '\t// purchase event\n', '\tevent Purchased(address indexed purchaser, uint256 indexed tokens);\n', '    \n', '    // checks that crowd sale is live\t\n', '    modifier onlyWhileActive {\n', '        require(now >= startDate && now <= endDate && active);\n', '        _;\n', '    }\t\n', '\t\n', '    function CrowdSale(address _tokenAddr, uint256 price) public {\n', '        // the LEON token contract\n', '        tokenContract = Token(_tokenAddr);\n', '        // initiate new refund vault to escrow ether from purchasers\n', '        refundVault = new RefundVault(etherVault);\n', '        \n', '        etherToUSDRate = price;\n', '    }\t\n', '\tfunction setRate(uint256 _rate) public onlyModerator returns (bool) {\n', '\t    etherToUSDRate = _rate;\n', '\t}\n', '\t// fallback function invokes buyTokens method\n', '\tfunction() external payable {\n', '\t    buyTokens(msg.sender);\n', '\t}\n', '\t\n', '\t// forwards ether received to refund vault and generates tokens for purchaser\n', '\tfunction buyTokens(address _purchaser) public payable ifUnrestricted onlyWhileActive returns (bool) {\n', '\t    require(!targetReached());\n', '\t    require(msg.value > purchaseThreshold);\n', '\t    refundVault.deposit.value(msg.value)(_purchaser);\n', '\t    // 1 LEON is priced at 1 USD\n', '\t    // etherToUSDRate is stored in cents, /100 to get USD quantity\n', '\t    // crowdsale offers 100% bonus, purchaser receives (tokens before bonus) * 2\n', '\t    // tokens = (ether * etherToUSDRate in cents) * 2 / 100\n', '\t\tuint256 _tokens = (msg.value).mul(etherToUSDRate).div(50);\t\t\n', '\t\trequire(tokenContract.transferFrom(moderator,_purchaser, _tokens));\n', '        tokensSold = tokensSold.add(_tokens);\n', '        Purchased(_purchaser, _tokens);\n', '        return true;\n', '\t}\t\n', '\t\n', '\tfunction initialize() public onlyModerator returns (bool) {\n', '\t    require(!active && !isFinalized);\n', '\t    require(tokenContract.allowance(moderator,address(this)) == crowdsaleTarget + margin);\n', '\t    active = true;\n', '\t}\n', '\t\n', '\t// activates end of crowdsale state\n', '    function finalize() public onlyModerator {\n', '        // cannot have been invoked before\n', '        require(!isFinalized);\n', '        // can only be invoked after end date or if target has been reached\n', '        require(hasEnded() || targetReached());\n', '        \n', '        // if crowdsale has been successful\n', '        if(targetReached()) {\n', '            // close refund vault and forward ether to etherVault\n', '            refundVault.close();\n', '\n', '        // if the sale was unsuccessful    \n', '        } else {\n', '            // activate refund vault\n', '            refundVault.enableRefunds();\n', '        }\n', '        // emit Finalized event\n', '        Finalized();\n', '        // set isFinalized boolean to true\n', '        isFinalized = true;\n', '        \n', '        active = false;\n', '\n', '    }\n', '    \n', '\t// checks if end date of crowdsale is passed    \n', '    function hasEnded() internal view returns (bool) {\n', '        return (now > endDate);\n', '    }\n', '    \n', '    // checks if crowdsale target is reached\n', '    function targetReached() internal view returns (bool) {\n', '        return (tokensSold >= crowdsaleTarget);\n', '    }\n', '    \n', '    // refunds ether to investors if crowdsale is unsuccessful \n', '    function claimRefund() public {\n', '        // can only be invoked after sale is finalized\n', '        require(isFinalized);\n', '        // can only be invoked if sale target was not reached\n', '        require(!targetReached());\n', '        // if msg.sender invested ether during crowdsale - refund them of their contribution\n', '        refundVault.refund(msg.sender);\n', '    }\n', '}']
