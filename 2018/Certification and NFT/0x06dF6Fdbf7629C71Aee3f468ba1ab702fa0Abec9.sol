['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BBODServiceRegistry is Ownable {\n', '\n', '  //1. Manager\n', '  //2. CustodyStorage\n', '  mapping(uint => address) public registry;\n', '\n', '    constructor(address _owner) {\n', '        owner = _owner;\n', '    }\n', '\n', '  function setServiceRegistryEntry (uint key, address entry) external onlyOwner {\n', '    registry[key] = entry;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ManagerInterface {\n', '  function createCustody(address) external {}\n', '\n', '  function isExchangeAlive() public pure returns (bool) {}\n', '\n', '  function isDailySettlementOnGoing() public pure returns (bool) {}\n', '}\n', '\n', 'contract Custody {\n', '\n', '  using SafeMath for uint;\n', '\n', '  BBODServiceRegistry public bbodServiceRegistry;\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor(address _serviceRegistryAddress, address _owner) public {\n', '    bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress);\n', '    owner = _owner;\n', '  }\n', '\n', '  function() public payable {}\n', '\n', '  modifier liveExchangeOrOwner(address _recipient) {\n', '    var manager = ManagerInterface(bbodServiceRegistry.registry(1));\n', '\n', '    if (manager.isExchangeAlive()) {\n', '\n', '      require(msg.sender == address(manager));\n', '\n', '      if (manager.isDailySettlementOnGoing()) {\n', '        require(_recipient == address(manager), "Only manager can do this when the settlement is ongoing");\n', '      } else {\n', '        require(_recipient == owner);\n', '      }\n', '\n', '    } else {\n', '      require(msg.sender == owner, "Only owner can do this when exchange is dead");\n', '    }\n', '    _;\n', '  }\n', '\n', '  function withdraw(uint _amount, address _recipient) external liveExchangeOrOwner(_recipient) {\n', '    _recipient.transfer(_amount);\n', '  }\n', '\n', '  function transferToken(address _erc20Address, address _recipient, uint _amount)\n', '    external liveExchangeOrOwner(_recipient) {\n', '\n', '    ERC20 token = ERC20(_erc20Address);\n', '\n', '    token.transfer(_recipient, _amount);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public {\n', '    require(msg.sender == owner, "Only the owner can transfer ownership");\n', '    require(newOwner != address(0));\n', '\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract CustodyStorage {\n', '\n', '  BBODServiceRegistry public bbodServiceRegistry;\n', '\n', '  mapping(address => bool) public custodiesMap;\n', '\n', '  //Number of all custodies in the contract\n', '  uint public custodyCounter = 0;\n', '\n', '  address[] public custodiesArray;\n', '\n', '  event CustodyRemoved(address indexed custody);\n', '\n', '  constructor(address _serviceRegistryAddress) public {\n', '    bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress);\n', '  }\n', '\n', '  modifier onlyManager() {\n', '    require(msg.sender == bbodServiceRegistry.registry(1));\n', '    _;\n', '  }\n', '\n', '  function addCustody(address _custody) external onlyManager {\n', '    custodiesMap[_custody] = true;\n', '    custodiesArray.push(_custody);\n', '    custodyCounter++;\n', '  }\n', '\n', '  function removeCustody(address _custodyAddress, uint _arrayIndex) external onlyManager {\n', '    require(custodiesArray[_arrayIndex] == _custodyAddress);\n', '\n', '    if (_arrayIndex == custodyCounter - 1) {\n', '      //Removing last custody\n', '      custodiesMap[_custodyAddress] = false;\n', '      emit CustodyRemoved(_custodyAddress);\n', '      custodyCounter--;\n', '      return;\n', '    }\n', '\n', '    custodiesMap[_custodyAddress] = false;\n', '    //Overwriting deleted custody with the last custody in the array\n', '    custodiesArray[_arrayIndex] = custodiesArray[custodyCounter - 1];\n', '    custodyCounter--;\n', '\n', '    emit CustodyRemoved(_custodyAddress);\n', '  }\n', '}\n', 'contract Insurance is Custody {\n', '\n', '  constructor(address _serviceRegistryAddress, address _owner)\n', '  Custody(_serviceRegistryAddress, _owner) public {}\n', '\n', '  function useInsurance (uint _amount) external {\n', '    var manager = ManagerInterface(bbodServiceRegistry.registry(1));\n', '    //Only usable for manager during settlement\n', '    require(manager.isDailySettlementOnGoing() && msg.sender == address(manager));\n', '\n', '    address(manager).transfer(_amount);\n', '  }\n', '}\n', '\n', 'contract Manager is Pausable {\n', 'using SafeMath for uint;\n', '\n', 'mapping(address => bool) public ownerAccountsMap;\n', 'mapping(address => bool) public exchangeAccountsMap;\n', '\n', '//SETTLEMENT PREPARATION####\n', '\n', 'enum SettlementPhase {\n', 'PREPARING, ONGOING, FINISHED\n', '}\n', '\n', 'enum Cryptocurrency {\n', 'ETH, BBD\n', '}\n', '\n', '//Initially ready for a settlement\n', 'SettlementPhase public currentSettlementPhase = SettlementPhase.FINISHED;\n', '\n', 'uint public startingFeeBalance = 0;\n', 'uint public totalFeeFlows = 0;\n', 'uint public startingInsuranceBalance = 0;\n', 'uint public totalInsuranceFlows = 0;\n', '\n', 'uint public lastSettlementStartedTimestamp = 0;\n', 'uint public earliestNextSettlementTimestamp = 0;\n', '\n', 'mapping(uint => mapping(address => bool)) public custodiesServedETH;\n', 'mapping(uint => mapping(address => bool)) public custodiesServedBBD;\n', '\n', 'address public feeAccount;\n', 'address public insuranceAccount;\n', 'ERC20 public bbdToken;\n', 'CustodyStorage public custodyStorage;\n', '\n', 'address public custodyFactory;\n', 'uint public gweiBBDPriceInWei;\n', 'uint public lastTimePriceSet;\n', 'uint constant public gwei = 1000000000;\n', '\n', 'uint public maxTimeIntervalHB = 1 weeks;\n', 'uint public heartBeat = now;\n', '\n', 'constructor(address _feeAccount, address _insuranceAccount, address _bbdTokenAddress, address _custodyStorage,\n', 'address _serviceRegistryAddress) public {\n', '//Contract creator is the first owner\n', 'ownerAccountsMap[msg.sender] = true;\n', 'feeAccount = _feeAccount;\n', 'insuranceAccount = _insuranceAccount;\n', 'bbdToken = ERC20(_bbdTokenAddress);\n', 'custodyStorage = CustodyStorage(_custodyStorage);\n', '}\n', '\n', 'function() public payable {}\n', '\n', 'function setCustodyFactory(address _custodyFactory) external onlyOwner {\n', 'custodyFactory = _custodyFactory;\n', '}\n', '\n', 'function pause() public onlyExchangeOrOwner {\n', 'paused = true;\n', '}\n', '\n', 'function unpause() public onlyExchangeOrOwner {\n', 'paused = false;\n', '}\n', '\n', 'modifier onlyAllowedInPhase(SettlementPhase _phase) {\n', 'require(currentSettlementPhase == _phase, "Not allowed in this phase");\n', '_;\n', '}\n', '\n', 'modifier onlyOwner() {\n', 'require(ownerAccountsMap[msg.sender] == true, "Only an owner can perform this action");\n', '_;\n', '}\n', '\n', 'modifier onlyExchange() {\n', 'require(exchangeAccountsMap[msg.sender] == true, "Only an exchange can perform this action");\n', '_;\n', '}\n', '\n', 'modifier onlyExchangeOrOwner() {\n', 'require(exchangeAccountsMap[msg.sender] == true ||\n', 'ownerAccountsMap[msg.sender] == true);\n', '_;\n', '}\n', '\n', 'function isDailySettlementOnGoing() external view returns (bool) {\n', 'return currentSettlementPhase != SettlementPhase.FINISHED;\n', '}\n', '\n', 'function updateHeartBeat() external whenNotPaused onlyOwner {\n', 'heartBeat = now;\n', '}\n', '\n', 'function isExchangeAlive() external view returns (bool) {\n', 'return now - heartBeat < maxTimeIntervalHB;\n', '}\n', '\n', 'function addOwnerAccount(address _exchangeAccount) external onlyOwner {\n', 'ownerAccountsMap[_exchangeAccount] = true;\n', '}\n', '\n', 'function addExchangeAccount(address _exchangeAccount) external onlyOwner whenNotPaused {\n', 'exchangeAccountsMap[_exchangeAccount] = true;\n', '}\n', '\n', 'function rmExchangeAccount(address _exchangeAccount) external onlyOwner whenNotPaused {\n', 'exchangeAccountsMap[_exchangeAccount] = false;\n', '}\n', '\n', 'function setBBDPrice(uint _priceInWei) external onlyExchangeOrOwner whenNotPaused\n', 'onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', 'if(gweiBBDPriceInWei == 0) {\n', 'gweiBBDPriceInWei = _priceInWei;\n', '} else {\n', '//Max 100% daily increase in price\n', 'if(_priceInWei > gweiBBDPriceInWei) {\n', 'require(_priceInWei - gweiBBDPriceInWei <= (gweiBBDPriceInWei / 2));\n', '//Max 50% daily decrease in price\n', '} else if(_priceInWei < gweiBBDPriceInWei) {\n', 'require(gweiBBDPriceInWei - _priceInWei <= (gweiBBDPriceInWei / 2));\n', '}\n', 'gweiBBDPriceInWei = _priceInWei;\n', '}\n', '//Price can only be set once per day\n', 'require(now - lastTimePriceSet > 23 hours);\n', '\n', 'lastTimePriceSet = now;\n', '}\n', '\n', 'function createCustody(address _custody) external whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', 'require(msg.sender == custodyFactory);\n', 'custodyStorage.addCustody(_custody);\n', '}\n', '\n', 'function removeCustody(address _custodyAddress, uint _arrayIndex) external whenNotPaused onlyExchangeOrOwner\n', 'onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', 'custodyStorage.removeCustody(_custodyAddress, _arrayIndex);\n', '}\n', '\n', '/// @dev Exchange uses this function to withdraw ether from the contract\n', '/// @param _amount to withdraw\n', '/// @param _recipient to send withdrawn ether to\n', 'function withdrawFromManager(uint _amount, address _recipient) external onlyExchangeOrOwner\n', 'whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', '_recipient.transfer(_amount);\n', '}\n', '\n', '/// @dev Users use this function to withdraw ether from their custody\n', '/// @param _amount to withdraw\n', '/// @param _custodyAddress to withdraw from\n', 'function withdrawFromCustody(uint _amount, address _custodyAddress,address _recipient) external onlyExchangeOrOwner\n', 'whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', 'Custody custody = Custody(_custodyAddress);\n', 'custody.withdraw(_amount, _recipient);\n', '}\n', '\n', '/// @dev Users use this function to withdraw ether from their custody\n', '/// @param _tokenAddress of the ERC20 to withdraw from\n', '/// @param _amount to withdraw\n', '/// @param _custodyAddress to withdraw from\n', 'function withdrawTokensFromCustody(address _tokenAddress, uint _amount, address _custodyAddress, address _recipient)\n', 'external whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) onlyExchangeOrOwner {\n', 'Custody custody = Custody(_custodyAddress);\n', 'custody.transferToken(_tokenAddress, _recipient,_amount);\n', '}\n', '\n', '//DAILY SETTLEMENT\n', '\n', '/// @dev This function prepares the daily settlement - resets all settlement\n', '/// @dev scope storage variables to 0.\n', 'function startSettlementPreparation() external whenNotPaused onlyExchangeOrOwner\n', 'onlyAllowedInPhase(SettlementPhase.FINISHED) {\n', 'require(now > earliestNextSettlementTimestamp, "A settlement can happen once per day");\n', 'require(gweiBBDPriceInWei > 0, "BBD Price cannot be 0 during settlement");\n', '\n', 'lastSettlementStartedTimestamp = now;\n', 'totalFeeFlows = 0;\n', 'totalInsuranceFlows = 0;\n', '\n', 'currentSettlementPhase = SettlementPhase.ONGOING;\n', '\n', '\n', 'startingFeeBalance = feeAccount.balance +\n', '((bbdToken.balanceOf(feeAccount) * gweiBBDPriceInWei) / gwei);\n', '\n', 'startingInsuranceBalance = insuranceAccount.balance;\n', '}\n', '\n', '/// @dev This function is used to process a batch of net eth flows, two arrays\n', '/// @dev are pairs of custody addresses and the balance changes that should\n', '/// @dev be executed. Transaction will revert if exchange rules are violated.\n', '/// @param _custodies flow addresses\n', '/// @param _flows flow balance changes (can be negative or positive)\n', '/// @param _fee calculated and deducted from all batch flows\n', '/// @param _insurance to be used\n', 'function settleETHBatch(address[] _custodies, int[] _flows, uint _fee, uint _insurance) external whenNotPaused onlyExchangeOrOwner\n', 'onlyAllowedInPhase(SettlementPhase.ONGOING) {\n', '\n', 'require(_custodies.length == _flows.length);\n', '\n', 'uint preBatchBalance = address(this).balance;\n', '\n', 'if(_insurance > 0) {\n', 'Insurance(insuranceAccount).useInsurance(_insurance);\n', '}\n', '\n', 'for (uint flowIndex = 0; flowIndex < _flows.length; flowIndex++) {\n', '\n', '//Every custody can be served ETH once during settlement\n', 'require(custodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] == false);\n', '\n', '//All addresses must be custodies\n', 'require(custodyStorage.custodiesMap(_custodies[flowIndex]));\n', '\n', 'if (_flows[flowIndex] > 0) {\n', '//10% rule\n', 'var outboundFlow = uint(_flows[flowIndex]);\n', '\n', '//100% rule exception threshold\n', 'if(outboundFlow > 10 ether) {\n', '//100% rule\n', 'require(getTotalBalanceFor(_custodies[flowIndex]) >= outboundFlow);\n', '}\n', '\n', '_custodies[flowIndex].transfer(uint(_flows[flowIndex]));\n', '\n', '} else if (_flows[flowIndex] < 0) {\n', 'Custody custody = Custody(_custodies[flowIndex]);\n', '\n', 'custody.withdraw(uint(-_flows[flowIndex]), address(this));\n', '}\n', '\n', 'custodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] = true;\n', '}\n', '\n', 'if(_fee > 0) {\n', 'feeAccount.transfer(_fee);\n', 'totalFeeFlows = totalFeeFlows + _fee;\n', '//100% rule for fee account\n', 'require(totalFeeFlows <= startingFeeBalance);\n', '}\n', '\n', 'uint postBatchBalance = address(this).balance;\n', '\n', '//Zero-sum guaranteed for ever batch\n', 'if(address(this).balance > preBatchBalance) {\n', 'uint leftovers = address(this).balance - preBatchBalance;\n', 'insuranceAccount.transfer(leftovers);\n', 'totalInsuranceFlows += leftovers;\n', '//100% rule for insurance account\n', 'require(totalInsuranceFlows <= startingInsuranceBalance);\n', '}\n', '}\n', '\n', '/// @dev This function is used to process a batch of net bbd flows, two arrays\n', '/// @dev are pairs of custody addresses and the balance changes that should\n', '/// @dev be executed. Transaction will revert if exchange rules are violated.\n', '/// @param _custodies flow addresses\n', '/// @param _flows flow balance changes (can be negative or positive)\n', '/// @param _fee calculated and deducted from all batch flows\n', 'function settleBBDBatch(address[] _custodies, int[] _flows, uint _fee) external whenNotPaused onlyExchangeOrOwner\n', 'onlyAllowedInPhase(SettlementPhase.ONGOING) {\n', '//TODO optimize for gas usage\n', '\n', 'require(_custodies.length == _flows.length);\n', '\n', 'uint preBatchBalance = bbdToken.balanceOf(address(this));\n', '\n', 'for (uint flowIndex = 0; flowIndex < _flows.length; flowIndex++) {\n', '\n', '//Every custody can be served BBD once during settlement\n', 'require(custodiesServedBBD[lastSettlementStartedTimestamp][_custodies[flowIndex]] == false);\n', '//All addresses must be custodies\n', 'require(custodyStorage.custodiesMap(_custodies[flowIndex]));\n', '\n', 'if (_flows[flowIndex] > 0) {\n', 'var flowValue = ((uint(_flows[flowIndex]) * gweiBBDPriceInWei)/gwei);\n', '\n', '//Minimal BBD transfer is 1gWeiBBD\n', 'require(flowValue >= 1);\n', '\n', '//50% rule threshold\n', 'if(flowValue > 10 ether) {\n', '//50% rule for bbd\n', 'require((getTotalBalanceFor(_custodies[flowIndex]) / 2) >= flowValue);\n', '}\n', '\n', 'bbdToken.transfer(_custodies[flowIndex], uint(_flows[flowIndex]));\n', '\n', '} else if (_flows[flowIndex] < 0) {\n', 'Custody custody = Custody(_custodies[flowIndex]);\n', '\n', 'custody.transferToken(address(bbdToken),address(this), uint(-(_flows[flowIndex])));\n', '}\n', '\n', 'custodiesServedBBD[lastSettlementStartedTimestamp][_custodies[flowIndex]] = true;\n', '}\n', '\n', 'if(_fee > 0) {\n', 'bbdToken.transfer(feeAccount, _fee);\n', '//No need for safe math, as transfer will trow if _fee could cause overflow\n', 'totalFeeFlows += ((_fee * gweiBBDPriceInWei) / gwei);\n', 'require (totalFeeFlows <= startingFeeBalance);\n', '}\n', '\n', 'uint postBatchBalance = bbdToken.balanceOf(address(this));\n', '\n', '//Zero-or-less-sum guaranteed for every batch, no insurance for spots\n', 'require(postBatchBalance <= preBatchBalance);\n', '}\n', '\n', '/// @dev This function is used to finish the settlement process\n', 'function finishSettlement() external whenNotPaused onlyExchangeOrOwner\n', 'onlyAllowedInPhase(SettlementPhase.ONGOING) {\n', '//TODO phase change event?\n', 'earliestNextSettlementTimestamp = lastSettlementStartedTimestamp + 23 hours;\n', '\n', 'currentSettlementPhase = SettlementPhase.FINISHED;\n', '}\n', '\n', 'function getTotalBalanceFor(address _custody) internal view returns (uint) {\n', '\n', 'var bbdHoldingsInWei = ((bbdToken.balanceOf(_custody) * gweiBBDPriceInWei) / gwei);\n', '\n', 'return _custody.balance + bbdHoldingsInWei;\n', '}\n', '\n', 'function checkIfCustodiesServedETH(address[] _custodies) external view returns (bool) {\n', 'for (uint custodyIndex = 0; custodyIndex < _custodies.length; custodyIndex++) {\n', 'if(custodiesServedETH[lastSettlementStartedTimestamp][_custodies[custodyIndex]]) {\n', 'return true;\n', '}\n', '}\n', 'return false;\n', '}\n', '\n', 'function checkIfCustodiesServedBBD(address[] _custodies) external view returns (bool) {\n', 'for (uint custodyIndex = 0; custodyIndex < _custodies.length; custodyIndex++) {\n', 'if(custodiesServedBBD[lastSettlementStartedTimestamp][_custodies[custodyIndex]]) {\n', 'return true;\n', '}\n', '}\n', 'return false;\n', '}\n', '}']