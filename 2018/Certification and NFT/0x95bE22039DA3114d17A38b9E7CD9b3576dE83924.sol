['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    \n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b8caddd5dbd7f88a">[email&#160;protected]</a>Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '  \n', '}\n', '\n', '\n', '/// @dev Interface to the Core Contract of Ether Dungeon.\n', 'contract EDCoreInterface {\n', '\n', '    /// @dev The external function to get all the game settings in one call.\n', '    function getGameSettings() external view returns (\n', '        uint _recruitHeroFee,\n', '        uint _transportationFeeMultiplier,\n', '        uint _noviceDungeonId,\n', '        uint _consolationRewardsRequiredFaith,\n', '        uint _challengeFeeMultiplier,\n', '        uint _dungeonPreparationTime,\n', '        uint _trainingFeeMultiplier,\n', '        uint _equipmentTrainingFeeMultiplier,\n', '        uint _preparationPeriodTrainingFeeMultiplier,\n', '        uint _preparationPeriodEquipmentTrainingFeeMultiplier\n', '    );\n', '    \n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific player by its address.\n', '     * @param _address The address of the player.\n', '     */\n', '    function getPlayerDetails(address _address) external view returns (\n', '        uint dungeonId, \n', '        uint payment, \n', '        uint dungeonCount, \n', '        uint heroCount, \n', '        uint faith,\n', '        bool firstHeroRecruited\n', '    );\n', '    \n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\n', '     * @param _id The ID of the dungeon.\n', '     */\n', '    function getDungeonDetails(uint _id) external view returns (\n', '        uint creationTime, \n', '        uint status, \n', '        uint difficulty, \n', '        uint capacity, \n', '        address owner, \n', '        bool isReady, \n', '        uint playerCount\n', '    );\n', '    \n', '    /**\n', '     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\n', '     * @param _id The ID of the dungeon.\n', '     */\n', '    function getDungeonFloorDetails(uint _id) external view returns (\n', '        uint floorNumber, \n', '        uint floorCreationTime, \n', '        uint rewards, \n', '        uint seedGenes, \n', '        uint floorGenes\n', '    );\n', '\n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific hero by its ID.\n', '     * @param _id The ID of the hero.\n', '     */\n', '    function getHeroDetails(uint _id) external view returns (\n', '        uint creationTime, \n', '        uint cooldownStartTime, \n', '        uint cooldownIndex, \n', '        uint genes, \n', '        address owner, \n', '        bool isReady, \n', '        uint cooldownRemainingTime\n', '    );\n', '\n', '    /// @dev Get the attributes (equipments + stats) of a hero from its gene.\n', '    function getHeroAttributes(uint _genes) public pure returns (uint[]);\n', '    \n', '    /// @dev Calculate the power of a hero from its gene, it calculates the equipment power, stats power, and super hero boost.\n', '    function getHeroPower(uint _genes, uint _dungeonDifficulty) public pure returns (\n', '        uint totalPower, \n', '        uint equipmentPower, \n', '        uint statsPower, \n', '        bool isSuper, \n', '        uint superRank,\n', '        uint superBoost\n', '    );\n', '    \n', '    /// @dev Calculate the power of a dungeon floor.\n', '    function getDungeonPower(uint _genes) public pure returns (uint);\n', '    \n', '    /**\n', '     * @dev Calculate the sum of top 5 heroes power a player owns.\n', '     *  The gas usage increased with the number of heroes a player owned, roughly 500 x hero count.\n', '     *  This is used in transport function only to calculate the required tranport fee.\n', '     */\n', '    function calculateTop5HeroesPower(address _address, uint _dungeonId) public view returns (uint);\n', '    \n', '}\n', '\n', '\n', '/// @dev Core Contract of "Enter the Coliseum" game of the ED (Ether Dungeon) Platform.\n', 'contract EDColiseumAlpha is Pausable, ReentrancyGuard, Destructible {\n', '    \n', '    struct Participant {\n', '        address player;\n', '        uint heroId;\n', '        uint heroPower;\n', '    }\n', '    \n', '    /// @dev The address of the EtherDungeonCore contract.\n', '    EDCoreInterface public edCoreContract = EDCoreInterface(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\n', '    \n', '    /// @dev Seed for the random number generator used for calculating fighting result.\n', '    uint _seed;\n', '    \n', '    \n', '    /* ======== SETTINGS ======== */\n', '\n', '    /// @dev The required win count to win a jackpot.\n', '    uint public jackpotWinCount = 3;\n', '    \n', '    /// @dev The percentage of jackpot a player get when reaching the jackpotWinCount.\n', '    uint public jackpotWinPercent = 50;\n', '    \n', '    /// @dev The percentage of rewards a player get when being the final winner of a tournament.\n', '    uint public winPercent = 55;\n', '    \n', '    /// @dev The percentage of rewards a player get when being the final loser of a tournament, remaining will add to tournamentJackpot.\n', '    uint public losePercent = 35;\n', '    \n', '    /// @dev Dungeon difficulty to be used when calculating super hero power boost, 1 is no boost.\n', '    uint public dungeonDifficulty = 1;\n', '\n', '    /// @dev The required fee to join a participant\n', '    uint public participationFee = 0.02 ether;\n', '    \n', '    /// @dev The maximum number of participants for a tournament.\n', '    uint public constant maxParticipantCount = 8;\n', '    \n', '    \n', '    /* ======== STATE VARIABLES ======== */\n', '    \n', '    /// @dev The next tournaments round number.\n', '    uint public nextTournamentRound = 1;\n', '\n', '    /// @dev The current accumulated rewards pool.\n', '    uint public tournamentRewards;\n', '\n', '    /// @dev The current accumulated jackpot.\n', '    uint public tournamentJackpot = 0.2 ether;\n', '    \n', '    /// @dev Array of all the participant for next tournament.\n', '    Participant[] public participants;\n', '    \n', '    /// @dev Array of all the participant for the previous tournament.\n', '    Participant[] public previousParticipants;\n', '    \n', '    /// @dev Array to store the participant index all winners / losers for each "fighting round" of the previous tournament.\n', '    uint[maxParticipantCount / 2] public firstRoundWinners;\n', '    uint[maxParticipantCount / 4] public secondRoundWinners;\n', '    uint[maxParticipantCount / 2] public firstRoundLosers;\n', '    uint[maxParticipantCount / 4] public secondRoundLosers;\n', '    uint public finalWinner;\n', '    uint public finalLoser;\n', '    \n', '    /// @dev Mapping of hero ID to the hero&#39;s last participated tournament round to avoid repeated hero participation.\n', '    mapping(uint => uint) public heroIdToLastRound;\n', '    \n', '    /// @dev Mapping of player ID to the consecutive win counts, used for calculating jackpot.\n', '    mapping(address => uint) public playerToWinCounts;\n', '\n', '    \n', '    /* ======== EVENTS ======== */\n', '    \n', '    /// @dev The PlayerTransported event is fired when user transported to another dungeon.\n', '    event TournamentFinished(uint timestamp, uint tournamentRound, address finalWinner, address finalLoser, uint winnerRewards, uint loserRewards, uint winCount, uint jackpotRewards);\n', '    \n', '    /// @dev Payable constructor to pass in the initial jackpot ethers.\n', '    function EDColiseum() public payable {}\n', '\n', '    \n', '    /* ======== PUBLIC/EXTERNAL FUNCTIONS ======== */\n', '    \n', '    /// @dev The external function to get all the game settings in one call.\n', '    function getGameSettings() external view returns (\n', '        uint _jackpotWinCount,\n', '        uint _jackpotWinPercent,\n', '        uint _winPercent,\n', '        uint _losePercent,\n', '        uint _dungeonDifficulty,\n', '        uint _participationFee,\n', '        uint _maxParticipantCount\n', '    ) {\n', '        _jackpotWinCount = jackpotWinCount;\n', '        _jackpotWinPercent = jackpotWinPercent;\n', '        _winPercent = winPercent;\n', '        _losePercent = losePercent;\n', '        _dungeonDifficulty = dungeonDifficulty;\n', '        _participationFee = participationFee;\n', '        _maxParticipantCount = maxParticipantCount;\n', '    }\n', '    \n', '    /// @dev The external function to get all the game settings in one call.\n', '    function getNextTournamentData() external view returns (\n', '        uint _nextTournamentRound,\n', '        uint _tournamentRewards,\n', '        uint _tournamentJackpot,\n', '        uint _participantCount\n', '    ) {\n', '        _nextTournamentRound = nextTournamentRound;\n', '        _tournamentRewards = tournamentRewards;\n', '        _tournamentJackpot = tournamentJackpot;\n', '        _participantCount = participants.length;\n', '    }\n', '    \n', '    /// @dev The external function to call when joining the next tournament.\n', '    function joinTournament(uint _heroId) whenNotPaused nonReentrant external payable {\n', '        uint genes;\n', '        address owner;\n', '        (,,, genes, owner,,) = edCoreContract.getHeroDetails(_heroId);\n', '        \n', '        // Throws if the hero is not owned by the sender.\n', '        require(msg.sender == owner);\n', '        \n', '        // Throws if the hero is already participated in the next tournament.\n', '        require(heroIdToLastRound[_heroId] != nextTournamentRound);\n', '        \n', '        // Throws if participation count is full.\n', '        require(participants.length < maxParticipantCount);\n', '        \n', '        // Throws if payment not enough, any exceeding funds will be transferred back to the player.\n', '        require(msg.value >= participationFee);\n', '        tournamentRewards += participationFee;\n', '\n', '        if (msg.value > participationFee) {\n', '            msg.sender.transfer(msg.value - participationFee);\n', '        }\n', '        \n', '        // Set the hero participation round.\n', '        heroIdToLastRound[_heroId] = nextTournamentRound;\n', '        \n', '        // Get the hero power and set it to storage.\n', '        uint heroPower;\n', '        (heroPower,,,,) = edCoreContract.getHeroPower(genes, dungeonDifficulty);\n', '        \n', '        // Throw if heroPower is 12 (novice hero).\n', '        require(heroPower > 12);\n', '        \n', '        // Set the participant data to storage.\n', '        participants.push(Participant(msg.sender, _heroId, heroPower));\n', '    }\n', '    \n', '    /// @dev The onlyOwner external function to call when joining the next tournament.\n', '    function startTournament() onlyOwner nonReentrant external {\n', '        // Throws if participation count is not full.\n', '        require(participants.length == maxParticipantCount);\n', '        \n', '        // FIGHT!\n', '        _firstRoundFight();\n', '        _secondRoundWinnersFight();\n', '        _secondRoundLosersFight();\n', '        _finalRoundWinnersFight();\n', '        _finalRoundLosersFight();\n', '        \n', '        // REWARDS!\n', '        uint winnerRewards = tournamentRewards * winPercent / 100;\n', '        uint loserRewards = tournamentRewards * losePercent / 100;\n', '        uint addToJackpot = tournamentRewards - winnerRewards - loserRewards;\n', '        \n', '        address winner = participants[finalWinner].player;\n', '        address loser = participants[finalLoser].player;\n', '        winner.transfer(winnerRewards);\n', '        loser.transfer(loserRewards);\n', '        tournamentJackpot += addToJackpot;\n', '        \n', '        // JACKPOT!\n', '        playerToWinCounts[winner]++;\n', '        \n', '        // Reset other participants&#39; consecutive winCount.\n', '        for (uint i = 0; i < participants.length; i++) {\n', '            address participant = participants[i].player;\n', '            \n', '            if (participant != winner && playerToWinCounts[participant] != 0) {\n', '                playerToWinCounts[participant] = 0;\n', '            }\n', '        }\n', '        \n', '        // Detemine if the winner have enough consecutive winnings for jackpot.\n', '        uint jackpotRewards;\n', '        uint winCount = playerToWinCounts[winner];\n', '        if (winCount == jackpotWinCount) {\n', '            // Reset consecutive winCount of winner.\n', '            playerToWinCounts[winner] = 0;\n', '            \n', '            jackpotRewards = tournamentJackpot * jackpotWinPercent / 100;\n', '            tournamentJackpot -= jackpotRewards;\n', '            \n', '            winner.transfer(jackpotRewards);\n', '        }\n', '        \n', '        // Reset tournament data and increment round.\n', '        tournamentRewards = 0;\n', '        previousParticipants = participants;\n', '        participants.length = 0;\n', '        nextTournamentRound++;\n', '        \n', '        // Emit TournamentFinished event.\n', '        TournamentFinished(now, nextTournamentRound - 1, winner, loser, winnerRewards, loserRewards, winCount, jackpotRewards);\n', '    }\n', '    \n', '    /// @dev The onlyOwner external function to call to cancel the next tournament and refunds.\n', '    function cancelTournament() onlyOwner nonReentrant external {\n', '        for (uint i = 0; i < participants.length; i++) {\n', '            address participant = participants[i].player;\n', '            \n', '            if (participant != 0x0) {\n', '                participant.transfer(participationFee);\n', '            }\n', '        }\n', '        \n', '        // Reset tournament data and increment round.\n', '        tournamentRewards = 0;\n', '        participants.length = 0;\n', '        nextTournamentRound++;\n', '    }\n', '    \n', '    /// @dev Withdraw all Ether from the contract.\n', '    function withdrawBalance() onlyOwner external {\n', '        // Can only withdraw if no participants joined (i.e. call cancelTournament first.)\n', '        require(participants.length == 0);\n', '        \n', '        msg.sender.transfer(this.balance);\n', '    }\n', '\n', '    /* ======== SETTER FUNCTIONS ======== */\n', '    \n', '    function setEdCoreContract(address _newEdCoreContract) onlyOwner external {\n', '        edCoreContract = EDCoreInterface(_newEdCoreContract);\n', '    }\n', '    \n', '    function setJackpotWinCount(uint _newJackpotWinCount) onlyOwner external {\n', '        jackpotWinCount = _newJackpotWinCount;\n', '    }\n', '    \n', '    function setJackpotWinPercent(uint _newJackpotWinPercent) onlyOwner external {\n', '        jackpotWinPercent = _newJackpotWinPercent;\n', '    }\n', '    \n', '    function setWinPercent(uint _newWinPercent) onlyOwner external {\n', '        winPercent = _newWinPercent;\n', '    }\n', '    \n', '    function setLosePercent(uint _newLosePercent) onlyOwner external {\n', '        losePercent = _newLosePercent;\n', '    }\n', '    \n', '    function setDungeonDifficulty(uint _newDungeonDifficulty) onlyOwner external {\n', '        dungeonDifficulty = _newDungeonDifficulty;\n', '    }\n', '    \n', '    function setParticipationFee(uint _newParticipationFee) onlyOwner external {\n', '        participationFee = _newParticipationFee;\n', '    }\n', '    \n', '    /* ======== INTERNAL/PRIVATE FUNCTIONS ======== */\n', '    \n', '    /// @dev Compute all winners and losers for the first round.\n', '    function _firstRoundFight() private {\n', '        // Get all hero powers.\n', '        uint heroPower0 = participants[0].heroPower;\n', '        uint heroPower1 = participants[1].heroPower;\n', '        uint heroPower2 = participants[2].heroPower;\n', '        uint heroPower3 = participants[3].heroPower;\n', '        uint heroPower4 = participants[4].heroPower;\n', '        uint heroPower5 = participants[5].heroPower;\n', '        uint heroPower6 = participants[6].heroPower;\n', '        uint heroPower7 = participants[7].heroPower;\n', '        \n', '        // Random number.\n', '        uint rand;\n', '        \n', '        // 0 Vs 1\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower0 > heroPower1 && rand < 60) || \n', '            (heroPower0 == heroPower1 && rand < 50) ||\n', '            (heroPower0 < heroPower1 && rand < 40)\n', '        ) {\n', '            firstRoundWinners[0] = 0;\n', '            firstRoundLosers[0] = 1;\n', '        } else {\n', '            firstRoundWinners[0] = 1;\n', '            firstRoundLosers[0] = 0;\n', '        }\n', '        \n', '        // 2 Vs 3\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower2 > heroPower3 && rand < 60) || \n', '            (heroPower2 == heroPower3 && rand < 50) ||\n', '            (heroPower2 < heroPower3 && rand < 40)\n', '        ) {\n', '            firstRoundWinners[1] = 2;\n', '            firstRoundLosers[1] = 3;\n', '        } else {\n', '            firstRoundWinners[1] = 3;\n', '            firstRoundLosers[1] = 2;\n', '        }\n', '        \n', '        // 4 Vs 5\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower4 > heroPower5 && rand < 60) || \n', '            (heroPower4 == heroPower5 && rand < 50) ||\n', '            (heroPower4 < heroPower5 && rand < 40)\n', '        ) {\n', '            firstRoundWinners[2] = 4;\n', '            firstRoundLosers[2] = 5;\n', '        } else {\n', '            firstRoundWinners[2] = 5;\n', '            firstRoundLosers[2] = 4;\n', '        }\n', '        \n', '        // 6 Vs 7\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower6 > heroPower7 && rand < 60) || \n', '            (heroPower6 == heroPower7 && rand < 50) ||\n', '            (heroPower6 < heroPower7 && rand < 40)\n', '        ) {\n', '            firstRoundWinners[3] = 6;\n', '            firstRoundLosers[3] = 7;\n', '        } else {\n', '            firstRoundWinners[3] = 7;\n', '            firstRoundLosers[3] = 6;\n', '        }\n', '    }\n', '    \n', '    /// @dev Compute all second winners of all first round winners.\n', '    function _secondRoundWinnersFight() private {\n', '        // Get all hero powers of all first round winners.\n', '        uint winner0 = firstRoundWinners[0];\n', '        uint winner1 = firstRoundWinners[1];\n', '        uint winner2 = firstRoundWinners[2];\n', '        uint winner3 = firstRoundWinners[3];\n', '        uint heroPower0 = participants[winner0].heroPower;\n', '        uint heroPower1 = participants[winner1].heroPower;\n', '        uint heroPower2 = participants[winner2].heroPower;\n', '        uint heroPower3 = participants[winner3].heroPower;\n', '        \n', '        // Random number.\n', '        uint rand;\n', '        \n', '        // 0 Vs 1\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower0 > heroPower1 && rand < 60) || \n', '            (heroPower0 == heroPower1 && rand < 50) ||\n', '            (heroPower0 < heroPower1 && rand < 40)\n', '        ) {\n', '            secondRoundWinners[0] = winner0;\n', '        } else {\n', '            secondRoundWinners[0] = winner1;\n', '        }\n', '        \n', '        // 2 Vs 3\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower2 > heroPower3 && rand < 60) || \n', '            (heroPower2 == heroPower3 && rand < 50) ||\n', '            (heroPower2 < heroPower3 && rand < 40)\n', '        ) {\n', '            secondRoundWinners[1] = winner2;\n', '        } else {\n', '            secondRoundWinners[1] = winner3;\n', '        }\n', '    }\n', '    \n', '    /// @dev Compute all second losers of all first round losers.\n', '    function _secondRoundLosersFight() private {\n', '        // Get all hero powers of all first round losers.\n', '        uint loser0 = firstRoundLosers[0];\n', '        uint loser1 = firstRoundLosers[1];\n', '        uint loser2 = firstRoundLosers[2];\n', '        uint loser3 = firstRoundLosers[3];\n', '        uint heroPower0 = participants[loser0].heroPower;\n', '        uint heroPower1 = participants[loser1].heroPower;\n', '        uint heroPower2 = participants[loser2].heroPower;\n', '        uint heroPower3 = participants[loser3].heroPower;\n', '        \n', '        // Random number.\n', '        uint rand;\n', '        \n', '        // 0 Vs 1\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower0 > heroPower1 && rand < 60) || \n', '            (heroPower0 == heroPower1 && rand < 50) ||\n', '            (heroPower0 < heroPower1 && rand < 40)\n', '        ) {\n', '            secondRoundLosers[0] = loser1;\n', '        } else {\n', '            secondRoundLosers[0] = loser0;\n', '        }\n', '        \n', '        // 2 Vs 3\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower2 > heroPower3 && rand < 60) || \n', '            (heroPower2 == heroPower3 && rand < 50) ||\n', '            (heroPower2 < heroPower3 && rand < 40)\n', '        ) {\n', '            secondRoundLosers[1] = loser3;\n', '        } else {\n', '            secondRoundLosers[1] = loser2;\n', '        }\n', '    }\n', '    \n', '    /// @dev Compute the final winner.\n', '    function _finalRoundWinnersFight() private {\n', '        // Get all hero powers of all first round winners.\n', '        uint winner0 = secondRoundWinners[0];\n', '        uint winner1 = secondRoundWinners[1];\n', '        uint heroPower0 = participants[winner0].heroPower;\n', '        uint heroPower1 = participants[winner1].heroPower;\n', '        \n', '        // Random number.\n', '        uint rand;\n', '        \n', '        // 0 Vs 1\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower0 > heroPower1 && rand < 60) || \n', '            (heroPower0 == heroPower1 && rand < 50) ||\n', '            (heroPower0 < heroPower1 && rand < 40)\n', '        ) {\n', '            finalWinner = winner0;\n', '        } else {\n', '            finalWinner = winner1;\n', '        }\n', '    }\n', '    \n', '    /// @dev Compute the final loser.\n', '    function _finalRoundLosersFight() private {\n', '        // Get all hero powers of all first round winners.\n', '        uint loser0 = secondRoundLosers[0];\n', '        uint loser1 = secondRoundLosers[1];\n', '        uint heroPower0 = participants[loser0].heroPower;\n', '        uint heroPower1 = participants[loser1].heroPower;\n', '        \n', '        // Random number.\n', '        uint rand;\n', '        \n', '        // 0 Vs 1\n', '        rand = _getRandomNumber(100);\n', '        if (\n', '            (heroPower0 > heroPower1 && rand < 60) || \n', '            (heroPower0 == heroPower1 && rand < 50) ||\n', '            (heroPower0 < heroPower1 && rand < 40)\n', '        ) {\n', '            finalLoser = loser1;\n', '        } else {\n', '            finalLoser = loser0;\n', '        }\n', '    }\n', '    \n', '    // @dev Return a pseudo random uint smaller than lower bounds.\n', '    function _getRandomNumber(uint _upper) private returns (uint) {\n', '        _seed = uint(keccak256(\n', '            _seed,\n', '            block.blockhash(block.number - 1),\n', '            block.coinbase,\n', '            block.difficulty\n', '        ));\n', '        \n', '        return _seed % _upper;\n', '    }\n', '\n', '}']