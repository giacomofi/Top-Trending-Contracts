['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/grapevine/crowdsale/GrapevineWhitelistInterface.sol\n', '\n', '/**\n', ' * @title Grapevine Whitelist extends the zeppelin Whitelist and adding off-chain signing capabilities.\n', ' * @dev Grapevine Crowdsale\n', ' **/\n', 'contract GrapevineWhitelistInterface {\n', '\n', '  /**\n', '   * @dev Function to check if an address is whitelisted or not\n', '   * @param _address address The address to be checked.\n', '   */\n', '  function whitelist(address _address) view external returns (bool);\n', '\n', ' \n', '  /**\n', '   * @dev Handles the off-chain whitelisting.\n', '   * @param _addr Address of the sender.\n', '   * @param _sig signed message provided by the sender.\n', '   */\n', '  function handleOffchainWhitelisted(address _addr, bytes _sig) external returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ECRecovery.sol\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      "\\x19Ethereum Signed Message:\\n32",\n', '      hash\n', '    );\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', ' * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n', ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/SignatureBouncer.sol\n', '\n', '/**\n', ' * @title SignatureBouncer\n', ' * @author PhABC and Shrugs\n', ' * @dev Bouncer allows users to submit a signature as a permission to do an action.\n', ' * If the signature is from one of the authorized bouncer addresses, the signature\n', ' * is valid. The owner of the contract adds/removes bouncers.\n', ' * Bouncer addresses can be individual servers signing grants or different\n', ' * users within a decentralized club that have permission to invite other members.\n', ' * \n', ' * This technique is useful for whitelists and airdrops; instead of putting all\n', ' * valid addresses on-chain, simply sign a grant of the form\n', ' * keccak256(`:contractAddress` + `:granteeAddress`) using a valid bouncer address.\n', ' * Then restrict access to your crowdsale/whitelist/airdrop using the\n', ' * `onlyValidSignature` modifier (or implement your own using isValidSignature).\n', ' * \n', ' * See the tests Bouncer.test.js for specific usage examples.\n', ' */\n', 'contract SignatureBouncer is Ownable, RBAC {\n', '  using ECRecovery for bytes32;\n', '\n', '  string public constant ROLE_BOUNCER = "bouncer";\n', '\n', '  /**\n', '   * @dev requires that a valid signature of a bouncer was provided\n', '   */\n', '  modifier onlyValidSignature(bytes _sig)\n', '  {\n', '    require(isValidSignature(msg.sender, _sig));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev allows the owner to add additional bouncer addresses\n', '   */\n', '  function addBouncer(address _bouncer)\n', '    onlyOwner\n', '    public\n', '  {\n', '    require(_bouncer != address(0));\n', '    addRole(_bouncer, ROLE_BOUNCER);\n', '  }\n', '\n', '  /**\n', '   * @dev allows the owner to remove bouncer addresses\n', '   */\n', '  function removeBouncer(address _bouncer)\n', '    onlyOwner\n', '    public\n', '  {\n', '    require(_bouncer != address(0));\n', '    removeRole(_bouncer, ROLE_BOUNCER);\n', '  }\n', '\n', '  /**\n', '   * @dev is the signature of `this + sender` from a bouncer?\n', '   * @return bool\n', '   */\n', '  function isValidSignature(address _address, bytes _sig)\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    return isValidDataHash(\n', '      keccak256(address(this), _address),\n', '      _sig\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev internal function to convert a hash to an eth signed message\n', '   * @dev and then recover the signature and check it against the bouncer role\n', '   * @return bool\n', '   */\n', '  function isValidDataHash(bytes32 hash, bytes _sig)\n', '    internal\n', '    view\n', '    returns (bool)\n', '  {\n', '    address signer = hash\n', '      .toEthSignedMessageHash()\n', '      .recover(_sig);\n', '    return hasRole(signer, ROLE_BOUNCER);\n', '  }\n', '}\n', '\n', '// File: contracts/grapevine/crowdsale/GrapevineWhitelist.sol\n', '\n', '/**\n', ' * @title Grapevine Whitelist extends the zeppelin Whitelist and adding off-chain signing capabilities.\n', ' * @dev Grapevine Crowdsale\n', ' **/\n', 'contract GrapevineWhitelist is SignatureBouncer, GrapevineWhitelistInterface {\n', '\n', '  event WhitelistedAddressAdded(address addr);\n', '  event WhitelistedAddressRemoved(address addr);\n', '  event UselessEvent(address addr, bytes sign, bool ret);\n', '\n', '  mapping(address => bool) public whitelist;\n', '\n', '  address crowdsale;\n', '\n', '  constructor(address _signer) public {\n', '    require(_signer != address(0));\n', '    addBouncer(_signer);\n', '  }\n', '\n', '  modifier onlyOwnerOrCrowdsale() {\n', '    require(msg.sender == owner || msg.sender == crowdsale);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check if an address is whitelisted\n', '   * @param _address address The address to be checked.\n', '   */\n', '  function whitelist(address _address) view external returns (bool) {\n', '    return whitelist[_address];\n', '  }\n', '  \n', '  /**\n', '   * @dev Function to set the crowdsale address\n', '   * @param _crowdsale address The address of the crowdsale.\n', '   */\n', '  function setCrowdsale(address _crowdsale) external onlyOwner {\n', '    require(_crowdsale != address(0));\n', '    crowdsale = _crowdsale;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing.\n', '   * @param _beneficiaries Addresses to be added to the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] _beneficiaries) external onlyOwnerOrCrowdsale {\n', '    for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '      addAddressToWhitelist(_beneficiaries[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Removes single address from whitelist.\n', '   * @param _beneficiary Address to be removed to the whitelist\n', '   */\n', '  function removeAddressFromWhitelist(address _beneficiary) external onlyOwnerOrCrowdsale {\n', '    whitelist[_beneficiary] = false;\n', '    emit WhitelistedAddressRemoved(_beneficiary);\n', '  }\n', '\n', '  /**\n', '   * @dev Handles the off-chain whitelisting.\n', '   * @param _addr Address of the sender.\n', '   * @param _sig signed message provided by the sender.\n', '   */\n', '  function handleOffchainWhitelisted(address _addr, bytes _sig) external onlyOwnerOrCrowdsale returns (bool) {\n', '    bool valid;\n', '    // no need for consuming gas when the address is already whitelisted \n', '    if (whitelist[_addr]) {\n', '      valid = true;\n', '    } else {\n', '      valid = isValidSignature(_addr, _sig);\n', '      if (valid) {\n', '        // no need for consuming gas again if the address calls the contract again. \n', '        addAddressToWhitelist(_addr);\n', '      }\n', '    }\n', '    return valid;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds single address to whitelist.\n', '   * @param _beneficiary Address to be added to the whitelist\n', '   */\n', '  function addAddressToWhitelist(address _beneficiary) public onlyOwnerOrCrowdsale {\n', '    whitelist[_beneficiary] = true;\n', '    emit WhitelistedAddressAdded(_beneficiary);\n', '  }\n', '}']