['pragma solidity ^0.4.24;\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external returns(bool);\n', '    function balanceOf(address who) external returns(uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns(bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string AddrName) external returns(address);\n', '}\n', '\n', 'contract Registry {\n', '    address public RegistryAddress;\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == getAddress("admin"));\n', '        _;\n', '    }\n', '    function getAddress(string AddressName) internal view returns(address) {\n', '        AddressRegistry aRegistry = AddressRegistry(RegistryAddress);\n', '        address realAddress = aRegistry.getAddr(AddressName);\n', '        require(realAddress != address(0));\n', '        return realAddress;\n', '    }\n', '}\n', '\n', 'contract Deposit is Registry {\n', '\n', '    bool public Paused;\n', '    function setPause(bool isPaused) onlyAdmin public {\n', '        Paused = isPaused;\n', '    }\n', '    modifier paused() {\n', '        require(!Paused);\n', '        _;\n', '    }\n', '\n', '    event eDeposit(address Investor, uint value);\n', '\n', '    // wei per MTU // rate will be 0 to stop minting\n', '    uint256 public claimRate;\n', '    uint256 public ethRaised;\n', '    uint256 public unClaimedEther;\n', '    uint256 public ClaimingTimeLimit;\n', '    bool public isCharged = true;\n', '\n', '    mapping(address => uint256) public Investors;\n', '\n', '    function setCharge(bool chargeBool) onlyAdmin public {\n', '        isCharged = chargeBool;\n', '    }\n', '\n', '    function SetClaimRate(uint256 weiAmt) onlyAdmin public {\n', '        claimRate = weiAmt;\n', '        // 7 days into seconds to currenct time in unix epoch seconds\n', '        ClaimingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;\n', '    }\n', '\n', '    // accepting deposits\n', '    function () paused public payable {\n', '        require(block.timestamp > ClaimingTimeLimit);\n', '        Investors[msg.sender] += msg.value;\n', '        unClaimedEther += msg.value;\n', '        emit eDeposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function getClaimEst(address Claimer) public view returns(uint256 ClaimEstimate) {\n', '        uint NoOfMTU = Investors[Claimer] / claimRate;\n', '        return NoOfMTU;\n', '    }\n', '\n', '    // claim your MTU or Ether\n', '    function ClaimMTU(bool claim) paused public {\n', '        uint256 ethVal = Investors[msg.sender];\n', '        require(ethVal >= claimRate);\n', '        if (claim) {\n', '            require(claimRate > 0);\n', '            require(block.timestamp < ClaimingTimeLimit);\n', '            ethRaised += ethVal;\n', '            uint256 claimTokens = ethVal / claimRate;\n', '            address tokenAddress = getAddress("unit");\n', '            token tokenTransfer = token(tokenAddress);\n', '            tokenTransfer.transfer(msg.sender, claimTokens);\n', '            if (isCharged) {getAddress("team").transfer(ethVal / 20);}\n', '        } else {\n', '            msg.sender.transfer(ethVal);\n', '        }\n', '        Investors[msg.sender] -= ethVal;\n', '        unClaimedEther -= ethVal;\n', '    }\n', '\n', '}\n', '\n', 'contract Redeem is Deposit {\n', '\n', '    event eAllowedMTU(address LeavingAway, uint NoOfTokens);\n', '    event eRedeem(address Investor, uint NoOfTokens, uint withdrawVal);\n', '\n', '    // wei per MTU // rate will be 0 to stop redeeming\n', '    uint256 public redeemRate;\n', '    uint256 public ethRedeemed;\n', '    uint256 public unRedeemedMTU;\n', '    uint256 public RedeemingTimeLimit;\n', '\n', '    mapping(address => uint256) public Redeemer;    \n', '    \n', '    function SetRedeemRate(uint256 weiAmt) onlyAdmin public {\n', '        redeemRate = weiAmt;\n', '        // 7 days into seconds to currenct time in unix epoch seconds\n', '        RedeemingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;\n', '    }\n', '\n', '    // allow MTU transfer\n', '    function DepositMTU(uint256 NoOfTokens) paused public {\n', '        require(block.timestamp > RedeemingTimeLimit);\n', '        address tokenAddress = getAddress("unit");\n', '        token tokenFunction = token(tokenAddress);\n', '        tokenFunction.transferFrom(msg.sender, address(this), NoOfTokens);\n', '        unRedeemedMTU += NoOfTokens;\n', '        Redeemer[msg.sender] += NoOfTokens;\n', '        emit eAllowedMTU(msg.sender, NoOfTokens);\n', '    }\n', '\n', '    // redeem MTU\n', '    function RedeemMTU(bool redeem) paused public {\n', '        uint256 AppliedUnits = Redeemer[msg.sender];\n', '        require(AppliedUnits > 0);\n', '        address tokenAddress = getAddress("unit");\n', '        token tokenFunction = token(tokenAddress);\n', '        if (redeem) {\n', '            require(block.timestamp < RedeemingTimeLimit);\n', '            require(redeemRate > 0);\n', '            uint256 withdrawVal = AppliedUnits * redeemRate;\n', '            ethRedeemed += withdrawVal;\n', '            msg.sender.transfer(withdrawVal);\n', '            emit eRedeem(msg.sender, AppliedUnits, withdrawVal);\n', '        } else {\n', '            tokenFunction.transfer(msg.sender, AppliedUnits);\n', '        }\n', '        Redeemer[msg.sender] = 0;\n', '        unRedeemedMTU -= AppliedUnits;\n', '    }\n', '\n', '    function getRedeemEst(address Claimer, uint256 NoOfTokens) public view returns(uint256 RedeemEstimate) {\n', '        uint WithdrawEther = redeemRate * NoOfTokens;\n', '        return WithdrawEther;\n', '    }\n', '\n', '}\n', '\n', 'contract MoatFund is Redeem {\n', '\n', '    event eNonIssueDeposits(address sender, uint value);\n', '\n', '    constructor(uint256 PrevRaisedEther, address rAddress) public {\n', '        ethRaised = PrevRaisedEther; // the ether raised value of previous smart contract\n', '        RegistryAddress = rAddress;\n', '    }\n', '\n', '    // for non issuance deposits\n', '    function NonIssueDeposits() public payable {\n', '        emit eNonIssueDeposits(msg.sender, msg.value);\n', '    }\n', '\n', '    function SendEtherToBoard(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);        \n', '        getAddress("board").transfer(weiAmt);\n', '    }\n', '\n', '    function SendEtherToAsset(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);\n', '        getAddress("asset").transfer(weiAmt);\n', '    }\n', '\n', '    function SendEtherToDex(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);        \n', '        getAddress("dex").transfer(weiAmt);\n', '    }\n', '\n', '    function SendERC20ToAsset(address tokenAddress) onlyAdmin public {\n', '        token tokenFunctions = token(tokenAddress);\n', '        uint256 tokenBal = tokenFunctions.balanceOf(address(this));\n', '        tokenFunctions.transfer(getAddress("asset"), tokenBal);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external returns(bool);\n', '    function balanceOf(address who) external returns(uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns(bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string AddrName) external returns(address);\n', '}\n', '\n', 'contract Registry {\n', '    address public RegistryAddress;\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == getAddress("admin"));\n', '        _;\n', '    }\n', '    function getAddress(string AddressName) internal view returns(address) {\n', '        AddressRegistry aRegistry = AddressRegistry(RegistryAddress);\n', '        address realAddress = aRegistry.getAddr(AddressName);\n', '        require(realAddress != address(0));\n', '        return realAddress;\n', '    }\n', '}\n', '\n', 'contract Deposit is Registry {\n', '\n', '    bool public Paused;\n', '    function setPause(bool isPaused) onlyAdmin public {\n', '        Paused = isPaused;\n', '    }\n', '    modifier paused() {\n', '        require(!Paused);\n', '        _;\n', '    }\n', '\n', '    event eDeposit(address Investor, uint value);\n', '\n', '    // wei per MTU // rate will be 0 to stop minting\n', '    uint256 public claimRate;\n', '    uint256 public ethRaised;\n', '    uint256 public unClaimedEther;\n', '    uint256 public ClaimingTimeLimit;\n', '    bool public isCharged = true;\n', '\n', '    mapping(address => uint256) public Investors;\n', '\n', '    function setCharge(bool chargeBool) onlyAdmin public {\n', '        isCharged = chargeBool;\n', '    }\n', '\n', '    function SetClaimRate(uint256 weiAmt) onlyAdmin public {\n', '        claimRate = weiAmt;\n', '        // 7 days into seconds to currenct time in unix epoch seconds\n', '        ClaimingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;\n', '    }\n', '\n', '    // accepting deposits\n', '    function () paused public payable {\n', '        require(block.timestamp > ClaimingTimeLimit);\n', '        Investors[msg.sender] += msg.value;\n', '        unClaimedEther += msg.value;\n', '        emit eDeposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function getClaimEst(address Claimer) public view returns(uint256 ClaimEstimate) {\n', '        uint NoOfMTU = Investors[Claimer] / claimRate;\n', '        return NoOfMTU;\n', '    }\n', '\n', '    // claim your MTU or Ether\n', '    function ClaimMTU(bool claim) paused public {\n', '        uint256 ethVal = Investors[msg.sender];\n', '        require(ethVal >= claimRate);\n', '        if (claim) {\n', '            require(claimRate > 0);\n', '            require(block.timestamp < ClaimingTimeLimit);\n', '            ethRaised += ethVal;\n', '            uint256 claimTokens = ethVal / claimRate;\n', '            address tokenAddress = getAddress("unit");\n', '            token tokenTransfer = token(tokenAddress);\n', '            tokenTransfer.transfer(msg.sender, claimTokens);\n', '            if (isCharged) {getAddress("team").transfer(ethVal / 20);}\n', '        } else {\n', '            msg.sender.transfer(ethVal);\n', '        }\n', '        Investors[msg.sender] -= ethVal;\n', '        unClaimedEther -= ethVal;\n', '    }\n', '\n', '}\n', '\n', 'contract Redeem is Deposit {\n', '\n', '    event eAllowedMTU(address LeavingAway, uint NoOfTokens);\n', '    event eRedeem(address Investor, uint NoOfTokens, uint withdrawVal);\n', '\n', '    // wei per MTU // rate will be 0 to stop redeeming\n', '    uint256 public redeemRate;\n', '    uint256 public ethRedeemed;\n', '    uint256 public unRedeemedMTU;\n', '    uint256 public RedeemingTimeLimit;\n', '\n', '    mapping(address => uint256) public Redeemer;    \n', '    \n', '    function SetRedeemRate(uint256 weiAmt) onlyAdmin public {\n', '        redeemRate = weiAmt;\n', '        // 7 days into seconds to currenct time in unix epoch seconds\n', '        RedeemingTimeLimit = block.timestamp + 7 * 24 * 60 * 60;\n', '    }\n', '\n', '    // allow MTU transfer\n', '    function DepositMTU(uint256 NoOfTokens) paused public {\n', '        require(block.timestamp > RedeemingTimeLimit);\n', '        address tokenAddress = getAddress("unit");\n', '        token tokenFunction = token(tokenAddress);\n', '        tokenFunction.transferFrom(msg.sender, address(this), NoOfTokens);\n', '        unRedeemedMTU += NoOfTokens;\n', '        Redeemer[msg.sender] += NoOfTokens;\n', '        emit eAllowedMTU(msg.sender, NoOfTokens);\n', '    }\n', '\n', '    // redeem MTU\n', '    function RedeemMTU(bool redeem) paused public {\n', '        uint256 AppliedUnits = Redeemer[msg.sender];\n', '        require(AppliedUnits > 0);\n', '        address tokenAddress = getAddress("unit");\n', '        token tokenFunction = token(tokenAddress);\n', '        if (redeem) {\n', '            require(block.timestamp < RedeemingTimeLimit);\n', '            require(redeemRate > 0);\n', '            uint256 withdrawVal = AppliedUnits * redeemRate;\n', '            ethRedeemed += withdrawVal;\n', '            msg.sender.transfer(withdrawVal);\n', '            emit eRedeem(msg.sender, AppliedUnits, withdrawVal);\n', '        } else {\n', '            tokenFunction.transfer(msg.sender, AppliedUnits);\n', '        }\n', '        Redeemer[msg.sender] = 0;\n', '        unRedeemedMTU -= AppliedUnits;\n', '    }\n', '\n', '    function getRedeemEst(address Claimer, uint256 NoOfTokens) public view returns(uint256 RedeemEstimate) {\n', '        uint WithdrawEther = redeemRate * NoOfTokens;\n', '        return WithdrawEther;\n', '    }\n', '\n', '}\n', '\n', 'contract MoatFund is Redeem {\n', '\n', '    event eNonIssueDeposits(address sender, uint value);\n', '\n', '    constructor(uint256 PrevRaisedEther, address rAddress) public {\n', '        ethRaised = PrevRaisedEther; // the ether raised value of previous smart contract\n', '        RegistryAddress = rAddress;\n', '    }\n', '\n', '    // for non issuance deposits\n', '    function NonIssueDeposits() public payable {\n', '        emit eNonIssueDeposits(msg.sender, msg.value);\n', '    }\n', '\n', '    function SendEtherToBoard(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);        \n', '        getAddress("board").transfer(weiAmt);\n', '    }\n', '\n', '    function SendEtherToAsset(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);\n', '        getAddress("asset").transfer(weiAmt);\n', '    }\n', '\n', '    function SendEtherToDex(uint256 weiAmt) onlyAdmin public {\n', '        require(address(this).balance > unClaimedEther);        \n', '        getAddress("dex").transfer(weiAmt);\n', '    }\n', '\n', '    function SendERC20ToAsset(address tokenAddress) onlyAdmin public {\n', '        token tokenFunctions = token(tokenAddress);\n', '        uint256 tokenBal = tokenFunctions.balanceOf(address(this));\n', '        tokenFunctions.transfer(getAddress("asset"), tokenBal);\n', '    }\n', '\n', '}']
