['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/libraries/PermissionsLib.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 Dharma Labs Inc.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '/**\n', ' *  Note(kayvon): these events are emitted by our PermissionsLib, but all contracts that\n', ' *  depend on the library must also define the events in order for web3 clients to pick them up.\n', ' *  This topic is discussed in greater detail here (under the section "Events and Libraries"):\n', ' *  https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736\n', ' */\n', 'contract PermissionEvents {\n', '    event Authorized(address indexed agent, string callingContext);\n', '    event AuthorizationRevoked(address indexed agent, string callingContext);\n', '}\n', '\n', '\n', 'library PermissionsLib {\n', '\n', '    // TODO(kayvon): remove these events and inherit from PermissionEvents when libraries are\n', '    // capable of inheritance.\n', '    // See relevant github issue here: https://github.com/ethereum/solidity/issues/891\n', '    event Authorized(address indexed agent, string callingContext);\n', '    event AuthorizationRevoked(address indexed agent, string callingContext);\n', '\n', '    struct Permissions {\n', '        mapping (address => bool) authorized;\n', '        mapping (address => uint) agentToIndex; // ensures O(1) look-up\n', '        address[] authorizedAgents;\n', '    }\n', '\n', '    function authorize(\n', '        Permissions storage self,\n', '        address agent,\n', '        string callingContext\n', '    )\n', '        internal\n', '    {\n', '        require(isNotAuthorized(self, agent));\n', '\n', '        self.authorized[agent] = true;\n', '        self.authorizedAgents.push(agent);\n', '        self.agentToIndex[agent] = self.authorizedAgents.length - 1;\n', '        Authorized(agent, callingContext);\n', '    }\n', '\n', '    function revokeAuthorization(\n', '        Permissions storage self,\n', '        address agent,\n', '        string callingContext\n', '    )\n', '        internal\n', '    {\n', '        /* We only want to do work in the case where the agent whose\n', '        authorization is being revoked had authorization permissions in the\n', '        first place. */\n', '        require(isAuthorized(self, agent));\n', '\n', '        uint indexOfAgentToRevoke = self.agentToIndex[agent];\n', '        uint indexOfAgentToMove = self.authorizedAgents.length - 1;\n', '        address agentToMove = self.authorizedAgents[indexOfAgentToMove];\n', '\n', '        // Revoke the agent&#39;s authorization.\n', '        delete self.authorized[agent];\n', '\n', '        // Remove the agent from our collection of authorized agents.\n', '        self.authorizedAgents[indexOfAgentToRevoke] = agentToMove;\n', '\n', '        // Update our indices to reflect the above changes.\n', '        self.agentToIndex[agentToMove] = indexOfAgentToRevoke;\n', '        delete self.agentToIndex[agent];\n', '\n', '        // Clean up memory that&#39;s no longer being used.\n', '        delete self.authorizedAgents[indexOfAgentToMove];\n', '        self.authorizedAgents.length -= 1;\n', '\n', '        AuthorizationRevoked(agent, callingContext);\n', '    }\n', '\n', '    function isAuthorized(Permissions storage self, address agent)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return self.authorized[agent];\n', '    }\n', '\n', '    function isNotAuthorized(Permissions storage self, address agent)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return !isAuthorized(self, agent);\n', '    }\n', '\n', '    function getAuthorizedAgents(Permissions storage self)\n', '        internal\n', '        view\n', '        returns (address[])\n', '    {\n', '        return self.authorizedAgents;\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/DebtRegistry.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 Dharma Labs Inc.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * The DebtRegistry stores the parameters and beneficiaries of all debt agreements in\n', ' * Dharma protocol.  It authorizes a limited number of agents to\n', ' * perform mutations on it -- those agents can be changed at any\n', ' * time by the contract&#39;s owner.\n', ' *\n', ' * Author: Nadav Hollander -- Github: nadavhollander\n', ' */\n', 'contract DebtRegistry is Pausable, PermissionEvents {\n', '    using SafeMath for uint;\n', '    using PermissionsLib for PermissionsLib.Permissions;\n', '\n', '    struct Entry {\n', '        address version;\n', '        address beneficiary;\n', '        address underwriter;\n', '        uint underwriterRiskRating;\n', '        address termsContract;\n', '        bytes32 termsContractParameters;\n', '        uint issuanceBlockTimestamp;\n', '    }\n', '\n', '    // Primary registry mapping agreement IDs to their corresponding entries\n', '    mapping (bytes32 => Entry) internal registry;\n', '\n', '    // Maps debtor addresses to a list of their debts&#39; agreement IDs\n', '    mapping (address => bytes32[]) internal debtorToDebts;\n', '\n', '    PermissionsLib.Permissions internal entryInsertPermissions;\n', '    PermissionsLib.Permissions internal entryEditPermissions;\n', '\n', '    string public constant INSERT_CONTEXT = "debt-registry-insert";\n', '    string public constant EDIT_CONTEXT = "debt-registry-edit";\n', '\n', '    event LogInsertEntry(\n', '        bytes32 indexed agreementId,\n', '        address indexed beneficiary,\n', '        address indexed underwriter,\n', '        uint underwriterRiskRating,\n', '        address termsContract,\n', '        bytes32 termsContractParameters\n', '    );\n', '\n', '    event LogModifyEntryBeneficiary(\n', '        bytes32 indexed agreementId,\n', '        address indexed previousBeneficiary,\n', '        address indexed newBeneficiary\n', '    );\n', '\n', '    modifier onlyAuthorizedToInsert() {\n', '        require(entryInsertPermissions.isAuthorized(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorizedToEdit() {\n', '        require(entryEditPermissions.isAuthorized(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyExtantEntry(bytes32 agreementId) {\n', '        require(doesEntryExist(agreementId));\n', '        _;\n', '    }\n', '\n', '    modifier nonNullBeneficiary(address beneficiary) {\n', '        require(beneficiary != address(0));\n', '        _;\n', '    }\n', '\n', '    /* Ensures an entry with the specified agreement ID exists within the debt registry. */\n', '    function doesEntryExist(bytes32 agreementId)\n', '        public\n', '        view\n', '        returns (bool exists)\n', '    {\n', '        return registry[agreementId].beneficiary != address(0);\n', '    }\n', '\n', '    /**\n', '     * Inserts a new entry into the registry, if the entry is valid and sender is\n', '     * authorized to make &#39;insert&#39; mutations to the registry.\n', '     */\n', '    function insert(\n', '        address _version,\n', '        address _beneficiary,\n', '        address _debtor,\n', '        address _underwriter,\n', '        uint _underwriterRiskRating,\n', '        address _termsContract,\n', '        bytes32 _termsContractParameters,\n', '        uint _salt\n', '    )\n', '        public\n', '        onlyAuthorizedToInsert\n', '        whenNotPaused\n', '        nonNullBeneficiary(_beneficiary)\n', '        returns (bytes32 _agreementId)\n', '    {\n', '        Entry memory entry = Entry(\n', '            _version,\n', '            _beneficiary,\n', '            _underwriter,\n', '            _underwriterRiskRating,\n', '            _termsContract,\n', '            _termsContractParameters,\n', '            block.timestamp\n', '        );\n', '\n', '        bytes32 agreementId = _getAgreementId(entry, _debtor, _salt);\n', '\n', '        require(registry[agreementId].beneficiary == address(0));\n', '\n', '        registry[agreementId] = entry;\n', '        debtorToDebts[_debtor].push(agreementId);\n', '\n', '        LogInsertEntry(\n', '            agreementId,\n', '            entry.beneficiary,\n', '            entry.underwriter,\n', '            entry.underwriterRiskRating,\n', '            entry.termsContract,\n', '            entry.termsContractParameters\n', '        );\n', '\n', '        return agreementId;\n', '    }\n', '\n', '    /**\n', '     * Modifies the beneficiary of a debt issuance, if the sender\n', '     * is authorized to make &#39;modifyBeneficiary&#39; mutations to\n', '     * the registry.\n', '     */\n', '    function modifyBeneficiary(bytes32 agreementId, address newBeneficiary)\n', '        public\n', '        onlyAuthorizedToEdit\n', '        whenNotPaused\n', '        onlyExtantEntry(agreementId)\n', '        nonNullBeneficiary(newBeneficiary)\n', '    {\n', '        address previousBeneficiary = registry[agreementId].beneficiary;\n', '\n', '        registry[agreementId].beneficiary = newBeneficiary;\n', '\n', '        LogModifyEntryBeneficiary(\n', '            agreementId,\n', '            previousBeneficiary,\n', '            newBeneficiary\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Adds an address to the list of agents authorized\n', '     * to make &#39;insert&#39; mutations to the registry.\n', '     */\n', '    function addAuthorizedInsertAgent(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryInsertPermissions.authorize(agent, INSERT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Adds an address to the list of agents authorized\n', '     * to make &#39;modifyBeneficiary&#39; mutations to the registry.\n', '     */\n', '    function addAuthorizedEditAgent(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryEditPermissions.authorize(agent, EDIT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Removes an address from the list of agents authorized\n', '     * to make &#39;insert&#39; mutations to the registry.\n', '     */\n', '    function revokeInsertAgentAuthorization(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryInsertPermissions.revokeAuthorization(agent, INSERT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Removes an address from the list of agents authorized\n', '     * to make &#39;modifyBeneficiary&#39; mutations to the registry.\n', '     */\n', '    function revokeEditAgentAuthorization(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryEditPermissions.revokeAuthorization(agent, EDIT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Returns the parameters of a debt issuance in the registry.\n', '     *\n', '     * TODO(kayvon): protect this function with our `onlyExtantEntry` modifier once the restriction\n', '     * on the size of the call stack has been addressed.\n', '     */\n', '    function get(bytes32 agreementId)\n', '        public\n', '        view\n', '        returns(address, address, address, uint, address, bytes32, uint)\n', '    {\n', '        return (\n', '            registry[agreementId].version,\n', '            registry[agreementId].beneficiary,\n', '            registry[agreementId].underwriter,\n', '            registry[agreementId].underwriterRiskRating,\n', '            registry[agreementId].termsContract,\n', '            registry[agreementId].termsContractParameters,\n', '            registry[agreementId].issuanceBlockTimestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns the beneficiary of a given issuance\n', '     */\n', '    function getBeneficiary(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns(address)\n', '    {\n', '        return registry[agreementId].beneficiary;\n', '    }\n', '\n', '    /**\n', '     * Returns the terms contract address of a given issuance\n', '     */\n', '    function getTermsContract(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (address)\n', '    {\n', '        return registry[agreementId].termsContract;\n', '    }\n', '\n', '    /**\n', '     * Returns the terms contract parameters of a given issuance\n', '     */\n', '    function getTermsContractParameters(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (bytes32)\n', '    {\n', '        return registry[agreementId].termsContractParameters;\n', '    }\n', '\n', '    /**\n', '     * Returns a tuple of the terms contract and its associated parameters\n', '     * for a given issuance\n', '     */\n', '    function getTerms(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns(address, bytes32)\n', '    {\n', '        return (\n', '            registry[agreementId].termsContract,\n', '            registry[agreementId].termsContractParameters\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns the timestamp of the block at which a debt agreement was issued.\n', '     */\n', '    function getIssuanceBlockTimestamp(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (uint timestamp)\n', '    {\n', '        return registry[agreementId].issuanceBlockTimestamp;\n', '    }\n', '\n', '    /**\n', '     * Returns the list of agents authorized to make &#39;insert&#39; mutations\n', '     */\n', '    function getAuthorizedInsertAgents()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return entryInsertPermissions.getAuthorizedAgents();\n', '    }\n', '\n', '    /**\n', '     * Returns the list of agents authorized to make &#39;modifyBeneficiary&#39; mutations\n', '     */\n', '    function getAuthorizedEditAgents()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return entryEditPermissions.getAuthorizedAgents();\n', '    }\n', '\n', '    /**\n', '     * Returns the list of debt agreements a debtor is party to,\n', '     * with each debt agreement listed by agreement ID.\n', '     */\n', '    function getDebtorsDebts(address debtor)\n', '        public\n', '        view\n', '        returns(bytes32[])\n', '    {\n', '        return debtorToDebts[debtor];\n', '    }\n', '\n', '    /**\n', '     * Helper function for computing the hash of a given issuance,\n', '     * and, in turn, its agreementId\n', '     */\n', '    function _getAgreementId(Entry _entry, address _debtor, uint _salt)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        return keccak256(\n', '            _entry.version,\n', '            _debtor,\n', '            _entry.underwriter,\n', '            _entry.underwriterRiskRating,\n', '            _entry.termsContract,\n', '            _entry.termsContractParameters,\n', '            _salt\n', '        );\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/libraries/PermissionsLib.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 Dharma Labs Inc.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '/**\n', ' *  Note(kayvon): these events are emitted by our PermissionsLib, but all contracts that\n', ' *  depend on the library must also define the events in order for web3 clients to pick them up.\n', ' *  This topic is discussed in greater detail here (under the section "Events and Libraries"):\n', ' *  https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736\n', ' */\n', 'contract PermissionEvents {\n', '    event Authorized(address indexed agent, string callingContext);\n', '    event AuthorizationRevoked(address indexed agent, string callingContext);\n', '}\n', '\n', '\n', 'library PermissionsLib {\n', '\n', '    // TODO(kayvon): remove these events and inherit from PermissionEvents when libraries are\n', '    // capable of inheritance.\n', '    // See relevant github issue here: https://github.com/ethereum/solidity/issues/891\n', '    event Authorized(address indexed agent, string callingContext);\n', '    event AuthorizationRevoked(address indexed agent, string callingContext);\n', '\n', '    struct Permissions {\n', '        mapping (address => bool) authorized;\n', '        mapping (address => uint) agentToIndex; // ensures O(1) look-up\n', '        address[] authorizedAgents;\n', '    }\n', '\n', '    function authorize(\n', '        Permissions storage self,\n', '        address agent,\n', '        string callingContext\n', '    )\n', '        internal\n', '    {\n', '        require(isNotAuthorized(self, agent));\n', '\n', '        self.authorized[agent] = true;\n', '        self.authorizedAgents.push(agent);\n', '        self.agentToIndex[agent] = self.authorizedAgents.length - 1;\n', '        Authorized(agent, callingContext);\n', '    }\n', '\n', '    function revokeAuthorization(\n', '        Permissions storage self,\n', '        address agent,\n', '        string callingContext\n', '    )\n', '        internal\n', '    {\n', '        /* We only want to do work in the case where the agent whose\n', '        authorization is being revoked had authorization permissions in the\n', '        first place. */\n', '        require(isAuthorized(self, agent));\n', '\n', '        uint indexOfAgentToRevoke = self.agentToIndex[agent];\n', '        uint indexOfAgentToMove = self.authorizedAgents.length - 1;\n', '        address agentToMove = self.authorizedAgents[indexOfAgentToMove];\n', '\n', "        // Revoke the agent's authorization.\n", '        delete self.authorized[agent];\n', '\n', '        // Remove the agent from our collection of authorized agents.\n', '        self.authorizedAgents[indexOfAgentToRevoke] = agentToMove;\n', '\n', '        // Update our indices to reflect the above changes.\n', '        self.agentToIndex[agentToMove] = indexOfAgentToRevoke;\n', '        delete self.agentToIndex[agent];\n', '\n', "        // Clean up memory that's no longer being used.\n", '        delete self.authorizedAgents[indexOfAgentToMove];\n', '        self.authorizedAgents.length -= 1;\n', '\n', '        AuthorizationRevoked(agent, callingContext);\n', '    }\n', '\n', '    function isAuthorized(Permissions storage self, address agent)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return self.authorized[agent];\n', '    }\n', '\n', '    function isNotAuthorized(Permissions storage self, address agent)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return !isAuthorized(self, agent);\n', '    }\n', '\n', '    function getAuthorizedAgents(Permissions storage self)\n', '        internal\n', '        view\n', '        returns (address[])\n', '    {\n', '        return self.authorizedAgents;\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/DebtRegistry.sol\n', '\n', '/*\n', '\n', '  Copyright 2017 Dharma Labs Inc.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * The DebtRegistry stores the parameters and beneficiaries of all debt agreements in\n', ' * Dharma protocol.  It authorizes a limited number of agents to\n', ' * perform mutations on it -- those agents can be changed at any\n', " * time by the contract's owner.\n", ' *\n', ' * Author: Nadav Hollander -- Github: nadavhollander\n', ' */\n', 'contract DebtRegistry is Pausable, PermissionEvents {\n', '    using SafeMath for uint;\n', '    using PermissionsLib for PermissionsLib.Permissions;\n', '\n', '    struct Entry {\n', '        address version;\n', '        address beneficiary;\n', '        address underwriter;\n', '        uint underwriterRiskRating;\n', '        address termsContract;\n', '        bytes32 termsContractParameters;\n', '        uint issuanceBlockTimestamp;\n', '    }\n', '\n', '    // Primary registry mapping agreement IDs to their corresponding entries\n', '    mapping (bytes32 => Entry) internal registry;\n', '\n', "    // Maps debtor addresses to a list of their debts' agreement IDs\n", '    mapping (address => bytes32[]) internal debtorToDebts;\n', '\n', '    PermissionsLib.Permissions internal entryInsertPermissions;\n', '    PermissionsLib.Permissions internal entryEditPermissions;\n', '\n', '    string public constant INSERT_CONTEXT = "debt-registry-insert";\n', '    string public constant EDIT_CONTEXT = "debt-registry-edit";\n', '\n', '    event LogInsertEntry(\n', '        bytes32 indexed agreementId,\n', '        address indexed beneficiary,\n', '        address indexed underwriter,\n', '        uint underwriterRiskRating,\n', '        address termsContract,\n', '        bytes32 termsContractParameters\n', '    );\n', '\n', '    event LogModifyEntryBeneficiary(\n', '        bytes32 indexed agreementId,\n', '        address indexed previousBeneficiary,\n', '        address indexed newBeneficiary\n', '    );\n', '\n', '    modifier onlyAuthorizedToInsert() {\n', '        require(entryInsertPermissions.isAuthorized(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyAuthorizedToEdit() {\n', '        require(entryEditPermissions.isAuthorized(msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier onlyExtantEntry(bytes32 agreementId) {\n', '        require(doesEntryExist(agreementId));\n', '        _;\n', '    }\n', '\n', '    modifier nonNullBeneficiary(address beneficiary) {\n', '        require(beneficiary != address(0));\n', '        _;\n', '    }\n', '\n', '    /* Ensures an entry with the specified agreement ID exists within the debt registry. */\n', '    function doesEntryExist(bytes32 agreementId)\n', '        public\n', '        view\n', '        returns (bool exists)\n', '    {\n', '        return registry[agreementId].beneficiary != address(0);\n', '    }\n', '\n', '    /**\n', '     * Inserts a new entry into the registry, if the entry is valid and sender is\n', "     * authorized to make 'insert' mutations to the registry.\n", '     */\n', '    function insert(\n', '        address _version,\n', '        address _beneficiary,\n', '        address _debtor,\n', '        address _underwriter,\n', '        uint _underwriterRiskRating,\n', '        address _termsContract,\n', '        bytes32 _termsContractParameters,\n', '        uint _salt\n', '    )\n', '        public\n', '        onlyAuthorizedToInsert\n', '        whenNotPaused\n', '        nonNullBeneficiary(_beneficiary)\n', '        returns (bytes32 _agreementId)\n', '    {\n', '        Entry memory entry = Entry(\n', '            _version,\n', '            _beneficiary,\n', '            _underwriter,\n', '            _underwriterRiskRating,\n', '            _termsContract,\n', '            _termsContractParameters,\n', '            block.timestamp\n', '        );\n', '\n', '        bytes32 agreementId = _getAgreementId(entry, _debtor, _salt);\n', '\n', '        require(registry[agreementId].beneficiary == address(0));\n', '\n', '        registry[agreementId] = entry;\n', '        debtorToDebts[_debtor].push(agreementId);\n', '\n', '        LogInsertEntry(\n', '            agreementId,\n', '            entry.beneficiary,\n', '            entry.underwriter,\n', '            entry.underwriterRiskRating,\n', '            entry.termsContract,\n', '            entry.termsContractParameters\n', '        );\n', '\n', '        return agreementId;\n', '    }\n', '\n', '    /**\n', '     * Modifies the beneficiary of a debt issuance, if the sender\n', "     * is authorized to make 'modifyBeneficiary' mutations to\n", '     * the registry.\n', '     */\n', '    function modifyBeneficiary(bytes32 agreementId, address newBeneficiary)\n', '        public\n', '        onlyAuthorizedToEdit\n', '        whenNotPaused\n', '        onlyExtantEntry(agreementId)\n', '        nonNullBeneficiary(newBeneficiary)\n', '    {\n', '        address previousBeneficiary = registry[agreementId].beneficiary;\n', '\n', '        registry[agreementId].beneficiary = newBeneficiary;\n', '\n', '        LogModifyEntryBeneficiary(\n', '            agreementId,\n', '            previousBeneficiary,\n', '            newBeneficiary\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Adds an address to the list of agents authorized\n', "     * to make 'insert' mutations to the registry.\n", '     */\n', '    function addAuthorizedInsertAgent(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryInsertPermissions.authorize(agent, INSERT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Adds an address to the list of agents authorized\n', "     * to make 'modifyBeneficiary' mutations to the registry.\n", '     */\n', '    function addAuthorizedEditAgent(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryEditPermissions.authorize(agent, EDIT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Removes an address from the list of agents authorized\n', "     * to make 'insert' mutations to the registry.\n", '     */\n', '    function revokeInsertAgentAuthorization(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryInsertPermissions.revokeAuthorization(agent, INSERT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Removes an address from the list of agents authorized\n', "     * to make 'modifyBeneficiary' mutations to the registry.\n", '     */\n', '    function revokeEditAgentAuthorization(address agent)\n', '        public\n', '        onlyOwner\n', '    {\n', '        entryEditPermissions.revokeAuthorization(agent, EDIT_CONTEXT);\n', '    }\n', '\n', '    /**\n', '     * Returns the parameters of a debt issuance in the registry.\n', '     *\n', '     * TODO(kayvon): protect this function with our `onlyExtantEntry` modifier once the restriction\n', '     * on the size of the call stack has been addressed.\n', '     */\n', '    function get(bytes32 agreementId)\n', '        public\n', '        view\n', '        returns(address, address, address, uint, address, bytes32, uint)\n', '    {\n', '        return (\n', '            registry[agreementId].version,\n', '            registry[agreementId].beneficiary,\n', '            registry[agreementId].underwriter,\n', '            registry[agreementId].underwriterRiskRating,\n', '            registry[agreementId].termsContract,\n', '            registry[agreementId].termsContractParameters,\n', '            registry[agreementId].issuanceBlockTimestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns the beneficiary of a given issuance\n', '     */\n', '    function getBeneficiary(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns(address)\n', '    {\n', '        return registry[agreementId].beneficiary;\n', '    }\n', '\n', '    /**\n', '     * Returns the terms contract address of a given issuance\n', '     */\n', '    function getTermsContract(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (address)\n', '    {\n', '        return registry[agreementId].termsContract;\n', '    }\n', '\n', '    /**\n', '     * Returns the terms contract parameters of a given issuance\n', '     */\n', '    function getTermsContractParameters(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (bytes32)\n', '    {\n', '        return registry[agreementId].termsContractParameters;\n', '    }\n', '\n', '    /**\n', '     * Returns a tuple of the terms contract and its associated parameters\n', '     * for a given issuance\n', '     */\n', '    function getTerms(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns(address, bytes32)\n', '    {\n', '        return (\n', '            registry[agreementId].termsContract,\n', '            registry[agreementId].termsContractParameters\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns the timestamp of the block at which a debt agreement was issued.\n', '     */\n', '    function getIssuanceBlockTimestamp(bytes32 agreementId)\n', '        public\n', '        view\n', '        onlyExtantEntry(agreementId)\n', '        returns (uint timestamp)\n', '    {\n', '        return registry[agreementId].issuanceBlockTimestamp;\n', '    }\n', '\n', '    /**\n', "     * Returns the list of agents authorized to make 'insert' mutations\n", '     */\n', '    function getAuthorizedInsertAgents()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return entryInsertPermissions.getAuthorizedAgents();\n', '    }\n', '\n', '    /**\n', "     * Returns the list of agents authorized to make 'modifyBeneficiary' mutations\n", '     */\n', '    function getAuthorizedEditAgents()\n', '        public\n', '        view\n', '        returns(address[])\n', '    {\n', '        return entryEditPermissions.getAuthorizedAgents();\n', '    }\n', '\n', '    /**\n', '     * Returns the list of debt agreements a debtor is party to,\n', '     * with each debt agreement listed by agreement ID.\n', '     */\n', '    function getDebtorsDebts(address debtor)\n', '        public\n', '        view\n', '        returns(bytes32[])\n', '    {\n', '        return debtorToDebts[debtor];\n', '    }\n', '\n', '    /**\n', '     * Helper function for computing the hash of a given issuance,\n', '     * and, in turn, its agreementId\n', '     */\n', '    function _getAgreementId(Entry _entry, address _debtor, uint _salt)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        return keccak256(\n', '            _entry.version,\n', '            _debtor,\n', '            _entry.underwriter,\n', '            _entry.underwriterRiskRating,\n', '            _entry.termsContract,\n', '            _entry.termsContractParameters,\n', '            _salt\n', '        );\n', '    }\n', '}']
