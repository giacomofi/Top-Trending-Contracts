['pragma solidity 0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', '\n', '\n', 'contract ParsecTokenERC20 {\n', '    // Public variables of the token\n', '    string public constant name = "Parsec Credits";\n', '    string public constant symbol = "PRSC";\n', '    uint8 public decimals = 6;\n', '    uint256 public initialSupply = 30856775800;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    function ParsecTokenERC20() public {\n', '        // Update total supply with the decimal amount\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '\n', '        // Give the creator all initial tokens\n', '        balanceOf[msg.sender] = totalSupply;\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        // Check allowance\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        // Check if the sender has enough\n', '        require(balanceOf[msg.sender] >= _value);\n', '\n', '        // Subtract from the sender\n', '        balanceOf[msg.sender] -= _value;\n', '\n', '        // Updates totalSupply\n', '        totalSupply -= _value;\n', '\n', '        // Notify clients about burned tokens\n', '        Burn(msg.sender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        // Check if the targeted balance is enough\n', '        require(balanceOf[_from] >= _value);\n', '\n', '        // Check allowance\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        // Subtract from the targeted balance\n', '        balanceOf[_from] -= _value;\n', '\n', '        // Subtract from the sender&#39;s allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '\n', '        // Update totalSupply\n', '        totalSupply -= _value;\n', '\n', '        // Notify clients about burned tokens\n', '        Burn(_from, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract ParsecCrowdsale is owned {\n', '    /// @notice Use OpenZeppelin&#39;s SafeMath\n', '    using SafeMath for uint256;\n', '\n', '    /// @notice Define KYC states\n', '    enum KycState {\n', '        Undefined,  // 0\n', '        Pending,    // 1\n', '        Accepted,   // 2\n', '        Declined    // 3\n', '    }\n', '\n', '    // -------------------------\n', '    // --- General constants ---\n', '    // -------------------------\n', '\n', '    /// @notice Minimum ETH amount per transaction\n', '    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 0.1 ether;\n', '\n', '    /// @notice Base rate of parsec credits per 1 ETH\n', '    uint256 public constant PARSECS_PER_ETHER_BASE = 1300000000000;      // 1,300,000.000000 PRSC\n', '\n', '    /// @notice Crowdsale hard cap in Parsecs\n', '    uint256 public constant PARSECS_TOTAL_AMOUNT = 16103862002000000;    // 16,103,862,002.000000 PRSC\n', '\n', '    // ----------------------------\n', '    // --- Bonus tier constants ---\n', '    // ----------------------------\n', '    \n', '    uint256 public constant BONUS_TIER_1_LIMIT = 715 ether;     // 30.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_2_LIMIT = 1443 ether;    // 27.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_3_LIMIT = 2434 ether;    // 25.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_4_LIMIT = 3446 ether;    // 22.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_5_LIMIT = 4478 ether;    // 20.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_6_LIMIT = 5532 ether;    // 17.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_7_LIMIT = 6609 ether;    // 15.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_8_LIMIT = 7735 ether;    // 10.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_9_LIMIT = 9210 ether;    // 5.00 % bonus Parsecs\n', '\n', '    // ------------------------\n', '    // --- Input parameters ---\n', '    // ------------------------\n', '\n', '    /// @notice Parsec ERC20 token address (from previously deployed contract)\n', '    ParsecTokenERC20 private parsecToken;\n', '\n', '    // @notice Multisig account address to collect accepted ETH\n', '    address public multisigAddress;\n', '\n', '    // @notice Auditor account address to perform KYC accepts and declines\n', '    address public auditorAddress;\n', '\n', '    // ---------------------------\n', '    // --- Power-up parameters ---\n', '    // ---------------------------\n', '\n', '    /// @notice Keep track if contract is powered up (has enough Parsecs)\n', '    bool public contractPoweredUp = false;\n', '\n', '    /// @notice Keep track if contract has enough ETH to perform refunds\n', '    bool public refundPoweredUp = false;\n', '\n', '    // ---------------------------\n', '    // --- State parameters ---\n', '    // ---------------------------\n', '\n', '    /// @notice Keep track if contract is started (permanently, works if contract is powered up) \n', '    bool public contractStarted = false;\n', '\n', '    /// @notice Keep track if contract is finished (permanently, works if contract is started) \n', '    bool public contractFinished = false;\n', '\n', '    /// @notice Keep track if contract is paused (transiently, works if contract started and not finished) \n', '    bool public contractPaused = false;\n', '\n', '    /// @notice Keep track if contract is failed (permanently, works if contract started and not finished) \n', '    bool public contractFailed = false;\n', '\n', '    /// @notice Keep track if contract refund is started\n', '    bool public contractRefundStarted = false;\n', '\n', '    /// @notice Keep track if contract refund is finished\n', '    bool public contractRefundFinished = false;\n', '\n', '    // ------------------------\n', '    // --- Funding tracking ---\n', '    // ------------------------\n', '\n', '    /// @notice Keep track of total amount of funding raised and passed KYC\n', '    uint256 public raisedFunding;\n', '       \n', '    /// @notice Keep track of funding amount pending KYC check\n', '    uint256 public pendingFunding;\n', '\n', '    /// @notice Keep track of refunded funding\n', '    uint256 public refundedFunding;\n', '\n', '    // ------------------------\n', '    // --- Parsecs tracking ---\n', '    // ------------------------\n', '\n', '    /// @notice Keep track of spent Parsecs amount (transferred to participants)\n', '    uint256 public spentParsecs;\n', '    \n', '    /// @notice Keep track of pending Parsecs amount (participant pending KYC)\n', '    uint256 public pendingParsecs;\n', '\n', '    // ----------------\n', '    // --- Balances ---\n', '    // ----------------\n', '\n', '    /// @notice Keep track of all contributions per account passed KYC\n', '    mapping (address => uint256) public contributionOf;\n', '\n', '    /// @notice Keep track of all Parsecs granted to participants after they passed KYC\n', '    mapping (address => uint256) public parsecsOf;\n', '\n', '    /// @notice Keep track of all contributions pending KYC\n', '    mapping (address => uint256) public pendingContributionOf;\n', '\n', '    /// @notice Keep track of all Parsecs&#39; rewards pending KYC\n', '    mapping (address => uint256) public pendingParsecsOf;\n', '\n', '    /// @notice Keep track of all refunds per account\n', '    mapping (address => uint256) public refundOf;\n', '\n', '    // -----------------------------------------\n', '    // --- KYC (Know-Your-Customer) tracking ---\n', '    // -----------------------------------------\n', '\n', '    /// @notice Keep track of participants&#39; KYC status\n', '    mapping (address => KycState) public kycStatus;\n', '\n', '    // --------------\n', '    // --- Events ---\n', '    // --------------\n', '\n', '    /// @notice Log an event for each KYC accept\n', '    event LogKycAccept(address indexed sender, uint256 value, uint256 timestamp);\n', '\n', '    /// @notice Log an event for each KYC decline\n', '    event LogKycDecline(address indexed sender, uint256 value, uint256 timestamp);\n', '\n', '    /// @notice Log an event for each contributed amount passed KYC\n', '    event LogContribution(address indexed sender, uint256 ethValue, uint256 parsecValue, uint256 timestamp);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Initializes smart contract\n', '     *\n', '     * @param _tokenAddress The address of the previously deployed ParsecTokenERC20 contract\n', '     * @param _multisigAddress The address of the Multisig wallet to redirect payments to\n', '     * @param _auditorAddress The address of the Auditor account which will accept or decline investors&#39; KYC\n', '     */\n', '    function ParsecCrowdsale (address _tokenAddress, address _multisigAddress, address _auditorAddress) public {\n', '        // Get Parsec ERC20 token instance\n', '        parsecToken = ParsecTokenERC20(_tokenAddress);\n', '\n', '        // Store Multisig wallet and Auditor addresses\n', '        multisigAddress = _multisigAddress;\n', '        auditorAddress = _auditorAddress;\n', '    }\n', '\n', '    /// @notice Allows only contract owner or Multisig to proceed\n', '    modifier onlyOwnerOrMultisig {\n', '        require(msg.sender == owner || msg.sender == multisigAddress);\n', '        _;\n', '    }\n', '\n', '    /// @notice Allows only contract owner or Auditor to proceed\n', '    modifier onlyOwnerOrAuditor {\n', '        require(msg.sender == owner || msg.sender == auditorAddress);\n', '        _;\n', '    }\n', '\n', '    /// @notice A participant sends a contribution to the contract&#39;s address\n', '    ///         when contract is active, not failed and not paused \n', '    /// @notice Only contributions above the MINIMUM_PARTICIPATION_AMOUNT are\n', '    ///         accepted. Otherwise the transaction is rejected and contributed\n', '    ///         amount is returned to the participant&#39;s account\n', '    /// @notice A participant&#39;s contribution will be rejected if it exceeds\n', '    ///         the hard cap\n', '    /// @notice A participant&#39;s contribution will be rejected if the hard\n', '    ///         cap is reached\n', '    function () public payable {\n', '        // Contract should be powered up\n', '        require(contractPoweredUp);\n', '\n', '        // Сontract should BE started\n', '        require(contractStarted);\n', '\n', '        // Сontract should NOT BE finished\n', '        require(!contractFinished);\n', '\n', '        // Сontract should NOT BE paused\n', '        require(!contractPaused);\n', '\n', '        // Сontract should NOT BE failed\n', '        require(!contractFailed);\n', '\n', '        // A participant cannot send less than the minimum amount\n', '        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT);\n', '\n', '        // Calculate amount of Parsecs to reward\n', '        uint256 parsecValue = calculateReward(msg.value);\n', '\n', '        // Calculate maximum amount of Parsecs smart contract can provide\n', '        uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT.sub(spentParsecs);\n', '        maxAcceptableParsecs = maxAcceptableParsecs.sub(pendingParsecs);\n', '\n', '        // A participant cannot receive more Parsecs than contract has to offer\n', '        require(parsecValue <= maxAcceptableParsecs);\n', '\n', '        // Check if participant&#39;s KYC state is Undefined and set it to Pending\n', '        if (kycStatus[msg.sender] == KycState.Undefined) {\n', '            kycStatus[msg.sender] = KycState.Pending;\n', '        }\n', '\n', '        if (kycStatus[msg.sender] == KycState.Pending) {\n', '            // KYC is Pending: register pending contribution\n', '            addPendingContribution(msg.sender, msg.value, parsecValue);\n', '        } else if (kycStatus[msg.sender] == KycState.Accepted) {\n', '            // KYC is Accepted: register accepted contribution\n', '            addAcceptedContribution(msg.sender, msg.value, parsecValue);\n', '        } else {\n', '            // KYC is Declined: revert transaction\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can withdraw Parsecs anytime in case of emergency\n', '    function emergencyWithdrawParsecs(uint256 value) external onlyOwnerOrMultisig {\n', '        // Amount of Parsecs to withdraw should not exceed current balance\n', '        require(value > 0);\n', '        require(value <= parsecToken.balanceOf(this));\n', '\n', '        // Transfer parsecs\n', '        parsecToken.transfer(msg.sender, value);\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can refund contract with ETH in case of failed Crowdsale\n', '    function emergencyRefundContract() external payable onlyOwnerOrMultisig {\n', '        // Contract should be failed previously\n', '        require(contractFailed);\n', '        \n', '        // Amount of ETH should be positive\n', '        require(msg.value > 0);\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can clawback ether after refund period is finished\n', '    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {\n', '        // Contract should be failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should be started and finished previously\n', '        require(contractRefundStarted);\n', '        require(contractRefundFinished);\n', '        \n', '        // Amount of ETH should be positive and not exceed current contract balance\n', '        require(value > 0);\n', '        require(value <= address(this).balance);\n', '\n', '        // Transfer ETH to Multisig\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    /// @notice Set Auditor account address to a new value\n', '    function ownerSetAuditor(address _auditorAddress) external onlyOwner {\n', '        // Auditor address cannot be zero\n', '        require(_auditorAddress != 0x0);\n', '\n', '        // Change Auditor account address\n', '        auditorAddress = _auditorAddress;\n', '    }\n', '\n', '    /// @notice Check if contract has enough Parsecs to cover hard cap\n', '    function ownerPowerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractPoweredUp);\n', '\n', '        // Contract should have enough Parsec credits\n', '        require(parsecToken.balanceOf(this) >= PARSECS_TOTAL_AMOUNT);\n', '\n', '        // Raise contract power-up flag\n', '        contractPoweredUp = true;\n', '    }\n', '\n', '    /// @notice Start contract (permanently)\n', '    function ownerStartContract() external onlyOwner {\n', '        // Contract should be powered up previously\n', '        require(contractPoweredUp);\n', '\n', '        // Contract should not be started previously\n', '        require(!contractStarted);\n', '\n', '        // Raise contract started flag\n', '        contractStarted = true;\n', '    }\n', '\n', '    /// @notice Finish contract (permanently)\n', '    function ownerFinishContract() external onlyOwner {\n', '        // Contract should be started previously\n', '        require(contractStarted);\n', '\n', '        // Contract should not be finished previously\n', '        require(!contractFinished);\n', '\n', '        // Raise contract finished flag\n', '        contractFinished = true;\n', '    }\n', '\n', '    /// @notice Pause contract (transiently)\n', '    function ownerPauseContract() external onlyOwner {\n', '        // Contract should be started previously\n', '        require(contractStarted);\n', '\n', '        // Contract should not be finished previously\n', '        require(!contractFinished);\n', '\n', '        // Contract should not be paused previously\n', '        require(!contractPaused);\n', '\n', '        // Raise contract paused flag\n', '        contractPaused = true;\n', '    }\n', '\n', '    /// @notice Resume contract (transiently)\n', '    function ownerResumeContract() external onlyOwner {\n', '        // Contract should be paused previously\n', '        require(contractPaused);\n', '\n', '        // Unset contract paused flag\n', '        contractPaused = false;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale failure (no more ETH are accepted from participants)\n', '    function ownerDeclareFailure() external onlyOwner {\n', '        // Contract should NOT BE failed previously\n', '        require(!contractFailed);\n', '\n', '        // Raise contract failed flag\n', '        contractFailed = true;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale refund start\n', '    function ownerDeclareRefundStart() external onlyOwner {\n', '        // Contract should BE failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should NOT BE started previously\n', '        require(!contractRefundStarted);\n', '\n', '        // Contract should NOT have any pending KYC requests\n', '        require(pendingFunding == 0x0);\n', '\n', '        // Contract should have enough ETH to perform refunds\n', '        require(address(this).balance >= raisedFunding);\n', '\n', '        // Raise contract refund started flag\n', '        contractRefundStarted = true;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale refund finish\n', '    function ownerDeclareRefundFinish() external onlyOwner {\n', '        // Contract should BE failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should BE started previously\n', '        require(contractRefundStarted);\n', '\n', '        // Contract refund should NOT BE finished previously\n', '        require(!contractRefundFinished);\n', '\n', '        // Raise contract refund finished flag\n', '        contractRefundFinished = true;\n', '    }\n', '\n', '    /// @notice Owner can withdraw Parsecs only after contract is finished\n', '    function ownerWithdrawParsecs(uint256 value) external onlyOwner {\n', '        // Contract should be finished before any Parsecs could be withdrawn\n', '        require(contractFinished);\n', '\n', '        // Get smart contract balance in Parsecs\n', '        uint256 parsecBalance = parsecToken.balanceOf(this);\n', '\n', '        // Calculate maximal amount to withdraw\n', '        uint256 maxAmountToWithdraw = parsecBalance.sub(pendingParsecs);\n', '\n', '        // Maximal amount to withdraw should be greater than zero and not greater than total balance\n', '        require(maxAmountToWithdraw > 0);\n', '        require(maxAmountToWithdraw <= parsecBalance);\n', '\n', '        // Amount of Parsecs to withdraw should not exceed maxAmountToWithdraw\n', '        require(value > 0);\n', '        require(value <= maxAmountToWithdraw);\n', '\n', '        // Transfer parsecs\n', '        parsecToken.transfer(owner, value);\n', '    }\n', ' \n', '    /// @dev Accept participant&#39;s KYC\n', '    function acceptKyc(address participant) external onlyOwnerOrAuditor {\n', '        // Set participant&#39;s KYC status to Accepted\n', '        kycStatus[participant] = KycState.Accepted;\n', '\n', '        // Get pending amounts in ETH and Parsecs\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\n', '\n', '        // Log an event of the participant&#39;s KYC accept\n', '        LogKycAccept(participant, pendingAmountOfEth, now);\n', '\n', '        if (pendingAmountOfEth > 0 || pendingAmountOfParsecs > 0) {\n', '            // Reset pending contribution\n', '            resetPendingContribution(participant);\n', '\n', '            // Add accepted contribution\n', '            addAcceptedContribution(participant, pendingAmountOfEth, pendingAmountOfParsecs);\n', '        }\n', '    }\n', '\n', '    /// @dev Decline participant&#39;s KYC\n', '    function declineKyc(address participant) external onlyOwnerOrAuditor {\n', '        // Set participant&#39;s KYC status to Declined\n', '        kycStatus[participant] = KycState.Declined;\n', '\n', '        // Log an event of the participant&#39;s KYC decline\n', '        LogKycDecline(participant, pendingAmountOfEth, now);\n', '\n', '        // Get pending ETH amount\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '\n', '        if (pendingAmountOfEth > 0) {\n', '            // Reset pending contribution\n', '            resetPendingContribution(participant);\n', '\n', '            // Transfer ETH back to participant\n', '            participant.transfer(pendingAmountOfEth);\n', '        }\n', '    }\n', '\n', '    /// @dev Allow participants to clawback ETH in case of Crowdsale failure\n', '    function participantClawbackEther(uint256 value) external {\n', '        // Participant cannot withdraw ETH if refund is not started or after it is finished\n', '        require(contractRefundStarted);\n', '        require(!contractRefundFinished);\n', '\n', '        // Get total contribution of participant\n', '        uint256 totalContribution = contributionOf[msg.sender];\n', '\n', '        // Get already refunded amount\n', '        uint256 alreadyRefunded = refundOf[msg.sender];\n', '\n', '        // Calculate maximal withdrawal amount\n', '        uint256 maxWithdrawalAmount = totalContribution.sub(alreadyRefunded);\n', '\n', '        // Maximal withdrawal amount should not be zero\n', '        require(maxWithdrawalAmount > 0);\n', '\n', '        // Requested value should not exceed maximal withdrawal amount\n', '        require(value > 0);\n', '        require(value <= maxWithdrawalAmount);\n', '\n', '        // Participant&#39;s refundOf is increased by the claimed amount\n', '        refundOf[msg.sender] = alreadyRefunded.add(value);\n', '\n', '        // Total refound amount is increased\n', '        refundedFunding = refundedFunding.add(value);\n', '\n', '        // Send ethers back to the participant&#39;s account\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    /// @dev Register pending contribution\n', '    function addPendingContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\n', '        // Participant&#39;s pending contribution is increased by ethValue\n', '        pendingContributionOf[participant] = pendingContributionOf[participant].add(ethValue);\n', '\n', '        // Parsecs pending to participant increased by parsecValue\n', '        pendingParsecsOf[participant] = pendingParsecsOf[participant].add(parsecValue);\n', '\n', '        // Increase pending funding by ethValue\n', '        pendingFunding = pendingFunding.add(ethValue);\n', '\n', '        // Increase pending Parsecs by parsecValue\n', '        pendingParsecs = pendingParsecs.add(parsecValue);\n', '    }\n', '\n', '    /// @dev Register accepted contribution\n', '    function addAcceptedContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\n', '        // Participant&#39;s contribution is increased by ethValue\n', '        contributionOf[participant] = contributionOf[participant].add(ethValue);\n', '\n', '        // Parsecs rewarded to participant increased by parsecValue\n', '        parsecsOf[participant] = parsecsOf[participant].add(parsecValue);\n', '\n', '        // Increase total raised funding by ethValue\n', '        raisedFunding = raisedFunding.add(ethValue);\n', '\n', '        // Increase spent Parsecs by parsecValue\n', '        spentParsecs = spentParsecs.add(parsecValue);\n', '\n', '        // Log an event of the participant&#39;s contribution\n', '        LogContribution(participant, ethValue, parsecValue, now);\n', '\n', '        // Transfer ETH to Multisig\n', '        multisigAddress.transfer(ethValue);\n', '\n', '        // Transfer Parsecs to participant\n', '        parsecToken.transfer(participant, parsecValue);\n', '    }\n', '\n', '    /// @dev Reset pending contribution\n', '    function resetPendingContribution(address participant) private {\n', '        // Get amounts of pending ETH and Parsecs\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\n', '\n', '        // Decrease pending contribution by pendingAmountOfEth\n', '        pendingContributionOf[participant] = pendingContributionOf[participant].sub(pendingAmountOfEth);\n', '\n', '        // Decrease pending Parsecs reward by pendingAmountOfParsecs\n', '        pendingParsecsOf[participant] = pendingParsecsOf[participant].sub(pendingAmountOfParsecs);\n', '\n', '        // Decrease pendingFunding by pendingAmountOfEth\n', '        pendingFunding = pendingFunding.sub(pendingAmountOfEth);\n', '\n', '        // Decrease pendingParsecs by pendingAmountOfParsecs\n', '        pendingParsecs = pendingParsecs.sub(pendingAmountOfParsecs);\n', '    }\n', '\n', '    /// @dev Calculate amount of Parsecs to grant for ETH contribution\n', '    function calculateReward(uint256 ethValue) private view returns (uint256 amount) {\n', '        // Define base quotient\n', '        uint256 baseQuotient = 1000;\n', '\n', '        // Calculate actual quotient according to current bonus tier\n', '        uint256 actualQuotient = baseQuotient.add(calculateBonusTierQuotient());\n', '\n', '        // Calculate reward amount\n', '        uint256 reward = ethValue.mul(PARSECS_PER_ETHER_BASE);\n', '        reward = reward.mul(actualQuotient);\n', '        reward = reward.div(baseQuotient);\n', '        return reward.div(1 ether);\n', '    }\n', '\n', '    /// @dev Calculate current bonus tier quotient\n', '    function calculateBonusTierQuotient() private view returns (uint256 quotient) {\n', '        uint256 funding = raisedFunding.add(pendingFunding);\n', '\n', '        if (funding < BONUS_TIER_1_LIMIT) {\n', '            return 300;     // 30.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_2_LIMIT) {\n', '            return 275;     // 27.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_3_LIMIT) {\n', '            return 250;     // 25.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_4_LIMIT) {\n', '            return 225;     // 22.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_5_LIMIT) {\n', '            return 200;     // 20.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_6_LIMIT) {\n', '            return 175;     // 17.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_7_LIMIT) {\n', '            return 150;     // 15.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_8_LIMIT) {\n', '            return 100;     // 10.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_9_LIMIT) {\n', '            return 50;      // 5.00 % bonus Parsecs\n', '        } else {\n', '            return 0;       // 0.00 % bonus Parsecs\n', '        }\n', '    }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'interface tokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n', '}\n', '\n', '\n', 'contract ParsecTokenERC20 {\n', '    // Public variables of the token\n', '    string public constant name = "Parsec Credits";\n', '    string public constant symbol = "PRSC";\n', '    uint8 public decimals = 6;\n', '    uint256 public initialSupply = 30856775800;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    function ParsecTokenERC20() public {\n', '        // Update total supply with the decimal amount\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '\n', '        // Give the creator all initial tokens\n', '        balanceOf[msg.sender] = totalSupply;\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        // Check allowance\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address and notify\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     * @param _extraData some extra information to send to the approved contract\n', '     */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        // Check if the sender has enough\n', '        require(balanceOf[msg.sender] >= _value);\n', '\n', '        // Subtract from the sender\n', '        balanceOf[msg.sender] -= _value;\n', '\n', '        // Updates totalSupply\n', '        totalSupply -= _value;\n', '\n', '        // Notify clients about burned tokens\n', '        Burn(msg.sender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        // Check if the targeted balance is enough\n', '        require(balanceOf[_from] >= _value);\n', '\n', '        // Check allowance\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        // Subtract from the targeted balance\n', '        balanceOf[_from] -= _value;\n', '\n', "        // Subtract from the sender's allowance\n", '        allowance[_from][msg.sender] -= _value;\n', '\n', '        // Update totalSupply\n', '        totalSupply -= _value;\n', '\n', '        // Notify clients about burned tokens\n', '        Burn(_from, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract ParsecCrowdsale is owned {\n', "    /// @notice Use OpenZeppelin's SafeMath\n", '    using SafeMath for uint256;\n', '\n', '    /// @notice Define KYC states\n', '    enum KycState {\n', '        Undefined,  // 0\n', '        Pending,    // 1\n', '        Accepted,   // 2\n', '        Declined    // 3\n', '    }\n', '\n', '    // -------------------------\n', '    // --- General constants ---\n', '    // -------------------------\n', '\n', '    /// @notice Minimum ETH amount per transaction\n', '    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 0.1 ether;\n', '\n', '    /// @notice Base rate of parsec credits per 1 ETH\n', '    uint256 public constant PARSECS_PER_ETHER_BASE = 1300000000000;      // 1,300,000.000000 PRSC\n', '\n', '    /// @notice Crowdsale hard cap in Parsecs\n', '    uint256 public constant PARSECS_TOTAL_AMOUNT = 16103862002000000;    // 16,103,862,002.000000 PRSC\n', '\n', '    // ----------------------------\n', '    // --- Bonus tier constants ---\n', '    // ----------------------------\n', '    \n', '    uint256 public constant BONUS_TIER_1_LIMIT = 715 ether;     // 30.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_2_LIMIT = 1443 ether;    // 27.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_3_LIMIT = 2434 ether;    // 25.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_4_LIMIT = 3446 ether;    // 22.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_5_LIMIT = 4478 ether;    // 20.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_6_LIMIT = 5532 ether;    // 17.5 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_7_LIMIT = 6609 ether;    // 15.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_8_LIMIT = 7735 ether;    // 10.0 % bonus Parsecs\n', '    uint256 public constant BONUS_TIER_9_LIMIT = 9210 ether;    // 5.00 % bonus Parsecs\n', '\n', '    // ------------------------\n', '    // --- Input parameters ---\n', '    // ------------------------\n', '\n', '    /// @notice Parsec ERC20 token address (from previously deployed contract)\n', '    ParsecTokenERC20 private parsecToken;\n', '\n', '    // @notice Multisig account address to collect accepted ETH\n', '    address public multisigAddress;\n', '\n', '    // @notice Auditor account address to perform KYC accepts and declines\n', '    address public auditorAddress;\n', '\n', '    // ---------------------------\n', '    // --- Power-up parameters ---\n', '    // ---------------------------\n', '\n', '    /// @notice Keep track if contract is powered up (has enough Parsecs)\n', '    bool public contractPoweredUp = false;\n', '\n', '    /// @notice Keep track if contract has enough ETH to perform refunds\n', '    bool public refundPoweredUp = false;\n', '\n', '    // ---------------------------\n', '    // --- State parameters ---\n', '    // ---------------------------\n', '\n', '    /// @notice Keep track if contract is started (permanently, works if contract is powered up) \n', '    bool public contractStarted = false;\n', '\n', '    /// @notice Keep track if contract is finished (permanently, works if contract is started) \n', '    bool public contractFinished = false;\n', '\n', '    /// @notice Keep track if contract is paused (transiently, works if contract started and not finished) \n', '    bool public contractPaused = false;\n', '\n', '    /// @notice Keep track if contract is failed (permanently, works if contract started and not finished) \n', '    bool public contractFailed = false;\n', '\n', '    /// @notice Keep track if contract refund is started\n', '    bool public contractRefundStarted = false;\n', '\n', '    /// @notice Keep track if contract refund is finished\n', '    bool public contractRefundFinished = false;\n', '\n', '    // ------------------------\n', '    // --- Funding tracking ---\n', '    // ------------------------\n', '\n', '    /// @notice Keep track of total amount of funding raised and passed KYC\n', '    uint256 public raisedFunding;\n', '       \n', '    /// @notice Keep track of funding amount pending KYC check\n', '    uint256 public pendingFunding;\n', '\n', '    /// @notice Keep track of refunded funding\n', '    uint256 public refundedFunding;\n', '\n', '    // ------------------------\n', '    // --- Parsecs tracking ---\n', '    // ------------------------\n', '\n', '    /// @notice Keep track of spent Parsecs amount (transferred to participants)\n', '    uint256 public spentParsecs;\n', '    \n', '    /// @notice Keep track of pending Parsecs amount (participant pending KYC)\n', '    uint256 public pendingParsecs;\n', '\n', '    // ----------------\n', '    // --- Balances ---\n', '    // ----------------\n', '\n', '    /// @notice Keep track of all contributions per account passed KYC\n', '    mapping (address => uint256) public contributionOf;\n', '\n', '    /// @notice Keep track of all Parsecs granted to participants after they passed KYC\n', '    mapping (address => uint256) public parsecsOf;\n', '\n', '    /// @notice Keep track of all contributions pending KYC\n', '    mapping (address => uint256) public pendingContributionOf;\n', '\n', "    /// @notice Keep track of all Parsecs' rewards pending KYC\n", '    mapping (address => uint256) public pendingParsecsOf;\n', '\n', '    /// @notice Keep track of all refunds per account\n', '    mapping (address => uint256) public refundOf;\n', '\n', '    // -----------------------------------------\n', '    // --- KYC (Know-Your-Customer) tracking ---\n', '    // -----------------------------------------\n', '\n', "    /// @notice Keep track of participants' KYC status\n", '    mapping (address => KycState) public kycStatus;\n', '\n', '    // --------------\n', '    // --- Events ---\n', '    // --------------\n', '\n', '    /// @notice Log an event for each KYC accept\n', '    event LogKycAccept(address indexed sender, uint256 value, uint256 timestamp);\n', '\n', '    /// @notice Log an event for each KYC decline\n', '    event LogKycDecline(address indexed sender, uint256 value, uint256 timestamp);\n', '\n', '    /// @notice Log an event for each contributed amount passed KYC\n', '    event LogContribution(address indexed sender, uint256 ethValue, uint256 parsecValue, uint256 timestamp);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Initializes smart contract\n', '     *\n', '     * @param _tokenAddress The address of the previously deployed ParsecTokenERC20 contract\n', '     * @param _multisigAddress The address of the Multisig wallet to redirect payments to\n', "     * @param _auditorAddress The address of the Auditor account which will accept or decline investors' KYC\n", '     */\n', '    function ParsecCrowdsale (address _tokenAddress, address _multisigAddress, address _auditorAddress) public {\n', '        // Get Parsec ERC20 token instance\n', '        parsecToken = ParsecTokenERC20(_tokenAddress);\n', '\n', '        // Store Multisig wallet and Auditor addresses\n', '        multisigAddress = _multisigAddress;\n', '        auditorAddress = _auditorAddress;\n', '    }\n', '\n', '    /// @notice Allows only contract owner or Multisig to proceed\n', '    modifier onlyOwnerOrMultisig {\n', '        require(msg.sender == owner || msg.sender == multisigAddress);\n', '        _;\n', '    }\n', '\n', '    /// @notice Allows only contract owner or Auditor to proceed\n', '    modifier onlyOwnerOrAuditor {\n', '        require(msg.sender == owner || msg.sender == auditorAddress);\n', '        _;\n', '    }\n', '\n', "    /// @notice A participant sends a contribution to the contract's address\n", '    ///         when contract is active, not failed and not paused \n', '    /// @notice Only contributions above the MINIMUM_PARTICIPATION_AMOUNT are\n', '    ///         accepted. Otherwise the transaction is rejected and contributed\n', "    ///         amount is returned to the participant's account\n", "    /// @notice A participant's contribution will be rejected if it exceeds\n", '    ///         the hard cap\n', "    /// @notice A participant's contribution will be rejected if the hard\n", '    ///         cap is reached\n', '    function () public payable {\n', '        // Contract should be powered up\n', '        require(contractPoweredUp);\n', '\n', '        // Сontract should BE started\n', '        require(contractStarted);\n', '\n', '        // Сontract should NOT BE finished\n', '        require(!contractFinished);\n', '\n', '        // Сontract should NOT BE paused\n', '        require(!contractPaused);\n', '\n', '        // Сontract should NOT BE failed\n', '        require(!contractFailed);\n', '\n', '        // A participant cannot send less than the minimum amount\n', '        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT);\n', '\n', '        // Calculate amount of Parsecs to reward\n', '        uint256 parsecValue = calculateReward(msg.value);\n', '\n', '        // Calculate maximum amount of Parsecs smart contract can provide\n', '        uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT.sub(spentParsecs);\n', '        maxAcceptableParsecs = maxAcceptableParsecs.sub(pendingParsecs);\n', '\n', '        // A participant cannot receive more Parsecs than contract has to offer\n', '        require(parsecValue <= maxAcceptableParsecs);\n', '\n', "        // Check if participant's KYC state is Undefined and set it to Pending\n", '        if (kycStatus[msg.sender] == KycState.Undefined) {\n', '            kycStatus[msg.sender] = KycState.Pending;\n', '        }\n', '\n', '        if (kycStatus[msg.sender] == KycState.Pending) {\n', '            // KYC is Pending: register pending contribution\n', '            addPendingContribution(msg.sender, msg.value, parsecValue);\n', '        } else if (kycStatus[msg.sender] == KycState.Accepted) {\n', '            // KYC is Accepted: register accepted contribution\n', '            addAcceptedContribution(msg.sender, msg.value, parsecValue);\n', '        } else {\n', '            // KYC is Declined: revert transaction\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can withdraw Parsecs anytime in case of emergency\n', '    function emergencyWithdrawParsecs(uint256 value) external onlyOwnerOrMultisig {\n', '        // Amount of Parsecs to withdraw should not exceed current balance\n', '        require(value > 0);\n', '        require(value <= parsecToken.balanceOf(this));\n', '\n', '        // Transfer parsecs\n', '        parsecToken.transfer(msg.sender, value);\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can refund contract with ETH in case of failed Crowdsale\n', '    function emergencyRefundContract() external payable onlyOwnerOrMultisig {\n', '        // Contract should be failed previously\n', '        require(contractFailed);\n', '        \n', '        // Amount of ETH should be positive\n', '        require(msg.value > 0);\n', '    }\n', '\n', '    /// @notice Contract owner or Multisig can clawback ether after refund period is finished\n', '    function emergencyClawbackEther(uint256 value) external onlyOwnerOrMultisig {\n', '        // Contract should be failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should be started and finished previously\n', '        require(contractRefundStarted);\n', '        require(contractRefundFinished);\n', '        \n', '        // Amount of ETH should be positive and not exceed current contract balance\n', '        require(value > 0);\n', '        require(value <= address(this).balance);\n', '\n', '        // Transfer ETH to Multisig\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    /// @notice Set Auditor account address to a new value\n', '    function ownerSetAuditor(address _auditorAddress) external onlyOwner {\n', '        // Auditor address cannot be zero\n', '        require(_auditorAddress != 0x0);\n', '\n', '        // Change Auditor account address\n', '        auditorAddress = _auditorAddress;\n', '    }\n', '\n', '    /// @notice Check if contract has enough Parsecs to cover hard cap\n', '    function ownerPowerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractPoweredUp);\n', '\n', '        // Contract should have enough Parsec credits\n', '        require(parsecToken.balanceOf(this) >= PARSECS_TOTAL_AMOUNT);\n', '\n', '        // Raise contract power-up flag\n', '        contractPoweredUp = true;\n', '    }\n', '\n', '    /// @notice Start contract (permanently)\n', '    function ownerStartContract() external onlyOwner {\n', '        // Contract should be powered up previously\n', '        require(contractPoweredUp);\n', '\n', '        // Contract should not be started previously\n', '        require(!contractStarted);\n', '\n', '        // Raise contract started flag\n', '        contractStarted = true;\n', '    }\n', '\n', '    /// @notice Finish contract (permanently)\n', '    function ownerFinishContract() external onlyOwner {\n', '        // Contract should be started previously\n', '        require(contractStarted);\n', '\n', '        // Contract should not be finished previously\n', '        require(!contractFinished);\n', '\n', '        // Raise contract finished flag\n', '        contractFinished = true;\n', '    }\n', '\n', '    /// @notice Pause contract (transiently)\n', '    function ownerPauseContract() external onlyOwner {\n', '        // Contract should be started previously\n', '        require(contractStarted);\n', '\n', '        // Contract should not be finished previously\n', '        require(!contractFinished);\n', '\n', '        // Contract should not be paused previously\n', '        require(!contractPaused);\n', '\n', '        // Raise contract paused flag\n', '        contractPaused = true;\n', '    }\n', '\n', '    /// @notice Resume contract (transiently)\n', '    function ownerResumeContract() external onlyOwner {\n', '        // Contract should be paused previously\n', '        require(contractPaused);\n', '\n', '        // Unset contract paused flag\n', '        contractPaused = false;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale failure (no more ETH are accepted from participants)\n', '    function ownerDeclareFailure() external onlyOwner {\n', '        // Contract should NOT BE failed previously\n', '        require(!contractFailed);\n', '\n', '        // Raise contract failed flag\n', '        contractFailed = true;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale refund start\n', '    function ownerDeclareRefundStart() external onlyOwner {\n', '        // Contract should BE failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should NOT BE started previously\n', '        require(!contractRefundStarted);\n', '\n', '        // Contract should NOT have any pending KYC requests\n', '        require(pendingFunding == 0x0);\n', '\n', '        // Contract should have enough ETH to perform refunds\n', '        require(address(this).balance >= raisedFunding);\n', '\n', '        // Raise contract refund started flag\n', '        contractRefundStarted = true;\n', '    }\n', '\n', '    /// @notice Declare Crowdsale refund finish\n', '    function ownerDeclareRefundFinish() external onlyOwner {\n', '        // Contract should BE failed previously\n', '        require(contractFailed);\n', '\n', '        // Contract refund should BE started previously\n', '        require(contractRefundStarted);\n', '\n', '        // Contract refund should NOT BE finished previously\n', '        require(!contractRefundFinished);\n', '\n', '        // Raise contract refund finished flag\n', '        contractRefundFinished = true;\n', '    }\n', '\n', '    /// @notice Owner can withdraw Parsecs only after contract is finished\n', '    function ownerWithdrawParsecs(uint256 value) external onlyOwner {\n', '        // Contract should be finished before any Parsecs could be withdrawn\n', '        require(contractFinished);\n', '\n', '        // Get smart contract balance in Parsecs\n', '        uint256 parsecBalance = parsecToken.balanceOf(this);\n', '\n', '        // Calculate maximal amount to withdraw\n', '        uint256 maxAmountToWithdraw = parsecBalance.sub(pendingParsecs);\n', '\n', '        // Maximal amount to withdraw should be greater than zero and not greater than total balance\n', '        require(maxAmountToWithdraw > 0);\n', '        require(maxAmountToWithdraw <= parsecBalance);\n', '\n', '        // Amount of Parsecs to withdraw should not exceed maxAmountToWithdraw\n', '        require(value > 0);\n', '        require(value <= maxAmountToWithdraw);\n', '\n', '        // Transfer parsecs\n', '        parsecToken.transfer(owner, value);\n', '    }\n', ' \n', "    /// @dev Accept participant's KYC\n", '    function acceptKyc(address participant) external onlyOwnerOrAuditor {\n', "        // Set participant's KYC status to Accepted\n", '        kycStatus[participant] = KycState.Accepted;\n', '\n', '        // Get pending amounts in ETH and Parsecs\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\n', '\n', "        // Log an event of the participant's KYC accept\n", '        LogKycAccept(participant, pendingAmountOfEth, now);\n', '\n', '        if (pendingAmountOfEth > 0 || pendingAmountOfParsecs > 0) {\n', '            // Reset pending contribution\n', '            resetPendingContribution(participant);\n', '\n', '            // Add accepted contribution\n', '            addAcceptedContribution(participant, pendingAmountOfEth, pendingAmountOfParsecs);\n', '        }\n', '    }\n', '\n', "    /// @dev Decline participant's KYC\n", '    function declineKyc(address participant) external onlyOwnerOrAuditor {\n', "        // Set participant's KYC status to Declined\n", '        kycStatus[participant] = KycState.Declined;\n', '\n', "        // Log an event of the participant's KYC decline\n", '        LogKycDecline(participant, pendingAmountOfEth, now);\n', '\n', '        // Get pending ETH amount\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '\n', '        if (pendingAmountOfEth > 0) {\n', '            // Reset pending contribution\n', '            resetPendingContribution(participant);\n', '\n', '            // Transfer ETH back to participant\n', '            participant.transfer(pendingAmountOfEth);\n', '        }\n', '    }\n', '\n', '    /// @dev Allow participants to clawback ETH in case of Crowdsale failure\n', '    function participantClawbackEther(uint256 value) external {\n', '        // Participant cannot withdraw ETH if refund is not started or after it is finished\n', '        require(contractRefundStarted);\n', '        require(!contractRefundFinished);\n', '\n', '        // Get total contribution of participant\n', '        uint256 totalContribution = contributionOf[msg.sender];\n', '\n', '        // Get already refunded amount\n', '        uint256 alreadyRefunded = refundOf[msg.sender];\n', '\n', '        // Calculate maximal withdrawal amount\n', '        uint256 maxWithdrawalAmount = totalContribution.sub(alreadyRefunded);\n', '\n', '        // Maximal withdrawal amount should not be zero\n', '        require(maxWithdrawalAmount > 0);\n', '\n', '        // Requested value should not exceed maximal withdrawal amount\n', '        require(value > 0);\n', '        require(value <= maxWithdrawalAmount);\n', '\n', "        // Participant's refundOf is increased by the claimed amount\n", '        refundOf[msg.sender] = alreadyRefunded.add(value);\n', '\n', '        // Total refound amount is increased\n', '        refundedFunding = refundedFunding.add(value);\n', '\n', "        // Send ethers back to the participant's account\n", '        msg.sender.transfer(value);\n', '    }\n', '\n', '    /// @dev Register pending contribution\n', '    function addPendingContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\n', "        // Participant's pending contribution is increased by ethValue\n", '        pendingContributionOf[participant] = pendingContributionOf[participant].add(ethValue);\n', '\n', '        // Parsecs pending to participant increased by parsecValue\n', '        pendingParsecsOf[participant] = pendingParsecsOf[participant].add(parsecValue);\n', '\n', '        // Increase pending funding by ethValue\n', '        pendingFunding = pendingFunding.add(ethValue);\n', '\n', '        // Increase pending Parsecs by parsecValue\n', '        pendingParsecs = pendingParsecs.add(parsecValue);\n', '    }\n', '\n', '    /// @dev Register accepted contribution\n', '    function addAcceptedContribution(address participant, uint256 ethValue, uint256 parsecValue) private {\n', "        // Participant's contribution is increased by ethValue\n", '        contributionOf[participant] = contributionOf[participant].add(ethValue);\n', '\n', '        // Parsecs rewarded to participant increased by parsecValue\n', '        parsecsOf[participant] = parsecsOf[participant].add(parsecValue);\n', '\n', '        // Increase total raised funding by ethValue\n', '        raisedFunding = raisedFunding.add(ethValue);\n', '\n', '        // Increase spent Parsecs by parsecValue\n', '        spentParsecs = spentParsecs.add(parsecValue);\n', '\n', "        // Log an event of the participant's contribution\n", '        LogContribution(participant, ethValue, parsecValue, now);\n', '\n', '        // Transfer ETH to Multisig\n', '        multisigAddress.transfer(ethValue);\n', '\n', '        // Transfer Parsecs to participant\n', '        parsecToken.transfer(participant, parsecValue);\n', '    }\n', '\n', '    /// @dev Reset pending contribution\n', '    function resetPendingContribution(address participant) private {\n', '        // Get amounts of pending ETH and Parsecs\n', '        uint256 pendingAmountOfEth = pendingContributionOf[participant];\n', '        uint256 pendingAmountOfParsecs = pendingParsecsOf[participant];\n', '\n', '        // Decrease pending contribution by pendingAmountOfEth\n', '        pendingContributionOf[participant] = pendingContributionOf[participant].sub(pendingAmountOfEth);\n', '\n', '        // Decrease pending Parsecs reward by pendingAmountOfParsecs\n', '        pendingParsecsOf[participant] = pendingParsecsOf[participant].sub(pendingAmountOfParsecs);\n', '\n', '        // Decrease pendingFunding by pendingAmountOfEth\n', '        pendingFunding = pendingFunding.sub(pendingAmountOfEth);\n', '\n', '        // Decrease pendingParsecs by pendingAmountOfParsecs\n', '        pendingParsecs = pendingParsecs.sub(pendingAmountOfParsecs);\n', '    }\n', '\n', '    /// @dev Calculate amount of Parsecs to grant for ETH contribution\n', '    function calculateReward(uint256 ethValue) private view returns (uint256 amount) {\n', '        // Define base quotient\n', '        uint256 baseQuotient = 1000;\n', '\n', '        // Calculate actual quotient according to current bonus tier\n', '        uint256 actualQuotient = baseQuotient.add(calculateBonusTierQuotient());\n', '\n', '        // Calculate reward amount\n', '        uint256 reward = ethValue.mul(PARSECS_PER_ETHER_BASE);\n', '        reward = reward.mul(actualQuotient);\n', '        reward = reward.div(baseQuotient);\n', '        return reward.div(1 ether);\n', '    }\n', '\n', '    /// @dev Calculate current bonus tier quotient\n', '    function calculateBonusTierQuotient() private view returns (uint256 quotient) {\n', '        uint256 funding = raisedFunding.add(pendingFunding);\n', '\n', '        if (funding < BONUS_TIER_1_LIMIT) {\n', '            return 300;     // 30.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_2_LIMIT) {\n', '            return 275;     // 27.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_3_LIMIT) {\n', '            return 250;     // 25.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_4_LIMIT) {\n', '            return 225;     // 22.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_5_LIMIT) {\n', '            return 200;     // 20.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_6_LIMIT) {\n', '            return 175;     // 17.5 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_7_LIMIT) {\n', '            return 150;     // 15.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_8_LIMIT) {\n', '            return 100;     // 10.0 % bonus Parsecs\n', '        } else if (funding < BONUS_TIER_9_LIMIT) {\n', '            return 50;      // 5.00 % bonus Parsecs\n', '        } else {\n', '            return 0;       // 0.00 % bonus Parsecs\n', '        }\n', '    }\n', '}']
