['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', '        // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', '    // NB: using bytes32 rather than the string type because it&#39;s cheaper gas-wise:\n', '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/*\n', ' Generic symbol / WEI rates contract.\n', ' only callable by trusted price oracles.\n', ' Being regularly called by a price oracle\n', '*/\n', '\n', 'contract Rates is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    struct RateInfo {\n', '        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n', '                    // 0 rate means no rate info available\n', '        uint lastUpdated;\n', '    }\n', '\n', '    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n', '    mapping(bytes32 => RateInfo) public rates;\n', '\n', '    event RateChanged(bytes32 symbol, uint newRate);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function setRate(bytes32 symbol, uint newRate) external restrict("RatesFeeder") {\n', '        rates[symbol] = RateInfo(newRate, now);\n', '        emit RateChanged(symbol, newRate);\n', '    }\n', '\n', '    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict("RatesFeeder") {\n', '        require(symbols.length == newRates.length, "symobls and newRates lengths must be equal");\n', '        for (uint256 i = 0; i < symbols.length; i++) {\n', '            rates[symbols[i]] = RateInfo(newRates[i], now);\n', '            emit RateChanged(symbols[i], newRates[i]);\n', '        }\n', '    }\n', '\n', '    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n', '    }\n', '\n', '    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n', '        // next line would revert with div by zero but require to emit reason\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        /* TODO: can we make this not loosing max scale? */\n', '        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', "    // NB: using bytes32 rather than the string type because it's cheaper gas-wise:\n", '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/*\n', ' Generic symbol / WEI rates contract.\n', ' only callable by trusted price oracles.\n', ' Being regularly called by a price oracle\n', '*/\n', '\n', 'contract Rates is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    struct RateInfo {\n', '        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n', '                    // 0 rate means no rate info available\n', '        uint lastUpdated;\n', '    }\n', '\n', '    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n', '    mapping(bytes32 => RateInfo) public rates;\n', '\n', '    event RateChanged(bytes32 symbol, uint newRate);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function setRate(bytes32 symbol, uint newRate) external restrict("RatesFeeder") {\n', '        rates[symbol] = RateInfo(newRate, now);\n', '        emit RateChanged(symbol, newRate);\n', '    }\n', '\n', '    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict("RatesFeeder") {\n', '        require(symbols.length == newRates.length, "symobls and newRates lengths must be equal");\n', '        for (uint256 i = 0; i < symbols.length; i++) {\n', '            rates[symbols[i]] = RateInfo(newRates[i], now);\n', '            emit RateChanged(symbols[i], newRates[i]);\n', '        }\n', '    }\n', '\n', '    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n', '    }\n', '\n', '    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n', '        // next line would revert with div by zero but require to emit reason\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        /* TODO: can we make this not loosing max scale? */\n', '        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n', '    }\n', '\n', '}']
