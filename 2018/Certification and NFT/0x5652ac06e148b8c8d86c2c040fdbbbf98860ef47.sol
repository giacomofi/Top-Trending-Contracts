['pragma solidity ^0.4.13;\n', '\n', 'contract DBC {\n', '\n', '    // MODIFIERS\n', '\n', '    modifier pre_cond(bool condition) {\n', '        require(condition);\n', '        _;\n', '    }\n', '\n', '    modifier post_cond(bool condition) {\n', '        _;\n', '        assert(condition);\n', '    }\n', '\n', '    modifier invariant(bool condition) {\n', '        require(condition);\n', '        _;\n', '        assert(condition);\n', '    }\n', '}\n', '\n', 'contract Competition is DBC {\n', '\n', '    // TYPES\n', '\n', '    struct Hopeful { // Someone who wants to succeed or who seems likely to win\n', '        address fund; // Address of the Melon fund\n', '        address manager; // Address of the fund manager, as used in the ipfs-frontend\n', '        address registrant; // Manager (== owner) of above Melon fund\n', '        bool hasSigned; // Whether initial requirements passed and Hopeful signed Terms and Conditions; Does not mean Hopeful is competing yet\n', '        address buyinAsset; // Asset (ERC20 Token) spent to take part in competition\n', '        address payoutAsset; // Asset (usually Melon Token) to be received as prize\n', '        uint buyinQuantity; // Quantity of buyinAsset spent\n', '        uint payoutQuantity; // Quantity of payoutAsset received as prize\n', '        address payoutAddress; // Address to payout in main chain\n', '        bool isCompeting; // Whether outside oracle verified remaining requirements; If yes Hopeful is taking part in a competition\n', '        bool isDisqualified; // Whether participant is disqualified\n', '        uint finalSharePrice; // Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\n', '        uint finalCompetitionRank; // Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\n', '    }\n', '\n', '    struct HopefulId {\n', '      uint id; // Actual Hopeful Id\n', '      bool exists; // Used to check if the mapping exists\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // Constant fields\n', '    // Competition terms and conditions as displayed on https://ipfs.io/ipfs/QmQ7DqjpxmTDbaxcH5qwv8QmGvJY7rhb8UV2QRfCEFBp8V\n', '    // IPFS hash encoded using http://lenschulwitz.com/base58\n', '    bytes32 public constant TERMS_AND_CONDITIONS = 0x1A46B45CC849E26BB3159298C3C218EF300D015ED3E23495E77F0E529CE9F69E;\n', '    uint public MELON_BASE_UNIT = 10 ** 18;\n', '    // Constructor fields\n', '    address public oracle; // Information e.g. from Kovan can be passed to contract from this address\n', '    uint public startTime; // Competition start time in seconds (Temporarily Set)\n', '    uint public endTime; // Competition end time in seconds\n', '    uint public maxbuyinQuantity; // Limit amount of deposit to participate in competition\n', '    uint public maxHopefulsNumber; // Limit number of participate in competition\n', '    uint public prizeMoneyAsset; // Equivalent to payoutAsset\n', '    uint public prizeMoneyQuantity; // Total prize money pool\n', '    address public MELON_ASSET; // Adresss of Melon asset contract\n', '    ERC20Interface public MELON_CONTRACT; // Melon as ERC20 contract\n', '    Certifier public CERTIFIER; // Parity KYC verification contract\n', '    // Methods fields\n', '    Hopeful[] public hopefuls; // List of all hopefuls, can be externally accessed\n', '    mapping (address => address) public registeredFundToRegistrants; // For fund address indexed accessing of registrant addresses\n', '    mapping(address => HopefulId) public registrantToHopefulIds; // For registrant address indexed accessing of hopeful ids\n', '\n', '    //EVENTS\n', '\n', '    event Register(uint withId, address fund, address manager);\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    /// @dev Proofs that terms and conditions have been read and understood\n', '    /// @param byManager Address of the fund manager, as used in the ipfs-frontend\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    /// @return Whether or not terms and conditions have been read and understood\n', '    function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool) {\n', '        return ecrecover(\n', '            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\n', '            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\n', '            //  it will return rsv (same as geth; where v is [27, 28]).\n', '            // Note that if you are using ecrecover, v will be either "00" or "01".\n', '            //  As a result, in order to use this value, you will have to parse it to an\n', '            //  integer and then add 27. This will result in either a 27 or a 28.\n', '            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\n', '            keccak256("\\x19Ethereum Signed Message:\\n32", TERMS_AND_CONDITIONS),\n', '            v,\n', '            r,\n', '            s\n', '        ) == byManager; // Has sender signed TERMS_AND_CONDITIONS\n', '    }\n', '\n', '    /// @return Whether message sender is oracle or not\n', '    function isOracle() view returns (bool) { return msg.sender == oracle; }\n', '\n', '    /// @dev Whether message sender is KYC verified through CERTIFIER\n', '    /// @param x Address to be checked for KYC verification\n', '    function isKYCVerified(address x) view returns (bool) { return CERTIFIER.certified(x); }\n', '\n', '    // CONSTANT METHODS\n', '\n', '    function getMelonAsset() view returns (address) { return MELON_ASSET; }\n', '\n', '    /// @return Get HopefulId from registrant address\n', '    function getHopefulId(address x) view returns (uint) { return registrantToHopefulIds[x].id; }\n', '\n', '    /**\n', '    @notice Returns an array of fund addresses and an associated array of whether competing and whether disqualified\n', '    @return {\n', '      "fundAddrs": "Array of addresses of Melon Funds",\n', '      "fundManagers": "Array of addresses of Melon fund managers, as used in the ipfs-frontend",\n', '      "areCompeting": "Array of boolean of whether or not fund is competing"\n', '      "areDisqualified": "Array of boolean of whether or not fund is disqualified"\n', '    }\n', '    */\n', '    function getCompetitionStatusOfHopefuls()\n', '        view\n', '        returns(\n', '            address[] fundAddrs,\n', '            address[] fundManagers,\n', '            bool[] areCompeting,\n', '            bool[] areDisqualified\n', '        )\n', '    {\n', '        for (uint i = 0; i <= hopefuls.length - 1; i++) {\n', '            fundAddrs[i] = hopefuls[i].fund;\n', '            fundManagers[i] = hopefuls[i].manager;\n', '            areCompeting[i] = hopefuls[i].isCompeting;\n', '            areDisqualified[i] = hopefuls[i].isDisqualified;\n', '        }\n', '        return (fundAddrs, fundManagers, areCompeting, areDisqualified);\n', '    }\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function Competition(\n', '        address ofMelonAsset,\n', '        address ofOracle,\n', '        address ofCertifier,\n', '        uint ofStartTime,\n', '        uint ofMaxbuyinQuantity,\n', '        uint ofMaxHopefulsNumber\n', '    ) {\n', '        MELON_ASSET = ofMelonAsset;\n', '        MELON_CONTRACT = ERC20Interface(MELON_ASSET);\n', '        oracle = ofOracle;\n', '        CERTIFIER = Certifier(ofCertifier);\n', '        startTime = ofStartTime;\n', '        endTime = startTime + 2 weeks;\n', '        maxbuyinQuantity = ofMaxbuyinQuantity;\n', '        maxHopefulsNumber = ofMaxHopefulsNumber;\n', '    }\n', '\n', '    /// @notice Register to take part in the competition\n', '    /// @param fund Address of the Melon fund\n', '    /// @param buyinAsset Asset (ERC20 Token) spent to take part in competition\n', '    /// @param payoutAsset Asset (usually Melon Token) to be received as prize\n', '    /// @param buyinQuantity Quantity of buyinAsset spent\n', '    /// @param v ellipitc curve parameter v\n', '    /// @param r ellipitc curve parameter r\n', '    /// @param s ellipitc curve parameter s\n', '    function registerForCompetition(\n', '        address fund,\n', '        address manager,\n', '        address buyinAsset,\n', '        address payoutAsset,\n', '        address payoutAddress,\n', '        uint buyinQuantity,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        pre_cond(termsAndConditionsAreSigned(manager, v, r, s) && isKYCVerified(msg.sender))\n', '        pre_cond(registeredFundToRegistrants[fund] == address(0) && registrantToHopefulIds[msg.sender].exists == false)\n', '    {\n', '        require(buyinAsset == MELON_ASSET && payoutAsset == MELON_ASSET);\n', '        require(buyinQuantity <= maxbuyinQuantity && hopefuls.length <= maxHopefulsNumber);\n', '        registeredFundToRegistrants[fund] = msg.sender;\n', '        registrantToHopefulIds[msg.sender] = HopefulId({id: hopefuls.length, exists: true});\n', '        Register(hopefuls.length, fund, msg.sender);\n', '        hopefuls.push(Hopeful({\n', '          fund: fund,\n', '          manager: manager,\n', '          registrant: msg.sender,\n', '          hasSigned: true,\n', '          buyinAsset: buyinAsset,\n', '          payoutAsset: payoutAsset,\n', '          payoutAddress: payoutAddress,\n', '          buyinQuantity: buyinQuantity,\n', '          payoutQuantity: 0,\n', '          isCompeting: true,\n', '          isDisqualified: false,\n', '          finalSharePrice: 0,\n', '          finalCompetitionRank: 0\n', '        }));\n', '    }\n', '\n', '    /// @notice Disqualify and participant\n', '    /// @dev Only the oracle can call this function\n', '    /// @param withId Index of Hopeful to disqualify\n', '    function disqualifyHopeful(\n', '        uint withId\n', '    )\n', '        pre_cond(isOracle())\n', '    {\n', '        hopefuls[withId].isDisqualified = true;\n', '    }\n', '\n', '    /// @notice Closing oracle service, inputs final stats and triggers payouts\n', '    /// @dev Only the oracle can call this function\n', '    /// @param withId Index of Hopeful to be attest for\n', '    /// @param payoutQuantity Quantity of payoutAsset received as prize\n', '    /// @param finalSharePrice Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\n', '    /// @param finalCompetitionRank Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\n', '    function finalizeAndPayoutForHopeful(\n', '        uint withId,\n', '        uint payoutQuantity, // Quantity of payoutAsset received as prize\n', '        uint finalSharePrice, // Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\n', '        uint finalCompetitionRank // Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\n', '    )\n', '        pre_cond(isOracle())\n', '        pre_cond(hopefuls[withId].isDisqualified == false)\n', '        pre_cond(block.timestamp >= endTime)\n', '    {\n', '        hopefuls[withId].finalSharePrice = finalSharePrice;\n', '        hopefuls[withId].finalCompetitionRank = finalCompetitionRank;\n', '        hopefuls[withId].payoutQuantity = payoutQuantity;\n', '        require(MELON_CONTRACT.transfer(hopefuls[withId].registrant, payoutQuantity));\n', '    }\n', '\n', '    /// @notice Changes certifier contract address\n', '    /// @dev Only the oracle can call this function\n', '    /// @param newCertifier Address of the new certifier\n', '    function changeCertifier(\n', '        address newCertifier\n', '    )\n', '        pre_cond(isOracle())\n', '    {\n', '        CERTIFIER = Certifier(newCertifier);\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    // EVENTS\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    // CONSTANT METHODS\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '}\n', '\n', 'contract Owned {\n', '\tmodifier only_owner { if (msg.sender != owner) return; _; }\n', '\n', '\tevent NewOwner(address indexed old, address indexed current);\n', '\n', '\tfunction setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }\n', '\n', '\taddress public owner = msg.sender;\n', '}\n', '\n', 'contract Certifier {\n', '\tevent Confirmed(address indexed who);\n', '\tevent Revoked(address indexed who);\n', '\tfunction certified(address _who) constant returns (bool);\n', '\tfunction get(address _who, string _field) constant returns (bytes32) {}\n', '\tfunction getAddress(address _who, string _field) constant returns (address) {}\n', '\tfunction getUint(address _who, string _field) constant returns (uint) {}\n', '}\n', '\n', 'contract SimpleCertifier is Owned, Certifier {\n', '\tmodifier only_delegate { if (msg.sender != delegate) return; _; }\n', '\tmodifier only_certified(address _who) { if (!certs[_who].active) return; _; }\n', '\n', '\tstruct Certification {\n', '\t\tbool active;\n', '\t\tmapping (string => bytes32) meta;\n', '\t}\n', '\n', '\tfunction certify(address _who) only_delegate {\n', '\t\tcerts[_who].active = true;\n', '\t\tConfirmed(_who);\n', '\t}\n', '\tfunction revoke(address _who) only_delegate only_certified(_who) {\n', '\t\tcerts[_who].active = false;\n', '\t\tRevoked(_who);\n', '\t}\n', '\tfunction certified(address _who) constant returns (bool) { return certs[_who].active; }\n', '\tfunction get(address _who, string _field) constant returns (bytes32) { return certs[_who].meta[_field]; }\n', '\tfunction getAddress(address _who, string _field) constant returns (address) { return address(certs[_who].meta[_field]); }\n', '\tfunction getUint(address _who, string _field) constant returns (uint) { return uint(certs[_who].meta[_field]); }\n', '\tfunction setDelegate(address _new) only_owner { delegate = _new; }\n', '\n', '\tmapping (address => Certification) certs;\n', "\t// So that the server posting puzzles doesn't have access to the ETH.\n", '\taddress public delegate = msg.sender;\n', '}']