['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "ONLY OWNER IS ALLOWED");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract IBelottoToken{\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function burn(uint256 _value) public;\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '}\n', '\n', '/**\n', ' * @title BelottoCrowdsale\n', ' * @dev BelottoCrowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract BelottoCrowdsale is Owned {\n', '  using SafeMath for uint256; \n', '  uint256 public presaleopeningTime;\n', '  uint256 public presaleclosingTime;\n', '  uint256 public saleopeningTime;\n', '  uint256 public saleclosingTime;\n', '  uint256 public secondsaleopeningTime;\n', '  uint256 public secondsaleclosingTime;\n', '  address public reserverWallet;    // Address where reserve tokens will be sent\n', '  address public bountyWallet;      // Address where bounty tokens will be sent\n', '  address public teamsWallet;       // Address where team&#39;s tokens will be sent\n', '  address public fundsWallet;       // Address where funds are collected\n', '  uint256 public fundsRaised;         // Amount of total fundsRaised\n', '  uint256 public preSaleTokens;\n', '  uint256 public saleTokens;\n', '  uint256 public teamAdvTokens;\n', '  uint256 public reserveTokens;\n', '  uint256 public bountyTokens;\n', '  uint256 public hardCap;\n', '  uint256 public minTxSize;\n', '  uint256 public maxTxSize;\n', '  bool    public presaleOpen;\n', '  bool    public firstsaleOpen;\n', '  bool    public secondsaleOpen;\n', '  mapping(address => uint) preSaleFunds;\n', '  mapping(address => uint) firstSaleFunds;\n', '  mapping(address => uint) secondSaleFunds;\n', '  struct Funds {\n', '    address spender;\n', '    uint256 amount;\n', '    uint256 time;\n', '    }\n', '    Funds[]  preSaleFundsArray;\n', '    Funds[]  firstSaleFundsArray;\n', '    Funds[]  secondSaleFundsArray;\n', '  \n', '  IBelottoToken public token;\n', '  \n', '  event Burn(address indexed burner, uint256 value);\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  /** @dev Reverts if not in crowdsale time range. */\n', '  modifier onlyWhilePreSaleOpen {\n', '    require(now >= presaleopeningTime && now <= presaleclosingTime, "Pre Sale Close");\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhileFirstSaleOpen {\n', '    require(now >= saleopeningTime && now <= saleclosingTime, "First Sale Close");\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhileSecondSaleOpen {\n', '    require(now >= secondsaleopeningTime && now <= secondsaleclosingTime, "Second Sale Close");\n', '    _;\n', '  }\n', '  \n', '  function totalRemainingTokens() public view returns(uint256 remainingTokens){\n', '    return token.balanceOf(this);      \n', '  }\n', '  \n', '  function BelottoCrowdsale(uint256 _preST, uint256 _saleT, uint256 _teamAdvT, uint256 _reserveT, uint256 _bountyT, address _reserverWallet, \n', '                            address _bountyWallet, address _teamsWallet, address _fundsWallet, address _tokenContractAdd, address _owner) \n', '                            public {\n', '    \n', '    \n', '    _setWallets(_reserverWallet,_bountyWallet,_teamsWallet,_fundsWallet);\n', '    _setMoreDetails(_preST,_saleT,_teamAdvT,_reserveT,_bountyT,_owner);\n', '    _setTimes();\n', '    \n', '    // takes an address of the existing token contract as parameter\n', '    token = IBelottoToken(_tokenContractAdd);\n', '  }\n', '  \n', '  function _setTimes() internal{\n', '    presaleopeningTime    = 1524873600; // 28th April 2018 00:00:00 GMT \n', '    presaleclosingTime    = 1527379199; // 26th May 2018 23:59:59 GMT   \n', '    saleopeningTime       = 1527724800; // 31st May 2018 00:00:00 GMT \n', '    saleclosingTime       = 1532908799; // 29th July 2018 23:59:59 GMT\n', '    secondsaleopeningTime = 1532908800; // 30th July 2018 00:00:00 GMT\n', '    secondsaleclosingTime = 1535673599; // 30th August 2018 23:59:59 GMT\n', '  }\n', '  \n', '  function _setWallets(address _reserverWallet, address _bountyWallet, address _teamsWallet, address _fundsWallet) internal{\n', '    reserverWallet        = _reserverWallet;\n', '    bountyWallet          = _bountyWallet;\n', '    teamsWallet           = _teamsWallet;\n', '    fundsWallet           = _fundsWallet;\n', '  }\n', '  \n', '  function _setMoreDetails(uint256 _preST, uint256 _saleT, uint256 _teamAdvT, uint256 _reserveT, uint256 _bountyT, address _owner) internal{\n', '    preSaleTokens         = _preST * 10**uint(18);\n', '    saleTokens            = _saleT * 10**uint(18);\n', '    teamAdvTokens         = _teamAdvT * 10**uint(18);\n', '    reserveTokens         = _reserveT * 10**uint(18);\n', '    bountyTokens          = _bountyT * 10**uint(18);\n', '    hardCap               = 16000 * 10**(uint(18));   //in start only, it&#39;ll be set by Owner\n', '    minTxSize             = 100000000000000000; // in wei&#39;s. (0,1 ETH)\n', '    maxTxSize             = 200000000000000000000; // in wei&#39;s. (200 ETH)\n', '    owner = _owner;\n', '  }\n', '  \n', '  function TokenAllocate(address _wallet,uint256 _amount) internal returns (bool success) {\n', '      uint256 tokenAmount = _amount;\n', '      token.transfer(_wallet,tokenAmount);\n', '      return true;\n', '  }\n', '  \n', '  function startSecondSale() public onlyOwner{\n', '      presaleOpen = false;\n', '      firstsaleOpen  = false;\n', '      secondsaleOpen = true;\n', '  }\n', '  \n', '  \n', '  function stopSecondSale() public onlyOwner{\n', '      presaleOpen = false;\n', '      firstsaleOpen = false;\n', '      secondsaleOpen = false;\n', '      if(teamAdvTokens >= 0 && bountyTokens >=0){\n', '          TokenAllocate(teamsWallet,teamAdvTokens);\n', '          teamAdvTokens = 0;\n', '          TokenAllocate(bountyWallet,bountyTokens);\n', '          bountyTokens = 0;\n', '      }\n', '  }\n', '\n', '  function _checkOpenings(uint256 _weiAmount) internal{\n', '      if((fundsRaised + _weiAmount >= hardCap)){\n', '            presaleOpen = false;\n', '            firstsaleOpen  = false;\n', '            secondsaleOpen = true;\n', '      }\n', '      else if(secondsaleOpen){\n', '          presaleOpen = false;\n', '          firstsaleOpen  = false;\n', '          secondsaleOpen = true;\n', '      }\n', '      else if(now >= presaleopeningTime && now <= presaleclosingTime){\n', '          presaleOpen = true;\n', '          firstsaleOpen = false;\n', '          secondsaleOpen = false;\n', '          if(reserveTokens >= 0){\n', '            if(TokenAllocate(reserverWallet,reserveTokens)){\n', '                reserveTokens = 0;\n', '            }\n', '          }\n', '      }\n', '      else if(now >= saleopeningTime && now <= saleclosingTime){\n', '          presaleOpen = false;\n', '          firstsaleOpen = true;\n', '          secondsaleOpen = false;\n', '      }\n', '      else if(now >= secondsaleopeningTime && now <= secondsaleclosingTime){\n', '            presaleOpen = false;\n', '            firstsaleOpen  = false;\n', '            secondsaleOpen = true;\n', '      }\n', '      else{\n', '          presaleOpen = false;\n', '          firstsaleOpen = false;\n', '          secondsaleOpen = false;\n', '          if(teamAdvTokens >= 0 && bountyTokens >=0){\n', '            TokenAllocate(teamsWallet,teamAdvTokens);\n', '            teamAdvTokens = 0;\n', '            TokenAllocate(bountyWallet,bountyTokens);\n', '            bountyTokens = 0;\n', '          }\n', '      }\n', '  }\n', '  \n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {\n', '    \n', '    uint256 ethers = msg.value;\n', '    \n', '    _preValidatePurchase(_beneficiary, ethers);\n', '    \n', '    _checkOpenings(ethers);\n', '    \n', '    _setFunds(_beneficiary,ethers);\n', '    \n', '    // update state of wei&#39;s raised during complete ICO\n', '    fundsRaised = fundsRaised.add(ethers);\n', '    //sjfhj\n', '    _forwardFunds(_beneficiary); \n', '  }\n', '  \n', '  function _setFunds(address _beneficiary, uint256 _ethers) internal{\n', '      if(presaleOpen){\n', '          preSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '      else if(firstsaleOpen){\n', '          firstSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '      else if(secondsaleOpen){\n', '          secondSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '  }\n', '  \n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal{\n', '   require(_beneficiary != address(0), "WRONG Address");\n', '   require(_weiAmount != 0, "Insufficient funds");\n', '   require(_weiAmount >= minTxSize  && _weiAmount <= maxTxSize ,"FUNDS should be MIN 0,1 ETH and Max 200 ETH");\n', '  }\n', '  \n', '  function TotalSpenders() public view returns (uint256 preSaleSpenders,uint256 firstSaleSpenders,uint256 secondSaleSpenders){\n', '      return ((preSaleFundsArray.length),(firstSaleFundsArray.length),(secondSaleFundsArray.length));\n', '  }\n', '  \n', '  function _forwardFunds(address _beneficiary) internal {\n', '    fundsWallet.transfer(msg.value);\n', '  }\n', '  \n', '  function preSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      _checkOpenings(0);\n', '      require(!presaleOpen, "Pre-Sale is NOT CLOSE ");\n', '      require(preSaleTokens >= _tokenAmount,"NO Pre-SALE Tokens Available");\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      preSaleTokens = preSaleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  function firstSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      require(!presaleOpen && !firstsaleOpen, "First Sale is NOT CLOSE");\n', '      if(saleTokens <= _tokenAmount && preSaleTokens >= _tokenAmount){\n', '          saleTokens = saleTokens.add(_tokenAmount);\n', '          preSaleTokens = preSaleTokens.sub(_tokenAmount);\n', '      }\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      saleTokens = saleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  function secondSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      require(!presaleOpen && !firstsaleOpen && !secondsaleOpen, "Second Sale is NOT CLOSE");\n', '      require(saleTokens >= _tokenAmount,"NO Sale Tokens Available");\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      saleTokens = saleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burnTokens(uint256 _value) public onlyOwner {\n', '      token.burn(_value);\n', '  }\n', ' \n', '  function preSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (preSaleFundsArray[_index].spender,preSaleFundsArray[_index].amount,preSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  function firstSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (firstSaleFundsArray[_index].spender,firstSaleFundsArray[_index].amount,firstSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  function secSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (secondSaleFundsArray[_index].spender,secondSaleFundsArray[_index].amount,secondSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  \n', '  function transferRemainingTokens(address _to,uint256 _tokens) public onlyOwner {\n', '      require(!presaleOpen && !firstsaleOpen && !secondsaleOpen);\n', '      uint myBalance = token.balanceOf(this); \n', '      require(myBalance >= _tokens);\n', '      token.transfer(_to,_tokens);\n', '  }\n', '  \n', '  function updateHardCap(uint256 _hardCap)public onlyOwner {\n', '      hardCap = _hardCap * 10**uint(18);\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "ONLY OWNER IS ALLOWED");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract IBelottoToken{\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function burn(uint256 _value) public;\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '}\n', '\n', '/**\n', ' * @title BelottoCrowdsale\n', ' * @dev BelottoCrowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract BelottoCrowdsale is Owned {\n', '  using SafeMath for uint256; \n', '  uint256 public presaleopeningTime;\n', '  uint256 public presaleclosingTime;\n', '  uint256 public saleopeningTime;\n', '  uint256 public saleclosingTime;\n', '  uint256 public secondsaleopeningTime;\n', '  uint256 public secondsaleclosingTime;\n', '  address public reserverWallet;    // Address where reserve tokens will be sent\n', '  address public bountyWallet;      // Address where bounty tokens will be sent\n', "  address public teamsWallet;       // Address where team's tokens will be sent\n", '  address public fundsWallet;       // Address where funds are collected\n', '  uint256 public fundsRaised;         // Amount of total fundsRaised\n', '  uint256 public preSaleTokens;\n', '  uint256 public saleTokens;\n', '  uint256 public teamAdvTokens;\n', '  uint256 public reserveTokens;\n', '  uint256 public bountyTokens;\n', '  uint256 public hardCap;\n', '  uint256 public minTxSize;\n', '  uint256 public maxTxSize;\n', '  bool    public presaleOpen;\n', '  bool    public firstsaleOpen;\n', '  bool    public secondsaleOpen;\n', '  mapping(address => uint) preSaleFunds;\n', '  mapping(address => uint) firstSaleFunds;\n', '  mapping(address => uint) secondSaleFunds;\n', '  struct Funds {\n', '    address spender;\n', '    uint256 amount;\n', '    uint256 time;\n', '    }\n', '    Funds[]  preSaleFundsArray;\n', '    Funds[]  firstSaleFundsArray;\n', '    Funds[]  secondSaleFundsArray;\n', '  \n', '  IBelottoToken public token;\n', '  \n', '  event Burn(address indexed burner, uint256 value);\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  /** @dev Reverts if not in crowdsale time range. */\n', '  modifier onlyWhilePreSaleOpen {\n', '    require(now >= presaleopeningTime && now <= presaleclosingTime, "Pre Sale Close");\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhileFirstSaleOpen {\n', '    require(now >= saleopeningTime && now <= saleclosingTime, "First Sale Close");\n', '    _;\n', '  }\n', '  \n', '  modifier onlyWhileSecondSaleOpen {\n', '    require(now >= secondsaleopeningTime && now <= secondsaleclosingTime, "Second Sale Close");\n', '    _;\n', '  }\n', '  \n', '  function totalRemainingTokens() public view returns(uint256 remainingTokens){\n', '    return token.balanceOf(this);      \n', '  }\n', '  \n', '  function BelottoCrowdsale(uint256 _preST, uint256 _saleT, uint256 _teamAdvT, uint256 _reserveT, uint256 _bountyT, address _reserverWallet, \n', '                            address _bountyWallet, address _teamsWallet, address _fundsWallet, address _tokenContractAdd, address _owner) \n', '                            public {\n', '    \n', '    \n', '    _setWallets(_reserverWallet,_bountyWallet,_teamsWallet,_fundsWallet);\n', '    _setMoreDetails(_preST,_saleT,_teamAdvT,_reserveT,_bountyT,_owner);\n', '    _setTimes();\n', '    \n', '    // takes an address of the existing token contract as parameter\n', '    token = IBelottoToken(_tokenContractAdd);\n', '  }\n', '  \n', '  function _setTimes() internal{\n', '    presaleopeningTime    = 1524873600; // 28th April 2018 00:00:00 GMT \n', '    presaleclosingTime    = 1527379199; // 26th May 2018 23:59:59 GMT   \n', '    saleopeningTime       = 1527724800; // 31st May 2018 00:00:00 GMT \n', '    saleclosingTime       = 1532908799; // 29th July 2018 23:59:59 GMT\n', '    secondsaleopeningTime = 1532908800; // 30th July 2018 00:00:00 GMT\n', '    secondsaleclosingTime = 1535673599; // 30th August 2018 23:59:59 GMT\n', '  }\n', '  \n', '  function _setWallets(address _reserverWallet, address _bountyWallet, address _teamsWallet, address _fundsWallet) internal{\n', '    reserverWallet        = _reserverWallet;\n', '    bountyWallet          = _bountyWallet;\n', '    teamsWallet           = _teamsWallet;\n', '    fundsWallet           = _fundsWallet;\n', '  }\n', '  \n', '  function _setMoreDetails(uint256 _preST, uint256 _saleT, uint256 _teamAdvT, uint256 _reserveT, uint256 _bountyT, address _owner) internal{\n', '    preSaleTokens         = _preST * 10**uint(18);\n', '    saleTokens            = _saleT * 10**uint(18);\n', '    teamAdvTokens         = _teamAdvT * 10**uint(18);\n', '    reserveTokens         = _reserveT * 10**uint(18);\n', '    bountyTokens          = _bountyT * 10**uint(18);\n', "    hardCap               = 16000 * 10**(uint(18));   //in start only, it'll be set by Owner\n", "    minTxSize             = 100000000000000000; // in wei's. (0,1 ETH)\n", "    maxTxSize             = 200000000000000000000; // in wei's. (200 ETH)\n", '    owner = _owner;\n', '  }\n', '  \n', '  function TokenAllocate(address _wallet,uint256 _amount) internal returns (bool success) {\n', '      uint256 tokenAmount = _amount;\n', '      token.transfer(_wallet,tokenAmount);\n', '      return true;\n', '  }\n', '  \n', '  function startSecondSale() public onlyOwner{\n', '      presaleOpen = false;\n', '      firstsaleOpen  = false;\n', '      secondsaleOpen = true;\n', '  }\n', '  \n', '  \n', '  function stopSecondSale() public onlyOwner{\n', '      presaleOpen = false;\n', '      firstsaleOpen = false;\n', '      secondsaleOpen = false;\n', '      if(teamAdvTokens >= 0 && bountyTokens >=0){\n', '          TokenAllocate(teamsWallet,teamAdvTokens);\n', '          teamAdvTokens = 0;\n', '          TokenAllocate(bountyWallet,bountyTokens);\n', '          bountyTokens = 0;\n', '      }\n', '  }\n', '\n', '  function _checkOpenings(uint256 _weiAmount) internal{\n', '      if((fundsRaised + _weiAmount >= hardCap)){\n', '            presaleOpen = false;\n', '            firstsaleOpen  = false;\n', '            secondsaleOpen = true;\n', '      }\n', '      else if(secondsaleOpen){\n', '          presaleOpen = false;\n', '          firstsaleOpen  = false;\n', '          secondsaleOpen = true;\n', '      }\n', '      else if(now >= presaleopeningTime && now <= presaleclosingTime){\n', '          presaleOpen = true;\n', '          firstsaleOpen = false;\n', '          secondsaleOpen = false;\n', '          if(reserveTokens >= 0){\n', '            if(TokenAllocate(reserverWallet,reserveTokens)){\n', '                reserveTokens = 0;\n', '            }\n', '          }\n', '      }\n', '      else if(now >= saleopeningTime && now <= saleclosingTime){\n', '          presaleOpen = false;\n', '          firstsaleOpen = true;\n', '          secondsaleOpen = false;\n', '      }\n', '      else if(now >= secondsaleopeningTime && now <= secondsaleclosingTime){\n', '            presaleOpen = false;\n', '            firstsaleOpen  = false;\n', '            secondsaleOpen = true;\n', '      }\n', '      else{\n', '          presaleOpen = false;\n', '          firstsaleOpen = false;\n', '          secondsaleOpen = false;\n', '          if(teamAdvTokens >= 0 && bountyTokens >=0){\n', '            TokenAllocate(teamsWallet,teamAdvTokens);\n', '            teamAdvTokens = 0;\n', '            TokenAllocate(bountyWallet,bountyTokens);\n', '            bountyTokens = 0;\n', '          }\n', '      }\n', '  }\n', '  \n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {\n', '    \n', '    uint256 ethers = msg.value;\n', '    \n', '    _preValidatePurchase(_beneficiary, ethers);\n', '    \n', '    _checkOpenings(ethers);\n', '    \n', '    _setFunds(_beneficiary,ethers);\n', '    \n', "    // update state of wei's raised during complete ICO\n", '    fundsRaised = fundsRaised.add(ethers);\n', '    //sjfhj\n', '    _forwardFunds(_beneficiary); \n', '  }\n', '  \n', '  function _setFunds(address _beneficiary, uint256 _ethers) internal{\n', '      if(presaleOpen){\n', '          preSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '      else if(firstsaleOpen){\n', '          firstSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '      else if(secondsaleOpen){\n', '          secondSaleFundsArray.push(Funds(_beneficiary,_ethers, now));\n', '      }\n', '  }\n', '  \n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal{\n', '   require(_beneficiary != address(0), "WRONG Address");\n', '   require(_weiAmount != 0, "Insufficient funds");\n', '   require(_weiAmount >= minTxSize  && _weiAmount <= maxTxSize ,"FUNDS should be MIN 0,1 ETH and Max 200 ETH");\n', '  }\n', '  \n', '  function TotalSpenders() public view returns (uint256 preSaleSpenders,uint256 firstSaleSpenders,uint256 secondSaleSpenders){\n', '      return ((preSaleFundsArray.length),(firstSaleFundsArray.length),(secondSaleFundsArray.length));\n', '  }\n', '  \n', '  function _forwardFunds(address _beneficiary) internal {\n', '    fundsWallet.transfer(msg.value);\n', '  }\n', '  \n', '  function preSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      _checkOpenings(0);\n', '      require(!presaleOpen, "Pre-Sale is NOT CLOSE ");\n', '      require(preSaleTokens >= _tokenAmount,"NO Pre-SALE Tokens Available");\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      preSaleTokens = preSaleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  function firstSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      require(!presaleOpen && !firstsaleOpen, "First Sale is NOT CLOSE");\n', '      if(saleTokens <= _tokenAmount && preSaleTokens >= _tokenAmount){\n', '          saleTokens = saleTokens.add(_tokenAmount);\n', '          preSaleTokens = preSaleTokens.sub(_tokenAmount);\n', '      }\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      saleTokens = saleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  function secondSaleDelivery(address _beneficiary, uint256 _tokenAmount) public onlyOwner{\n', '      require(!presaleOpen && !firstsaleOpen && !secondsaleOpen, "Second Sale is NOT CLOSE");\n', '      require(saleTokens >= _tokenAmount,"NO Sale Tokens Available");\n', '      token.transfer(_beneficiary,_tokenAmount);\n', '      saleTokens = saleTokens.sub(_tokenAmount);\n', '  }\n', '  \n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burnTokens(uint256 _value) public onlyOwner {\n', '      token.burn(_value);\n', '  }\n', ' \n', '  function preSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (preSaleFundsArray[_index].spender,preSaleFundsArray[_index].amount,preSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  function firstSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (firstSaleFundsArray[_index].spender,firstSaleFundsArray[_index].amount,firstSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  function secSaleSpenderTxDetails(uint _index) public view returns(address spender, uint256 amount, uint256 time){\n', '      return (secondSaleFundsArray[_index].spender,secondSaleFundsArray[_index].amount,secondSaleFundsArray[_index].time);\n', '  }\n', '  \n', '  \n', '  function transferRemainingTokens(address _to,uint256 _tokens) public onlyOwner {\n', '      require(!presaleOpen && !firstsaleOpen && !secondsaleOpen);\n', '      uint myBalance = token.balanceOf(this); \n', '      require(myBalance >= _tokens);\n', '      token.transfer(_to,_tokens);\n', '  }\n', '  \n', '  function updateHardCap(uint256 _hardCap)public onlyOwner {\n', '      hardCap = _hardCap * 10**uint(18);\n', '  }\n', '}']
