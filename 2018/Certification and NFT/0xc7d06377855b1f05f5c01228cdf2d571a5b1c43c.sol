['/*\n', 'Capital Technologies & Research - Bounty Distribution Smart Contract\n', 'https://www.mycapitalco.in\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract CapitalBountyDelivery is Ownable {\n', 'using SafeMath for uint256;\n', '    ERC20 public token_call;\n', '    ERC20 public token_callg;\n', '\tmapping (address => bool) public distributedFirst;\n', '\tmapping (address => bool) public distributedSecond;\n', '\tuint public sentFirst;\n', '\tuint public sentSecond;\n', '    event DistributeFirst(address indexed userWallet, uint token_call, uint token_callg);\n', '\tevent DistributeSecond(address indexed userWallet, uint token_call, uint token_callg);\n', '\tevent AdminWithdrawn(address indexed adminWallet, uint token_call, uint token_callg);\n', '    constructor (ERC20 _token_call, ERC20 _token_callg) public {\n', '        require(_token_call != address(0));\n', '        require(_token_callg != address(0));\n', '        token_call = _token_call;\n', '        token_callg = _token_callg;\n', '    }\n', '    function () public payable {\n', '    }\n', '    function sendFirst(address userWallet, uint call) public onlyOwner {\n', '\t\trequire(now >= 1531958400);\n', '\t\trequire(userWallet != address(0));\n', '\t\trequire(!distributedFirst[userWallet]);\n', '        uint _call = call * 10 ** 18;\n', '\t\tuint _callg = _call.mul(200);\n', '\t\tdistributedFirst[userWallet] = true;\n', '        require(token_call.transfer(userWallet, _call));\n', '        require(token_callg.transfer(userWallet, _callg));\n', '\t\tsentFirst = sentFirst.add(_call);\n', '        emit DistributeFirst(userWallet, _call, _callg);\n', '    }\n', '\tfunction sendSecond(address userWallet, uint call) public onlyOwner {\n', '\t\trequire(now >= 1538179200);\n', '\t\trequire(userWallet != address(0));\n', '\t\trequire(!distributedSecond[userWallet]);\n', '        uint _call = call * 10 ** 18;\n', '\t\tuint _callg = _call.mul(200);\n', '\t\tdistributedSecond[userWallet] = true;\n', '        require(token_call.transfer(userWallet, _call));\n', '        require(token_callg.transfer(userWallet, _callg));\n', '\t\tsentSecond = sentSecond.add(_call);\n', '        emit DistributeSecond(userWallet, _call, _callg);\n', '    }\n', '\tfunction sendFirstBatch(address[] _userWallet, uint[] call) public onlyOwner {\n', '\t\trequire(now >= 1531958400);\n', '\t\tfor(uint256 i = 0; i < _userWallet.length; i++) {\n', '\t\t\tif (!distributedFirst[_userWallet[i]]) {\n', '\t\t\t\tuint _call = call[i] * 10 ** 18;\n', '\t\t\t\tuint _callg = _call.mul(200);\n', '\t\t\t\tdistributedFirst[_userWallet[i]] = true;\n', '\t\t\t\trequire(token_call.transfer(_userWallet[i], _call));\n', '\t\t\t\trequire(token_callg.transfer(_userWallet[i], _callg));\n', '\t\t\t\tsentFirst = sentFirst.add(_call);\n', '\t\t\t\temit DistributeFirst(_userWallet[i], _call, _callg);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\tfunction sendSecondBatch(address[] _userWallet, uint[] call) public onlyOwner {\n', '\t\trequire(now >= 1538179200); \n', '\t\tfor(uint256 i = 0; i < _userWallet.length; i++) {\n', '\t\t\tif (!distributedSecond[_userWallet[i]]) {\n', '\t\t\t\tuint _call = call[i] * 10 ** 18;\n', '\t\t\t\tuint _callg = _call.mul(200);\n', '\t\t\t\tdistributedSecond[_userWallet[i]] = true;\n', '\t\t\t\trequire(token_call.transfer(_userWallet[i], _call));\n', '\t\t\t\trequire(token_callg.transfer(_userWallet[i], _callg));\n', '\t\t\t\tsentSecond = sentSecond.add(_call);\n', '\t\t\t\temit DistributeSecond(_userWallet[i], _call, _callg);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\tfunction withdrawTokens(address adminWallet) public onlyOwner {\n', '        require(adminWallet != address(0));\n', '        uint call_balance = token_call.balanceOf(this);\n', '        uint callg_balance = token_callg.balanceOf(this);\n', '        token_call.transfer(adminWallet, call_balance);\n', '        token_callg.transfer(adminWallet, callg_balance);\n', '        emit AdminWithdrawn(adminWallet, call_balance, callg_balance);\n', '    }\n', '}']
['/*\n', 'Capital Technologies & Research - Bounty Distribution Smart Contract\n', 'https://www.mycapitalco.in\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract CapitalBountyDelivery is Ownable {\n', 'using SafeMath for uint256;\n', '    ERC20 public token_call;\n', '    ERC20 public token_callg;\n', '\tmapping (address => bool) public distributedFirst;\n', '\tmapping (address => bool) public distributedSecond;\n', '\tuint public sentFirst;\n', '\tuint public sentSecond;\n', '    event DistributeFirst(address indexed userWallet, uint token_call, uint token_callg);\n', '\tevent DistributeSecond(address indexed userWallet, uint token_call, uint token_callg);\n', '\tevent AdminWithdrawn(address indexed adminWallet, uint token_call, uint token_callg);\n', '    constructor (ERC20 _token_call, ERC20 _token_callg) public {\n', '        require(_token_call != address(0));\n', '        require(_token_callg != address(0));\n', '        token_call = _token_call;\n', '        token_callg = _token_callg;\n', '    }\n', '    function () public payable {\n', '    }\n', '    function sendFirst(address userWallet, uint call) public onlyOwner {\n', '\t\trequire(now >= 1531958400);\n', '\t\trequire(userWallet != address(0));\n', '\t\trequire(!distributedFirst[userWallet]);\n', '        uint _call = call * 10 ** 18;\n', '\t\tuint _callg = _call.mul(200);\n', '\t\tdistributedFirst[userWallet] = true;\n', '        require(token_call.transfer(userWallet, _call));\n', '        require(token_callg.transfer(userWallet, _callg));\n', '\t\tsentFirst = sentFirst.add(_call);\n', '        emit DistributeFirst(userWallet, _call, _callg);\n', '    }\n', '\tfunction sendSecond(address userWallet, uint call) public onlyOwner {\n', '\t\trequire(now >= 1538179200);\n', '\t\trequire(userWallet != address(0));\n', '\t\trequire(!distributedSecond[userWallet]);\n', '        uint _call = call * 10 ** 18;\n', '\t\tuint _callg = _call.mul(200);\n', '\t\tdistributedSecond[userWallet] = true;\n', '        require(token_call.transfer(userWallet, _call));\n', '        require(token_callg.transfer(userWallet, _callg));\n', '\t\tsentSecond = sentSecond.add(_call);\n', '        emit DistributeSecond(userWallet, _call, _callg);\n', '    }\n', '\tfunction sendFirstBatch(address[] _userWallet, uint[] call) public onlyOwner {\n', '\t\trequire(now >= 1531958400);\n', '\t\tfor(uint256 i = 0; i < _userWallet.length; i++) {\n', '\t\t\tif (!distributedFirst[_userWallet[i]]) {\n', '\t\t\t\tuint _call = call[i] * 10 ** 18;\n', '\t\t\t\tuint _callg = _call.mul(200);\n', '\t\t\t\tdistributedFirst[_userWallet[i]] = true;\n', '\t\t\t\trequire(token_call.transfer(_userWallet[i], _call));\n', '\t\t\t\trequire(token_callg.transfer(_userWallet[i], _callg));\n', '\t\t\t\tsentFirst = sentFirst.add(_call);\n', '\t\t\t\temit DistributeFirst(_userWallet[i], _call, _callg);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\tfunction sendSecondBatch(address[] _userWallet, uint[] call) public onlyOwner {\n', '\t\trequire(now >= 1538179200); \n', '\t\tfor(uint256 i = 0; i < _userWallet.length; i++) {\n', '\t\t\tif (!distributedSecond[_userWallet[i]]) {\n', '\t\t\t\tuint _call = call[i] * 10 ** 18;\n', '\t\t\t\tuint _callg = _call.mul(200);\n', '\t\t\t\tdistributedSecond[_userWallet[i]] = true;\n', '\t\t\t\trequire(token_call.transfer(_userWallet[i], _call));\n', '\t\t\t\trequire(token_callg.transfer(_userWallet[i], _callg));\n', '\t\t\t\tsentSecond = sentSecond.add(_call);\n', '\t\t\t\temit DistributeSecond(_userWallet[i], _call, _callg);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\tfunction withdrawTokens(address adminWallet) public onlyOwner {\n', '        require(adminWallet != address(0));\n', '        uint call_balance = token_call.balanceOf(this);\n', '        uint callg_balance = token_callg.balanceOf(this);\n', '        token_call.transfer(adminWallet, call_balance);\n', '        token_callg.transfer(adminWallet, callg_balance);\n', '        emit AdminWithdrawn(adminWallet, call_balance, callg_balance);\n', '    }\n', '}']
