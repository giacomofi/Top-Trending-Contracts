['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library SafeMath_Time {\n', '    function addTime(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '  \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) external;\n', '    function freezeAccount(address target, bool freeze, uint startTime, uint endTime) external; \n', '}\n', '\n', 'interface marketPrice {\n', '    function getUSDEth() external returns(uint256);\n', '}\n', '\n', 'contract BaseCrowdsale{\n', '    using SafeMath for uint256;\n', '    using SafeMath_Time for uint;\n', '\n', '    token public ctrtToken;\n', '    address public wallet;\n', '    uint256 public weiRaised;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);    \n', '\n', '    function init(address _wallet, address _token) internal {\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '\n', '        wallet = _wallet;\n', '        ctrtToken = token(_token);\n', '    }        \n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = weiAmount;\n', '        tokens = _getTokenAmount(weiAmount);\n', '\n', '        _preValidatePurchase(_beneficiary, weiAmount, tokens);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '\n', '        _processPurchase(_beneficiary, weiAmount, tokens);\n', '\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '        _updatePurchasingState(_beneficiary, weiAmount, tokens);\n', '\n', '        _forwardFunds();\n', '        _postValidatePurchase(_beneficiary, weiAmount, tokens);\n', '    }\n', '\n', '    function _getTokenAmount(uint256 _tokenAmount) internal view returns (uint256) {\n', '        uint256 Amount = _tokenAmount;\n', '        return Amount;\n', '    }\n', '\n', '    function _updatePurchasingState(address _beneficiary, uint _weiAmount, uint256 _tokenAmount) internal {}\n', '    \n', '    function _preValidatePurchase(address _beneficiary, uint _weiAmount, uint256 _tokenAmount)  internal {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount != 0);\n', '    }\n', '\n', '    function _postValidatePurchase(address _beneficiary, uint _weiAmount, uint256 _tokenAmount) internal {        \n', '    }\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        ctrtToken.transfer(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    function _processPurchase(address _beneficiary, uint _weiAmount, uint256 _tokenAmount) internal {\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', 'contract AdvanceCrowdsale is BaseCrowdsale, Ownable{\n', '    using SafeMath for uint256;\n', '    uint constant MAX_FUND_SIZE = 20;\n', '\n', '    uint256[MAX_FUND_SIZE] public fundingGoalInToken;\n', '    uint256[MAX_FUND_SIZE] public amountRaisedInToken;\n', '    uint[MAX_FUND_SIZE] public rate;\n', '    uint[MAX_FUND_SIZE] public openingTimeArray;\n', '    uint[MAX_FUND_SIZE] public closingTimeArray;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    uint256 public price;              //USD cent per token\n', '    uint public tokenPerEth;\n', '    uint public minFundInEther = 0;    \n', '    uint public usdPerEth = 0;          //USD cent    \n', '    marketPrice public ctrtMarketPrice;\n', '\n', '    bool[MAX_FUND_SIZE] public isLockUpSale;\n', '    uint[MAX_FUND_SIZE] public lockDurationTime;\n', '\n', '    event Refunding(uint pos, uint256 FundingGoalInToken, uint _rate, uint _openingTime, uint _closingTime,\n', '    bool _isLockUpSale, uint _lockDurationTime);\n', '    event TokenPrice(uint usdPerEth, uint tokenPerEth);\n', '\n', '    function init(\n', '        address _wallet,\n', '        address _token,\n', '        address _marketPriceContract,\n', '        uint _usdPerEth,\n', '        uint _price\n', '    ) public         \n', '    {\n', '        super.init(_wallet, _token);\n', '        price = _price;\n', '        minFundInEther = 1;\n', '        ctrtMarketPrice = marketPrice(_marketPriceContract);\n', '        setUSDPerETH(_usdPerEth);\n', '    }\n', '    \n', '    function setFunding(\n', '        uint pos, uint256 _fundingGoalInToken, uint _rate, uint _openingTime, \n', '        uint _closingTime, bool _isLockUpSale, uint _lockDurationTime)\n', '    public onlyOwner\n', '    {\n', '        require(pos < MAX_FUND_SIZE);\n', '        openingTimeArray[pos] = _openingTime;\n', '        closingTimeArray[pos] = _closingTime;\n', '        rate[pos] = _rate;\n', '        fundingGoalInToken[pos] = _fundingGoalInToken.mul(1 ether);\n', '        amountRaisedInToken[pos] = 0;\n', '\n', '        isLockUpSale[pos] = _isLockUpSale;\n', '        lockDurationTime[pos] = _lockDurationTime.mul(1 minutes);\n', '        \n', '        emit Refunding(pos, _fundingGoalInToken, _rate, _openingTime, _closingTime, _isLockUpSale, _lockDurationTime);\n', '    }\n', '\n', '    function hasClosed() public view returns (bool) {\n', '        for(uint i = 0; i < MAX_FUND_SIZE; ++i)\n', '        {\n', '            if(openingTimeArray[i] <= now && now <= closingTimeArray[i])\n', '            {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function fundPos() public view returns (uint) {\n', '        for(uint i = 0; i < MAX_FUND_SIZE; ++i)\n', '        {\n', '            if(openingTimeArray[i] <= now && now <= closingTimeArray[i])\n', '            {\n', '                return i;\n', '            }\n', '        }\n', '\n', '        require(false);\n', '    }\n', '\n', '    function setUSDPerETH(uint _usdPerEth) public onlyOwner{\n', '        require(_usdPerEth != 0);\n', '        usdPerEth = _usdPerEth;\n', '        tokenPerEth = usdPerEth.div(price).mul(1 ether);\n', '\n', '        TokenPrice(usdPerEth, tokenPerEth);\n', '    }\n', '\n', '    function SetUSDPerETH_byContract(uint _usdPerEth) internal {\n', '        require(_usdPerEth != 0);\n', '        usdPerEth = _usdPerEth;\n', '        tokenPerEth = usdPerEth.div(price).mul(1 ether);\n', '\n', '        TokenPrice(usdPerEth, tokenPerEth);\n', '    }\n', '\n', '    function setMarket(address _marketPrice) public onlyOwner{\n', '        ctrtMarketPrice = marketPrice(_marketPrice);\n', '    }\n', '\n', '    function newLockUpAddress(address newAddress) public {\n', '        uint pos = fundPos();\n', '\n', '        ctrtToken.freezeAccount(newAddress, true, block.timestamp, closingTimeArray[pos].addTime(lockDurationTime[pos]));\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint _weiAmount, uint256 _tokenAmount)  internal {\n', '        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);       \n', '        \n', '        require(hasClosed() == false);\n', '        uint pos = fundPos();\n', '\n', '        require(fundingGoalInToken[pos] >= amountRaisedInToken[pos].add(_tokenAmount));        \n', '        require(minFundInEther <= msg.value);        \n', '    }\n', '     \n', '    function _getTokenAmount(uint256 _tokenAmount) internal view returns (uint256) {\n', '        if(ctrtMarketPrice != address(0))\n', '        {           \n', '            uint256 usd = ctrtMarketPrice.getUSDEth();\n', '    \n', '            if(usd != usdPerEth) {\n', '                SetUSDPerETH_byContract(usd);\n', '            }\n', '        }\n', '        require(usdPerEth != 0);\n', '\n', '        uint256 Amount = _tokenAmount.mul(tokenPerEth).div(1 ether);\n', '        \n', '        require(hasClosed() == false);\n', '        uint pos = fundPos();\n', '\n', '        Amount = Amount.mul(rate[pos].add(100)).div(100);\n', '        return Amount;\n', '    }\n', '\n', '    function _updatePurchasingState(address _beneficiary, uint _weiAmount, uint256 _tokenAmount) internal {        \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);\n', '        require(hasClosed() == false);\n', '        uint pos = fundPos();\n', '        amountRaisedInToken[pos] = amountRaisedInToken[pos].add(_tokenAmount);\n', '    }\n', '\n', '    function _postValidatePurchase(address _beneficiary, uint _weiAmount, uint256 _tokenAmount) internal {\n', '        uint pos = fundPos();\n', '        if(true == isLockUpSale[pos])\n', '            newLockUpAddress(msg.sender);\n', '    }\n', '}']