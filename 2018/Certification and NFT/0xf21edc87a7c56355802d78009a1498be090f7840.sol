['pragma solidity 0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        require(owner == msg.sender);\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title AllstocksCrowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override \n', ' * the methods to add functionality. Consider using &#39;super&#39; where appropiate to concatenate\n', ' * behavior.\n', ' */\n', '\n', 'contract AllstocksCrowdsale is Owned {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  //ERC20Interface public token;\n', '  address public token;\n', '\n', '  // Address where funds are collected\n', '  address public ethFundDeposit; \n', '\n', '  // How many token units a buyer gets per wei // starts with 625 Allstocks tokens per 1 ETH\n', '  uint256 public tokenExchangeRate = 625;                         \n', '  \n', '  // 25m hard cap\n', '  uint256 public tokenCreationCap =  25 * (10**6) * 10**18; // 25m maximum; \n', '\n', '  //2.5m softcap\n', '  uint256 public tokenCreationMin =  25 * (10**5) * 10**18; // 2.5m minimum\n', '\n', '  // Amount of wei raised\n', '  uint256 public _raised = 0;\n', '  \n', '  // switched to true in after setup\n', '  bool public isActive = false;                 \n', ' \n', '  //start time \n', '  uint256 public fundingStartTime = 0;\n', '   \n', '  //end time\n', '  uint256 public fundingEndTime = 0;\n', '\n', '  // switched to true in operational state\n', '  bool public isFinalized = false; \n', '  \n', '  //refund list - will hold a list of all contributers \n', '  mapping(address => uint256) public refunds;\n', '\n', '  /**\n', '   * Event for token Allocate logging\n', '   * @param allocator for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenAllocated(address indexed allocator, address indexed beneficiary, uint256 amount);\n', '\n', '  event LogRefund(address indexed _to, uint256 _value);\n', '\n', '  constructor() public {\n', '      tokenExchangeRate = 625;\n', '  }\n', '\n', '  function setup (uint256 _fundingStartTime, uint256 _fundingEndTime, address _token) onlyOwner external {\n', '    require (isActive == false); \n', '    require (isFinalized == false); \t\t\t        \t   \n', '    require (msg.sender == owner);                // locks finalize to the ultimate ETH owner\n', '    require(_fundingStartTime > 0);\n', '    require(_fundingEndTime > 0 && _fundingEndTime > _fundingStartTime);\n', '    require(_token != address(0));\n', '\n', '    isFinalized = false;                          // controls pre through crowdsale state\n', '    isActive = true;                              // set sale status to be true\n', '    ethFundDeposit = owner;                       // set ETH wallet owner \n', '    fundingStartTime = _fundingStartTime;\n', '    fundingEndTime = _fundingEndTime;\n', '    //set token\n', '    token = _token;\n', '  }\n', '\n', '  /// @dev send funding to safe wallet if minimum is reached \n', '  function vaultFunds() public onlyOwner {\n', '    require(msg.sender == owner);                    // Allstocks double chack\n', '    require(_raised >= tokenCreationMin);            // have to sell minimum to move to operational \n', '    ethFundDeposit.transfer(address(this).balance);  // send the eth to Allstocks\n', '  }  \n', '\n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    buyTokens(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase ***DO NOT OVERRIDE***\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary, uint256 _value) internal {\n', '    _preValidatePurchase(_beneficiary, _value);\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(_value);\n', '    // update state\n', '    uint256 checkedSupply = _raised.add(tokens);\n', '    //check that we are not over cap\n', '    require(checkedSupply <= tokenCreationCap);\n', '    _raised = checkedSupply;\n', '    bool mined = ERC20Interface(token).mint(_beneficiary, tokens);\n', '    require(mined);\n', '    //add sent eth to refunds list\n', '    refunds[_beneficiary] = _value.add(refunds[_beneficiary]);  // safeAdd \n', '    emit TokenAllocated(this, _beneficiary, tokens); // log it\n', '    //forward funds to deposite only in minimum was reached\n', '    if(_raised >= tokenCreationMin) {\n', '      _forwardFunds();\n', '    }\n', '  }\n', '\n', '  // @dev method for manageing bonus phases \n', '\tfunction setRate(uint256 _value) external onlyOwner {\n', '    require (isActive == true);\n', '    require(msg.sender == owner); // Allstocks double check owner   \n', '    // Range is set between 500 to 625, based on the bonus program stated in whitepaper.\n', '    // Upper range is set to 1500 (x3 times margin based on ETH price) .\n', '    require (_value >= 500 && _value <= 1500); \n', '    tokenExchangeRate = _value;\n', '  }\n', '\n', '  // @dev method for allocate tokens to beneficiary account \n', '  function allocate(address _beneficiary, uint256 _value) public onlyOwner returns (bool success) {\n', '    require (isActive == true);          // sale have to be active\n', '    require (_value > 0);                // value must be greater then 0 \n', '    require (msg.sender == owner);       // Allstocks double chack \n', '    require(_beneficiary != address(0)); // none empty address\n', '    uint256 checkedSupply = _raised.add(_value); \n', '    require(checkedSupply <= tokenCreationCap); //check that we dont over cap\n', '    _raised = checkedSupply;\n', '    bool sent = ERC20Interface(token).mint(_beneficiary, _value); // mint using ERC20 interface\n', '    require(sent); \n', '    emit TokenAllocated(this, _beneficiary, _value); // log it\n', '    return true;\n', '  }\n', '\n', '  //claim back token ownership \n', '  function transferTokenOwnership(address _newTokenOwner) public onlyOwner {\n', '    require(_newTokenOwner != address(0));\n', '    require(owner == msg.sender);\n', '    Owned(token).transferOwnership(_newTokenOwner);\n', '  }\n', '\n', '  /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n', '  function refund() external {\n', '    require (isFinalized == false);  // prevents refund if operational\n', '    require (isActive == true);      // only if sale is active\n', '    require (now > fundingEndTime);  // prevents refund until sale period is over\n', '    require(_raised < tokenCreationMin);  // no refunds if we sold enough\n', '    require(msg.sender != owner);         // Allstocks not entitled to a refund\n', '    //get contribution amount in eth\n', '    uint256 ethValRefund = refunds[msg.sender];\n', '    //refund should be greater then zero\n', '    require(ethValRefund > 0);\n', '    //zero sender refund balance\n', '    refunds[msg.sender] = 0;\n', '    //check user balance\n', '    uint256 allstocksVal = ERC20Interface(token).balanceOf(msg.sender);\n', '    //substruct from total raised - please notice main assumption is that tokens are not tradeble at this stage.\n', '    _raised = _raised.sub(allstocksVal);               // extra safe\n', '    //send eth back to user\n', '    msg.sender.transfer(ethValRefund);                 // if you&#39;re using a contract; make sure it works with .send gas limits\n', '    emit LogRefund(msg.sender, ethValRefund);          // log it\n', '  }\n', '\n', '   /// @dev Ends the funding period and sends the ETH home\n', '  function finalize() external onlyOwner {\n', '    require (isFinalized == false);\n', '    require(msg.sender == owner); // Allstocks double chack  \n', '    require(_raised >= tokenCreationMin);  // have to sell minimum to move to operational\n', '    require(_raised > 0);\n', '\n', '    if (now < fundingEndTime) {    //if try to close before end time, check that we reach max cap\n', '      require(_raised >= tokenCreationCap);\n', '    }\n', '    else \n', '      require(now >= fundingEndTime); //allow finilize only after time ends\n', '    \n', '    //transfer token ownership back to original owner\n', '    transferTokenOwnership(owner);\n', '    // move to operational\n', '    isFinalized = true;\n', '    vaultFunds();  // send the eth to Allstocks\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\n', '    require(now >= fundingStartTime);\n', '    require(now < fundingEndTime); \n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '    return _weiAmount.mul(tokenExchangeRate);\n', '  }\n', '\n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    ethFundDeposit.transfer(msg.value);\n', '  }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '    function approve(address spender, uint256 tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        require(owner == msg.sender);\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title AllstocksCrowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override \n', " * the methods to add functionality. Consider using 'super' where appropiate to concatenate\n", ' * behavior.\n', ' */\n', '\n', 'contract AllstocksCrowdsale is Owned {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  //ERC20Interface public token;\n', '  address public token;\n', '\n', '  // Address where funds are collected\n', '  address public ethFundDeposit; \n', '\n', '  // How many token units a buyer gets per wei // starts with 625 Allstocks tokens per 1 ETH\n', '  uint256 public tokenExchangeRate = 625;                         \n', '  \n', '  // 25m hard cap\n', '  uint256 public tokenCreationCap =  25 * (10**6) * 10**18; // 25m maximum; \n', '\n', '  //2.5m softcap\n', '  uint256 public tokenCreationMin =  25 * (10**5) * 10**18; // 2.5m minimum\n', '\n', '  // Amount of wei raised\n', '  uint256 public _raised = 0;\n', '  \n', '  // switched to true in after setup\n', '  bool public isActive = false;                 \n', ' \n', '  //start time \n', '  uint256 public fundingStartTime = 0;\n', '   \n', '  //end time\n', '  uint256 public fundingEndTime = 0;\n', '\n', '  // switched to true in operational state\n', '  bool public isFinalized = false; \n', '  \n', '  //refund list - will hold a list of all contributers \n', '  mapping(address => uint256) public refunds;\n', '\n', '  /**\n', '   * Event for token Allocate logging\n', '   * @param allocator for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenAllocated(address indexed allocator, address indexed beneficiary, uint256 amount);\n', '\n', '  event LogRefund(address indexed _to, uint256 _value);\n', '\n', '  constructor() public {\n', '      tokenExchangeRate = 625;\n', '  }\n', '\n', '  function setup (uint256 _fundingStartTime, uint256 _fundingEndTime, address _token) onlyOwner external {\n', '    require (isActive == false); \n', '    require (isFinalized == false); \t\t\t        \t   \n', '    require (msg.sender == owner);                // locks finalize to the ultimate ETH owner\n', '    require(_fundingStartTime > 0);\n', '    require(_fundingEndTime > 0 && _fundingEndTime > _fundingStartTime);\n', '    require(_token != address(0));\n', '\n', '    isFinalized = false;                          // controls pre through crowdsale state\n', '    isActive = true;                              // set sale status to be true\n', '    ethFundDeposit = owner;                       // set ETH wallet owner \n', '    fundingStartTime = _fundingStartTime;\n', '    fundingEndTime = _fundingEndTime;\n', '    //set token\n', '    token = _token;\n', '  }\n', '\n', '  /// @dev send funding to safe wallet if minimum is reached \n', '  function vaultFunds() public onlyOwner {\n', '    require(msg.sender == owner);                    // Allstocks double chack\n', '    require(_raised >= tokenCreationMin);            // have to sell minimum to move to operational \n', '    ethFundDeposit.transfer(address(this).balance);  // send the eth to Allstocks\n', '  }  \n', '\n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    buyTokens(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase ***DO NOT OVERRIDE***\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary, uint256 _value) internal {\n', '    _preValidatePurchase(_beneficiary, _value);\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(_value);\n', '    // update state\n', '    uint256 checkedSupply = _raised.add(tokens);\n', '    //check that we are not over cap\n', '    require(checkedSupply <= tokenCreationCap);\n', '    _raised = checkedSupply;\n', '    bool mined = ERC20Interface(token).mint(_beneficiary, tokens);\n', '    require(mined);\n', '    //add sent eth to refunds list\n', '    refunds[_beneficiary] = _value.add(refunds[_beneficiary]);  // safeAdd \n', '    emit TokenAllocated(this, _beneficiary, tokens); // log it\n', '    //forward funds to deposite only in minimum was reached\n', '    if(_raised >= tokenCreationMin) {\n', '      _forwardFunds();\n', '    }\n', '  }\n', '\n', '  // @dev method for manageing bonus phases \n', '\tfunction setRate(uint256 _value) external onlyOwner {\n', '    require (isActive == true);\n', '    require(msg.sender == owner); // Allstocks double check owner   \n', '    // Range is set between 500 to 625, based on the bonus program stated in whitepaper.\n', '    // Upper range is set to 1500 (x3 times margin based on ETH price) .\n', '    require (_value >= 500 && _value <= 1500); \n', '    tokenExchangeRate = _value;\n', '  }\n', '\n', '  // @dev method for allocate tokens to beneficiary account \n', '  function allocate(address _beneficiary, uint256 _value) public onlyOwner returns (bool success) {\n', '    require (isActive == true);          // sale have to be active\n', '    require (_value > 0);                // value must be greater then 0 \n', '    require (msg.sender == owner);       // Allstocks double chack \n', '    require(_beneficiary != address(0)); // none empty address\n', '    uint256 checkedSupply = _raised.add(_value); \n', '    require(checkedSupply <= tokenCreationCap); //check that we dont over cap\n', '    _raised = checkedSupply;\n', '    bool sent = ERC20Interface(token).mint(_beneficiary, _value); // mint using ERC20 interface\n', '    require(sent); \n', '    emit TokenAllocated(this, _beneficiary, _value); // log it\n', '    return true;\n', '  }\n', '\n', '  //claim back token ownership \n', '  function transferTokenOwnership(address _newTokenOwner) public onlyOwner {\n', '    require(_newTokenOwner != address(0));\n', '    require(owner == msg.sender);\n', '    Owned(token).transferOwnership(_newTokenOwner);\n', '  }\n', '\n', '  /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n', '  function refund() external {\n', '    require (isFinalized == false);  // prevents refund if operational\n', '    require (isActive == true);      // only if sale is active\n', '    require (now > fundingEndTime);  // prevents refund until sale period is over\n', '    require(_raised < tokenCreationMin);  // no refunds if we sold enough\n', '    require(msg.sender != owner);         // Allstocks not entitled to a refund\n', '    //get contribution amount in eth\n', '    uint256 ethValRefund = refunds[msg.sender];\n', '    //refund should be greater then zero\n', '    require(ethValRefund > 0);\n', '    //zero sender refund balance\n', '    refunds[msg.sender] = 0;\n', '    //check user balance\n', '    uint256 allstocksVal = ERC20Interface(token).balanceOf(msg.sender);\n', '    //substruct from total raised - please notice main assumption is that tokens are not tradeble at this stage.\n', '    _raised = _raised.sub(allstocksVal);               // extra safe\n', '    //send eth back to user\n', "    msg.sender.transfer(ethValRefund);                 // if you're using a contract; make sure it works with .send gas limits\n", '    emit LogRefund(msg.sender, ethValRefund);          // log it\n', '  }\n', '\n', '   /// @dev Ends the funding period and sends the ETH home\n', '  function finalize() external onlyOwner {\n', '    require (isFinalized == false);\n', '    require(msg.sender == owner); // Allstocks double chack  \n', '    require(_raised >= tokenCreationMin);  // have to sell minimum to move to operational\n', '    require(_raised > 0);\n', '\n', '    if (now < fundingEndTime) {    //if try to close before end time, check that we reach max cap\n', '      require(_raised >= tokenCreationCap);\n', '    }\n', '    else \n', '      require(now >= fundingEndTime); //allow finilize only after time ends\n', '    \n', '    //transfer token ownership back to original owner\n', '    transferTokenOwnership(owner);\n', '    // move to operational\n', '    isFinalized = true;\n', '    vaultFunds();  // send the eth to Allstocks\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\n', '    require(now >= fundingStartTime);\n', '    require(now < fundingEndTime); \n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '    return _weiAmount.mul(tokenExchangeRate);\n', '  }\n', '\n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    ethFundDeposit.transfer(msg.value);\n', '  }\n', '}']
