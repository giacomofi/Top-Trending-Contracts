['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/ERC20Interface.sol\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/PermissionGroups.sol\n', '\n', 'contract PermissionGroups {\n', '\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    mapping(address=>bool) internal operators;\n', '    mapping(address=>bool) internal alerters;\n', '    address[] internal operatorsGroup;\n', '    address[] internal alertersGroup;\n', '    uint constant internal MAX_GROUP_SIZE = 50;\n', '\n', '    constructor(address _admin) public {\n', '        admin = _admin;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAlerter() {\n', '        require(alerters[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function getOperators () external view returns(address[]) {\n', '        return operatorsGroup;\n', '    }\n', '\n', '    function getAlerters () external view returns(address[]) {\n', '        return alertersGroup;\n', '    }\n', '\n', '    event TransferAdminPending(address pendingAdmin);\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the pendingAdmin address.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdmin(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        emit TransferAdminPending(pendingAdmin);\n', '        pendingAdmin = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        emit TransferAdminPending(newAdmin);\n', '        emit AdminClaimed(newAdmin, admin);\n', '        admin = newAdmin;\n', '    }\n', '\n', '    event AdminClaimed( address newAdmin, address previousAdmin);\n', '\n', '    /**\n', '     * @dev Allows the pendingAdmin address to finalize the change admin process.\n', '     */\n', '    function claimAdmin() public {\n', '        require(pendingAdmin == msg.sender);\n', '        emit AdminClaimed(pendingAdmin, admin);\n', '        admin = pendingAdmin;\n', '        pendingAdmin = address(0);\n', '    }\n', '\n', '    event AlerterAdded (address newAlerter, bool isAdd);\n', '\n', '    function addAlerter(address newAlerter) public onlyAdmin {\n', '        require(!alerters[newAlerter]); // prevent duplicates.\n', '        require(alertersGroup.length < MAX_GROUP_SIZE);\n', '\n', '        emit AlerterAdded(newAlerter, true);\n', '        alerters[newAlerter] = true;\n', '        alertersGroup.push(newAlerter);\n', '    }\n', '\n', '    function removeAlerter (address alerter) public onlyAdmin {\n', '        require(alerters[alerter]);\n', '        alerters[alerter] = false;\n', '\n', '        for (uint i = 0; i < alertersGroup.length; ++i) {\n', '            if (alertersGroup[i] == alerter) {\n', '                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n', '                alertersGroup.length--;\n', '                emit AlerterAdded(alerter, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    event OperatorAdded(address newOperator, bool isAdd);\n', '\n', '    function addOperator(address newOperator) public onlyAdmin {\n', '        require(!operators[newOperator]); // prevent duplicates.\n', '        require(operatorsGroup.length < MAX_GROUP_SIZE);\n', '\n', '        emit OperatorAdded(newOperator, true);\n', '        operators[newOperator] = true;\n', '        operatorsGroup.push(newOperator);\n', '    }\n', '\n', '    function removeOperator (address operator) public onlyAdmin {\n', '        require(operators[operator]);\n', '        operators[operator] = false;\n', '\n', '        for (uint i = 0; i < operatorsGroup.length; ++i) {\n', '            if (operatorsGroup[i] == operator) {\n', '                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n', '                operatorsGroup.length -= 1;\n', '                emit OperatorAdded(operator, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Withdrawable.sol\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens or ethers can inherit this contract.\n', ' * @author Ilan Doron\n', ' * @dev Allows to recover any tokens or Ethers received in a contract.\n', ' * Should prevent any accidental loss of tokens.\n', ' */\n', 'contract Withdrawable is PermissionGroups {\n', '\n', '    constructor(address _admin) PermissionGroups (_admin) public {}\n', '\n', '    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw all ERC20 compatible tokens\n', '     * @param token ERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n', '        require(token.transfer(sendTo, amount));\n', '        emit TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    event EtherWithdraw(uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n', '        sendTo.transfer(amount);\n', '        emit EtherWithdraw(amount, sendTo);\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/IEORate.sol\n', '\n', 'contract IEORate is Withdrawable {\n', '\n', '    uint public ethToTokenNumerator;\n', '    uint public ethToTokenDenominator;\n', '\n', '    constructor(address admin) Withdrawable(admin) public\n', '    {}\n', '\n', '    event RateSet (uint rateNumerator, uint rateDenominator, address sender);\n', '\n', '    function setRateEthToToken(uint rateNumerator, uint rateDenominator) public onlyOperator {\n', '        require(rateNumerator > 0);\n', '        require(rateDenominator > 0);\n', '\n', '        ethToTokenNumerator = rateNumerator;\n', '        ethToTokenDenominator = rateDenominator;\n', '        emit RateSet(rateNumerator, rateDenominator, msg.sender);\n', '    }\n', '\n', '    function getRate () public view returns(uint rateNumerator, uint rateDenominator) {\n', '        rateNumerator = ethToTokenNumerator;\n', '        rateDenominator = ethToTokenDenominator;\n', '    }\n', '}\n', '\n', '// File: contracts/CapManager.sol\n', '\n', '//@Title Cap manager handles contribution cap per contributor.\n', '//@dev   IEO will have 2 phases:\n', '//          First phase is capped IEO where each contributor can contribute up to capped amount.\n', '//          Second phase will be open for unlimited contributions that are blocked only by amount of tokens.\n', 'contract CapManager is Withdrawable {\n', '    mapping(uint=>uint) public participatedWei;\n', '    uint public contributorCapWei;\n', '    uint internal IEOId; //uinque ID will be part of hash\n', '    uint constant public MAX_PURCHASE_WEI = uint(-1);\n', '    uint public cappedIEOStartTime;\n', '    uint public openIEOStartTime; //open IEO means no cap on purchase amount of KYC addresses.\n', '    uint public endIEOTime;\n', '\n', '    using SafeMath for uint;\n', '\n', '    constructor(uint _cappedIEOTime,\n', '        uint _openIEOTime,\n', '        uint _endIEOTime,\n', '        uint _contributorCapWei,\n', '        uint _IEOId,\n', '        address _admin)\n', '        Withdrawable(_admin)\n', '        public\n', '    {\n', '        require(_cappedIEOTime >= now); // solium-disable-line security/no-block-members\n', '        require(_cappedIEOTime <= _openIEOTime);\n', '        require(_openIEOTime <= _endIEOTime);\n', '        require(_IEOId != 0);\n', '\n', '        contributorCapWei = _contributorCapWei;\n', '        IEOId = _IEOId;\n', '        cappedIEOStartTime = _cappedIEOTime;\n', '        openIEOStartTime = _openIEOTime;\n', '        endIEOTime = _endIEOTime;\n', '    }\n', '\n', '    //@dev  getContributorRemainingCap returns remaining cap for a contributor\n', '    //      Assuming that contributor has passed KYC process = is allowed to participate.\n', '    //      If contributor hasn"t participated - it will return full cap according to IEO stage (capped / open / close).\n', '    //      If contributor already participated. when IEO in capped stage, will return contributor cap less previous\n', '    //        participation. if open contribute stage will return max cap.\n', '    //        notice the participation amount will still be blocked by token balance of this contract.\n', '    function getContributorRemainingCap(uint userId) public view returns(uint capWei) {\n', '        if (!IEOStarted()) return 0;\n', '        if (IEOEnded()) return 0;\n', '\n', '        if (openIEOStarted()) {\n', '            capWei = MAX_PURCHASE_WEI;\n', '        } else {\n', '            if (participatedWei[userId] >= contributorCapWei) capWei = 0;\n', '            else capWei = contributorCapWei.sub(participatedWei[userId]);\n', '        }\n', '    }\n', '\n', '    function eligible(uint userID, uint amountWei) public view returns(uint) {\n', '        uint remainingCap = getContributorRemainingCap(userID);\n', '        if (amountWei > remainingCap) return remainingCap;\n', '        return amountWei;\n', '    }\n', '\n', '    event ContributorCapSet(uint capWei, address sender);\n', '    function setContributorCap(uint capWei) public onlyAdmin {\n', '        contributorCapWei = capWei;\n', '        emit ContributorCapSet(capWei, msg.sender);\n', '    }\n', '\n', '    function IEOStarted() public view returns(bool) {\n', '        return (now >= cappedIEOStartTime); // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    function openIEOStarted() public view returns(bool) {\n', '        return (now >= openIEOStartTime); // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    function IEOEnded() public view returns(bool) {\n', '        return (now >= endIEOTime); // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    function validateContributor(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) public view returns(bool) {\n', '        require(verifySignature(keccak256(contributor, userId, IEOId), v, r, s));\n', '        return true;\n', '    }\n', '\n', '    function getIEOId() external view returns(uint) {\n', '        return IEOId;\n', '    }\n', '\n', '    function eligibleCheckAndIncrement(uint userId, uint amountInWei) internal returns(uint)\n', '    {\n', '        uint result = eligible(userId, amountInWei);\n', '        participatedWei[userId] = participatedWei[userId].add(result);\n', '\n', '        return result;\n', '    }\n', '\n', '    function verifySignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\n', '        address signer = ecrecover(hash, v, r, s);\n', '        return operators[signer];\n', '    }\n', '}\n', '\n', '// File: contracts/KyberIEOInterface.sol\n', '\n', 'interface KyberIEOInterface {\n', '    function contribute(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) external payable returns(bool);\n', '    function getContributorRemainingCap(uint userId) external view returns(uint capWei);\n', '    function getIEOId() external view returns(uint);\n', '}\n', '\n', '// File: contracts/KyberIEO.sol\n', '\n', 'contract KyberIEO is KyberIEOInterface, CapManager {\n', '    mapping(address=>bool) public whiteListedAddresses;\n', '    ERC20 public token;\n', '    uint  public raisedWei;\n', '    uint  public distributedTokensTwei;\n', '    bool  public haltedIEO = false;\n', '    IEORate public IEORateContract;\n', '    address public contributionWallet;\n', '\n', '    constructor (\n', '        address _admin,\n', '        address _contributionWallet,\n', '        ERC20 _token,\n', '        uint _contributorCapWei,\n', '        uint _IEOId,\n', '        uint _cappedIEOStart,\n', '        uint _openIEOStart,\n', '        uint _publicIEOEnd)\n', '        CapManager(_cappedIEOStart, _openIEOStart, _publicIEOEnd, _contributorCapWei, _IEOId, _admin)\n', '        public\n', '    {\n', '        require(_token != address(0));\n', '        require(_contributionWallet != address(0));\n', '\n', '        IEORateContract = new IEORate(_admin);\n', '        contributionWallet = _contributionWallet;\n', '        token = _token;\n', '    }\n', '\n', '    event IEOHalted(address sender);\n', '    function haltIEO() public onlyAlerter {\n', '        haltedIEO = true;\n', '        emit IEOHalted(msg.sender);\n', '    }\n', '\n', '    event IEOResumed(address sender);\n', '    function resumeIEO() public onlyAdmin {\n', '        haltedIEO = false;\n', '        emit IEOResumed(msg.sender);\n', '    }\n', '\n', '    event Contribution(address msgSender, address contributor, uint userId, uint distributedTokensTwei, uint payedWei);\n', '    function contribute(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) external payable returns(bool) {\n', '        require(!haltedIEO);\n', '        require(IEOStarted());\n', '        require(!IEOEnded());\n', '        require((contributor == msg.sender) || whiteListedAddresses[msg.sender]);\n', '\n', '        uint rateNumerator;\n', '        uint rateDenominator;\n', '        (rateNumerator, rateDenominator) = IEORateContract.getRate();\n', '        require(rateNumerator > 0);\n', '        require(rateDenominator > 0);\n', '        require(validateContributor(contributor, userId, v, r, s));\n', '\n', '        uint weiPayment = eligibleCheckAndIncrement(userId, msg.value);\n', '        require(weiPayment > 0);\n', '\n', '        uint tokenQty = weiPayment.mul(rateNumerator).div(rateDenominator);\n', '        require(tokenQty > 0);\n', '\n', '        // send remaining wei to msg.sender, not to contributor\n', '        if(msg.value > weiPayment) {\n', '            msg.sender.transfer(msg.value.sub(weiPayment));\n', '        }\n', '\n', '        // send payment to wallet\n', '        sendETHToContributionWallet(weiPayment);\n', '        raisedWei = raisedWei.add(weiPayment);\n', '\n', '        //send exchanged tokens to contributor\n', '        require(token.transfer(contributor, tokenQty));\n', '        distributedTokensTwei = distributedTokensTwei.add(tokenQty);\n', '\n', '        emit Contribution(msg.sender, contributor, userId, tokenQty, weiPayment);\n', '\n', '        return true;\n', '    }\n', '\n', '    event addressWhiteListed(address _address, bool whiteListed);\n', '    function whiteListAddress(address addr, bool whiteListed) public onlyAdmin {\n', '        whiteListedAddresses[addr] = whiteListed;\n', '        emit addressWhiteListed(addr, whiteListed);\n', '    }\n', '\n', '    function getRate () public view returns(uint rateNumerator, uint rateDenominator) {\n', '        (rateNumerator, rateDenominator) = IEORateContract.getRate();\n', '    }\n', '\n', '    // just to check that funds goes to the right place\n', '    // tokens are not given in return\n', '    function debugBuy() public payable {\n', '        require(msg.value == 123);\n', '        sendETHToContributionWallet(msg.value);\n', '    }\n', '\n', '    function sendETHToContributionWallet(uint valueWei) internal {\n', '        contributionWallet.transfer(valueWei);\n', '    }\n', '}\n', '\n', '// File: contracts/KyberIEOGetter.sol\n', '\n', 'contract ERC20Plus is ERC20 {\n', '    function symbol() external view returns(string);\n', '    function totalSupply() external view returns(uint);\n', '}\n', '\n', '\n', 'contract KyberIEOGetter {\n', '\n', '    function getIEOInfo(KyberIEO IEO) public view returns (\n', '        uint[3] IEOTimes,\n', '        bool[4] IEOStates,\n', '        uint[2] rate,\n', '        uint[5] amounts,\n', '        uint tokenDecimals,\n', '        address tokenAddress,\n', '        string symbol\n', '        )\n', '    {\n', '        IEOTimes = [IEO.cappedIEOStartTime(), IEO.openIEOStartTime(), IEO.endIEOTime()];\n', '        IEOStates = [IEO.IEOStarted(), IEO.openIEOStarted(), IEO.IEOEnded(), IEO.haltedIEO()];\n', '        rate = [IEORate(IEO.IEORateContract()).ethToTokenNumerator(), IEORate(IEO.IEORateContract()).ethToTokenDenominator()];\n', '        amounts = [IEO.distributedTokensTwei(), IEO.raisedWei(), IEO.contributorCapWei(), 0, IEO.token().totalSupply()];\n', '        amounts[3] = IEO.token().balanceOf(address(IEO));\n', '\n', '        return(IEOTimes, IEOStates, rate, amounts, IEO.token().decimals(), IEO.token(), ERC20Plus(IEO.token()).symbol());\n', '    }\n', '\n', '    function getIEOsInfo(KyberIEO[] IEOs) public view returns(\n', '        uint[] distributedTweiPerIEO,\n', '        uint[] tokenBalancePerIEO,\n', '        address[] tokenAddressPerIEO,\n', '        bytes32[] tokenSymbolPerIEO,\n', '        uint[] tokenDecimalsPerIEO,\n', '        uint[] totalSupplyPerIEO\n', '        )\n', '    {\n', '\n', '        distributedTweiPerIEO = new uint[](IEOs.length);\n', '        tokenBalancePerIEO = new uint[](IEOs.length);\n', '        tokenAddressPerIEO = new address[](IEOs.length);\n', '        tokenSymbolPerIEO = new bytes32[](IEOs.length);\n', '        tokenDecimalsPerIEO = new uint[](IEOs.length);\n', '        totalSupplyPerIEO = new uint[](IEOs.length);\n', '\n', '        for(uint i = 0; i < IEOs.length; i++) {\n', '            distributedTweiPerIEO[i] = IEOs[i].distributedTokensTwei();\n', '            tokenBalancePerIEO[i] = IEOs[i].token().balanceOf(address(IEOs[i]));\n', '            tokenAddressPerIEO[i] = IEOs[i].token();\n', '            tokenSymbolPerIEO[i] = stringToBytes32(ERC20Plus(IEOs[i].token()).symbol());\n', '            tokenDecimalsPerIEO[i] = IEOs[i].token().decimals();\n', '            totalSupplyPerIEO[i] = IEOs[i].token().totalSupply();\n', '        }\n', '    }\n', '\n', '    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}']