['/*\n', '\n', '  Copyright 2018 bZeroX, LLC\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// This provides a gatekeeping modifier for functions that can only be used by the bZx contract\n', '// Since it inherits Ownable provides typical ownership functionality with a slight modification to the transferOwnership function\n', '// Setting owner and bZxContractAddress to the same address is not supported.\n', 'contract BZxOwnable is Ownable {\n', '\n', '    address public bZxContractAddress;\n', '\n', '    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\n', '\n', '    // modifier reverts if bZxContractAddress isn&#39;t set\n', '    modifier onlyBZx() {\n', '        require(msg.sender == bZxContractAddress, "only bZx contracts can call this function");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\n', '    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\n', '    */\n', '    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\n', '        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, "transferBZxOwnership::unauthorized");\n', '        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\n', '        bZxContractAddress = newBZxContractAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0) && newOwner != bZxContractAddress, "transferOwnership::unauthorized");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract GasRefunder {\n', '    using SafeMath for uint256;\n', '\n', '    // If true, uses the "transfer" method, which throws on failure, reverting state.\n', '    // If false, a failed "send" won&#39;t throw, and fails silently.\n', '    // Note that a throw will prevent a GasRefund event.\n', '    bool public throwOnGasRefundFail = false;\n', '\n', '    struct GasData {\n', '        address payer;\n', '        uint gasUsed;\n', '        bool isPaid;\n', '    }\n', '\n', '    event GasRefund(address payer, uint gasUsed, uint currentGasPrice, uint refundAmount, bool refundSuccess);\n', '\n', '    modifier refundsGas(address payer, uint gasPrice, uint gasUsed, uint percentMultiplier)\n', '    {\n', '        _;\n', '        calculateAndSendRefund(\n', '            payer,\n', '            gasUsed,\n', '            gasPrice,\n', '            percentMultiplier\n', '        );\n', '    }\n', '\n', '    modifier refundsGasAfterCollection(address payer, uint gasPrice, uint percentMultiplier)\n', '    {\n', '        uint startingGas = gasleft();\n', '        _;\n', '        calculateAndSendRefund(\n', '            payer,\n', '            startingGas,\n', '            gasPrice,\n', '            percentMultiplier\n', '        );\n', '    }\n', '\n', '    function calculateAndSendRefund(\n', '        address payer,\n', '        uint gasUsed,\n', '        uint gasPrice,\n', '        uint percentMultiplier)\n', '        internal\n', '    {\n', '\n', '        if (gasUsed == 0 || gasPrice == 0)\n', '            return;\n', '\n', '        gasUsed = gasUsed - gasleft();\n', '\n', '        sendRefund(\n', '            payer,\n', '            gasUsed,\n', '            gasPrice,\n', '            percentMultiplier\n', '        );\n', '    }\n', '\n', '    function sendRefund(\n', '        address payer,\n', '        uint gasUsed,\n', '        uint gasPrice,\n', '        uint percentMultiplier)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (percentMultiplier == 0) // 0 percentMultiplier not allowed\n', '            percentMultiplier = 100;\n', '        \n', '        uint refundAmount = gasUsed.mul(gasPrice).mul(percentMultiplier).div(100);\n', '\n', '        if (throwOnGasRefundFail) {\n', '            payer.transfer(refundAmount);\n', '            emit GasRefund(\n', '                payer,\n', '                gasUsed,\n', '                gasPrice,\n', '                refundAmount,\n', '                true\n', '            );\n', '        } else {\n', '            emit GasRefund(\n', '                payer,\n', '                gasUsed,\n', '                gasPrice,\n', '                refundAmount,\n', '                payer.send(refundAmount)\n', '            );\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// supports a single EMA calculated for the inheriting contract\n', 'contract EMACollector {\n', '\n', '    uint public emaValue; // the last ema calculated\n', '    uint public emaPeriods; // averaging periods for EMA calculation\n', '\n', '    modifier updatesEMA(uint value) {\n', '        _;\n', '        updateEMA(value);\n', '    }\n', '\n', '    function updateEMA(uint value) \n', '        internal {\n', '        /*\n', '            Multiplier: 2 / (emaPeriods + 1)\n', '            EMA: (LastestValue - PreviousEMA) * Multiplier + PreviousEMA \n', '        */\n', '\n', '        require(emaPeriods >= 2, "emaPeriods < 2");\n', '\n', '        // calculate new EMA\n', '        emaValue = \n', '            SafeMath.sub(\n', '                SafeMath.add(\n', '                    value / (emaPeriods + 1) * 2,\n', '                    emaValue\n', '                ),\n', '                emaValue / (emaPeriods + 1) * 2\n', '            );\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title EIP20/ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract EIP20 is ERC20 {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '}\n', '\n', 'interface NonCompliantEIP20 {\n', '    function transfer(address _to, uint _value) external;\n', '    function transferFrom(address _from, address _to, uint _value) external;\n', '    function approve(address _spender, uint _value) external;\n', '}\n', '\n', '/**\n', ' * @title EIP20/ERC20 wrapper that will support noncompliant ERC20s\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' * @dev see https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', ' */\n', 'contract EIP20Wrapper {\n', '\n', '    function eip20Transfer(\n', '        address token,\n', '        address to,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).transfer(to, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20Transfer failed");\n', '    }\n', '\n', '    function eip20TransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).transferFrom(from, to, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20TransferFrom failed");\n', '    }\n', '\n', '    function eip20Approve(\n', '        address token,\n', '        address spender,\n', '        uint256 value)\n', '        internal\n', '        returns (bool result) {\n', '\n', '        NonCompliantEIP20(token).approve(spender, value);\n', '\n', '        assembly {\n', '            switch returndatasize()   \n', '            case 0 {                        // non compliant ERC20\n', '                result := not(0)            // result is true\n', '            }\n', '            case 32 {                       // compliant ERC20\n', '                returndatacopy(0, 0, 32) \n', '                result := mload(0)          // result == returndata of external call\n', '            }\n', '            default {                       // not an not an ERC20 token\n', '                revert(0, 0) \n', '            }\n', '        }\n', '\n', '        require(result, "eip20Approve failed");\n', '    }\n', '}\n', '\n', 'interface OracleInterface {\n', '\n', '    /// @dev Called by bZx after a loan order is taken\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param taker The taker of the loan order\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didTakeOrder(\n', '        bytes32 loanOrderHash,\n', '        address taker,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a position token is traded\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param trader The trader doing the trade\n', '    /// @param tradeTokenAddress The token that was bought in the trade\n', '    /// @param tradeTokenAmount The amount of token that was bought\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didTradePosition(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        address tradeTokenAddress,\n', '        uint tradeTokenAmount,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after interest should be paid to a lender\n', '    /// @dev Assume the interest token has already been transfered to\n', '    /// @dev this contract before this function is called.\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param trader The trader\n', '    /// @param lender The lender\n', '    /// @param interestTokenAddress The token that will be paid for interest\n', '    /// @param amountOwed The amount interest to pay\n', '    /// @param convert A boolean indicating if the interest should be converted to Ether\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didPayInterest(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        address lender,\n', '        address interestTokenAddress,\n', '        uint amountOwed,\n', '        bool convert,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a borrower has deposited additional collateral\n', '    /// @dev token for an open loan\n', '    /// @param loanOrderHash A unique hash representing the loan order.\n', '    /// @param borrower The borrower\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didDepositCollateral(\n', '        bytes32 loanOrderHash,\n', '        address borrower,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a borrower has withdrawn excess collateral\n', '    /// @dev token for an open loan\n', '    /// @param loanOrderHash A unique hash representing the loan order.\n', '    /// @param borrower The borrower\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didWithdrawCollateral(\n', '        bytes32 loanOrderHash,\n', '        address borrower,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a borrower has changed the collateral token\n', '    /// @dev used for an open loan\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param borrower The borrower\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didChangeCollateral(\n', '        bytes32 loanOrderHash,\n', '        address borrower,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a borrower has withdraw their profits, if any\n', '    /// @dev used for an open loan\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param borrower The borrower\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didWithdrawProfit(\n', '        bytes32 loanOrderHash,\n', '        address borrower,\n', '        uint profitOrLoss,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Called by bZx after a loan is closed\n', '    /// @param loanOrderHash A unique hash representing the loan order.\n', '    /// @param loanCloser The user that closed the loan\n', '    /// @param isLiquidation A boolean indicating if the loan was closed due to liquidation\n', '    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\n', '    /// @return Successful execution of the function\n', '    function didCloseLoan(\n', '        bytes32 loanOrderHash,\n', '        address loanCloser,\n', '        bool isLiquidation,\n', '        uint gasUsed)\n', '        external\n', '        returns (bool);\n', '\n', '    /// @dev Places a manual on-chain trade with a liquidity provider\n', '    /// @param sourceTokenAddress The token being sold\n', '    /// @param destTokenAddress The token being bought\n', '    /// @param sourceTokenAmount The amount of token being sold\n', '    /// @return The amount of destToken bought\n', '    function doManualTrade(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        external\n', '        returns (uint);\n', '\n', '    /// @dev Places an automatic on-chain trade with a liquidity provider\n', '    /// @param sourceTokenAddress The token being sold\n', '    /// @param destTokenAddress The token being bought\n', '    /// @param sourceTokenAmount The amount of token being sold\n', '    /// @return The amount of destToken bought\n', '    function doTrade(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        external\n', '        returns (uint);\n', '\n', '    /// @dev Verifies a position has fallen below margin maintenance\n', '    /// @dev then liquidates the position on-chain\n', '    /// @param loanTokenAddress The token that was loaned\n', '    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\n', '    /// @param collateralTokenAddress The token used for collateral\n', '    /// @param loanTokenAmount The amount of loan token\n', '    /// @param positionTokenAmount The amount of position token\n', '    /// @param collateralTokenAmount The amount of collateral token\n', '    /// @param maintenanceMarginAmount The maintenance margin amount from the loan\n', '    /// @return The amount of destToken bought\n', '    function verifyAndLiquidate(\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount,\n', '        uint maintenanceMarginAmount)\n', '        external\n', '        returns (uint);\n', '\n', '    /// @dev Liquidates collateral to cover loan losses\n', '    /// @param collateralTokenAddress The collateral token\n', '    /// @param loanTokenAddress The loan token\n', '    /// @param collateralTokenAmountUsable The total amount of collateral usable to cover losses\n', '    /// @param loanTokenAmountNeeded The amount of loan token needed to cover losses\n', '    /// @param initialMarginAmount The initial margin amount set for the loan\n', '    /// @param maintenanceMarginAmount The maintenance margin amount set for the loan\n', '    /// @return The amount of destToken bought\n', '    function doTradeofCollateral(\n', '        address collateralTokenAddress,\n', '        address loanTokenAddress,\n', '        uint collateralTokenAmountUsable,\n', '        uint loanTokenAmountNeeded,\n', '        uint initialMarginAmount,\n', '        uint maintenanceMarginAmount)\n', '        external\n', '        returns (uint, uint);\n', '\n', '    /// @dev Checks if a position has fallen below margin\n', '    /// @dev maintenance and should be liquidated\n', '    /// @param loanOrderHash A unique hash representing the loan order\n', '    /// @param trader The address of the trader\n', '    /// @param loanTokenAddress The token that was loaned\n', '    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\n', '    /// @param collateralTokenAddress The token used for collateral\n', '    /// @param loanTokenAmount The amount of loan token\n', '    /// @param positionTokenAmount The amount of position token\n', '    /// @param collateralTokenAmount The amount of collateral token\n', '    /// @param maintenanceMarginAmount The maintenance margin amount from the loan\n', '    /// @return Returns True if the trade should be liquidated immediately\n', '    function shouldLiquidate(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount,\n', '        uint maintenanceMarginAmount)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Gets the trade price of the ERC-20 token pair\n', '    /// @param sourceTokenAddress Token being sold\n', '    /// @param destTokenAddress Token being bought\n', '    /// @return The trade rate\n', '    function getTradeRate(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress)\n', '        external\n', '        view \n', '        returns (uint);\n', '\n', '    /// @dev Returns the profit/loss data for the current position\n', '    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\n', '    /// @param loanTokenAddress The token that was loaned\n', '    /// @param positionTokenAmount The amount of position token\n', '    /// @param loanTokenAmount The amount of loan token\n', '    /// @return isProfit, profitOrLoss (denominated in positionToken)\n', '    function getProfitOrLoss(\n', '        address positionTokenAddress,\n', '        address loanTokenAddress,\n', '        uint positionTokenAmount,\n', '        uint loanTokenAmount)\n', '        external\n', '        view\n', '        returns (bool isProfit, uint profitOrLoss);\n', '\n', '    /// @dev Returns the current margin level for this particular loan/position\n', '    /// @param loanTokenAddress The token that was loaned\n', '    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\n', '    /// @param collateralTokenAddress The token used for collateral\n', '    /// @param loanTokenAmount The amount of loan token\n', '    /// @param positionTokenAmount The amount of position token\n', '    /// @param collateralTokenAmount The amount of collateral token\n', '    /// @return The current margin amount (a percentage -> i.e. 54350000000000000000 == 54.35%)\n', '    function getCurrentMarginAmount(\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount)\n', '        external\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Checks if the ERC20 token pair is supported by the oracle\n', '    /// @param sourceTokenAddress Token being sold\n', '    /// @param destTokenAddress Token being bought\n', '    /// @param sourceTokenAmount Amount of token being sold\n', '    /// @return True if price discovery and trading is supported\n', '    function isTradeSupported(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        external\n', '        view \n', '        returns (bool);\n', '}\n', '\n', 'interface WETH_Interface {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', 'interface KyberNetwork_Interface {\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev makes a trade between src and dest token and send dest token to destAddress\n', '    /// @param src Src token\n', '    /// @param srcAmount amount of src tokens\n', '    /// @param dest   Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n', '    /// @param walletId is the wallet ID to send part of the fees\n', '    /// @return amount of actual dest tokens\n', '    function trade(\n', '        address src,\n', '        uint srcAmount,\n', '        address dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId\n', '    )\n', '        external\n', '        payable\n', '        returns(uint);\n', '\n', '    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n', '    function getExpectedRate(\n', '        address src,\n', '        address dest,\n', '        uint srcQty) \n', '        external \n', '        view \n', '        returns (uint expectedRate, uint slippageRate);\n', '}\n', '\n', 'contract BZxOracle is OracleInterface, EIP20Wrapper, EMACollector, GasRefunder, BZxOwnable {\n', '    using SafeMath for uint256;\n', '\n', '    // this is the value the Kyber portal uses when setting a very high maximum number\n', '    uint internal constant MAX_FOR_KYBER = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n', '\n', '    address internal constant KYBER_ETH_TOKEN_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n', '\n', '    // Percentage of interest retained as fee\n', '    // This will always be between 0 and 100\n', '    uint public interestFeePercent = 10;\n', '\n', '    // Percentage of liquidation level that will trigger a liquidation of positions\n', '    // This can never be less than 100\n', '    uint public liquidationThresholdPercent = 105;\n', '\n', '    // Percentage of gas refund paid to non-bounty hunters\n', '    uint public gasRewardPercent = 10;\n', '\n', '    // Percentage of gas refund paid to bounty hunters after successfully liquidating a position\n', '    uint public bountyRewardPercent = 110;\n', '\n', '    // A threshold of minimum initial margin for loan to be insured by the guarantee fund\n', '    // A value of 0 indicates that no threshold exists for this parameter.\n', '    uint public minInitialMarginAmount = 0;\n', '\n', '    // A threshold of minimum maintenance margin for loan to be insured by the guarantee fund\n', '    // A value of 0 indicates that no threshold exists for this parameter.\n', '    uint public minMaintenanceMarginAmount = 25;\n', '\n', '    bool public isManualTradingAllowed = true;\n', '\n', '    address public vaultContract;\n', '    address public kyberContract;\n', '    address public wethContract;\n', '    address public bZRxTokenContract;\n', '\n', '    mapping (bytes32 => GasData[]) public gasRefunds; // mapping of loanOrderHash to array of GasData\n', '\n', '    constructor(\n', '        address _vaultContract,\n', '        address _kyberContract,\n', '        address _wethContract,\n', '        address _bZRxTokenContract)\n', '        public\n', '        payable\n', '    {\n', '        vaultContract = _vaultContract;\n', '        kyberContract = _kyberContract;\n', '        wethContract = _wethContract;\n', '        bZRxTokenContract = _bZRxTokenContract;\n', '\n', '        // settings for EMACollector\n', '        emaValue = 20 * 10**9 wei; // set an initial price average for gas (20 gwei)\n', '        emaPeriods = 10; // set periods to use for EMA calculation\n', '    }\n', '\n', '    // The contract needs to be able to receive Ether from Kyber trades\n', '    function() public payable {}\n', '\n', '    // standard functions\n', '    function didTakeOrder(\n', '        bytes32 loanOrderHash,\n', '        address taker,\n', '        uint gasUsed)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        gasRefunds[loanOrderHash].push(GasData({\n', '            payer: taker,\n', '            gasUsed: gasUsed.sub(gasleft()),\n', '            isPaid: false\n', '        }));\n', '\n', '        return true;\n', '    }\n', '\n', '    function didTradePosition(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* trader */,\n', '        address /* tradeTokenAddress */,\n', '        uint /* tradeTokenAmount */,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function didPayInterest(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* trader */,\n', '        address lender,\n', '        address interestTokenAddress,\n', '        uint amountOwed,\n', '        bool convert,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        uint interestFee = amountOwed.mul(interestFeePercent).div(100);\n', '\n', '        // Transfers the interest to the lender, less the interest fee.\n', '        // The fee is retained by the oracle.\n', '        if (!_transferToken(\n', '            interestTokenAddress,\n', '            lender,\n', '            amountOwed.sub(interestFee))) {\n', '            revert("BZxOracle::didPayInterest: _transferToken failed");\n', '        }\n', '\n', '        if (interestTokenAddress == wethContract) {\n', '            // interest paid in WETH is withdrawn to Ether\n', '            WETH_Interface(wethContract).withdraw(interestFee);\n', '        } else if (convert && interestTokenAddress != bZRxTokenContract) {\n', '            // interest paid in BZRX is retained as is, other tokens are sold for Ether\n', '            _doTradeForEth(\n', '                interestTokenAddress,\n', '                interestFee,\n', '                this // BZxOracle receives the Ether proceeds\n', '            );\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function didDepositCollateral(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* borrower */,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function didWithdrawCollateral(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* borrower */,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function didChangeCollateral(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* borrower */,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function didWithdrawProfit(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* borrower */,\n', '        uint /* profitOrLoss */,\n', '        uint /* gasUsed */)\n', '        public\n', '        onlyBZx\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function didCloseLoan(\n', '        bytes32 loanOrderHash,\n', '        address loanCloser,\n', '        bool isLiquidation,\n', '        uint gasUsed)\n', '        public\n', '        onlyBZx\n', '        //refundsGas(taker, emaValue, gasUsed, 0) // refunds based on collected gas price EMA\n', '        updatesEMA(tx.gasprice)\n', '        returns (bool)\n', '    {\n', '        // sends gas refunds owed from earlier transactions\n', '        for (uint i=0; i < gasRefunds[loanOrderHash].length; i++) {\n', '            GasData storage gasData = gasRefunds[loanOrderHash][i];\n', '            if (!gasData.isPaid) {\n', '                if (sendRefund(\n', '                    gasData.payer,\n', '                    gasData.gasUsed,\n', '                    emaValue,\n', '                    gasRewardPercent))               \n', '                        gasData.isPaid = true;\n', '            }\n', '        }\n', '\n', '        // sends gas and bounty reward to bounty hunter\n', '        if (isLiquidation) {\n', '            calculateAndSendRefund(\n', '                loanCloser,\n', '                gasUsed,\n', '                emaValue,\n', '                bountyRewardPercent);\n', '        }\n', '        \n', '        return true;\n', '    }\n', '\n', '    function doManualTrade(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        public\n', '        onlyBZx\n', '        returns (uint destTokenAmount)\n', '    {\n', '        if (isManualTradingAllowed) {\n', '            destTokenAmount = _doTrade(\n', '                sourceTokenAddress,\n', '                destTokenAddress,\n', '                sourceTokenAmount,\n', '                MAX_FOR_KYBER); // no limit on the dest amount\n', '        }\n', '        else {\n', '            revert("Manual trading is disabled.");\n', '        }\n', '    }\n', '\n', '    function doTrade(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        public\n', '        onlyBZx\n', '        returns (uint destTokenAmount)\n', '    {\n', '        destTokenAmount = _doTrade(\n', '            sourceTokenAddress,\n', '            destTokenAddress,\n', '            sourceTokenAmount,\n', '            MAX_FOR_KYBER); // no limit on the dest amount\n', '    }\n', '\n', '    function verifyAndLiquidate(\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount,\n', '        uint maintenanceMarginAmount)\n', '        public\n', '        onlyBZx\n', '        returns (uint destTokenAmount)\n', '    {\n', '        if (!shouldLiquidate(\n', '            0x0,\n', '            0x0,\n', '            loanTokenAddress,\n', '            positionTokenAddress,\n', '            collateralTokenAddress,\n', '            loanTokenAmount,\n', '            positionTokenAmount,\n', '            collateralTokenAmount,\n', '            maintenanceMarginAmount)) {\n', '            return 0;\n', '        }\n', '        \n', '        destTokenAmount = _doTrade(\n', '            positionTokenAddress,\n', '            loanTokenAddress,\n', '            positionTokenAmount,\n', '            MAX_FOR_KYBER); // no limit on the dest amount\n', '    }\n', '\n', '    function doTradeofCollateral(\n', '        address collateralTokenAddress,\n', '        address loanTokenAddress,\n', '        uint collateralTokenAmountUsable,\n', '        uint loanTokenAmountNeeded,\n', '        uint initialMarginAmount,\n', '        uint maintenanceMarginAmount)\n', '        public\n', '        onlyBZx\n', '        returns (uint loanTokenAmountCovered, uint collateralTokenAmountUsed)\n', '    {\n', '        uint collateralTokenBalance = EIP20(collateralTokenAddress).balanceOf.gas(4999)(this); // Changes to state require at least 5000 gas\n', '        if (collateralTokenBalance < collateralTokenAmountUsable) { // sanity check\n', '            revert("BZxOracle::doTradeofCollateral: collateralTokenBalance < collateralTokenAmountUsable");\n', '        }\n', '\n', '        loanTokenAmountCovered = _doTrade(\n', '            collateralTokenAddress,\n', '            loanTokenAddress,\n', '            collateralTokenAmountUsable,\n', '            loanTokenAmountNeeded);\n', '\n', '        collateralTokenAmountUsed = collateralTokenBalance.sub(EIP20(collateralTokenAddress).balanceOf.gas(4999)(this)); // Changes to state require at least 5000 gas\n', '        \n', '        if (collateralTokenAmountUsed < collateralTokenAmountUsable) {\n', '            // send unused collateral token back to the vault\n', '            if (!_transferToken(\n', '                collateralTokenAddress,\n', '                vaultContract,\n', '                collateralTokenAmountUsable.sub(collateralTokenAmountUsed))) {\n', '                revert("BZxOracle::doTradeofCollateral: _transferToken failed");\n', '            }\n', '        }\n', '\n', '        if (loanTokenAmountCovered < loanTokenAmountNeeded) {\n', '            // cover losses with insurance if applicable\n', '            if ((minInitialMarginAmount == 0 || initialMarginAmount >= minInitialMarginAmount) &&\n', '                (minMaintenanceMarginAmount == 0 || maintenanceMarginAmount >= minMaintenanceMarginAmount)) {\n', '                \n', '                loanTokenAmountCovered = loanTokenAmountCovered.add(\n', '                    _doTradeWithEth(\n', '                        loanTokenAddress,\n', '                        loanTokenAmountNeeded.sub(loanTokenAmountCovered),\n', '                        vaultContract\n', '                ));\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '    * Public View functions\n', '    */\n', '\n', '    function shouldLiquidate(\n', '        bytes32 /* loanOrderHash */,\n', '        address /* trader */,\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount,\n', '        uint maintenanceMarginAmount)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            getCurrentMarginAmount(\n', '                loanTokenAddress,\n', '                positionTokenAddress,\n', '                collateralTokenAddress,\n', '                loanTokenAmount,\n', '                positionTokenAmount,\n', '                collateralTokenAmount).div(maintenanceMarginAmount).div(10**16) <= (liquidationThresholdPercent)\n', '            );\n', '    } \n', '\n', '    function isTradeSupported(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        public\n', '        view \n', '        returns (bool)\n', '    {\n', '        (uint rate, uint slippage) = _getExpectedRate(\n', '            sourceTokenAddress,\n', '            destTokenAddress,\n', '            sourceTokenAmount);\n', '        \n', '        if (rate > 0 && (sourceTokenAmount == 0 || slippage > 0))\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', '    function getTradeRate(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress)\n', '        public\n', '        view \n', '        returns (uint rate)\n', '    {\n', '        (rate,) = _getExpectedRate(\n', '            sourceTokenAddress,\n', '            destTokenAddress,\n', '            0);\n', '    }\n', '\n', '    // returns bool isProfit, uint profitOrLoss\n', '    // the position&#39;s profit/loss denominated in positionToken\n', '    function getProfitOrLoss(\n', '        address positionTokenAddress,\n', '        address loanTokenAddress,\n', '        uint positionTokenAmount,\n', '        uint loanTokenAmount)\n', '        public\n', '        view\n', '        returns (bool isProfit, uint profitOrLoss)\n', '    {\n', '        uint loanToPositionAmount;\n', '        if (positionTokenAddress == loanTokenAddress) {\n', '            loanToPositionAmount = loanTokenAmount;\n', '        } else {\n', '            (uint positionToLoanRate,) = _getExpectedRate(\n', '                positionTokenAddress,\n', '                loanTokenAddress,\n', '                0);\n', '            if (positionToLoanRate == 0) {\n', '                return;\n', '            }\n', '            loanToPositionAmount = loanTokenAmount.mul(10**18).div(positionToLoanRate);\n', '        }\n', '\n', '        if (positionTokenAmount > loanToPositionAmount) {\n', '            isProfit = true;\n', '            profitOrLoss = positionTokenAmount - loanToPositionAmount;\n', '        } else {\n', '            isProfit = false;\n', '            profitOrLoss = loanToPositionAmount - positionTokenAmount;\n', '        }\n', '    }\n', '\n', '    /// @return The current margin amount (a percentage -> i.e. 54350000000000000000 == 54.35%)\n', '    function getCurrentMarginAmount(\n', '        address loanTokenAddress,\n', '        address positionTokenAddress,\n', '        address collateralTokenAddress,\n', '        uint loanTokenAmount,\n', '        uint positionTokenAmount,\n', '        uint collateralTokenAmount)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint collateralToLoanAmount;\n', '        if (collateralTokenAddress == loanTokenAddress) {\n', '            collateralToLoanAmount = collateralTokenAmount;\n', '        } else {\n', '            (uint collateralToLoanRate,) = _getExpectedRate(\n', '                collateralTokenAddress,\n', '                loanTokenAddress,\n', '                0);\n', '            if (collateralToLoanRate == 0) {\n', '                return 0;\n', '            }\n', '            collateralToLoanAmount = collateralTokenAmount.mul(collateralToLoanRate).div(10**18);\n', '        }\n', '\n', '        uint positionToLoanAmount;\n', '        if (positionTokenAddress == loanTokenAddress) {\n', '            positionToLoanAmount = positionTokenAmount;\n', '        } else {\n', '            (uint positionToLoanRate,) = _getExpectedRate(\n', '                positionTokenAddress,\n', '                loanTokenAddress,\n', '                0);\n', '            if (positionToLoanRate == 0) {\n', '                return 0;\n', '            }\n', '            positionToLoanAmount = positionTokenAmount.mul(positionToLoanRate).div(10**18);\n', '        }\n', '\n', '        return collateralToLoanAmount.add(positionToLoanAmount).sub(loanTokenAmount).mul(10**20).div(loanTokenAmount);\n', '    }\n', '\n', '    /*\n', '    * Owner functions\n', '    */\n', '\n', '    function setInterestFeePercent(\n', '        uint newRate) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newRate != interestFeePercent && newRate >= 0 && newRate <= 100);\n', '        interestFeePercent = newRate;\n', '    }\n', '\n', '    function setLiquidationThresholdPercent(\n', '        uint newValue) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newValue != liquidationThresholdPercent && liquidationThresholdPercent >= 100);\n', '        liquidationThresholdPercent = newValue;\n', '    }\n', '\n', '    function setGasRewardPercent(\n', '        uint newValue) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newValue != gasRewardPercent);\n', '        gasRewardPercent = newValue;\n', '    }\n', '\n', '    function setBountyRewardPercent(\n', '        uint newValue) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newValue != bountyRewardPercent);\n', '        bountyRewardPercent = newValue;\n', '    }\n', '\n', '    function setMarginThresholds(\n', '        uint newInitialMargin,\n', '        uint newMaintenanceMargin) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newInitialMargin >= newMaintenanceMargin);\n', '        minInitialMarginAmount = newInitialMargin;\n', '        minMaintenanceMarginAmount = newMaintenanceMargin;\n', '    }\n', '\n', '    function setManualTradingAllowed (\n', '        bool _isManualTradingAllowed)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (isManualTradingAllowed != _isManualTradingAllowed)\n', '            isManualTradingAllowed = _isManualTradingAllowed;\n', '    }\n', '\n', '    function setVaultContractAddress(\n', '        address newAddress) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newAddress != vaultContract && newAddress != address(0));\n', '        vaultContract = newAddress;\n', '    }\n', '\n', '    function setKyberContractAddress(\n', '        address newAddress) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newAddress != kyberContract && newAddress != address(0));\n', '        kyberContract = newAddress;\n', '    }\n', '\n', '    function setWethContractAddress(\n', '        address newAddress) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newAddress != wethContract && newAddress != address(0));\n', '        wethContract = newAddress;\n', '    }\n', '\n', '    function setBZRxTokenContractAddress(\n', '        address newAddress) \n', '        public\n', '        onlyOwner\n', '    {\n', '        require(newAddress != bZRxTokenContract && newAddress != address(0));\n', '        bZRxTokenContract = newAddress;\n', '    }\n', '\n', '    function setEMAPeriods (\n', '        uint _newEMAPeriods)\n', '        public\n', '        onlyOwner {\n', '        require(_newEMAPeriods > 1 && _newEMAPeriods != emaPeriods);\n', '        emaPeriods = _newEMAPeriods;\n', '    }\n', '\n', '    function transferEther(\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint amount = value;\n', '        if (amount > address(this).balance) {\n', '            amount = address(this).balance;\n', '        }\n', '\n', '        return (to.send(amount));\n', '    }\n', '\n', '    function transferToken(\n', '        address tokenAddress,\n', '        address to,\n', '        uint value)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        return (_transferToken(\n', '            tokenAddress,\n', '            to,\n', '            value\n', '        ));\n', '    }\n', '\n', '    /*\n', '    * Internal functions\n', '    */\n', '\n', '    // ref: https://github.com/KyberNetwork/smart-contracts/blob/master/integration.md#rate-query\n', '    function _getExpectedRate(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount)\n', '        internal\n', '        view \n', '        returns (uint expectedRate, uint slippageRate)\n', '    {\n', '        if (sourceTokenAddress == destTokenAddress) {\n', '            expectedRate = 10**18;\n', '            slippageRate = 0;\n', '        } else {\n', '            if (sourceTokenAddress == wethContract) {\n', '                (expectedRate, slippageRate) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    destTokenAddress, \n', '                    sourceTokenAmount\n', '                );\n', '            } else if (destTokenAddress == wethContract) {\n', '                (expectedRate, slippageRate) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '                    sourceTokenAddress,\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    sourceTokenAmount\n', '                );\n', '            } else {\n', '                (uint sourceToEther, uint sourceToEtherSlippage) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '                    sourceTokenAddress,\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    sourceTokenAmount\n', '                );\n', '                if (sourceTokenAmount > 0) {\n', '                    sourceTokenAmount = sourceTokenAmount.mul(sourceToEther).div(10**18);\n', '                }\n', '\n', '                (uint etherToDest, uint etherToDestSlippage) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    destTokenAddress,\n', '                    sourceTokenAmount\n', '                );\n', '\n', '                expectedRate = sourceToEther.mul(etherToDest).div(10**18);\n', '                slippageRate = sourceToEtherSlippage.mul(etherToDestSlippage).div(10**18);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doTrade(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount,\n', '        uint maxDestTokenAmount)\n', '        internal\n', '        returns (uint destTokenAmount)\n', '    {\n', '        if (sourceTokenAddress == destTokenAddress) {\n', '            if (maxDestTokenAmount < MAX_FOR_KYBER) {\n', '                destTokenAmount = maxDestTokenAmount;\n', '            } else {\n', '                destTokenAmount = sourceTokenAmount;\n', '            }\n', '        } else {\n', '            if (sourceTokenAddress == wethContract) {\n', '                WETH_Interface(wethContract).withdraw(sourceTokenAmount);\n', '\n', '                destTokenAmount = KyberNetwork_Interface(kyberContract).trade\n', '                    .value(sourceTokenAmount)( // send Ether along \n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    sourceTokenAmount,\n', '                    destTokenAddress,\n', '                    vaultContract, // bZxVault recieves the destToken\n', '                    maxDestTokenAmount,\n', '                    0, // no min coversation rate\n', '                    address(0)\n', '                );\n', '            } else if (destTokenAddress == wethContract) {\n', '                // re-up the Kyber spend approval if needed\n', '                if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \n', '                    MAX_FOR_KYBER) {\n', '                    \n', '                    eip20Approve(\n', '                        sourceTokenAddress,\n', '                        kyberContract,\n', '                        MAX_FOR_KYBER);\n', '                }\n', '\n', '                destTokenAmount = KyberNetwork_Interface(kyberContract).trade(\n', '                    sourceTokenAddress,\n', '                    sourceTokenAmount,\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    this, // BZxOracle receives the Ether proceeds\n', '                    maxDestTokenAmount,\n', '                    0, // no min coversation rate\n', '                    address(0)\n', '                );\n', '\n', '                WETH_Interface(wethContract).deposit.value(destTokenAmount)();\n', '\n', '                if (!_transferToken(\n', '                    destTokenAddress,\n', '                    vaultContract,\n', '                    destTokenAmount)) {\n', '                    revert("BZxOracle::_doTrade: _transferToken failed");\n', '                }\n', '            } else {\n', '                // re-up the Kyber spend approval if needed\n', '                if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \n', '                    MAX_FOR_KYBER) {\n', '                    \n', '                    eip20Approve(\n', '                        sourceTokenAddress,\n', '                        kyberContract,\n', '                        MAX_FOR_KYBER);\n', '                }\n', '                \n', '                uint maxDestEtherAmount = maxDestTokenAmount;\n', '                if (maxDestTokenAmount < MAX_FOR_KYBER) {\n', '                    uint etherToDest;\n', '                    (etherToDest,) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '                        KYBER_ETH_TOKEN_ADDRESS,\n', '                        destTokenAddress, \n', '                        0\n', '                    );\n', '                    maxDestEtherAmount = maxDestTokenAmount.mul(10**18).div(etherToDest);\n', '                }\n', '\n', '                uint destEtherAmount = KyberNetwork_Interface(kyberContract).trade(\n', '                    sourceTokenAddress,\n', '                    sourceTokenAmount,\n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    this, // BZxOracle receives the Ether proceeds\n', '                    maxDestEtherAmount,\n', '                    0, // no min coversation rate\n', '                    address(0)\n', '                );\n', '\n', '                destTokenAmount = KyberNetwork_Interface(kyberContract).trade\n', '                    .value(destEtherAmount)( // send Ether along \n', '                    KYBER_ETH_TOKEN_ADDRESS,\n', '                    destEtherAmount,\n', '                    destTokenAddress,\n', '                    vaultContract, // bZxVault recieves the destToken\n', '                    maxDestTokenAmount,\n', '                    0, // no min coversation rate\n', '                    address(0)\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doTradeForEth(\n', '        address sourceTokenAddress,\n', '        uint sourceTokenAmount,\n', '        address receiver)\n', '        internal\n', '        returns (uint)\n', '    {\n', '        // re-up the Kyber spend approval if needed\n', '        if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \n', '            MAX_FOR_KYBER) {\n', '\n', '            eip20Approve(\n', '                sourceTokenAddress,\n', '                kyberContract,\n', '                MAX_FOR_KYBER);\n', '        }\n', '        \n', '        // bytes4(keccak256("trade(address,uint256,address,address,uint256,uint256,address)")) = 0xcb3c28c7\n', '        bool result = kyberContract.call\n', '            .gas(gasleft())(\n', '            0xcb3c28c7,\n', '            sourceTokenAddress,\n', '            sourceTokenAmount,\n', '            KYBER_ETH_TOKEN_ADDRESS,\n', '            receiver,\n', '            MAX_FOR_KYBER, // no limit on the dest amount\n', '            0, // no min coversation rate\n', '            address(0)\n', '        );\n', '\n', '        assembly {\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            switch result\n', '            case 0 { return(0, 0x20) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function _doTradeWithEth(\n', '        address destTokenAddress,\n', '        uint destTokenAmountNeeded,\n', '        address receiver)\n', '        internal\n', '        returns (uint)\n', '    {\n', '        uint etherToDest;\n', '        (etherToDest,) = KyberNetwork_Interface(kyberContract).getExpectedRate(\n', '            KYBER_ETH_TOKEN_ADDRESS,\n', '            destTokenAddress, \n', '            0\n', '        );\n', '\n', '        // calculate amount of ETH to use with a 5% buffer (unused ETH is returned by Kyber)\n', '        uint ethToSend = destTokenAmountNeeded.mul(10**18).div(etherToDest).mul(105).div(100);\n', '        if (ethToSend > address(this).balance) {\n', '            ethToSend = address(this).balance;\n', '        }\n', '\n', '        // bytes4(keccak256("trade(address,uint256,address,address,uint256,uint256,address)")) = 0xcb3c28c7\n', '        bool result = kyberContract.call\n', '            .gas(gasleft())\n', '            .value(ethToSend)( // send Ether along \n', '            0xcb3c28c7,\n', '            KYBER_ETH_TOKEN_ADDRESS,\n', '            ethToSend,\n', '            destTokenAddress,\n', '            receiver,\n', '            destTokenAmountNeeded,\n', '            0, // no min coversation rate\n', '            address(0)\n', '        );\n', '\n', '        assembly {\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            switch result\n', '            case 0 { return(0, 0x20) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function _transferToken(\n', '        address tokenAddress,\n', '        address to,\n', '        uint value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        eip20Transfer(\n', '            tokenAddress,\n', '            to,\n', '            value);\n', '\n', '        return true;\n', '    }\n', '}']