['pragma solidity ^0.4.19;\n', '\n', 'contract CrowdsaleTokenInterface {\n', '\n', '  uint public decimals;\n', '   \n', '  function addLockAddress(address addr, uint lock_time) public;\n', '  function mint(address _to, uint256 _amount) public returns (bool);\n', '  function finishMinting() public returns (bool);\n', '}\n', '\n', 'contract CrowdsaleLimit {\n', '  using SafeMath for uint256;\n', '\n', '  // the UNIX timestamp start date of the crowdsale\n', '  uint public startsAt;\n', '  // the UNIX timestamp end date of the crowdsale\n', '  uint public endsAt;\n', '  \n', '  uint public token_decimals = 8;\n', '    \n', '  uint public TOKEN_RATE_PRESALE  = 7200;\n', '  uint public TOKEN_RATE_CROWDSALE= 6000;\n', '  \n', '  // setting the wei value for one token in presale stage\n', '  uint public PRESALE_TOKEN_IN_WEI = 1 ether / TOKEN_RATE_PRESALE;  \n', '  // setting the wei value for one token in crowdsale stage\n', '  uint public CROWDSALE_TOKEN_IN_WEI = 1 ether / TOKEN_RATE_CROWDSALE;\n', '  \n', '  // setting the max fund of presale with eth\n', '  uint public PRESALE_ETH_IN_WEI_FUND_MAX = 40000 ether; \n', '  // setting the min fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MIN = 22000 ether;\n', '  // setting the max fund of crowdsale with eth\n', '  uint public CROWDSALE_ETH_IN_WEI_FUND_MAX = 90000 ether;\n', '  \n', '  // setting the min acceptable invest with eth in presale\n', '  uint public PRESALE_ETH_IN_WEI_ACCEPTED_MIN = 1 ether; \n', '  // setting the min acceptable invest with eth in pubsale\n', '  uint public CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = 100 finney;\n', '  \n', '  // setting the gasprice to limit big buyer, default to disable\n', '  uint public CROWDSALE_GASPRICE_IN_WEI_MAX = 0;\n', ' \n', ' // total eth fund in presale stage\n', '  uint public presale_eth_fund= 0;\n', '  // total eth fund\n', '  uint public crowdsale_eth_fund= 0;\n', '  // total eth refund\n', '  uint public crowdsale_eth_refund = 0;\n', '   \n', '  // setting team list and set percentage of tokens\n', '  mapping(address => uint) public team_addresses_token_percentage;\n', '  mapping(uint => address) public team_addresses_idx;\n', '  uint public team_address_count= 0;\n', '  uint public team_token_percentage_total= 0;\n', '  uint public team_token_percentage_max= 40;\n', '    \n', '  event EndsAtChanged(uint newEndsAt);\n', '  event AddTeamAddress(address addr, uint release_time, uint token_percentage);\n', '  event Refund(address investor, uint weiAmount);\n', '    \n', '  // limitation of buying tokens\n', '  modifier allowCrowdsaleAmountLimit(){\t\n', '\tif (msg.value == 0) revert();\n', '\tif((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert();\n', '\tif((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert();\n', '\t_;\n', '  }\n', '   \n', '  function CrowdsaleLimit(uint _start, uint _end) public {\n', '\trequire(_start != 0);\n', '\trequire(_end != 0);\n', '\trequire(_start < _end);\n', '\t\t\t\n', '\tstartsAt = _start;\n', '    endsAt = _end;\n', '  }\n', '    \n', '  // caculate amount of token in presale stage\n', '  function calculateTokenPresale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(PRESALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // caculate amount of token in crowdsale stage\n', '  function calculateTokenCrowsale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\n', '    uint multiplier = 10 ** decimals;\n', '    return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI);\n', '  }\n', '  \n', '  // check if the goal is reached\n', '  function isMinimumGoalReached() public constant returns (bool) {\n', '    return crowdsale_eth_fund >= CROWDSALE_ETH_IN_WEI_FUND_MIN;\n', '  }\n', '  \n', '  // add new team percentage of tokens\n', '  function addTeamAddressInternal(address addr, uint release_time, uint token_percentage) internal {\n', '\tif((team_token_percentage_total.add(token_percentage)) > team_token_percentage_max) revert();\n', '\tif((team_token_percentage_total.add(token_percentage)) > 100) revert();\n', '\tif(team_addresses_token_percentage[addr] != 0) revert();\n', '\t\n', '\tteam_addresses_token_percentage[addr]= token_percentage;\n', '\tteam_addresses_idx[team_address_count]= addr;\n', '\tteam_address_count++;\n', '\t\n', '\tteam_token_percentage_total = team_token_percentage_total.add(token_percentage);\n', '\n', '\tAddTeamAddress(addr, release_time, token_percentage);\n', '  }\n', '   \n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > endsAt;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) revert();\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) revert();\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is CrowdsaleLimit, Haltable {\n', '  using SafeMath for uint256;\n', '\n', '  CrowdsaleTokenInterface public token;\n', '    \n', '  /* tokens will be transfered from this address */\n', '  address public multisigWallet;\n', '    \n', '  /** How much ETH each address has invested to this crowdsale */\n', '  mapping (address => uint256) public investedAmountOf;\n', '\n', '  /** How much tokens this crowdsale has credited for each investor address */\n', '  mapping (address => uint256) public tokenAmountOf;\n', '     \n', '  /* the number of tokens already sold through this contract*/\n', '  uint public tokensSold = 0;\n', '  \n', '  /* How many distinct addresses have invested */\n', '  uint public investorCount = 0;\n', '  \n', '  /* How much wei we have returned back to the contract after a failed crowdfund. */\n', '  uint public loadedRefund = 0;\n', '  \n', '  /* Has this crowdsale been finalized */\n', '  bool public finalized;\n', '  \n', '  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n', '    \n', '  // A new investment was made\n', '  event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '    \n', '  event createTeamTokenEvent(address addr, uint tokens);\n', '  \n', '  event Finalized();\n', '  \n', '  /** Modified allowing execution only if the crowdsale is currently running.  */\n', '  modifier inState(State state) {\n', '    if(getState() != state) revert();\n', '    _;\n', '  }\n', '\n', '  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end) CrowdsaleLimit(_start, _end) public\n', '  {\n', '    require(_token != 0x0);\n', '    require(_multisigWallet != 0x0);\n', '\t\n', '\ttoken = CrowdsaleTokenInterface(_token);\t\n', '\tif(token_decimals != token.decimals()) revert();\n', '\t\n', '\tmultisigWallet = _multisigWallet;\n', '  }\n', '  \n', '  /* Crowdfund state machine management. */\n', '  function getState() public constant returns (State) {\n', '    if(finalized) return State.Finalized;\n', '    else if (now < startsAt) return State.PreFunding;\n', '    else if (now <= endsAt && !isMinimumGoalReached()) return State.Funding;\n', '    else if (isMinimumGoalReached()) return State.Success;\n', '    else if (!isMinimumGoalReached() && crowdsale_eth_fund > 0 && loadedRefund >= crowdsale_eth_fund) return State.Refunding;\n', '    else return State.Failure;\n', '  }\n', '    \n', '  //add new team percentage of tokens and lock their release time\n', '  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) public {\n', '\tsuper.addTeamAddressInternal(addr, release_time, token_percentage);\n', '\ttoken.addLockAddress(addr, release_time);  //not use delegatecall\n', '  }\n', '  \n', '  //generate team tokens in accordance with percentage of total issue tokens, not preallocate\n', '  function createTeamTokenByPercentage() onlyOwner internal {\n', '\t//uint total= token.totalSupply();\n', '\tuint total= tokensSold;\n', '\t\n', '\t//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);\n', '\tuint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);\n', '\t\n', '\tfor(uint i=0; i<team_address_count; i++) {\n', '\t\taddress addr= team_addresses_idx[i];\n', '\t\tif(addr==0x0) continue;\n', '\t\t\n', '\t\tuint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);\n', '\t\ttoken.mint(addr, ntoken);\t\t\n', '\t\tcreateTeamTokenEvent(addr, ntoken);\n', '\t}\n', '  }\n', '  \n', '  // fallback function can be used to buy tokens\n', '  function () stopInEmergency allowCrowdsaleAmountLimit payable public {\n', '\trequire(msg.sender != 0x0);\n', '    buyTokensCrowdsale(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {\n', '\tuint256 weiAmount = msg.value;\n', '\tuint256 tokenAmount= 0;\n', '\t\n', '\tif(getState() == State.PreFunding) {\n', '\t\tif (weiAmount < PRESALE_ETH_IN_WEI_ACCEPTED_MIN) revert();\n', '\t\tif((PRESALE_ETH_IN_WEI_FUND_MAX > 0) && ((presale_eth_fund.add(weiAmount)) > PRESALE_ETH_IN_WEI_FUND_MAX)) revert();\t\t\n', '\t\t\n', '\t\ttokenAmount = calculateTokenPresale(weiAmount, token_decimals);\n', '\t\tpresale_eth_fund = presale_eth_fund.add(weiAmount);\n', '\t}\n', '\telse if((getState() == State.Funding) || (getState() == State.Success)) {\n', '\t\tif (weiAmount < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert();\n', '\t\t\n', '\t\ttokenAmount = calculateTokenCrowsale(weiAmount, token_decimals);\n', '\t\t\n', '    } else {\n', '      // Unwanted state\n', '      revert();\n', '    }\n', '\t\n', '\tif(tokenAmount == 0) {\n', '\t\trevert();\n', '\t}\t\n', '\t\n', '\tif(investedAmountOf[receiver] == 0) {\n', '       investorCount++;\n', '    }\n', '    \n', '\t// Update investor\n', '    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '\t\n', '    // Update totals\n', '\tcrowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);\n', '\ttokensSold = tokensSold.add(tokenAmount);\n', '\t\n', '    token.mint(receiver, tokenAmount);\n', '\n', '    if(!multisigWallet.send(weiAmount)) revert();\n', '\t\n', '\t// Tell us invest was success\n', '    Invested(receiver, weiAmount, tokenAmount);\n', '  }\n', ' \n', '  /**\n', '   * Allow load refunds back on the contract for the refunding.\n', '   *\n', '   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n', '   */\n', '  function loadRefund() public payable inState(State.Failure) {\n', '    if(msg.value == 0) revert();\n', '    loadedRefund = loadedRefund.add(msg.value);\n', '  }\n', '  \n', '  /**\n', '   * Investors can claim refund.\n', '   *\n', '   * Note that any refunds from proxy buyers should be handled separately,\n', '   * and not through this contract.\n', '   */\n', '  function refund() public inState(State.Refunding) {\n', '    uint256 weiValue = investedAmountOf[msg.sender];\n', '    if (weiValue == 0) revert();\n', '    investedAmountOf[msg.sender] = 0;\n', '    crowdsale_eth_refund = crowdsale_eth_refund.add(weiValue);\n', '    Refund(msg.sender, weiValue);\n', '    if (!msg.sender.send(weiValue)) revert();\n', '  }\n', '  \n', '  function setEndsAt(uint time) onlyOwner public {\n', '    if(now > time) {\n', '      revert();\n', '    }\n', '\n', '    endsAt = time;\n', '    EndsAtChanged(endsAt);\n', '  }\n', '  \n', '  // should be called after crowdsale ends, to do\n', '  // some extra finalization work\n', '  function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '    \n', '\tif(finalized) {\n', '      revert();\n', '    }\n', '\n', '\tcreateTeamTokenByPercentage();\n', '    token.finishMinting();\t\n', '        \n', '    finalized = true;\n', '\tFinalized();\n', '  }\n', '  \n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']