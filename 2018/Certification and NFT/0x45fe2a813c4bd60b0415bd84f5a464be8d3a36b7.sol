['/* solium-disable-next-line linebreak-style */\n', 'pragma solidity ^0.4.24;\n', '\n', '// Implements a simple ownership model with 2-phase transfer.\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public proposedOwner;\n', '\n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(msg.sender) == true, &#39;Require owner to execute transaction&#39;);\n', '        _;\n', '    }\n', '\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return (_address == owner);\n', '    }\n', '\n', '\n', '    function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool success) {\n', '        require(_proposedOwner != address(0), &#39;Require proposedOwner != address(0)&#39;);\n', '        require(_proposedOwner != address(this), &#39;Require proposedOwner != address(this)&#39;);\n', '        require(_proposedOwner != owner, &#39;Require proposedOwner != owner&#39;);\n', '\n', '        proposedOwner = _proposedOwner;\n', '        return true;\n', '    }\n', '\n', '\n', '    function completeOwnershipTransfer() public returns (bool success) {\n', '        require(msg.sender == proposedOwner, &#39;Require msg.sender == proposedOwner&#39;);\n', '\n', '        owner = msg.sender;\n', '        proposedOwner = address(0);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// OpsManaged - Implements an Owner and Ops Permission Model\n', '// ----------------------------------------------------------------------------\n', 'contract OpsManaged is Owned {\n', '\n', '    address public opsAddress;\n', '\n', '\n', '    constructor() public\n', '        Owned()\n', '    {\n', '    }\n', '\n', '\n', '    modifier onlyOwnerOrOps() {\n', '        require(isOwnerOrOps(msg.sender), &#39;Require only owner or ops&#39;);\n', '        _;\n', '    }\n', '\n', '\n', '    function isOps(address _address) public view returns (bool) {\n', '        return (opsAddress != address(0) && _address == opsAddress);\n', '    }\n', '\n', '\n', '    function isOwnerOrOps(address _address) public view returns (bool) {\n', '        return (isOwner(_address) || isOps(_address));\n', '    }\n', '\n', '\n', '    function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool success) {\n', '        require(_newOpsAddress != owner, &#39;Require newOpsAddress != owner&#39;);\n', '        require(_newOpsAddress != address(this), &#39;Require newOpsAddress != address(this)&#39;);\n', '\n', '        opsAddress = _newOpsAddress;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Finalizable - Implement Finalizable (Crowdsale) model\n', '// ----------------------------------------------------------------------------\n', 'contract Finalizable is OpsManaged {\n', '\n', '    FinalizableState public finalized;\n', '    \n', '    enum FinalizableState { \n', '        None,\n', '        Finalized\n', '    }\n', '\n', '    event Finalized();\n', '\n', '\n', '    constructor() public OpsManaged()\n', '    {\n', '        finalized = FinalizableState.None;\n', '    }\n', '\n', '\n', '    function finalize() public onlyOwner returns (bool success) {\n', '        require(finalized == FinalizableState.None, &#39;Require !finalized&#39;);\n', '\n', '        finalized = FinalizableState.Finalized;\n', '\n', '        emit Finalized();\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Math - Implement Math Library\n', '// ----------------------------------------------------------------------------\n', 'library Math {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 r = a + b;\n', '\n', '        require(r >= a, &#39;Require r >= a&#39;);\n', '\n', '        return r;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(a >= b, &#39;Require a >= b&#39;);\n', '\n', '        return a - b;\n', '    }\n', '\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 r = a * b;\n', '\n', '        require(r / a == b, &#39;Require r / a == b&#39;);\n', '\n', '        return r;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Interface - Standard ERC20 Interface Definition\n', '// Based on the final ERC20 specification at:\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Token - Standard ERC20 Implementation\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Token is ERC20Interface {\n', '\n', '    using Math for uint256;\n', '\n', '    string public  name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokenHolder) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '\n', '        // The initial balance of tokens is assigned to the given token holder address.\n', '        balances[_initialTokenHolder] = _totalSupply;\n', '        allowed[_initialTokenHolder][_initialTokenHolder] = balances[_initialTokenHolder];\n', '\n', '        // Per EIP20, the constructor should fire a Transfer event if tokens are assigned to an account.\n', '        emit Transfer(0x0, _initialTokenHolder, _totalSupply);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) { \n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '\n', '            emit Transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_from] = balances[_from].sub(_value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '\n', '            emit Transfer(_from, _to, _value);\n', '\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// FinalizableToken - Extension to ERC20Token with ops and finalization\n', '// ----------------------------------------------------------------------------\n', '\n', '//\n', '// ERC20 token with the following additions:\n', '//    1. Owner/Ops Ownership\n', '//    2. Finalization\n', '//\n', 'contract FinalizableToken is ERC20Token, OpsManaged, Finalizable {\n', '\n', '    using Math for uint256;\n', '\n', '\n', '    // The constructor will assign the initial token supply to the owner (msg.sender).\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public\n', '        ERC20Token(_name, _symbol, _decimals, _totalSupply, msg.sender)\n', '        Finalizable()\n', '    {\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        validateTransfer(msg.sender, _to);\n', '\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        validateTransfer(msg.sender, _to);\n', '\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    function validateTransfer(address _sender, address _to) internal view {\n', '        // Once the token is finalized, everybody can transfer tokens.\n', '        if (finalized == FinalizableState.Finalized) {\n', '            return;\n', '        }\n', '        \n', '\n', '        if (isOwner(_to)) {\n', '            return;\n', '        }\n', '\n', '        // Before the token is finalized, only owner and ops are allowed to initiate transfers.\n', '        // This allows them to move tokens while the sale is still in private sale.\n', '        require(isOwnerOrOps(_sender), &#39;Require is owner or ops allowed to initiate transfer&#39;);\n', '    }\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// PBTT Token Contract Configuration\n', '// ----------------------------------------------------------------------------\n', 'contract PBTTTokenConfig {\n', '\n', '    string  internal constant TOKEN_SYMBOL      = &#39;PBTT&#39;;\n', '    string  internal constant TOKEN_NAME        = &#39;Purple Butterfly Token (PBTT)&#39;;\n', '    uint8   internal constant TOKEN_DECIMALS    = 3;\n', '\n', '    uint256 internal constant DECIMALSFACTOR    = 10**uint256(TOKEN_DECIMALS);\n', '    uint256 internal constant TOKEN_TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// PBTT Token Contract\n', '// ----------------------------------------------------------------------------\n', 'contract PBTTToken is FinalizableToken, PBTTTokenConfig {\n', '      \n', '    uint256 public buyPriceEth = 0.0002 ether;                              // Buy price for PBTT\n', '    uint256 public sellPriceEth = 0.0001 ether;                             // Sell price for PBTT\n', '    uint256 public gasForPBTT = 0.005 ether;                                // Eth from contract against PBTT to pay tx (10 times sellPriceEth)\n', '    uint256 public PBTTForGas = 1;                                          // PBTT to contract against eth to pay tx\n', '    uint256 public gasReserve = 1 ether;                                    // Eth amount that remains in the contract for gas and can&#39;t be sold\n', '\n', '    // Minimal eth balance of sender and recipient, ensure that no account receiving\n', '    // the token has less than the necessary Ether to pay the fees\n', '    uint256 public minBalanceForAccounts = 0.005 ether;                     \n', '    uint256 public totalTokenSold = 0;\n', '    \n', '    enum HaltState { \n', '        Unhalted,\n', '        Halted        \n', '    }\n', '\n', '    HaltState public halts;\n', '\n', '    constructor() public\n', '        FinalizableToken(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, TOKEN_TOTALSUPPLY)\n', '    {\n', '        halts = HaltState.Unhalted;\n', '        finalized = FinalizableState.None;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        require(halts == HaltState.Unhalted, &#39;Require smart contract is not in halted state&#39;);\n', '\n', '        // Prevents drain and spam\n', '        require(_value >= PBTTForGas, &#39;Token amount is not enough to transfer&#39;); \n', '         \n', '        if (!isOwnerOrOps(msg.sender) && _to == address(this)) {\n', '            // Trade PBTT against eth by sending to the token contract\n', '            sellPBTTAgainstEther(_value);                             \n', '            return true;\n', '        } else {\n', '            if(isOwnerOrOps(msg.sender)) {\n', '                return super.transferFrom(owner, _to, _value);\n', '            }\n', '            return super.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(halts == HaltState.Unhalted, &#39;Require smart contract is not in halted state&#39;);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    //Change PPBT Selling and Buy Price\n', '    function setEtherPrices(uint256 newBuyPriceEth, uint256 newSellPriceEth) public onlyOwnerOrOps {\n', '        // Set prices to buy and sell PBTT\n', '        buyPriceEth = newBuyPriceEth;                                       \n', '        sellPriceEth = newSellPriceEth;\n', '    }\n', '\n', '    function setGasForPBTT(uint256 newGasAmountInWei) public onlyOwnerOrOps {\n', '        gasForPBTT = newGasAmountInWei;\n', '    }\n', '\n', '    //set PBTT to contract against eth to pay tx\n', '    function setPBTTForGas(uint256 newPBTTAmount) public onlyOwnerOrOps {\n', '        PBTTForGas = newPBTTAmount;\n', '    }\n', '\n', '    function setGasReserve(uint256 newGasReserveInWei) public onlyOwnerOrOps {\n', '        gasReserve = newGasReserveInWei;\n', '    }\n', '\n', '    function setMinBalance(uint256 minimumBalanceInWei) public onlyOwnerOrOps {\n', '        minBalanceForAccounts = minimumBalanceInWei;\n', '    }\n', '\n', '    function getTokenRemaining() public view returns (uint256 total){\n', '        return (TOKEN_TOTALSUPPLY.div(DECIMALSFACTOR)).sub(totalTokenSold);\n', '    }\n', '\n', '    /* User buys PBTT and pays in Ether */\n', '    function buyPBTTAgainstEther() private returns (uint256 tokenAmount) {\n', '        // Avoid dividing 0, sending small amounts and spam\n', '        require(buyPriceEth > 0, &#39;buyPriceEth must be > 0&#39;);\n', '        require(msg.value >= buyPriceEth, &#39;Transfer money must be enough for 1 token&#39;);\n', '        \n', '        // Calculate the amount of PBTT\n', '        tokenAmount = (msg.value.mul(DECIMALSFACTOR)).div(buyPriceEth);                \n', '        \n', '        // Check if it has enough to sell\n', '        require(balances[owner] >= tokenAmount, &#39;Not enough token balance&#39;);\n', '        \n', '        // Add the amount to buyer&#39;s balance\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);            \n', '\n', '        // Subtract amount from PBTT balance\n', '        balances[owner] = balances[owner].sub(tokenAmount);\n', '\n', '        // Execute an event reflecting the change\n', '        emit Transfer(owner, msg.sender, tokenAmount);                           \n', '        \n', '        totalTokenSold = totalTokenSold + tokenAmount;\n', '\t\t\n', '        return tokenAmount;\n', '    }\n', '\n', '    function sellPBTTAgainstEther(uint256 amount) private returns (uint256 revenue) {\n', '        // Avoid selling and spam\n', '        require(sellPriceEth > 0, &#39;sellPriceEth must be > 0&#39;);\n', '        \n', '        require(amount >= PBTTForGas, &#39;Sell token amount must be larger than PBTTForGas value&#39;);\n', '\n', '        // Check if the sender has enough to sell\n', '        require(balances[msg.sender] >= amount, &#39;Token balance is not enough to sold&#39;);\n', '        \n', '        require(msg.sender.balance >= minBalanceForAccounts, &#39;Seller balance must be enough to pay the transaction fee&#39;);\n', '        \n', '        // Revenue = eth that will be send to the user\n', '        revenue = (amount.div(DECIMALSFACTOR)).mul(sellPriceEth);                                 \n', '\n', '        // Keep min amount of eth in contract to provide gas for transactions\n', '        uint256 remaining = address(this).balance.sub(revenue);\n', '        require(remaining >= gasReserve, &#39;Remaining contract balance is not enough for reserved&#39;);\n', '\n', '        // Add the token amount to owner balance\n', '        balances[owner] = balances[owner].add(amount);         \n', '        // Subtract the amount from seller&#39;s token balance\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);            \n', '\n', '        // transfer eth\n', '        // &#39;msg.sender.transfer&#39; means the contract sends ether to &#39;msg.sender&#39;\n', '        // It&#39;s important to do this last to avoid recursion attacks\n', '        msg.sender.transfer(revenue);\n', ' \n', '        // Execute an event reflecting on the change\n', '        emit Transfer(msg.sender, owner, amount);                            \n', '        return revenue;   \n', '    }\n', '\n', '    // Allows a token holder to burn tokens. Once burned, tokens are permanently\n', '    // removed from the total supply.\n', '    function burn(uint256 _amount) public returns (bool success) {\n', '        require(_amount > 0, &#39;Token amount to burn must be larger than 0&#39;);\n', '\n', '        address account = msg.sender;\n', '        require(_amount <= balanceOf(account), &#39;You cannot burn token you dont have&#39;);\n', '\n', '        balances[account] = balances[account].sub(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    // Allows the owner to reclaim tokens that are assigned to the token contract itself.\n', '    function reclaimTokens() public onlyOwner returns (bool success) {\n', '\n', '        address account = address(this);\n', '        uint256 amount = balanceOf(account);\n', '\n', '        if (amount == 0) {\n', '            return false;\n', '        }\n', '\n', '        balances[account] = balances[account].sub(amount);\n', '        balances[owner] = balances[owner].add(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Allows the owner to withdraw that are assigned to the token contract itself.\n', '    function withdrawFundToOwner() public onlyOwner {\n', '        // transfer to owner\n', '        uint256 eth = address(this).balance; \n', '        owner.transfer(eth);\n', '    }\n', '\n', '    // Allows the owner to withdraw all fund from contract to owner&#39;s specific adress\n', '    function withdrawFundToAddress(address _ownerOtherAdress) public onlyOwner {\n', '        // transfer to owner\n', '        uint256 eth = address(this).balance; \n', '        _ownerOtherAdress.transfer(eth);\n', '    }\n', '\n', '    /* Halts or unhalts direct trades without the sell/buy functions below */\n', '    function haltsTrades() public onlyOwnerOrOps returns (bool success) {\n', '        halts = HaltState.Halted;\n', '        return true;\n', '    }\n', '\n', '    function unhaltsTrades() public onlyOwnerOrOps returns (bool success) {\n', '        halts = HaltState.Unhalted;\n', '        return true;\n', '    }\n', '\n', '    function() public payable { \n', '        if(msg.sender != owner) {\n', '            require(finalized == FinalizableState.Finalized, &#39;Require smart contract is finalized&#39;);\n', '            require(halts == HaltState.Unhalted, &#39;Require smart contract is not halted&#39;);\n', '            \n', '            buyPBTTAgainstEther(); \n', '        }\n', '    } \n', '\n', '}']
['/* solium-disable-next-line linebreak-style */\n', 'pragma solidity ^0.4.24;\n', '\n', '// Implements a simple ownership model with 2-phase transfer.\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public proposedOwner;\n', '\n', '    constructor() public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', "        require(isOwner(msg.sender) == true, 'Require owner to execute transaction');\n", '        _;\n', '    }\n', '\n', '\n', '    function isOwner(address _address) public view returns (bool) {\n', '        return (_address == owner);\n', '    }\n', '\n', '\n', '    function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool success) {\n', "        require(_proposedOwner != address(0), 'Require proposedOwner != address(0)');\n", "        require(_proposedOwner != address(this), 'Require proposedOwner != address(this)');\n", "        require(_proposedOwner != owner, 'Require proposedOwner != owner');\n", '\n', '        proposedOwner = _proposedOwner;\n', '        return true;\n', '    }\n', '\n', '\n', '    function completeOwnershipTransfer() public returns (bool success) {\n', "        require(msg.sender == proposedOwner, 'Require msg.sender == proposedOwner');\n", '\n', '        owner = msg.sender;\n', '        proposedOwner = address(0);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// OpsManaged - Implements an Owner and Ops Permission Model\n', '// ----------------------------------------------------------------------------\n', 'contract OpsManaged is Owned {\n', '\n', '    address public opsAddress;\n', '\n', '\n', '    constructor() public\n', '        Owned()\n', '    {\n', '    }\n', '\n', '\n', '    modifier onlyOwnerOrOps() {\n', "        require(isOwnerOrOps(msg.sender), 'Require only owner or ops');\n", '        _;\n', '    }\n', '\n', '\n', '    function isOps(address _address) public view returns (bool) {\n', '        return (opsAddress != address(0) && _address == opsAddress);\n', '    }\n', '\n', '\n', '    function isOwnerOrOps(address _address) public view returns (bool) {\n', '        return (isOwner(_address) || isOps(_address));\n', '    }\n', '\n', '\n', '    function setOpsAddress(address _newOpsAddress) public onlyOwner returns (bool success) {\n', "        require(_newOpsAddress != owner, 'Require newOpsAddress != owner');\n", "        require(_newOpsAddress != address(this), 'Require newOpsAddress != address(this)');\n", '\n', '        opsAddress = _newOpsAddress;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Finalizable - Implement Finalizable (Crowdsale) model\n', '// ----------------------------------------------------------------------------\n', 'contract Finalizable is OpsManaged {\n', '\n', '    FinalizableState public finalized;\n', '    \n', '    enum FinalizableState { \n', '        None,\n', '        Finalized\n', '    }\n', '\n', '    event Finalized();\n', '\n', '\n', '    constructor() public OpsManaged()\n', '    {\n', '        finalized = FinalizableState.None;\n', '    }\n', '\n', '\n', '    function finalize() public onlyOwner returns (bool success) {\n', "        require(finalized == FinalizableState.None, 'Require !finalized');\n", '\n', '        finalized = FinalizableState.Finalized;\n', '\n', '        emit Finalized();\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Math - Implement Math Library\n', '// ----------------------------------------------------------------------------\n', 'library Math {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 r = a + b;\n', '\n', "        require(r >= a, 'Require r >= a');\n", '\n', '        return r;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(a >= b, 'Require a >= b');\n", '\n', '        return a - b;\n', '    }\n', '\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 r = a * b;\n', '\n', "        require(r / a == b, 'Require r / a == b');\n", '\n', '        return r;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Interface - Standard ERC20 Interface Definition\n', '// Based on the final ERC20 specification at:\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20Token - Standard ERC20 Implementation\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Token is ERC20Interface {\n', '\n', '    using Math for uint256;\n', '\n', '    string public  name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, address _initialTokenHolder) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '\n', '        // The initial balance of tokens is assigned to the given token holder address.\n', '        balances[_initialTokenHolder] = _totalSupply;\n', '        allowed[_initialTokenHolder][_initialTokenHolder] = balances[_initialTokenHolder];\n', '\n', '        // Per EIP20, the constructor should fire a Transfer event if tokens are assigned to an account.\n', '        emit Transfer(0x0, _initialTokenHolder, _totalSupply);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) { \n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '\n', '            emit Transfer(msg.sender, _to, _value);\n', '\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_from] = balances[_from].sub(_value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '\n', '            emit Transfer(_from, _to, _value);\n', '\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// FinalizableToken - Extension to ERC20Token with ops and finalization\n', '// ----------------------------------------------------------------------------\n', '\n', '//\n', '// ERC20 token with the following additions:\n', '//    1. Owner/Ops Ownership\n', '//    2. Finalization\n', '//\n', 'contract FinalizableToken is ERC20Token, OpsManaged, Finalizable {\n', '\n', '    using Math for uint256;\n', '\n', '\n', '    // The constructor will assign the initial token supply to the owner (msg.sender).\n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public\n', '        ERC20Token(_name, _symbol, _decimals, _totalSupply, msg.sender)\n', '        Finalizable()\n', '    {\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        validateTransfer(msg.sender, _to);\n', '\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        validateTransfer(msg.sender, _to);\n', '\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    function validateTransfer(address _sender, address _to) internal view {\n', '        // Once the token is finalized, everybody can transfer tokens.\n', '        if (finalized == FinalizableState.Finalized) {\n', '            return;\n', '        }\n', '        \n', '\n', '        if (isOwner(_to)) {\n', '            return;\n', '        }\n', '\n', '        // Before the token is finalized, only owner and ops are allowed to initiate transfers.\n', '        // This allows them to move tokens while the sale is still in private sale.\n', "        require(isOwnerOrOps(_sender), 'Require is owner or ops allowed to initiate transfer');\n", '    }\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// PBTT Token Contract Configuration\n', '// ----------------------------------------------------------------------------\n', 'contract PBTTTokenConfig {\n', '\n', "    string  internal constant TOKEN_SYMBOL      = 'PBTT';\n", "    string  internal constant TOKEN_NAME        = 'Purple Butterfly Token (PBTT)';\n", '    uint8   internal constant TOKEN_DECIMALS    = 3;\n', '\n', '    uint256 internal constant DECIMALSFACTOR    = 10**uint256(TOKEN_DECIMALS);\n', '    uint256 internal constant TOKEN_TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// PBTT Token Contract\n', '// ----------------------------------------------------------------------------\n', 'contract PBTTToken is FinalizableToken, PBTTTokenConfig {\n', '      \n', '    uint256 public buyPriceEth = 0.0002 ether;                              // Buy price for PBTT\n', '    uint256 public sellPriceEth = 0.0001 ether;                             // Sell price for PBTT\n', '    uint256 public gasForPBTT = 0.005 ether;                                // Eth from contract against PBTT to pay tx (10 times sellPriceEth)\n', '    uint256 public PBTTForGas = 1;                                          // PBTT to contract against eth to pay tx\n', "    uint256 public gasReserve = 1 ether;                                    // Eth amount that remains in the contract for gas and can't be sold\n", '\n', '    // Minimal eth balance of sender and recipient, ensure that no account receiving\n', '    // the token has less than the necessary Ether to pay the fees\n', '    uint256 public minBalanceForAccounts = 0.005 ether;                     \n', '    uint256 public totalTokenSold = 0;\n', '    \n', '    enum HaltState { \n', '        Unhalted,\n', '        Halted        \n', '    }\n', '\n', '    HaltState public halts;\n', '\n', '    constructor() public\n', '        FinalizableToken(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, TOKEN_TOTALSUPPLY)\n', '    {\n', '        halts = HaltState.Unhalted;\n', '        finalized = FinalizableState.None;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', "        require(halts == HaltState.Unhalted, 'Require smart contract is not in halted state');\n", '\n', '        // Prevents drain and spam\n', "        require(_value >= PBTTForGas, 'Token amount is not enough to transfer'); \n", '         \n', '        if (!isOwnerOrOps(msg.sender) && _to == address(this)) {\n', '            // Trade PBTT against eth by sending to the token contract\n', '            sellPBTTAgainstEther(_value);                             \n', '            return true;\n', '        } else {\n', '            if(isOwnerOrOps(msg.sender)) {\n', '                return super.transferFrom(owner, _to, _value);\n', '            }\n', '            return super.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', "        require(halts == HaltState.Unhalted, 'Require smart contract is not in halted state');\n", '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    //Change PPBT Selling and Buy Price\n', '    function setEtherPrices(uint256 newBuyPriceEth, uint256 newSellPriceEth) public onlyOwnerOrOps {\n', '        // Set prices to buy and sell PBTT\n', '        buyPriceEth = newBuyPriceEth;                                       \n', '        sellPriceEth = newSellPriceEth;\n', '    }\n', '\n', '    function setGasForPBTT(uint256 newGasAmountInWei) public onlyOwnerOrOps {\n', '        gasForPBTT = newGasAmountInWei;\n', '    }\n', '\n', '    //set PBTT to contract against eth to pay tx\n', '    function setPBTTForGas(uint256 newPBTTAmount) public onlyOwnerOrOps {\n', '        PBTTForGas = newPBTTAmount;\n', '    }\n', '\n', '    function setGasReserve(uint256 newGasReserveInWei) public onlyOwnerOrOps {\n', '        gasReserve = newGasReserveInWei;\n', '    }\n', '\n', '    function setMinBalance(uint256 minimumBalanceInWei) public onlyOwnerOrOps {\n', '        minBalanceForAccounts = minimumBalanceInWei;\n', '    }\n', '\n', '    function getTokenRemaining() public view returns (uint256 total){\n', '        return (TOKEN_TOTALSUPPLY.div(DECIMALSFACTOR)).sub(totalTokenSold);\n', '    }\n', '\n', '    /* User buys PBTT and pays in Ether */\n', '    function buyPBTTAgainstEther() private returns (uint256 tokenAmount) {\n', '        // Avoid dividing 0, sending small amounts and spam\n', "        require(buyPriceEth > 0, 'buyPriceEth must be > 0');\n", "        require(msg.value >= buyPriceEth, 'Transfer money must be enough for 1 token');\n", '        \n', '        // Calculate the amount of PBTT\n', '        tokenAmount = (msg.value.mul(DECIMALSFACTOR)).div(buyPriceEth);                \n', '        \n', '        // Check if it has enough to sell\n', "        require(balances[owner] >= tokenAmount, 'Not enough token balance');\n", '        \n', "        // Add the amount to buyer's balance\n", '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);            \n', '\n', '        // Subtract amount from PBTT balance\n', '        balances[owner] = balances[owner].sub(tokenAmount);\n', '\n', '        // Execute an event reflecting the change\n', '        emit Transfer(owner, msg.sender, tokenAmount);                           \n', '        \n', '        totalTokenSold = totalTokenSold + tokenAmount;\n', '\t\t\n', '        return tokenAmount;\n', '    }\n', '\n', '    function sellPBTTAgainstEther(uint256 amount) private returns (uint256 revenue) {\n', '        // Avoid selling and spam\n', "        require(sellPriceEth > 0, 'sellPriceEth must be > 0');\n", '        \n', "        require(amount >= PBTTForGas, 'Sell token amount must be larger than PBTTForGas value');\n", '\n', '        // Check if the sender has enough to sell\n', "        require(balances[msg.sender] >= amount, 'Token balance is not enough to sold');\n", '        \n', "        require(msg.sender.balance >= minBalanceForAccounts, 'Seller balance must be enough to pay the transaction fee');\n", '        \n', '        // Revenue = eth that will be send to the user\n', '        revenue = (amount.div(DECIMALSFACTOR)).mul(sellPriceEth);                                 \n', '\n', '        // Keep min amount of eth in contract to provide gas for transactions\n', '        uint256 remaining = address(this).balance.sub(revenue);\n', "        require(remaining >= gasReserve, 'Remaining contract balance is not enough for reserved');\n", '\n', '        // Add the token amount to owner balance\n', '        balances[owner] = balances[owner].add(amount);         \n', "        // Subtract the amount from seller's token balance\n", '        balances[msg.sender] = balances[msg.sender].sub(amount);            \n', '\n', '        // transfer eth\n', "        // 'msg.sender.transfer' means the contract sends ether to 'msg.sender'\n", "        // It's important to do this last to avoid recursion attacks\n", '        msg.sender.transfer(revenue);\n', ' \n', '        // Execute an event reflecting on the change\n', '        emit Transfer(msg.sender, owner, amount);                            \n', '        return revenue;   \n', '    }\n', '\n', '    // Allows a token holder to burn tokens. Once burned, tokens are permanently\n', '    // removed from the total supply.\n', '    function burn(uint256 _amount) public returns (bool success) {\n', "        require(_amount > 0, 'Token amount to burn must be larger than 0');\n", '\n', '        address account = msg.sender;\n', "        require(_amount <= balanceOf(account), 'You cannot burn token you dont have');\n", '\n', '        balances[account] = balances[account].sub(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        return true;\n', '    }\n', '\n', '    // Allows the owner to reclaim tokens that are assigned to the token contract itself.\n', '    function reclaimTokens() public onlyOwner returns (bool success) {\n', '\n', '        address account = address(this);\n', '        uint256 amount = balanceOf(account);\n', '\n', '        if (amount == 0) {\n', '            return false;\n', '        }\n', '\n', '        balances[account] = balances[account].sub(amount);\n', '        balances[owner] = balances[owner].add(amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    // Allows the owner to withdraw that are assigned to the token contract itself.\n', '    function withdrawFundToOwner() public onlyOwner {\n', '        // transfer to owner\n', '        uint256 eth = address(this).balance; \n', '        owner.transfer(eth);\n', '    }\n', '\n', "    // Allows the owner to withdraw all fund from contract to owner's specific adress\n", '    function withdrawFundToAddress(address _ownerOtherAdress) public onlyOwner {\n', '        // transfer to owner\n', '        uint256 eth = address(this).balance; \n', '        _ownerOtherAdress.transfer(eth);\n', '    }\n', '\n', '    /* Halts or unhalts direct trades without the sell/buy functions below */\n', '    function haltsTrades() public onlyOwnerOrOps returns (bool success) {\n', '        halts = HaltState.Halted;\n', '        return true;\n', '    }\n', '\n', '    function unhaltsTrades() public onlyOwnerOrOps returns (bool success) {\n', '        halts = HaltState.Unhalted;\n', '        return true;\n', '    }\n', '\n', '    function() public payable { \n', '        if(msg.sender != owner) {\n', "            require(finalized == FinalizableState.Finalized, 'Require smart contract is finalized');\n", "            require(halts == HaltState.Unhalted, 'Require smart contract is not halted');\n", '            \n', '            buyPBTTAgainstEther(); \n', '        }\n', '    } \n', '\n', '}']
