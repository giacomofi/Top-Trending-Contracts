['pragma solidity ^0.4.24;\n', '\n', '// File: C:\\Users\\James\\simpletoken\\node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: C:\\Users\\James\\simpletoken\\node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: C:\\Users\\James\\simpletoken\\node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: C:\\Users\\James\\simpletoken\\node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', '\n', '  \n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '\n', '// File: ethberlin-master\\contracts\\math\\Power.sol\n', '\n', '/**\n', ' * bancor formula by bancor\n', ' * https://github.com/bancorprotocol/contracts\n', ' * Modified from the original by Slava Balasanov\n', ' * Split Power.sol out from BancorFormula.sol\n', ' * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements;\n', ' * and to You under the Apache License, Version 2.0. "\n', ' */\n', 'contract Power {\n', '  string public version = "0.3";\n', '\n', '  uint256 private constant ONE = 1;\n', '  uint32 private constant MAX_WEIGHT = 1000000;\n', '  uint8 private constant MIN_PRECISION = 32;\n', '  uint8 private constant MAX_PRECISION = 127;\n', '\n', '  /**\n', '    The values below depend on MAX_PRECISION. If you choose to change it:\n', "    Apply the same change in file 'PrintIntScalingFactors.py', run it and paste the results below.\n", '  */\n', '  uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\n', '  uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\n', '  uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\n', '\n', '  /**\n', '    The values below depend on MAX_PRECISION. If you choose to change it:\n', "    Apply the same change in file 'PrintLn2ScalingFactors.py', run it and paste the results below.\n", '  */\n', '  uint256 private constant LN2_MANTISSA = 0x2c5c85fdf473de6af278ece600fcbda;\n', '  uint8   private constant LN2_EXPONENT = 122;\n', '\n', '  /**\n', '    The values below depend on MIN_PRECISION and MAX_PRECISION. If you choose to change either one of them:\n', "    Apply the same change in file 'PrintFunctionBancorFormula.py', run it and paste the results below.\n", '  */\n', '  uint256[128] private maxExpArray;\n', '\n', '  constructor() public {\n', '//  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\n', '//  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\n', '//  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\n', '//  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\n', '//  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\n', '//  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\n', '//  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\n', '//  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\n', '//  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\n', '//  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\n', '//  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\n', '//  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\n', '//  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\n', '//  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\n', '//  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\n', '//  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\n', '//  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\n', '    maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\n', '    maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\n', '    maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\n', '    maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\n', '    maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\n', '    maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\n', '    maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\n', '    maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\n', '    maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\n', '    maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\n', '    maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\n', '    maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\n', '    maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\n', '    maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\n', '    maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\n', '    maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\n', '    maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\n', '    maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\n', '    maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\n', '    maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\n', '    maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\n', '    maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\n', '    maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\n', '    maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\n', '    maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\n', '    maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\n', '    maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\n', '    maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\n', '    maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\n', '    maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\n', '    maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\n', '    maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\n', '    maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\n', '    maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\n', '    maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\n', '    maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\n', '    maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\n', '    maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\n', '    maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\n', '    maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\n', '    maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\n', '    maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\n', '    maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\n', '    maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\n', '    maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\n', '    maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\n', '    maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\n', '    maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\n', '    maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\n', '    maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\n', '    maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\n', '    maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\n', '    maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\n', '    maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\n', '    maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\n', '    maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\n', '    maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\n', '    maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\n', '    maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\n', '    maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\n', '    maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\n', '    maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\n', '    maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\n', '    maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\n', '    maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\n', '    maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\n', '    maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\n', '    maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\n', '    maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\n', '    maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\n', '    maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\n', '    maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\n', '    maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\n', '    maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\n', '    maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\n', '    maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\n', '    maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\n', '    maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\n', '    maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\n', '    maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\n', '    maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\n', '    maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\n', '    maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\n', '    maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\n', '    maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\n', '    maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\n', '    maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\n', '    maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\n', '    maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\n', '    maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\n', '    maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\n', '    maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\n', '    maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\n', '    maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\n', '    maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\n', '    maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\n', '  }\n', '\n', '\n', '  /**\n', '    General Description:\n', '        Determine a value of precision.\n', '        Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\n', '        Return the result along with the precision used.\n', '\n', '    Detailed Description:\n', '        Instead of calculating "base ^ exp", we calculate "e ^ (ln(base) * exp)".\n', '        The value of "ln(base)" is represented with an integer slightly smaller than "ln(base) * 2 ^ precision".\n', '        The larger "precision" is, the more accurately this value represents the real value.\n', '        However, the larger "precision" is, the more bits are required in order to store this value.\n', '        And the exponentiation function, which takes "x" and calculates "e ^ x", is limited to a maximum exponent (maximum value of "x").\n', '        This maximum exponent depends on the "precision" used, and it is given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".\n', '        Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\n', '        This allows us to compute "base ^ exp" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\n', '*/\n', '  function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal constant returns (uint256, uint8) {\n', '    uint256 lnBaseTimesExp = ln(_baseN, _baseD) * _expN / _expD;\n', '    uint8 precision = findPositionInMaxExpArray(lnBaseTimesExp);\n', '    return (fixedExp(lnBaseTimesExp >> (MAX_PRECISION - precision), precision), precision);\n', '  }\n', '\n', '  /**\n', '    Return floor(ln(numerator / denominator) * 2 ^ MAX_PRECISION), where:\n', '    - The numerator   is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    - The denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\n', '    - The output      is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\n', '    This functions assumes that the numerator is larger than or equal to the denominator, because the output would be negative otherwise.\n', '  */\n', '  function ln(uint256 _numerator, uint256 _denominator) internal constant returns (uint256) {\n', '    assert(_numerator <= MAX_NUM);\n', '\n', '    uint256 res = 0;\n', '    uint256 x = _numerator * FIXED_1 / _denominator;\n', '\n', '    // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\n', '    if (x >= FIXED_2) {\n', '      uint8 count = floorLog2(x / FIXED_1);\n', '      x >>= count; // now x < 2\n', '      res = count * FIXED_1;\n', '    }\n', '\n', '    // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\n', '    if (x > FIXED_1) {\n', '      for (uint8 i = MAX_PRECISION; i > 0; --i) {\n', '        x = (x * x) / FIXED_1; // now 1 < x < 4\n', '        if (x >= FIXED_2) {\n', '          x >>= 1; // now 1 < x < 2\n', '          res += ONE << (i - 1);\n', '        }\n', '      }\n', '    }\n', '\n', '    return (res * LN2_MANTISSA) >> LN2_EXPONENT;\n', '  }\n', '\n', '  /**\n', '    Compute the largest integer smaller than or equal to the binary logarithm of the input.\n', '  */\n', '  function floorLog2(uint256 _n) internal constant returns (uint8) {\n', '    uint8 res = 0;\n', '    uint256 n = _n;\n', '\n', '    if (n < 256) {\n', '      // At most 8 iterations\n', '      while (n > 1) {\n', '        n >>= 1;\n', '        res += 1;\n', '      }\n', '    } else {\n', '      // Exactly 8 iterations\n', '      for (uint8 s = 128; s > 0; s >>= 1) {\n', '        if (n >= (ONE << s)) {\n', '          n >>= s;\n', '          res |= s;\n', '        }\n', '      }\n', '    }\n', '\n', '    return res;\n', '  }\n', '\n', '  /**\n', '      The global "maxExpArray" is sorted in descending order, and therefore the following statements are equivalent:\n', '      - This function finds the position of [the smallest value in "maxExpArray" larger than or equal to "x"]\n', '      - This function finds the highest position of [a value in "maxExpArray" larger than or equal to "x"]\n', '  */\n', '  function findPositionInMaxExpArray(uint256 _x) internal constant returns (uint8) {\n', '    uint8 lo = MIN_PRECISION;\n', '    uint8 hi = MAX_PRECISION;\n', '\n', '    while (lo + 1 < hi) {\n', '      uint8 mid = (lo + hi) / 2;\n', '      if (maxExpArray[mid] >= _x)\n', '        lo = mid;\n', '      else\n', '        hi = mid;\n', '    }\n', '\n', '    if (maxExpArray[hi] >= _x)\n', '        return hi;\n', '    if (maxExpArray[lo] >= _x)\n', '        return lo;\n', '\n', '    assert(false);\n', '    return 0;\n', '  }\n', '\n', '  /**\n', "      This function can be auto-generated by the script 'PrintFunctionFixedExp.py'.\n", '      It approximates "e ^ x" via maclaurin summation: "(x^0)/0! + (x^1)/1! + ... + (x^n)/n!".\n', '      It returns "e ^ (x / 2 ^ precision) * 2 ^ precision", that is, the result is upshifted for accuracy.\n', '      The global "maxExpArray" maps each "precision" to "((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1".\n', '      The maximum permitted value for "x" is therefore given by "maxExpArray[precision] >> (MAX_PRECISION - precision)".\n', '  */\n', '  function fixedExp(uint256 _x, uint8 _precision) internal constant returns (uint256) {\n', '    uint256 xi = _x;\n', '    uint256 res = 0;\n', '\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x03442c4e6074a82f1797f72ac0000000; // add x^2 * (33! / 2!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0116b96f757c380fb287fd0e40000000; // add x^3 * (33! / 3!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0045ae5bdd5f0e03eca1ff4390000000; // add x^4 * (33! / 4!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000defabf91302cd95b9ffda50000000; // add x^5 * (33! / 5!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0002529ca9832b22439efff9b8000000; // add x^6 * (33! / 6!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000054f1cf12bd04e516b6da88000000; // add x^7 * (33! / 7!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000a9e39e257a09ca2d6db51000000; // add x^8 * (33! / 8!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000012e066e7b839fa050c309000000; // add x^9 * (33! / 9!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000052b6b54569976310000; // add x^17 * (33! / 17!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000004985f67696bf748000; // add x^18 * (33! / 18!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000001317c70077000; // add x^23 * (33! / 23!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000000000000082573a0a00; // add x^25 * (33! / 25!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000000000000005035ad900; // add x^26 * (33! / 26!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x0000000000000000000000002f881b00; // add x^27 * (33! / 27!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000000000001b29340; // add x^28 * (33! / 28!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x000000000000000000000000000efc40; // add x^29 * (33! / 29!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000000000000007fe0; // add x^30 * (33! / 30!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000000000000000420; // add x^31 * (33! / 31!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000000000000000021; // add x^32 * (33! / 32!)\n', '    xi = (xi * _x) >> _precision;\n', '    res += xi * 0x00000000000000000000000000000001; // add x^33 * (33! / 33!)\n', '\n', '    return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\n', '  }\n', '}\n', '\n', '// File: ethberlin-master\\contracts\\tokens\\BancorFormula.sol\n', '\n', '/**\n', ' * Bancor formula by Bancor\n', ' * https://github.com/bancorprotocol/contracts\n', ' * Modified from the original by Slava Balasanov\n', " * Split Power.sol out from BancorFormula.sol and replace SafeMath formulas with zeppelin's SafeMath\n", ' * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements;\n', ' * and to You under the Apache License, Version 2.0. "\n', ' */\n', 'contract BancorFormula is Power {\n', '  using SafeMath for uint256;\n', '\n', '  string public version = "0.3";\n', '  uint32 private constant MAX_WEIGHT = 1000000;\n', '\n', '  /**\n', '    @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\n', '    calculates the return for a given conversion (in the main token)\n', '\n', '    Formula:\n', '    Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\n', '\n', '    @param _supply              token total supply\n', '    @param _connectorBalance    total connector balance\n', '    @param _connectorWeight     connector weight, represented in ppm, 1-1000000\n', '    @param _depositAmount       deposit amount, in connector token\n', '\n', '    @return purchase return amount\n', '  */\n', '  function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public constant returns (uint256) {\n', '    // validate input\n', '    require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\n', '\n', '    // special case for 0 deposit amount\n', '    if (_depositAmount == 0)\n', '      return 0;\n', '\n', '    // special case if the weight = 100%\n', '    if (_connectorWeight == MAX_WEIGHT)\n', '      return _supply.mul(_depositAmount).div(_connectorBalance);\n', '\n', '    uint256 result;\n', '    uint8 precision;\n', '    uint256 baseN = _depositAmount.add(_connectorBalance);\n', '    (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\n', '    uint256 temp = _supply.mul(result) >> precision;\n', '    return temp - _supply;\n', '  }\n', '\n', '  /**\n', '    @dev given a token supply, connector balance, weight and a sell amount (in the main token),\n', '    calculates the return for a given conversion (in the connector token)\n', '\n', '    Formula:\n', '    Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\n', '\n', '    @param _supply              token total supply\n', '    @param _connectorBalance    total connector\n', '    @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\n', '    @param _sellAmount          sell amount, in the token itself\n', '\n', '    @return sale return amount\n', '  */\n', '  function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public constant returns (uint256) {\n', '    // validate input\n', '    require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\n', '\n', '    // special case for 0 sell amount\n', '    if (_sellAmount == 0)\n', '      return 0;\n', '\n', '    // special case for selling the entire supply\n', '    if (_sellAmount == _supply)\n', '      return _connectorBalance;\n', '\n', '    // special case if the weight = 100%\n', '    if (_connectorWeight == MAX_WEIGHT)\n', '      return _connectorBalance.mul(_sellAmount).div(_supply);\n', '\n', '    uint256 result;\n', '    uint8 precision;\n', '    uint256 baseD = _supply - _sellAmount;\n', '    (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\n', '    uint256 temp1 = _connectorBalance.mul(result);\n', '    uint256 temp2 = _connectorBalance << precision;\n', '    return temp1.sub(temp2).div(result);\n', '  }\n', '}\n', '\n', '// File: ethberlin-master\\contracts\\tokens\\EthBondingCurve.sol\n', '\n', '/**\n', ' * @title Bonding Curve\n', ' * @dev Bonding curve contract based on Bacor formula\n', ' * inspired by bancor protocol and simondlr\n', ' * https://github.com/bancorprotocol/contracts\n', ' * https://github.com/ConsenSys/curationmarkets/blob/master/CurationMarkets.sol\n', ' */\n', 'contract EthBondingCurve is StandardToken, BancorFormula, Ownable {\n', '  uint256 public poolBalance;\n', '\n', '  /*\n', '    reserve ratio, represented in ppm, 1-1000000\n', '    1/3 corresponds to y= multiple * x^2\n', '    1/2 corresponds to y= multiple * x\n', '    2/3 corresponds to y= multiple * x^1/2\n', '    multiple will depends on contract initialization,\n', '    specificallytotalAmount and poolBalance parameters\n', "    we might want to add an 'initialize' function that will allow\n", '    the owner to send ether to the contract and mint a given amount of tokens\n', '  */\n', '  uint32 public reserveRatio;\n', '\n', '  /*\n', '    - Front-running attacks are currently mitigated by the following mechanisms:\n', '    TODO - minimum return argument for each conversion provides a way to define a minimum/maximum price for the transaction\n', '    - gas price limit prevents users from having control over the order of execution\n', '  */\n', '  uint256 public gasPrice = 0 wei; // maximum gas price for bancor transactions\n', '\n', '  /**\n', '   * @dev default function\n', '   * gas ~ 91645\n', '   */\n', '  function() public payable {\n', '    buy();\n', '  }\n', '\n', '  /**\n', '   * @dev Buy tokens\n', '   * gas ~ 77825\n', '   * TODO implement maxAmount that helps prevent miner front-running\n', '   */\n', '  function buy() validGasPrice onlyOwner public payable returns(bool) {\n', '    require(msg.value > 0);\n', '    uint256 tokensToMint = calculatePurchaseReturn(totalSupply_, poolBalance, reserveRatio, msg.value);\n', '    totalSupply_ = totalSupply_.add(tokensToMint);\n', '    balances[msg.sender] = balances[msg.sender].add(tokensToMint);\n', '    poolBalance = poolBalance.add(msg.value);\n', '    emit LogMint(msg.sender, tokensToMint, msg.value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Sell tokens\n', '   * gas ~ 86936\n', '   * @param sellAmount Amount of tokens to withdraw\n', '   * TODO implement maxAmount that helps prevent miner front-running\n', '   */\n', '  function sell(uint256 sellAmount) validGasPrice public returns(bool) {\n', '    require(sellAmount > 0 && balances[msg.sender] >= sellAmount);\n', '    uint256 ethAmount = calculateSaleReturn(totalSupply_, poolBalance, reserveRatio, sellAmount);\n', '    msg.sender.transfer(ethAmount);\n', '    poolBalance = poolBalance.sub(ethAmount);\n', '    balances[msg.sender] = balances[msg.sender].sub(sellAmount);\n', '    totalSupply_ = totalSupply_.sub(sellAmount);\n', '    emit LogWithdraw(msg.sender, sellAmount, ethAmount);\n', '    return true;\n', '  }\n', '\n', '  // verifies that the gas price is lower than the universal limit\n', '  modifier validGasPrice() {\n', '    assert(tx.gasprice <= gasPrice);\n', '    _;\n', '  }\n', '\n', '  /**\n', '    @dev Allows the owner to update the gas price limit\n', '    @param _gasPrice The new gas price limit\n', '  */\n', '  function setGasPrice(uint256 _gasPrice) onlyOwner public {\n', '    require(_gasPrice > 0);\n', '    gasPrice = _gasPrice;\n', '  }\n', '\n', '  event LogMint(address sender, uint256 amountMinted, uint256 totalCost);\n', '  event LogWithdraw(address sender, uint256 amountWithdrawn, uint256 reward);\n', '  event LogBondingCurve(address sender, string logString, uint256 value);\n', '}\n', '\n', '// File: ethberlin-master\\contracts\\tokens\\SoulToken.sol\n', '\n', 'contract TrojanCoin is EthBondingCurve {\n', '  string public constant name = "Trojan";\n', '  string public constant symbol = "TROJ";\n', '  uint8 public constant decimals = 18;\n', '\n', '  uint256 public constant INITIAL_SUPPLY = 2000000 * (10 ** 18);\n', '  uint256 public constant INITIAL_PRICE = 5 * (10 ** 13);\n', '  uint32 public constant CURVE_RATIO = 500000;\n', '  uint256 public constant INITAL_BALANCE = CURVE_RATIO * INITIAL_SUPPLY * INITIAL_PRICE / (1000000 * 10 ** 18);\n', '\n', '  constructor() public {\n', '    reserveRatio = CURVE_RATIO;\n', '    totalSupply_ = INITIAL_SUPPLY;\n', '    poolBalance = INITAL_BALANCE;\n', '    gasPrice = 26 * (10 ** 9);\n', '  }\n', '}']