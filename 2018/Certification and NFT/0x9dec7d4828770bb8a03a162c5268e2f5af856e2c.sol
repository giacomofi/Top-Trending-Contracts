['contract AirSwap {\n', '    function fill(\n', '      address makerAddress,\n', '      uint makerAmount,\n', '      address makerToken,\n', '      address takerAddress,\n', '      uint takerAmount,\n', '      address takerToken,\n', '      uint256 expiration,\n', '      uint256 nonce,\n', '      uint8 v,\n', '      bytes32 r,\n', '      bytes32 s\n', '    ) payable {}\n', '}\n', '\n', 'contract P3D {\n', '  uint256 public stakingRequirement;\n', '  function buy(address _referredBy) public payable returns(uint256) {}\n', '  function balanceOf(address _customerAddress) view public returns(uint256) {}\n', '  function exit() public {}\n', '  function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\n', '  function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) { }\n', '  function myDividends(bool _includeReferralBonus) public view returns(uint256) {}\n', '  function withdraw() public {}\n', '  function totalSupply() public view returns(uint256);\n', '}\n', '\n', 'contract Pool {\n', '  P3D constant public p3d = P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '\n', '  address public owner;\n', '  uint256 public minimum;\n', '\n', '  event Contribution(address indexed caller, address indexed receiver, uint256 contribution, uint256 payout);\n', '  event Approved(address addr);\n', '  event Removed(address addr);\n', '  event OwnerChanged(address owner);\n', '  event MinimumChanged(uint256 minimum);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function() external payable {\n', '    // accept donations\n', '    if (msg.sender != address(p3d)) {\n', '      p3d.buy.value(msg.value)(msg.sender);\n', '      emit Contribution(msg.sender, address(0), msg.value, 0);\n', '    }\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  mapping (address => bool) public approved;\n', '\n', '  function approve(address _addr) external onlyOwner() {\n', '    approved[_addr] = true;\n', '    emit Approved(_addr);\n', '  }\n', '\n', '  function remove(address _addr) external onlyOwner() {\n', '    approved[_addr] = false;\n', '    emit Removed(_addr);\n', '  }\n', '\n', '  function changeOwner(address _newOwner) external onlyOwner() {\n', '    owner = _newOwner;\n', '    emit OwnerChanged(owner);\n', '  }\n', '  \n', '  function changeMinimum(uint256 _minimum) external onlyOwner() {\n', '    minimum = _minimum;\n', '    emit MinimumChanged(minimum);\n', '  }\n', '\n', '  function contribute(address _masternode, address _receiver) external payable {\n', '    // buy p3d\n', '    p3d.buy.value(msg.value)(_masternode);\n', '    \n', '    uint256 payout;\n', '    \n', '    // caller must be approved and value must meet the minimum\n', '    if (approved[msg.sender] && msg.value >= minimum) {\n', '      payout = p3d.myDividends(true);\n', '      if (payout != 0) {\n', '        p3d.withdraw();\n', '        // send divs to receiver\n', '        _receiver.transfer(payout);\n', '      }\n', '    }\n', '    \n', '    emit Contribution(msg.sender, _receiver, msg.value, payout);\n', '  }\n', '\n', '  function getInfo() external view returns (uint256, uint256) {\n', '    return (\n', '      p3d.balanceOf(address(this)),\n', '      p3d.myDividends(true)\n', '    );\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '}\n', '\n', 'contract Weth {\n', '  function deposit() public payable {}\n', '  function withdraw(uint wad) public {}\n', '  function approve(address guy, uint wad) public returns (bool) {}\n', '}\n', '\n', 'contract Dex {\n', '  using SafeMath for uint256;\n', '\n', '  AirSwap constant airswap = AirSwap(0x8fd3121013A07C57f0D69646E86E7a4880b467b7);\n', '  P3D constant p3d = P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '  Pool constant pool = Pool(0xE00c09fEdD3d3Ed09e2D6F6F6E9B1597c1A99bc8);\n', '  Weth constant weth = Weth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '  \n', '  uint256 constant MAX_UINT = 2**256 - 1;\n', '  \n', '  constructor() public {\n', '    // pre-approve weth transactions\n', '    weth.approve(address(airswap), MAX_UINT);\n', '  }\n', '  \n', '  function() external payable {}\n', '\n', '  function fill(\n', '    // [makerAddress, masternode]\n', '    address[2] addresses,\n', '    uint256 makerAmount,\n', '    address makerToken,\n', '    uint256 takerAmount,\n', '    address takerToken,\n', '    uint256 expiration,\n', '    uint256 nonce,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) public payable {\n', '\n', '    // fee, ether amount\n', '    uint256 fee;\n', '    uint256 amount;\n', '\n', '    if (takerToken == address(0) || takerToken == address(weth)) {\n', '      // taker is buying a token with ether or weth\n', '\n', '      // maker token must not be ether or weth\n', '      require(makerToken != address(0) && makerToken != address(weth));\n', '\n', '      // 1% fee on ether\n', '      fee = takerAmount / 100;\n', '\n', '      // subtract fee from value\n', '      amount = msg.value.sub(fee);\n', '      \n', '      // taker amount must match\n', '      require(amount == takerAmount);\n', '      \n', '      if (takerToken == address(weth)) {\n', '        // if we are exchanging weth, deposit\n', '        weth.deposit.value(amount);\n', '        \n', '        // fill weth order\n', '        airswap.fill(\n', '          addresses[0],\n', '          makerAmount,\n', '          makerToken,\n', '          address(this),\n', '          amount,\n', '          takerToken,\n', '          expiration,\n', '          nonce,\n', '          v,\n', '          r,\n', '          s\n', '        );\n', '      } else {\n', '        // fill eth order\n', '        airswap.fill.value(amount)(\n', '          addresses[0],\n', '          makerAmount,\n', '          makerToken,\n', '          address(this),\n', '          amount,\n', '          takerToken,\n', '          expiration,\n', '          nonce,\n', '          v,\n', '          r,\n', '          s\n', '        );\n', '      }\n', '\n', '      // send fee to the pool contract\n', '      if (fee != 0) {\n', '        pool.contribute.value(fee)(addresses[1], msg.sender);\n', '      }\n', '\n', '      // finish trade\n', '      require(IERC20(makerToken).transfer(msg.sender, makerAmount));\n', '\n', '    } else {\n', '      // taker is selling a token for ether\n', '\n', '      // no ether should be sent\n', '      require(msg.value == 0);\n', '\n', '      // maker token must be ether or weth\n', '      require(makerToken == address(0) || makerToken == address(weth));\n', '        \n', '      // transfer taker tokens to this contract\n', '      require(IERC20(takerToken).transferFrom(msg.sender, address(this), takerAmount));\n', '\n', '      // approve the airswap contract for this transaction\n', '      if (IERC20(takerToken).allowance(address(this), address(airswap)) < takerAmount) {\n', '        IERC20(takerToken).approve(address(airswap), MAX_UINT);\n', '      }\n', '\n', '      // fill the order\n', '      airswap.fill(\n', '        addresses[0],\n', '        makerAmount,\n', '        makerToken,\n', '        address(this),\n', '        takerAmount,\n', '        takerToken,\n', '        expiration,\n', '        nonce,\n', '        v,\n', '        r,\n', '        s\n', '      );\n', '      \n', '      // if we bought weth, withdraw ether\n', '      if (makerToken == address(weth)) {\n', '        weth.withdraw(makerAmount);\n', '      }\n', '      \n', '      // 1% fee on ether\n', '      fee = makerAmount / 100;\n', '\n', '      // subtract fee from amount\n', '      amount = makerAmount.sub(fee);\n', '\n', '      // send fee to the pool contract\n', '      if (fee != 0) {\n', '        pool.contribute.value(fee)(addresses[1], msg.sender);\n', '      }\n', '\n', '      // finish trade\n', '      msg.sender.transfer(amount);\n', '    }\n', '  }\n', '}']