['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev A standard interface for tokens.\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20 {\n', '  \n', '    /// @dev Returns the total token supply\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @dev Returns the account balance of the account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @dev Transfers _value number of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Transfers _value number of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Allows _spender to withdraw from the msg.sender&#39;s account up to the _value amount\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract Fundraiser {\n', '\n', '    event Beginning(\n', '        bytes32 _causeSecret\n', '    );\n', '\n', '    event Participation(\n', '        address _participant,\n', '        bytes32 _message,\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    );\n', '\n', '    event Raise(\n', '        address _participant,\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    );\n', '\n', '    event Revelation(\n', '        bytes32 _causeMessage\n', '    );\n', '\n', '    event Selection(\n', '        address _participant,\n', '        bytes32 _participantMessage,\n', '        bytes32 _causeMessage,\n', '        bytes32 _ownerMessage\n', '    );\n', '\n', '    event Cancellation();\n', '\n', '    event Withdrawal(\n', '        address _address\n', '    );\n', '\n', '    struct Deployment {\n', '        address _cause;\n', '        address _causeWallet;\n', '        uint256 _causeSplit;\n', '        uint256 _participantSplit;\n', '        address _owner;\n', '        address _ownerWallet;\n', '        uint256 _ownerSplit;\n', '        bytes32 _ownerSecret;\n', '        uint256 _valuePerEntry;\n', '        uint256 _deployTime;\n', '        uint256 _endTime;\n', '        uint256 _expireTime;\n', '        uint256 _destructTime;\n', '        uint256 _entropy;\n', '    }\n', '\n', '    struct State {\n', '        bytes32 _causeSecret;\n', '        bytes32 _causeMessage;\n', '        bool _causeWithdrawn;\n', '        address _participant;\n', '        bool _participantWithdrawn;\n', '        bytes32 _ownerMessage;\n', '        bool _ownerWithdrawn;\n', '        bool _cancelled;\n', '        uint256 _participants;\n', '        uint256 _entries;\n', '        uint256 _revealBlockNumber;\n', '        uint256 _revealBlockHash;\n', '    }\n', '\n', '    struct Participant {\n', '        bytes32 _message;\n', '        uint256 _entries;\n', '    }\n', '\n', '    struct Fund {\n', '        address _participant;\n', '        uint256 _entries;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == deployment._owner);\n', '        _;\n', '    }\n', '\n', '    modifier neverOwner() {\n', '        require(msg.sender != deployment._owner);\n', '        require(msg.sender != deployment._ownerWallet);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCause() {\n', '        require(msg.sender == deployment._cause);\n', '        _;\n', '    }\n', '\n', '    modifier neverCause() {\n', '        require(msg.sender != deployment._cause);\n', '        require(msg.sender != deployment._causeWallet);\n', '        _;\n', '    }\n', '\n', '    modifier participationPhase() {\n', '        require(now < deployment._endTime);\n', '        _;\n', '    }\n', '\n', '    modifier recapPhase() {\n', '        require((now >= deployment._endTime) && (now < deployment._expireTime));\n', '        _;\n', '    }\n', '\n', '    modifier destructionPhase() {\n', '        require(now >= deployment._destructTime);\n', '        _;\n', '    }\n', '    \n', '    Deployment public deployment;\n', '    mapping(address => Participant) public participants;\n', '    Fund[] private funds;\n', '    State private _state;\n', '\n', '    function Fundraiser(\n', '        address _cause,\n', '        address _causeWallet,\n', '        uint256 _causeSplit,\n', '        uint256 _participantSplit,\n', '        address _ownerWallet,\n', '        uint256 _ownerSplit,\n', '        bytes32 _ownerSecret,\n', '        uint256 _valuePerEntry,\n', '        uint256 _endTime,\n', '        uint256 _expireTime,\n', '        uint256 _destructTime,\n', '        uint256 _entropy\n', '    ) public {\n', '        require(_cause != 0x0);\n', '        require(_causeWallet != 0x0);\n', '        require(_causeSplit != 0);\n', '        require(_participantSplit != 0);\n', '        require(_ownerWallet != 0x0);\n', '        require(_causeSplit + _participantSplit + _ownerSplit == 1000);\n', '        require(_ownerSecret != 0x0);\n', '        require(_valuePerEntry != 0);\n', '        require(_endTime > now); // participation phase\n', '        require(_expireTime > _endTime); // end phase\n', '        require(_destructTime > _expireTime); // destruct phase\n', '        require(_entropy > 0);\n', '\n', '        // set the deployment\n', '        deployment = Deployment(\n', '            _cause,\n', '            _causeWallet,\n', '            _causeSplit,\n', '            _participantSplit,\n', '            msg.sender,\n', '            _ownerWallet,\n', '            _ownerSplit,\n', '            _ownerSecret,\n', '            _valuePerEntry,\n', '            now,\n', '            _endTime,\n', '            _expireTime,\n', '            _destructTime,\n', '            _entropy\n', '        );\n', '\n', '    }\n', '\n', '    // returns the post-deployment state of the contract\n', '    function state() public view returns (\n', '        bytes32 _causeSecret,\n', '        bytes32 _causeMessage,\n', '        bool _causeWithdrawn,\n', '        address _participant,\n', '        bytes32 _participantMessage,\n', '        bool _participantWithdrawn,\n', '        bytes32 _ownerMessage,\n', '        bool _ownerWithdrawn,\n', '        bool _cancelled,\n', '        uint256 _participants,\n', '        uint256 _entries\n', '    ) {\n', '        _causeSecret = _state._causeSecret;\n', '        _causeMessage = _state._causeMessage;\n', '        _causeWithdrawn = _state._causeWithdrawn;\n', '        _participant = _state._participant;\n', '        _participantMessage = participants[_participant]._message;\n', '        _participantWithdrawn = _state._participantWithdrawn;\n', '        _ownerMessage = _state._ownerMessage;\n', '        _ownerWithdrawn = _state._ownerWithdrawn;\n', '        _cancelled = _state._cancelled;\n', '        _participants = _state._participants;\n', '        _entries = _state._entries;\n', '    }\n', '\n', '    // returns the balance of a cause, selected participant, owner, or participant (refund)\n', '    function balance() public view returns (uint256) {\n', '        // check for fundraiser ended normally\n', '        if (_state._participant != address(0)) {\n', '            // selected, get split\n', '            uint256 _split;\n', '            // determine split based on sender\n', '            if (msg.sender == deployment._cause) {\n', '                if (_state._causeWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._causeSplit;\n', '            } else if (msg.sender == _state._participant) {\n', '                if (_state._participantWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._participantSplit;\n', '            } else if (msg.sender == deployment._owner) {\n', '                if (_state._ownerWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._ownerSplit;\n', '            } else {\n', '                return 0;\n', '            }\n', '            // multiply total entries by split % (non-revealed winnings are forfeited)\n', '            return _state._entries * deployment._valuePerEntry * _split / 1000;\n', '        } else if (_state._cancelled) {\n', '            // value per entry times participant entries == balance\n', '            Participant storage _participant = participants[msg.sender];\n', '            return _participant._entries * deployment._valuePerEntry;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    // called by the cause to begin their fundraiser with their secret\n', '    function begin(bytes32 _secret) public participationPhase onlyCause {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret == 0x0); // cause has not seeded secret\n', '        require(_secret != 0x0); // secret cannot be zero\n', '\n', '        // seed cause secret, starting the fundraiser\n', '        _state._causeSecret = _secret;\n', '\n', '        // broadcast event\n', '        Beginning(_secret);\n', '    }\n', '\n', '    // participate in this fundraiser by contributing messages and ether for entries\n', '    function participate(bytes32 _message) public participationPhase neverCause neverOwner payable {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret != 0x0); // cause has seeded secret\n', '        require(_message != 0x0); // message cannot be zero\n', '\n', '        // find and check for no existing participant\n', '        Participant storage _participant = participants[msg.sender];\n', '        require(_participant._message == 0x0);\n', '        require(_participant._entries == 0);\n', '\n', '        // add entries to participant\n', '        var (_entries, _refund) = _raise(_participant);\n', '        // save participant message, increment total participants\n', '        _participant._message = _message;\n', '        _state._participants++;\n', '\n', '        // send out participation update\n', '        Participation(msg.sender, _message, _entries, _refund);\n', '    }\n', '\n', '    // called by participate() and the fallback function for obtaining (additional) entries\n', '    function _raise(Participant storage _participant) private returns (\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    ) {\n', '        // calculate the number of entries from the wei sent\n', '        _entries = msg.value / deployment._valuePerEntry;\n', '        require(_entries >= 1); // ensure we have at least one entry\n', '        // update participant totals\n', '        _participant._entries += _entries;\n', '        _state._entries += _entries;\n', '\n', '        // get previous fund&#39;s entries\n', '        uint256 _previousFundEntries = (funds.length > 0) ?\n', '            funds[funds.length - 1]._entries : 0;\n', '        // create and save new fund with cumulative entries\n', '        Fund memory _fund = Fund(msg.sender, _previousFundEntries + _entries);\n', '        funds.push(_fund);\n', '\n', '        // calculate partial entry refund\n', '        _refund = msg.value % deployment._valuePerEntry;\n', '        // refund any excess wei immediately (partial entry)\n', '        if (_refund > 0) {\n', '            msg.sender.transfer(_refund);\n', '        }\n', '    }\n', '\n', '    // fallback function that accepts ether for additional entries after an initial participation\n', '    function () public participationPhase neverCause neverOwner payable {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret != 0x0); // cause has seeded secret\n', '\n', '        // find existing participant\n', '        Participant storage _participant = participants[msg.sender];\n', '        require(_participant._message != 0x0); // make sure they participated\n', '        // forward to raise\n', '        var (_entries, _refund) = _raise(_participant);\n', '        \n', '        // send raise event\n', '        Raise(msg.sender, _entries, _refund);\n', '    }\n', '\n', '    // called by the cause to reveal their message after the end time but before the end() function\n', '    function reveal(bytes32 _message) public recapPhase onlyCause {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeMessage == 0x0); // cannot have revealed already\n', '        require(_state._revealBlockNumber == 0); // block number of reveal should not be set\n', '        require(_decode(_state._causeSecret, _message)); // check for valid message\n', '\n', '        // save revealed cause message\n', '        _state._causeMessage = _message;\n', '        // save reveal block number\n', '        _state._revealBlockNumber = block.number;\n', '\n', '        // send reveal event\n', '        Revelation(_message);\n', '    }\n', '\n', '    // determines that validity of a message, given a secret\n', '    function _decode(bytes32 _secret, bytes32 _message) private view returns (bool) {\n', '        return _secret == keccak256(_message, msg.sender);\n', '    }\n', '\n', '    // ends this fundraiser, selects a participant to reward, and allocates funds for the cause, the\n', '    // selected participant, and the contract owner\n', '    function end(bytes32 _message) public recapPhase onlyOwner {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeMessage != 0x0); // cause must have revealed\n', '        require(_state._revealBlockNumber != 0); // reveal block number must be set\n', '        require(_state._ownerMessage == 0x0); // cannot have ended already\n', '        require(_decode(deployment._ownerSecret, _message)); // check for valid message\n', '        require(block.number > _state._revealBlockNumber); // verify reveal has been mined\n', '\n', '        // get the (cause) reveal blockhash and ensure within 256 blocks (non-zero)\n', '        _state._revealBlockHash = uint256(block.blockhash(_state._revealBlockNumber));\n', '        require(_state._revealBlockHash != 0);\n', '        // save revealed owner message\n', '        _state._ownerMessage = _message;\n', '\n', '        bytes32 _randomNumber;\n', '        address _participant;\n', '        bytes32 _participantMessage;\n', '        // add additional entropy to the random from participant messages\n', '        for (uint256 i = 0; i < deployment._entropy; i++) {\n', '            // calculate the next random\n', '            _randomNumber = keccak256(\n', '                _message,\n', '                _state._causeMessage,\n', '                _state._revealBlockHash,\n', '                _participantMessage\n', '            );\n', '            // calculate next entry and grab corresponding participant\n', '            uint256 _entry = uint256(_randomNumber) % _state._entries;\n', '            _participant = _findParticipant(_entry);\n', '            _participantMessage = participants[_participant]._message;\n', '        }\n', '\n', '        // the final participant receives the reward\n', '        _state._participant = _participant;\n', '        \n', '        // send out select event\n', '        Selection(\n', '            _state._participant,\n', '            _participantMessage,\n', '            _state._causeMessage,\n', '            _message\n', '        );\n', '    }\n', '\n', '    // given an entry number, find the corresponding participant (address)\n', '    function _findParticipant(uint256 _entry) private view returns (address)  {\n', '        uint256 _leftFundIndex = 0;\n', '        uint256 _rightFundIndex = funds.length - 1;\n', '        // loop until participant found\n', '        while (true) {\n', '            // first or last fund (edge cases)\n', '            if (_leftFundIndex == _rightFundIndex) {\n', '                return funds[_leftFundIndex]._participant;\n', '            }\n', '            // get fund indexes for mid & next\n', '            uint256 _midFundIndex =\n', '                _leftFundIndex + ((_rightFundIndex - _leftFundIndex) / 2);\n', '            uint256 _nextFundIndex = _midFundIndex + 1;\n', '            // get mid and next funds\n', '            Fund memory _midFund = funds[_midFundIndex];\n', '            Fund memory _nextFund = funds[_nextFundIndex];\n', '            // binary search\n', '            if (_entry >= _midFund._entries) {\n', '                if (_entry < _nextFund._entries) {\n', '                    // we are in range, participant found\n', '                    return _nextFund._participant;\n', '                }\n', '                // entry is greater, move right\n', '                _leftFundIndex = _nextFundIndex;\n', '            } else {\n', '                // entry is less, move left\n', '                _rightFundIndex = _midFundIndex;\n', '            }\n', '        }\n', '    }\n', '\n', '    // called by the cause or Seedom before the end time to cancel the fundraiser, refunding all\n', '    // participants; this function is available to the entire community after the expire time\n', '    function cancel() public {\n', '        require(!_state._cancelled); // fundraiser not already cancelled\n', '        require(_state._participant == address(0)); // selected must not have been chosen\n', '        \n', '        // open cancellation to community if past expire time (but before destruct time)\n', '        if ((msg.sender != deployment._owner) && (msg.sender != deployment._cause)) {\n', '            require((now >= deployment._expireTime) && (now < deployment._destructTime));\n', '        }\n', '\n', '        // immediately set us to cancelled\n', '        _state._cancelled = true;\n', '\n', '        // send out cancellation event\n', '        Cancellation();\n', '    }\n', '\n', '    // used to withdraw funds from the contract from an ended fundraiser or refunds when the\n', '    // fundraiser is cancelled\n', '    function withdraw() public {\n', '        // check for a balance\n', '        uint256 _balance = balance();\n', '        require (_balance > 0); // can only withdraw a balance\n', '\n', '        address _wallet;\n', '        // check for fundraiser ended normally\n', '        if (_state._participant != address(0)) {\n', '\n', '            // determine split based on sender\n', '            if (msg.sender == deployment._cause) {\n', '                _state._causeWithdrawn = true;\n', '                _wallet = deployment._causeWallet;\n', '            } else if (msg.sender == _state._participant) {\n', '                _state._participantWithdrawn = true;\n', '                _wallet = _state._participant;\n', '            } else if (msg.sender == deployment._owner) {\n', '                _state._ownerWithdrawn = true;\n', '                _wallet = deployment._ownerWallet;\n', '            } else {\n', '                revert();\n', '            }\n', '\n', '        } else if (_state._cancelled) {\n', '\n', '            // set participant entries to zero to prevent multiple refunds\n', '            Participant storage _participant = participants[msg.sender];\n', '            _participant._entries = 0;\n', '            _wallet = msg.sender;\n', '\n', '        } else {\n', '            // no selected and not cancelled\n', '            revert();\n', '        }\n', '\n', '        // execute the refund if we have one\n', '        _wallet.transfer(_balance);\n', '        // send withdrawal event\n', '        Withdrawal(msg.sender);\n', '    }\n', '\n', '    // destroy() will be used to clean up old contracts from the network\n', '    function destroy() public destructionPhase onlyOwner {\n', '        // destroy this contract and send remaining funds to owner\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    // recover() allows the owner to recover ERC20 tokens sent to this contract, for later\n', '    // distribution back to their original holders, upon request\n', '    function recover(address _token) public onlyOwner {\n', '        ERC20 _erc20 = ERC20(_token);\n', '        uint256 _balance = _erc20.balanceOf(this);\n', '        require(_erc20.transfer(deployment._owner, _balance));\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev A standard interface for tokens.\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20 {\n', '  \n', '    /// @dev Returns the total token supply\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @dev Returns the account balance of the account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @dev Transfers _value number of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Transfers _value number of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', "    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\n", '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract Fundraiser {\n', '\n', '    event Beginning(\n', '        bytes32 _causeSecret\n', '    );\n', '\n', '    event Participation(\n', '        address _participant,\n', '        bytes32 _message,\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    );\n', '\n', '    event Raise(\n', '        address _participant,\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    );\n', '\n', '    event Revelation(\n', '        bytes32 _causeMessage\n', '    );\n', '\n', '    event Selection(\n', '        address _participant,\n', '        bytes32 _participantMessage,\n', '        bytes32 _causeMessage,\n', '        bytes32 _ownerMessage\n', '    );\n', '\n', '    event Cancellation();\n', '\n', '    event Withdrawal(\n', '        address _address\n', '    );\n', '\n', '    struct Deployment {\n', '        address _cause;\n', '        address _causeWallet;\n', '        uint256 _causeSplit;\n', '        uint256 _participantSplit;\n', '        address _owner;\n', '        address _ownerWallet;\n', '        uint256 _ownerSplit;\n', '        bytes32 _ownerSecret;\n', '        uint256 _valuePerEntry;\n', '        uint256 _deployTime;\n', '        uint256 _endTime;\n', '        uint256 _expireTime;\n', '        uint256 _destructTime;\n', '        uint256 _entropy;\n', '    }\n', '\n', '    struct State {\n', '        bytes32 _causeSecret;\n', '        bytes32 _causeMessage;\n', '        bool _causeWithdrawn;\n', '        address _participant;\n', '        bool _participantWithdrawn;\n', '        bytes32 _ownerMessage;\n', '        bool _ownerWithdrawn;\n', '        bool _cancelled;\n', '        uint256 _participants;\n', '        uint256 _entries;\n', '        uint256 _revealBlockNumber;\n', '        uint256 _revealBlockHash;\n', '    }\n', '\n', '    struct Participant {\n', '        bytes32 _message;\n', '        uint256 _entries;\n', '    }\n', '\n', '    struct Fund {\n', '        address _participant;\n', '        uint256 _entries;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == deployment._owner);\n', '        _;\n', '    }\n', '\n', '    modifier neverOwner() {\n', '        require(msg.sender != deployment._owner);\n', '        require(msg.sender != deployment._ownerWallet);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCause() {\n', '        require(msg.sender == deployment._cause);\n', '        _;\n', '    }\n', '\n', '    modifier neverCause() {\n', '        require(msg.sender != deployment._cause);\n', '        require(msg.sender != deployment._causeWallet);\n', '        _;\n', '    }\n', '\n', '    modifier participationPhase() {\n', '        require(now < deployment._endTime);\n', '        _;\n', '    }\n', '\n', '    modifier recapPhase() {\n', '        require((now >= deployment._endTime) && (now < deployment._expireTime));\n', '        _;\n', '    }\n', '\n', '    modifier destructionPhase() {\n', '        require(now >= deployment._destructTime);\n', '        _;\n', '    }\n', '    \n', '    Deployment public deployment;\n', '    mapping(address => Participant) public participants;\n', '    Fund[] private funds;\n', '    State private _state;\n', '\n', '    function Fundraiser(\n', '        address _cause,\n', '        address _causeWallet,\n', '        uint256 _causeSplit,\n', '        uint256 _participantSplit,\n', '        address _ownerWallet,\n', '        uint256 _ownerSplit,\n', '        bytes32 _ownerSecret,\n', '        uint256 _valuePerEntry,\n', '        uint256 _endTime,\n', '        uint256 _expireTime,\n', '        uint256 _destructTime,\n', '        uint256 _entropy\n', '    ) public {\n', '        require(_cause != 0x0);\n', '        require(_causeWallet != 0x0);\n', '        require(_causeSplit != 0);\n', '        require(_participantSplit != 0);\n', '        require(_ownerWallet != 0x0);\n', '        require(_causeSplit + _participantSplit + _ownerSplit == 1000);\n', '        require(_ownerSecret != 0x0);\n', '        require(_valuePerEntry != 0);\n', '        require(_endTime > now); // participation phase\n', '        require(_expireTime > _endTime); // end phase\n', '        require(_destructTime > _expireTime); // destruct phase\n', '        require(_entropy > 0);\n', '\n', '        // set the deployment\n', '        deployment = Deployment(\n', '            _cause,\n', '            _causeWallet,\n', '            _causeSplit,\n', '            _participantSplit,\n', '            msg.sender,\n', '            _ownerWallet,\n', '            _ownerSplit,\n', '            _ownerSecret,\n', '            _valuePerEntry,\n', '            now,\n', '            _endTime,\n', '            _expireTime,\n', '            _destructTime,\n', '            _entropy\n', '        );\n', '\n', '    }\n', '\n', '    // returns the post-deployment state of the contract\n', '    function state() public view returns (\n', '        bytes32 _causeSecret,\n', '        bytes32 _causeMessage,\n', '        bool _causeWithdrawn,\n', '        address _participant,\n', '        bytes32 _participantMessage,\n', '        bool _participantWithdrawn,\n', '        bytes32 _ownerMessage,\n', '        bool _ownerWithdrawn,\n', '        bool _cancelled,\n', '        uint256 _participants,\n', '        uint256 _entries\n', '    ) {\n', '        _causeSecret = _state._causeSecret;\n', '        _causeMessage = _state._causeMessage;\n', '        _causeWithdrawn = _state._causeWithdrawn;\n', '        _participant = _state._participant;\n', '        _participantMessage = participants[_participant]._message;\n', '        _participantWithdrawn = _state._participantWithdrawn;\n', '        _ownerMessage = _state._ownerMessage;\n', '        _ownerWithdrawn = _state._ownerWithdrawn;\n', '        _cancelled = _state._cancelled;\n', '        _participants = _state._participants;\n', '        _entries = _state._entries;\n', '    }\n', '\n', '    // returns the balance of a cause, selected participant, owner, or participant (refund)\n', '    function balance() public view returns (uint256) {\n', '        // check for fundraiser ended normally\n', '        if (_state._participant != address(0)) {\n', '            // selected, get split\n', '            uint256 _split;\n', '            // determine split based on sender\n', '            if (msg.sender == deployment._cause) {\n', '                if (_state._causeWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._causeSplit;\n', '            } else if (msg.sender == _state._participant) {\n', '                if (_state._participantWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._participantSplit;\n', '            } else if (msg.sender == deployment._owner) {\n', '                if (_state._ownerWithdrawn) {\n', '                    return 0;\n', '                }\n', '                _split = deployment._ownerSplit;\n', '            } else {\n', '                return 0;\n', '            }\n', '            // multiply total entries by split % (non-revealed winnings are forfeited)\n', '            return _state._entries * deployment._valuePerEntry * _split / 1000;\n', '        } else if (_state._cancelled) {\n', '            // value per entry times participant entries == balance\n', '            Participant storage _participant = participants[msg.sender];\n', '            return _participant._entries * deployment._valuePerEntry;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    // called by the cause to begin their fundraiser with their secret\n', '    function begin(bytes32 _secret) public participationPhase onlyCause {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret == 0x0); // cause has not seeded secret\n', '        require(_secret != 0x0); // secret cannot be zero\n', '\n', '        // seed cause secret, starting the fundraiser\n', '        _state._causeSecret = _secret;\n', '\n', '        // broadcast event\n', '        Beginning(_secret);\n', '    }\n', '\n', '    // participate in this fundraiser by contributing messages and ether for entries\n', '    function participate(bytes32 _message) public participationPhase neverCause neverOwner payable {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret != 0x0); // cause has seeded secret\n', '        require(_message != 0x0); // message cannot be zero\n', '\n', '        // find and check for no existing participant\n', '        Participant storage _participant = participants[msg.sender];\n', '        require(_participant._message == 0x0);\n', '        require(_participant._entries == 0);\n', '\n', '        // add entries to participant\n', '        var (_entries, _refund) = _raise(_participant);\n', '        // save participant message, increment total participants\n', '        _participant._message = _message;\n', '        _state._participants++;\n', '\n', '        // send out participation update\n', '        Participation(msg.sender, _message, _entries, _refund);\n', '    }\n', '\n', '    // called by participate() and the fallback function for obtaining (additional) entries\n', '    function _raise(Participant storage _participant) private returns (\n', '        uint256 _entries,\n', '        uint256 _refund\n', '    ) {\n', '        // calculate the number of entries from the wei sent\n', '        _entries = msg.value / deployment._valuePerEntry;\n', '        require(_entries >= 1); // ensure we have at least one entry\n', '        // update participant totals\n', '        _participant._entries += _entries;\n', '        _state._entries += _entries;\n', '\n', "        // get previous fund's entries\n", '        uint256 _previousFundEntries = (funds.length > 0) ?\n', '            funds[funds.length - 1]._entries : 0;\n', '        // create and save new fund with cumulative entries\n', '        Fund memory _fund = Fund(msg.sender, _previousFundEntries + _entries);\n', '        funds.push(_fund);\n', '\n', '        // calculate partial entry refund\n', '        _refund = msg.value % deployment._valuePerEntry;\n', '        // refund any excess wei immediately (partial entry)\n', '        if (_refund > 0) {\n', '            msg.sender.transfer(_refund);\n', '        }\n', '    }\n', '\n', '    // fallback function that accepts ether for additional entries after an initial participation\n', '    function () public participationPhase neverCause neverOwner payable {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeSecret != 0x0); // cause has seeded secret\n', '\n', '        // find existing participant\n', '        Participant storage _participant = participants[msg.sender];\n', '        require(_participant._message != 0x0); // make sure they participated\n', '        // forward to raise\n', '        var (_entries, _refund) = _raise(_participant);\n', '        \n', '        // send raise event\n', '        Raise(msg.sender, _entries, _refund);\n', '    }\n', '\n', '    // called by the cause to reveal their message after the end time but before the end() function\n', '    function reveal(bytes32 _message) public recapPhase onlyCause {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeMessage == 0x0); // cannot have revealed already\n', '        require(_state._revealBlockNumber == 0); // block number of reveal should not be set\n', '        require(_decode(_state._causeSecret, _message)); // check for valid message\n', '\n', '        // save revealed cause message\n', '        _state._causeMessage = _message;\n', '        // save reveal block number\n', '        _state._revealBlockNumber = block.number;\n', '\n', '        // send reveal event\n', '        Revelation(_message);\n', '    }\n', '\n', '    // determines that validity of a message, given a secret\n', '    function _decode(bytes32 _secret, bytes32 _message) private view returns (bool) {\n', '        return _secret == keccak256(_message, msg.sender);\n', '    }\n', '\n', '    // ends this fundraiser, selects a participant to reward, and allocates funds for the cause, the\n', '    // selected participant, and the contract owner\n', '    function end(bytes32 _message) public recapPhase onlyOwner {\n', '        require(!_state._cancelled); // fundraiser not cancelled\n', '        require(_state._causeMessage != 0x0); // cause must have revealed\n', '        require(_state._revealBlockNumber != 0); // reveal block number must be set\n', '        require(_state._ownerMessage == 0x0); // cannot have ended already\n', '        require(_decode(deployment._ownerSecret, _message)); // check for valid message\n', '        require(block.number > _state._revealBlockNumber); // verify reveal has been mined\n', '\n', '        // get the (cause) reveal blockhash and ensure within 256 blocks (non-zero)\n', '        _state._revealBlockHash = uint256(block.blockhash(_state._revealBlockNumber));\n', '        require(_state._revealBlockHash != 0);\n', '        // save revealed owner message\n', '        _state._ownerMessage = _message;\n', '\n', '        bytes32 _randomNumber;\n', '        address _participant;\n', '        bytes32 _participantMessage;\n', '        // add additional entropy to the random from participant messages\n', '        for (uint256 i = 0; i < deployment._entropy; i++) {\n', '            // calculate the next random\n', '            _randomNumber = keccak256(\n', '                _message,\n', '                _state._causeMessage,\n', '                _state._revealBlockHash,\n', '                _participantMessage\n', '            );\n', '            // calculate next entry and grab corresponding participant\n', '            uint256 _entry = uint256(_randomNumber) % _state._entries;\n', '            _participant = _findParticipant(_entry);\n', '            _participantMessage = participants[_participant]._message;\n', '        }\n', '\n', '        // the final participant receives the reward\n', '        _state._participant = _participant;\n', '        \n', '        // send out select event\n', '        Selection(\n', '            _state._participant,\n', '            _participantMessage,\n', '            _state._causeMessage,\n', '            _message\n', '        );\n', '    }\n', '\n', '    // given an entry number, find the corresponding participant (address)\n', '    function _findParticipant(uint256 _entry) private view returns (address)  {\n', '        uint256 _leftFundIndex = 0;\n', '        uint256 _rightFundIndex = funds.length - 1;\n', '        // loop until participant found\n', '        while (true) {\n', '            // first or last fund (edge cases)\n', '            if (_leftFundIndex == _rightFundIndex) {\n', '                return funds[_leftFundIndex]._participant;\n', '            }\n', '            // get fund indexes for mid & next\n', '            uint256 _midFundIndex =\n', '                _leftFundIndex + ((_rightFundIndex - _leftFundIndex) / 2);\n', '            uint256 _nextFundIndex = _midFundIndex + 1;\n', '            // get mid and next funds\n', '            Fund memory _midFund = funds[_midFundIndex];\n', '            Fund memory _nextFund = funds[_nextFundIndex];\n', '            // binary search\n', '            if (_entry >= _midFund._entries) {\n', '                if (_entry < _nextFund._entries) {\n', '                    // we are in range, participant found\n', '                    return _nextFund._participant;\n', '                }\n', '                // entry is greater, move right\n', '                _leftFundIndex = _nextFundIndex;\n', '            } else {\n', '                // entry is less, move left\n', '                _rightFundIndex = _midFundIndex;\n', '            }\n', '        }\n', '    }\n', '\n', '    // called by the cause or Seedom before the end time to cancel the fundraiser, refunding all\n', '    // participants; this function is available to the entire community after the expire time\n', '    function cancel() public {\n', '        require(!_state._cancelled); // fundraiser not already cancelled\n', '        require(_state._participant == address(0)); // selected must not have been chosen\n', '        \n', '        // open cancellation to community if past expire time (but before destruct time)\n', '        if ((msg.sender != deployment._owner) && (msg.sender != deployment._cause)) {\n', '            require((now >= deployment._expireTime) && (now < deployment._destructTime));\n', '        }\n', '\n', '        // immediately set us to cancelled\n', '        _state._cancelled = true;\n', '\n', '        // send out cancellation event\n', '        Cancellation();\n', '    }\n', '\n', '    // used to withdraw funds from the contract from an ended fundraiser or refunds when the\n', '    // fundraiser is cancelled\n', '    function withdraw() public {\n', '        // check for a balance\n', '        uint256 _balance = balance();\n', '        require (_balance > 0); // can only withdraw a balance\n', '\n', '        address _wallet;\n', '        // check for fundraiser ended normally\n', '        if (_state._participant != address(0)) {\n', '\n', '            // determine split based on sender\n', '            if (msg.sender == deployment._cause) {\n', '                _state._causeWithdrawn = true;\n', '                _wallet = deployment._causeWallet;\n', '            } else if (msg.sender == _state._participant) {\n', '                _state._participantWithdrawn = true;\n', '                _wallet = _state._participant;\n', '            } else if (msg.sender == deployment._owner) {\n', '                _state._ownerWithdrawn = true;\n', '                _wallet = deployment._ownerWallet;\n', '            } else {\n', '                revert();\n', '            }\n', '\n', '        } else if (_state._cancelled) {\n', '\n', '            // set participant entries to zero to prevent multiple refunds\n', '            Participant storage _participant = participants[msg.sender];\n', '            _participant._entries = 0;\n', '            _wallet = msg.sender;\n', '\n', '        } else {\n', '            // no selected and not cancelled\n', '            revert();\n', '        }\n', '\n', '        // execute the refund if we have one\n', '        _wallet.transfer(_balance);\n', '        // send withdrawal event\n', '        Withdrawal(msg.sender);\n', '    }\n', '\n', '    // destroy() will be used to clean up old contracts from the network\n', '    function destroy() public destructionPhase onlyOwner {\n', '        // destroy this contract and send remaining funds to owner\n', '        selfdestruct(msg.sender);\n', '    }\n', '\n', '    // recover() allows the owner to recover ERC20 tokens sent to this contract, for later\n', '    // distribution back to their original holders, upon request\n', '    function recover(address _token) public onlyOwner {\n', '        ERC20 _erc20 = ERC20(_token);\n', '        uint256 _balance = _erc20.balanceOf(this);\n', '        require(_erc20.transfer(deployment._owner, _balance));\n', '    }\n', '}']
