['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * (c) SecureVote 2018\n', ' * \n', ' * This is a library to manage all ballot box functions. The idea is that\n', ' * ballot box contracts should the the _minimum_ code required to be deployed\n', ' * which means most (ideally all) functions should be moved here.\n', ' */\n', '\n', '\n', 'library BBLib {\n', '    using BytesLib for bytes;\n', '\n', '    // ballot meta\n', '    uint256 constant BB_VERSION = 6;\n', '    /* 4 deprecated due to insecure vote by proxy\n', '       5 deprecated to\n', '        - add `returns (address)` to submitProxyVote\n', '    */\n', '\n', '    // voting settings\n', '    uint16 constant USE_ETH = 1;          // 2^0\n', '    uint16 constant USE_SIGNED = 2;       // 2^1\n', '    uint16 constant USE_NO_ENC = 4;       // 2^2\n', '    uint16 constant USE_ENC = 8;          // 2^3\n', '\n', '    // ballot settings\n', '    uint16 constant IS_BINDING = 8192;    // 2^13\n', '    uint16 constant IS_OFFICIAL = 16384;  // 2^14\n', '    uint16 constant USE_TESTING = 32768;  // 2^15\n', '\n', '    // other consts\n', '    uint32 constant MAX_UINT32 = 0xFFFFFFFF;\n', '\n', '    //// ** Storage Variables\n', '\n', '    // struct for ballot\n', '    struct Vote {\n', '        bytes32 voteData;\n', '        bytes32 castTsAndSender;\n', '        bytes extra;\n', '    }\n', '\n', '    struct Sponsor {\n', '        address sender;\n', '        uint amount;\n', '    }\n', '\n', '    //// ** Events\n', '    event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\n', '    event SuccessfulVote(address indexed voter, uint voteId);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event DeprecatedContract();\n', '\n', '\n', '    // The big database struct\n', '\n', '\n', '    struct DB {\n', '        // Maps to store ballots, along with corresponding log of voters.\n', '        // Should only be modified through internal functions\n', '        mapping (uint256 => Vote) votes;\n', '        uint256 nVotesCast;\n', '\n', '        // we need replay protection for proxy ballots - this will let us check against a sequence number\n', '        // note: votes directly from a user ALWAYS take priority b/c they do not have sequence numbers\n', '        // (sequencing is done by Ethereum itself via the tx nonce).\n', '        mapping (address => uint32) sequenceNumber;\n', '\n', '        // NOTE - We don&#39;t actually want to include the encryption PublicKey because _it&#39;s included in the ballotSpec_.\n', '        // It&#39;s better to ensure ppl actually have the ballot spec by not including it in the contract.\n', '        // Plus we&#39;re already storing the hash of the ballotSpec anyway...\n', '\n', '        // Private key to be set after ballot conclusion - curve25519\n', '        bytes32 ballotEncryptionSeckey;\n', '\n', '        // packed contains:\n', '        // 1. Timestamps for start and end of ballot (UTC)\n', '        // 2. bits used to decide which options are enabled or disabled for submission of ballots\n', '        uint256 packed;\n', '\n', '        // specHash by which to validate the ballots integrity\n', '        bytes32 specHash;\n', '        // extradata if we need it - allows us to upgrade spechash format, etc\n', '        bytes16 extraData;\n', '\n', '        // allow tracking of sponsorship for this ballot & connection to index\n', '        Sponsor[] sponsors;\n', '        IxIface index;\n', '\n', '        // deprecation flag - doesn&#39;t actually do anything besides signal that this contract is deprecated;\n', '        bool deprecated;\n', '\n', '        address ballotOwner;\n', '        uint256 creationTs;\n', '    }\n', '\n', '\n', '    // ** Modifiers -- note, these are functions here to allow use as a lib\n', '    function requireBallotClosed(DB storage db) internal view {\n', '        require(now > BPackedUtils.packedToEndTime(db.packed), "!b-closed");\n', '    }\n', '\n', '    function requireBallotOpen(DB storage db) internal view {\n', '        uint64 _n = uint64(now);\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\n', '        require(_n >= startTs && _n < endTs, "!b-open");\n', '        require(db.deprecated == false, "b-deprecated");\n', '    }\n', '\n', '    function requireBallotOwner(DB storage db) internal view {\n', '        require(msg.sender == db.ballotOwner, "!b-owner");\n', '    }\n', '\n', '    function requireTesting(DB storage db) internal view {\n', '        require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), "!testing");\n', '    }\n', '\n', '    /* Library meta */\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        // even though this is constant we want to make sure that it&#39;s actually\n', '        // callable on Ethereum so we don&#39;t accidentally package the constant code\n', '        // in with an SC using BBLib. This function _must_ be external.\n', '        return BB_VERSION;\n', '    }\n', '\n', '    /* Functions */\n', '\n', '    // "Constructor" function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\n', '        require(db.specHash == bytes32(0), "b-exists");\n', '\n', '        db.index = ix;\n', '        db.ballotOwner = ballotOwner;\n', '\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        uint16 sb;\n', '        (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\n', '\n', '        bool _testing = isTesting(sb);\n', '        if (_testing) {\n', '            emit TestingEnabled();\n', '        } else {\n', '            require(endTs > now, "bad-end-time");\n', '\n', '            // 0x1ff2 is 0001111111110010 in binary\n', '            // by ANDing with subBits we make sure that only bits in positions 0,2,3,13,14,15\n', '            // can be used. these correspond to the option flags at the top, and ETH ballots\n', '            // that are enc&#39;d or plaintext.\n', '            require(sb & 0x1ff2 == 0, "bad-sb");\n', '\n', '            // if we give bad submission bits (e.g. all 0s) then refuse to deploy ballot\n', '            bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\n', '            require(okaySubmissionBits, "!valid-sb");\n', '\n', '            // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '            // (which someone might be able to do if they could set the timestamp in the past)\n', '            startTs = startTs > now ? startTs : uint64(now);\n', '        }\n', '        require(_specHash != bytes32(0), "null-specHash");\n', '        db.specHash = _specHash;\n', '\n', '        db.packed = BPackedUtils.pack(sb, startTs, endTs);\n', '        db.creationTs = now;\n', '\n', '        if (extraData != bytes16(0)) {\n', '            db.extraData = extraData;\n', '        }\n', '\n', '        emit CreatedBallot(db.specHash, startTs, endTs, sb);\n', '    }\n', '\n', '    /* sponsorship */\n', '\n', '    function logSponsorship(DB storage db, uint value) internal {\n', '        db.sponsors.push(Sponsor(msg.sender, value));\n', '    }\n', '\n', '    /* getters */\n', '\n', '    function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n', '        return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\n', '    }\n', '\n', '    function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\n', '        return db.sequenceNumber[voter];\n', '    }\n', '\n', '    function getTotalSponsorship(DB storage db) internal view returns (uint total) {\n', '        for (uint i = 0; i < db.sponsors.length; i++) {\n', '            total += db.sponsors[i].amount;\n', '        }\n', '    }\n', '\n', '    function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\n', '        sender = db.sponsors[i].sender;\n', '        amount = db.sponsors[i].amount;\n', '    }\n', '\n', '    /* ETH BALLOTS */\n', '\n', '    // Ballot submission\n', '    // note: if USE_ENC then curve25519 keys should be generated for\n', '    // each ballot (then thrown away).\n', '    // the curve25519 PKs go in the extra param\n', '    function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\n', '        _addVote(db, voteData, msg.sender, extra);\n', '        // set the sequence number to max uint32 to disable proxy submitted ballots\n', '        // after a voter submits a transaction personally - effectivley disables proxy\n', '        // ballots. You can _always_ submit a new vote _personally_ with this scheme.\n', '        if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\n', '            // using an IF statement here let&#39;s us save 4800 gas on repeat votes at the cost of 20k extra gas initially\n', '            db.sequenceNumber[msg.sender] = MAX_UINT32;\n', '        }\n', '    }\n', '\n', '    // Boundaries for constructing the msg we&#39;ll validate the signature of\n', '    function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\n', '        // a proxy vote (where the vote is submitted (i.e. tx fee paid by someone else)\n', '        // docs for datastructs: https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md\n', '\n', '        bytes32 r = proxyReq[0];\n', '        bytes32 s = proxyReq[1];\n', '        uint8 v = uint8(proxyReq[2][0]);\n', '        // converting to uint248 will truncate the first byte, and we can then convert it to a bytes31.\n', '        // we truncate the first byte because it&#39;s the `v` parm used above\n', '        bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\n', '        // proxyReq[3] is ballotId - required for verifying sig but not used for anything else\n', '        bytes32 ballotId = proxyReq[3];\n', '        bytes32 voteData = proxyReq[4];\n', '\n', '        // using abi.encodePacked is much cheaper than making bytes in other ways...\n', '        bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\n', '        bytes32 msgHash = keccak256(signed);\n', '        // need to be sure we are signing the entire ballot and any extra data that comes with it\n', '        voter = ecrecover(msgHash, v, r, s);\n', '\n', '        // we need to make sure that this is the most recent vote the voter made, and that it has\n', '        // not been seen before. NOTE: we&#39;ve already validated the BBFarm namespace before this, so\n', '        // we know it&#39;s meant for _this_ ballot.\n', '        uint32 sequence = uint32(proxyReq2);  // last 4 bytes of proxyReq2 - the sequence number\n', '        _proxyReplayProtection(db, voter, sequence);\n', '\n', '        _addVote(db, voteData, voter, extra);\n', '    }\n', '\n', '    function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n', '        requireBallotOpen(db);\n', '\n', '        id = db.nVotesCast;\n', '        db.votes[id].voteData = voteData;\n', '        // pack the casting ts right next to the sender\n', '        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\n', '        if (extra.length > 0) {\n', '            db.votes[id].extra = extra;\n', '        }\n', '        db.nVotesCast += 1;\n', '        emit SuccessfulVote(sender, id);\n', '    }\n', '\n', '    function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\n', '        // we want the replay protection sequence number to be STRICTLY MORE than what\n', '        // is stored in the mapping. This means we can set sequence to MAX_UINT32 to disable\n', '        // any future votes.\n', '        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");\n', '        db.sequenceNumber[voter] = sequence;\n', '    }\n', '\n', '    /* Admin */\n', '\n', '    function setEndTime(DB storage db, uint64 newEndTime) external {\n', '        uint16 sb;\n', '        uint64 sTs;\n', '        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\n', '        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\n', '    }\n', '\n', '    function revealSeckey(DB storage db, bytes32 sk) internal {\n', '        db.ballotEncryptionSeckey = sk;\n', '        emit SeckeyRevealed(sk);\n', '    }\n', '\n', '    /* Submission Bits (Ballot Classifications) */\n', '\n', '    // do (bits & SETTINGS_MASK) to get just operational bits (as opposed to testing or official flag)\n', '    uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\n', '\n', '    function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\n', '    }\n', '\n', '    function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_ENC);\n', '    }\n', '\n', '    function isOfficial(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\n', '    }\n', '\n', '    function isBinding(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_BINDING) == IS_BINDING;\n', '    }\n', '\n', '    function isTesting(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & USE_TESTING) == USE_TESTING;\n', '    }\n', '\n', '    function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\n', '        // if submissionBits AND any of the bits that make this _not_ a community\n', '        // ballot is equal to zero that means none of those bits were active, so\n', '        // it could be a community ballot\n', '        return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\n', '    }\n', '\n', '    function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\n', '        // this should ignore ONLY the testing/flag bits - all other bits are significant\n', '        uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\n', '        // then we want ONLY expected\n', '        return sBitsNoSettings == expected;\n', '    }\n', '}\n', '\n', 'library BPackedUtils {\n', '\n', '    // the uint16 ending at 128 bits should be 0s\n', '    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n', '    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n', '    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n', '\n', '    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n', '        return uint16(packed >> 128);\n', '    }\n', '\n', '    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed >> 64);\n', '    }\n', '\n', '    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed);\n', '    }\n', '\n', '    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n', '        submissionBits = uint16(packed >> 128);\n', '        startTime = uint64(packed >> 64);\n', '        endTime = uint64(packed);\n', '    }\n', '\n', '    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n', '        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n', '    }\n', '\n', '    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n', '        return (packed & sbMask) | uint256(newSB) << 128;\n', '    }\n', '\n', '    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\n', '    //     return (packed & startTimeMask) | uint256(startTime) << 64;\n', '    // }\n', '\n', '    // function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n', '    //     return (packed & endTimeMask) | uint256(endTime);\n', '    // }\n', '}\n', '\n', 'interface IxIface {}\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', '            // of the array. (We don&#39;t need to use the offset into the slot\n', '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', '            // if length < 32 bytes so let&#39;s prepare for that\n', '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', '                // data we don&#39;t care about, but the last `lengthmod` bytes will\n', '                // land at the beginning of the contents of the new array. When\n', '                // we&#39;re done copying, we overwrite the full first word with\n', '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', '                // the following copy loop was copying the origin&#39;s length\n', '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', '            //if we want a zero-length slice let&#39;s just return a zero-length array\n', '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', '                // cb is a circuit breaker in the for loop since there&#39;s\n', '                //  no said feature for inline assembly loops\n', '                // cb = 1 - don&#39;t breaker\n', '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', '                // if length < 32 bytes so let&#39;s prepare for that\n', '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', '                        // cb is a circuit breaker in the for loop since there&#39;s\n', '                        //  no said feature for inline assembly loops\n', '                        // cb = 1 - don&#39;t breaker\n', '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}']