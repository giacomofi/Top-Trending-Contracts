['pragma solidity ^0.4.18;\n', '/* ==================================================================== */\n', '/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\n', '/* \n', '/* https://www.pirateconquest.com One of the world&#39;s slg games of blockchain \n', '/*  \n', '/* authors rainy@livestar.com/Jonny.Fu@livestar.com\n', '/*                 \n', '/* ==================================================================== */\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', 'contract ERC721 /* is ERC165 */ {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function ownerOf(uint256 _tokenId) external view returns (address);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function approve(address _approved, uint256 _tokenId) external payable;\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', 'interface ERC165 {\n', '     function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x780e9d63\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /*\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() external onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() external onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract AccessAdmin is Pausable {\n', '\n', '  /// @dev Admin Address\n', '  mapping (address => bool) adminContracts;\n', '\n', '  /// @dev Trust contract\n', '  mapping (address => bool) actionContracts;\n', '\n', '  function setAdminContract(address _addr, bool _useful) public onlyOwner {\n', '    require(_addr != address(0));\n', '    adminContracts[_addr] = _useful;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    require(adminContracts[msg.sender]); \n', '    _;\n', '  }\n', '\n', '  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n', '    actionContracts[_actionAddr] = _useful;\n', '  }\n', '\n', '  modifier onlyAccess() {\n', '    require(actionContracts[msg.sender]);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', 'contract KittyToken is AccessAdmin, ERC721 {\n', '  using SafeMath for SafeMath;\n', '  //event \n', '  event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price);\n', '  //ERC721\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  struct Kitty {\n', '    uint32 kittyId;\n', '  }\n', '\n', '  Kitty[] public kitties; //dynamic Array\n', '  function KittyToken() public {\n', '    kitties.length += 1;\n', '    setAdminContract(msg.sender,true);\n', '    setActionContract(msg.sender,true);\n', '  }\n', '\n', '  /**MAPPING**/\n', '  /// @dev tokenId to owner  tokenId -> address\n', '  mapping (uint256 => address) public TokenIdToOwner;\n', '  /// @dev Equipment token ID search in owner array kittyId -> tokenId\n', '  mapping (uint256 => uint256) kittyIdToOwnerIndex;  \n', '  /// @dev kittys owner by the owner (array)\n', '  mapping (address => uint256[]) ownerTokittyArray;\n', '  /// @dev price of each token\n', '  mapping (uint256 => uint256) TokenIdToPrice;\n', '  /// @dev token count of kitty\n', '  mapping (uint32 => uint256) tokenCountOfkitty;\n', '  /// @dev tokens by the kitty\n', '  mapping (uint256 => uint32) IndexTokitty;\n', '  /// @dev The authorized address for each kitty\n', '  mapping (uint256 => address) kittyTokenIdToApprovals;\n', '  /// @dev The authorized operators for each address\n', '  mapping (address => mapping (address => bool)) operatorToApprovals;\n', '  mapping(uint256 => bool) tokenToSell;\n', '  \n', '\n', '  /*** CONSTRUCTOR ***/\n', '  /// @dev Amount of tokens destroyed\n', '  uint256 destroyKittyCount;\n', '  uint256 onAuction;\n', '  // modifier\n', '  /// @dev Check if token ID is valid\n', '  modifier isValidToken(uint256 _tokenId) {\n', '    require(_tokenId >= 1 && _tokenId <= kitties.length);\n', '    require(TokenIdToOwner[_tokenId] != address(0)); \n', '    _;\n', '  }\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(msg.sender == TokenIdToOwner[_tokenId]);\n', '    _;\n', '  }\n', '  /// @dev Creates a new kitty with the given name.\n', '  function CreateKittyToken(address _owner,uint256 _price, uint32 _cardId) public onlyAccess {\n', '    _createKittyToken(_owner,_price,_cardId);\n', '  }\n', '\n', '    /// For creating GiftToken\n', '  function _createKittyToken(address _owner, uint256 _price, uint32 _kittyId) \n', '  internal {\n', '    uint256 newTokenId = kitties.length;\n', '    Kitty memory _kitty = Kitty({\n', '      kittyId: _kittyId\n', '    });\n', '    kitties.push(_kitty);\n', '    //event\n', '    CreateGift(newTokenId, _kittyId, _owner, _price);\n', '    TokenIdToPrice[newTokenId] = _price;\n', '    IndexTokitty[newTokenId] = _kittyId;\n', '    tokenCountOfkitty[_kittyId] = SafeMath.add(tokenCountOfkitty[_kittyId],1);\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newTokenId);\n', '  } \n', '  /// @dev let owner set the token price\n', '  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {\n', '    require(TokenIdToOwner[_tokenId] == msg.sender);\n', '    TokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '    /// @dev set the token price\n', '  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {\n', '    TokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific tokenId.\n', '  /// @param _tokenId The tokenId of the captain\n', '  function getKittyInfo(uint256 _tokenId) external view returns (\n', '    uint32 kittyId,  \n', '    uint256 price,\n', '    address owner,\n', '    bool selled\n', '  ) {\n', '    Kitty storage kitty = kitties[_tokenId];\n', '    kittyId = kitty.kittyId;\n', '    price = TokenIdToPrice[_tokenId];\n', '    owner = TokenIdToOwner[_tokenId];\n', '    selled = tokenToSell[_tokenId];\n', '  }\n', '  /// @dev Do the real transfer with out any condition checking\n', '  /// @param _from The old owner of this kitty(If created: 0x0)\n', '  /// @param _to The new owner of this kitty \n', '  /// @param _tokenId The tokenId of the kitty\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '    if (_from != address(0)) {\n', '      uint256 indexFrom = kittyIdToOwnerIndex[_tokenId];  // tokenId -> kittyId\n', '      uint256[] storage cpArray = ownerTokittyArray[_from];\n', '      require(cpArray[indexFrom] == _tokenId);\n', '\n', '      // If the kitty is not the element of array, change it to with the last\n', '      if (indexFrom != cpArray.length - 1) {\n', '        uint256 lastTokenId = cpArray[cpArray.length - 1];\n', '        cpArray[indexFrom] = lastTokenId; \n', '        kittyIdToOwnerIndex[lastTokenId] = indexFrom;\n', '      }\n', '      cpArray.length -= 1; \n', '    \n', '      if (kittyTokenIdToApprovals[_tokenId] != address(0)) {\n', '        delete kittyTokenIdToApprovals[_tokenId];\n', '      }      \n', '    }\n', '\n', '    // Give the kitty to &#39;_to&#39;\n', '    TokenIdToOwner[_tokenId] = _to;\n', '    ownerTokittyArray[_to].push(_tokenId);\n', '    kittyIdToOwnerIndex[_tokenId] = ownerTokittyArray[_to].length - 1;\n', '        \n', '    Transfer(_from != address(0) ? _from : this, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Return all the auction tokens\n', '  function getAuctions() external view returns (uint256[]) {\n', '    uint256 totalgifts = kitties.length - destroyKittyCount - 1;\n', '\n', '    uint256[] memory result = new uint256[](onAuction);\n', '    uint256 tokenId = 1;\n', '    for (uint i=0;i< totalgifts;i++) {\n', '      if (tokenToSell[tokenId] == true) {\n', '        result[i] = tokenId;\n', '        tokenId ++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  /// ERC721 \n', '\n', '  function balanceOf(address _owner) external view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownerTokittyArray[_owner].length;\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address) {\n', '    return TokenIdToOwner[_tokenId];\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, data);\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /// @dev Actually perform the safeTransferFrom\n', '  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \n', '    internal\n', '    isValidToken(_tokenId) \n', '    canTransfer(_tokenId)\n', '    {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0) && owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '\n', '    // Do the callback after everything is done to avoid reentrancy attack\n', '    /*uint256 codeSize;\n', '    assembly { codeSize := extcodesize(_to) }\n', '    if (codeSize == 0) {\n', '      return;\n', '    }*/\n', '    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '    // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;\n', '    require(retval == 0xf0b9e5ba);\n', '  }\n', '    \n', '  /// @dev Transfer ownership of an kitty, &#39;_to&#39; must be a vaild address, or the WAR will lost\n', '  /// @param _from The current owner of the kitty\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The kitty to transfer\n', '  function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        external\n', '        whenNotPaused\n', '        isValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '        payable\n', '    {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Safe transfer by trust contracts\n', '  function safeTransferByContract(address _from,address _to, uint256 _tokenId) \n', '  external\n', '  whenNotPaused\n', '  {\n', '    require(actionContracts[msg.sender]);\n', '\n', '    require(_tokenId >= 1 && _tokenId <= kitties.length);\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(_to != address(0));\n', '    require(owner != _to);\n', '    require(_from == owner);\n', '\n', '    _transfer(owner, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Set or reaffirm the approved address for an kitty\n', '  /// @param _approved The new approved kitty controller\n', '  /// @param _tokenId The kitty to approve\n', '  function approve(address _approved, uint256 _tokenId)\n', '    external\n', '    whenNotPaused \n', '    payable\n', '  {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\n', '\n', '    kittyTokenIdToApprovals[_tokenId] = _approved;\n', '    Approval(owner, _approved, _tokenId);\n', '  }\n', '\n', '  /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.\n', '  /// @param _operator Address to add to the set of authorized operators.\n', '  /// @param _approved True if the operators is approved, false to revoke approval\n', '  function setApprovalForAll(address _operator, bool _approved) \n', '    external \n', '    whenNotPaused\n', '  {\n', '    operatorToApprovals[msg.sender][_operator] = _approved;\n', '    ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @dev Get the approved address for a single kitty\n', '  /// @param _tokenId The WAR to find the approved address for\n', '  /// @return The approved address for this WAR, or the zero address if there is none\n', '  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\n', '    return kittyTokenIdToApprovals[_tokenId];\n', '  }\n', '  \n', '  /// @dev Query if an address is an authorized operator for another address\n', '  /// @param _owner The address that owns the WARs\n', '  /// @param _operator The address that acts on behalf of the owner\n', '  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '    return operatorToApprovals[_owner][_operator];\n', '  }\n', '  /// @notice A descriptive name for a collection of NFTs in this contract\n', '  function name() public pure returns(string) {\n', '    return "Pirate Kitty Token";\n', '  }\n', '  /// @notice An abbreviated name for NFTs in this contract\n', '  function symbol() public pure returns(string) {\n', '    return "KCT";\n', '  }\n', '  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '  ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '  ///  Metadata JSON Schema".\n', '  //function tokenURI(uint256 _tokenId) external view returns (string);\n', '\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  function totalSupply() external view returns (uint256) {\n', '    return kitties.length - destroyKittyCount -1;\n', '  }\n', '  /// @notice Enumerate valid NFTs\n', '  /// @dev Throws if `_index` >= `totalSupply()`.\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for the `_index`th NFT,\n', '  ///  (sort order not specified)\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '    require(_index<(kitties.length - destroyKittyCount));\n', '    //return kittyIdToOwnerIndex[_index];\n', '    return _index;\n', '  }\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '    require(_index < ownerTokittyArray[_owner].length);\n', '    if (_owner != address(0)) {\n', '      uint256 tokenId = ownerTokittyArray[_owner][_index];\n', '      return tokenId;\n', '    }\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {\n', '    uint256 len = ownerTokittyArray[_owner].length;\n', '    uint256[] memory tokens = new uint256[](len);\n', '    uint32[] memory kittyss = new uint32[](len);\n', '    uint256 icount;\n', '    if (_owner != address(0)) {\n', '      for (uint256 i=0;i<len;i++) {\n', '        tokens[i] = ownerTokittyArray[_owner][icount];\n', '        kittyss[i] = IndexTokitty[ownerTokittyArray[_owner][icount]];\n', '        icount++;\n', '      }\n', '    }\n', '    return (tokens,kittyss);\n', '  }\n', '\n', '  /// @param _kittyId The kitty whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfkitty(uint32 _kittyId) public view returns(uint256[] kittyTokens) {\n', '    uint256 tokenCount = tokenCountOfkitty[_kittyId];\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalkitties = kitties.length - destroyKittyCount - 1;\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 tokenId;\n', '      for (tokenId = 0; tokenId <= totalkitties; tokenId++) {\n', '        if (IndexTokitty[tokenId] == _kittyId) {\n', '          result[resultIndex] = tokenId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  } \n', '}']
['pragma solidity ^0.4.18;\n', '/* ==================================================================== */\n', '/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\n', '/* \n', "/* https://www.pirateconquest.com One of the world's slg games of blockchain \n", '/*  \n', '/* authors rainy@livestar.com/Jonny.Fu@livestar.com\n', '/*                 \n', '/* ==================================================================== */\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', 'contract ERC721 /* is ERC165 */ {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function ownerOf(uint256 _tokenId) external view returns (address);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function approve(address _approved, uint256 _tokenId) external payable;\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', 'interface ERC165 {\n', '     function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x780e9d63\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /*\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() external onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() external onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract AccessAdmin is Pausable {\n', '\n', '  /// @dev Admin Address\n', '  mapping (address => bool) adminContracts;\n', '\n', '  /// @dev Trust contract\n', '  mapping (address => bool) actionContracts;\n', '\n', '  function setAdminContract(address _addr, bool _useful) public onlyOwner {\n', '    require(_addr != address(0));\n', '    adminContracts[_addr] = _useful;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    require(adminContracts[msg.sender]); \n', '    _;\n', '  }\n', '\n', '  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n', '    actionContracts[_actionAddr] = _useful;\n', '  }\n', '\n', '  modifier onlyAccess() {\n', '    require(actionContracts[msg.sender]);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', 'contract KittyToken is AccessAdmin, ERC721 {\n', '  using SafeMath for SafeMath;\n', '  //event \n', '  event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price);\n', '  //ERC721\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  struct Kitty {\n', '    uint32 kittyId;\n', '  }\n', '\n', '  Kitty[] public kitties; //dynamic Array\n', '  function KittyToken() public {\n', '    kitties.length += 1;\n', '    setAdminContract(msg.sender,true);\n', '    setActionContract(msg.sender,true);\n', '  }\n', '\n', '  /**MAPPING**/\n', '  /// @dev tokenId to owner  tokenId -> address\n', '  mapping (uint256 => address) public TokenIdToOwner;\n', '  /// @dev Equipment token ID search in owner array kittyId -> tokenId\n', '  mapping (uint256 => uint256) kittyIdToOwnerIndex;  \n', '  /// @dev kittys owner by the owner (array)\n', '  mapping (address => uint256[]) ownerTokittyArray;\n', '  /// @dev price of each token\n', '  mapping (uint256 => uint256) TokenIdToPrice;\n', '  /// @dev token count of kitty\n', '  mapping (uint32 => uint256) tokenCountOfkitty;\n', '  /// @dev tokens by the kitty\n', '  mapping (uint256 => uint32) IndexTokitty;\n', '  /// @dev The authorized address for each kitty\n', '  mapping (uint256 => address) kittyTokenIdToApprovals;\n', '  /// @dev The authorized operators for each address\n', '  mapping (address => mapping (address => bool)) operatorToApprovals;\n', '  mapping(uint256 => bool) tokenToSell;\n', '  \n', '\n', '  /*** CONSTRUCTOR ***/\n', '  /// @dev Amount of tokens destroyed\n', '  uint256 destroyKittyCount;\n', '  uint256 onAuction;\n', '  // modifier\n', '  /// @dev Check if token ID is valid\n', '  modifier isValidToken(uint256 _tokenId) {\n', '    require(_tokenId >= 1 && _tokenId <= kitties.length);\n', '    require(TokenIdToOwner[_tokenId] != address(0)); \n', '    _;\n', '  }\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(msg.sender == TokenIdToOwner[_tokenId]);\n', '    _;\n', '  }\n', '  /// @dev Creates a new kitty with the given name.\n', '  function CreateKittyToken(address _owner,uint256 _price, uint32 _cardId) public onlyAccess {\n', '    _createKittyToken(_owner,_price,_cardId);\n', '  }\n', '\n', '    /// For creating GiftToken\n', '  function _createKittyToken(address _owner, uint256 _price, uint32 _kittyId) \n', '  internal {\n', '    uint256 newTokenId = kitties.length;\n', '    Kitty memory _kitty = Kitty({\n', '      kittyId: _kittyId\n', '    });\n', '    kitties.push(_kitty);\n', '    //event\n', '    CreateGift(newTokenId, _kittyId, _owner, _price);\n', '    TokenIdToPrice[newTokenId] = _price;\n', '    IndexTokitty[newTokenId] = _kittyId;\n', '    tokenCountOfkitty[_kittyId] = SafeMath.add(tokenCountOfkitty[_kittyId],1);\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newTokenId);\n', '  } \n', '  /// @dev let owner set the token price\n', '  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {\n', '    require(TokenIdToOwner[_tokenId] == msg.sender);\n', '    TokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '    /// @dev set the token price\n', '  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {\n', '    TokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific tokenId.\n', '  /// @param _tokenId The tokenId of the captain\n', '  function getKittyInfo(uint256 _tokenId) external view returns (\n', '    uint32 kittyId,  \n', '    uint256 price,\n', '    address owner,\n', '    bool selled\n', '  ) {\n', '    Kitty storage kitty = kitties[_tokenId];\n', '    kittyId = kitty.kittyId;\n', '    price = TokenIdToPrice[_tokenId];\n', '    owner = TokenIdToOwner[_tokenId];\n', '    selled = tokenToSell[_tokenId];\n', '  }\n', '  /// @dev Do the real transfer with out any condition checking\n', '  /// @param _from The old owner of this kitty(If created: 0x0)\n', '  /// @param _to The new owner of this kitty \n', '  /// @param _tokenId The tokenId of the kitty\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '    if (_from != address(0)) {\n', '      uint256 indexFrom = kittyIdToOwnerIndex[_tokenId];  // tokenId -> kittyId\n', '      uint256[] storage cpArray = ownerTokittyArray[_from];\n', '      require(cpArray[indexFrom] == _tokenId);\n', '\n', '      // If the kitty is not the element of array, change it to with the last\n', '      if (indexFrom != cpArray.length - 1) {\n', '        uint256 lastTokenId = cpArray[cpArray.length - 1];\n', '        cpArray[indexFrom] = lastTokenId; \n', '        kittyIdToOwnerIndex[lastTokenId] = indexFrom;\n', '      }\n', '      cpArray.length -= 1; \n', '    \n', '      if (kittyTokenIdToApprovals[_tokenId] != address(0)) {\n', '        delete kittyTokenIdToApprovals[_tokenId];\n', '      }      \n', '    }\n', '\n', "    // Give the kitty to '_to'\n", '    TokenIdToOwner[_tokenId] = _to;\n', '    ownerTokittyArray[_to].push(_tokenId);\n', '    kittyIdToOwnerIndex[_tokenId] = ownerTokittyArray[_to].length - 1;\n', '        \n', '    Transfer(_from != address(0) ? _from : this, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Return all the auction tokens\n', '  function getAuctions() external view returns (uint256[]) {\n', '    uint256 totalgifts = kitties.length - destroyKittyCount - 1;\n', '\n', '    uint256[] memory result = new uint256[](onAuction);\n', '    uint256 tokenId = 1;\n', '    for (uint i=0;i< totalgifts;i++) {\n', '      if (tokenToSell[tokenId] == true) {\n', '        result[i] = tokenId;\n', '        tokenId ++;\n', '      }\n', '    }\n', '    return result;\n', '  }\n', '  /// ERC721 \n', '\n', '  function balanceOf(address _owner) external view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownerTokittyArray[_owner].length;\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address) {\n', '    return TokenIdToOwner[_tokenId];\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, data);\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /// @dev Actually perform the safeTransferFrom\n', '  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \n', '    internal\n', '    isValidToken(_tokenId) \n', '    canTransfer(_tokenId)\n', '    {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0) && owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '\n', '    // Do the callback after everything is done to avoid reentrancy attack\n', '    /*uint256 codeSize;\n', '    assembly { codeSize := extcodesize(_to) }\n', '    if (codeSize == 0) {\n', '      return;\n', '    }*/\n', '    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '    // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;\n', '    require(retval == 0xf0b9e5ba);\n', '  }\n', '    \n', "  /// @dev Transfer ownership of an kitty, '_to' must be a vaild address, or the WAR will lost\n", '  /// @param _from The current owner of the kitty\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The kitty to transfer\n', '  function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        external\n', '        whenNotPaused\n', '        isValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '        payable\n', '    {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Safe transfer by trust contracts\n', '  function safeTransferByContract(address _from,address _to, uint256 _tokenId) \n', '  external\n', '  whenNotPaused\n', '  {\n', '    require(actionContracts[msg.sender]);\n', '\n', '    require(_tokenId >= 1 && _tokenId <= kitties.length);\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(_to != address(0));\n', '    require(owner != _to);\n', '    require(_from == owner);\n', '\n', '    _transfer(owner, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Set or reaffirm the approved address for an kitty\n', '  /// @param _approved The new approved kitty controller\n', '  /// @param _tokenId The kitty to approve\n', '  function approve(address _approved, uint256 _tokenId)\n', '    external\n', '    whenNotPaused \n', '    payable\n', '  {\n', '    address owner = TokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\n', '\n', '    kittyTokenIdToApprovals[_tokenId] = _approved;\n', '    Approval(owner, _approved, _tokenId);\n', '  }\n', '\n', '  /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.\n', '  /// @param _operator Address to add to the set of authorized operators.\n', '  /// @param _approved True if the operators is approved, false to revoke approval\n', '  function setApprovalForAll(address _operator, bool _approved) \n', '    external \n', '    whenNotPaused\n', '  {\n', '    operatorToApprovals[msg.sender][_operator] = _approved;\n', '    ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @dev Get the approved address for a single kitty\n', '  /// @param _tokenId The WAR to find the approved address for\n', '  /// @return The approved address for this WAR, or the zero address if there is none\n', '  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\n', '    return kittyTokenIdToApprovals[_tokenId];\n', '  }\n', '  \n', '  /// @dev Query if an address is an authorized operator for another address\n', '  /// @param _owner The address that owns the WARs\n', '  /// @param _operator The address that acts on behalf of the owner\n', '  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '    return operatorToApprovals[_owner][_operator];\n', '  }\n', '  /// @notice A descriptive name for a collection of NFTs in this contract\n', '  function name() public pure returns(string) {\n', '    return "Pirate Kitty Token";\n', '  }\n', '  /// @notice An abbreviated name for NFTs in this contract\n', '  function symbol() public pure returns(string) {\n', '    return "KCT";\n', '  }\n', '  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '  ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '  ///  Metadata JSON Schema".\n', '  //function tokenURI(uint256 _tokenId) external view returns (string);\n', '\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  function totalSupply() external view returns (uint256) {\n', '    return kitties.length - destroyKittyCount -1;\n', '  }\n', '  /// @notice Enumerate valid NFTs\n', '  /// @dev Throws if `_index` >= `totalSupply()`.\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for the `_index`th NFT,\n', '  ///  (sort order not specified)\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '    require(_index<(kitties.length - destroyKittyCount));\n', '    //return kittyIdToOwnerIndex[_index];\n', '    return _index;\n', '  }\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '    require(_index < ownerTokittyArray[_owner].length);\n', '    if (_owner != address(0)) {\n', '      uint256 tokenId = ownerTokittyArray[_owner][_index];\n', '      return tokenId;\n', '    }\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', "  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {\n', '    uint256 len = ownerTokittyArray[_owner].length;\n', '    uint256[] memory tokens = new uint256[](len);\n', '    uint32[] memory kittyss = new uint32[](len);\n', '    uint256 icount;\n', '    if (_owner != address(0)) {\n', '      for (uint256 i=0;i<len;i++) {\n', '        tokens[i] = ownerTokittyArray[_owner][icount];\n', '        kittyss[i] = IndexTokitty[ownerTokittyArray[_owner][icount]];\n', '        icount++;\n', '      }\n', '    }\n', '    return (tokens,kittyss);\n', '  }\n', '\n', '  /// @param _kittyId The kitty whose celebrity tokens we are interested in.\n', "  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfkitty(uint32 _kittyId) public view returns(uint256[] kittyTokens) {\n', '    uint256 tokenCount = tokenCountOfkitty[_kittyId];\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalkitties = kitties.length - destroyKittyCount - 1;\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 tokenId;\n', '      for (tokenId = 0; tokenId <= totalkitties; tokenId++) {\n', '        if (IndexTokitty[tokenId] == _kittyId) {\n', '          result[resultIndex] = tokenId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  } \n', '}']
