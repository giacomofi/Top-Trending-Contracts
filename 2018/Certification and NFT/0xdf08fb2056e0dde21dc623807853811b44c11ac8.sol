['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', '    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it&#39;s safe to\n', '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/*\n', '    This is an abstract contract, inherited by Treasury, that manages\n', '    creating, cancelling, and executing admin requests that control\n', '    capital. It provides transparency, governence, and security.\n', '\n', '    In the future, the Admin account can be set to be a DAO.\n', '    \n', '    A Request:\n', '        - can only be created by Admin\n', '        - can be cancelled by Admin, if not yet executed\n', '        - can be executed after WAITING_TIME (1 week)\n', '        - cannot be executed after TIMEOUT_TIME (2 weeks)\n', '        - contains a type, target, and value\n', '        - when executed, calls corresponding `execute${type}()` method\n', '*/\n', 'contract Requestable is\n', '    UsingAdmin \n', '{\n', '    uint32 public constant WAITING_TIME = 60*60*24*7;   // 1 week\n', '    uint32 public constant TIMEOUT_TIME = 60*60*24*14;  // 2 weeks\n', '    uint32 public constant MAX_PENDING_REQUESTS = 10;\n', '\n', '    // Requests.\n', '    enum RequestType {SendCapital, RecallCapital, RaiseCapital, DistributeCapital}\n', '    struct Request {\n', '        // Params to handle state and history.\n', '        uint32 id;\n', '        uint8 typeId;\n', '        uint32 dateCreated;\n', '        uint32 dateCancelled;\n', '        uint32 dateExecuted;\n', '        string createdMsg;\n', '        string cancelledMsg;\n', '        string executedMsg;\n', '        bool executedSuccessfully;\n', '        // Params for execution.\n', '        address target;\n', '        uint value;\n', '    }\n', '    mapping (uint32 => Request) public requests;\n', '    uint32 public curRequestId;\n', '    uint32[] public completedRequestIds;\n', '    uint32[] public cancelledRequestIds;\n', '    uint32[] public pendingRequestIds;\n', '\n', '    // Events.\n', '    event RequestCreated(uint time, uint indexed id, uint indexed typeId, address indexed target, uint value, string msg);\n', '    event RequestCancelled(uint time, uint indexed id, uint indexed typeId, address indexed target, string msg);\n', '    event RequestExecuted(uint time, uint indexed id, uint indexed typeId, address indexed target, bool success, string msg);\n', '\n', '    constructor(address _registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    { }\n', '\n', '    // Creates a request, assigning it the next ID.\n', '    // Throws if there are already 8 pending requests.\n', '    function createRequest(uint _typeId, address _target, uint _value, string _msg)\n', '        public\n', '        fromAdmin\n', '    {\n', '        uint32 _id = ++curRequestId;\n', '        requests[_id].id = _id;\n', '        requests[_id].typeId = uint8(RequestType(_typeId));\n', '        requests[_id].dateCreated = uint32(now);\n', '        requests[_id].createdMsg = _msg;\n', '        requests[_id].target = _target;\n', '        requests[_id].value = _value;\n', '        _addPendingRequestId(_id);\n', '        emit RequestCreated(now, _id, _typeId, _target, _value, _msg);\n', '    }\n', '\n', '    // Cancels a request.\n', '    // Throws if already cancelled or executed.\n', '    function cancelRequest(uint32 _id, string _msg)\n', '        public\n', '        fromAdmin\n', '    {\n', '        // Require Request exists, is not cancelled, is not executed.\n', '        Request storage r = requests[_id];\n', '        require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0);\n', '        r.dateCancelled = uint32(now);\n', '        r.cancelledMsg = _msg;\n', '        _removePendingRequestId(_id);\n', '        cancelledRequestIds.push(_id);\n', '        emit RequestCancelled(now, r.id, r.typeId, r.target, _msg);\n', '    }\n', '\n', '    // Executes (or times out) a request if it is not already cancelled or executed.\n', '    // Note: This may revert if the executeFn() reverts. It&#39;ll time-out eventually.\n', '    function executeRequest(uint32 _id)\n', '        public\n', '    {\n', '        // Require Request exists, is not cancelled, is not executed.\n', '        // Also require is past WAITING_TIME since creation.\n', '        Request storage r = requests[_id];\n', '        require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0);\n', '        require(uint32(now) > r.dateCreated + WAITING_TIME);\n', '        \n', '        // If request timed out, cancel it.\n', '        if (uint32(now) > r.dateCreated + TIMEOUT_TIME) {\n', '            cancelRequest(_id, "Request timed out.");\n', '            return;\n', '        }\n', '                \n', '        // Execute concrete method after setting as executed.\n', '        r.dateExecuted = uint32(now);\n', '        string memory _msg;\n', '        bool _success;\n', '        RequestType _type = RequestType(r.typeId);\n', '        if (_type == RequestType.SendCapital) {\n', '            (_success, _msg) = executeSendCapital(r.target, r.value);\n', '        } else if (_type == RequestType.RecallCapital) {\n', '            (_success, _msg) = executeRecallCapital(r.target, r.value);\n', '        } else if (_type == RequestType.RaiseCapital) {\n', '            (_success, _msg) = executeRaiseCapital(r.value);\n', '        } else if (_type == RequestType.DistributeCapital) {\n', '            (_success, _msg) = executeDistributeCapital(r.value);\n', '        }\n', '\n', '        // Save results, and emit.\n', '        r.executedSuccessfully = _success;\n', '        r.executedMsg = _msg;\n', '        _removePendingRequestId(_id);\n', '        completedRequestIds.push(_id);\n', '        emit RequestExecuted(now, r.id, r.typeId, r.target, _success, _msg);\n', '    }\n', '\n', '    // Pushes id onto the array, throws if too many.\n', '    function _addPendingRequestId(uint32 _id)\n', '        private\n', '    {\n', '        require(pendingRequestIds.length != MAX_PENDING_REQUESTS);\n', '        pendingRequestIds.push(_id);\n', '    }\n', '\n', '    // Removes id from array, reduces array length by one.\n', '    // Throws if not found.\n', '    function _removePendingRequestId(uint32 _id)\n', '        private\n', '    {\n', '        // Find this id in the array, or throw.\n', '        uint _len = pendingRequestIds.length;\n', '        uint _foundIndex = MAX_PENDING_REQUESTS;\n', '        for (uint _i = 0; _i < _len; _i++) {\n', '            if (pendingRequestIds[_i] == _id) {\n', '                _foundIndex = _i;\n', '                break;\n', '            }\n', '        }\n', '        require(_foundIndex != MAX_PENDING_REQUESTS);\n', '\n', '        // Swap last element to this index, then delete last element.\n', '        pendingRequestIds[_foundIndex] = pendingRequestIds[_len-1];\n', '        pendingRequestIds.length--;\n', '    }\n', '\n', '    // These methods must be implemented by Treasury /////////////////\n', '    function executeSendCapital(address _target, uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeRecallCapital(address _target, uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeRaiseCapital(uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeDistributeCapital(uint _value)\n', '        internal returns (bool _success, string _msg);\n', '    //////////////////////////////////////////////////////////////////\n', '\n', '    // View that returns a Request as a valid tuple.\n', '    // Sorry for the formatting, but it&#39;s a waste of lines otherwise.\n', '    function getRequest(uint32 _requestId) public view returns (\n', '        uint32 _id, uint8 _typeId, address _target, uint _value,\n', '        bool _executedSuccessfully,\n', '        uint32 _dateCreated, uint32 _dateCancelled, uint32 _dateExecuted,\n', '        string _createdMsg, string _cancelledMsg, string _executedMsg       \n', '    ) {\n', '        Request memory r = requests[_requestId];\n', '        return (\n', '            r.id, r.typeId, r.target, r.value,\n', '            r.executedSuccessfully,\n', '            r.dateCreated, r.dateCancelled, r.dateExecuted,\n', '            r.createdMsg, r.cancelledMsg, r.executedMsg\n', '        );\n', '    }\n', '\n', '    function isRequestExecutable(uint32 _requestId)\n', '        public\n', '        view\n', '        returns (bool _isExecutable)\n', '    {\n', '        Request memory r = requests[_requestId];\n', '        _isExecutable = (r.id>0 && r.dateCancelled==0 && r.dateExecuted==0);\n', '        _isExecutable = _isExecutable && (uint32(now) > r.dateCreated + WAITING_TIME);\n', '        return _isExecutable;\n', '    }\n', '\n', '    // Return the lengths of arrays.\n', '    function numPendingRequests() public view returns (uint _num){\n', '        return pendingRequestIds.length;\n', '    }\n', '    function numCompletedRequests() public view returns (uint _num){\n', '        return completedRequestIds.length;\n', '    }\n', '    function numCancelledRequests() public view returns (uint _num){\n', '        return cancelledRequestIds.length;\n', '    }\n', '}\n', '\n', '/*\n', '\n', 'UI: https://www.pennyether.com/status/treasury\n', '\n', 'The Treasury manages 2 balances:\n', '\n', '    * capital: Ether that can be sent to bankrollable contracts.\n', '        - Is controlled via `Requester` governance, by the Admin (which is mutable)\n', '            - Capital received by Comptroller is considered "capitalRaised".\n', '            - A target amount can be set: "capitalRaisedTarget".\n', '            - Comptroller will sell Tokens to reach capitalRaisedTarget.\n', '        - Can be sent to Bankrollable contracts.\n', '        - Can be recalled from Bankrollable contracts.\n', '        - Allocation in-total and per-contract is available.\n', '\n', '    * profits: Ether received via fallback fn. Can be sent to Token at any time.\n', '        - Are received via fallback function, typically by bankrolled contracts.\n', '        - Can be sent to Token at any time, by anyone, via .issueDividend()\n', '\n', 'All Ether entering and leaving Treasury is allocated to one of the three balances.\n', 'Thus, the balance of Treasury will always equal: capital + profits.\n', '\n', 'Roles:\n', '    Owner:       can set Comptroller and Token addresses, once.\n', '    Comptroller: can add and remove "raised" capital\n', '    Admin:       can trigger requests.\n', '    Token:       receives profits via .issueDividend().\n', '    Anybody:     can call .issueDividend()\n', '                 can call .addCapital()\n', '\n', '*/\n', '// Allows Treasury to add/remove capital to/from Bankrollable instances.\n', 'interface _ITrBankrollable {\n', '    function removeBankroll(uint _amount, string _callbackFn) external;\n', '    function addBankroll() external payable;\n', '}\n', 'interface _ITrComptroller {\n', '    function treasury() external view returns (address);\n', '    function token() external view returns (address);\n', '    function wasSaleEnded() external view returns (bool);\n', '}\n', '\n', 'contract Treasury is\n', '    Requestable\n', '{\n', '    // Address that can initComptroller\n', '    address public owner;\n', '    // Capital sent from this address is considered "capitalRaised"\n', '    // This also contains the token that dividends will be sent to.\n', '    _ITrComptroller public comptroller;\n', '\n', '    // Balances\n', '    uint public capital;  // Ether held as capital. Sendable/Recallable via Requests\n', '    uint public profits;  // Ether received via fallback fn. Distributable only to Token.\n', '    \n', '    // Capital Management\n', '    uint public capitalRaised;        // The amount of capital raised from Comptroller.\n', '    uint public capitalRaisedTarget;  // The target amount of capitalRaised.\n', '    Ledger public capitalLedger;      // Tracks capital allocated per address\n', '\n', '    // Stats\n', '    uint public profitsSent;          // Total profits ever sent.\n', '    uint public profitsTotal;         // Total profits ever received.\n', '\n', '    // EVENTS\n', '    event Created(uint time);\n', '    // Admin triggered events\n', '    event ComptrollerSet(uint time, address comptroller, address token);\n', '    // capital-related events\n', '    event CapitalAdded(uint time, address indexed sender, uint amount);\n', '    event CapitalRemoved(uint time, address indexed recipient, uint amount);\n', '    event CapitalRaised(uint time, uint amount);\n', '    // profit-related events\n', '    event ProfitsReceived(uint time, address indexed sender, uint amount);\n', '    // request-related events\n', '    event ExecutedSendCapital(uint time, address indexed bankrollable, uint amount);\n', '    event ExecutedRecallCapital(uint time, address indexed bankrollable, uint amount);\n', '    event ExecutedRaiseCapital(uint time, uint amount);\n', '    event ExecutedDistributeCapital(uint time, uint amount);\n', '    // dividend events\n', '    event DividendSuccess(uint time, address token, uint amount);\n', '    event DividendFailure(uint time, string msg);\n', '\n', '    // `Requester` provides .fromAdmin() and requires implementation of:\n', '    //   - executeSendCapital\n', '    //   - executeRecallCapital\n', '    //   - executeRaiseCapital\n', '    constructor(address _registry, address _owner)\n', '        Requestable(_registry)\n', '        public\n', '    {\n', '        owner = _owner;\n', '        capitalLedger = new Ledger(this);\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** OWNER FUNCTIONS *****************************/\n', '    /*************************************************************/\n', '\n', '    // Callable once to set the Comptroller address\n', '    function initComptroller(_ITrComptroller _comptroller)\n', '        public\n', '    {\n', '        // only owner can call this.\n', '        require(msg.sender == owner);\n', '        // comptroller must not already be set.\n', '        require(address(comptroller) == address(0));\n', '        // comptroller&#39;s treasury must point to this.\n', '        require(_comptroller.treasury() == address(this));\n', '        comptroller = _comptroller;\n', '        emit ComptrollerSet(now, _comptroller, comptroller.token());\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******* PROFITS AND DIVIDENDS *******************************/\n', '    /*************************************************************/\n', '\n', '    // Can receive Ether from anyone. Typically Bankrollable contracts&#39; profits.\n', '    function () public payable {\n', '        profits += msg.value;\n', '        profitsTotal += msg.value;\n', '        emit ProfitsReceived(now, msg.sender, msg.value);\n', '    }\n', '\n', '    // Sends profits to Token\n', '    function issueDividend()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        // Ensure token is set.\n', '        if (address(comptroller) == address(0)) {\n', '            emit DividendFailure(now, "Comptroller not yet set.");\n', '            return;\n', '        }\n', '        // Ensure the CrowdSale is completed\n', '        if (comptroller.wasSaleEnded() == false) {\n', '            emit DividendFailure(now, "CrowdSale not yet completed.");\n', '            return;\n', '        }\n', '        // Load _profits to memory (saves gas), and ensure there are profits.\n', '        _profits = profits;\n', '        if (_profits <= 0) {\n', '            emit DividendFailure(now, "No profits to send.");\n', '            return;\n', '        }\n', '\n', '        // Set profits to 0, and send to Token\n', '        address _token = comptroller.token();\n', '        profits = 0;\n', '        profitsSent += _profits;\n', '        require(_token.call.value(_profits)());\n', '        emit DividendSuccess(now, _token, _profits);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** ADDING CAPITAL ******************************/\n', '    /*************************************************************/ \n', '\n', '    // Anyone can add capital at any time.\n', '    // If it comes from Comptroller, it counts as capitalRaised.\n', '    function addCapital()\n', '        public\n', '        payable\n', '    {\n', '        capital += msg.value;\n', '        if (msg.sender == address(comptroller)) {\n', '            capitalRaised += msg.value;\n', '            emit CapitalRaised(now, msg.value);\n', '        }\n', '        emit CapitalAdded(now, msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** REQUESTER IMPLEMENTATION ********************/\n', '    /*************************************************************/\n', '\n', '    // Removes from capital, sends it to Bankrollable target.\n', '    function executeSendCapital(address _bankrollable, uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // Fail if we do not have the capital available.\n', '        if (_value > capital)\n', '            return (false, "Not enough capital.");\n', '        // Fail if target is not Bankrollable\n', '        if (!_hasCorrectTreasury(_bankrollable))\n', '            return (false, "Bankrollable does not have correct Treasury.");\n', '\n', '        // Decrease capital, increase bankrolled\n', '        capital -= _value;\n', '        capitalLedger.add(_bankrollable, _value);\n', '\n', '        // Send it (this throws on failure). Then emit events.\n', '        _ITrBankrollable(_bankrollable).addBankroll.value(_value)();\n', '        emit CapitalRemoved(now, _bankrollable, _value);\n', '        emit ExecutedSendCapital(now, _bankrollable, _value);\n', '        return (true, "Sent bankroll to target.");\n', '    }\n', '\n', '    // Calls ".removeBankroll()" on Bankrollable target.\n', '    function executeRecallCapital(address _bankrollable, uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // This should call .addCapital(), incrementing capital.\n', '        uint _prevCapital = capital;\n', '        _ITrBankrollable(_bankrollable).removeBankroll(_value, "addCapital()");\n', '        uint _recalled = capital - _prevCapital;\n', '        capitalLedger.subtract(_bankrollable, _recalled);\n', '        \n', '        // Emit and return\n', '        emit ExecutedRecallCapital(now, _bankrollable, _recalled);\n', '        return (true, "Received bankoll back from target.");\n', '    }\n', '\n', '    // Increases capitalRaisedTarget\n', '    function executeRaiseCapital(uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // Increase target amount.\n', '        capitalRaisedTarget += _value;\n', '        emit ExecutedRaiseCapital(now, _value);\n', '        return (true, "Capital target raised.");\n', '    }\n', '\n', '    // Moves capital to profits\n', '    function executeDistributeCapital(uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        if (_value > capital)\n', '            return (false, "Not enough capital.");\n', '        capital -= _value;\n', '        profits += _value;\n', '        profitsTotal += _value;\n', '        emit CapitalRemoved(now, this, _value);\n', '        emit ProfitsReceived(now, this, _value);\n', '        emit ExecutedDistributeCapital(now, _value);\n', '        return (true, "Capital moved to profits.");\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** PUBLIC VIEWS ********************************/\n', '    /*************************************************************/\n', '\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return profitsSent + profits;\n', '    }\n', '\n', '    function profitsSendable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        if (address(comptroller)==0) return 0;\n', '        if (!comptroller.wasSaleEnded()) return 0;\n', '        return profits;\n', '    }\n', '\n', '    // Returns the amount of capital needed to reach capitalRaisedTarget.\n', '    function capitalNeeded()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalRaisedTarget > capitalRaised\n', '            ? capitalRaisedTarget - capitalRaised\n', '            : 0;\n', '    }\n', '\n', '    // Returns the total amount of capital allocated\n', '    function capitalAllocated()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalLedger.total();\n', '    }\n', '\n', '    // Returns amount of capital allocated to an address\n', '    function capitalAllocatedTo(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalLedger.balanceOf(_addr);\n', '    }\n', '\n', '    // Returns the full capital allocation table\n', '    function capitalAllocation()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _amounts)\n', '    {\n', '        return capitalLedger.balances();\n', '    }\n', '\n', '    // Returns if _addr.getTreasury() returns this address.\n', '    // This is not fool-proof, but should prevent accidentally\n', '    //  sending capital to non-bankrollable addresses.\n', '    function _hasCorrectTreasury(address _addr)\n', '        private\n', '        returns (bool)\n', '    {\n', '        bytes32 _sig = bytes4(keccak256("getTreasury()"));\n', '        bool _success;\n', '        address _response;\n', '        assembly {\n', '            let x := mload(0x40)    // get free memory\n', '            mstore(x, _sig)         // store signature into it\n', '            // store if call was successful\n', '            _success := call(\n', '                10000,  // 10k gas\n', '                _addr,  // to _addr\n', '                0,      // 0 value\n', '                x,      // input is x\n', '                4,      // input length is 4\n', '                x,      // store output to x\n', '                32      // store first return value\n', '            )\n', '            // store first return value to _response\n', '            _response := mload(x)\n', '        }\n', '        return _success ? _response == address(this) : false;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', "    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\n", '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/*\n', '    This is an abstract contract, inherited by Treasury, that manages\n', '    creating, cancelling, and executing admin requests that control\n', '    capital. It provides transparency, governence, and security.\n', '\n', '    In the future, the Admin account can be set to be a DAO.\n', '    \n', '    A Request:\n', '        - can only be created by Admin\n', '        - can be cancelled by Admin, if not yet executed\n', '        - can be executed after WAITING_TIME (1 week)\n', '        - cannot be executed after TIMEOUT_TIME (2 weeks)\n', '        - contains a type, target, and value\n', '        - when executed, calls corresponding `execute${type}()` method\n', '*/\n', 'contract Requestable is\n', '    UsingAdmin \n', '{\n', '    uint32 public constant WAITING_TIME = 60*60*24*7;   // 1 week\n', '    uint32 public constant TIMEOUT_TIME = 60*60*24*14;  // 2 weeks\n', '    uint32 public constant MAX_PENDING_REQUESTS = 10;\n', '\n', '    // Requests.\n', '    enum RequestType {SendCapital, RecallCapital, RaiseCapital, DistributeCapital}\n', '    struct Request {\n', '        // Params to handle state and history.\n', '        uint32 id;\n', '        uint8 typeId;\n', '        uint32 dateCreated;\n', '        uint32 dateCancelled;\n', '        uint32 dateExecuted;\n', '        string createdMsg;\n', '        string cancelledMsg;\n', '        string executedMsg;\n', '        bool executedSuccessfully;\n', '        // Params for execution.\n', '        address target;\n', '        uint value;\n', '    }\n', '    mapping (uint32 => Request) public requests;\n', '    uint32 public curRequestId;\n', '    uint32[] public completedRequestIds;\n', '    uint32[] public cancelledRequestIds;\n', '    uint32[] public pendingRequestIds;\n', '\n', '    // Events.\n', '    event RequestCreated(uint time, uint indexed id, uint indexed typeId, address indexed target, uint value, string msg);\n', '    event RequestCancelled(uint time, uint indexed id, uint indexed typeId, address indexed target, string msg);\n', '    event RequestExecuted(uint time, uint indexed id, uint indexed typeId, address indexed target, bool success, string msg);\n', '\n', '    constructor(address _registry)\n', '        UsingAdmin(_registry)\n', '        public\n', '    { }\n', '\n', '    // Creates a request, assigning it the next ID.\n', '    // Throws if there are already 8 pending requests.\n', '    function createRequest(uint _typeId, address _target, uint _value, string _msg)\n', '        public\n', '        fromAdmin\n', '    {\n', '        uint32 _id = ++curRequestId;\n', '        requests[_id].id = _id;\n', '        requests[_id].typeId = uint8(RequestType(_typeId));\n', '        requests[_id].dateCreated = uint32(now);\n', '        requests[_id].createdMsg = _msg;\n', '        requests[_id].target = _target;\n', '        requests[_id].value = _value;\n', '        _addPendingRequestId(_id);\n', '        emit RequestCreated(now, _id, _typeId, _target, _value, _msg);\n', '    }\n', '\n', '    // Cancels a request.\n', '    // Throws if already cancelled or executed.\n', '    function cancelRequest(uint32 _id, string _msg)\n', '        public\n', '        fromAdmin\n', '    {\n', '        // Require Request exists, is not cancelled, is not executed.\n', '        Request storage r = requests[_id];\n', '        require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0);\n', '        r.dateCancelled = uint32(now);\n', '        r.cancelledMsg = _msg;\n', '        _removePendingRequestId(_id);\n', '        cancelledRequestIds.push(_id);\n', '        emit RequestCancelled(now, r.id, r.typeId, r.target, _msg);\n', '    }\n', '\n', '    // Executes (or times out) a request if it is not already cancelled or executed.\n', "    // Note: This may revert if the executeFn() reverts. It'll time-out eventually.\n", '    function executeRequest(uint32 _id)\n', '        public\n', '    {\n', '        // Require Request exists, is not cancelled, is not executed.\n', '        // Also require is past WAITING_TIME since creation.\n', '        Request storage r = requests[_id];\n', '        require(r.id != 0 && r.dateCancelled == 0 && r.dateExecuted == 0);\n', '        require(uint32(now) > r.dateCreated + WAITING_TIME);\n', '        \n', '        // If request timed out, cancel it.\n', '        if (uint32(now) > r.dateCreated + TIMEOUT_TIME) {\n', '            cancelRequest(_id, "Request timed out.");\n', '            return;\n', '        }\n', '                \n', '        // Execute concrete method after setting as executed.\n', '        r.dateExecuted = uint32(now);\n', '        string memory _msg;\n', '        bool _success;\n', '        RequestType _type = RequestType(r.typeId);\n', '        if (_type == RequestType.SendCapital) {\n', '            (_success, _msg) = executeSendCapital(r.target, r.value);\n', '        } else if (_type == RequestType.RecallCapital) {\n', '            (_success, _msg) = executeRecallCapital(r.target, r.value);\n', '        } else if (_type == RequestType.RaiseCapital) {\n', '            (_success, _msg) = executeRaiseCapital(r.value);\n', '        } else if (_type == RequestType.DistributeCapital) {\n', '            (_success, _msg) = executeDistributeCapital(r.value);\n', '        }\n', '\n', '        // Save results, and emit.\n', '        r.executedSuccessfully = _success;\n', '        r.executedMsg = _msg;\n', '        _removePendingRequestId(_id);\n', '        completedRequestIds.push(_id);\n', '        emit RequestExecuted(now, r.id, r.typeId, r.target, _success, _msg);\n', '    }\n', '\n', '    // Pushes id onto the array, throws if too many.\n', '    function _addPendingRequestId(uint32 _id)\n', '        private\n', '    {\n', '        require(pendingRequestIds.length != MAX_PENDING_REQUESTS);\n', '        pendingRequestIds.push(_id);\n', '    }\n', '\n', '    // Removes id from array, reduces array length by one.\n', '    // Throws if not found.\n', '    function _removePendingRequestId(uint32 _id)\n', '        private\n', '    {\n', '        // Find this id in the array, or throw.\n', '        uint _len = pendingRequestIds.length;\n', '        uint _foundIndex = MAX_PENDING_REQUESTS;\n', '        for (uint _i = 0; _i < _len; _i++) {\n', '            if (pendingRequestIds[_i] == _id) {\n', '                _foundIndex = _i;\n', '                break;\n', '            }\n', '        }\n', '        require(_foundIndex != MAX_PENDING_REQUESTS);\n', '\n', '        // Swap last element to this index, then delete last element.\n', '        pendingRequestIds[_foundIndex] = pendingRequestIds[_len-1];\n', '        pendingRequestIds.length--;\n', '    }\n', '\n', '    // These methods must be implemented by Treasury /////////////////\n', '    function executeSendCapital(address _target, uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeRecallCapital(address _target, uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeRaiseCapital(uint _value)\n', '        internal returns (bool _success, string _msg);\n', '\n', '    function executeDistributeCapital(uint _value)\n', '        internal returns (bool _success, string _msg);\n', '    //////////////////////////////////////////////////////////////////\n', '\n', '    // View that returns a Request as a valid tuple.\n', "    // Sorry for the formatting, but it's a waste of lines otherwise.\n", '    function getRequest(uint32 _requestId) public view returns (\n', '        uint32 _id, uint8 _typeId, address _target, uint _value,\n', '        bool _executedSuccessfully,\n', '        uint32 _dateCreated, uint32 _dateCancelled, uint32 _dateExecuted,\n', '        string _createdMsg, string _cancelledMsg, string _executedMsg       \n', '    ) {\n', '        Request memory r = requests[_requestId];\n', '        return (\n', '            r.id, r.typeId, r.target, r.value,\n', '            r.executedSuccessfully,\n', '            r.dateCreated, r.dateCancelled, r.dateExecuted,\n', '            r.createdMsg, r.cancelledMsg, r.executedMsg\n', '        );\n', '    }\n', '\n', '    function isRequestExecutable(uint32 _requestId)\n', '        public\n', '        view\n', '        returns (bool _isExecutable)\n', '    {\n', '        Request memory r = requests[_requestId];\n', '        _isExecutable = (r.id>0 && r.dateCancelled==0 && r.dateExecuted==0);\n', '        _isExecutable = _isExecutable && (uint32(now) > r.dateCreated + WAITING_TIME);\n', '        return _isExecutable;\n', '    }\n', '\n', '    // Return the lengths of arrays.\n', '    function numPendingRequests() public view returns (uint _num){\n', '        return pendingRequestIds.length;\n', '    }\n', '    function numCompletedRequests() public view returns (uint _num){\n', '        return completedRequestIds.length;\n', '    }\n', '    function numCancelledRequests() public view returns (uint _num){\n', '        return cancelledRequestIds.length;\n', '    }\n', '}\n', '\n', '/*\n', '\n', 'UI: https://www.pennyether.com/status/treasury\n', '\n', 'The Treasury manages 2 balances:\n', '\n', '    * capital: Ether that can be sent to bankrollable contracts.\n', '        - Is controlled via `Requester` governance, by the Admin (which is mutable)\n', '            - Capital received by Comptroller is considered "capitalRaised".\n', '            - A target amount can be set: "capitalRaisedTarget".\n', '            - Comptroller will sell Tokens to reach capitalRaisedTarget.\n', '        - Can be sent to Bankrollable contracts.\n', '        - Can be recalled from Bankrollable contracts.\n', '        - Allocation in-total and per-contract is available.\n', '\n', '    * profits: Ether received via fallback fn. Can be sent to Token at any time.\n', '        - Are received via fallback function, typically by bankrolled contracts.\n', '        - Can be sent to Token at any time, by anyone, via .issueDividend()\n', '\n', 'All Ether entering and leaving Treasury is allocated to one of the three balances.\n', 'Thus, the balance of Treasury will always equal: capital + profits.\n', '\n', 'Roles:\n', '    Owner:       can set Comptroller and Token addresses, once.\n', '    Comptroller: can add and remove "raised" capital\n', '    Admin:       can trigger requests.\n', '    Token:       receives profits via .issueDividend().\n', '    Anybody:     can call .issueDividend()\n', '                 can call .addCapital()\n', '\n', '*/\n', '// Allows Treasury to add/remove capital to/from Bankrollable instances.\n', 'interface _ITrBankrollable {\n', '    function removeBankroll(uint _amount, string _callbackFn) external;\n', '    function addBankroll() external payable;\n', '}\n', 'interface _ITrComptroller {\n', '    function treasury() external view returns (address);\n', '    function token() external view returns (address);\n', '    function wasSaleEnded() external view returns (bool);\n', '}\n', '\n', 'contract Treasury is\n', '    Requestable\n', '{\n', '    // Address that can initComptroller\n', '    address public owner;\n', '    // Capital sent from this address is considered "capitalRaised"\n', '    // This also contains the token that dividends will be sent to.\n', '    _ITrComptroller public comptroller;\n', '\n', '    // Balances\n', '    uint public capital;  // Ether held as capital. Sendable/Recallable via Requests\n', '    uint public profits;  // Ether received via fallback fn. Distributable only to Token.\n', '    \n', '    // Capital Management\n', '    uint public capitalRaised;        // The amount of capital raised from Comptroller.\n', '    uint public capitalRaisedTarget;  // The target amount of capitalRaised.\n', '    Ledger public capitalLedger;      // Tracks capital allocated per address\n', '\n', '    // Stats\n', '    uint public profitsSent;          // Total profits ever sent.\n', '    uint public profitsTotal;         // Total profits ever received.\n', '\n', '    // EVENTS\n', '    event Created(uint time);\n', '    // Admin triggered events\n', '    event ComptrollerSet(uint time, address comptroller, address token);\n', '    // capital-related events\n', '    event CapitalAdded(uint time, address indexed sender, uint amount);\n', '    event CapitalRemoved(uint time, address indexed recipient, uint amount);\n', '    event CapitalRaised(uint time, uint amount);\n', '    // profit-related events\n', '    event ProfitsReceived(uint time, address indexed sender, uint amount);\n', '    // request-related events\n', '    event ExecutedSendCapital(uint time, address indexed bankrollable, uint amount);\n', '    event ExecutedRecallCapital(uint time, address indexed bankrollable, uint amount);\n', '    event ExecutedRaiseCapital(uint time, uint amount);\n', '    event ExecutedDistributeCapital(uint time, uint amount);\n', '    // dividend events\n', '    event DividendSuccess(uint time, address token, uint amount);\n', '    event DividendFailure(uint time, string msg);\n', '\n', '    // `Requester` provides .fromAdmin() and requires implementation of:\n', '    //   - executeSendCapital\n', '    //   - executeRecallCapital\n', '    //   - executeRaiseCapital\n', '    constructor(address _registry, address _owner)\n', '        Requestable(_registry)\n', '        public\n', '    {\n', '        owner = _owner;\n', '        capitalLedger = new Ledger(this);\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** OWNER FUNCTIONS *****************************/\n', '    /*************************************************************/\n', '\n', '    // Callable once to set the Comptroller address\n', '    function initComptroller(_ITrComptroller _comptroller)\n', '        public\n', '    {\n', '        // only owner can call this.\n', '        require(msg.sender == owner);\n', '        // comptroller must not already be set.\n', '        require(address(comptroller) == address(0));\n', "        // comptroller's treasury must point to this.\n", '        require(_comptroller.treasury() == address(this));\n', '        comptroller = _comptroller;\n', '        emit ComptrollerSet(now, _comptroller, comptroller.token());\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /******* PROFITS AND DIVIDENDS *******************************/\n', '    /*************************************************************/\n', '\n', "    // Can receive Ether from anyone. Typically Bankrollable contracts' profits.\n", '    function () public payable {\n', '        profits += msg.value;\n', '        profitsTotal += msg.value;\n', '        emit ProfitsReceived(now, msg.sender, msg.value);\n', '    }\n', '\n', '    // Sends profits to Token\n', '    function issueDividend()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        // Ensure token is set.\n', '        if (address(comptroller) == address(0)) {\n', '            emit DividendFailure(now, "Comptroller not yet set.");\n', '            return;\n', '        }\n', '        // Ensure the CrowdSale is completed\n', '        if (comptroller.wasSaleEnded() == false) {\n', '            emit DividendFailure(now, "CrowdSale not yet completed.");\n', '            return;\n', '        }\n', '        // Load _profits to memory (saves gas), and ensure there are profits.\n', '        _profits = profits;\n', '        if (_profits <= 0) {\n', '            emit DividendFailure(now, "No profits to send.");\n', '            return;\n', '        }\n', '\n', '        // Set profits to 0, and send to Token\n', '        address _token = comptroller.token();\n', '        profits = 0;\n', '        profitsSent += _profits;\n', '        require(_token.call.value(_profits)());\n', '        emit DividendSuccess(now, _token, _profits);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** ADDING CAPITAL ******************************/\n', '    /*************************************************************/ \n', '\n', '    // Anyone can add capital at any time.\n', '    // If it comes from Comptroller, it counts as capitalRaised.\n', '    function addCapital()\n', '        public\n', '        payable\n', '    {\n', '        capital += msg.value;\n', '        if (msg.sender == address(comptroller)) {\n', '            capitalRaised += msg.value;\n', '            emit CapitalRaised(now, msg.value);\n', '        }\n', '        emit CapitalAdded(now, msg.sender, msg.value);\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** REQUESTER IMPLEMENTATION ********************/\n', '    /*************************************************************/\n', '\n', '    // Removes from capital, sends it to Bankrollable target.\n', '    function executeSendCapital(address _bankrollable, uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // Fail if we do not have the capital available.\n', '        if (_value > capital)\n', '            return (false, "Not enough capital.");\n', '        // Fail if target is not Bankrollable\n', '        if (!_hasCorrectTreasury(_bankrollable))\n', '            return (false, "Bankrollable does not have correct Treasury.");\n', '\n', '        // Decrease capital, increase bankrolled\n', '        capital -= _value;\n', '        capitalLedger.add(_bankrollable, _value);\n', '\n', '        // Send it (this throws on failure). Then emit events.\n', '        _ITrBankrollable(_bankrollable).addBankroll.value(_value)();\n', '        emit CapitalRemoved(now, _bankrollable, _value);\n', '        emit ExecutedSendCapital(now, _bankrollable, _value);\n', '        return (true, "Sent bankroll to target.");\n', '    }\n', '\n', '    // Calls ".removeBankroll()" on Bankrollable target.\n', '    function executeRecallCapital(address _bankrollable, uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // This should call .addCapital(), incrementing capital.\n', '        uint _prevCapital = capital;\n', '        _ITrBankrollable(_bankrollable).removeBankroll(_value, "addCapital()");\n', '        uint _recalled = capital - _prevCapital;\n', '        capitalLedger.subtract(_bankrollable, _recalled);\n', '        \n', '        // Emit and return\n', '        emit ExecutedRecallCapital(now, _bankrollable, _recalled);\n', '        return (true, "Received bankoll back from target.");\n', '    }\n', '\n', '    // Increases capitalRaisedTarget\n', '    function executeRaiseCapital(uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        // Increase target amount.\n', '        capitalRaisedTarget += _value;\n', '        emit ExecutedRaiseCapital(now, _value);\n', '        return (true, "Capital target raised.");\n', '    }\n', '\n', '    // Moves capital to profits\n', '    function executeDistributeCapital(uint _value)\n', '        internal\n', '        returns (bool _success, string _result)\n', '    {\n', '        if (_value > capital)\n', '            return (false, "Not enough capital.");\n', '        capital -= _value;\n', '        profits += _value;\n', '        profitsTotal += _value;\n', '        emit CapitalRemoved(now, this, _value);\n', '        emit ProfitsReceived(now, this, _value);\n', '        emit ExecutedDistributeCapital(now, _value);\n', '        return (true, "Capital moved to profits.");\n', '    }\n', '\n', '\n', '    /*************************************************************/\n', '    /*************** PUBLIC VIEWS ********************************/\n', '    /*************************************************************/\n', '\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return profitsSent + profits;\n', '    }\n', '\n', '    function profitsSendable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        if (address(comptroller)==0) return 0;\n', '        if (!comptroller.wasSaleEnded()) return 0;\n', '        return profits;\n', '    }\n', '\n', '    // Returns the amount of capital needed to reach capitalRaisedTarget.\n', '    function capitalNeeded()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalRaisedTarget > capitalRaised\n', '            ? capitalRaisedTarget - capitalRaised\n', '            : 0;\n', '    }\n', '\n', '    // Returns the total amount of capital allocated\n', '    function capitalAllocated()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalLedger.total();\n', '    }\n', '\n', '    // Returns amount of capital allocated to an address\n', '    function capitalAllocatedTo(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return capitalLedger.balanceOf(_addr);\n', '    }\n', '\n', '    // Returns the full capital allocation table\n', '    function capitalAllocation()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _amounts)\n', '    {\n', '        return capitalLedger.balances();\n', '    }\n', '\n', '    // Returns if _addr.getTreasury() returns this address.\n', '    // This is not fool-proof, but should prevent accidentally\n', '    //  sending capital to non-bankrollable addresses.\n', '    function _hasCorrectTreasury(address _addr)\n', '        private\n', '        returns (bool)\n', '    {\n', '        bytes32 _sig = bytes4(keccak256("getTreasury()"));\n', '        bool _success;\n', '        address _response;\n', '        assembly {\n', '            let x := mload(0x40)    // get free memory\n', '            mstore(x, _sig)         // store signature into it\n', '            // store if call was successful\n', '            _success := call(\n', '                10000,  // 10k gas\n', '                _addr,  // to _addr\n', '                0,      // 0 value\n', '                x,      // input is x\n', '                4,      // input length is 4\n', '                x,      // store output to x\n', '                32      // store first return value\n', '            )\n', '            // store first return value to _response\n', '            _response := mload(x)\n', '        }\n', '        return _success ? _response == address(this) : false;\n', '    }\n', '}']
