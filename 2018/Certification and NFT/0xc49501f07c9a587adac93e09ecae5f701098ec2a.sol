['pragma solidity 0.4.21;\n', '\n', '// Wolf Crypto presale pooling library\n', '// written by @iamdefinitelyahuman\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) return 0;\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ERC20 {\n', '  function balanceOf(address _owner) external returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) external returns (bool success);\n', '}\n', '\n', 'interface WhiteList {\n', '   function checkMemberLevel (address addr) external view returns (uint);\n', '}\n', '\n', 'library PresaleLib {\n', '\t\n', '  using SafeMath for uint;\n', '  \n', '  WhiteList constant whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63);\n', '  uint constant contributionMin = 100000000000000000;\n', '  uint constant maxGasPrice = 50000000000;\n', '  \n', '  struct Contributor {\n', '    uint16 claimedTokensIndex;\n', '    uint balance;\n', '  }\n', '  \n', '  struct Data {\n', '    address owner;\n', '    address receiver;\n', '    address[] withdrawToken;\n', '    bool poolSubmitted;\n', '    bool locked;\n', '    uint addressSetTime;\n', '    uint fee;\n', '    uint contractCap;\n', '    uint finalBalance;\n', '    uint[] withdrawAmount;\n', '    uint[] capAmounts;\n', '    uint32[] capTimes;\n', '    mapping (address => uint) tokenBalances;\n', '    mapping (address => uint) individualCaps;\n', '    mapping (address => Contributor) contributorMap;\n', '  }\n', '  \n', '  event ContributorBalanceChanged (address contributor, uint totalBalance);\n', '  event ReceiverAddressSet ( address addr);\n', '  event PoolSubmitted (address receiver, uint amount);\n', '  event WithdrawalAvailable (address token);\n', '  event WithdrawalClaimed (address receiver, address token, uint amount);\n', '  \n', '  modifier onlyOwner (Data storage self) {\n', '    require (msg.sender == self.owner);\n', '    _;\n', '  }\n', '  \n', '  modifier noReentrancy(Data storage self) {\n', '    require(!self.locked);\n', '    self.locked = true;\n', '    _;\n', '    self.locked = false;\n', '  }\n', '  \n', '  function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n', '    return numerator.mul(10 ** 20).div(denominator);\n', '  }\n', '  \n', '  function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n', '    return numerator.mul(pct).div(10 ** 20);\n', '  }\n', '  \n', '  function newPool (Data storage self, uint _fee, address _receiver, uint _contractCap, uint _individualCap) public {\n', '    require (_fee < 1000);\n', '    self.owner = msg.sender;\n', '    self.receiver = _receiver;\n', '    self.contractCap = _contractCap;\n', '    self.capTimes.push(0);\n', '    self.capAmounts.push(_individualCap);\n', '    self.fee = _toPct(_fee,1000);\n', '  }\n', '\t\n', '  function deposit (Data storage self) public {\n', '\t  assert (!self.poolSubmitted);\n', '    require (tx.gasprice <= maxGasPrice);\n', '    Contributor storage c = self.contributorMap[msg.sender];\n', '    uint cap = _getCap(self, msg.sender);\n', '    require (cap >= c.balance.add(msg.value));\n', '    if (self.contractCap < address(this).balance) {\n', '      require (address(this).balance.sub(msg.value) < self.contractCap);\n', '      uint excess = address(this).balance.sub(self.contractCap);\n', '      c.balance = c.balance.add(msg.value.sub(excess));\n', '      msg.sender.transfer(excess);\n', '    } else {\n', '      c.balance = c.balance.add(msg.value);\n', '    }\n', '    require (c.balance >= contributionMin);\n', '    emit ContributorBalanceChanged(msg.sender, c.balance);\n', '  }\n', '  \n', '  function receiveRefund (Data storage self) public {\n', '    assert (self.poolSubmitted);\n', '    require (msg.sender == self.receiver || msg.sender == self.owner);\n', '    require (msg.value >= 1 ether);\n', '    self.withdrawToken.push(0x00);\n', '    self.withdrawAmount.push(msg.value);\n', '    emit WithdrawalAvailable(0x00);\n', '  }\n', '  \n', '  function withdraw (Data storage self) public {\n', '    assert (msg.value == 0);\n', '    Contributor storage c = self.contributorMap[msg.sender];\n', '    require (c.balance > 0);\n', '    if (!self.poolSubmitted) {\n', '      uint balance = c.balance;\n', '      c.balance = 0;\n', '      msg.sender.transfer(balance);\n', '      emit ContributorBalanceChanged(msg.sender, 0);\n', '      return;\n', '    }\n', '    require (c.claimedTokensIndex < self.withdrawToken.length);\n', '    uint pct = _toPct(c.balance,self.finalBalance);\n', '    uint amount;\n', '    address token;\n', '    for (uint16 i = c.claimedTokensIndex; i < self.withdrawToken.length; i++) {\n', '      amount = _applyPct(self.withdrawAmount[i],pct);\n', '      token = self.withdrawToken[i];\n', '      c.claimedTokensIndex++;\n', '      if (amount > 0) {  \n', '        if (token == 0x00) {\n', '          msg.sender.transfer(amount);\n', '        } else {\n', '          require (ERC20(token).transfer(msg.sender, amount));\n', '          self.tokenBalances[token] = self.tokenBalances[token].sub(amount);  \n', '        }\n', '        emit WithdrawalClaimed(msg.sender, token, amount);\n', '      }\n', '    }\n', '  }\n', '  \n', '  function setIndividualCaps (Data storage self, address[] addr, uint[] cap) public onlyOwner(self) {\n', '    require (addr.length == cap.length);\n', '    for (uint8 i = 0; i < addr.length; i++) {\n', '      self.individualCaps[addr[i]] = cap[i];\n', '    }  \n', '  }\n', '  \n', '  function setCaps (Data storage self, uint32[] times, uint[] caps) public onlyOwner(self) {\n', '    require (caps.length > 0);\n', '    require (caps.length == times.length);\n', '    self.capTimes = [0];\n', '    self.capAmounts = [self.capAmounts[0]];\n', '    for (uint8 i = 0; i < caps.length; i++) {\n', '      require (times[i] > self.capTimes[self.capTimes.length.sub(1)]);\n', '      self.capTimes.push(times[i]);\n', '      self.capAmounts.push(caps[i]);\n', '    }\n', '  }\n', '  \n', '  function setContractCap (Data storage self, uint amount) public onlyOwner(self) {\n', '    require (amount >= address(this).balance);\n', '    self.contractCap = amount;\n', '  }\n', '  \n', '  function _getCap (Data storage self, address addr) internal view returns (uint) {\n', '    if (self.individualCaps[addr] > 0) return self.individualCaps[addr];\n', '    if (whitelistContract.checkMemberLevel(msg.sender) == 0) return 0;\n', '    return getCapAtTime(self,now);\n', '  }\n', '  \n', '  function getCapAtTime (Data storage self, uint time) public view returns (uint) {\n', '    if (time == 0) time = now;\n', '    for (uint i = 1; i < self.capTimes.length; i++) {\n', '      if (self.capTimes[i] > time) return self.capAmounts[i-1];\n', '    }\n', '    return self.capAmounts[self.capAmounts.length-1];\n', '  }\n', '  \n', '  function getPoolInfo (Data storage self) view public returns (uint balance, uint remaining, uint cap) {\n', '    if (!self.poolSubmitted) return (address(this).balance, self.contractCap.sub(address(this).balance), self.contractCap);\n', '    return (address(this).balance, 0, self.contractCap);\n', '  }\n', '  \n', '  function getContributorInfo (Data storage self, address addr) view public returns (uint balance, uint remaining, uint cap) {\n', '    cap = _getCap(self, addr);\n', '    Contributor storage c = self.contributorMap[addr];\n', '    if (self.poolSubmitted || cap <= c.balance) return (c.balance, 0, cap);\n', '    if (cap.sub(c.balance) > self.contractCap.sub(address(this).balance)) return (c.balance, self.contractCap.sub(address(this).balance), cap);\n', '    return (c.balance, cap.sub(c.balance), cap);\n', '  }\n', '  \n', '  function checkWithdrawalAvailable (Data storage self, address addr) view public returns (bool) {\n', '    return self.contributorMap[addr].claimedTokensIndex < self.withdrawToken.length;\n', '  }\n', '  \n', '  function setReceiverAddress (Data storage self, address _receiver) public onlyOwner(self) {\n', '    require (!self.poolSubmitted);\n', '    self.receiver = _receiver;\n', '    self.addressSetTime = now;\n', '    emit ReceiverAddressSet(_receiver);\n', '  }\n', '  \n', '  function submitPool (Data storage self, uint amountInWei) public onlyOwner(self) noReentrancy(self) {\n', '    require (!self.poolSubmitted);\n', '    require (now > self.addressSetTime.add(86400));\n', '    if (amountInWei == 0) amountInWei = address(this).balance;\n', '    self.finalBalance = address(this).balance;\n', '    self.poolSubmitted = true;\n', '    require (self.receiver.call.value(amountInWei).gas(gasleft().sub(5000))());\n', '    if (address(this).balance > 0) {\n', '      self.withdrawToken.push(0x00);\n', '      self.withdrawAmount.push(address(this).balance);\n', '      emit WithdrawalAvailable(0x00);\n', '    }\n', '    emit PoolSubmitted(self.receiver, amountInWei);\n', '  }\n', '  \n', '  function enableWithdrawals (Data storage self, address tokenAddress, address feeAddress) public onlyOwner(self) noReentrancy(self) {\n', '    require (self.poolSubmitted);\n', '    if (feeAddress == 0x00) feeAddress = self.owner;\n', '    ERC20 token = ERC20(tokenAddress);\n', '    uint amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]);\n', '    require (amount > 0);\n', '    if (self.fee > 0) {\n', '      require (token.transfer(feeAddress, _applyPct(amount,self.fee)));\n', '      amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]);\n', '    }\n', '    self.tokenBalances[tokenAddress] = token.balanceOf(this);\n', '    self.withdrawToken.push(tokenAddress);\n', '    self.withdrawAmount.push(amount);\n', '    emit WithdrawalAvailable(tokenAddress);\n', '  }\n', '\n', '}']