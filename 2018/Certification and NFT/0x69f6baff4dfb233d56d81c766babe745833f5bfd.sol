['pragma solidity 0.4.23;\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract Proxied is Ownable {\n', '    address public target;\n', '    mapping (address => bool) public initialized;\n', '\n', '    event EventUpgrade(address indexed newTarget, address indexed oldTarget, address indexed admin);\n', '    event EventInitialized(address indexed target);\n', '\n', '    function upgradeTo(address _target) public;\n', '}\n', '\n', 'contract Upgradeable is Proxied {\n', '    /*\n', '     * @notice Modifier to make body of function only execute if the contract has not already been initialized.\n', '     */\n', '    modifier initializeOnceOnly() {\n', '         if(!initialized[target]) {\n', '             initialized[target] = true;\n', '             emit EventInitialized(target);\n', '             _;\n', '         } else revert();\n', '     }\n', '\n', '    /**\n', '     * @notice Will always fail if called. This is used as a placeholder for the contract ABI.\n', '     * @dev This is code is never executed by the Proxy using delegate call\n', '     */\n', '    function upgradeTo(address) public {\n', '        assert(false);\n', '    }\n', '\n', '    /**\n', '     * @notice Initialize any state variables that would normally be set in the contructor.\n', '     * @dev Initialization functionality MUST be implemented in inherited upgradeable contract if the child contract requires\n', '     * variable initialization on creation. This is because the contructor of the child contract will not execute\n', '     * and set any state when the Proxy contract targets it.\n', '     * This function MUST be called stright after the Upgradeable contract is set as the target of the Proxy. This method\n', '     * can be overwridden so that it may have arguments. Make sure that the initializeOnceOnly() modifier is used to protect\n', '     * from being initialized more than once.\n', '     * If a contract is upgraded twice, pay special attention that the state variables are not initialized again\n', '     */\n', '    function initialize() initializeOnceOnly public {\n', '        // initialize contract state variables here\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require (!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require (paused) ;\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'interface IClaims  {\n', '\n', '    event ClaimCreated(uint indexed claimId);\n', '\n', '    function createClaim(address[] _voters, uint _votingDeadline,\n', '    address _claimantAddress) external;\n', '\n', '    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\n', '    bytes32 _tokenHash) external;\n', '    \n', '    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\n', '    bytes32 _tokenHash) external;\n', '}\n', '\n', 'contract NaiveClaims is Upgradeable, Pausable, IClaims  {\n', '\n', '    struct Claim {\n', '        address[] voters;\n', '        mapping(address => Vote) votes;\n', '        address claimantAddress;\n', '        uint votingDeadline;\n', '    }\n', '\n', '    struct Vote {\n', '        uint pType;\n', '        bytes32 hash;\n', '        string url;\n', '        bool exists;\n', '        bytes32 tokenHash;\n', '    }\n', '\n', '    mapping (uint => Claim) public claims;\n', '    event ClaimCreated(uint indexed claimId);\n', '    uint256 public claimsCreated;\n', '\n', '    /**\n', '     * @param _voters - addresses eligible to vote\n', '     * @param _votingDeadline - after which votes cannot be submitted\n', '     * @param _claimantAddress  - claimants address\n', '     */\n', '    function createClaim(address[] _voters, uint _votingDeadline, address _claimantAddress) external whenNotPaused {\n', '\n', '        claims[claimsCreated].voters = _voters;\n', '        claims[claimsCreated].claimantAddress = _claimantAddress;\n', '        claims[claimsCreated].votingDeadline = _votingDeadline;\n', '\n', '        emit ClaimCreated(claimsCreated);\n', '        claimsCreated++;\n', '    }\n', '\n', '    /**\n', '     * @param _claimId - claim id for which user is casting the vote\n', '     * @param _pType - type of hashPointer (1 - PlainVote)\n', '     * @param _hash - of the vote - in this version plain YES or NO\n', '     * @param _url - to the location of the vote (mongo://{vote-doc-id})\n', '     * @param _tokenHash - received from indorse on centralized vote submission\n', '     */\n', '    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\n', '    bytes32 _tokenHash) external {\n', '        Claim storage claim = claims[_claimId];\n', '        Vote storage vote = claim.votes[msg.sender];\n', '\n', '        require(vote.exists != true, "Voters can only vote once");\n', '        require(now < claim.votingDeadline, "Cannot vote after the dealine has passed");\n', '\n', '        claims[_claimId].votes[msg.sender] = Vote(_pType, _hash, _url, true, _tokenHash);\n', '    }\n', '\n', '    function getVote(uint _claimId, address _voter)  constant external returns (uint ,bytes32,\n', '    string ,bool ,bytes32){\n', '        return (claims[_claimId].votes[_voter].pType,\n', '        claims[_claimId].votes[_voter].hash,\n', '        claims[_claimId].votes[_voter].url,\n', '        claims[_claimId].votes[_voter].exists,\n', '        claims[_claimId].votes[_voter].tokenHash);\n', '    }\n', '\n', '    function getVoter(uint _claimId, uint _index) external constant returns (address) {\n', '        return claims[_claimId].voters[_index];\n', '    }\n', '\n', '    function getVoterCount(uint _claimId) external constant returns (uint) {\n', '        return claims[_claimId].voters.length;\n', '    }\n', '\n', '    function initialize() initializeOnceOnly public {\n', '        claimsCreated = 0; // This is not strictly needed but is good practice to show initialization here\n', '    }\n', '\n', '    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\n', '    bytes32 _tokenHash) external {\n', '        revert("Unsupported operation");\n', '    }\n', '}']