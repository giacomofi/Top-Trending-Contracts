['pragma solidity ^0.4.19;\n', '\n', 'contract Questions {\n', '    struct Question {\n', '        address creator;\n', '        uint paymentForAnswer;\n', '        uint8 maxAnswers;\n', '        uint8 answerCount;\n', '        int minVoteWeight;\n', '    }\n', '    \n', '    struct Answer {\n', '        bool placed;\n', '        int rating;\n', '        uint8 votes;\n', '    }\n', '    \n', '    address public owner;\n', '    uint private ownerBalance;\n', '    \n', '    uint public minPaymentForAnswer = 1 finney;\n', '    uint public votesForAnswer = 5;\n', '    int public maxAbsKindness = 25;\n', '    uint public resetVoteKindnessEvery = 5000;\n', '    uint public minVoteWeightK = 1 finney;\n', '    \n', '    mapping (uint => Question) public questions;\n', '    uint public currentQuestionId = 0;\n', '    \n', '    // questionId => creator => rating\n', '    mapping (uint => mapping (address => Answer)) public answers;\n', '    \n', '    // questionId => creator => voter => true\n', '    mapping (uint => mapping (address => mapping (address => bool))) public votes;\n', '    \n', '    // voter => kindness\n', '    mapping (address => int8) public voteKindness;\n', '    \n', '    // user => vote kindness reset\n', '    mapping (address => uint) public voteKindnessReset;\n', '    \n', '    // user => vote weight\n', '    mapping (address => int) public voteWeight;\n', '    \n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '    event PlaceQuestion(\n', '        uint indexed questionId,\n', '        address indexed creator,\n', '        uint paymentForAnswer,\n', '        uint8 maxAnswers,\n', '        uint minVoteWeight,\n', '        string text\n', '    );\n', '    event PlaceAnswer(\n', '        uint indexed questionId,\n', '        address indexed creator,\n', '        string text\n', '    );\n', '    event Vote(uint indexed questionId, address indexed creator, int ratingDelta);\n', '    event VoteWeightChange(address indexed user, int weight);\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '    function setMinPaymentForAnswer(uint value) external onlyOwner {\n', '        require(value < minPaymentForAnswer);\n', '        minPaymentForAnswer = value;\n', '    }\n', '    \n', '    function setMaxAbsKindness(int value) external onlyOwner {\n', '        require(value > 0);\n', '        maxAbsKindness = value;\n', '    }\n', '    \n', '    function setResetVoteKindnessEvery(uint value) external onlyOwner {\n', '        resetVoteKindnessEvery = value;\n', '    }\n', '    \n', '    function setMinVoteWeightK(uint value) external onlyOwner {\n', '        minVoteWeightK = value;\n', '    }\n', '    \n', '    function Questions() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function safeAdd(uint a, uint b) private pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function safeSub(uint a, uint b) private pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function safeMul(uint a, uint b) private pure returns (uint) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        \n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function changeVoteWeight(address user, int delta) internal {\n', '        voteWeight[user] += delta;\n', '        VoteWeightChange(user, voteWeight[user]);\n', '    }\n', '    \n', '    function placeQuestion(uint paymentForAnswer, uint8 maxAnswers, uint minVoteWeight, string text) external payable {\n', '        require(maxAnswers > 0 && maxAnswers <= 32);\n', '        require(msg.value == safeMul(paymentForAnswer, safeAdd(maxAnswers, 1)));\n', '        require(paymentForAnswer >= safeAdd(minPaymentForAnswer, safeMul(minVoteWeight, minVoteWeightK)));\n', '        uint len = bytes(text).length;\n', '        require(len > 0 && len <= 1024);\n', '        \n', '        uint realPaymentForAnswer = paymentForAnswer / 2;\n', '        uint realPaymentForVote = realPaymentForAnswer / votesForAnswer;\n', '        \n', '        int minVoteWeightI = int(minVoteWeight);\n', '        require(minVoteWeightI >= 0);\n', '        \n', '        questions[currentQuestionId] = Question({\n', '            creator: msg.sender,\n', '            paymentForAnswer: realPaymentForAnswer,\n', '            maxAnswers: maxAnswers,\n', '            answerCount: 0,\n', '            minVoteWeight: minVoteWeightI\n', '        });\n', '        PlaceQuestion(currentQuestionId, msg.sender, realPaymentForAnswer, maxAnswers, minVoteWeight, text);\n', '        currentQuestionId++;\n', '        \n', '        changeVoteWeight(msg.sender, 1);\n', '        \n', '        ownerBalance += msg.value - (realPaymentForAnswer + realPaymentForVote * votesForAnswer) * maxAnswers;\n', '        \n', '        FundTransfer(msg.sender, msg.value, true);\n', '    }\n', '    \n', '    function placeAnswer(uint questionId, string text) external {\n', '        require(questions[questionId].creator != 0x0);\n', '        require(questions[questionId].creator != msg.sender);\n', '        require(!answers[questionId][msg.sender].placed);\n', '        uint len = bytes(text).length;\n', '        require(len > 0 && len <= 1024);\n', '        require(questions[questionId].answerCount < questions[questionId].maxAnswers);\n', '        require(voteWeight[msg.sender] >= questions[questionId].minVoteWeight);\n', '        \n', '        questions[questionId].answerCount++;\n', '        answers[questionId][msg.sender] = Answer({\n', '            placed: true,\n', '            rating: 0,\n', '            votes: 0\n', '        });\n', '        PlaceAnswer(questionId, msg.sender, text);\n', '    }\n', '    \n', '    function voteForAnswer(uint questionId, address creator, bool isSpam) external {\n', '        require(questions[questionId].creator != msg.sender);\n', '        require(creator != msg.sender);\n', '        require(answers[questionId][creator].placed);\n', '        require(answers[questionId][creator].votes < votesForAnswer);\n', '        require(!votes[questionId][creator][msg.sender]);\n', '        require(voteWeight[msg.sender] > 0);\n', '        require(voteWeight[msg.sender] >= questions[questionId].minVoteWeight);\n', '        \n', '        if (voteKindnessReset[msg.sender] + resetVoteKindnessEvery <= block.number) {\n', '            voteKindness[msg.sender] = 0;\n', '            voteKindnessReset[msg.sender] = block.number;\n', '        }\n', '        \n', '        if (isSpam) {\n', '            require(voteKindness[msg.sender] > -maxAbsKindness);\n', '            voteKindness[msg.sender]--;\n', '        } else {\n', '            require(voteKindness[msg.sender] < maxAbsKindness);\n', '            voteKindness[msg.sender]++;\n', '        }\n', '        \n', '        int ratingDelta = isSpam ? -voteWeight[msg.sender] : voteWeight[msg.sender];\n', '        votes[questionId][creator][msg.sender] = true;\n', '        answers[questionId][creator].votes++;\n', '        answers[questionId][creator].rating += ratingDelta;\n', '        Vote(questionId, creator, ratingDelta);\n', '        \n', '        uint payment = questions[questionId].paymentForAnswer / votesForAnswer;\n', '        msg.sender.transfer(payment);\n', '        FundTransfer(msg.sender, payment, false);\n', '        \n', '        if (answers[questionId][creator].votes == votesForAnswer) {\n', '            if (answers[questionId][creator].rating > 0) {\n', '                creator.transfer(questions[questionId].paymentForAnswer);\n', '                FundTransfer(creator, questions[questionId].paymentForAnswer, false);\n', '                \n', '                changeVoteWeight(creator, 5);\n', '            } else {\n', '                questions[questionId].creator.transfer(questions[questionId].paymentForAnswer);\n', '                FundTransfer(questions[questionId].creator, questions[questionId].paymentForAnswer, false);\n', '                \n', '                changeVoteWeight(creator, -5);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function withdrawEther() external onlyOwner {\n', '        owner.transfer(ownerBalance);\n', '        ownerBalance = 0;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract Questions {\n', '    struct Question {\n', '        address creator;\n', '        uint paymentForAnswer;\n', '        uint8 maxAnswers;\n', '        uint8 answerCount;\n', '        int minVoteWeight;\n', '    }\n', '    \n', '    struct Answer {\n', '        bool placed;\n', '        int rating;\n', '        uint8 votes;\n', '    }\n', '    \n', '    address public owner;\n', '    uint private ownerBalance;\n', '    \n', '    uint public minPaymentForAnswer = 1 finney;\n', '    uint public votesForAnswer = 5;\n', '    int public maxAbsKindness = 25;\n', '    uint public resetVoteKindnessEvery = 5000;\n', '    uint public minVoteWeightK = 1 finney;\n', '    \n', '    mapping (uint => Question) public questions;\n', '    uint public currentQuestionId = 0;\n', '    \n', '    // questionId => creator => rating\n', '    mapping (uint => mapping (address => Answer)) public answers;\n', '    \n', '    // questionId => creator => voter => true\n', '    mapping (uint => mapping (address => mapping (address => bool))) public votes;\n', '    \n', '    // voter => kindness\n', '    mapping (address => int8) public voteKindness;\n', '    \n', '    // user => vote kindness reset\n', '    mapping (address => uint) public voteKindnessReset;\n', '    \n', '    // user => vote weight\n', '    mapping (address => int) public voteWeight;\n', '    \n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '    event PlaceQuestion(\n', '        uint indexed questionId,\n', '        address indexed creator,\n', '        uint paymentForAnswer,\n', '        uint8 maxAnswers,\n', '        uint minVoteWeight,\n', '        string text\n', '    );\n', '    event PlaceAnswer(\n', '        uint indexed questionId,\n', '        address indexed creator,\n', '        string text\n', '    );\n', '    event Vote(uint indexed questionId, address indexed creator, int ratingDelta);\n', '    event VoteWeightChange(address indexed user, int weight);\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '    function setMinPaymentForAnswer(uint value) external onlyOwner {\n', '        require(value < minPaymentForAnswer);\n', '        minPaymentForAnswer = value;\n', '    }\n', '    \n', '    function setMaxAbsKindness(int value) external onlyOwner {\n', '        require(value > 0);\n', '        maxAbsKindness = value;\n', '    }\n', '    \n', '    function setResetVoteKindnessEvery(uint value) external onlyOwner {\n', '        resetVoteKindnessEvery = value;\n', '    }\n', '    \n', '    function setMinVoteWeightK(uint value) external onlyOwner {\n', '        minVoteWeightK = value;\n', '    }\n', '    \n', '    function Questions() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function safeAdd(uint a, uint b) private pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    function safeSub(uint a, uint b) private pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function safeMul(uint a, uint b) private pure returns (uint) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        \n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function changeVoteWeight(address user, int delta) internal {\n', '        voteWeight[user] += delta;\n', '        VoteWeightChange(user, voteWeight[user]);\n', '    }\n', '    \n', '    function placeQuestion(uint paymentForAnswer, uint8 maxAnswers, uint minVoteWeight, string text) external payable {\n', '        require(maxAnswers > 0 && maxAnswers <= 32);\n', '        require(msg.value == safeMul(paymentForAnswer, safeAdd(maxAnswers, 1)));\n', '        require(paymentForAnswer >= safeAdd(minPaymentForAnswer, safeMul(minVoteWeight, minVoteWeightK)));\n', '        uint len = bytes(text).length;\n', '        require(len > 0 && len <= 1024);\n', '        \n', '        uint realPaymentForAnswer = paymentForAnswer / 2;\n', '        uint realPaymentForVote = realPaymentForAnswer / votesForAnswer;\n', '        \n', '        int minVoteWeightI = int(minVoteWeight);\n', '        require(minVoteWeightI >= 0);\n', '        \n', '        questions[currentQuestionId] = Question({\n', '            creator: msg.sender,\n', '            paymentForAnswer: realPaymentForAnswer,\n', '            maxAnswers: maxAnswers,\n', '            answerCount: 0,\n', '            minVoteWeight: minVoteWeightI\n', '        });\n', '        PlaceQuestion(currentQuestionId, msg.sender, realPaymentForAnswer, maxAnswers, minVoteWeight, text);\n', '        currentQuestionId++;\n', '        \n', '        changeVoteWeight(msg.sender, 1);\n', '        \n', '        ownerBalance += msg.value - (realPaymentForAnswer + realPaymentForVote * votesForAnswer) * maxAnswers;\n', '        \n', '        FundTransfer(msg.sender, msg.value, true);\n', '    }\n', '    \n', '    function placeAnswer(uint questionId, string text) external {\n', '        require(questions[questionId].creator != 0x0);\n', '        require(questions[questionId].creator != msg.sender);\n', '        require(!answers[questionId][msg.sender].placed);\n', '        uint len = bytes(text).length;\n', '        require(len > 0 && len <= 1024);\n', '        require(questions[questionId].answerCount < questions[questionId].maxAnswers);\n', '        require(voteWeight[msg.sender] >= questions[questionId].minVoteWeight);\n', '        \n', '        questions[questionId].answerCount++;\n', '        answers[questionId][msg.sender] = Answer({\n', '            placed: true,\n', '            rating: 0,\n', '            votes: 0\n', '        });\n', '        PlaceAnswer(questionId, msg.sender, text);\n', '    }\n', '    \n', '    function voteForAnswer(uint questionId, address creator, bool isSpam) external {\n', '        require(questions[questionId].creator != msg.sender);\n', '        require(creator != msg.sender);\n', '        require(answers[questionId][creator].placed);\n', '        require(answers[questionId][creator].votes < votesForAnswer);\n', '        require(!votes[questionId][creator][msg.sender]);\n', '        require(voteWeight[msg.sender] > 0);\n', '        require(voteWeight[msg.sender] >= questions[questionId].minVoteWeight);\n', '        \n', '        if (voteKindnessReset[msg.sender] + resetVoteKindnessEvery <= block.number) {\n', '            voteKindness[msg.sender] = 0;\n', '            voteKindnessReset[msg.sender] = block.number;\n', '        }\n', '        \n', '        if (isSpam) {\n', '            require(voteKindness[msg.sender] > -maxAbsKindness);\n', '            voteKindness[msg.sender]--;\n', '        } else {\n', '            require(voteKindness[msg.sender] < maxAbsKindness);\n', '            voteKindness[msg.sender]++;\n', '        }\n', '        \n', '        int ratingDelta = isSpam ? -voteWeight[msg.sender] : voteWeight[msg.sender];\n', '        votes[questionId][creator][msg.sender] = true;\n', '        answers[questionId][creator].votes++;\n', '        answers[questionId][creator].rating += ratingDelta;\n', '        Vote(questionId, creator, ratingDelta);\n', '        \n', '        uint payment = questions[questionId].paymentForAnswer / votesForAnswer;\n', '        msg.sender.transfer(payment);\n', '        FundTransfer(msg.sender, payment, false);\n', '        \n', '        if (answers[questionId][creator].votes == votesForAnswer) {\n', '            if (answers[questionId][creator].rating > 0) {\n', '                creator.transfer(questions[questionId].paymentForAnswer);\n', '                FundTransfer(creator, questions[questionId].paymentForAnswer, false);\n', '                \n', '                changeVoteWeight(creator, 5);\n', '            } else {\n', '                questions[questionId].creator.transfer(questions[questionId].paymentForAnswer);\n', '                FundTransfer(questions[questionId].creator, questions[questionId].paymentForAnswer, false);\n', '                \n', '                changeVoteWeight(creator, -5);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function withdrawEther() external onlyOwner {\n', '        owner.transfer(ownerBalance);\n', '        ownerBalance = 0;\n', '    }\n', '}']
