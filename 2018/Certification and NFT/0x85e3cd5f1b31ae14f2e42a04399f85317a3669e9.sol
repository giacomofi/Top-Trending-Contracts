['pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '\tfunction add(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a + b; require(c >= a);\n', '\t}\n', '\tfunction sub(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b <= a); c = a - b;\n', '\t}\n', '\tfunction mul(uint a, uint b) internal pure returns (uint c) {\n', '\t\tc = a * b; require(a == 0 || c / a == b);\n', '\t}\n', '\tfunction div(uint a, uint b) internal pure returns (uint c) {\n', '\t\trequire(b > 0); c = a / b;\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '\tfunction totalSupply() public constant returns (uint);\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '\tfunction transfer(address to, uint tokens) public returns (bool success);\n', '\tfunction approve(address spender, uint tokens) public returns (bool success);\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\tevent Transfer(address indexed from, address indexed to, uint tokens);\n', '\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '\taddress public owner;\n', '\taddress public parityOwner;\n', '\taddress public newOwner;\n', '\taddress public newParityOwner;\n', '\tevent OwnershipTransferred(address indexed _from, address indexed _to);\n', '\tevent ParityOwnershipTransferred(address indexed _from, address indexed _to);\n', '\tconstructor() public {\n', '\t\towner = 0xF355F9f411A5580a5f9e74203458906a90d39DE1;\n', '\t\tparityOwner = 0x0057015543016dadc0Df0f1df1Cc79d496602f03;\n', '\t}\n', '\tmodifier onlyOwner {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\trequire(isOwner);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyOwners {\n', '\t\tbool isOwner = (msg.sender == owner);\n', '\t\tbool isParityOwner = (msg.sender == parityOwner);\n', '\t\trequire(owner != parityOwner);\n', '\t\trequire(isOwner || isParityOwner);\n', '\t\t_;\n', '\t}\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(_newOwner != parityOwner);\n', '\t\trequire(_newOwner != newParityOwner);\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == newOwner);\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\tfunction transferParityOwnership(address _newParityOwner) public onlyOwner {\n', '\t\trequire(_newParityOwner != owner);\n', '\t\trequire(_newParityOwner != newOwner);\n', '\t\tnewParityOwner = _newParityOwner;\n', '\t}\n', '\tfunction acceptParityOwnership() public {\n', '\t\trequire(msg.sender == newParityOwner);\n', '\t\temit ParityOwnershipTransferred(parityOwner, newParityOwner);\n', '\t\tparityOwner = newParityOwner;\n', '\t\tnewParityOwner = address(0);\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NZO (Release Candidate)\n', '// ----------------------------------------------------------------------------\n', 'contract NZO is ERC20Interface, Owned {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring public symbol;\n', '\tstring public  name;\n', '\tuint8  public decimals;\n', '\tuint   public _totalSupply;\n', '\tuint   public releasedSupply;\n', '\tuint   public crowdSaleBalance;\n', '\tuint   public crowdSaleAmountRaised;\n', '\tbool   public crowdSaleOngoing;\n', '\tuint   public crowdSalesCompleted;\n', '\tuint   public crowdSaleBonusADeadline;\n', '\tuint   public crowdSaleBonusBDeadline;\n', '\tuint   public crowdSaleBonusAPercentage;\n', '\tuint   public crowdSaleBonusBPercentage;\n', '\tuint   public crowdSaleWeiMinimum;\n', '\tuint   public crowdSaleWeiMaximum;\n', '\tbool   public supplyLocked;\n', '\tbool   public supplyLockedA;\n', '\tbool   public supplyLockedB;\n', '\tuint   public weiCostOfToken;\n', '\n', '\tmapping(address => uint) balances;\n', '\tmapping(address => mapping(address => uint)) allowed;\n', '\tmapping(address => mapping(address => uint)) owed;\n', '\tmapping(address => uint) crowdSaleAllowed;\n', '\n', '\tevent SupplyLocked(bool isLocked);\n', '\tevent AddOwed(address indexed from, address indexed to, uint tokens);\n', '\tevent CrowdSaleLocked(bool status, uint indexed completed, uint amountRaised);\n', '\tevent CrowdSaleOpened(bool status);\n', '\tevent CrowdSaleApproval(address approver, address indexed buyer, uint tokens);\n', '\tevent CrowdSalePurchaseCompleted(address indexed buyer, uint ethAmount, uint tokens);\n', '\tevent ChangedWeiCostOfToken(uint newCost, uint weiMinimum, uint weiMaximum);\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Constructor\n', '\t// 900,000,000 total.\n', '\t// 540,000,000 for crowd sale.\n', '\t// 360,000,000 for normal.\n', '\t// Starting cost: 0.10 USD for 1 token.\n', '\t// ------------------------------------------------------------------------\n', '\tconstructor() public {\n', '\t\tsymbol                    = "NZO";\n', '\t\tname                      = "Non-Zero";\n', '\t\tdecimals                  = 18;\n', '\t\t_totalSupply              = 900000000 * 10**uint(decimals);\n', '\t\treleasedSupply            = 0;\n', '\t\tcrowdSaleBalance          = 0;\n', '\t\tcrowdSaleAmountRaised     = 0;\n', '\t\tcrowdSaleOngoing          = false;\n', '\t\tcrowdSalesCompleted       = 0;\n', '\t\tcrowdSaleBonusADeadline   = 0;\n', '\t\tcrowdSaleBonusBDeadline   = 0;\n', '\t\tcrowdSaleBonusAPercentage = 100;\n', '\t\tcrowdSaleBonusBPercentage = 100;\n', '\t\tcrowdSaleWeiMinimum       = 0;\n', '\t\tcrowdSaleWeiMaximum       = 0;\n', '\t\tsupplyLocked              = false;\n', '\t\tsupplyLockedA             = false;\n', '\t\tsupplyLockedB             = false;\n', '\t\tweiCostOfToken            = 168000000000000 * 1 wei;\n', '\t\tbalances[owner]           = _totalSupply;\n', '\t\temit Transfer(address(0), owner, _totalSupply);\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Getters\n', '\t// ------------------------------------------------------------------------\n', '\tfunction totalSupply() public constant returns (uint) {\n', '\t\treturn _totalSupply  - balances[address(0)];\n', '\t}\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '\t\treturn balances[tokenOwner];\n', '\t}\n', '\tfunction allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '\t\treturn allowed[tokenOwner][spender];\n', '\t}\n', '\tfunction getOwed(address from, address to) public constant returns (uint tokens) {\n', '\t\treturn owed[from][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Lock token supply. CAUTION: IRREVERSIBLE\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockSupply() public onlyOwners returns (bool isSupplyLocked) {\n', '\t\trequire(!supplyLocked);\n', '\t\tif (msg.sender == owner) {\n', '\t\t\tsupplyLockedA = true;\n', '\t\t} else if (msg.sender == parityOwner) {\n', '\t\t\tsupplyLockedB = true;\n', '\t\t}\n', '\t\tsupplyLocked = (supplyLockedA && supplyLockedB);\n', '\t\temit SupplyLocked(true);\n', '\t\treturn supplyLocked;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Increase total supply ("issue" new tokens)\n', '\t// ------------------------------------------------------------------------\n', '\tfunction increaseTotalSupply(uint tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(!supplyLocked);\n', '\t\t_totalSupply = _totalSupply.add(tokens);\n', '\t\tbalances[owner] = balances[owner].add(tokens);\n', '\t\temit Transfer(address(0), owner, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// End crowd sale. Increments crowdSalesCompleted counter.\n', '\t// Returns remaining crowdSaleBalance to owner.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction lockCrowdSale() public onlyOwner returns (bool success) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\tcrowdSaleOngoing = false;\n', '\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\tbalances[owner] = balances[owner].add(crowdSaleBalance);\n', '\t\tcrowdSaleBalance = 0;\n', '\t\tcrowdSaleBonusADeadline = 0;\n', '\t\tcrowdSaleBonusBDeadline = 0;\n', '\t\tcrowdSaleBonusAPercentage = 100;\n', '\t\tcrowdSaleBonusBPercentage = 100;\n', '\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\treturn !crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Open a new crowd sale.\n', '\t// bonusBDeadline must always be more in the future than bonusADeadline.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction openCrowdSale(\n', '\t\tuint supply, uint bonusADeadline, uint bonusBDeadline, uint bonusAPercentage, uint bonusBPercentage\n', '\t) public onlyOwner returns (bool success) {\n', '\t\trequire(!crowdSaleOngoing);\n', '\t\trequire(supply <= balances[owner]);\n', '\t\trequire(bonusADeadline > now);\n', '\t\trequire(bonusBDeadline > now);\n', '\t\trequire(bonusAPercentage >= 100);\n', '\t\trequire(bonusBPercentage >= 100);\n', '\t\tbalances[owner] = balances[owner].sub(supply);\n', '\t\tcrowdSaleBalance = supply;\n', '\t\tcrowdSaleBonusADeadline = bonusADeadline;\n', '\t\tcrowdSaleBonusBDeadline = bonusBDeadline;\n', '\t\tcrowdSaleBonusAPercentage = bonusAPercentage;\n', '\t\tcrowdSaleBonusBPercentage = bonusBPercentage;\n', '\t\tcrowdSaleOngoing = true;\n', '\t\temit CrowdSaleOpened(crowdSaleOngoing);\n', '\t\treturn crowdSaleOngoing;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Add amount owed (usually from broker to user)\n', '\t// Amount can only be increased, and can only be decreased by paying.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction addOwed(address to, uint tokens) public returns (uint newOwed) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\towed[msg.sender][to] = owed[msg.sender][to].add(tokens);\n', '\t\temit AddOwed(msg.sender, to, tokens);\n', '\t\treturn owed[msg.sender][to];\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "\t// from the token owner's account\n", '\t//\n', '\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '\t// recommends that there are no checks for the approval double-spend attack\n', '\t// as this should be implemented in user interfaces \n', '\t// ------------------------------------------------------------------------\n', '\tfunction approve(address spender, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\tallowed[msg.sender][spender] = tokens;\n', '\t\temit Approval(msg.sender, spender, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Allow an address to participate in the crowd sale up to some limit\n', '\t// ------------------------------------------------------------------------\n', '\tfunction crowdSaleApprove(address[] buyers, uint[] tokens) public onlyOwner returns (bool success) {\n', '\t\trequire(buyers.length == tokens.length);\n', '\t\tuint buyersLength = buyers.length;\n', '\t\tfor (uint i = 0; i < buyersLength; i++) {\n', '\t\t\trequire(tokens[i] <= crowdSaleBalance);\n', '\t\t\tcrowdSaleAllowed[buyers[i]] = tokens[i];\n', '\t\t\temit CrowdSaleApproval(msg.sender, buyers[i], tokens[i]);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', "\t// Transfer the balance from token owner's account to `to` account\n", "\t// - Owner's account must have sufficient balance to transfer\n", '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transfer(address to, uint tokens) public returns (bool success) {\n', '\t\trequire((msg.sender == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(msg.sender != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[msg.sender][to] >= tokens) {\n', '\t\t\towed[msg.sender][to].sub(tokens);\n', '\t\t} else if (owed[msg.sender][to] < tokens) {\n', '\t\t\towed[msg.sender][to] = uint(0);\n', '\t\t}\n', '\t\tif (msg.sender == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(msg.sender, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Utility function for the above transfer function, to pass arrays.\n', '\t// ------------------------------------------------------------------------\n', '\tfunction batchTransfer(address[] tos, uint[] tokens) public returns (bool success) {\n', '\t\trequire(tos.length == tokens.length);\n', '\t\tuint tosLength = tos.length;\n', '\t\tfor (uint i = 0; i < tosLength; i++) {\n', '\t\t\ttransfer(tos[i], tokens[i]);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Transfer `tokens` from the `from` account to the `to` account\n', '\t// \n', '\t// The calling account must already have sufficient tokens approve(...)-d\n', '\t// for spending from the `from` account and\n', '\t// - From account must have sufficient balance to transfer\n', '\t// - Spender must have sufficient allowance to transfer\n', '\t// - 0 value transfers are allowed\n', '\t// ------------------------------------------------------------------------\n', '\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '\t\trequire((from == owner) || (crowdSalesCompleted > 0));\n', '\t\trequire(from != to);\n', '\t\trequire(to != owner);\n', '\t\tbalances[from] = balances[from].sub(tokens);\n', '\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '\t\tbalances[to] = balances[to].add(tokens);\n', '\t\tif (owed[from][to] >= tokens) {\n', '\t\t\towed[from][to].sub(tokens);\n', '\t\t} else if (owed[from][to] < tokens) {\n', '\t\t\towed[from][to] = uint(0);\n', '\t\t}\n', '\t\tif (from == owner) {\n', '\t\t\treleasedSupply.add(tokens);\n', '\t\t}\n', '\t\temit Transfer(from, to, tokens);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Change ETH cost of token (goal is to keep it pegged to 0.10 USD)\n', '\t// Cost must be specified in Wei\n', '\t// ------------------------------------------------------------------------\n', '\tfunction changeWeiCostOfToken(uint newCost, uint weiMinimum, uint weiMaximum) public onlyOwners returns (bool success) {\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(newCost > 0);\n', '\t\trequire(weiMinimum >= 0);\n', '\t\trequire(weiMaximum >= 0);\n', '\t\tweiCostOfToken = newCost * 1 wei;\n', '\t\tcrowdSaleWeiMinimum = weiMinimum;\n', '\t\tcrowdSaleWeiMaximum = weiMaximum;\n', '\t\temit ChangedWeiCostOfToken(weiCostOfToken, crowdSaleWeiMinimum, crowdSaleWeiMaximum);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Only accept ETH during crowd sale period\n', '\t// Crowdsale purchaser must be KYCed and added to allowed map\n', '\t// ------------------------------------------------------------------------\n', '\tfunction () public payable {\n', '\t\trequire(msg.value > 0);\n', '\t\trequire(crowdSaleOngoing);\n', '\t\trequire(msg.value >= crowdSaleWeiMinimum);\n', '\t\trequire((msg.value <= crowdSaleWeiMaximum) || (crowdSaleWeiMaximum <= 0));\n', '\n', '\t\tuint tokens = (msg.value * (10**uint(decimals))) / weiCostOfToken;\n', '\t\tuint remainder = msg.value % weiCostOfToken;\n', '\n', '\t\tif (now < crowdSaleBonusADeadline) {\n', '\t\t\ttokens = (crowdSaleBonusAPercentage * tokens) / 100;\n', '\t\t} else if (now < crowdSaleBonusBDeadline) {\n', '\t\t\ttokens = (crowdSaleBonusBPercentage * tokens) / 100;\n', '\t\t}\n', '\n', '\t\tcrowdSaleAllowed[msg.sender] = crowdSaleAllowed[msg.sender].sub(tokens);\n', '\t\tcrowdSaleBalance = crowdSaleBalance.sub(tokens);\n', '\t\tbalances[msg.sender] = balances[msg.sender].add(tokens);\n', '\t\tcrowdSaleAmountRaised = crowdSaleAmountRaised.add(msg.value);\n', '\t\towner.transfer(msg.value - remainder);\n', '\t\temit Transfer(owner, msg.sender, tokens);\n', '\t\temit CrowdSalePurchaseCompleted(msg.sender, msg.value, tokens);\n', '\t\t\n', '\t\tif (crowdSaleBalance == 0) {\n', '\t\t\tcrowdSaleOngoing = false;\n', '\t\t\tcrowdSalesCompleted = crowdSalesCompleted.add(1);\n', '\t\t\temit CrowdSaleLocked(!crowdSaleOngoing, crowdSalesCompleted, crowdSaleAmountRaised);\n', '\t\t}\n', '\t\tif (remainder > 0) {\n', '\t\t\tmsg.sender.transfer(remainder);\n', '\t\t}\n', '\t}\n', '}']