['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * Libraries\n', '**/\n', '\n', 'library ExtendedMath {\n', '    function limitLessThan(uint a, uint b) internal pure returns(uint c) {\n', '        if (a > b) return b;\n', '        return a;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns(uint256);\n', '\n', '    function balanceOf(address _who) public view returns(uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address _owner, address _spender) public view returns(uint256);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath\n', '    for uint256;\n', '\n', '    mapping(address => uint256) internal balances;\n', '\n', '    uint256 internal totalSupply_;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns(uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns(bool) {\n', '        //require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) public view returns(uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns(bool) {\n', '        //require(_value <= balances[_from]);\n', '        //require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        allowed[msg.sender][_spender] = (\n', '            allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'interface IRemoteFunctions {\n', '  function _externalAddMasternode(address) external;\n', '  function _externalStopMasternode(address) external;\n', '}\n', '\n', 'interface IcaelumVoting {\n', '    function getTokenProposalDetails() external view returns(address, uint, uint, uint);\n', '    function getExpiry() external view returns (uint);\n', '    function getContractType () external view returns (uint);\n', '}\n', '\n', 'interface EIP918Interface  {\n', '\n', '    /*\n', '     * Externally facing mint function that is called by miners to validate challenge digests, calculate reward,\n', '     * populate statistics, mutate epoch variables and adjust the solution difficulty as required. Once complete,\n', '     * a Mint event is emitted before returning a success indicator.\n', '     **/\n', '  \tfunction mint(uint256 nonce, bytes32 challenge_digest) external returns (bool success);\n', '\n', '\n', '\t/*\n', '     * Returns the challenge number\n', '     **/\n', '    function getChallengeNumber() external constant returns (bytes32);\n', '\n', '    /*\n', '     * Returns the mining difficulty. The number of digits that the digest of the PoW solution requires which\n', '     * typically auto adjusts during reward generation.\n', '     **/\n', '    function getMiningDifficulty() external constant returns (uint);\n', '\n', '    /*\n', '     * Returns the mining target\n', '     **/\n', '    function getMiningTarget() external constant returns (uint);\n', '\n', '    /*\n', '     * Return the current reward amount. Depending on the algorithm, typically rewards are divided every reward era\n', '     * as tokens are mined to provide scarcity\n', '     **/\n', '    function getMiningReward() external constant returns (uint);\n', '\n', '    /*\n', '     * Upon successful verification and reward the mint method dispatches a Mint Event indicating the reward address,\n', '     * the reward amount, the epoch count and newest challenge number.\n', '     **/\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', 'contract NewMinerProposal is IcaelumVoting {\n', '\n', '    enum VOTE_TYPE {MINER, MASTER, TOKEN}\n', '\n', '    VOTE_TYPE public contractType = VOTE_TYPE.TOKEN;\n', '    address contractAddress;\n', '    uint validUntil;\n', '    uint votingDurationInDays;\n', '\n', '    /**\n', '     * @dev Create a new vote proposal for an ERC20 token.\n', '     * @param _contract ERC20 contract\n', '     * @param _valid How long do we accept these tokens on the contract (UNIX timestamp)\n', '     * @param _voteDuration How many days is this vote available\n', '     */\n', '    constructor(address _contract, uint _valid, uint _voteDuration) public {\n', '        require(_voteDuration >= 14 && _voteDuration <= 50, "Proposed voting duration does not meet requirements");\n', '\n', '        contractAddress = _contract;\n', '        validUntil = _valid;\n', '        votingDurationInDays = _voteDuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about this proposal\n', '     */\n', '    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\n', '        return (contractAddress, 0, validUntil, uint(contractType));\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the expiry date of contract\n', '     * @return uint Days valid\n', '     */\n', '    function getExpiry() external view returns (uint) {\n', '        return votingDurationInDays;\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the type of contract\n', '     * @return uint Enum value {TOKEN, TEAM}\n', '     */\n', '    function getContractType () external view returns (uint){\n', '        return uint(contractType);\n', '    }\n', '}\n', '\n', 'contract CaelumVotings is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    enum VOTE_TYPE {MINER, MASTER, TOKEN}\n', '\n', '    struct Proposals {\n', '        address tokenContract;\n', '        uint totalVotes;\n', '        uint proposedOn;\n', '        uint acceptedOn;\n', '        VOTE_TYPE proposalType;\n', '    }\n', '\n', '    struct Voters {\n', '        bool isVoter;\n', '        address owner;\n', '        uint[] votedFor;\n', '    }\n', '\n', '    uint MAJORITY_PERCENTAGE_NEEDED = 60;\n', '    uint MINIMUM_VOTERS_NEEDED = 1;\n', '    bool public proposalPending;\n', '\n', '    mapping(uint => Proposals) public proposalList;\n', '    mapping (address => Voters) public voterMap;\n', '    mapping(uint => address) public voterProposals;\n', '    uint public proposalCounter;\n', '    uint public votersCount;\n', '    uint public votersCountTeam;\n', '\n', '\n', '    function setMasternodeContractFromVote(address _t) internal ;\n', '    function setTokenContractFromVote(address _t) internal;\n', '    function setMiningContractFromVote (address _t) internal;\n', '\n', '    event NewProposal(uint ProposalID);\n', '    event ProposalAccepted(uint ProposalID);\n', '\n', '    address _CaelumMasternodeContract;\n', '    CaelumMasternode public MasternodeContract;\n', '\n', '    function setMasternodeContractForData(address _t) onlyOwner public {\n', '        MasternodeContract = CaelumMasternode(_t);\n', '        _CaelumMasternodeContract = (_t);\n', '    }\n', '\n', '    function setVotingMinority(uint _total) onlyOwner public {\n', '        require(_total > MINIMUM_VOTERS_NEEDED);\n', '        MINIMUM_VOTERS_NEEDED = _total;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Create a new proposal.\n', '     * @param _contract Proposal contract address\n', '     * @return uint ProposalID\n', '     */\n', '    function pushProposal(address _contract) onlyOwner public returns (uint) {\n', '        if(proposalCounter != 0)\n', '        require (pastProposalTimeRules (), "You need to wait 90 days before submitting a new proposal.");\n', '        require (!proposalPending, "Another proposal is pending.");\n', '\n', '        uint _contractType = IcaelumVoting(_contract).getContractType();\n', '        proposalList[proposalCounter] = Proposals(_contract, 0, now, 0, VOTE_TYPE(_contractType));\n', '\n', '        emit NewProposal(proposalCounter);\n', '\n', '        proposalCounter++;\n', '        proposalPending = true;\n', '\n', '        return proposalCounter.sub(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that handles the proposal after it got accepted.\n', '     * This function determines if the proposal is a token or team member proposal and executes the corresponding functions.\n', '     * @return uint Returns the proposal ID.\n', '     */\n', '    function handleLastProposal () internal returns (uint) {\n', '        uint _ID = proposalCounter.sub(1);\n', '\n', '        proposalList[_ID].acceptedOn = now;\n', '        proposalPending = false;\n', '\n', '        address _address;\n', '        uint _required;\n', '        uint _valid;\n', '        uint _type;\n', '        (_address, _required, _valid, _type) = getTokenProposalDetails(_ID);\n', '\n', '        if(_type == uint(VOTE_TYPE.MINER)) {\n', '            setMiningContractFromVote(_address);\n', '        }\n', '\n', '        if(_type == uint(VOTE_TYPE.MASTER)) {\n', '            setMasternodeContractFromVote(_address);\n', '        }\n', '\n', '        if(_type == uint(VOTE_TYPE.TOKEN)) {\n', '            setTokenContractFromVote(_address);\n', '        }\n', '\n', '        emit ProposalAccepted(_ID);\n', '\n', '        return _ID;\n', '    }\n', '\n', '    /**\n', "     * @dev Rejects the last proposal after the allowed voting time has expired and it's not accepted.\n", '     */\n', '    function discardRejectedProposal() onlyOwner public returns (bool) {\n', '        require(proposalPending);\n', '        require (LastProposalCanDiscard());\n', '        proposalPending = false;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', "     * @dev Checks if the last proposal allowed voting time has expired and it's not accepted.\n", '     * @return bool\n', '     */\n', '    function LastProposalCanDiscard () public view returns (bool) {\n', '\n', '        uint daysBeforeDiscard = IcaelumVoting(proposalList[proposalCounter - 1].tokenContract).getExpiry();\n', '        uint entryDate = proposalList[proposalCounter - 1].proposedOn;\n', '        uint expiryDate = entryDate + (daysBeforeDiscard * 1 days);\n', '\n', '        if (now >= expiryDate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about a proposal\n', '     */\n', '    function getTokenProposalDetails(uint proposalID) public view returns(address, uint, uint, uint) {\n', '        return IcaelumVoting(proposalList[proposalID].tokenContract).getTokenProposalDetails();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if our 90 day cooldown has passed\n', '     * @return bool\n', '     */\n', '    function pastProposalTimeRules() public view returns (bool) {\n', '        uint lastProposal = proposalList[proposalCounter - 1].proposedOn;\n', '        if (now >= lastProposal + 90 days)\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allow any masternode user to become a voter.\n', '     */\n', '    function becomeVoter() public  {\n', '        require (MasternodeContract.isMasternodeOwner(msg.sender), "User has no masternodes");\n', '        require (!voterMap[msg.sender].isVoter, "User Already voted for this proposal");\n', '\n', '        voterMap[msg.sender].owner = msg.sender;\n', '        voterMap[msg.sender].isVoter = true;\n', '        votersCount = votersCount + 1;\n', '\n', '        if (MasternodeContract.isTeamMember(msg.sender))\n', '        votersCountTeam = votersCountTeam + 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow voters to submit their vote on a proposal. Voters can only cast 1 vote per proposal.\n', '     * If the proposed vote is about adding Team members, only Team members are able to vote.\n', '     * A proposal can only be published if the total of votes is greater then MINIMUM_VOTERS_NEEDED.\n', '     * @param proposalID proposalID\n', '     */\n', '    function voteProposal(uint proposalID) public returns (bool success) {\n', '        require(voterMap[msg.sender].isVoter, "Sender not listed as voter");\n', '        require(proposalID >= 0, "No proposal was selected.");\n', '        require(proposalID <= proposalCounter, "Proposal out of limits.");\n', '        require(voterProposals[proposalID] != msg.sender, "Already voted.");\n', '\n', '\n', '        require(votersCount >= MINIMUM_VOTERS_NEEDED, "Not enough voters in existence to push a proposal");\n', '        voterProposals[proposalID] = msg.sender;\n', '        proposalList[proposalID].totalVotes++;\n', '\n', '        if(reachedMajority(proposalID)) {\n', '            // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\n', '            // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\n', '            handleLastProposal();\n', '            return true;\n', '\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajority (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majority())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majority () internal view returns (uint) {\n', '        uint a = (votersCount * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote for a team member\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajorityForTeam (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majorityForTeam())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majorityForTeam () internal view returns (uint) {\n', '        uint a = (votersCountTeam * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumAcceptERC20 is Ownable  {\n', '    using SafeMath for uint;\n', '\n', '    IRemoteFunctions public DataVault;\n', '\n', '    address[] public tokensList;\n', '    bool setOwnContract = true;\n', '\n', '    struct _whitelistTokens {\n', '        address tokenAddress;\n', '        bool active;\n', '        uint requiredAmount;\n', '        uint validUntil;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping(address => mapping(address => uint)) public tokens;\n', '    mapping(address => _whitelistTokens) acceptedTokens;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    \n', '\n', '\n', '    /**\n', "     * @notice Allow the dev to set it's own token as accepted payment.\n", '     * @dev Can be hardcoded in the constructor. Given the contract size, we decided to separate it.\n', '     * @return bool\n', '     */\n', '    function addOwnToken() onlyOwner public returns (bool) {\n', '        require(setOwnContract);\n', '        addToWhitelist(this, 5000 * 1e8, 36500);\n', '        setOwnContract = false;\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Add a new token as accepted payment method.\n', '     * @param _token Token contract address.\n', '     * @param _amount Required amount of this Token as collateral\n', '     * @param daysAllowed How many days will we accept this token?\n', '     */\n', '    function addToWhitelist(address _token, uint _amount, uint daysAllowed) internal {\n', '        _whitelistTokens storage newToken = acceptedTokens[_token];\n', '        newToken.tokenAddress = _token;\n', '        newToken.requiredAmount = _amount;\n', '        newToken.timestamp = now;\n', '        newToken.validUntil = now + (daysAllowed * 1 days);\n', '        newToken.active = true;\n', '\n', '        tokensList.push(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if we accept this token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isAcceptedToken(address _ad) internal view returns(bool) {\n', '        return acceptedTokens[_ad].active;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine the requiredAmount for a specific token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function getAcceptedTokenAmount(address _ad) internal view returns(uint) {\n', '        return acceptedTokens[_ad].requiredAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if the token is still accepted timewise.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isValid(address _ad) internal view returns(bool) {\n', '        uint endTime = acceptedTokens[_ad].validUntil;\n', '        if (block.timestamp < endTime) return true;\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns an array of all accepted token. You can get more details by calling getTokenDetails function with this address.\n', '     * @return array Address\n', '     */\n', '    function listAcceptedTokens() public view returns(address[]) {\n', '        return tokensList;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns a full list of the token details\n', '     * @param token Token contract address\n', '     */\n', '    function getTokenDetails(address token) public view returns(address ad,uint required, bool active, uint valid) {\n', '        return (acceptedTokens[token].tokenAddress, acceptedTokens[token].requiredAmount,acceptedTokens[token].active, acceptedTokens[token].validUntil);\n', '    }\n', '\n', '    /**\n', '     * @notice Public function that allows any user to deposit accepted tokens as collateral to become a masternode.\n', '     * @param token Token contract address\n', '     * @param amount Amount to deposit\n', '     */\n', '    function depositCollateral(address token, uint amount) public {\n', '        require(isAcceptedToken(token), "ERC20 not authorised");  // Should be a token from our list\n', '        require(amount == getAcceptedTokenAmount(token));         // The amount needs to match our set amount\n', '        require(isValid(token));                                  // It should be called within the setup timeframe\n', '\n', '        tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '\n', '        require(StandardToken(token).transferFrom(msg.sender, this, amount), "error with token");\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        DataVault._externalAddMasternode(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Public function that allows any user to withdraw deposited tokens and stop as masternode\n', '     * @param token Token contract address\n', '     * @param amount Amount to withdraw\n', '     */\n', '    function withdrawCollateral(address token, uint amount) public {\n', '        require(token != 0);                                        // token should be an actual address\n', '        require(isAcceptedToken(token), "ERC20 not authorised");    // Should be a token from our list\n', '        require(amount == getAcceptedTokenAmount(token));           // The amount needs to match our set amount, allow only one withdrawal at a time.\n', '        require(tokens[token][msg.sender] >= amount);               // The owner must own at least this amount of tokens.\n', '\n', '        uint amountToWithdraw = tokens[token][msg.sender];\n', '        tokens[token][msg.sender] = 0;\n', '\n', '        DataVault._externalStopMasternode(msg.sender);\n', '\n', '        if (!StandardToken(token).transfer(msg.sender, amountToWithdraw)) revert();\n', '        emit Withdraw(token, msg.sender, amountToWithdraw, amountToWithdraw);\n', '    }\n', '\n', '    function setDataStorage (address _masternodeContract) onlyOwner public {\n', '        DataVault = IRemoteFunctions(_masternodeContract);\n', '    }\n', '}\n', '\n', 'contract CaelumAbstractMasternode is Ownable{\n', '    using SafeMath for uint;\n', '\n', '    bool onTestnet = false;\n', '    bool genesisAdded = false;\n', '\n', '    uint public masternodeRound;\n', '    uint public masternodeCandidate;\n', '    uint public masternodeCounter;\n', '    uint public masternodeEpoch;\n', '    uint public miningEpoch;\n', '\n', '    uint public rewardsProofOfWork;\n', '    uint public rewardsMasternode;\n', '    uint rewardsGlobal = 50 * 1e8;\n', '\n', '    uint public MINING_PHASE_DURATION_BLOCKS = 4500;\n', '\n', '    struct MasterNode {\n', '        address accountOwner;\n', '        bool isActive;\n', '        bool isTeamMember;\n', '        uint storedIndex;\n', '        uint startingRound;\n', '        uint[] indexcounter;\n', '    }\n', '\n', '    uint[] userArray;\n', '    address[] userAddressArray;\n', '\n', '    mapping(uint => MasterNode) userByIndex; // UINT masterMapping\n', '    mapping(address => MasterNode) userByAddress; //masterMapping\n', '    mapping(address => uint) userAddressIndex;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    event NewMasternode(address candidateAddress, uint timeStamp);\n', '    event RemovedMasternode(address candidateAddress, uint timeStamp);\n', '\n', '    /**\n', '     * @dev Add the genesis accounts\n', '     */\n', '    function addGenesis(address _genesis, bool _team) onlyOwner public {\n', '        require(!genesisAdded);\n', '\n', '        addMasternode(_genesis);\n', '\n', '        if (_team) {\n', '            updateMasternodeAsTeamMember(msg.sender);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Close the genesis accounts\n', '     */\n', '    function closeGenesis() onlyOwner public {\n', '        genesisAdded = true; // Forever lock this.\n', '    }\n', '\n', '    /**\n', '     * @dev Add a user as masternode. Called as internal since we only add masternodes by depositing collateral or by voting.\n', '     * @param _candidate Candidate address\n', '     * @return uint Masternode index\n', '     */\n', '    function addMasternode(address _candidate) internal returns(uint) {\n', '        userByIndex[masternodeCounter].accountOwner = _candidate;\n', '        userByIndex[masternodeCounter].isActive = true;\n', '        userByIndex[masternodeCounter].startingRound = masternodeRound + 1;\n', '        userByIndex[masternodeCounter].storedIndex = masternodeCounter;\n', '\n', '        userByAddress[_candidate].accountOwner = _candidate;\n', '        userByAddress[_candidate].indexcounter.push(masternodeCounter);\n', '\n', '        userArray.push(userArray.length);\n', '        masternodeCounter++;\n', '\n', '        emit NewMasternode(_candidate, now);\n', '        return masternodeCounter - 1; //\n', '    }\n', '\n', '    /**\n', "     * @dev Allow us to update a masternode's round to keep progress\n", '     * @param _candidate ID of masternode\n', '     */\n', '    function updateMasternode(uint _candidate) internal returns(bool) {\n', '        userByIndex[_candidate].startingRound++;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow us to update a masternode to team member status\n', '     * @param _member address\n', '     */\n', '    function updateMasternodeAsTeamMember(address _member) internal returns (bool) {\n', '        userByAddress[_member].isTeamMember = true;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', '     * @dev Let us know if an address is part of the team.\n', '     * @param _member address\n', '     */\n', '    function isTeamMember (address _member) public view returns (bool) {\n', '        if (userByAddress[_member].isTeamMember)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a specific masternode\n', '     * @param _masternodeID ID of the masternode to remove\n', '     */\n', '    function deleteMasternode(uint _masternodeID) internal returns(bool success) {\n', '\n', '        uint rowToDelete = userByIndex[_masternodeID].storedIndex;\n', '        uint keyToMove = userArray[userArray.length - 1];\n', '\n', '        userByIndex[_masternodeID].isActive = userByIndex[_masternodeID].isActive = (false);\n', '        userArray[rowToDelete] = keyToMove;\n', '        userByIndex[keyToMove].storedIndex = rowToDelete;\n', '        userArray.length = userArray.length - 1;\n', '\n', '        removeFromUserCounter(_masternodeID);\n', '\n', '        emit RemovedMasternode(userByIndex[_masternodeID].accountOwner, now);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev returns what account belongs to a masternode\n', '     */\n', '    function isPartOf(uint mnid) public view returns (address) {\n', '        return userByIndex[mnid].accountOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to remove a masternode from a user address if this address holds multpile masternodes\n', '     * @param index MasternodeID\n', '     */\n', '    function removeFromUserCounter(uint index)  internal returns(uint[]) {\n', '        address belong = isPartOf(index);\n', '\n', '        if (index >= userByAddress[belong].indexcounter.length) return;\n', '\n', '        for (uint i = index; i<userByAddress[belong].indexcounter.length-1; i++){\n', '            userByAddress[belong].indexcounter[i] = userByAddress[belong].indexcounter[i+1];\n', '        }\n', '\n', '        delete userByAddress[belong].indexcounter[userByAddress[belong].indexcounter.length-1];\n', '        userByAddress[belong].indexcounter.length--;\n', '        return userByAddress[belong].indexcounter;\n', '    }\n', '\n', '    /**\n', '     * @dev Primary contract function to update the current user and prepare the next one.\n', '     * A number of steps have been token to ensure the contract can never run out of gas when looping over our masternodes.\n', '     */\n', '    function setMasternodeCandidate() internal returns(address) {\n', '\n', '        uint hardlimitCounter = 0;\n', '\n', '        while (getFollowingCandidate() == 0x0) {\n', '            // We must return a value not to break the contract. Require is a secondary killswitch now.\n', '            require(hardlimitCounter < 6, "Failsafe switched on");\n', '            // Choose if loop over revert/require to terminate the loop and return a 0 address.\n', '            if (hardlimitCounter == 5) return (0);\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '            hardlimitCounter++;\n', '        }\n', '\n', '        if (masternodeCandidate == masternodeCounter - 1) {\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == masternodeRound) {\n', '                    updateMasternode(i);\n', '                    masternodeCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        masternodeRound = masternodeRound + 1;\n', '        return (0);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to loop through our masternodes at start and return the correct round\n', '     */\n', '    function getFollowingCandidate() internal view returns(address _address) {\n', '        uint tmpRound = masternodeRound;\n', '        uint tmpCandidate = masternodeCandidate;\n', '\n', '        if (tmpCandidate == masternodeCounter - 1) {\n', '            tmpRound = tmpRound + 1;\n', '            tmpCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == tmpRound) {\n', '                    tmpCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        tmpRound = tmpRound + 1;\n', '        return (0);\n', '    }\n', '\n', '    /**\n', '     * @dev Displays all masternodes belonging to a user address.\n', '     */\n', '    function belongsToUser(address userAddress) public view returns(uint[]) {\n', '        return (userByAddress[userAddress].indexcounter);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to know if an address owns masternodes\n', '     */\n', '    function isMasternodeOwner(address _candidate) public view returns(bool) {\n', '        if(userByAddress[_candidate].indexcounter.length <= 0) return false;\n', '        if (userByAddress[_candidate].accountOwner == _candidate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to get the last masternode belonging to a user\n', '     */\n', '    function getLastPerUser(address _candidate) public view returns (uint) {\n', '        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\n', '    }\n', '\n', '    /**\n', '     * @dev Return the base rewards. This should be overrided by the miner contract.\n', '     * Return a base value for standalone usage ONLY.\n', '     */\n', '    function getMiningReward() public view returns(uint) {\n', '        return 50 * 1e8;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate and set the reward schema for Caelum.\n', '     * Each mining phase is decided by multiplying the MINING_PHASE_DURATION_BLOCKS with factor 10.\n', '     * Depending on the outcome (solidity always rounds), we can detect the current stage of mining.\n', '     * First stage we cut the rewards to 5% to prevent instamining.\n', '     * Last stage we leave 2% for miners to incentivize keeping miners running.\n', '     */\n', '    function calculateRewardStructures() internal {\n', '        //ToDo: Set\n', '        uint _global_reward_amount = getMiningReward();\n', '        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\n', '\n', '        if (getStageOfMining < 10) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 5;\n', '            rewardsMasternode = 0;\n', '            return;\n', '        }\n', '\n', '        if (getStageOfMining > 90) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 2;\n', '            rewardsMasternode = _global_reward_amount / 100 * 98;\n', '            return;\n', '        }\n', '\n', '        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\n', '        uint _powreward = (_global_reward_amount - _mnreward);\n', '\n', '        setBaseRewards(_powreward, _mnreward);\n', '    }\n', '\n', '    function setBaseRewards(uint _pow, uint _mn) internal {\n', '        rewardsMasternode = _mn;\n', '        rewardsProofOfWork = _pow;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     */\n', '    function _arrangeMasternodeFlow() internal {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     * This is an emergency manual loop method.\n', '     */\n', '    function _emergencyLoop() onlyOwner public {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    function masternodeInfo(uint index) public view returns\n', '    (\n', '        address,\n', '        bool,\n', '        uint,\n', '        uint\n', '    )\n', '    {\n', '        return (\n', '            userByIndex[index].accountOwner,\n', '            userByIndex[index].isActive,\n', '            userByIndex[index].storedIndex,\n', '            userByIndex[index].startingRound\n', '        );\n', '    }\n', '\n', '    function contractProgress() public view returns\n', '    (\n', '        uint epoch,\n', '        uint candidate,\n', '        uint round,\n', '        uint miningepoch,\n', '        uint globalreward,\n', '        uint powreward,\n', '        uint masternodereward,\n', '        uint usercounter\n', '    )\n', '    {\n', '        return (\n', '            masternodeEpoch,\n', '            masternodeCandidate,\n', '            masternodeRound,\n', '            miningEpoch,\n', '            getMiningReward(),\n', '            rewardsProofOfWork,\n', '            rewardsMasternode,\n', '            masternodeCounter\n', '        );\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumMasternode is CaelumVotings, CaelumAbstractMasternode {\n', '\n', '    /**\n', '     * @dev Hardcoded token mining address. For trust and safety we do not allow changing this.\n', '     * Should anything change, a new instance needs to be redeployed.\n', '     */\n', '    address public miningContract;\n', '    address public tokenContract;\n', '    \n', '    bool minerSet = false;\n', '    bool tokenSet = false;\n', '\n', '    function setMiningContract(address _t) onlyOwner public {\n', '        require(!minerSet);\n', '        miningContract = _t;\n', '        minerSet = true;\n', '    }\n', '\n', '    function setTokenContract(address _t) onlyOwner public {\n', '        require(!tokenSet);\n', '        tokenContract = _t;\n', '        tokenSet = true;\n', '    }\n', '\n', '    function setMasternodeContractFromVote(address _t) internal {\n', '    }\n', '\n', '    function setTokenContractFromVote(address _t) internal{\n', '        tokenContract = _t;\n', '    }\n', '\n', '    function setMiningContractFromVote (address _t) internal {\n', '        miningContract = _t;\n', '    }\n', '\n', '    /**\n', '     * @dev Only allow the token mining contract to call this function when used remotely.\n', '     * Use the internal function when working within the same contract.\n', '     */\n', '    modifier onlyMiningContract() {\n', '        require(msg.sender == miningContract);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Only allow the token contract to call this function when used remotely.\n', '     * Use the internal function when working within the same contract.\n', '     */\n', '    modifier onlyTokenContract() {\n', '        require(msg.sender == tokenContract);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Only allow the token contract to call this function when used remotely.\n', '     * Use the internal function when working within the same contract.\n', '     */\n', '    modifier bothRemoteContracts() {\n', '        require(msg.sender == tokenContract || msg.sender == miningContract);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Use this to externaly call the _arrangeMasternodeFlow function. ALWAYS set a modifier !\n', '     */\n', '    function _externalArrangeFlow() onlyMiningContract external {\n', '        _arrangeMasternodeFlow();\n', '    }\n', '\n', '    /**\n', '     * @dev Use this to externaly call the addMasternode function. ALWAYS set a modifier !\n', '     */\n', '    function _externalAddMasternode(address _received) onlyMiningContract external {\n', '        addMasternode(_received);\n', '    }\n', '\n', '    /**\n', '     * @dev Use this to externaly call the deleteMasternode function. ALWAYS set a modifier !\n', '     */\n', '    function _externalStopMasternode(address _received) onlyMiningContract external {\n', '        deleteMasternode(getLastPerUser(_received));\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return CaelumMiner(miningContract).getMiningReward();\n', '    }\n', '    \n', '    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\n', '    \n', '    function getDataFromContract () onlyOwner public returns(uint) {\n', '        \n', '        CaelumMasternode prev = CaelumMasternode(cloneDataFrom);\n', '        (uint epoch,\n', '        uint candidate,\n', '        uint round,\n', '        uint miningepoch,\n', '        uint globalreward,\n', '        uint powreward,\n', '        uint masternodereward,\n', '        uint usercounter) = prev.contractProgress();\n', '        \n', '        masternodeEpoch = epoch;\n', '        masternodeRound = round;\n', '        miningEpoch = miningepoch;\n', '        rewardsProofOfWork = powreward;\n', '        rewardsMasternode = masternodereward;\n', '\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumToken is Ownable, StandardToken, CaelumVotings, CaelumAcceptERC20 {\n', '    using SafeMath for uint;\n', '\n', '    ERC20 previousContract;\n', '    \n', '    bool contractSet = false;\n', '    bool public swapClosed = false;\n', '    uint public swapCounter;\n', '\n', '    string public symbol = "CLM";\n', '    string public name = "Caelum Token";\n', '    uint8 public decimals = 8;\n', '    uint256 public totalSupply = 2100000000000000;\n', '    \n', '    address public miningContract = 0x0;\n', '\n', '    /**\n', '     * @dev Only allow the token mining contract to call this function when used remotely.\n', '     * Use the internal function when working within the same contract.\n', '     */\n', '    modifier onlyMiningContract() {\n', '        require(msg.sender == miningContract);\n', '        _;\n', '    }\n', '\n', '    constructor(address _previousContract) public {\n', '        previousContract = ERC20(_previousContract);\n', '        swapClosed = false;\n', '        swapCounter = 0;\n', '    }\n', '\n', '    function setMiningContract (address _t) onlyOwner public {\n', '        require(!contractSet);\n', '        miningContract = _t;\n', '        contractSet = true;\n', '    }\n', '\n', '    function setMasternodeContractFromVote(address _t) internal {\n', '        return;\n', '    }\n', '\n', '    function setTokenContractFromVote(address _t) internal{\n', '        return;\n', '    }\n', '\n', '    function setMiningContractFromVote (address _t) internal {\n', '        miningContract = _t;\n', '    }\n', '    \n', '    function changeSwapState (bool _state) onlyOwner public {\n', '        require(swapCounter <= 9);\n', '        swapClosed = _state;\n', '        swapCounter++;\n', '    }\n', '\n', '    function rewardExternal(address _receiver, uint _amount) onlyMiningContract external {\n', '        balances[_receiver] = balances[_receiver].add(_amount);\n', '        emit Transfer(this, _receiver, _amount);\n', '    }\n', '\n', '\n', '    function upgradeTokens() public{\n', '        require(!swapClosed);\n', '        uint amountToUpgrade = previousContract.balanceOf(msg.sender);\n', '        require(amountToUpgrade <= previousContract.allowance(msg.sender, this));\n', '        \n', '        if(previousContract.transferFrom(msg.sender, this, amountToUpgrade)){\n', '            balances[msg.sender] = balances[msg.sender].add(amountToUpgrade); // 2% Premine as determined by the community meeting.\n', '            emit Transfer(this, msg.sender, amountToUpgrade);\n', '        }\n', '        \n', '        require(previousContract.balanceOf(msg.sender) == 0);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract AbstractERC918 is EIP918Interface {\n', '\n', '    // generate a new challenge number after a new reward is minted\n', '    bytes32 public challengeNumber;\n', '\n', '    // the current mining difficulty\n', '    uint public difficulty;\n', '\n', '    // cumulative counter of the total minted tokens\n', '    uint public tokensMinted;\n', '\n', '    // track read only minting statistics\n', '    struct Statistics {\n', '        address lastRewardTo;\n', '        uint lastRewardAmount;\n', '        uint lastRewardEthBlockNumber;\n', '        uint lastRewardTimestamp;\n', '    }\n', '\n', '    Statistics public statistics;\n', '\n', '    /*\n', '     * Externally facing mint function that is called by miners to validate challenge digests, calculate reward,\n', '     * populate statistics, mutate epoch variables and adjust the solution difficulty as required. Once complete,\n', '     * a Mint event is emitted before returning a success indicator.\n', '     **/\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '\n', '    /*\n', '     * Internal interface function _hash. Overide in implementation to define hashing algorithm and\n', '     * validation\n', '     **/\n', '    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns (bytes32 digest);\n', '\n', '    /*\n', '     * Internal interface function _reward. Overide in implementation to calculate and return reward\n', '     * amount\n', '     **/\n', '    function _reward() internal returns (uint);\n', '\n', '    /*\n', '     * Internal interface function _newEpoch. Overide in implementation to define a cutpoint for mutating\n', '     * mining variables in preparation for the next epoch\n', '     **/\n', '    function _newEpoch(uint256 nonce) internal returns (uint);\n', '\n', '    /*\n', '     * Internal interface function _adjustDifficulty. Overide in implementation to adjust the difficulty\n', '     * of the mining as required\n', '     **/\n', '    function _adjustDifficulty() internal returns (uint);\n', '\n', '}\n', '\n', 'contract CaelumAbstractMiner is AbstractERC918 {\n', '    /**\n', '     * CaelumMiner contract.\n', '     *\n', '     * We need to make sure the contract is 100% compatible when using the EIP918Interface.\n', '     * This contract is an abstract Caelum miner contract.\n', '     *\n', "     * Function 'mint', and '_reward' are overriden in the CaelumMiner contract.\n", "     * Function '_reward_masternode' is added and needs to be overriden in the CaelumMiner contract.\n", '     */\n', '\n', '    using SafeMath for uint;\n', '    using ExtendedMath for uint;\n', '\n', '    uint256 public totalSupply = 2100000000000000;\n', '\n', '    uint public latestDifficultyPeriodStarted;\n', '    uint public epochCount;\n', '    uint public baseMiningReward = 50;\n', '    uint public blocksPerReadjustment = 512;\n', '    uint public _MINIMUM_TARGET = 2 ** 16;\n', '    uint public _MAXIMUM_TARGET = 2 ** 234;\n', '    uint public rewardEra = 0;\n', '\n', '    uint public maxSupplyForEra;\n', '    uint public MAX_REWARD_ERA = 39;\n', '    uint public MINING_RATE_FACTOR = 60; //mint the token 60 times less often than ether\n', '\n', '    uint public MAX_ADJUSTMENT_PERCENT = 100;\n', '    uint public TARGET_DIVISOR = 2000;\n', '    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    bytes32 public challengeNumber;\n', '    uint public difficulty;\n', '    uint public tokensMinted;\n', '\n', '\n', '    Statistics public statistics;\n', '\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '    event RewardMasternode(address candidate, uint amount);\n', '\n', '    constructor() public {\n', '        tokensMinted = 0;\n', '        maxSupplyForEra = totalSupply.div(2);\n', '        difficulty = _MAXIMUM_TARGET;\n', '        latestDifficultyPeriodStarted = block.number;\n', '        _newEpoch(0);\n', '    }\n', '\n', '\n', '\n', '    function _newEpoch(uint256 nonce) internal returns(uint) {\n', '\n', '        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < MAX_REWARD_ERA) {\n', '            rewardEra = rewardEra + 1;\n', '        }\n', '        maxSupplyForEra = totalSupply - totalSupply.div(2 ** (rewardEra + 1));\n', '        epochCount = epochCount.add(1);\n', '        challengeNumber = blockhash(block.number - 1);\n', '        return (epochCount);\n', '    }\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success);\n', '\n', '    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns(bytes32 digest) {\n', '        digest = keccak256(challengeNumber, msg.sender, nonce);\n', '        if (digest != challenge_digest) revert();\n', '        if (uint256(digest) > difficulty) revert();\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        solutionForChallenge[challengeNumber] = digest;\n', '        if (solution != 0x0) revert(); //prevent the same answer from awarding twice\n', '    }\n', '\n', '    function _reward() internal returns(uint);\n', '\n', '    function _reward_masternode() internal returns(uint);\n', '\n', '    function _adjustDifficulty() internal returns(uint) {\n', '        //every so often, readjust difficulty. Dont readjust when deploying\n', '        if (epochCount % blocksPerReadjustment != 0) {\n', '            return difficulty;\n', '        }\n', '\n', '        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n', '        //assume 360 ethereum blocks per hour\n', "        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xbitcoin epoch\n", '        uint epochsMined = blocksPerReadjustment;\n', '        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\n', '        //if there were less eth blocks passed in time than expected\n', '        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\n', '            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\n', '            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\n', '            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n', '            //make it harder\n', '            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra)); //by up to 50 %\n', '        } else {\n', '            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\n', '            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\n', '            //make it easier\n', '            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra)); //by up to 50 %\n', '        }\n', '        latestDifficultyPeriodStarted = block.number;\n', '        if (difficulty < _MINIMUM_TARGET) //very difficult\n', '        {\n', '            difficulty = _MINIMUM_TARGET;\n', '        }\n', '        if (difficulty > _MAXIMUM_TARGET) //very easy\n', '        {\n', '            difficulty = _MAXIMUM_TARGET;\n', '        }\n', '    }\n', '\n', '    function getChallengeNumber() public view returns(bytes32) {\n', '        return challengeNumber;\n', '    }\n', '\n', '    function getMiningDifficulty() public view returns(uint) {\n', '        return _MAXIMUM_TARGET.div(difficulty);\n', '    }\n', '\n', '    function getMiningTarget() public view returns(uint) {\n', '        return difficulty;\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return (baseMiningReward * 1e8).div(2 ** rewardEra);\n', '    }\n', '\n', '    function getMintDigest(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number\n', '    )\n', '    public view returns(bytes32 digesttest) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        return digest;\n', '    }\n', '\n', '    function checkMintSolution(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number,\n', '        uint testTarget\n', '    )\n', '    public view returns(bool success) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        if (uint256(digest) > testTarget) revert();\n', '        return (digest == challenge_digest);\n', '    }\n', '}\n', '\n', 'contract CaelumMiner is CaelumVotings, CaelumAbstractMiner {\n', '\n', '    /**\n', '     * CaelumMiner main contract\n', '     *\n', '     * Inherit from our abstract CaelumMiner contract and override some functions\n', '     * of the AbstractERC918 contract to allow masternode rewardings.\n', '     *\n', '     * @dev use this contract to make all changes needed for your project.\n', '     */\n', '\n', '    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\n', '\n', '    bool ACTIVE_CONTRACT_STATE = true;\n', '    bool MasternodeSet = false;\n', '    bool TokenSet = false;\n', '\n', '    address _CaelumMasternodeContract;\n', '    address _CaelumTokenContract;\n', '\n', '    CaelumMasternode public MasternodeContract;\n', '    CaelumToken public tokenContract;\n', '\n', '    function setMasternodeContract(address _t) onlyOwner public {\n', '        require(!MasternodeSet);\n', '        MasternodeContract = CaelumMasternode(_t);\n', '        _CaelumMasternodeContract = (_t);\n', '        MasternodeSet = true;\n', '    }\n', '\n', '    function setTokenContract(address _t) onlyOwner public {\n', '        require(!TokenSet);\n', '        tokenContract = CaelumToken(_t);\n', '        _CaelumTokenContract = (_t);\n', '        TokenSet = true;\n', '    }\n', '\n', '    function setMiningContract (address _t) onlyOwner public {\n', '        return; \n', '    }\n', '\n', '    function setMasternodeContractFromVote(address _t) internal {\n', '        MasternodeContract = CaelumMasternode(_t);\n', '        _CaelumMasternodeContract = (_t);\n', '    }\n', '\n', '    function setTokenContractFromVote(address _t) internal{\n', '        tokenContract = CaelumToken(_t);\n', '        _CaelumTokenContract = (_t);\n', '    }\n', '\n', '    function setMiningContractFromVote (address _t) internal {\n', '        return;\n', '    }\n', '    \n', '    function lockMiningContract () onlyOwner public {\n', '        ACTIVE_CONTRACT_STATE = false;\n', '    }\n', '\n', '    function getDataFromContract () onlyOwner public {\n', '\n', '        require(_CaelumTokenContract != 0);\n', '        require(_CaelumMasternodeContract != 0);\n', '\n', '        CaelumMiner prev = CaelumMiner(cloneDataFrom);\n', '        difficulty = prev.difficulty();\n', '        rewardEra = prev.rewardEra();\n', '        MINING_RATE_FACTOR = prev.MINING_RATE_FACTOR();\n', '        maxSupplyForEra = prev.maxSupplyForEra();\n', '        tokensMinted = prev.tokensMinted();\n', '        epochCount = prev.epochCount();\n', '        latestDifficultyPeriodStarted = prev.latestDifficultyPeriodStarted();\n', '\n', '        ACTIVE_CONTRACT_STATE = true;\n', '    }\n', '    \n', '\n', '    /**\n', '     * @dev override of the original function since we want to call the masternode contract remotely.\n', '     */\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\n', '        // If contract is no longer active, stop accepting solutions.\n', '        require(ACTIVE_CONTRACT_STATE);\n', '\n', '        _hash(nonce, challenge_digest);\n', '\n', '        MasternodeContract._externalArrangeFlow();\n', '\n', '        uint rewardAmount =_reward();\n', '        uint rewardMasternode = _reward_masternode();\n', '\n', '        tokensMinted += rewardAmount.add(rewardMasternode);\n', '\n', '        uint epochCounter = _newEpoch(nonce);\n', '\n', '        _adjustDifficulty();\n', '\n', '        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\n', '\n', '        emit Mint(msg.sender, rewardAmount, epochCounter, challengeNumber);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev override of the original function since we want to call the masternode contract remotely.\n', '     */\n', '    function _reward() internal returns(uint) {\n', '\n', '        uint _pow = MasternodeContract.rewardsProofOfWork();\n', '\n', '        tokenContract.rewardExternal(msg.sender, _pow);\n', '\n', '        return _pow;\n', '    }\n', '\n', '    /**\n', '     * @dev override of the original function since we want to call the masternode contract remotely.\n', '     */\n', '    function _reward_masternode() internal returns(uint) {\n', '\n', '        uint _mnReward = MasternodeContract.rewardsMasternode();\n', '        if (MasternodeContract.masternodeCounter() == 0) return 0;\n', '\n', '        uint getCandidate = MasternodeContract.masternodeCandidate();\n', '        address _mnCandidate = MasternodeContract.isPartOf(getCandidate);\n', '        if (_mnCandidate == 0x0) return 0;\n', '\n', '        tokenContract.rewardExternal(_mnCandidate, _mnReward);\n', '\n', '        emit RewardMasternode(_mnCandidate, _mnReward);\n', '\n', '        return _mnReward;\n', '    }\n', '    \n', '    function getMiningReward() public view returns(uint) {\n', '        return MasternodeContract.rewardsProofOfWork();\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Burn some gas and create all contracts in a single call :-)\n', ' */\n', '\n', 'contract caelumFactory { \n', '\n', '    CaelumMiner public MINER;\n', '    CaelumMasternode public MASTER;\n', '    CaelumToken public TOKEN;\n', '\n', '    function newCookie() public {\n', '        MINER = new CaelumMiner();\n', '        MASTER = new CaelumMasternode();\n', '        TOKEN = new CaelumToken(0x0);\n', '\n', '        MASTER.setMiningContract(MINER);\n', '        MASTER.setTokenContract(TOKEN);\n', '\n', '        MINER.setMasternodeContract(MASTER);\n', '        MINER.setTokenContract(TOKEN);\n', '\n', '        TOKEN.setMiningContract(MINER);\n', '        TOKEN.setDataStorage(MASTER);\n', '\n', '        MASTER.transferOwnership(msg.sender);\n', '        TOKEN.transferOwnership(msg.sender);\n', '        MINER.transferOwnership(msg.sender);\n', '    }\n', '\n', '}']