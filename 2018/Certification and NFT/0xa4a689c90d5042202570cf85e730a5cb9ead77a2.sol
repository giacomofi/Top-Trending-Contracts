['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/upgradeability/ImplementationStorage.sol\n', '\n', '/**\n', ' * @title ImplementationStorage\n', ' * @dev This contract stores proxy implementation address.\n', ' */\n', 'contract ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "cvc.proxy.implementation", and is validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    */\n', '    constructor() public {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("cvc.proxy.implementation"));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/upgradeability/CvcProxy.sol\n', '\n', '/**\n', ' * @title CvcProxy\n', ' * @dev Transparent proxy with upgradeability functions and authorization control.\n', ' */\n', 'contract CvcProxy is ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address implementation);\n', '\n', '    /**\n', '     * @dev Emitted when the administration has been transferred.\n', '     * @param previousAdmin Address of the previous admin.\n', '     * @param newAdmin Address of the new admin.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "cvc.proxy.admin", and is validated in the constructor.\n', '     */\n', '    bytes32 private constant ADMIN_SLOT = 0x2bbac3e52eee27be250d682577104e2abe776c40160cd3167b24633933100433;\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the admin.\n', '     * It executes the function if called by admin. Otherwise, it will delegate the call to the implementation.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == currentAdmin()) {\n', '            _;\n', '        } else {\n', '            delegate(implementation());\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Contract constructor.\n', '     * It sets the `msg.sender` as the proxy admin.\n', '     */\n', '    constructor() public {\n', '        assert(ADMIN_SLOT == keccak256("cvc.proxy.admin"));\n', '        setAdmin(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function.\n', '     */\n', '    function() external payable {\n', '        require(msg.sender != currentAdmin(), "Message sender is not contract admin");\n', '        delegate(implementation());\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * Only the current admin can call this function.\n', '     * @param _newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeAdmin(address _newAdmin) external ifAdmin {\n', '        require(_newAdmin != address(0), "Cannot change contract admin to zero address");\n', '        emit AdminChanged(currentAdmin(), _newAdmin);\n', '        setAdmin(_newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     */\n', '    function upgradeTo(address _implementation) external ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade and call the new implementation\n', '     * to initialize whatever is needed through a low level call.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     * @param _data the msg.data to bet sent in the low level call. This parameter may include the function\n', '     * signature of the implementation to be called with the needed payload.\n', '     */\n', '    function upgradeToAndCall(address _implementation, bytes _data) external payable ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '        //solium-disable-next-line security/no-call-value\n', '        require(address(this).call.value(msg.value)(_data), "Upgrade error: initialization method call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the Address of the proxy admin.\n', '     * @return address\n', '     */\n', '    function admin() external view ifAdmin returns (address) {\n', '        return currentAdmin();\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the implementation address.\n', '     * @param _newImplementation the address of the new implementation to be set\n', '     */\n', '    function upgradeImplementation(address _newImplementation) private {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation, "Upgrade error: proxy contract already uses specified implementation");\n', '        setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', '     * This is a low level function that doesn&#39;t return to its internal call site.\n', '     * It will return to the external caller whatever the implementation returns.\n', '     * @param _implementation Address to delegate.\n', '     */\n', '    function delegate(address _implementation) private {\n', '        assembly {\n', '            // Copy msg.data.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '            // Call current implementation passing proxy calldata.\n', '            let result := delegatecall(gas, _implementation, 0, calldatasize, 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            // Propagate result (delegatecall returns 0 on error).\n', '            switch result\n', '            case 0 {revert(0, returndatasize)}\n', '            default {return (0, returndatasize)}\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return The admin slot.\n', '     */\n', '    function currentAdmin() private view returns (address proxyAdmin) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            proxyAdmin := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the proxy admin.\n', '     * @param _newAdmin Address of the new proxy admin.\n', '     */\n', '    function setAdmin(address _newAdmin) private {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            sstore(slot, _newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param _newImplementation Address of the new implementation.\n', '     */\n', '    function setImplementation(address _newImplementation) private {\n', '        require(\n', '            AddressUtils.isContract(_newImplementation),\n', '            "Cannot set new implementation: no contract code at contract address"\n', '        );\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(slot, _newImplementation)\n', '        }\n', '    }\n', '\n', '}']