['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = 0x0;\n', '  }\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '  \n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '}\n', '\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  constructor() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    require(owner.send(address(this).balance));\n', '  }\n', '}\n', '\n', 'contract HasNoTokens is CanReclaimToken {\n', '\n', ' /**\n', '  * @dev Reject all ERC23 compatible tokens\n', '  * @param from_ address The address that is transferring the tokens\n', '  * @param value_ uint256 the amount of the specified token\n', '  * @param data_ Bytes The data passed from the caller.\n', '  */\n', '  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract CertificateRedeemer is Claimable, HasNoTokens, HasNoEther {\n', '    /// @dev A set of addresses that are approved to sign on behalf of this contract\n', '    mapping(address => bool) public signers;\n', '\n', '    /// @dev The nonce associated with each hash(accountId).  In this case, the account is an external\n', '    /// concept that does not correspond to an Ethereum address.  Therefore, the hash of the accountId\n', '    /// is used\n', '    mapping(bytes32 => uint256) public nonces;\n', '\n', '    address public token;\n', '    address public tokenHolder;\n', '\n', '    event TokenHolderChanged(address oldTokenHolder, address newTokenHolder);\n', '    event CertificateRedeemed(string accountId, uint256 amount, address recipient, uint256 nonce, address signer);\n', '    event SignerAdded(address signer);\n', '    event SignerRemoved(address signer);\n', '    event AccountNonceChanged(uint256 oldNonce, uint256 newNone);\n', '\n', '    constructor(address _token, address _tokenHolder)\n', '    public\n', '    {\n', '        token = _token;\n', '        tokenHolder = _tokenHolder;\n', '    }\n', '\n', '    function redeemWithdrawalCertificate(string accountId, uint256 amount, address recipient, bytes signature)\n', '      external\n', '      returns (bool)\n', '    {\n', '        // although the external accountId is a string, internally we use a hash of the string\n', '        bytes32 accountHash = hashAccountId(accountId);\n', '        uint256 nonce = nonces[accountHash]++;\n', '        \n', '        // compute the message that should have been signed for this action.\n', '        bytes32 unsignedMessage = generateWithdrawalHash(accountId, amount, recipient, nonce);\n', '\n', '        // assuming the computed message is correct, recover the signer from the given signature.\n', '        // If the actual message that was signed was a different message, the recovered signer\n', '        // address will be a random address. We can be sure the correct message was signed if\n', '        // the signer is one of our approved signers.\n', '        address signer = recoverSigner(unsignedMessage, signature);\n', '\n', '        // require that the signer is an approved signer\n', '        require(signers[signer]);\n', '\n', '        // log the event, including the nonce that was used and the signer that approved the action\n', '        emit CertificateRedeemed(accountId, amount, recipient, nonce, signer);\n', '\n', '        // make sure the transfer is successful\n', '        require(ERC20(token).transferFrom(tokenHolder, recipient, amount));\n', '\n', '        return true;\n', '    }\n', '\n', '    /// Helper Methods\n', '\n', '    /**\n', '     * @dev Generates the hash of the message that needs to be signed by an approved signer.\n', '     * The nonce is read directly from the contract&#39;s state.\n', '     */\n', '    function generateWithdrawalHash(string accountId, uint256 amount, address recipient, uint256 nonce)\n', '     view\n', '     public\n', '    returns (bytes32)\n', '    {\n', '        bytes memory message = abi.encodePacked(address(this), &#39;withdraw&#39;, accountId, amount, recipient, nonce);\n', '        bytes32 messageHash = keccak256(message);\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", messageHash));\n', '    }\n', '\n', '    /**\n', '     * @dev converts and accoutId to a bytes32\n', '     */\n', '    function hashAccountId(string accountId)\n', '    pure\n', '    internal\n', '    returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked(accountId));\n', '    }\n', '\n', '\n', '    function recoverSigner(bytes32 _hash, bytes _signature)\n', '    internal\n', '    pure\n', '    returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (_signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(_signature, 32))\n', '            s := mload(add(_signature, 64))\n', '            v := byte(0, mload(add(_signature, 96)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(_hash, v, r, s);\n', '        }\n', '    }\n', '\n', '\n', '    /// Admin Methods\n', '\n', '    function updateTokenHolder(address newTokenHolder)\n', '     onlyOwner\n', '     external\n', '    {\n', '        address oldTokenHolder = tokenHolder;\n', '        tokenHolder = newTokenHolder;\n', '        emit TokenHolderChanged(oldTokenHolder, newTokenHolder);\n', '    }\n', '\n', '    function addSigner(address signer)\n', '     onlyOwner\n', '     external\n', '    {\n', '        signers[signer] = true;\n', '        emit SignerAdded(signer);\n', '    }\n', '\n', '    function removeSigner(address signer)\n', '     onlyOwner\n', '     external\n', '    {\n', '        signers[signer] = false;\n', '        emit SignerRemoved(signer);\n', '    }\n', '    \n', '    function setNonce(string accountId, uint256 newNonce) \n', '      public\n', '      onlyOwner\n', '    {\n', '        bytes32 accountHash = hashAccountId(accountId);\n', '        uint256 oldNonce = nonces[accountHash];\n', '        require(newNonce > oldNonce);\n', '        \n', '        nonces[accountHash] = newNonce;\n', '        \n', '        emit AccountNonceChanged(oldNonce, newNonce);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = 0x0;\n', '  }\n', '}\n', '\n', 'contract CanReclaimToken is Ownable {\n', '  \n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param token ERC20Basic The address of the token contract\n', '   */\n', '  function reclaimToken(ERC20Basic token) external onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '}\n', '\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  constructor() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    require(owner.send(address(this).balance));\n', '  }\n', '}\n', '\n', 'contract HasNoTokens is CanReclaimToken {\n', '\n', ' /**\n', '  * @dev Reject all ERC23 compatible tokens\n', '  * @param from_ address The address that is transferring the tokens\n', '  * @param value_ uint256 the amount of the specified token\n', '  * @param data_ Bytes The data passed from the caller.\n', '  */\n', '  function tokenFallback(address from_, uint256 value_, bytes data_) external {\n', '    revert();\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract CertificateRedeemer is Claimable, HasNoTokens, HasNoEther {\n', '    /// @dev A set of addresses that are approved to sign on behalf of this contract\n', '    mapping(address => bool) public signers;\n', '\n', '    /// @dev The nonce associated with each hash(accountId).  In this case, the account is an external\n', '    /// concept that does not correspond to an Ethereum address.  Therefore, the hash of the accountId\n', '    /// is used\n', '    mapping(bytes32 => uint256) public nonces;\n', '\n', '    address public token;\n', '    address public tokenHolder;\n', '\n', '    event TokenHolderChanged(address oldTokenHolder, address newTokenHolder);\n', '    event CertificateRedeemed(string accountId, uint256 amount, address recipient, uint256 nonce, address signer);\n', '    event SignerAdded(address signer);\n', '    event SignerRemoved(address signer);\n', '    event AccountNonceChanged(uint256 oldNonce, uint256 newNone);\n', '\n', '    constructor(address _token, address _tokenHolder)\n', '    public\n', '    {\n', '        token = _token;\n', '        tokenHolder = _tokenHolder;\n', '    }\n', '\n', '    function redeemWithdrawalCertificate(string accountId, uint256 amount, address recipient, bytes signature)\n', '      external\n', '      returns (bool)\n', '    {\n', '        // although the external accountId is a string, internally we use a hash of the string\n', '        bytes32 accountHash = hashAccountId(accountId);\n', '        uint256 nonce = nonces[accountHash]++;\n', '        \n', '        // compute the message that should have been signed for this action.\n', '        bytes32 unsignedMessage = generateWithdrawalHash(accountId, amount, recipient, nonce);\n', '\n', '        // assuming the computed message is correct, recover the signer from the given signature.\n', '        // If the actual message that was signed was a different message, the recovered signer\n', '        // address will be a random address. We can be sure the correct message was signed if\n', '        // the signer is one of our approved signers.\n', '        address signer = recoverSigner(unsignedMessage, signature);\n', '\n', '        // require that the signer is an approved signer\n', '        require(signers[signer]);\n', '\n', '        // log the event, including the nonce that was used and the signer that approved the action\n', '        emit CertificateRedeemed(accountId, amount, recipient, nonce, signer);\n', '\n', '        // make sure the transfer is successful\n', '        require(ERC20(token).transferFrom(tokenHolder, recipient, amount));\n', '\n', '        return true;\n', '    }\n', '\n', '    /// Helper Methods\n', '\n', '    /**\n', '     * @dev Generates the hash of the message that needs to be signed by an approved signer.\n', "     * The nonce is read directly from the contract's state.\n", '     */\n', '    function generateWithdrawalHash(string accountId, uint256 amount, address recipient, uint256 nonce)\n', '     view\n', '     public\n', '    returns (bytes32)\n', '    {\n', "        bytes memory message = abi.encodePacked(address(this), 'withdraw', accountId, amount, recipient, nonce);\n", '        bytes32 messageHash = keccak256(message);\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", messageHash));\n', '    }\n', '\n', '    /**\n', '     * @dev converts and accoutId to a bytes32\n', '     */\n', '    function hashAccountId(string accountId)\n', '    pure\n', '    internal\n', '    returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked(accountId));\n', '    }\n', '\n', '\n', '    function recoverSigner(bytes32 _hash, bytes _signature)\n', '    internal\n', '    pure\n', '    returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (_signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(_signature, 32))\n', '            s := mload(add(_signature, 64))\n', '            v := byte(0, mload(add(_signature, 96)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(_hash, v, r, s);\n', '        }\n', '    }\n', '\n', '\n', '    /// Admin Methods\n', '\n', '    function updateTokenHolder(address newTokenHolder)\n', '     onlyOwner\n', '     external\n', '    {\n', '        address oldTokenHolder = tokenHolder;\n', '        tokenHolder = newTokenHolder;\n', '        emit TokenHolderChanged(oldTokenHolder, newTokenHolder);\n', '    }\n', '\n', '    function addSigner(address signer)\n', '     onlyOwner\n', '     external\n', '    {\n', '        signers[signer] = true;\n', '        emit SignerAdded(signer);\n', '    }\n', '\n', '    function removeSigner(address signer)\n', '     onlyOwner\n', '     external\n', '    {\n', '        signers[signer] = false;\n', '        emit SignerRemoved(signer);\n', '    }\n', '    \n', '    function setNonce(string accountId, uint256 newNonce) \n', '      public\n', '      onlyOwner\n', '    {\n', '        bytes32 accountHash = hashAccountId(accountId);\n', '        uint256 oldNonce = nonces[accountHash];\n', '        require(newNonce > oldNonce);\n', '        \n', '        nonces[accountHash] = newNonce;\n', '        \n', '        emit AccountNonceChanged(oldNonce, newNonce);\n', '    }\n', '}']
