['pragma solidity 0.4.24;\n', 'pragma experimental "v0.5.0";\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/*\n', '\n', '    Copyright 2018 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/external/0x/v2/libs/LibOrder.sol\n', '\n', 'contract LibOrder\n', '{\n', '    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n', '    // An order&#39;s state is unaffected by external factors, like account balances.\n', '    enum OrderStatus {\n', '        INVALID,                     // Default value\n', '        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n', '        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n', '        FILLABLE,                    // Order is fillable\n', '        EXPIRED,                     // Order has already expired\n', '        FULLY_FILLED,                // Order is fully filled\n', '        CANCELLED                    // Order has been cancelled\n', '    }\n', '\n', '    struct Order {\n', '        address makerAddress;           // Address that created the order.\n', '        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n', '        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n', '        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n', '        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n', '        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n', '        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n', '        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n', '        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n', '        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order&#39;s hash.\n', '        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n', '        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n', '    }\n', '\n', '    struct OrderInfo {\n', '        uint8 orderStatus;                    // Status that describes order&#39;s validity and fillability.\n', '        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n', '        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n', '    }\n', '}\n', '\n', '// File: contracts/external/0x/v2/libs/LibFillResults.sol\n', '\n', 'contract LibFillResults\n', '{\n', '    struct FillResults {\n', '        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n', '        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n', '        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n', '        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n', '    }\n', '\n', '    struct MatchedFillResults {\n', '        FillResults left;                    // Amounts filled and fees paid of left order.\n', '        FillResults right;                   // Amounts filled and fees paid of right order.\n', '        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order&#39;s makerAsset, paid to taker.\n', '    }\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/IExchangeCore.sol\n', '\n', 'contract IExchangeCore {\n', '\n', '    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n', '    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n', '    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n', '    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n', '        external;\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param order Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrder(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev After calling, the order can not be filled anymore.\n', '    /// @param order Order struct containing order specifications.\n', '    function cancelOrder(LibOrder.Order memory order)\n', '        public;\n', '\n', '    /// @dev Gets information about an order: status, hash, and amount filled.\n', '    /// @param order Order to gather information on.\n', '    /// @return OrderInfo Information about the order and its state.\n', '    ///                   See LibOrder.OrderInfo for a complete description.\n', '    function getOrderInfo(LibOrder.Order memory order)\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo memory orderInfo);\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/IMatchOrders.sol\n', '\n', 'contract IMatchOrders {\n', '\n', '    /// @dev Match two complementary orders that have a profitable spread.\n', '    ///      Each order is filled at their respective price point. However, the calculations are\n', '    ///      carried out as though the orders are both being filled at the right order&#39;s price point.\n', '    ///      The profit made by the left order goes to the taker (who matched the two orders).\n', '    /// @param leftOrder First order to match.\n', '    /// @param rightOrder Second order to match.\n', '    /// @param leftSignature Proof that order was created by the left maker.\n', '    /// @param rightSignature Proof that order was created by the right maker.\n', '    /// @return matchedFillResults Amounts filled and fees paid by maker and taker of matched orders.\n', '    function matchOrders(\n', '        LibOrder.Order memory leftOrder,\n', '        LibOrder.Order memory rightOrder,\n', '        bytes memory leftSignature,\n', '        bytes memory rightSignature\n', '    )\n', '        public\n', '        returns (LibFillResults.MatchedFillResults memory matchedFillResults);\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/ISignatureValidator.sol\n', '\n', 'contract ISignatureValidator {\n', '\n', '    /// @dev Approves a hash on-chain using any valid signature type.\n', '    ///      After presigning a hash, the preSign signature type will become valid for that hash and signer.\n', '    /// @param signerAddress Address that should have signed the given hash.\n', '    /// @param signature Proof that the hash has been signed by signer.\n', '    function preSign(\n', '        bytes32 hash,\n', '        address signerAddress,\n', '        bytes signature\n', '    )\n', '        external;\n', '\n', '    /// @dev Approves/unnapproves a Validator contract to verify signatures on signer&#39;s behalf.\n', '    /// @param validatorAddress Address of Validator contract.\n', '    /// @param approval Approval or disapproval of  Validator contract.\n', '    function setSignatureValidatorApproval(\n', '        address validatorAddress,\n', '        bool approval\n', '    )\n', '        external;\n', '\n', '    /// @dev Verifies that a signature is valid.\n', '    /// @param hash Message hash that is signed.\n', '    /// @param signerAddress Address of signer.\n', '    /// @param signature Proof of signing.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        bytes32 hash,\n', '        address signerAddress,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        view\n', '        returns (bool isValid);\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/ITransactions.sol\n', '\n', 'contract ITransactions {\n', '\n', '    /// @dev Executes an exchange method call in the context of signer.\n', '    /// @param salt Arbitrary number to ensure uniqueness of transaction hash.\n', '    /// @param signerAddress Address of transaction signer.\n', '    /// @param data AbiV2 encoded calldata.\n', '    /// @param signature Proof of signer transaction by signer.\n', '    function executeTransaction(\n', '        uint256 salt,\n', '        address signerAddress,\n', '        bytes data,\n', '        bytes signature\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/IAssetProxyDispatcher.sol\n', '\n', 'contract IAssetProxyDispatcher {\n', '\n', '    /// @dev Registers an asset proxy to its asset proxy id.\n', '    ///      Once an asset proxy is registered, it cannot be unregistered.\n', '    /// @param assetProxy Address of new asset proxy to register.\n', '    function registerAssetProxy(address assetProxy)\n', '        external;\n', '\n', '    /// @dev Gets an asset proxy.\n', '    /// @param assetProxyId Id of the asset proxy.\n', '    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\n', '    function getAssetProxy(bytes4 assetProxyId)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/IWrapperFunctions.sol\n', '\n', 'contract IWrapperFunctions {\n', '\n', '    /// @dev Fills the input order. Reverts if exact takerAssetFillAmount not filled.\n', '    /// @param order LibOrder.Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    function fillOrKillOrder(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param order LibOrder.Order struct containing order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signature Proof that order has been created by maker.\n', '    /// @return Amounts filled and fees paid by maker and taker.\n', '    function fillOrderNoThrow(\n', '        LibOrder.Order memory order,\n', '        uint256 takerAssetFillAmount,\n', '        bytes memory signature\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory fillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrKill.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrKillOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function batchFillOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256[] memory takerAssetFillAmounts,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signatures Proofs that orders have been created by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketSellOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 takerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketSellOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 takerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple calls of fillOrder until total amount of makerAsset is bought by taker.\n', '    /// @param orders Array of order specifications.\n', '    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketBuyOrders(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 makerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total amount is bought by taker.\n', '    ///      Returns false if the transaction would otherwise revert.\n', '    /// @param orders Array of order specifications.\n', '    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\n', '    /// @param signatures Proofs that orders have been signed by makers.\n', '    /// @return Amounts filled and fees paid by makers and taker.\n', '    function marketBuyOrdersNoThrow(\n', '        LibOrder.Order[] memory orders,\n', '        uint256 makerAssetFillAmount,\n', '        bytes[] memory signatures\n', '    )\n', '        public\n', '        returns (LibFillResults.FillResults memory totalFillResults);\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orders Array of order specifications.\n', '    function batchCancelOrders(LibOrder.Order[] memory orders)\n', '        public;\n', '\n', '    /// @dev Fetches information for all passed in orders\n', '    /// @param orders Array of order specifications.\n', '    /// @return Array of OrderInfo instances that correspond to each order.\n', '    function getOrdersInfo(LibOrder.Order[] memory orders)\n', '        public\n', '        view\n', '        returns (LibOrder.OrderInfo[] memory);\n', '}\n', '\n', '// File: contracts/external/0x/v2/interfaces/IExchange.sol\n', '\n', 'contract IExchange is\n', '    IExchangeCore,\n', '    IMatchOrders,\n', '    ISignatureValidator,\n', '    ITransactions,\n', '    IAssetProxyDispatcher,\n', '    IWrapperFunctions\n', '{}\n', '\n', '// File: contracts/lib/MathHelpers.sol\n', '\n', '/**\n', ' * @title MathHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with common math functions in Solidity\n', ' */\n', 'library MathHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              target * numerator / denominator\n', '     */\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              Rounded-up result of target * numerator / denominator\n', '     */\n', '    function getPartialAmountRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return divisionRoundedUp(numerator.mul(target), denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates division given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator.\n', '     * @param  denominator  Denominator.\n', '     * @return              Rounded-up result of numerator / denominator\n', '     */\n', '    function divisionRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(denominator != 0); // coverage-enable-line\n', '        if (numerator == 0) {\n', '            return 0;\n', '        }\n', '        return numerator.sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint256(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint32(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        return 2 ** 32 - 1;\n', '    }\n', '\n', '    /**\n', '     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n', '     *\n', '     * @param  n  The uint256 to get the number of bits in\n', '     * @return    The number of bits in n\n', '     */\n', '    function getNumBits(\n', '        uint256 n\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 first = 0;\n', '        uint256 last = 256;\n', '        while (first < last) {\n', '            uint256 check = (first + last) / 2;\n', '            if ((n >> check) == 0) {\n', '                last = check;\n', '            } else {\n', '                first = check + 1;\n', '            }\n', '        }\n', '        assert(first <= 256);\n', '        return first;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/GeneralERC20.sol\n', '\n', '/**\n', ' * @title GeneralERC20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', ' * that we dont automatically revert when calling non-compliant tokens that have no return value for\n', ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface GeneralERC20 {\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/TokenInteract.sol\n', '\n', '/**\n', ' * @title TokenInteract\n', ' * @author dYdX\n', ' *\n', ' * This library contains functions for interacting with ERC20 tokens\n', ' */\n', 'library TokenInteract {\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        GeneralERC20(token).approve(spender, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#approve: Approval failed"\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        address from = address(this);\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transfer(to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transfer: Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transferFrom(from, to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transferFrom: TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeReader.sol\n', '\n', '/**\n', ' * @title ExchangeReader\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that wraps an exchange and provides information about the current state of the\n', ' * exchange or particular orders\n', ' */\n', 'interface ExchangeReader {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Get the maxmimum amount of makerToken for some order\n', '     *\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      Maximum amount of makerToken\n', '     */\n', '    function getMaxMakerAmount(\n', '        address makerToken,\n', '        address takerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n', ' * with other smart contracts through a common interface.\n', ' */\n', 'interface ExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the transaction\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/external/exchangewrappers/ZeroExV2ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ZeroExV2ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * dYdX ExchangeWrapper to interface with 0x Version 2\n', ' */\n', 'contract ZeroExV2ExchangeWrapper is\n', '    LibFillResults,\n', '    LibOrder,\n', '    ExchangeWrapper,\n', '    ExchangeReader\n', '{\n', '    using SafeMath for uint256;\n', '    using TokenInteract for address;\n', '\n', '    // ============ State Variables ============\n', '\n', '    // msg.senders that will put the correct tradeOriginator in callerData when doing an exchange\n', '    mapping (address => bool) public TRUSTED_MSG_SENDER;\n', '\n', '    // address of the ZeroEx V2 Exchange\n', '    address public ZERO_EX_EXCHANGE;\n', '\n', '    // address of the ZeroEx V2 ERC20Proxy\n', '    address public ZERO_EX_TOKEN_PROXY;\n', '\n', '    // address of the ZRX token\n', '    address public ZRX;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address zeroExExchange,\n', '        address zeroExProxy,\n', '        address zrxToken,\n', '        address[] trustedMsgSenders\n', '    )\n', '        public\n', '    {\n', '        ZERO_EX_EXCHANGE = zeroExExchange;\n', '        ZERO_EX_TOKEN_PROXY = zeroExProxy;\n', '        ZRX = zrxToken;\n', '\n', '        for (uint256 i = 0; i < trustedMsgSenders.length; i++) {\n', '            TRUSTED_MSG_SENDER[trustedMsgSenders[i]] = true;\n', '        }\n', '\n', '        // The ZRX token does not decrement allowance if set to MAX_UINT\n', '        // therefore setting it once to the maximum amount is sufficient\n', '        // NOTE: this is *not* standard behavior for an ERC20, so do not rely on it for other tokens\n', '        ZRX.approve(ZERO_EX_TOKEN_PROXY, MathHelpers.maxUint256());\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256)\n', '    {\n', '        // prepare the exchange\n', '        Order memory order = parseOrder(orderData, makerToken, takerToken);\n', '        bytes memory signature = parseSignature(orderData);\n', '\n', '        // transfer ZRX fee from trader if applicable\n', '        transferTakerFee(\n', '            order,\n', '            tradeOriginator,\n', '            requestedFillAmount\n', '        );\n', '\n', '        // make sure that the exchange can take the tokens from this contract\n', '        ensureAllowance(\n', '            takerToken,\n', '            ZERO_EX_TOKEN_PROXY,\n', '            requestedFillAmount\n', '        );\n', '\n', '        // do the exchange\n', '        IExchange v2Exchange = IExchange(ZERO_EX_EXCHANGE);\n', '        FillResults memory fill = v2Exchange.fillOrKillOrder(order, requestedFillAmount, signature);\n', '\n', '        // validate results\n', '        assert(fill.takerAssetFilledAmount == requestedFillAmount);\n', '\n', '        // set allowance\n', '        ensureAllowance(makerToken, receiver, fill.makerAssetFilledAmount);\n', '\n', '        return fill.makerAssetFilledAmount;\n', '    }\n', '\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Order memory order = parseOrder(orderData, makerToken, takerToken);\n', '\n', '        return MathHelpers.getPartialAmountRoundedUp(\n', '            order.takerAssetAmount,\n', '            order.makerAssetAmount,\n', '            desiredMakerToken\n', '        );\n', '    }\n', '\n', '    function getMaxMakerAmount(\n', '        address makerToken,\n', '        address takerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Order memory order = parseOrder(orderData, makerToken, takerToken);\n', '        IExchange v2Exchange = IExchange(ZERO_EX_EXCHANGE);\n', '        OrderInfo memory orderInfo = v2Exchange.getOrderInfo(order);\n', '\n', '        if (orderInfo.orderStatus != uint8(OrderStatus.FILLABLE)) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 remainingTakerAssetAmount =\n', '            order.takerAssetAmount.sub(orderInfo.orderTakerAssetFilledAmount);\n', '\n', '        return MathHelpers.getPartialAmount(\n', '            remainingTakerAssetAmount,\n', '            order.takerAssetAmount,\n', '            order.makerAssetAmount\n', '        );\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function ensureAllowance(\n', '        address token,\n', '        address spender,\n', '        uint256 requiredAmount\n', '    )\n', '        private\n', '    {\n', '        if (token.allowance(address(this), spender) >= requiredAmount) {\n', '            return;\n', '        }\n', '\n', '        token.approve(\n', '            spender,\n', '            MathHelpers.maxUint256()\n', '        );\n', '    }\n', '\n', '    function transferTakerFee(\n', '        Order memory order,\n', '        address tradeOriginator,\n', '        uint256 requestedFillAmount\n', '    )\n', '        private\n', '    {\n', '        uint256 takerFee = MathHelpers.getPartialAmount(\n', '            requestedFillAmount,\n', '            order.takerAssetAmount,\n', '            order.takerFee\n', '        );\n', '\n', '        if (takerFee == 0) {\n', '            return;\n', '        }\n', '\n', '        require(\n', '            TRUSTED_MSG_SENDER[msg.sender],\n', '            "ZeroExV2ExchangeWrapper#transferTakerFee: Only trusted senders can dictate the fee payer"\n', '        );\n', '\n', '        ZRX.transferFrom(\n', '            tradeOriginator,\n', '            address(this),\n', '            takerFee\n', '        );\n', '    }\n', '\n', '    function parseSignature(\n', '        bytes orderData\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory signature = new bytes(66);\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            mstore(add(signature, 32), mload(add(orderData, 352)))  // first 32 bytes\n', '            mstore(add(signature, 64), mload(add(orderData, 384)))  // next 32 bytes\n', '            mstore(add(signature, 66), mload(add(orderData, 386)))  // last 2 bytes\n', '        }\n', '\n', '        return signature;\n', '    }\n', '\n', '    function parseOrder(\n', '        bytes orderData,\n', '        address makerToken,\n', '        address takerToken\n', '    )\n', '        private\n', '        pure\n', '        returns (Order memory)\n', '    {\n', '        Order memory order;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            mstore(order,           mload(add(orderData, 32)))  // makerAddress\n', '            mstore(add(order, 32),  mload(add(orderData, 64)))  // takerAddress\n', '            mstore(add(order, 64),  mload(add(orderData, 96)))  // feeRecipientAddress\n', '            mstore(add(order, 96),  mload(add(orderData, 128))) // senderAddress\n', '            mstore(add(order, 128), mload(add(orderData, 160))) // makerAssetAmount\n', '            mstore(add(order, 160), mload(add(orderData, 192))) // takerAssetAmount\n', '            mstore(add(order, 192), mload(add(orderData, 224))) // makerFee\n', '            mstore(add(order, 224), mload(add(orderData, 256))) // takerFee\n', '            mstore(add(order, 256), mload(add(orderData, 288))) // expirationTimeSeconds\n', '            mstore(add(order, 288), mload(add(orderData, 320))) // salt\n', '        }\n', '\n', '        order.makerAssetData = tokenAddressToAssetData(makerToken);\n', '        order.takerAssetData = tokenAddressToAssetData(takerToken);\n', '\n', '        return order;\n', '    }\n', '\n', '    function tokenAddressToAssetData(\n', '        address tokenAddress\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes)\n', '    {\n', '        bytes memory result = new bytes(36);\n', '\n', '        // padded version of bytes4(keccak256("ERC20Token(address)"));\n', '        bytes32 selector = 0xf47261b000000000000000000000000000000000000000000000000000000000;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // Store the selector and address in the asset data\n', '            // The first 32 bytes of an array are the length (already set above)\n', '            mstore(add(result, 32), selector)\n', '            mstore(add(result, 36), tokenAddress)\n', '        }\n', '\n', '        return result;\n', '    }\n', '}']