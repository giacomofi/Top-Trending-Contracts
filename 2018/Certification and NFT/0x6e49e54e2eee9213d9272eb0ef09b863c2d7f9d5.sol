['pragma solidity ^0.4.18;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title ServiceAllowance.\n', '///\n', '/// Provides a way to delegate operation allowance decision to a service contract\n', 'contract ServiceAllowance {\n', '    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n', '}\n', '\n', 'contract ATxPlatformInterface {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataControllerInterface {\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address - checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isHolderAddress(address _address) public view returns (bool);\n', '\n', '    function allowance(address _user) public view returns (uint);\n', '\n', '    function changeAllowance(address _holder, uint _value) public returns (uint);\n', '}\n', '\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceControllerInterface {\n', '\n', '    /// @notice Check target address is service\n', '    /// @param _address target address\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool);\n', '}\n', '\n', 'contract ATxAssetInterface {\n', '\n', '    DataControllerInterface public dataController;\n', '    ServiceControllerInterface public serviceController;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function __process(bytes /*_data*/, address /*_sender*/) payable public {\n', '        revert();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', 'contract Platform {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', 'contract ATxAssetProxy is ERC20, Object, ServiceAllowance {\n', '\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\n', '     */\n', '    event UpgradeProposal(address newVersion);\n', '\n', '    // Current asset implementation contract address.\n', '    address latestVersion;\n', '\n', '    // Assigned platform, immutable.\n', '    Platform public platform;\n', '\n', '    // Assigned symbol, immutable.\n', '    bytes32 public smbl;\n', '\n', '    // Assigned name, immutable.\n', '    string public name;\n', '\n', '    /**\n', '     * Only platform is allowed to call.\n', '     */\n', '    modifier onlyPlatform() {\n', '        if (msg.sender == address(platform)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only current asset owner is allowed to call.\n', '     */\n', '    modifier onlyAssetOwner() {\n', '        if (platform.isOwner(msg.sender, smbl)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only asset implementation contract assigned to sender is allowed to call.\n', '     */\n', '    modifier onlyAccess(address _sender) {\n', '        if (getLatestVersion() == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there transaction data,\n', '     * along with the value. This allows for proxy interface growth.\n', '     */\n', '    function() public payable {\n', '        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets platform address, assigns symbol and name.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _platform platform contract address.\n', '     * @param _symbol assigned symbol.\n', '     * @param _name assigned name.\n', '     *\n', '     * @return success.\n', '     */\n', '    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\n', '        if (address(platform) != 0x0) {\n', '            return false;\n', '        }\n', '        platform = _platform;\n', '        symbol = _symbol;\n', '        smbl = stringToBytes32(_symbol);\n', '        name = _name;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset total supply.\n', '     *\n', '     * @return asset total supply.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return platform.totalSupply(smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset balance for a particular holder.\n', '     *\n', '     * @param _owner holder address.\n', '     *\n', '     * @return holder balance.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return platform.balanceOf(_owner, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset allowance from one holder to another.\n', '     *\n', '     * @param _from holder that allowed spending.\n', '     * @param _spender holder that is allowed to spend.\n', '     *\n', '     * @return holder to spender allowance.\n', '     */\n', '    function allowance(address _from, address _spender) public view returns (uint) {\n', '        return platform.allowance(_from, _spender, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset decimals.\n', '     *\n', '     * @return asset decimals.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return platform.baseUnit(smbl);\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, "");\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver adding specified comment.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, _reference);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Prforms allowance transfer of asset balance between holders.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _getAsset().__transferFromWithReference(_from, _to, _value, "", msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     * @param _reference transfer comment to be included in a platform&#39;s Transfer event.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Sets asset spending allowance for a specified spender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     *\n', '     * @return success.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        if (_spender != 0x0) {\n', '            return _getAsset().__approve(_spender, _value, msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance setting call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Transfer event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset transfer happens.\n', '     */\n', '    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Approval event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset allowance set happens.\n', '     */\n', '    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\n', '        Approval(_from, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * Returns current asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getLatestVersion() public view returns (address) {\n', '        return latestVersion;\n', '    }\n', '\n', '    /**\n', '     * Propose next asset implementation contract address.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * Note: freeze-time should not be applied for the initial setup.\n', '     *\n', '     * @param _newVersion asset implementation contract address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\n', '        // New version address should be other than 0x0.\n', '        if (_newVersion == 0x0) {\n', '            return false;\n', '        }\n', '        \n', '        latestVersion = _newVersion;\n', '\n', '        UpgradeProposal(_newVersion); \n', '        return true;\n', '    }\n', '\n', '    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset implementation contract for current caller.\n', '     *\n', '     * @return asset implementation contract.\n', '     */\n', '    function _getAsset() internal view returns (ATxAssetInterface) {\n', '        return ATxAssetInterface(getLatestVersion());\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there arguments along with\n', '     * the caller address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\n', '        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\n', '    }\n', '\n', '    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}\n', '\n', 'contract ATxBuybackInterface {\n', '\n', '\tevent EtherReceived(uint amount);\n', '\tevent TokenExchanged(\n', '\t\taddress recepient, \n', '\t\taddress token, \n', '\t\tuint tokenAmount, \n', '\t\tuint etherAmount, \n', '\t\tuint feeAmount, \n', '\t\taddress feeReceiver, \n', '\t\tuint price\n', '\t);\n', '}\n', '\n', '/// @title Token Buyback contract.\n', '/// @notice Plays role of token exchange to Ether.\n', '/// Has only one token at a contract. To support other tokens\n', '/// there should be created other ATxBuyback contracts.\n', 'contract ATxBuyback is Object, ATxBuybackInterface, ServiceAllowance {\n', '\n', '\tusing SafeMath for uint;\n', '\n', '    struct FeeData {\n', '        uint feeValue;\n', '        uint feeDecimals;\n', '    }\n', '\n', '\t/// @dev Redemption fee collector address\n', '\taddress public rdCollectorAddress;\n', '\t/// @dev Fee value\n', '\tFeeData rdFee;\n', '\n', '\t/// @dev Token to exchange.\n', '\tATxAssetProxy public token;\n', '\t/// @dev Price for 1 token\n', '\tuint public price;\n', '\t/// @dev Active flag\n', '\tbool public active;\n', '\n', '\t/// @dev Guards from invocation only when state is active\n', '\tmodifier onlyActive {\n', '\t\tif (active) {\n', '\t\t\t_;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction ATxBuyback(ATxAssetProxy _token) public {\n', '\t\trequire(address(_token) != 0x0);\n', '\t\ttoken = _token;\n', '\t}\n', '\n', '\t/// @notice Sets a price (in wei) for selling one token\n', '\t/// @param _price "in wei" = 1 ATx\n', '\tfunction setPrice(uint _price) onlyContractOwner external returns (uint) {\n', '\t\tprice = _price;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Sets contract to active/non active state.\n', '\t/// Should be performed only by contract owner.\n', '\t/// @param _active next state of contract. True to activate a contract\n', '\t/// @return result code of an operation\n', '\tfunction setActive(bool _active) onlyContractOwner external returns (uint) {\n', '\t\tif (active == _active) {\n', '\t\t\treturn;\n', '\t\t}\n', '\n', '        active = _active;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Setup redemption destination address\n', '\t/// @param _collectorAddress address where all redemptiom fee will be directed\n', '\t/// @return result code of an operation\n', '\tfunction setRdCollectorAddress(address _collectorAddress) onlyContractOwner external returns (uint) {\n', '\t\trequire(_collectorAddress != 0x0);\n', '\t\t\n', '\t\trdCollectorAddress = _collectorAddress;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Setup redemption fee value\n', '\t/// @param _feeValue fee amount; the minimal value is 1\n', '\t/// @param _feeDecimals fee decimals, sets a precision for fee value\n', '\t/// @return result code of an operation\n', '\tfunction setRdFee(uint _feeValue, uint _feeDecimals) onlyContractOwner external returns (uint) {\n', '\t\trequire(_validFee(_feeValue, _feeDecimals));\n', '\n', '\t\trdFee = FeeData(_feeValue, _feeDecimals);\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Gets redemption fee value\n', '\t/// @return {\n', '\t/// \t"_value": "amount of percents",\n', '\t///\t\t"_decimals": "percent&#39;s precision"\n', '\t/// }\n', '\tfunction getRdFee() public view returns (uint _value, uint _decimals) {\n', '\t\tFeeData memory _fee = rdFee;\n', '\t\treturn (_fee.feeValue, _fee.feeDecimals);\n', '\t}\n', '\n', '\t/// @notice Withdraws all Ether from buyback contract to specified address.\n', '\t/// Allowed only for contract owner.\n', '\t/// @param _to destination address to send Ether\n', '\t/// @return result code of an operation\n', '\tfunction withdrawAllEth(address _to) onlyContractOwner external returns (uint) {\n', '\t\tuint _balance = address(this).balance;\n', '\t\tif (_balance == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\t_to.transfer(_balance);\n', '\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// ServiceAllowance\n', '    ///\n', '    /// @notice ServiceAllowance interface implementation\n', '    /// @dev Should cover conditions for allowance of transfers\n', '    function isTransferAllowed(address, address _to, address, address _token, uint) onlyActive public view returns (bool) {\n', '        if (_token == address(token) && _to == address(this)) {\n', '            return true;\n', '        }\n', '    }\n', '\n', '\t/// @notice Fallback function for ERC223 standard.\n', '\t/// Allowed to work only in active state.\n', '\t/// @param _sender original sender of token transfer\n', '\t/// @param _value amount of tokens that has been sent\n', '\tfunction tokenFallback(address _sender, uint _value, bytes) external {\n', '\t\t/// Don&#39;t allow to transfer and exchange tokens when Buyback contract\n', '\t\t/// is not in &#39;active&#39; state\n', '\t\tif (!active) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\t\n', '\t\t/// This call should be produced by AssetProxy&#39;s backend - an Asset contract.\n', '\t\t/// Any other call will be followed by revert()\n', '\t\tATxAssetProxy _token = token;\n', '\t\tif (msg.sender != _token.getLatestVersion()) {\n', '\t\t\trevert();\n', '\t\t}\n', '\n', '\t\t/// Need to check available ETH balance in order to fulfill holder&#39;s request\n', '\t\t/// about exchanging ATx Token to ETH equivalent\n', '\t\tuint _etherToExchange = _value.mul(price) / (10 ** uint(_token.decimals()));\n', '\t\tif (this.balance < _etherToExchange) {\n', '\t\t\trevert();\n', '\t\t}\n', '\n', '\t\t/// To prevent double spending we revoke transferred assets from foundation platform,\n', '\t\tATxPlatformInterface _platform = ATxPlatformInterface(address(_token.platform()));\n', '\t\trequire(OK == _platform.revokeAsset(_token.smbl(), _value));\n', '\n', '\t\t/// Take redemption fee and return left amount of Ether to transfer it to a holder\n', '\t\tuint _restEther = _takeRdFee(_etherToExchange);\n', '\t\t/// Transfer the rest to holder&#39;s account\n', '\t\t_sender.transfer(_restEther);\n', '\n', '\t\t/// Voila! Just emit the event to say to the world that one more exchange action was finished\n', '\t\tTokenExchanged(_sender, _token, _value, _restEther, _etherToExchange.sub(_restEther), rdCollectorAddress, price);\n', '\t}\n', '\n', '\t/// @notice Accepts Ether and emits EtherReceived event\n', '\tfunction() payable external {\n', '\t\tif (msg.value > 0) {\n', '\t\t\tEtherReceived(msg.value);\n', '\t\t}\n', '\t}\n', '\n', '\t/* Internal */\n', '\n', '\tfunction _takeRdFee(uint _fromValue) private returns (uint _restValue) {\n', '\t\t/// Here we check if redemption fee was setup after the contract initialization\n', '\t\tFeeData memory _fee = rdFee;\n', '\t\trequire(_validFee(_fee.feeValue, _fee.feeDecimals));\n', '\n', '\t\t/// Calculate amount of redemption fee that we have to take from the whole sum\n', '\t\tuint _rdFeeEther;\n', '\t\t_rdFeeEther = _fromValue.mul(_fee.feeValue).div(10 ** _fee.feeDecimals);\n', '\t\t_restValue = _fromValue.sub(_rdFeeEther);\n', '\n', '\t\t/// At first use method collector.transfer() to ensure that if this move is not possible\n', '\t\t/// then revert all changes\n', '\t\taddress _rdCollectorAddress = rdCollectorAddress;\n', '\t\trequire(_rdCollectorAddress != 0x0);\n', '\t\t_rdCollectorAddress.transfer(_rdFeeEther);\n', '\t}\n', '\n', '\tfunction _validFee(uint _value, uint _decimals) private pure returns (bool) {\n', '        return _value != 0 && _value / 10 ** _decimals.sub(1) >= 0 && _value / 10 ** _decimals.sub(1) < 10;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title ServiceAllowance.\n', '///\n', '/// Provides a way to delegate operation allowance decision to a service contract\n', 'contract ServiceAllowance {\n', '    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\n', '}\n', '\n', 'contract ATxPlatformInterface {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '/// @title Provides possibility manage holders? country limits and limits for holders.\n', 'contract DataControllerInterface {\n', '\n', '    /// @notice Checks user is holder.\n', '    /// @param _address - checking address.\n', '    /// @return `true` if _address is registered holder, `false` otherwise.\n', '    function isHolderAddress(address _address) public view returns (bool);\n', '\n', '    function allowance(address _user) public view returns (uint);\n', '\n', '    function changeAllowance(address _holder, uint _value) public returns (uint);\n', '}\n', '\n', '/// @title ServiceController\n', '///\n', '/// Base implementation\n', '/// Serves for managing service instances\n', 'contract ServiceControllerInterface {\n', '\n', '    /// @notice Check target address is service\n', '    /// @param _address target address\n', '    /// @return `true` when an address is a service, `false` otherwise\n', '    function isService(address _address) public view returns (bool);\n', '}\n', '\n', 'contract ATxAssetInterface {\n', '\n', '    DataControllerInterface public dataController;\n', '    ServiceControllerInterface public serviceController;\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\n', '    function __approve(address _spender, uint _value, address _sender) public returns (bool);\n', '    function __process(bytes /*_data*/, address /*_sender*/) payable public {\n', '        revert();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', 'contract Platform {\n', '    mapping(bytes32 => address) public proxies;\n', '    function name(bytes32 _symbol) public view returns (string);\n', '    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\n', '    function totalSupply(bytes32 _symbol) public view returns (uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\n', '    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\n', '    function isReissuable(bytes32 _symbol) public view returns (bool);\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\n', '}\n', '\n', 'contract ATxAssetProxy is ERC20, Object, ServiceAllowance {\n', '\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\n', '     */\n', '    event UpgradeProposal(address newVersion);\n', '\n', '    // Current asset implementation contract address.\n', '    address latestVersion;\n', '\n', '    // Assigned platform, immutable.\n', '    Platform public platform;\n', '\n', '    // Assigned symbol, immutable.\n', '    bytes32 public smbl;\n', '\n', '    // Assigned name, immutable.\n', '    string public name;\n', '\n', '    /**\n', '     * Only platform is allowed to call.\n', '     */\n', '    modifier onlyPlatform() {\n', '        if (msg.sender == address(platform)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only current asset owner is allowed to call.\n', '     */\n', '    modifier onlyAssetOwner() {\n', '        if (platform.isOwner(msg.sender, smbl)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Only asset implementation contract assigned to sender is allowed to call.\n', '     */\n', '    modifier onlyAccess(address _sender) {\n', '        if (getLatestVersion() == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there transaction data,\n', '     * along with the value. This allows for proxy interface growth.\n', '     */\n', '    function() public payable {\n', '        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets platform address, assigns symbol and name.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _platform platform contract address.\n', '     * @param _symbol assigned symbol.\n', '     * @param _name assigned name.\n', '     *\n', '     * @return success.\n', '     */\n', '    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\n', '        if (address(platform) != 0x0) {\n', '            return false;\n', '        }\n', '        platform = _platform;\n', '        symbol = _symbol;\n', '        smbl = stringToBytes32(_symbol);\n', '        name = _name;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset total supply.\n', '     *\n', '     * @return asset total supply.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return platform.totalSupply(smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset balance for a particular holder.\n', '     *\n', '     * @param _owner holder address.\n', '     *\n', '     * @return holder balance.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return platform.balanceOf(_owner, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset allowance from one holder to another.\n', '     *\n', '     * @param _from holder that allowed spending.\n', '     * @param _spender holder that is allowed to spend.\n', '     *\n', '     * @return holder to spender allowance.\n', '     */\n', '    function allowance(address _from, address _spender) public view returns (uint) {\n', '        return platform.allowance(_from, _spender, smbl);\n', '    }\n', '\n', '    /**\n', '     * Returns asset decimals.\n', '     *\n', '     * @return asset decimals.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return platform.baseUnit(smbl);\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, "");\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfers asset balance from the caller to specified receiver adding specified comment.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     *\n', '     * @return success.\n', '     */\n', '    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _transferWithReference(_to, _value, _reference);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Prforms allowance transfer of asset balance between holders.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', '     *\n', '     * @return success.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_to != 0x0) {\n', '            return _getAsset().__transferFromWithReference(_from, _to, _value, "", msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance transfer call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _from holder address to take from.\n', '     * @param _to holder address to give to.\n', '     * @param _value amount to transfer.\n', "     * @param _reference transfer comment to be included in a platform's Transfer event.\n", '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Sets asset spending allowance for a specified spender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     *\n', '     * @return success.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        if (_spender != 0x0) {\n', '            return _getAsset().__approve(_spender, _value, msg.sender);\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Performs allowance setting call on the platform by the name of specified sender.\n', '     *\n', '     * Can only be called by asset implementation contract assigned to sender.\n', '     *\n', '     * @param _spender holder address to set allowance to.\n', '     * @param _value amount to allow.\n', '     * @param _sender initial caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\n', '        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Transfer event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset transfer happens.\n', '     */\n', '    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Emits ERC20 Approval event on this contract.\n', '     *\n', '     * Can only be, and, called by assigned platform when asset allowance set happens.\n', '     */\n', '    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\n', '        Approval(_from, _spender, _value);\n', '    }\n', '\n', '    /**\n', '     * Returns current asset implementation contract address.\n', '     *\n', '     * @return asset implementation contract address.\n', '     */\n', '    function getLatestVersion() public view returns (address) {\n', '        return latestVersion;\n', '    }\n', '\n', '    /**\n', '     * Propose next asset implementation contract address.\n', '     *\n', '     * Can only be called by current asset owner.\n', '     *\n', '     * Note: freeze-time should not be applied for the initial setup.\n', '     *\n', '     * @param _newVersion asset implementation contract address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\n', '        // New version address should be other than 0x0.\n', '        if (_newVersion == 0x0) {\n', '            return false;\n', '        }\n', '        \n', '        latestVersion = _newVersion;\n', '\n', '        UpgradeProposal(_newVersion); \n', '        return true;\n', '    }\n', '\n', '    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns asset implementation contract for current caller.\n', '     *\n', '     * @return asset implementation contract.\n', '     */\n', '    function _getAsset() internal view returns (ATxAssetInterface) {\n', '        return ATxAssetInterface(getLatestVersion());\n', '    }\n', '\n', '    /**\n', '     * Resolves asset implementation contract for the caller and forwards there arguments along with\n', '     * the caller address.\n', '     *\n', '     * @return success.\n', '     */\n', '    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\n', '        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\n', '    }\n', '\n', '    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}\n', '\n', 'contract ATxBuybackInterface {\n', '\n', '\tevent EtherReceived(uint amount);\n', '\tevent TokenExchanged(\n', '\t\taddress recepient, \n', '\t\taddress token, \n', '\t\tuint tokenAmount, \n', '\t\tuint etherAmount, \n', '\t\tuint feeAmount, \n', '\t\taddress feeReceiver, \n', '\t\tuint price\n', '\t);\n', '}\n', '\n', '/// @title Token Buyback contract.\n', '/// @notice Plays role of token exchange to Ether.\n', '/// Has only one token at a contract. To support other tokens\n', '/// there should be created other ATxBuyback contracts.\n', 'contract ATxBuyback is Object, ATxBuybackInterface, ServiceAllowance {\n', '\n', '\tusing SafeMath for uint;\n', '\n', '    struct FeeData {\n', '        uint feeValue;\n', '        uint feeDecimals;\n', '    }\n', '\n', '\t/// @dev Redemption fee collector address\n', '\taddress public rdCollectorAddress;\n', '\t/// @dev Fee value\n', '\tFeeData rdFee;\n', '\n', '\t/// @dev Token to exchange.\n', '\tATxAssetProxy public token;\n', '\t/// @dev Price for 1 token\n', '\tuint public price;\n', '\t/// @dev Active flag\n', '\tbool public active;\n', '\n', '\t/// @dev Guards from invocation only when state is active\n', '\tmodifier onlyActive {\n', '\t\tif (active) {\n', '\t\t\t_;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction ATxBuyback(ATxAssetProxy _token) public {\n', '\t\trequire(address(_token) != 0x0);\n', '\t\ttoken = _token;\n', '\t}\n', '\n', '\t/// @notice Sets a price (in wei) for selling one token\n', '\t/// @param _price "in wei" = 1 ATx\n', '\tfunction setPrice(uint _price) onlyContractOwner external returns (uint) {\n', '\t\tprice = _price;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Sets contract to active/non active state.\n', '\t/// Should be performed only by contract owner.\n', '\t/// @param _active next state of contract. True to activate a contract\n', '\t/// @return result code of an operation\n', '\tfunction setActive(bool _active) onlyContractOwner external returns (uint) {\n', '\t\tif (active == _active) {\n', '\t\t\treturn;\n', '\t\t}\n', '\n', '        active = _active;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Setup redemption destination address\n', '\t/// @param _collectorAddress address where all redemptiom fee will be directed\n', '\t/// @return result code of an operation\n', '\tfunction setRdCollectorAddress(address _collectorAddress) onlyContractOwner external returns (uint) {\n', '\t\trequire(_collectorAddress != 0x0);\n', '\t\t\n', '\t\trdCollectorAddress = _collectorAddress;\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Setup redemption fee value\n', '\t/// @param _feeValue fee amount; the minimal value is 1\n', '\t/// @param _feeDecimals fee decimals, sets a precision for fee value\n', '\t/// @return result code of an operation\n', '\tfunction setRdFee(uint _feeValue, uint _feeDecimals) onlyContractOwner external returns (uint) {\n', '\t\trequire(_validFee(_feeValue, _feeDecimals));\n', '\n', '\t\trdFee = FeeData(_feeValue, _feeDecimals);\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// @notice Gets redemption fee value\n', '\t/// @return {\n', '\t/// \t"_value": "amount of percents",\n', '\t///\t\t"_decimals": "percent\'s precision"\n', '\t/// }\n', '\tfunction getRdFee() public view returns (uint _value, uint _decimals) {\n', '\t\tFeeData memory _fee = rdFee;\n', '\t\treturn (_fee.feeValue, _fee.feeDecimals);\n', '\t}\n', '\n', '\t/// @notice Withdraws all Ether from buyback contract to specified address.\n', '\t/// Allowed only for contract owner.\n', '\t/// @param _to destination address to send Ether\n', '\t/// @return result code of an operation\n', '\tfunction withdrawAllEth(address _to) onlyContractOwner external returns (uint) {\n', '\t\tuint _balance = address(this).balance;\n', '\t\tif (_balance == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\t_to.transfer(_balance);\n', '\n', '\t\treturn OK;\n', '\t}\n', '\n', '\t/// ServiceAllowance\n', '    ///\n', '    /// @notice ServiceAllowance interface implementation\n', '    /// @dev Should cover conditions for allowance of transfers\n', '    function isTransferAllowed(address, address _to, address, address _token, uint) onlyActive public view returns (bool) {\n', '        if (_token == address(token) && _to == address(this)) {\n', '            return true;\n', '        }\n', '    }\n', '\n', '\t/// @notice Fallback function for ERC223 standard.\n', '\t/// Allowed to work only in active state.\n', '\t/// @param _sender original sender of token transfer\n', '\t/// @param _value amount of tokens that has been sent\n', '\tfunction tokenFallback(address _sender, uint _value, bytes) external {\n', "\t\t/// Don't allow to transfer and exchange tokens when Buyback contract\n", "\t\t/// is not in 'active' state\n", '\t\tif (!active) {\n', '\t\t\trevert();\n', '\t\t}\n', '\t\t\n', "\t\t/// This call should be produced by AssetProxy's backend - an Asset contract.\n", '\t\t/// Any other call will be followed by revert()\n', '\t\tATxAssetProxy _token = token;\n', '\t\tif (msg.sender != _token.getLatestVersion()) {\n', '\t\t\trevert();\n', '\t\t}\n', '\n', "\t\t/// Need to check available ETH balance in order to fulfill holder's request\n", '\t\t/// about exchanging ATx Token to ETH equivalent\n', '\t\tuint _etherToExchange = _value.mul(price) / (10 ** uint(_token.decimals()));\n', '\t\tif (this.balance < _etherToExchange) {\n', '\t\t\trevert();\n', '\t\t}\n', '\n', '\t\t/// To prevent double spending we revoke transferred assets from foundation platform,\n', '\t\tATxPlatformInterface _platform = ATxPlatformInterface(address(_token.platform()));\n', '\t\trequire(OK == _platform.revokeAsset(_token.smbl(), _value));\n', '\n', '\t\t/// Take redemption fee and return left amount of Ether to transfer it to a holder\n', '\t\tuint _restEther = _takeRdFee(_etherToExchange);\n', "\t\t/// Transfer the rest to holder's account\n", '\t\t_sender.transfer(_restEther);\n', '\n', '\t\t/// Voila! Just emit the event to say to the world that one more exchange action was finished\n', '\t\tTokenExchanged(_sender, _token, _value, _restEther, _etherToExchange.sub(_restEther), rdCollectorAddress, price);\n', '\t}\n', '\n', '\t/// @notice Accepts Ether and emits EtherReceived event\n', '\tfunction() payable external {\n', '\t\tif (msg.value > 0) {\n', '\t\t\tEtherReceived(msg.value);\n', '\t\t}\n', '\t}\n', '\n', '\t/* Internal */\n', '\n', '\tfunction _takeRdFee(uint _fromValue) private returns (uint _restValue) {\n', '\t\t/// Here we check if redemption fee was setup after the contract initialization\n', '\t\tFeeData memory _fee = rdFee;\n', '\t\trequire(_validFee(_fee.feeValue, _fee.feeDecimals));\n', '\n', '\t\t/// Calculate amount of redemption fee that we have to take from the whole sum\n', '\t\tuint _rdFeeEther;\n', '\t\t_rdFeeEther = _fromValue.mul(_fee.feeValue).div(10 ** _fee.feeDecimals);\n', '\t\t_restValue = _fromValue.sub(_rdFeeEther);\n', '\n', '\t\t/// At first use method collector.transfer() to ensure that if this move is not possible\n', '\t\t/// then revert all changes\n', '\t\taddress _rdCollectorAddress = rdCollectorAddress;\n', '\t\trequire(_rdCollectorAddress != 0x0);\n', '\t\t_rdCollectorAddress.transfer(_rdFeeEther);\n', '\t}\n', '\n', '\tfunction _validFee(uint _value, uint _decimals) private pure returns (bool) {\n', '        return _value != 0 && _value / 10 ** _decimals.sub(1) >= 0 && _value / 10 ** _decimals.sub(1) < 10;\n', '    }\n', '}']
