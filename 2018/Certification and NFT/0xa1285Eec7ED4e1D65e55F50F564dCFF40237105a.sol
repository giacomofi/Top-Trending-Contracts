['pragma solidity ^0.4.13;\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', '    // It&#39;s O(log n), instead of O(n) for naive repeated multiplication.\n', '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract Asset is DSMath, ERC20Interface {\n', '\n', '    // DATA STRUCTURES\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public _totalSupply;\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from `msg.sender`\n', '     * @dev Transfers sender&#39;s tokens to a given address\n', '     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\n', '     * @param _to Address of token receiver\n', '     * @param _value Number of tokens to transfer\n', '     * @return Returns success of function call\n', '     */\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(balances[msg.sender] >= _value); // sanity checks\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] = sub(balances[msg.sender], _value);\n', '        balances[_to] = add(balances[_to], _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\n', '    /// @notice Restriction: An account can only use this function to send to itself\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_from != address(0));\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '        // require(_to == msg.sender); // can only use transferFrom to send to self\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(_spender != address(0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on\n', '    /// behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _spender)\n', '        constant\n', '        public\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by the given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function totalSupply() view public returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '}\n', '\n', 'interface RiskMgmtInterface {\n', '\n', '    // METHODS\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks if the makeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If makeOrder is permitted\n', '    function isMakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '\n', '    /// @notice Checks if the takeOrder price is reasonable and not manipulative\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If takeOrder is permitted\n', '    function isTakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (bool);\n', '}\n', '\n', 'contract RMMakeOrders is DSMath, RiskMgmtInterface {\n', '\n', '    // FIELDS\n', '\n', '    uint public constant RISK_LEVEL = 10 ** uint256(17); // Allows 10 percent deviation from referencePrice; 10 percent is expressed as 0.1 * 10 ** 18\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    /// @notice Checks if the makeOrder price is within maximum allowed deviation from reference price\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If makeOrder is permitted\n', '    function isMakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        view\n', '        returns (bool)\n', '    {\n', '        // Makes sure difference between orderPrice and referencePrice is less than or equal to maximum allowed deviation\n', '        if (orderPrice < sub(referencePrice, wmul(RISK_LEVEL, referencePrice))) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /// @notice Checks if the takeOrder price is within maximum allowed deviation from reference price\n', '    /// @param orderPrice Price of Order\n', '    /// @param referencePrice Reference price obtained through PriceFeed contract\n', '    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\n', '    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\n', '    /// @param sellQuantity Quantity of sellAsset to be sold\n', '    /// @param buyQuantity Quantity of buyAsset to be bought\n', '    /// @return If takeOrder is permitted\n', '    function isTakePermitted(\n', '        uint orderPrice,\n', '        uint referencePrice,\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        view\n', '        returns (bool)\n', '    {\n', '        // Makes sure difference between orderPrice and referencePrice is less than or equal to maximum allowed deviation\n', '        if (orderPrice < sub(referencePrice, wmul(RISK_LEVEL, referencePrice))) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '}']