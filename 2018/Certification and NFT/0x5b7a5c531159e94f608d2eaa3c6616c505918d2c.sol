['pragma solidity ^0.4.19;\n', '\n', 'interface ERC20 {\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'interface ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Distribution {\n', '  using SafeMath for uint256;\n', '\n', '  enum State {\n', '    AwaitingTokens,\n', '    DistributingNormally,\n', '    DistributingProRata,\n', '    Done\n', '  }\n', ' \n', '  address admin;\n', '  ERC20 tokenContract;\n', '  State public state;\n', '  uint256 actualTotalTokens;\n', '  uint256 tokensTransferred;\n', '\n', '  bytes32[] contributionHashes;\n', '  uint256 expectedTotalTokens;\n', '\n', '  function Distribution(address _admin, ERC20 _tokenContract,\n', '                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\n', '    expectedTotalTokens = _expectedTotalTokens;\n', '    contributionHashes = _contributionHashes;\n', '    tokenContract = _tokenContract;\n', '    admin = _admin;\n', '\n', '    state = State.AwaitingTokens;\n', '  }\n', '\n', '  function _handleTokensReceived(uint256 totalTokens) internal {\n', '    require(state == State.AwaitingTokens);\n', '    require(totalTokens > 0);\n', '\n', '    tokensTransferred = 0;\n', '    if (totalTokens == expectedTotalTokens) {\n', '      state = State.DistributingNormally;\n', '    } else {\n', '      actualTotalTokens = totalTokens;\n', '      state = State.DistributingProRata;\n', '    }\n', '  }\n', '\n', '  function handleTokensReceived() public {\n', '    _handleTokensReceived(tokenContract.balanceOf(this));\n', '  }\n', '\n', '  function tokenFallback(address /*_from*/, uint _value, bytes /*_data*/) public {\n', '    require(msg.sender == address(tokenContract));\n', '    _handleTokensReceived(_value);\n', '  }\n', '\n', '  function _numTokensForContributor(uint256 contributorExpectedTokens,\n', '                                    uint256 _tokensTransferred, State _state)\n', '      internal view returns (uint256) {\n', '    if (_state == State.DistributingNormally) {\n', '      return contributorExpectedTokens;\n', '    } else if (_state == State.DistributingProRata) {\n', '      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\n', '\n', '      // Handle roundoff on last contributor.\n', '      uint256 tokensRemaining = actualTotalTokens - _tokensTransferred;\n', '      if (tokens < tokensRemaining) {\n', '        return tokens;\n', '      } else {\n', '        return tokensRemaining;\n', '      }\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function doDistributionRange(uint256 start, address[] contributors,\n', '                               uint256[] contributorExpectedTokens) public {\n', '    require(contributors.length == contributorExpectedTokens.length);\n', '\n', '    uint256 tokensTransferredSoFar = tokensTransferred;\n', '    uint256 end = start + contributors.length;\n', '    State _state = state;\n', '    for (uint256 i = start; i < end; ++i) {\n', '      address contributor = contributors[i];\n', '      uint256 expectedTokens = contributorExpectedTokens[i];\n', '      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\n', '      contributionHashes[i] = 0x00000000000000000000000000000000;\n', '\n', '      uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state);\n', '      tokensTransferredSoFar += numTokens;\n', '      require(tokenContract.transfer(contributor, numTokens));\n', '    }\n', '\n', '    tokensTransferred = tokensTransferredSoFar;\n', '    if (tokensTransferred == actualTotalTokens) {\n', '      state = State.Done;\n', '    }\n', '  }\n', '\n', '  function numTokensForContributor(uint256 contributorExpectedTokens)\n', '      public view returns (uint256) {\n', '    return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state);\n', '  }\n', '\n', '  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n', '    require(msg.sender == admin);\n', '    require(to.call.value(value)(data));\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'interface ERC20 {\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'interface ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Distribution {\n', '  using SafeMath for uint256;\n', '\n', '  enum State {\n', '    AwaitingTokens,\n', '    DistributingNormally,\n', '    DistributingProRata,\n', '    Done\n', '  }\n', ' \n', '  address admin;\n', '  ERC20 tokenContract;\n', '  State public state;\n', '  uint256 actualTotalTokens;\n', '  uint256 tokensTransferred;\n', '\n', '  bytes32[] contributionHashes;\n', '  uint256 expectedTotalTokens;\n', '\n', '  function Distribution(address _admin, ERC20 _tokenContract,\n', '                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\n', '    expectedTotalTokens = _expectedTotalTokens;\n', '    contributionHashes = _contributionHashes;\n', '    tokenContract = _tokenContract;\n', '    admin = _admin;\n', '\n', '    state = State.AwaitingTokens;\n', '  }\n', '\n', '  function _handleTokensReceived(uint256 totalTokens) internal {\n', '    require(state == State.AwaitingTokens);\n', '    require(totalTokens > 0);\n', '\n', '    tokensTransferred = 0;\n', '    if (totalTokens == expectedTotalTokens) {\n', '      state = State.DistributingNormally;\n', '    } else {\n', '      actualTotalTokens = totalTokens;\n', '      state = State.DistributingProRata;\n', '    }\n', '  }\n', '\n', '  function handleTokensReceived() public {\n', '    _handleTokensReceived(tokenContract.balanceOf(this));\n', '  }\n', '\n', '  function tokenFallback(address /*_from*/, uint _value, bytes /*_data*/) public {\n', '    require(msg.sender == address(tokenContract));\n', '    _handleTokensReceived(_value);\n', '  }\n', '\n', '  function _numTokensForContributor(uint256 contributorExpectedTokens,\n', '                                    uint256 _tokensTransferred, State _state)\n', '      internal view returns (uint256) {\n', '    if (_state == State.DistributingNormally) {\n', '      return contributorExpectedTokens;\n', '    } else if (_state == State.DistributingProRata) {\n', '      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\n', '\n', '      // Handle roundoff on last contributor.\n', '      uint256 tokensRemaining = actualTotalTokens - _tokensTransferred;\n', '      if (tokens < tokensRemaining) {\n', '        return tokens;\n', '      } else {\n', '        return tokensRemaining;\n', '      }\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function doDistributionRange(uint256 start, address[] contributors,\n', '                               uint256[] contributorExpectedTokens) public {\n', '    require(contributors.length == contributorExpectedTokens.length);\n', '\n', '    uint256 tokensTransferredSoFar = tokensTransferred;\n', '    uint256 end = start + contributors.length;\n', '    State _state = state;\n', '    for (uint256 i = start; i < end; ++i) {\n', '      address contributor = contributors[i];\n', '      uint256 expectedTokens = contributorExpectedTokens[i];\n', '      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\n', '      contributionHashes[i] = 0x00000000000000000000000000000000;\n', '\n', '      uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state);\n', '      tokensTransferredSoFar += numTokens;\n', '      require(tokenContract.transfer(contributor, numTokens));\n', '    }\n', '\n', '    tokensTransferred = tokensTransferredSoFar;\n', '    if (tokensTransferred == actualTotalTokens) {\n', '      state = State.Done;\n', '    }\n', '  }\n', '\n', '  function numTokensForContributor(uint256 contributorExpectedTokens)\n', '      public view returns (uint256) {\n', '    return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state);\n', '  }\n', '\n', '  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n', '    require(msg.sender == admin);\n', '    require(to.call.value(value)(data));\n', '  }\n', '}']
