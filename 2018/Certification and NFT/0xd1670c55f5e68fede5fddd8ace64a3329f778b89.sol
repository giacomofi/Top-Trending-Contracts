['pragma solidity ^0.4.23;\n', '\n', '/*\n', ' * Contract accepting reservations for ATS tokens.\n', ' * The actual tokens are not yet created and distributed due to non-technical reasons.\n', ' * This contract is used to collect funds for the ATS token sale and to transparently document that on a blockchain.\n', ' * It is tailored to allow a simple user journey while keeping complexity minimal.\n', ' * Once the privileged "state controller" sets the state to "Open", anybody can send Ether to the contract.\n', ' * Only Ether sent from whitelisted addresses is accepted for future ATS token conversion.\n', ' * The whitelisting is done by a dedicated whitelist controller.\n', ' * Whitelisting can take place asynchronously - that is, participants don&#39;t need to wait for the whitelisting to\n', ' * succeed before sending funds. This is a technical detail which allows for a smoother user journey.\n', ' * The state controller can switch to synchronous whitelisting (no Ether accepted from accounts not whitelisted before).\n', ' * Participants can trigger refunding during the Open state by making a transfer of 0 Ether.\n', ' * Funds of those not whitelisted (not accepted) are never locked, they can trigger refund beyond Open state.\n', ' * Only in Over state can whitelisted Ether deposits be fetched from the contract.\n', ' *\n', ' * When setting the state to Open, the state controller specifies a minimal timeframe for this state.\n', ' * Transition to the next state (Locked) is not possible (enforced by the contract).\n', ' * This gives participants the guarantee that they can get their full deposits refunded anytime and independently\n', ' * of the will of anybody else during that timeframe.\n', ' * (Note that this is true only as long as the whole process takes place before the date specified by FALLBACK_FETCH_FUNDS_TS)\n', ' *\n', ' * Ideally, there&#39;s no funds left in the contract once the state is set to Over and the accepted deposits were fetched.\n', ' * Since this can&#39;t really be foreseen, there&#39;s a fallback which allows to fetch all remaining Ether\n', ' * to a pre-specified address after a pre-specified date.\n', ' *\n', ' * Static analysis: block.timestamp is not used in a way which gives miners leeway for taking advantage.\n', ' *\n', ' * see https://code.lab10.io/graz/04-artis/artis/issues/364 for task evolution\n', ' */\n', 'contract ATSTokenReservation {\n', '\n', '    // ################### DATA STRUCTURES ###################\n', '\n', '    enum States {\n', '        Init, // initial state. Contract is deployed, but deposits not yet accepted\n', '        Open, // open for token reservations. Refunds possible for all\n', '        Locked, // open for token reservations. Refunds locked for accepted deposits\n', '        Over // contract has done its duty. Funds payout can be triggered by state controller\n', '    }\n', '\n', '    // ################### CONSTANTS ###################\n', '\n', '    // 1. Oct 2018\n', '    uint32 FALLBACK_PAYOUT_TS = 1538352000;\n', '\n', '    // ################### STATE VARIABLES ###################\n', '\n', '    States public state = States.Init;\n', '\n', '    // privileged account: switch contract state, change config, whitelisting, trigger payout, ...\n', '    address public stateController;\n', '\n', '    // privileged account: whitelisting\n', '    address public whitelistController;\n', '\n', '    // Collected funds can be transferred only to this address. Is set in constructor.\n', '    address public payoutAddress;\n', '\n', '    // accepted deposits (received from whitelisted accounts)\n', '    uint256 public cumAcceptedDeposits = 0;\n', '    // not (yet) accepted deposits (received from non-whitelisted accounts)\n', '    uint256 public cumAlienDeposits = 0;\n', '\n', '    // cap for how much we accept (since the amount of tokens sold is also capped)\n', '    uint256 public maxCumAcceptedDeposits = 1E9 * 1E18; // pre-set to effectively unlimited (> existing ETH)\n', '\n', '    uint256 public minDeposit = 0.1 * 1E18; // lower bound per participant (can be a kind of spam protection)\n', '\n', '    uint256 minLockingTs; // earliest possible start of "locked" phase\n', '\n', '    // whitelisted addresses (those having "accepted" deposits)\n', '    mapping (address => bool) public whitelist;\n', '\n', '    // the state controller can set this in order to disallow deposits from addresses not whitelisted before\n', '    bool public requireWhitelistingBeforeDeposit = false;\n', '\n', '    // tracks accepted deposits (whitelisted accounts)\n', '    mapping (address => uint256) public acceptedDeposits;\n', '\n', '    // tracks alien (not yet accepted) deposits (non-whitelisted accounts)\n', '    mapping (address => uint256) public alienDeposits;\n', '\n', '    // ################### EVENTS ###################\n', '\n', '    // emitted events transparently document the open funding activities.\n', '    // only deposits made by whitelisted accounts (and not followed by a refund) count.\n', '\n', '    event StateTransition(States oldState, States newState);\n', '    event Whitelisted(address addr);\n', '    event Deposit(address addr, uint256 amount);\n', '    event Refund(address addr, uint256 amount);\n', '\n', '    // emitted when the accepted deposits are fetched to an account controlled by the ATS token provider\n', '    event FetchedDeposits(uint256 amount);\n', '\n', '    // ################### MODIFIERS ###################\n', '\n', '    modifier onlyStateControl() { require(msg.sender == stateController, "no permission"); _; }\n', '\n', '    modifier onlyWhitelistControl()\t{\n', '        require(msg.sender == stateController || msg.sender == whitelistController, "no permission");\n', '        _;\n', '    }\n', '\n', '    modifier requireState(States _requiredState) { require(state == _requiredState, "wrong state"); _; }\n', '\n', '    // ################### CONSTRUCTOR ###################\n', '\n', '    // the contract creator is set as stateController\n', '    constructor(address _whitelistController, address _payoutAddress) public {\n', '        whitelistController = _whitelistController;\n', '        payoutAddress = _payoutAddress;\n', '        stateController = msg.sender;\n', '    }\n', '\n', '    // ################### FALLBACK FUNCTION ###################\n', '\n', '    // implements the deposit and refund actions.\n', '    function () payable public {\n', '        if(msg.value > 0) {\n', '            require(state == States.Open || state == States.Locked);\n', '            if(requireWhitelistingBeforeDeposit) {\n', '                require(whitelist[msg.sender] == true, "not whitelisted");\n', '            }\n', '            tryDeposit();\n', '        } else {\n', '            tryRefund();\n', '        }\n', '    }\n', '\n', '    // ################### PUBLIC FUNCTIONS ###################\n', '\n', '    function stateSetOpen(uint32 _minLockingTs) public\n', '        onlyStateControl\n', '        requireState(States.Init)\n', '    {\n', '        minLockingTs = _minLockingTs;\n', '        setState(States.Open);\n', '    }\n', '\n', '    function stateSetLocked() public\n', '        onlyStateControl\n', '        requireState(States.Open)\n', '    {\n', '        require(block.timestamp >= minLockingTs);\n', '        setState(States.Locked);\n', '    }\n', '\n', '    function stateSetOver() public\n', '        onlyStateControl\n', '        requireState(States.Locked)\n', '    {\n', '        setState(States.Over);\n', '    }\n', '\n', '    // state controller can change the cap. Reducing possible only if not below current deposits\n', '    function updateMaxAcceptedDeposits(uint256 _newMaxDeposits) public onlyStateControl {\n', '        require(cumAcceptedDeposits <= _newMaxDeposits);\n', '        maxCumAcceptedDeposits = _newMaxDeposits;\n', '    }\n', '\n', '    // new limit to be enforced for future deposits\n', '    function updateMinDeposit(uint256 _newMinDeposit) public onlyStateControl {\n', '        minDeposit = _newMinDeposit;\n', '    }\n', '\n', '    // option to switch between async and sync whitelisting\n', '    function setRequireWhitelistingBeforeDeposit(bool _newState) public onlyStateControl {\n', '        requireWhitelistingBeforeDeposit = _newState;\n', '    }\n', '\n', '    // Since whitelisting can occur asynchronously, an account to be whitelisted may already have deposited Ether.\n', '    // In this case the deposit is converted form alien to accepted.\n', '    // Since the deposit logic depends on the whitelisting status and since transactions are processed sequentially,\n', '    // it&#39;s ensured that at any time an account can have either (XOR) no or alien or accepted deposits and that\n', '    // the whitelisting status corresponds to the deposit status (not_whitelisted <-> alien | whitelisted <-> accepted).\n', '    // This function is idempotent.\n', '    function addToWhitelist(address _addr) public onlyWhitelistControl {\n', '        if(whitelist[_addr] != true) {\n', '            // if address has alien deposit: convert it to accepted\n', '            if(alienDeposits[_addr] > 0) {\n', '                cumAcceptedDeposits += alienDeposits[_addr];\n', '                acceptedDeposits[_addr] += alienDeposits[_addr];\n', '                cumAlienDeposits -= alienDeposits[_addr];\n', '                delete alienDeposits[_addr]; // needs to be the last statement in this block!\n', '            }\n', '            whitelist[_addr] = true;\n', '            emit Whitelisted(_addr);\n', '        }\n', '    }\n', '\n', '    // Option for batched whitelisting (for times with crowded chain).\n', '    // caller is responsible to not blow gas limit with too many addresses at once\n', '    function batchAddToWhitelist(address[] _addresses) public onlyWhitelistControl {\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            addToWhitelist(_addresses[i]);\n', '        }\n', '    }\n', '\n', '\n', '    // transfers an alien deposit back to the sender\n', '    function refundAlienDeposit(address _addr) public onlyWhitelistControl {\n', '        // Note: this implementation requires that alienDeposits has a primitive value type.\n', '        // With a complex type, this code would produce a dangling reference.\n', '        uint256 withdrawAmount = alienDeposits[_addr];\n', '        require(withdrawAmount > 0);\n', '        delete alienDeposits[_addr]; // implies setting the value to 0\n', '        cumAlienDeposits -= withdrawAmount;\n', '        emit Refund(_addr, withdrawAmount);\n', '        _addr.transfer(withdrawAmount); // throws on failure\n', '    }\n', '\n', '    // payout of the accepted deposits to the pre-designated address, available once it&#39;s all over\n', '    function payout() public\n', '        onlyStateControl\n', '        requireState(States.Over)\n', '    {\n', '        uint256 amount = cumAcceptedDeposits;\n', '        cumAcceptedDeposits = 0;\n', '        emit FetchedDeposits(amount);\n', '        payoutAddress.transfer(amount);\n', '        // not idempotent, but multiple invocation would just trigger zero-transfers\n', '    }\n', '\n', '    // After the specified date, any of the privileged/special accounts can trigger payment of remaining funds\n', '    // to the payoutAddress. This is a safety net to minimize the risk of funds remaining stuck.\n', '    // It&#39;s not yet clear what we can / should / are allowed to do with alien deposits which aren&#39;t reclaimed.\n', '    // With this fallback in place, we have for example the option to donate them at some point.\n', '    function fallbackPayout() public {\n', '        require(msg.sender == stateController || msg.sender == whitelistController || msg.sender == payoutAddress);\n', '        require(block.timestamp > FALLBACK_PAYOUT_TS);\n', '        payoutAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    // ################### INTERNAL FUNCTIONS ###################\n', '\n', '    // rule enforcement and book-keeping for incoming deposits\n', '    function tryDeposit() internal {\n', '        require(cumAcceptedDeposits + msg.value <= maxCumAcceptedDeposits);\n', '        if(whitelist[msg.sender] == true) {\n', '            require(acceptedDeposits[msg.sender] + msg.value >= minDeposit);\n', '            acceptedDeposits[msg.sender] += msg.value;\n', '            cumAcceptedDeposits += msg.value;\n', '        } else {\n', '            require(alienDeposits[msg.sender] + msg.value >= minDeposit);\n', '            alienDeposits[msg.sender] += msg.value;\n', '            cumAlienDeposits += msg.value;\n', '        }\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    // rule enforcement and book-keeping for refunding requests\n', '    function tryRefund() internal {\n', '        // Note: this implementation requires that acceptedDeposits and alienDeposits have a primitive value type.\n', '        // With a complex type, this code would produce dangling references.\n', '        uint256 withdrawAmount;\n', '        if(whitelist[msg.sender] == true) {\n', '            require(state == States.Open);\n', '            withdrawAmount = acceptedDeposits[msg.sender];\n', '            require(withdrawAmount > 0);\n', '            delete acceptedDeposits[msg.sender]; // implies setting the value to 0\n', '            cumAcceptedDeposits -= withdrawAmount;\n', '        } else {\n', '            // alien deposits can be withdrawn anytime (we prefer to not touch them)\n', '            withdrawAmount = alienDeposits[msg.sender];\n', '            require(withdrawAmount > 0);\n', '            delete alienDeposits[msg.sender]; // implies setting the value to 0\n', '            cumAlienDeposits -= withdrawAmount;\n', '        }\n', '        emit Refund(msg.sender, withdrawAmount);\n', '        // do the actual transfer last as recommended since the DAO incident (Checks-Effects-Interaction pattern)\n', '        msg.sender.transfer(withdrawAmount); // throws on failure\n', '    }\n', '\n', '    function setState(States _newState) internal {\n', '        state = _newState;\n', '        emit StateTransition(state, _newState);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/*\n', ' * Contract accepting reservations for ATS tokens.\n', ' * The actual tokens are not yet created and distributed due to non-technical reasons.\n', ' * This contract is used to collect funds for the ATS token sale and to transparently document that on a blockchain.\n', ' * It is tailored to allow a simple user journey while keeping complexity minimal.\n', ' * Once the privileged "state controller" sets the state to "Open", anybody can send Ether to the contract.\n', ' * Only Ether sent from whitelisted addresses is accepted for future ATS token conversion.\n', ' * The whitelisting is done by a dedicated whitelist controller.\n', " * Whitelisting can take place asynchronously - that is, participants don't need to wait for the whitelisting to\n", ' * succeed before sending funds. This is a technical detail which allows for a smoother user journey.\n', ' * The state controller can switch to synchronous whitelisting (no Ether accepted from accounts not whitelisted before).\n', ' * Participants can trigger refunding during the Open state by making a transfer of 0 Ether.\n', ' * Funds of those not whitelisted (not accepted) are never locked, they can trigger refund beyond Open state.\n', ' * Only in Over state can whitelisted Ether deposits be fetched from the contract.\n', ' *\n', ' * When setting the state to Open, the state controller specifies a minimal timeframe for this state.\n', ' * Transition to the next state (Locked) is not possible (enforced by the contract).\n', ' * This gives participants the guarantee that they can get their full deposits refunded anytime and independently\n', ' * of the will of anybody else during that timeframe.\n', ' * (Note that this is true only as long as the whole process takes place before the date specified by FALLBACK_FETCH_FUNDS_TS)\n', ' *\n', " * Ideally, there's no funds left in the contract once the state is set to Over and the accepted deposits were fetched.\n", " * Since this can't really be foreseen, there's a fallback which allows to fetch all remaining Ether\n", ' * to a pre-specified address after a pre-specified date.\n', ' *\n', ' * Static analysis: block.timestamp is not used in a way which gives miners leeway for taking advantage.\n', ' *\n', ' * see https://code.lab10.io/graz/04-artis/artis/issues/364 for task evolution\n', ' */\n', 'contract ATSTokenReservation {\n', '\n', '    // ################### DATA STRUCTURES ###################\n', '\n', '    enum States {\n', '        Init, // initial state. Contract is deployed, but deposits not yet accepted\n', '        Open, // open for token reservations. Refunds possible for all\n', '        Locked, // open for token reservations. Refunds locked for accepted deposits\n', '        Over // contract has done its duty. Funds payout can be triggered by state controller\n', '    }\n', '\n', '    // ################### CONSTANTS ###################\n', '\n', '    // 1. Oct 2018\n', '    uint32 FALLBACK_PAYOUT_TS = 1538352000;\n', '\n', '    // ################### STATE VARIABLES ###################\n', '\n', '    States public state = States.Init;\n', '\n', '    // privileged account: switch contract state, change config, whitelisting, trigger payout, ...\n', '    address public stateController;\n', '\n', '    // privileged account: whitelisting\n', '    address public whitelistController;\n', '\n', '    // Collected funds can be transferred only to this address. Is set in constructor.\n', '    address public payoutAddress;\n', '\n', '    // accepted deposits (received from whitelisted accounts)\n', '    uint256 public cumAcceptedDeposits = 0;\n', '    // not (yet) accepted deposits (received from non-whitelisted accounts)\n', '    uint256 public cumAlienDeposits = 0;\n', '\n', '    // cap for how much we accept (since the amount of tokens sold is also capped)\n', '    uint256 public maxCumAcceptedDeposits = 1E9 * 1E18; // pre-set to effectively unlimited (> existing ETH)\n', '\n', '    uint256 public minDeposit = 0.1 * 1E18; // lower bound per participant (can be a kind of spam protection)\n', '\n', '    uint256 minLockingTs; // earliest possible start of "locked" phase\n', '\n', '    // whitelisted addresses (those having "accepted" deposits)\n', '    mapping (address => bool) public whitelist;\n', '\n', '    // the state controller can set this in order to disallow deposits from addresses not whitelisted before\n', '    bool public requireWhitelistingBeforeDeposit = false;\n', '\n', '    // tracks accepted deposits (whitelisted accounts)\n', '    mapping (address => uint256) public acceptedDeposits;\n', '\n', '    // tracks alien (not yet accepted) deposits (non-whitelisted accounts)\n', '    mapping (address => uint256) public alienDeposits;\n', '\n', '    // ################### EVENTS ###################\n', '\n', '    // emitted events transparently document the open funding activities.\n', '    // only deposits made by whitelisted accounts (and not followed by a refund) count.\n', '\n', '    event StateTransition(States oldState, States newState);\n', '    event Whitelisted(address addr);\n', '    event Deposit(address addr, uint256 amount);\n', '    event Refund(address addr, uint256 amount);\n', '\n', '    // emitted when the accepted deposits are fetched to an account controlled by the ATS token provider\n', '    event FetchedDeposits(uint256 amount);\n', '\n', '    // ################### MODIFIERS ###################\n', '\n', '    modifier onlyStateControl() { require(msg.sender == stateController, "no permission"); _; }\n', '\n', '    modifier onlyWhitelistControl()\t{\n', '        require(msg.sender == stateController || msg.sender == whitelistController, "no permission");\n', '        _;\n', '    }\n', '\n', '    modifier requireState(States _requiredState) { require(state == _requiredState, "wrong state"); _; }\n', '\n', '    // ################### CONSTRUCTOR ###################\n', '\n', '    // the contract creator is set as stateController\n', '    constructor(address _whitelistController, address _payoutAddress) public {\n', '        whitelistController = _whitelistController;\n', '        payoutAddress = _payoutAddress;\n', '        stateController = msg.sender;\n', '    }\n', '\n', '    // ################### FALLBACK FUNCTION ###################\n', '\n', '    // implements the deposit and refund actions.\n', '    function () payable public {\n', '        if(msg.value > 0) {\n', '            require(state == States.Open || state == States.Locked);\n', '            if(requireWhitelistingBeforeDeposit) {\n', '                require(whitelist[msg.sender] == true, "not whitelisted");\n', '            }\n', '            tryDeposit();\n', '        } else {\n', '            tryRefund();\n', '        }\n', '    }\n', '\n', '    // ################### PUBLIC FUNCTIONS ###################\n', '\n', '    function stateSetOpen(uint32 _minLockingTs) public\n', '        onlyStateControl\n', '        requireState(States.Init)\n', '    {\n', '        minLockingTs = _minLockingTs;\n', '        setState(States.Open);\n', '    }\n', '\n', '    function stateSetLocked() public\n', '        onlyStateControl\n', '        requireState(States.Open)\n', '    {\n', '        require(block.timestamp >= minLockingTs);\n', '        setState(States.Locked);\n', '    }\n', '\n', '    function stateSetOver() public\n', '        onlyStateControl\n', '        requireState(States.Locked)\n', '    {\n', '        setState(States.Over);\n', '    }\n', '\n', '    // state controller can change the cap. Reducing possible only if not below current deposits\n', '    function updateMaxAcceptedDeposits(uint256 _newMaxDeposits) public onlyStateControl {\n', '        require(cumAcceptedDeposits <= _newMaxDeposits);\n', '        maxCumAcceptedDeposits = _newMaxDeposits;\n', '    }\n', '\n', '    // new limit to be enforced for future deposits\n', '    function updateMinDeposit(uint256 _newMinDeposit) public onlyStateControl {\n', '        minDeposit = _newMinDeposit;\n', '    }\n', '\n', '    // option to switch between async and sync whitelisting\n', '    function setRequireWhitelistingBeforeDeposit(bool _newState) public onlyStateControl {\n', '        requireWhitelistingBeforeDeposit = _newState;\n', '    }\n', '\n', '    // Since whitelisting can occur asynchronously, an account to be whitelisted may already have deposited Ether.\n', '    // In this case the deposit is converted form alien to accepted.\n', '    // Since the deposit logic depends on the whitelisting status and since transactions are processed sequentially,\n', "    // it's ensured that at any time an account can have either (XOR) no or alien or accepted deposits and that\n", '    // the whitelisting status corresponds to the deposit status (not_whitelisted <-> alien | whitelisted <-> accepted).\n', '    // This function is idempotent.\n', '    function addToWhitelist(address _addr) public onlyWhitelistControl {\n', '        if(whitelist[_addr] != true) {\n', '            // if address has alien deposit: convert it to accepted\n', '            if(alienDeposits[_addr] > 0) {\n', '                cumAcceptedDeposits += alienDeposits[_addr];\n', '                acceptedDeposits[_addr] += alienDeposits[_addr];\n', '                cumAlienDeposits -= alienDeposits[_addr];\n', '                delete alienDeposits[_addr]; // needs to be the last statement in this block!\n', '            }\n', '            whitelist[_addr] = true;\n', '            emit Whitelisted(_addr);\n', '        }\n', '    }\n', '\n', '    // Option for batched whitelisting (for times with crowded chain).\n', '    // caller is responsible to not blow gas limit with too many addresses at once\n', '    function batchAddToWhitelist(address[] _addresses) public onlyWhitelistControl {\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            addToWhitelist(_addresses[i]);\n', '        }\n', '    }\n', '\n', '\n', '    // transfers an alien deposit back to the sender\n', '    function refundAlienDeposit(address _addr) public onlyWhitelistControl {\n', '        // Note: this implementation requires that alienDeposits has a primitive value type.\n', '        // With a complex type, this code would produce a dangling reference.\n', '        uint256 withdrawAmount = alienDeposits[_addr];\n', '        require(withdrawAmount > 0);\n', '        delete alienDeposits[_addr]; // implies setting the value to 0\n', '        cumAlienDeposits -= withdrawAmount;\n', '        emit Refund(_addr, withdrawAmount);\n', '        _addr.transfer(withdrawAmount); // throws on failure\n', '    }\n', '\n', "    // payout of the accepted deposits to the pre-designated address, available once it's all over\n", '    function payout() public\n', '        onlyStateControl\n', '        requireState(States.Over)\n', '    {\n', '        uint256 amount = cumAcceptedDeposits;\n', '        cumAcceptedDeposits = 0;\n', '        emit FetchedDeposits(amount);\n', '        payoutAddress.transfer(amount);\n', '        // not idempotent, but multiple invocation would just trigger zero-transfers\n', '    }\n', '\n', '    // After the specified date, any of the privileged/special accounts can trigger payment of remaining funds\n', '    // to the payoutAddress. This is a safety net to minimize the risk of funds remaining stuck.\n', "    // It's not yet clear what we can / should / are allowed to do with alien deposits which aren't reclaimed.\n", '    // With this fallback in place, we have for example the option to donate them at some point.\n', '    function fallbackPayout() public {\n', '        require(msg.sender == stateController || msg.sender == whitelistController || msg.sender == payoutAddress);\n', '        require(block.timestamp > FALLBACK_PAYOUT_TS);\n', '        payoutAddress.transfer(address(this).balance);\n', '    }\n', '\n', '    // ################### INTERNAL FUNCTIONS ###################\n', '\n', '    // rule enforcement and book-keeping for incoming deposits\n', '    function tryDeposit() internal {\n', '        require(cumAcceptedDeposits + msg.value <= maxCumAcceptedDeposits);\n', '        if(whitelist[msg.sender] == true) {\n', '            require(acceptedDeposits[msg.sender] + msg.value >= minDeposit);\n', '            acceptedDeposits[msg.sender] += msg.value;\n', '            cumAcceptedDeposits += msg.value;\n', '        } else {\n', '            require(alienDeposits[msg.sender] + msg.value >= minDeposit);\n', '            alienDeposits[msg.sender] += msg.value;\n', '            cumAlienDeposits += msg.value;\n', '        }\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    // rule enforcement and book-keeping for refunding requests\n', '    function tryRefund() internal {\n', '        // Note: this implementation requires that acceptedDeposits and alienDeposits have a primitive value type.\n', '        // With a complex type, this code would produce dangling references.\n', '        uint256 withdrawAmount;\n', '        if(whitelist[msg.sender] == true) {\n', '            require(state == States.Open);\n', '            withdrawAmount = acceptedDeposits[msg.sender];\n', '            require(withdrawAmount > 0);\n', '            delete acceptedDeposits[msg.sender]; // implies setting the value to 0\n', '            cumAcceptedDeposits -= withdrawAmount;\n', '        } else {\n', '            // alien deposits can be withdrawn anytime (we prefer to not touch them)\n', '            withdrawAmount = alienDeposits[msg.sender];\n', '            require(withdrawAmount > 0);\n', '            delete alienDeposits[msg.sender]; // implies setting the value to 0\n', '            cumAlienDeposits -= withdrawAmount;\n', '        }\n', '        emit Refund(msg.sender, withdrawAmount);\n', '        // do the actual transfer last as recommended since the DAO incident (Checks-Effects-Interaction pattern)\n', '        msg.sender.transfer(withdrawAmount); // throws on failure\n', '    }\n', '\n', '    function setState(States _newState) internal {\n', '        state = _newState;\n', '        emit StateTransition(state, _newState);\n', '    }\n', '}']
