['/* Author: Aleksey Selikhov  <span class="__cf_email__" data-cfemail="03626f666870667a2d70666f6a686b6c7543646e626a6f2d606c6e">[email&#160;protected]</span> */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title CommonModifiersInterface\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool);\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the _targetAddress is a contract.\n', '   */\n', '  modifier onlyContractAddress(address _targetAddress) {\n', '    require(isContract(_targetAddress) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title CommonModifiers\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiers is CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool) {\n', '    require (_targetAddress != address(0x0));\n', '\n', '    uint256 length;\n', '    assembly {\n', '      //retrieve the size of the code on target address, this needs assembly\n', '      length := extcodesize(_targetAddress)\n', '    }\n', '    return (length > 0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnableInterface\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableInterface {\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address);\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the current owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == getOwner());\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is OwnableInterface {\n', '\n', '  /* Storage */\n', '\n', '  address owner = address(0x0);\n', '  address proposedOwner = address(0x0);\n', '\n', '\n', '  /* Events */\n', '\n', '  event OwnerAssignedEvent(address indexed newowner);\n', '  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);\n', '\n', '\n', '  /**\n', '   * @dev The constructor sets the initial `owner` to the passed account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner requests transfer ownership to the new owner.\n', '   * @param _proposedOwner The address to transfer ownership to.\n', '   */\n', '  function createOwnershipOffer(address _proposedOwner) external onlyOwner {\n', '    require (proposedOwner == address(0x0));\n', '    require (_proposedOwner != address(0x0));\n', '    require (_proposedOwner != address(this));\n', '\n', '    proposedOwner = _proposedOwner;\n', '\n', '    emit OwnershipOfferCreatedEvent(owner, _proposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the new owner to accept an ownership offer to contract control.\n', '   */\n', '  //noinspection UnprotectedFunction\n', '  function acceptOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == proposedOwner);\n', '\n', '    address _oldOwner = owner;\n', '    owner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '    emit OwnershipOfferAcceptedEvent(_oldOwner, owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner cancels transfer ownership to the new owner.\n', '   */\n', '  function cancelOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == owner || msg.sender == proposedOwner);\n', '\n', '    address _oldProposedOwner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnershipOfferCancelledEvent(owner, _oldProposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "proposedOwner" contract variable\n', '   */\n', '  function getProposedOwner() public constant returns (address) {\n', '    return proposedOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ManageableInterface\n', ' * @dev Contract that allows to grant permissions to any address\n', ' * @dev In real life we are no able to perform all actions with just one Ethereum address\n', ' * @dev because risks are too high.\n', ' * @dev Instead owner delegates rights to manage an contract to the different addresses and\n', ' * @dev stay able to revoke permissions at any time.\n', ' */\n', 'contract ManageableInterface {\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);\n', '\n', '  /**\n', '   * @dev Modifier to use in derived contracts\n', '   */\n', '  modifier onlyAllowedManager(string _permissionName) {\n', '    require(isManagerAllowed(msg.sender, _permissionName) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', 'contract Manageable is OwnableInterface,\n', '                       ManageableInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (address => bool) managerEnabled;  // hard switch for a manager - on/off\n', '  mapping (address => mapping (string => bool)) managerPermissions;  // detailed info about manager`s permissions\n', '\n', '\n', '  /* Events */\n', '\n', '  event ManagerEnabledEvent(address indexed manager);\n', '  event ManagerDisabledEvent(address indexed manager);\n', '  event ManagerPermissionGrantedEvent(address indexed manager, bytes32 permission);\n', '  event ManagerPermissionRevokedEvent(address indexed manager, bytes32 permission);\n', '\n', '\n', '  /* Configure contract */\n', '\n', '  /**\n', '   * @dev Function to add new manager\n', '   * @param _manager address New manager\n', '   */\n', '  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == false);\n', '\n', '    managerEnabled[_manager] = true;\n', '\n', '    emit ManagerEnabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to remove existing manager\n', '   * @param _manager address Existing manager\n', '   */\n', '  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == true);\n', '\n', '    managerEnabled[_manager] = false;\n', '\n', '    emit ManagerDisabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to grant new permission to the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Granted permission name\n', '   */\n', '  function grantManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == false);\n', '\n', '    managerPermissions[_manager][_permissionName] = true;\n', '\n', '    emit ManagerPermissionGrantedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '  /**\n', '   * @dev Function to revoke permission of the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Revoked permission name\n', '   */\n', '  function revokeManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == true);\n', '\n', '    managerPermissions[_manager][_permissionName] = false;\n', '\n', '    emit ManagerPermissionRevokedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev Function to check manager status\n', '   * @param _manager address Manager`s address\n', '   * @return True if manager is enabled\n', '   */\n', '  function isManagerEnabled(\n', '    address _manager\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    returns (bool)\n', '  {\n', '    return managerEnabled[_manager];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check permissions of a manager\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager has been granted needed permission\n', '   */\n', '  function isPermissionGranted(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return managerPermissions[_manager][_permissionName];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return (managerEnabled[_manager] && managerPermissions[_manager][_permissionName]);\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  /**\n', '   * @dev Modifier to check manager address\n', '   */\n', '  modifier onlyValidManagerAddress(address _manager) {\n', '    require(_manager != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidPermissionName(string _permissionName) {\n', '    require(bytes(_permissionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title PausableInterface\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' * @dev Based on zeppelin&#39;s Pausable, but integrated with Manageable\n', ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract PausableInterface {\n', '\n', '  /**\n', '   * Events\n', '   */\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public;\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public;\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool);\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenContractNotPaused() {\n', '    require(getPaused() == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenContractPaused {\n', '    require(getPaused() == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' * @dev Based on zeppelin&#39;s Pausable, but integrated with Manageable\n', ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract Pausable is ManageableInterface,\n', '                     PausableInterface {\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '\n', '  bool paused = true;\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public onlyAllowedManager(&#39;pause_contract&#39;) whenContractNotPaused {\n', '    paused = true;\n', '    emit PauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public onlyAllowedManager(&#39;unpause_contract&#39;) whenContractPaused {\n', '    paused = false;\n', '    emit UnpauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool) {\n', '    return paused;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20Interface\n', ' * @dev ERC20 interface to use in applications\n', ' */\n', 'contract CrydrViewERC20Interface {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function totalSupply() external constant returns (uint256);\n', '  function balanceOf(address _owner) external constant returns (uint256);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20LoggableInterface\n', ' * @dev Contract is able to create Transfer/Approval events with the cal from controller\n', ' */\n', 'contract CrydrViewERC20LoggableInterface {\n', '\n', '  function emitTransferEvent(address _from, address _to, uint256 _value) external;\n', '  function emitApprovalEvent(address _owner, address _spender, uint256 _value) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrStorageERC20Interface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR and have optimization for ERC20 controllers\n', ' */\n', 'contract CrydrStorageERC20Interface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrTransferredEvent(address indexed from, address indexed to, uint256 value);\n', '  event CrydrTransferredFromEvent(address indexed spender, address indexed from, address indexed to, uint256 value);\n', '  event CrydrSpendingApprovedEvent(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '  /* ERC20 optimization. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(address _msgsender, address _to, uint256 _value) public;\n', '  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;\n', '  function approve(address _msgsender, address _spender, uint256 _value) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBaseInterface interface\n', ' * @dev Interface of a contract that implement business-logic of an CryDR, mediates CryDR views and storage\n', ' */\n', 'contract CrydrControllerBaseInterface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrStorageChangedEvent(address indexed crydrstorage);\n', '  event CrydrViewAddedEvent(address indexed crydrview, bytes32 standardname);\n', '  event CrydrViewRemovedEvent(address indexed crydrview, bytes32 standardname);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setCrydrStorage(address _newStorage) external;\n', '  function getCrydrStorageAddress() public constant returns (address);\n', '\n', '  function setCrydrView(address _newCrydrView, string _viewApiStandardName) external;\n', '  function removeCrydrView(string _viewApiStandardName) external;\n', '  function getCrydrViewAddress(string _viewApiStandardName) public constant returns (address);\n', '\n', '  function isCrydrViewAddress(address _crydrViewAddress) public constant returns (bool);\n', '  function isCrydrViewRegistered(string _viewApiStandardName) public constant returns (bool);\n', '\n', '\n', '  /* Helpers */\n', '\n', '  modifier onlyValidCrydrViewStandardName(string _viewApiStandard) {\n', '    require(bytes(_viewApiStandard).length > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCrydrView() {\n', '    require(isCrydrViewAddress(msg.sender) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title JNTPaymentGatewayInterface\n', ' * @dev Allows to charge users by JNT\n', ' */\n', 'contract JNTPaymentGatewayInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTChargedEvent(address indexed payableservice, address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function chargeJNT(address _from, address _to, uint256 _value) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title JNTPaymentGateway\n', ' * @dev Allows to charge users by JNT\n', ' */\n', 'contract JNTPaymentGateway is ManageableInterface,\n', '                              CrydrControllerBaseInterface,\n', '                              JNTPaymentGatewayInterface {\n', '\n', '  function chargeJNT(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    onlyAllowedManager(&#39;jnt_payable_service&#39;)\n', '  {\n', '    CrydrStorageERC20Interface(getCrydrStorageAddress()).transfer(_from, _to, _value);\n', '\n', '    emit JNTChargedEvent(msg.sender, _from, _to, _value);\n', '    if (isCrydrViewRegistered(&#39;erc20&#39;) == true) {\n', '      CrydrViewERC20LoggableInterface(getCrydrViewAddress(&#39;erc20&#39;)).emitTransferEvent(_from, _to, _value);\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTPayableService interface\n', ' * @dev Interface of a contract that charge JNT for actions\n', ' */\n', 'contract JNTPayableServiceInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTControllerChangedEvent(address jntcontroller);\n', '  event JNTBeneficiaryChangedEvent(address jntbeneficiary);\n', '  event JNTChargedEvent(address indexed payer, address indexed to, uint256 value, bytes32 actionname);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(address _jntController) external;\n', '  function getJntController() public constant returns (address);\n', '\n', '  function setJntBeneficiary(address _jntBeneficiary) external;\n', '  function getJntBeneficiary() public constant returns (address);\n', '\n', '  function setActionPrice(string _actionName, uint256 _jntPriceWei) external;\n', '  function getActionPrice(string _actionName) public constant returns (uint256);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function initChargeJNT(address _payer, string _actionName) internal;\n', '}\n', '\n', '\n', 'contract JNTPayableService is CommonModifiersInterface,\n', '                              ManageableInterface,\n', '                              PausableInterface,\n', '                              JNTPayableServiceInterface {\n', '\n', '  /* Storage */\n', '\n', '  JNTPaymentGateway jntController;\n', '  address jntBeneficiary;\n', '  mapping (string => uint256) actionPrice;\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(\n', '    address _jntController\n', '  )\n', '    external\n', '    onlyContractAddress(_jntController)\n', '    onlyAllowedManager(&#39;set_jnt_controller&#39;)\n', '    whenContractPaused\n', '  {\n', '    require(_jntController != address(jntController));\n', '\n', '    jntController = JNTPaymentGateway(_jntController);\n', '\n', '    emit JNTControllerChangedEvent(_jntController);\n', '  }\n', '\n', '  function getJntController() public constant returns (address) {\n', '    return address(jntController);\n', '  }\n', '\n', '\n', '  function setJntBeneficiary(\n', '    address _jntBeneficiary\n', '  )\n', '    external\n', '    onlyValidJntBeneficiary(_jntBeneficiary)\n', '    onlyAllowedManager(&#39;set_jnt_beneficiary&#39;)\n', '    whenContractPaused\n', '  {\n', '    require(_jntBeneficiary != jntBeneficiary);\n', '    require(_jntBeneficiary != address(this));\n', '\n', '    jntBeneficiary = _jntBeneficiary;\n', '\n', '    emit JNTBeneficiaryChangedEvent(jntBeneficiary);\n', '  }\n', '\n', '  function getJntBeneficiary() public constant returns (address) {\n', '    return jntBeneficiary;\n', '  }\n', '\n', '\n', '  function setActionPrice(\n', '    string _actionName,\n', '    uint256 _jntPriceWei\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;set_action_price&#39;)\n', '    onlyValidActionName(_actionName)\n', '    whenContractPaused\n', '  {\n', '    require (_jntPriceWei > 0);\n', '\n', '    actionPrice[_actionName] = _jntPriceWei;\n', '  }\n', '\n', '  function getActionPrice(\n', '    string _actionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidActionName(_actionName)\n', '    returns (uint256)\n', '  {\n', '    return actionPrice[_actionName];\n', '  }\n', '\n', '\n', '  /* Actions */\n', '\n', '  function initChargeJNT(\n', '    address _from,\n', '    string _actionName\n', '  )\n', '    internal\n', '    onlyValidActionName(_actionName)\n', '    whenContractNotPaused\n', '  {\n', '    require(_from != address(0x0));\n', '    require(_from != jntBeneficiary);\n', '\n', '    uint256 _actionPrice = getActionPrice(_actionName);\n', '    require (_actionPrice > 0);\n', '\n', '    jntController.chargeJNT(_from, jntBeneficiary, _actionPrice);\n', '\n', '    emit JNTChargedEvent(_from, jntBeneficiary, _actionPrice, keccak256(_actionName));\n', '  }\n', '\n', '\n', '  /* Pausable */\n', '\n', '  /**\n', '   * @dev Override method to ensure that contract properly configured before it is unpaused\n', '   */\n', '  function unpauseContract()\n', '    public\n', '    onlyContractAddress(jntController)\n', '    onlyValidJntBeneficiary(jntBeneficiary)\n', '  {\n', '    super.unpauseContract();\n', '  }\n', '\n', '\n', '  /* Modifiers */\n', '\n', '  modifier onlyValidJntBeneficiary(address _jntBeneficiary) {\n', '    require(_jntBeneficiary != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidActionName(string _actionName) {\n', '    require(bytes(_actionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title JcashRegistrarInterface\n', ' * @dev Interface of a contract that can receives ETH&ERC20, refunds ETH&ERC20 and logs these operations\n', ' */\n', 'contract JcashRegistrarInterface {\n', '\n', '  /* Events */\n', '\n', '  event ReceiveEthEvent(address indexed from, uint256 value);\n', '  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '\n', '  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event ReplenishEthEvent(address indexed from, uint256 value);\n', '  event WithdrawEthEvent(address indexed to, uint256 value);\n', '  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /* Replenisher actions */\n', '\n', '  /**\n', '   * @dev Allows to withdraw ETH by Replenisher.\n', '   */\n', '  function withdrawEth(uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to withdraw tokens by Replenisher.\n', '   */\n', '  function withdrawToken(address _tokenAddress, uint256 _weivalue) external;\n', '\n', '\n', '  /* Processing of exchange operations */\n', '\n', '  /**\n', '   * @dev Allows to perform refund ETH.\n', '   */\n', '  function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform refund ERC20 tokens.\n', '   */\n', '  function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ETH.\n', '   *\n', '   */\n', '  function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ERC20 tokens.\n', '   */\n', '  function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev The getter returns true if tx hash is processed\n', '   */\n', '  function isProcessedTx(bytes32 _txHash) public view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title JcashRegistrar\n', ' * @dev Implementation of a contract that can receives ETH&ERC20, refunds ETH&ERC20 and logs these operations\n', ' */\n', 'contract JcashRegistrar is CommonModifiers,\n', '                           Ownable,\n', '                           Manageable,\n', '                           Pausable,\n', '                           JNTPayableService,\n', '                           JcashRegistrarInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (bytes32 => bool) processedTxs;\n', '\n', '\n', '  /* Events */\n', '\n', '  event ReceiveEthEvent(address indexed from, uint256 value);\n', '  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event ReplenishEthEvent(address indexed from, uint256 value);\n', '  event WithdrawEthEvent(address indexed to, uint256 value);\n', '  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /* Modifiers */\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    require(msg.data.length == (size + 4));\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Fallback function allowing the contract to receive funds, if contract haven&#39;t already been paused.\n', '   */\n', '  function () external payable {\n', '    if (isManagerAllowed(msg.sender, &#39;replenish_eth&#39;)==true) {\n', '      emit ReplenishEthEvent(msg.sender, msg.value);\n', '    } else {\n', '      require (getPaused() == false);\n', '      emit ReceiveEthEvent(msg.sender, msg.value);\n', '    }\n', '  }\n', '\n', '\n', '  /* Replenisher actions */\n', '\n', '  /**\n', '   * @dev Allows to withdraw ETH by Replenisher.\n', '   */\n', '  function withdrawEth(\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;replenish_eth&#39;)\n', '    onlyPayloadSize(1 * 32)\n', '  {\n', '    require (_weivalue > 0);\n', '\n', '    address(msg.sender).transfer(_weivalue);\n', '    emit WithdrawEthEvent(msg.sender, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to withdraw tokens by Replenisher.\n', '   */\n', '  function withdrawToken(\n', '    address _tokenAddress,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;replenish_token&#39;)\n', '    onlyPayloadSize(2 * 32)\n', '  {\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(msg.sender, _weivalue);\n', '    emit WithdrawTokenEvent(_tokenAddress, msg.sender, _weivalue);\n', '  }\n', '\n', '\n', '  /* Processing of exchange operations */\n', '\n', '  /**\n', '   * @dev Allows to perform refund ETH.\n', '   */\n', '  function refundEth(\n', '    bytes32 _txHash,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;refund_eth&#39;)\n', '    whenContractNotPaused\n', '    onlyPayloadSize(3 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    _to.transfer(_weivalue);\n', '\n', '    emit RefundEthEvent(_txHash, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform refund ERC20 tokens.\n', '   */\n', '  function refundToken(\n', '    bytes32 _txHash,\n', '    address _tokenAddress,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;refund_token&#39;)\n', '    whenContractNotPaused\n', '    onlyPayloadSize(4 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);\n', '\n', '    emit RefundTokenEvent(_txHash, _tokenAddress, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ETH.\n', '   *\n', '   */\n', '  function transferEth(\n', '    bytes32 _txHash,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;transfer_eth&#39;)\n', '    whenContractNotPaused\n', '    onlyPayloadSize(3 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    _to.transfer(_weivalue);\n', '\n', '    if (getActionPrice(&#39;transfer_eth&#39;) > 0) {\n', '      initChargeJNT(_to, &#39;transfer_eth&#39;);\n', '    }\n', '\n', '    emit TransferEthEvent(_txHash, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ERC20 tokens.\n', '   */\n', '  function transferToken(\n', '    bytes32 _txHash,\n', '    address _tokenAddress,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;transfer_token&#39;)\n', '    whenContractNotPaused\n', '    onlyPayloadSize(4 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '\n', '    processedTxs[_txHash] = true;\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);\n', '\n', '    if (getActionPrice(&#39;transfer_token&#39;) > 0) {\n', '      initChargeJNT(_to, &#39;transfer_token&#39;);\n', '    }\n', '\n', '    emit TransferTokenEvent(_txHash, _tokenAddress, _to, _weivalue);\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev The getter returns true if tx hash is processed\n', '   */\n', '  function isProcessedTx(\n', '    bytes32 _txHash\n', '  )\n', '    public\n', '    view\n', '    onlyPayloadSize(1 * 32)\n', '    returns (bool)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    return processedTxs[_txHash];\n', '  }\n', '}']
['/* Author: Aleksey Selikhov  aleksey.selikhov@gmail.com */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title CommonModifiersInterface\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool);\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the _targetAddress is a contract.\n', '   */\n', '  modifier onlyContractAddress(address _targetAddress) {\n', '    require(isContract(_targetAddress) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title CommonModifiers\n', ' * @dev Base contract which contains common checks.\n', ' */\n', 'contract CommonModifiers is CommonModifiersInterface {\n', '\n', '  /**\n', '   * @dev Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '   */\n', '  function isContract(address _targetAddress) internal constant returns (bool) {\n', '    require (_targetAddress != address(0x0));\n', '\n', '    uint256 length;\n', '    assembly {\n', '      //retrieve the size of the code on target address, this needs assembly\n', '      length := extcodesize(_targetAddress)\n', '    }\n', '    return (length > 0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnableInterface\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableInterface {\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address);\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the current owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == getOwner());\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is OwnableInterface {\n', '\n', '  /* Storage */\n', '\n', '  address owner = address(0x0);\n', '  address proposedOwner = address(0x0);\n', '\n', '\n', '  /* Events */\n', '\n', '  event OwnerAssignedEvent(address indexed newowner);\n', '  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);\n', '\n', '\n', '  /**\n', '   * @dev The constructor sets the initial `owner` to the passed account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner requests transfer ownership to the new owner.\n', '   * @param _proposedOwner The address to transfer ownership to.\n', '   */\n', '  function createOwnershipOffer(address _proposedOwner) external onlyOwner {\n', '    require (proposedOwner == address(0x0));\n', '    require (_proposedOwner != address(0x0));\n', '    require (_proposedOwner != address(this));\n', '\n', '    proposedOwner = _proposedOwner;\n', '\n', '    emit OwnershipOfferCreatedEvent(owner, _proposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the new owner to accept an ownership offer to contract control.\n', '   */\n', '  //noinspection UnprotectedFunction\n', '  function acceptOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == proposedOwner);\n', '\n', '    address _oldOwner = owner;\n', '    owner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '    emit OwnershipOfferAcceptedEvent(_oldOwner, owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner cancels transfer ownership to the new owner.\n', '   */\n', '  function cancelOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == owner || msg.sender == proposedOwner);\n', '\n', '    address _oldProposedOwner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnershipOfferCancelledEvent(owner, _oldProposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "proposedOwner" contract variable\n', '   */\n', '  function getProposedOwner() public constant returns (address) {\n', '    return proposedOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ManageableInterface\n', ' * @dev Contract that allows to grant permissions to any address\n', ' * @dev In real life we are no able to perform all actions with just one Ethereum address\n', ' * @dev because risks are too high.\n', ' * @dev Instead owner delegates rights to manage an contract to the different addresses and\n', ' * @dev stay able to revoke permissions at any time.\n', ' */\n', 'contract ManageableInterface {\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);\n', '\n', '  /**\n', '   * @dev Modifier to use in derived contracts\n', '   */\n', '  modifier onlyAllowedManager(string _permissionName) {\n', '    require(isManagerAllowed(msg.sender, _permissionName) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', 'contract Manageable is OwnableInterface,\n', '                       ManageableInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (address => bool) managerEnabled;  // hard switch for a manager - on/off\n', '  mapping (address => mapping (string => bool)) managerPermissions;  // detailed info about manager`s permissions\n', '\n', '\n', '  /* Events */\n', '\n', '  event ManagerEnabledEvent(address indexed manager);\n', '  event ManagerDisabledEvent(address indexed manager);\n', '  event ManagerPermissionGrantedEvent(address indexed manager, bytes32 permission);\n', '  event ManagerPermissionRevokedEvent(address indexed manager, bytes32 permission);\n', '\n', '\n', '  /* Configure contract */\n', '\n', '  /**\n', '   * @dev Function to add new manager\n', '   * @param _manager address New manager\n', '   */\n', '  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == false);\n', '\n', '    managerEnabled[_manager] = true;\n', '\n', '    emit ManagerEnabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to remove existing manager\n', '   * @param _manager address Existing manager\n', '   */\n', '  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == true);\n', '\n', '    managerEnabled[_manager] = false;\n', '\n', '    emit ManagerDisabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to grant new permission to the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Granted permission name\n', '   */\n', '  function grantManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == false);\n', '\n', '    managerPermissions[_manager][_permissionName] = true;\n', '\n', '    emit ManagerPermissionGrantedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '  /**\n', '   * @dev Function to revoke permission of the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Revoked permission name\n', '   */\n', '  function revokeManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == true);\n', '\n', '    managerPermissions[_manager][_permissionName] = false;\n', '\n', '    emit ManagerPermissionRevokedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev Function to check manager status\n', '   * @param _manager address Manager`s address\n', '   * @return True if manager is enabled\n', '   */\n', '  function isManagerEnabled(\n', '    address _manager\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    returns (bool)\n', '  {\n', '    return managerEnabled[_manager];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check permissions of a manager\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager has been granted needed permission\n', '   */\n', '  function isPermissionGranted(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return managerPermissions[_manager][_permissionName];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return (managerEnabled[_manager] && managerPermissions[_manager][_permissionName]);\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  /**\n', '   * @dev Modifier to check manager address\n', '   */\n', '  modifier onlyValidManagerAddress(address _manager) {\n', '    require(_manager != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidPermissionName(string _permissionName) {\n', '    require(bytes(_permissionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title PausableInterface\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', " * @dev Based on zeppelin's Pausable, but integrated with Manageable\n", ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract PausableInterface {\n', '\n', '  /**\n', '   * Events\n', '   */\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public;\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public;\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool);\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenContractNotPaused() {\n', '    require(getPaused() == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenContractPaused {\n', '    require(getPaused() == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', " * @dev Based on zeppelin's Pausable, but integrated with Manageable\n", ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract Pausable is ManageableInterface,\n', '                     PausableInterface {\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '\n', '  bool paused = true;\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', "  function pauseContract() public onlyAllowedManager('pause_contract') whenContractNotPaused {\n", '    paused = true;\n', '    emit PauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', "  function unpauseContract() public onlyAllowedManager('unpause_contract') whenContractPaused {\n", '    paused = false;\n', '    emit UnpauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool) {\n', '    return paused;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20Interface\n', ' * @dev ERC20 interface to use in applications\n', ' */\n', 'contract CrydrViewERC20Interface {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function totalSupply() external constant returns (uint256);\n', '  function balanceOf(address _owner) external constant returns (uint256);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '  function allowance(address _owner, address _spender) external constant returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrViewERC20LoggableInterface\n', ' * @dev Contract is able to create Transfer/Approval events with the cal from controller\n', ' */\n', 'contract CrydrViewERC20LoggableInterface {\n', '\n', '  function emitTransferEvent(address _from, address _to, uint256 _value) external;\n', '  function emitApprovalEvent(address _owner, address _spender, uint256 _value) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrStorageERC20Interface interface\n', ' * @dev Interface of a contract that manages balance of an CryDR and have optimization for ERC20 controllers\n', ' */\n', 'contract CrydrStorageERC20Interface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrTransferredEvent(address indexed from, address indexed to, uint256 value);\n', '  event CrydrTransferredFromEvent(address indexed spender, address indexed from, address indexed to, uint256 value);\n', '  event CrydrSpendingApprovedEvent(address indexed owner, address indexed spender, uint256 value);\n', '\n', '\n', '  /* ERC20 optimization. _msgsender - account that invoked CrydrView */\n', '\n', '  function transfer(address _msgsender, address _to, uint256 _value) public;\n', '  function transferFrom(address _msgsender, address _from, address _to, uint256 _value) public;\n', '  function approve(address _msgsender, address _spender, uint256 _value) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title CrydrControllerBaseInterface interface\n', ' * @dev Interface of a contract that implement business-logic of an CryDR, mediates CryDR views and storage\n', ' */\n', 'contract CrydrControllerBaseInterface {\n', '\n', '  /* Events */\n', '\n', '  event CrydrStorageChangedEvent(address indexed crydrstorage);\n', '  event CrydrViewAddedEvent(address indexed crydrview, bytes32 standardname);\n', '  event CrydrViewRemovedEvent(address indexed crydrview, bytes32 standardname);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setCrydrStorage(address _newStorage) external;\n', '  function getCrydrStorageAddress() public constant returns (address);\n', '\n', '  function setCrydrView(address _newCrydrView, string _viewApiStandardName) external;\n', '  function removeCrydrView(string _viewApiStandardName) external;\n', '  function getCrydrViewAddress(string _viewApiStandardName) public constant returns (address);\n', '\n', '  function isCrydrViewAddress(address _crydrViewAddress) public constant returns (bool);\n', '  function isCrydrViewRegistered(string _viewApiStandardName) public constant returns (bool);\n', '\n', '\n', '  /* Helpers */\n', '\n', '  modifier onlyValidCrydrViewStandardName(string _viewApiStandard) {\n', '    require(bytes(_viewApiStandard).length > 0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyCrydrView() {\n', '    require(isCrydrViewAddress(msg.sender) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title JNTPaymentGatewayInterface\n', ' * @dev Allows to charge users by JNT\n', ' */\n', 'contract JNTPaymentGatewayInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTChargedEvent(address indexed payableservice, address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function chargeJNT(address _from, address _to, uint256 _value) public;\n', '}\n', '\n', '\n', '/**\n', ' * @title JNTPaymentGateway\n', ' * @dev Allows to charge users by JNT\n', ' */\n', 'contract JNTPaymentGateway is ManageableInterface,\n', '                              CrydrControllerBaseInterface,\n', '                              JNTPaymentGatewayInterface {\n', '\n', '  function chargeJNT(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', "    onlyAllowedManager('jnt_payable_service')\n", '  {\n', '    CrydrStorageERC20Interface(getCrydrStorageAddress()).transfer(_from, _to, _value);\n', '\n', '    emit JNTChargedEvent(msg.sender, _from, _to, _value);\n', "    if (isCrydrViewRegistered('erc20') == true) {\n", "      CrydrViewERC20LoggableInterface(getCrydrViewAddress('erc20')).emitTransferEvent(_from, _to, _value);\n", '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JNTPayableService interface\n', ' * @dev Interface of a contract that charge JNT for actions\n', ' */\n', 'contract JNTPayableServiceInterface {\n', '\n', '  /* Events */\n', '\n', '  event JNTControllerChangedEvent(address jntcontroller);\n', '  event JNTBeneficiaryChangedEvent(address jntbeneficiary);\n', '  event JNTChargedEvent(address indexed payer, address indexed to, uint256 value, bytes32 actionname);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(address _jntController) external;\n', '  function getJntController() public constant returns (address);\n', '\n', '  function setJntBeneficiary(address _jntBeneficiary) external;\n', '  function getJntBeneficiary() public constant returns (address);\n', '\n', '  function setActionPrice(string _actionName, uint256 _jntPriceWei) external;\n', '  function getActionPrice(string _actionName) public constant returns (uint256);\n', '\n', '\n', '  /* Actions */\n', '\n', '  function initChargeJNT(address _payer, string _actionName) internal;\n', '}\n', '\n', '\n', 'contract JNTPayableService is CommonModifiersInterface,\n', '                              ManageableInterface,\n', '                              PausableInterface,\n', '                              JNTPayableServiceInterface {\n', '\n', '  /* Storage */\n', '\n', '  JNTPaymentGateway jntController;\n', '  address jntBeneficiary;\n', '  mapping (string => uint256) actionPrice;\n', '\n', '\n', '  /* Configuration */\n', '\n', '  function setJntController(\n', '    address _jntController\n', '  )\n', '    external\n', '    onlyContractAddress(_jntController)\n', "    onlyAllowedManager('set_jnt_controller')\n", '    whenContractPaused\n', '  {\n', '    require(_jntController != address(jntController));\n', '\n', '    jntController = JNTPaymentGateway(_jntController);\n', '\n', '    emit JNTControllerChangedEvent(_jntController);\n', '  }\n', '\n', '  function getJntController() public constant returns (address) {\n', '    return address(jntController);\n', '  }\n', '\n', '\n', '  function setJntBeneficiary(\n', '    address _jntBeneficiary\n', '  )\n', '    external\n', '    onlyValidJntBeneficiary(_jntBeneficiary)\n', "    onlyAllowedManager('set_jnt_beneficiary')\n", '    whenContractPaused\n', '  {\n', '    require(_jntBeneficiary != jntBeneficiary);\n', '    require(_jntBeneficiary != address(this));\n', '\n', '    jntBeneficiary = _jntBeneficiary;\n', '\n', '    emit JNTBeneficiaryChangedEvent(jntBeneficiary);\n', '  }\n', '\n', '  function getJntBeneficiary() public constant returns (address) {\n', '    return jntBeneficiary;\n', '  }\n', '\n', '\n', '  function setActionPrice(\n', '    string _actionName,\n', '    uint256 _jntPriceWei\n', '  )\n', '    external\n', "    onlyAllowedManager('set_action_price')\n", '    onlyValidActionName(_actionName)\n', '    whenContractPaused\n', '  {\n', '    require (_jntPriceWei > 0);\n', '\n', '    actionPrice[_actionName] = _jntPriceWei;\n', '  }\n', '\n', '  function getActionPrice(\n', '    string _actionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidActionName(_actionName)\n', '    returns (uint256)\n', '  {\n', '    return actionPrice[_actionName];\n', '  }\n', '\n', '\n', '  /* Actions */\n', '\n', '  function initChargeJNT(\n', '    address _from,\n', '    string _actionName\n', '  )\n', '    internal\n', '    onlyValidActionName(_actionName)\n', '    whenContractNotPaused\n', '  {\n', '    require(_from != address(0x0));\n', '    require(_from != jntBeneficiary);\n', '\n', '    uint256 _actionPrice = getActionPrice(_actionName);\n', '    require (_actionPrice > 0);\n', '\n', '    jntController.chargeJNT(_from, jntBeneficiary, _actionPrice);\n', '\n', '    emit JNTChargedEvent(_from, jntBeneficiary, _actionPrice, keccak256(_actionName));\n', '  }\n', '\n', '\n', '  /* Pausable */\n', '\n', '  /**\n', '   * @dev Override method to ensure that contract properly configured before it is unpaused\n', '   */\n', '  function unpauseContract()\n', '    public\n', '    onlyContractAddress(jntController)\n', '    onlyValidJntBeneficiary(jntBeneficiary)\n', '  {\n', '    super.unpauseContract();\n', '  }\n', '\n', '\n', '  /* Modifiers */\n', '\n', '  modifier onlyValidJntBeneficiary(address _jntBeneficiary) {\n', '    require(_jntBeneficiary != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidActionName(string _actionName) {\n', '    require(bytes(_actionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title JcashRegistrarInterface\n', ' * @dev Interface of a contract that can receives ETH&ERC20, refunds ETH&ERC20 and logs these operations\n', ' */\n', 'contract JcashRegistrarInterface {\n', '\n', '  /* Events */\n', '\n', '  event ReceiveEthEvent(address indexed from, uint256 value);\n', '  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '\n', '  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event ReplenishEthEvent(address indexed from, uint256 value);\n', '  event WithdrawEthEvent(address indexed to, uint256 value);\n', '  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /* Replenisher actions */\n', '\n', '  /**\n', '   * @dev Allows to withdraw ETH by Replenisher.\n', '   */\n', '  function withdrawEth(uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to withdraw tokens by Replenisher.\n', '   */\n', '  function withdrawToken(address _tokenAddress, uint256 _weivalue) external;\n', '\n', '\n', '  /* Processing of exchange operations */\n', '\n', '  /**\n', '   * @dev Allows to perform refund ETH.\n', '   */\n', '  function refundEth(bytes32 _txHash, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform refund ERC20 tokens.\n', '   */\n', '  function refundToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ETH.\n', '   *\n', '   */\n', '  function transferEth(bytes32 _txHash, address _to, uint256 _weivalue) external;\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ERC20 tokens.\n', '   */\n', '  function transferToken(bytes32 _txHash, address _tokenAddress, address _to, uint256 _weivalue) external;\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev The getter returns true if tx hash is processed\n', '   */\n', '  function isProcessedTx(bytes32 _txHash) public view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title JcashRegistrar\n', ' * @dev Implementation of a contract that can receives ETH&ERC20, refunds ETH&ERC20 and logs these operations\n', ' */\n', 'contract JcashRegistrar is CommonModifiers,\n', '                           Ownable,\n', '                           Manageable,\n', '                           Pausable,\n', '                           JNTPayableService,\n', '                           JcashRegistrarInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (bytes32 => bool) processedTxs;\n', '\n', '\n', '  /* Events */\n', '\n', '  event ReceiveEthEvent(address indexed from, uint256 value);\n', '  event RefundEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event TransferEthEvent(bytes32 txhash, address indexed to, uint256 value);\n', '  event RefundTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '  event TransferTokenEvent(bytes32 txhash, address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event ReplenishEthEvent(address indexed from, uint256 value);\n', '  event WithdrawEthEvent(address indexed to, uint256 value);\n', '  event WithdrawTokenEvent(address indexed tokenaddress, address indexed to, uint256 value);\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /* Modifiers */\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    require(msg.data.length == (size + 4));\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', "   * @dev Fallback function allowing the contract to receive funds, if contract haven't already been paused.\n", '   */\n', '  function () external payable {\n', "    if (isManagerAllowed(msg.sender, 'replenish_eth')==true) {\n", '      emit ReplenishEthEvent(msg.sender, msg.value);\n', '    } else {\n', '      require (getPaused() == false);\n', '      emit ReceiveEthEvent(msg.sender, msg.value);\n', '    }\n', '  }\n', '\n', '\n', '  /* Replenisher actions */\n', '\n', '  /**\n', '   * @dev Allows to withdraw ETH by Replenisher.\n', '   */\n', '  function withdrawEth(\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('replenish_eth')\n", '    onlyPayloadSize(1 * 32)\n', '  {\n', '    require (_weivalue > 0);\n', '\n', '    address(msg.sender).transfer(_weivalue);\n', '    emit WithdrawEthEvent(msg.sender, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to withdraw tokens by Replenisher.\n', '   */\n', '  function withdrawToken(\n', '    address _tokenAddress,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('replenish_token')\n", '    onlyPayloadSize(2 * 32)\n', '  {\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(msg.sender, _weivalue);\n', '    emit WithdrawTokenEvent(_tokenAddress, msg.sender, _weivalue);\n', '  }\n', '\n', '\n', '  /* Processing of exchange operations */\n', '\n', '  /**\n', '   * @dev Allows to perform refund ETH.\n', '   */\n', '  function refundEth(\n', '    bytes32 _txHash,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('refund_eth')\n", '    whenContractNotPaused\n', '    onlyPayloadSize(3 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    _to.transfer(_weivalue);\n', '\n', '    emit RefundEthEvent(_txHash, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform refund ERC20 tokens.\n', '   */\n', '  function refundToken(\n', '    bytes32 _txHash,\n', '    address _tokenAddress,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('refund_token')\n", '    whenContractNotPaused\n', '    onlyPayloadSize(4 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);\n', '\n', '    emit RefundTokenEvent(_txHash, _tokenAddress, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ETH.\n', '   *\n', '   */\n', '  function transferEth(\n', '    bytes32 _txHash,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('transfer_eth')\n", '    whenContractNotPaused\n', '    onlyPayloadSize(3 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '    require (_weivalue > 0);\n', '\n', '    processedTxs[_txHash] = true;\n', '    _to.transfer(_weivalue);\n', '\n', "    if (getActionPrice('transfer_eth') > 0) {\n", "      initChargeJNT(_to, 'transfer_eth');\n", '    }\n', '\n', '    emit TransferEthEvent(_txHash, _to, _weivalue);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows to perform transfer ERC20 tokens.\n', '   */\n', '  function transferToken(\n', '    bytes32 _txHash,\n', '    address _tokenAddress,\n', '    address _to,\n', '    uint256 _weivalue\n', '  )\n', '    external\n', "    onlyAllowedManager('transfer_token')\n", '    whenContractNotPaused\n', '    onlyPayloadSize(4 * 32)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    require (processedTxs[_txHash] == false);\n', '    require (_tokenAddress != address(0x0));\n', '    require (_tokenAddress != address(this));\n', '    require (_to != address(0x0));\n', '    require (_to != address(this));\n', '\n', '    processedTxs[_txHash] = true;\n', '    CrydrViewERC20Interface(_tokenAddress).transfer(_to, _weivalue);\n', '\n', "    if (getActionPrice('transfer_token') > 0) {\n", "      initChargeJNT(_to, 'transfer_token');\n", '    }\n', '\n', '    emit TransferTokenEvent(_txHash, _tokenAddress, _to, _weivalue);\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev The getter returns true if tx hash is processed\n', '   */\n', '  function isProcessedTx(\n', '    bytes32 _txHash\n', '  )\n', '    public\n', '    view\n', '    onlyPayloadSize(1 * 32)\n', '    returns (bool)\n', '  {\n', '    require (_txHash != bytes32(0));\n', '    return processedTxs[_txHash];\n', '  }\n', '}']
