['pragma solidity ^0.4.24;\n', '\n', '   contract TCallee {\n', '\n', '// Connection to other ERC20 smart contracts\n', ' function transferFrom(address _from, address _to, uint256 _value) external returns (bool success){}\n', '\n', '}\n', ' \n', 'interface  ptopinterface  {\n', '       //new exchange function\n', '       function newExchange (address smart1, uint256 amount1, address two2, address smart2, uint256 amount2) external payable returns(uint exchangeId);\n', '       //new exchange event\n', '       event NewExchange (uint exchangeId, address one1, address indexed smart1, uint256 amount1, address two2, address indexed smart2, uint256 amount2);\n', '      //get the exchange details\n', '       function getExchange (uint _Id) external view returns (address _one1,address _smart1,uint256 _amount1, address _two2, address _smart2, uint256 _amount2, bool); \n', '       //cancek an exchange by one of the parties\n', '       function cancelExchange (uint exchangeId) external payable returns (bool success);\n', '       //cancel exchange event\n', '       event CancelExchange (uint exchangeId);\n', '       // do exchange function\n', '       function doExchange (uint exchangeId) external payable returns (bool success);\n', '       //do exchange event\n', '       event DoExchange (uint exchangeId);\n', '    \n', '}\n', '\n', 'contract p2ptokenexchange is ptopinterface{\n', '    \n', '     address constant atokenaddress=0xf0B3BA2Dd4B2ef75d727A4045d7fBcc415B77bF0;//mainnet\n', '    \n', '    struct exchange {\n', '        address one1;\n', '        address smart1;\n', '        uint256 amount1;\n', '        address two2;\n', '        address smart2;\n', '        uint256 amount2;\n', '        bool DealDone;\n', '    }\n', '    \n', '    uint counter= 0;\n', '    //mapping by counter \n', '    mapping (uint => exchange) exchanges;\n', '    \n', '    event NewExchange (uint exchangeId, address one1, address indexed smart1, uint256 amount1, address two2, address indexed smart2, uint256 amount2);\n', '    event CancelExchange (uint exchangeId);\n', '    event DoExchange (uint exchangeId);\n', '    \n', '    function newExchange (address smart1, uint256 amount1, address two2, address smart2, uint256 amount2) external payable returns(uint exchangeId) {\n', '        require(msg.value>=206000000);\n', '        exchangeId = counter;\n', '        exchanges[exchangeId]=exchange(msg.sender,smart1,amount1,two2,smart2,amount2,false);\n', '        counter +=1;\n', '        if (exchanges[exchangeId].smart1==address(0)) {\n', '        require(msg.value>=exchanges[exchangeId].amount1+206000000);\n', '        uint256 amountTosend=(msg.value-exchanges[exchangeId].amount1);\n', '        payether(atokenaddress, amountTosend);\n', '        } else {\n', '           require(payether(atokenaddress, msg.value)==true);   \n', '        }\n', '        emit NewExchange (exchangeId,msg.sender,smart1,amount1,two2,smart2,amount2);\n', '        return exchangeId;\n', '    }\n', '    \n', '    function getExchange (uint _Id) external view returns (address _one1,address _smart1,uint256 _amount1, address _two2, address _smart2, uint256 _amount2, bool){\n', '        return (exchanges[_Id].one1, exchanges[_Id].smart1, exchanges[_Id].amount1, exchanges[_Id].two2, exchanges[_Id].smart2, exchanges[_Id].amount2, exchanges[_Id].DealDone);\n', '    }\n', '    \n', '    function cancelExchange (uint exchangeId) external payable returns (bool success) {\n', '         //re-entry defense\n', '        bool locked;\n', '        require(!locked);\n', '        locked = true;\n', '        require(msg.value>=206000000);\n', '        if (msg.sender==exchanges[exchangeId].one1) {\n', '        } else {\n', '        require(msg.sender==exchanges[exchangeId].two2);\n', '        require(msg.sender!=0x1111111111111111111111111111111111111111);    \n', '        }\n', '        \n', '        exchanges[exchangeId].DealDone=true;\n', '        if (exchanges[exchangeId].smart1==address(0)) {\n', '            require(payether(exchanges[exchangeId].one1, exchanges[exchangeId].amount1)==true);\n', '        }\n', '         require(payether(atokenaddress, msg.value)==true);\n', '         emit CancelExchange(exchangeId);\n', '         locked=false;\n', '            return true;\n', '                }\n', '    \n', '    function doExchange (uint exchangeId) external payable returns (bool success) {\n', '         //re-entry defense\n', '        bool _locked;\n', '        require(!_locked);\n', '        _locked = true;\n', '        require(msg.value>=206000000);\n', '        if (exchanges[exchangeId].two2!=0x1111111111111111111111111111111111111111){\n', '        require(msg.sender==exchanges[exchangeId].two2);\n', '        } else {\n', '        exchanges[exchangeId].two2=msg.sender;    \n', '        }\n', '   \n', '        require(exchanges[exchangeId].DealDone==false);\n', '        require(exchanges[exchangeId].amount2>0);\n', '       \n', '        if (exchanges[exchangeId].smart2==address(0)) {\n', '            \n', '            require(msg.value >=206000000 + exchanges[exchangeId].amount2);\n', '            require(payether(atokenaddress, msg.value - exchanges[exchangeId].amount2)==true);\n', '        } else {\n', '            require(payether(atokenaddress, msg.value)==true);\n', '        }\n', '       //party 2 move tokens to party 1\n', '        if (exchanges[exchangeId].smart2==address(0)) {\n', '            require(payether(exchanges[exchangeId].one1,exchanges[exchangeId].amount2)==true);\n', '        } else {\n', '            TCallee c= TCallee(exchanges[exchangeId].smart2);\n', '            bool x=c.transferFrom(exchanges[exchangeId].two2, exchanges[exchangeId].one1, exchanges[exchangeId].amount2);\n', '             require(x==true);\n', '        }\n', '      \n', '      //party 1 moves tokens to party 2\n', '      if (exchanges[exchangeId].smart1==address(0)) {\n', '         require(payether(exchanges[exchangeId].two2, exchanges[exchangeId].amount1)==true);\n', '         \n', '    } else {\n', '         TCallee d= TCallee(exchanges[exchangeId].smart1);\n', '            bool y=d.transferFrom(exchanges[exchangeId].one1, exchanges[exchangeId].two2, exchanges[exchangeId].amount1);\n', '             require(y==true);\n', '      \n', '      \n', '    }\n', '    exchanges[exchangeId].DealDone=true;\n', '    emit DoExchange (exchangeId); \n', '    _locked=false;\n', '    return true;\n', '}\n', '\n', 'function payether(address payto, uint256 amountTo) internal returns(bool){\n', '    payto.transfer(amountTo);\n', '    return true;\n', '}\n', '}']