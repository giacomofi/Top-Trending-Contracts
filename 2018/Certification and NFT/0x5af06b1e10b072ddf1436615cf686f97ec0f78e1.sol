['pragma solidity ^0.4.16;\n', '\n', '\n', 'contract UnilotPrizeCalculator {\n', '    //Calculation constants\n', '    uint64  constant accuracy                   = 1000000000000000000;\n', '    uint8  constant MAX_X_FOR_Y                = 195;  // 19.5\n', '\n', '    uint8  constant minPrizeCoeficent          = 1;\n', '    uint8  constant percentOfWinners           = 5;    // 5%\n', '    uint8  constant percentOfFixedPrizeWinners = 20;   // 20%\n', '\n', '    uint8  constant gameCommision              = 0;   // 0%\n', '    uint8  constant bonusGameCommision         = 0;   // 0%\n', '    uint8  constant tokenHolerGameCommision    = 0;    // 0%\n', '    // End Calculation constants\n', '\n', '    event Debug(uint);\n', '\n', '    function getPrizeAmount(uint totalAmount)\n', '        public\n', '        pure\n', '        returns (uint result)\n', '    {\n', '        uint totalCommision = gameCommision\n', '                            + bonusGameCommision\n', '                            + tokenHolerGameCommision;\n', '\n', '        //Calculation is odd on purpose.  It is a sort of ceiling effect to\n', '        // maximize amount of prize\n', '        result = ( totalAmount - ( ( totalAmount * totalCommision) / 100) );\n', '\n', '        return result;\n', '    }\n', '\n', '    function getNumWinners(uint numPlayers)\n', '        public\n', '        pure\n', '        returns (uint16 numWinners, uint16 numFixedAmountWinners)\n', '    {\n', '        // Calculation is odd on purpose. It is a sort of ceiling effect to\n', '        // maximize number of winners\n', '        uint16 totaNumlWinners = uint16( numPlayers - ( (numPlayers * ( 100 - percentOfWinners ) ) / 100 ) );\n', '\n', '\n', '        numFixedAmountWinners = uint16( (totaNumlWinners * percentOfFixedPrizeWinners) / 100 );\n', '        numWinners = uint16( totaNumlWinners - numFixedAmountWinners );\n', '\n', '        return (numWinners, numFixedAmountWinners);\n', '    }\n', '\n', '    function calcaultePrizes(uint bet, uint numPlayers)\n', '        public\n', '        pure\n', '        returns (uint[50] memory prizes)\n', '    {\n', '        var (numWinners, numFixedAmountWinners) = getNumWinners(numPlayers);\n', '\n', '        require( uint(numWinners + numFixedAmountWinners) <= prizes.length );\n', '\n', '        uint[] memory y = new uint[]((numWinners - 1));\n', '        uint z = 0; // Sum of all Y values\n', '\n', '        if ( numWinners == 1 ) {\n', '            prizes[0] = getPrizeAmount(uint(bet*numPlayers));\n', '\n', '            return prizes;\n', '        } else if ( numWinners < 1 ) {\n', '            return prizes;\n', '        }\n', '\n', '        for (uint i = 0; i < y.length; i++) {\n', '            y[i] = formula( (calculateStep(numWinners) * i) );\n', '            z += y[i];\n', '        }\n', '\n', '        bool stop = false;\n', '\n', '        for (i = 0; i < 10; i++) {\n', '            uint[5] memory chunk = distributePrizeCalculation(\n', '                i, z, y, numPlayers, bet);\n', '\n', '            for ( uint j = 0; j < chunk.length; j++ ) {\n', '                if ( ( (i * chunk.length) + j ) >= ( numWinners + numFixedAmountWinners ) ) {\n', '                    stop = true;\n', '                    break;\n', '                }\n', '\n', '                prizes[ (i * chunk.length) + j ] = chunk[j];\n', '            }\n', '\n', '            if ( stop ) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        return prizes;\n', '    }\n', '\n', '    function distributePrizeCalculation (uint chunkNumber, uint z, uint[] memory y, uint totalNumPlayers, uint bet)\n', '        private\n', '        pure\n', '        returns (uint[5] memory prizes)\n', '    {\n', '        var(numWinners, numFixedAmountWinners) = getNumWinners(totalNumPlayers);\n', '        uint prizeAmountForDeligation = getPrizeAmount( (totalNumPlayers * bet) );\n', '        prizeAmountForDeligation -= uint( ( bet * minPrizeCoeficent ) * uint( numWinners + numFixedAmountWinners ) );\n', '\n', '        uint mainWinnerBaseAmount = ( (prizeAmountForDeligation * accuracy) / ( ( ( z * accuracy ) / ( 2 * y[0] ) ) + ( 1 * accuracy ) ) );\n', '        uint undeligatedAmount    = prizeAmountForDeligation;\n', '\n', '        uint startPoint = chunkNumber * prizes.length;\n', '\n', '        for ( uint i = 0; i < prizes.length; i++ ) {\n', '            if ( i >= uint(numWinners + numFixedAmountWinners) ) {\n', '                break;\n', '            }\n', '            prizes[ i ] = (bet * minPrizeCoeficent);\n', '            uint extraPrize = 0;\n', '\n', '            if ( i == ( numWinners - 1 ) ) {\n', '                extraPrize = undeligatedAmount;\n', '            } else if ( i == 0 && chunkNumber == 0 ) {\n', '                extraPrize = mainWinnerBaseAmount;\n', '            } else if ( ( startPoint + i ) < numWinners ) {\n', '                extraPrize = ( ( y[ ( startPoint + i ) - 1 ] * (prizeAmountForDeligation - mainWinnerBaseAmount) ) / z);\n', '            }\n', '\n', '            prizes[ i ] += extraPrize;\n', '            undeligatedAmount -= extraPrize;\n', '        }\n', '\n', '        return prizes;\n', '    }\n', '\n', '    function formula(uint x)\n', '        public\n', '        pure\n', '        returns (uint y)\n', '    {\n', '        y = ( (1 * accuracy**2) / (x + (5*accuracy/10))) - ((5 * accuracy) / 100);\n', '\n', '        return y;\n', '    }\n', '\n', '    function calculateStep(uint numWinners)\n', '        public\n', '        pure\n', '        returns(uint step)\n', '    {\n', '        step = ( MAX_X_FOR_Y * accuracy / 10 ) / numWinners;\n', '\n', '        return step;\n', '    }\n', '}']