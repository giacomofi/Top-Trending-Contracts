['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '\n', '/******* USING MONARCHYCONTROLLER **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getMonarchyController(): returns current IMC instance\n', '    [modifier] .fromMonarchyController(): requires the sender is current MC.\n', '\n', '*************************************************/\n', '// Returned by .getMonarchyController()\n', 'interface IMonarchyController {\n', '    function refreshGames() external returns (uint _numGamesEnded, uint _feesSent);\n', '    function startDefinedGame(uint _index) external payable returns (address _game);\n', '    function getFirstStartableIndex() external view returns (uint _index);\n', '    function getNumEndableGames() external view returns (uint _count);\n', '    function getAvailableFees() external view returns (uint _feesAvailable);\n', '    function getInitialPrize(uint _index) external view returns (uint);\n', '    function getIsStartable(uint _index) external view returns (bool);\n', '}\n', '\n', 'contract UsingMonarchyController is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromMonarchyController(){\n', '        require(msg.sender == address(getMonarchyController()));\n', '        _;\n', '    }\n', '\n', '    function getMonarchyController()\n', '        public\n', '        view\n', '        returns (IMonarchyController)\n', '    {\n', '        return IMonarchyController(addressOf("MONARCHY_CONTROLLER"));\n', '    }\n', '}\n', '\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '/*\n', '    Exposes the following internal methods:\n', '        - _useFromDailyLimit(uint)\n', '        - _setDailyLimit(uint)\n', '        - getDailyLimit()\n', '        - getDailyLimitUsed()\n', '        - getDailyLimitUnused()\n', '*/\n', 'contract HasDailyLimit {\n', '    // squeeze all vars into one storage slot.\n', '    struct DailyLimitVars {\n', '        uint112 dailyLimit; // Up to 5e15 * 1e18.\n', '        uint112 usedToday;  // Up to 5e15 * 1e18.\n', '        uint32 lastDay;     // Up to the year 11,000,000 AD\n', '    }\n', '    DailyLimitVars private vars;\n', '    uint constant MAX_ALLOWED = 2**112 - 1;\n', '\n', '    constructor(uint _limit) public {\n', '        _setDailyLimit(_limit);\n', '    }\n', '\n', '    // Sets the daily limit.\n', '    function _setDailyLimit(uint _limit) internal {\n', '        require(_limit <= MAX_ALLOWED);\n', '        vars.dailyLimit = uint112(_limit);\n', '    }\n', '\n', '    // Uses the requested amount if its within limit. Or throws.\n', '    // You should use getDailyLimitRemaining() before calling this.\n', '    function _useFromDailyLimit(uint _amount) internal {\n', '        uint _remaining = updateAndGetRemaining();\n', '        require(_amount <= _remaining);\n', '        vars.usedToday += uint112(_amount);\n', '    }\n', '\n', '    // If necessary, resets the day&#39;s usage.\n', '    // Then returns the amount remaining for today.\n', '    function updateAndGetRemaining() private returns (uint _amtRemaining) {\n', '        if (today() > vars.lastDay) {\n', '            vars.usedToday = 0;\n', '            vars.lastDay = today();\n', '        }\n', '        uint112 _usedToday = vars.usedToday;\n', '        uint112 _dailyLimit = vars.dailyLimit;\n', '        // This could be negative if _dailyLimit was reduced.\n', '        return uint(_usedToday >= _dailyLimit ? 0 : _dailyLimit - _usedToday);\n', '    }\n', '\n', '    // Returns the current day.\n', '    function today() private view returns (uint32) {\n', '        return uint32(block.timestamp / 1 days);\n', '    }\n', '\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    ////////////// PUBLIC VIEWS /////////////////////////////////////\n', '    /////////////////////////////////////////////////////////////////\n', '\n', '    function getDailyLimit() public view returns (uint) {\n', '        return uint(vars.dailyLimit);\n', '    }\n', '    function getDailyLimitUsed() public view returns (uint) {\n', '        return uint(today() > vars.lastDay ? 0 : vars.usedToday);\n', '    }\n', '    function getDailyLimitRemaining() public view returns (uint) {\n', '        uint _used = getDailyLimitUsed();\n', '        return uint(_used >= vars.dailyLimit ? 0 : vars.dailyLimit - _used);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If it doesn&#39;t exist already, there is nothing to do.\n', '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', '    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it&#39;s safe to\n', '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '/*\n', '  This is a simple class that pays anybody to execute methods on\n', '  other contracts. The reward amounts are configurable by the Admin,\n', '  with some hard limits to prevent the Admin from pilfering. The\n', '  contract has a DailyLimit, so even if the Admin is compromised,\n', '  the contract cannot be drained.\n', '\n', '  TaskManager is Bankrollable, meaning it can accept bankroll from \n', '  the Treasury (and have it recalled).  However, it will never generate\n', '  profits. On rare occasion, new funds will need to be added to ensure\n', '  rewards can be paid.\n', '\n', '  This class is divided into sections that pay rewards for a specific\n', '  contract or set of contracts. Any time a new contract is added to\n', '  the system that requires Tasks, this file will be updated and \n', '  redeployed.\n', '*/\n', 'interface _IBankrollable {\n', '    function sendProfits() external returns (uint _profits);\n', '    function profits() external view returns (int _profits);\n', '}\n', 'contract TaskManager is\n', '    HasDailyLimit,\n', '    Bankrollable,\n', '    UsingAdmin,\n', '    UsingMonarchyController\n', '{\n', '    uint constant public version = 1;\n', '    uint public totalRewarded;\n', '\n', '    // Number of basis points to reward caller.\n', '    // 1 = .01%, 10 = .1%, 100 = 1%. Capped at .1%.\n', '    uint public issueDividendRewardBips;\n', '    // Number of basis points to reward caller.\n', '    // 1 = .01%, 10 = .1%, 100 = 1%. Capped at 1%.\n', '    uint public sendProfitsRewardBips;\n', '    // How much to pay for games to start and end.\n', '    // These values are capped at 1 Ether.\n', '    uint public monarchyStartReward;\n', '    uint public monarchyEndReward;\n', '    \n', '    event Created(uint time);\n', '    event DailyLimitChanged(uint time, address indexed owner, uint newValue);\n', '    // admin events\n', '    event IssueDividendRewardChanged(uint time, address indexed admin, uint newValue);\n', '    event SendProfitsRewardChanged(uint time, address indexed admin, uint newValue);\n', '    event MonarchyRewardsChanged(uint time, address indexed admin, uint startReward, uint endReward);\n', '    // base events\n', '    event TaskError(uint time, address indexed caller, string msg);\n', '    event RewardSuccess(uint time, address indexed caller, uint reward);\n', '    event RewardFailure(uint time, address indexed caller, uint reward, string msg);\n', '    // task events\n', '    event IssueDividendSuccess(uint time, address indexed treasury, uint profitsSent);\n', '    event SendProfitsSuccess(uint time, address indexed bankrollable, uint profitsSent);\n', '    event MonarchyGameStarted(uint time, address indexed addr, uint initialPrize);\n', '    event MonarchyGamesRefreshed(uint time, uint numEnded, uint feesCollected);\n', '\n', '    // Construct sets the registry and instantiates inherited classes.\n', '    constructor(address _registry)\n', '        public\n', '        HasDailyLimit(1 ether)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        UsingMonarchyController(_registry)\n', '    {\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// OWNER FUNCTIONS ////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function setDailyLimit(uint _amount)\n', '        public\n', '        fromOwner\n', '    {\n', '        _setDailyLimit(_amount);\n', '        emit DailyLimitChanged(now, msg.sender, _amount);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// ADMIN FUNCTIONS ////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function setIssueDividendReward(uint _bips)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_bips <= 10);\n', '        issueDividendRewardBips = _bips;\n', '        emit IssueDividendRewardChanged(now, msg.sender, _bips);\n', '    }\n', '\n', '    function setSendProfitsReward(uint _bips)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_bips <= 100);\n', '        sendProfitsRewardBips = _bips;\n', '        emit SendProfitsRewardChanged(now, msg.sender, _bips);\n', '    }\n', '\n', '    function setMonarchyRewards(uint _startReward, uint _endReward)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_startReward <= 1 ether);\n', '        require(_endReward <= 1 ether);\n', '        monarchyStartReward = _startReward;\n', '        monarchyEndReward = _endReward;\n', '        emit MonarchyRewardsChanged(now, msg.sender, _startReward, _endReward);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// ISSUE DIVIDEND TASK ////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function doIssueDividend()\n', '        public\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        // get amount of profits\n', '        ITreasury _tr = getTreasury();\n', '        _profits = _tr.profitsSendable();\n', '        // quit if no profits to send.\n', '        if (_profits == 0) {\n', '            _taskError("No profits to send.");\n', '            return;\n', '        }\n', '        // call .issueDividend(), use return value to compute _reward\n', '        _profits = _tr.issueDividend();\n', '        if (_profits == 0) {\n', '            _taskError("No profits were sent.");\n', '            return;\n', '        } else {\n', '            emit IssueDividendSuccess(now, address(_tr), _profits);\n', '        }\n', '        // send reward\n', '        _reward = (_profits * issueDividendRewardBips) / 10000;\n', '        _sendReward(_reward);\n', '    }\n', '\n', '    // Returns reward and profits\n', '    function issueDividendReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        _profits = getTreasury().profitsSendable();\n', '        _reward = _cappedReward((_profits * issueDividendRewardBips) / 10000);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// SEND PROFITS TASKS /////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function doSendProfits(address _bankrollable)\n', '        public\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        // Call .sendProfits(). Look for Treasury balance to change.\n', '        ITreasury _tr = getTreasury();\n', '        uint _oldTrBalance = address(_tr).balance;\n', '        _IBankrollable(_bankrollable).sendProfits();\n', '        uint _newTrBalance = address(_tr).balance;\n', '\n', '        // Quit if no profits. Otherwise compute profits.\n', '        if (_newTrBalance <= _oldTrBalance) {\n', '            _taskError("No profits were sent.");\n', '            return;\n', '        } else {\n', '            _profits = _newTrBalance - _oldTrBalance;\n', '            emit SendProfitsSuccess(now, _bankrollable, _profits);\n', '        }\n', '        \n', '        // Cap reward to current balance (or send will fail)\n', '        _reward = (_profits * sendProfitsRewardBips) / 10000;\n', '        _sendReward(_reward);\n', '    }\n', '\n', '    // Returns an estimate of profits to send, and reward.\n', '    function sendProfitsReward(address _bankrollable)\n', '        public\n', '        view\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        int _p = _IBankrollable(_bankrollable).profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        _reward = _cappedReward((_profits * sendProfitsRewardBips) / 10000);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// MONARCHY TASKS /////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    // Try to start monarchy game, reward upon success.\n', '    function startMonarchyGame(uint _index)\n', '        public\n', '    {\n', '        // Don&#39;t bother trying if it&#39;s not startable\n', '        IMonarchyController _mc = getMonarchyController();\n', '        if (!_mc.getIsStartable(_index)){\n', '            _taskError("Game is not currently startable.");\n', '            return;\n', '        }\n', '\n', '        // Try to start the game. This may fail.\n', '        address _game = _mc.startDefinedGame(_index);\n', '        if (_game == address(0)) {\n', '            _taskError("MonarchyConroller.startDefinedGame() failed.");\n', '            return;\n', '        } else {\n', '            emit MonarchyGameStarted(now, _game, _mc.getInitialPrize(_index));   \n', '        }\n', '\n', '        // Reward\n', '        _sendReward(monarchyStartReward);\n', '    }\n', '\n', '    // Return the _reward and _index of the first startable MonarchyGame\n', '    function startMonarchyGameReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _index)\n', '    {\n', '        IMonarchyController _mc = getMonarchyController();\n', '        _index = _mc.getFirstStartableIndex();\n', '        if (_index > 0) _reward = _cappedReward(monarchyStartReward);\n', '    }\n', '\n', '\n', '    // Invoke .refreshGames() and pay reward on number of games ended.\n', '    function refreshMonarchyGames()\n', '        public\n', '    {\n', '        // do the call\n', '        uint _numGamesEnded;\n', '        uint _feesCollected;\n', '        (_numGamesEnded, _feesCollected) = getMonarchyController().refreshGames();\n', '        emit MonarchyGamesRefreshed(now, _numGamesEnded, _feesCollected);\n', '\n', '        if (_numGamesEnded == 0) {\n', '            _taskError("No games ended.");\n', '        } else {\n', '            _sendReward(_numGamesEnded * monarchyEndReward);   \n', '        }\n', '    }\n', '    \n', '    // Return a reward for each MonarchyGame that will end\n', '    function refreshMonarchyGamesReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _numEndable)\n', '    {\n', '        IMonarchyController _mc = getMonarchyController();\n', '        _numEndable = _mc.getNumEndableGames();\n', '        _reward = _cappedReward(_numEndable * monarchyEndReward);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    /////////////////// PRIVATE FUNCTIONS /////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////////\n', '\n', '    // Called when task is unable to execute.\n', '    function _taskError(string _msg) private {\n', '        emit TaskError(now, msg.sender, _msg);\n', '    }\n', '\n', '    // Sends a capped amount of _reward to the msg.sender, and emits proper event.\n', '    function _sendReward(uint _reward) private {\n', '        // Limit the reward to balance or dailyLimitRemaining\n', '        uint _amount = _cappedReward(_reward);\n', '        if (_reward > 0 && _amount == 0) {\n', '            emit RewardFailure(now, msg.sender, _amount, "Not enough funds, or daily limit reached.");\n', '            return;\n', '        }\n', '\n', '        // Attempt to send it (even if _reward was 0)\n', '        if (msg.sender.call.value(_amount)()) {\n', '            _useFromDailyLimit(_amount);\n', '            totalRewarded += _amount;\n', '            emit RewardSuccess(now, msg.sender, _amount);\n', '        } else {\n', '            emit RewardFailure(now, msg.sender, _amount, "Reward rejected by recipient (out of gas, or revert).");\n', '        }\n', '    }\n', '\n', '    // This caps the reward amount to the minimum of (reward, balance, dailyLimitRemaining)\n', '    function _cappedReward(uint _reward) private view returns (uint) {\n', '        uint _balance = address(this).balance;\n', '        uint _remaining = getDailyLimitRemaining();\n', '        if (_reward > _balance) _reward = _balance;\n', '        if (_reward > _remaining) _reward = _remaining;\n', '        return _reward;\n', '    }\n', '\n', '    // IMPLEMENT BANKROLLABLE FUNCTIONS\n', '    function getCollateral() public view returns (uint) {}\n', '    function getWhitelistOwner() public view returns (address){ return getAdmin(); }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/******* USING Registry **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .addressOf(bytes32): returns current address mapped to the name.\n', '    [modifier] .fromOwner(): requires the sender is owner.\n', '\n', '*************************************************/\n', '// Returned by .getRegistry()\n', 'interface IRegistry {\n', '    function owner() external view returns (address _addr);\n', '    function addressOf(bytes32 _name) external view returns (address _addr);\n', '}\n', '\n', 'contract UsingRegistry {\n', '    IRegistry private registry;\n', '\n', '    modifier fromOwner(){\n', '        require(msg.sender == getOwner());\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry)\n', '        public\n', '    {\n', '        require(_registry != 0);\n', '        registry = IRegistry(_registry);\n', '    }\n', '\n', '    function addressOf(bytes32 _name)\n', '        internal\n', '        view\n', '        returns(address _addr)\n', '    {\n', '        return registry.addressOf(_name);\n', '    }\n', '\n', '    function getOwner()\n', '        public\n', '        view\n', '        returns (address _addr)\n', '    {\n', '        return registry.owner();\n', '    }\n', '\n', '    function getRegistry()\n', '        public\n', '        view\n', '        returns (IRegistry _addr)\n', '    {\n', '        return registry;\n', '    }\n', '}\n', '\n', '/******* USING ADMIN ***********************\n', '\n', 'Gives the inherting contract access to:\n', '    .getAdmin(): returns the current address of the admin\n', '    [modifier] .fromAdmin: requires the sender is the admin\n', '\n', '*************************************************/\n', 'contract UsingAdmin is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromAdmin(){\n', '        require(msg.sender == getAdmin());\n', '        _;\n', '    }\n', '    \n', '    function getAdmin()\n', '        public\n', '        constant\n', '        returns (address _addr)\n', '    {\n', '        return addressOf("ADMIN");\n', '    }\n', '}\n', '\n', '\n', '/******* USING MONARCHYCONTROLLER **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getMonarchyController(): returns current IMC instance\n', '    [modifier] .fromMonarchyController(): requires the sender is current MC.\n', '\n', '*************************************************/\n', '// Returned by .getMonarchyController()\n', 'interface IMonarchyController {\n', '    function refreshGames() external returns (uint _numGamesEnded, uint _feesSent);\n', '    function startDefinedGame(uint _index) external payable returns (address _game);\n', '    function getFirstStartableIndex() external view returns (uint _index);\n', '    function getNumEndableGames() external view returns (uint _count);\n', '    function getAvailableFees() external view returns (uint _feesAvailable);\n', '    function getInitialPrize(uint _index) external view returns (uint);\n', '    function getIsStartable(uint _index) external view returns (bool);\n', '}\n', '\n', 'contract UsingMonarchyController is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromMonarchyController(){\n', '        require(msg.sender == address(getMonarchyController()));\n', '        _;\n', '    }\n', '\n', '    function getMonarchyController()\n', '        public\n', '        view\n', '        returns (IMonarchyController)\n', '    {\n', '        return IMonarchyController(addressOf("MONARCHY_CONTROLLER"));\n', '    }\n', '}\n', '\n', '\n', '/******* USING TREASURY **************************\n', '\n', 'Gives the inherting contract access to:\n', '    .getTreasury(): returns current ITreasury instance\n', '    [modifier] .fromTreasury(): requires the sender is current Treasury\n', '\n', '*************************************************/\n', '// Returned by .getTreasury()\n', 'interface ITreasury {\n', '    function issueDividend() external returns (uint _profits);\n', '    function profitsSendable() external view returns (uint _profits);\n', '}\n', '\n', 'contract UsingTreasury is\n', '    UsingRegistry\n', '{\n', '    constructor(address _registry)\n', '        UsingRegistry(_registry)\n', '        public\n', '    {}\n', '\n', '    modifier fromTreasury(){\n', '        require(msg.sender == address(getTreasury()));\n', '        _;\n', '    }\n', '    \n', '    function getTreasury()\n', '        public\n', '        view\n', '        returns (ITreasury)\n', '    {\n', '        return ITreasury(addressOf("TREASURY"));\n', '    }\n', '}\n', '\n', '/*\n', '    Exposes the following internal methods:\n', '        - _useFromDailyLimit(uint)\n', '        - _setDailyLimit(uint)\n', '        - getDailyLimit()\n', '        - getDailyLimitUsed()\n', '        - getDailyLimitUnused()\n', '*/\n', 'contract HasDailyLimit {\n', '    // squeeze all vars into one storage slot.\n', '    struct DailyLimitVars {\n', '        uint112 dailyLimit; // Up to 5e15 * 1e18.\n', '        uint112 usedToday;  // Up to 5e15 * 1e18.\n', '        uint32 lastDay;     // Up to the year 11,000,000 AD\n', '    }\n', '    DailyLimitVars private vars;\n', '    uint constant MAX_ALLOWED = 2**112 - 1;\n', '\n', '    constructor(uint _limit) public {\n', '        _setDailyLimit(_limit);\n', '    }\n', '\n', '    // Sets the daily limit.\n', '    function _setDailyLimit(uint _limit) internal {\n', '        require(_limit <= MAX_ALLOWED);\n', '        vars.dailyLimit = uint112(_limit);\n', '    }\n', '\n', '    // Uses the requested amount if its within limit. Or throws.\n', '    // You should use getDailyLimitRemaining() before calling this.\n', '    function _useFromDailyLimit(uint _amount) internal {\n', '        uint _remaining = updateAndGetRemaining();\n', '        require(_amount <= _remaining);\n', '        vars.usedToday += uint112(_amount);\n', '    }\n', '\n', "    // If necessary, resets the day's usage.\n", '    // Then returns the amount remaining for today.\n', '    function updateAndGetRemaining() private returns (uint _amtRemaining) {\n', '        if (today() > vars.lastDay) {\n', '            vars.usedToday = 0;\n', '            vars.lastDay = today();\n', '        }\n', '        uint112 _usedToday = vars.usedToday;\n', '        uint112 _dailyLimit = vars.dailyLimit;\n', '        // This could be negative if _dailyLimit was reduced.\n', '        return uint(_usedToday >= _dailyLimit ? 0 : _dailyLimit - _usedToday);\n', '    }\n', '\n', '    // Returns the current day.\n', '    function today() private view returns (uint32) {\n', '        return uint32(block.timestamp / 1 days);\n', '    }\n', '\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    ////////////// PUBLIC VIEWS /////////////////////////////////////\n', '    /////////////////////////////////////////////////////////////////\n', '\n', '    function getDailyLimit() public view returns (uint) {\n', '        return uint(vars.dailyLimit);\n', '    }\n', '    function getDailyLimitUsed() public view returns (uint) {\n', '        return uint(today() > vars.lastDay ? 0 : vars.usedToday);\n', '    }\n', '    function getDailyLimitRemaining() public view returns (uint) {\n', '        uint _used = getDailyLimitUsed();\n', '        return uint(_used >= vars.dailyLimit ? 0 : vars.dailyLimit - _used);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    addresses it has seen. Addresses can be added and removed\n', '    from the set, and a full list of addresses can be obtained.\n', '\n', '    Methods:\n', '     - [fromOwner] .add()\n', '     - [fromOwner] .remove()\n', '    Views:\n', '     - .size()\n', '     - .has()\n', '     - .addresses()\n', '*/\n', 'contract AddressSet {\n', '    \n', '    struct Entry {  // Doubly linked list\n', '        bool exists;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner.\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didCreate)\n', '    {\n', '        // Do not allow the adding of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', '        // If already exists, do nothing. Otherwise set it.\n', '        if (entry.exists) return;\n', '        else entry.exists = true;\n', '\n', '        // Replace first entry with this one.\n', '        // Before: HEAD <-> X <-> Y\n', '        // After: HEAD <-> THIS <-> X <-> Y\n', '        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\n', '        Entry storage HEAD = entries[0x0];\n', '        entry.next = HEAD.next;\n', '        entries[HEAD.next].prev = _address;\n', '        HEAD.next = _address;\n', '        return true;\n', '    }\n', '\n', '    function remove(address _address)\n', '        fromOwner\n', '        public\n', '        returns (bool _didExist)\n', '    {\n', '        // Do not allow the removal of HEAD.\n', '        if (_address == address(0)) return;\n', '        Entry storage entry = entries[_address];\n', "        // If it doesn't exist already, there is nothing to do.\n", '        if (!entry.exists) return;\n', '\n', '        // Stitch together next and prev, delete entry.\n', '        // Before: X <-> THIS <-> Y\n', '        // After: X <-> Y\n', '        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\n', '        entries[entry.prev].next = entry.next;\n', '        entries[entry.next].prev = entry.prev;\n', '        delete entries[_address];\n', '        return true;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function has(address _address)\n', '        public\n', '        view\n', '        returns (bool _exists)\n', '    {\n', '        return entries[_address].exists;\n', '    }\n', '\n', '    function addresses()\n', '        public\n', '        view\n', '        returns (address[] _addresses)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        // Iterate forward through all entries until the end.\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return _addresses;\n', '    }\n', '}\n', '\n', '/**\n', '    This is a simple class that maintains a doubly linked list of\n', '    address => uint amounts. Address balances can be added to \n', '    or removed from via add() and subtract(). All balances can\n', '    be obtain by calling balances(). If an address has a 0 amount,\n', '    it is removed from the Ledger.\n', '\n', "    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\n", '          use to track Ether balances.\n', '\n', '    Public methods:\n', '      - [fromOwner] add()\n', '      - [fromOwner] subtract()\n', '    Public views:\n', '      - total()\n', '      - size()\n', '      - balanceOf()\n', '      - balances()\n', '      - entries() [to manually iterate]\n', '*/\n', 'contract Ledger {\n', '    uint public total;      // Total amount in Ledger\n', '\n', '    struct Entry {          // Doubly linked list tracks amount per address\n', '        uint balance;\n', '        address next;\n', '        address prev;\n', '    }\n', '    mapping (address => Entry) public entries;\n', '\n', '    address public owner;\n', '    modifier fromOwner() { require(msg.sender==owner); _; }\n', '\n', '    // Constructor sets the owner\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** OWNER METHODS ************************/\n', '    /******************************************************/\n', '\n', '    function add(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        // If new entry, replace first entry with this one.\n', '        if (entry.balance == 0) {\n', '            entry.next = entries[0x0].next;\n', '            entries[entries[0x0].next].prev = _address;\n', '            entries[0x0].next = _address;\n', '        }\n', '        // Update stats.\n', '        total += _amt;\n', '        entry.balance += _amt;\n', '    }\n', '\n', '    function subtract(address _address, uint _amt)\n', '        fromOwner\n', '        public\n', '        returns (uint _amtRemoved)\n', '    {\n', '        if (_address == address(0) || _amt == 0) return;\n', '        Entry storage entry = entries[_address];\n', '\n', '        uint _maxAmt = entry.balance;\n', '        if (_maxAmt == 0) return;\n', '        \n', '        if (_amt >= _maxAmt) {\n', '            // Subtract the max amount, and delete entry.\n', '            total -= _maxAmt;\n', '            entries[entry.prev].next = entry.next;\n', '            entries[entry.next].prev = entry.prev;\n', '            delete entries[_address];\n', '            return _maxAmt;\n', '        } else {\n', '            // Subtract the amount from entry.\n', '            total -= _amt;\n', '            entry.balance -= _amt;\n', '            return _amt;\n', '        }\n', '    }\n', '\n', '\n', '    /******************************************************/\n', '    /*************** PUBLIC VIEWS *************************/\n', '    /******************************************************/\n', '\n', '    function size()\n', '        public\n', '        view\n', '        returns (uint _size)\n', '    {\n', '        // Loop once to get the total count.\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _curEntry = entries[_curEntry.next];\n', '            _size++;\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    function balanceOf(address _address)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return entries[_address].balance;\n', '    }\n', '\n', '    function balances()\n', '        public\n', '        view\n', '        returns (address[] _addresses, uint[] _balances)\n', '    {\n', '        // Populate names and addresses\n', '        uint _size = size();\n', '        _addresses = new address[](_size);\n', '        _balances = new uint[](_size);\n', '        uint _i = 0;\n', '        Entry memory _curEntry = entries[0x0];\n', '        while (_curEntry.next > 0) {\n', '            _addresses[_i] = _curEntry.next;\n', '            _balances[_i] = entries[_curEntry.next].balance;\n', '            _curEntry = entries[_curEntry.next];\n', '            _i++;\n', '        }\n', '        return (_addresses, _balances);\n', '    }\n', '}\n', '\n', '/**\n', '  A simple class that manages bankroll, and maintains collateral.\n', '  This class only ever sends profits the Treasury. No exceptions.\n', '\n', '  - Anybody can add funding (according to whitelist)\n', '  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\n', '  - Anyone can remove their funding, so long as balance >= collateral.\n', '  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\n', '\n', '  Exposes the following:\n', '    Public Methods\n', '     - addBankroll\n', '     - removeBankroll\n', '     - sendProfits\n', '    Public Views\n', '     - getCollateral\n', '     - profits\n', '     - profitsSent\n', '     - profitsTotal\n', '     - bankroll\n', '     - bankrollAvailable\n', '     - bankrolledBy\n', '     - bankrollerTable\n', '*/\n', 'contract Bankrollable is\n', '    UsingTreasury\n', '{   \n', '    // How much profits have been sent. \n', '    uint public profitsSent;\n', '    // Ledger keeps track of who has bankrolled us, and for how much\n', '    Ledger public ledger;\n', '    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\n', '    uint public bankroll;\n', '    // This is the whitelist of who can call .addBankroll()\n', '    AddressSet public whitelist;\n', '\n', '    modifier fromWhitelistOwner(){\n', '        require(msg.sender == getWhitelistOwner());\n', '        _;\n', '    }\n', '\n', '    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\n', '    event ProfitsSent(uint time, address indexed treasury, uint amount);\n', '    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\n', '\n', '    // Constructor creates the ledger and whitelist, with self as owner.\n', '    constructor(address _registry)\n', '        UsingTreasury(_registry)\n', '        public\n', '    {\n', '        ledger = new Ledger(this);\n', '        whitelist = new AddressSet(this);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** WHITELIST MGMT ***********************/\n', '    /*****************************************************/    \n', '\n', '    function addToWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didAdd = whitelist.add(_addr);\n', '        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    function removeFromWhitelist(address _addr)\n', '        fromWhitelistOwner\n', '        public\n', '    {\n', '        bool _didRemove = whitelist.remove(_addr);\n', '        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\n', '    }\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC FUNCTIONS *********************/\n', '    /*****************************************************/\n', '\n', '    // Bankrollable contracts should be payable (to receive revenue)\n', '    function () public payable {}\n', '\n', '    // Increase funding by whatever value is sent\n', '    function addBankroll()\n', '        public\n', '        payable \n', '    {\n', '        require(whitelist.size()==0 || whitelist.has(msg.sender));\n', '        ledger.add(msg.sender, msg.value);\n', '        bankroll = ledger.total();\n', '        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\n', '    }\n', '\n', '    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\n', '    function removeBankroll(uint _amount, string _callbackFn)\n', '        public\n', '        returns (uint _recalled)\n', '    {\n', '        // cap amount at the balance minus collateral, or nothing at all.\n', '        address _bankroller = msg.sender;\n', '        uint _collateral = getCollateral();\n', '        uint _balance = address(this).balance;\n', '        uint _available = _balance > _collateral ? _balance - _collateral : 0;\n', '        if (_amount > _available) _amount = _available;\n', '\n', '        // Try to remove _amount from ledger, get actual _amount removed.\n', '        _amount = ledger.subtract(_bankroller, _amount);\n', '        bankroll = ledger.total();\n', '        if (_amount == 0) return;\n', '\n', '        bytes4 _sig = bytes4(keccak256(_callbackFn));\n', '        require(_bankroller.call.value(_amount)(_sig));\n', '        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\n', '        return _amount;\n', '    }\n', '\n', '    // Send any excess profits to treasury.\n', '    function sendProfits()\n', '        public\n', '        returns (uint _profits)\n', '    {\n', '        int _p = profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        profitsSent += _profits;\n', '        // Send profits to Treasury\n', '        address _tr = getTreasury();\n', '        require(_tr.call.value(_profits)());\n', '        emit ProfitsSent(now, _tr, _profits);\n', '    }\n', '\n', '\n', '    /*****************************************************/\n', '    /************** PUBLIC VIEWS *************************/\n', '    /*****************************************************/\n', '\n', '    // Function must be overridden by inheritors to ensure collateral is kept.\n', '    function getCollateral()\n', '        public\n', '        view\n', '        returns (uint _amount);\n', '\n', '    // Function must be overridden by inheritors to enable whitelist control.\n', '    function getWhitelistOwner()\n', '        public\n', '        view\n', '        returns (address _addr);\n', '\n', '    // Profits are the difference between balance and threshold\n', '    function profits()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        int _balance = int(address(this).balance);\n', '        int _threshold = int(bankroll + getCollateral());\n', '        return _balance - _threshold;\n', '    }\n', '\n', '    // How profitable this contract is, overall\n', '    function profitsTotal()\n', '        public\n', '        view\n', '        returns (int _profits)\n', '    {\n', '        return int(profitsSent) + profits();\n', '    }\n', '\n', '    // Returns the amount that can currently be bankrolled.\n', '    //   - 0 if balance < collateral\n', '    //   - If profits: full bankroll\n', '    //   - If no profits: remaning bankroll: balance - collateral\n', '    function bankrollAvailable()\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        uint _balance = address(this).balance;\n', '        uint _bankroll = bankroll;\n', '        uint _collat = getCollateral();\n', '        // Balance is below collateral!\n', '        if (_balance <= _collat) return 0;\n', '        // No profits, but we have a balance over collateral.\n', '        else if (_balance < _collat + _bankroll) return _balance - _collat;\n', '        // Profits. Return only _bankroll\n', '        else return _bankroll;\n', '    }\n', '\n', '    function bankrolledBy(address _addr)\n', '        public\n', '        view\n', '        returns (uint _amount)\n', '    {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '\n', '    function bankrollerTable()\n', '        public\n', '        view\n', '        returns (address[], uint[])\n', '    {\n', '        return ledger.balances();\n', '    }\n', '}\n', '\n', '/*\n', '  This is a simple class that pays anybody to execute methods on\n', '  other contracts. The reward amounts are configurable by the Admin,\n', '  with some hard limits to prevent the Admin from pilfering. The\n', '  contract has a DailyLimit, so even if the Admin is compromised,\n', '  the contract cannot be drained.\n', '\n', '  TaskManager is Bankrollable, meaning it can accept bankroll from \n', '  the Treasury (and have it recalled).  However, it will never generate\n', '  profits. On rare occasion, new funds will need to be added to ensure\n', '  rewards can be paid.\n', '\n', '  This class is divided into sections that pay rewards for a specific\n', '  contract or set of contracts. Any time a new contract is added to\n', '  the system that requires Tasks, this file will be updated and \n', '  redeployed.\n', '*/\n', 'interface _IBankrollable {\n', '    function sendProfits() external returns (uint _profits);\n', '    function profits() external view returns (int _profits);\n', '}\n', 'contract TaskManager is\n', '    HasDailyLimit,\n', '    Bankrollable,\n', '    UsingAdmin,\n', '    UsingMonarchyController\n', '{\n', '    uint constant public version = 1;\n', '    uint public totalRewarded;\n', '\n', '    // Number of basis points to reward caller.\n', '    // 1 = .01%, 10 = .1%, 100 = 1%. Capped at .1%.\n', '    uint public issueDividendRewardBips;\n', '    // Number of basis points to reward caller.\n', '    // 1 = .01%, 10 = .1%, 100 = 1%. Capped at 1%.\n', '    uint public sendProfitsRewardBips;\n', '    // How much to pay for games to start and end.\n', '    // These values are capped at 1 Ether.\n', '    uint public monarchyStartReward;\n', '    uint public monarchyEndReward;\n', '    \n', '    event Created(uint time);\n', '    event DailyLimitChanged(uint time, address indexed owner, uint newValue);\n', '    // admin events\n', '    event IssueDividendRewardChanged(uint time, address indexed admin, uint newValue);\n', '    event SendProfitsRewardChanged(uint time, address indexed admin, uint newValue);\n', '    event MonarchyRewardsChanged(uint time, address indexed admin, uint startReward, uint endReward);\n', '    // base events\n', '    event TaskError(uint time, address indexed caller, string msg);\n', '    event RewardSuccess(uint time, address indexed caller, uint reward);\n', '    event RewardFailure(uint time, address indexed caller, uint reward, string msg);\n', '    // task events\n', '    event IssueDividendSuccess(uint time, address indexed treasury, uint profitsSent);\n', '    event SendProfitsSuccess(uint time, address indexed bankrollable, uint profitsSent);\n', '    event MonarchyGameStarted(uint time, address indexed addr, uint initialPrize);\n', '    event MonarchyGamesRefreshed(uint time, uint numEnded, uint feesCollected);\n', '\n', '    // Construct sets the registry and instantiates inherited classes.\n', '    constructor(address _registry)\n', '        public\n', '        HasDailyLimit(1 ether)\n', '        Bankrollable(_registry)\n', '        UsingAdmin(_registry)\n', '        UsingMonarchyController(_registry)\n', '    {\n', '        emit Created(now);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// OWNER FUNCTIONS ////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function setDailyLimit(uint _amount)\n', '        public\n', '        fromOwner\n', '    {\n', '        _setDailyLimit(_amount);\n', '        emit DailyLimitChanged(now, msg.sender, _amount);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// ADMIN FUNCTIONS ////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function setIssueDividendReward(uint _bips)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_bips <= 10);\n', '        issueDividendRewardBips = _bips;\n', '        emit IssueDividendRewardChanged(now, msg.sender, _bips);\n', '    }\n', '\n', '    function setSendProfitsReward(uint _bips)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_bips <= 100);\n', '        sendProfitsRewardBips = _bips;\n', '        emit SendProfitsRewardChanged(now, msg.sender, _bips);\n', '    }\n', '\n', '    function setMonarchyRewards(uint _startReward, uint _endReward)\n', '        public\n', '        fromAdmin\n', '    {\n', '        require(_startReward <= 1 ether);\n', '        require(_endReward <= 1 ether);\n', '        monarchyStartReward = _startReward;\n', '        monarchyEndReward = _endReward;\n', '        emit MonarchyRewardsChanged(now, msg.sender, _startReward, _endReward);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// ISSUE DIVIDEND TASK ////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function doIssueDividend()\n', '        public\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        // get amount of profits\n', '        ITreasury _tr = getTreasury();\n', '        _profits = _tr.profitsSendable();\n', '        // quit if no profits to send.\n', '        if (_profits == 0) {\n', '            _taskError("No profits to send.");\n', '            return;\n', '        }\n', '        // call .issueDividend(), use return value to compute _reward\n', '        _profits = _tr.issueDividend();\n', '        if (_profits == 0) {\n', '            _taskError("No profits were sent.");\n', '            return;\n', '        } else {\n', '            emit IssueDividendSuccess(now, address(_tr), _profits);\n', '        }\n', '        // send reward\n', '        _reward = (_profits * issueDividendRewardBips) / 10000;\n', '        _sendReward(_reward);\n', '    }\n', '\n', '    // Returns reward and profits\n', '    function issueDividendReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        _profits = getTreasury().profitsSendable();\n', '        _reward = _cappedReward((_profits * issueDividendRewardBips) / 10000);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// SEND PROFITS TASKS /////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    function doSendProfits(address _bankrollable)\n', '        public\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        // Call .sendProfits(). Look for Treasury balance to change.\n', '        ITreasury _tr = getTreasury();\n', '        uint _oldTrBalance = address(_tr).balance;\n', '        _IBankrollable(_bankrollable).sendProfits();\n', '        uint _newTrBalance = address(_tr).balance;\n', '\n', '        // Quit if no profits. Otherwise compute profits.\n', '        if (_newTrBalance <= _oldTrBalance) {\n', '            _taskError("No profits were sent.");\n', '            return;\n', '        } else {\n', '            _profits = _newTrBalance - _oldTrBalance;\n', '            emit SendProfitsSuccess(now, _bankrollable, _profits);\n', '        }\n', '        \n', '        // Cap reward to current balance (or send will fail)\n', '        _reward = (_profits * sendProfitsRewardBips) / 10000;\n', '        _sendReward(_reward);\n', '    }\n', '\n', '    // Returns an estimate of profits to send, and reward.\n', '    function sendProfitsReward(address _bankrollable)\n', '        public\n', '        view\n', '        returns (uint _reward, uint _profits)\n', '    {\n', '        int _p = _IBankrollable(_bankrollable).profits();\n', '        if (_p <= 0) return;\n', '        _profits = uint(_p);\n', '        _reward = _cappedReward((_profits * sendProfitsRewardBips) / 10000);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    ////////// MONARCHY TASKS /////////////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////\n', '\n', '    // Try to start monarchy game, reward upon success.\n', '    function startMonarchyGame(uint _index)\n', '        public\n', '    {\n', "        // Don't bother trying if it's not startable\n", '        IMonarchyController _mc = getMonarchyController();\n', '        if (!_mc.getIsStartable(_index)){\n', '            _taskError("Game is not currently startable.");\n', '            return;\n', '        }\n', '\n', '        // Try to start the game. This may fail.\n', '        address _game = _mc.startDefinedGame(_index);\n', '        if (_game == address(0)) {\n', '            _taskError("MonarchyConroller.startDefinedGame() failed.");\n', '            return;\n', '        } else {\n', '            emit MonarchyGameStarted(now, _game, _mc.getInitialPrize(_index));   \n', '        }\n', '\n', '        // Reward\n', '        _sendReward(monarchyStartReward);\n', '    }\n', '\n', '    // Return the _reward and _index of the first startable MonarchyGame\n', '    function startMonarchyGameReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _index)\n', '    {\n', '        IMonarchyController _mc = getMonarchyController();\n', '        _index = _mc.getFirstStartableIndex();\n', '        if (_index > 0) _reward = _cappedReward(monarchyStartReward);\n', '    }\n', '\n', '\n', '    // Invoke .refreshGames() and pay reward on number of games ended.\n', '    function refreshMonarchyGames()\n', '        public\n', '    {\n', '        // do the call\n', '        uint _numGamesEnded;\n', '        uint _feesCollected;\n', '        (_numGamesEnded, _feesCollected) = getMonarchyController().refreshGames();\n', '        emit MonarchyGamesRefreshed(now, _numGamesEnded, _feesCollected);\n', '\n', '        if (_numGamesEnded == 0) {\n', '            _taskError("No games ended.");\n', '        } else {\n', '            _sendReward(_numGamesEnded * monarchyEndReward);   \n', '        }\n', '    }\n', '    \n', '    // Return a reward for each MonarchyGame that will end\n', '    function refreshMonarchyGamesReward()\n', '        public\n', '        view\n', '        returns (uint _reward, uint _numEndable)\n', '    {\n', '        IMonarchyController _mc = getMonarchyController();\n', '        _numEndable = _mc.getNumEndableGames();\n', '        _reward = _cappedReward(_numEndable * monarchyEndReward);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    /////////////////// PRIVATE FUNCTIONS /////////////////////////////////\n', '    ///////////////////////////////////////////////////////////////////////\n', '\n', '    // Called when task is unable to execute.\n', '    function _taskError(string _msg) private {\n', '        emit TaskError(now, msg.sender, _msg);\n', '    }\n', '\n', '    // Sends a capped amount of _reward to the msg.sender, and emits proper event.\n', '    function _sendReward(uint _reward) private {\n', '        // Limit the reward to balance or dailyLimitRemaining\n', '        uint _amount = _cappedReward(_reward);\n', '        if (_reward > 0 && _amount == 0) {\n', '            emit RewardFailure(now, msg.sender, _amount, "Not enough funds, or daily limit reached.");\n', '            return;\n', '        }\n', '\n', '        // Attempt to send it (even if _reward was 0)\n', '        if (msg.sender.call.value(_amount)()) {\n', '            _useFromDailyLimit(_amount);\n', '            totalRewarded += _amount;\n', '            emit RewardSuccess(now, msg.sender, _amount);\n', '        } else {\n', '            emit RewardFailure(now, msg.sender, _amount, "Reward rejected by recipient (out of gas, or revert).");\n', '        }\n', '    }\n', '\n', '    // This caps the reward amount to the minimum of (reward, balance, dailyLimitRemaining)\n', '    function _cappedReward(uint _reward) private view returns (uint) {\n', '        uint _balance = address(this).balance;\n', '        uint _remaining = getDailyLimitRemaining();\n', '        if (_reward > _balance) _reward = _balance;\n', '        if (_reward > _remaining) _reward = _remaining;\n', '        return _reward;\n', '    }\n', '\n', '    // IMPLEMENT BANKROLLABLE FUNCTIONS\n', '    function getCollateral() public view returns (uint) {}\n', '    function getWhitelistOwner() public view returns (address){ return getAdmin(); }\n', '}']
