['pragma solidity ^ 0.4.18;\n', '\n', '/**\n', ' * @title Owned\n', ' * @dev The Owned contract has an owner address, and provides basic authorization control\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '   \n', '    /*Set owner of the contract*/\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /*only owner can be modifier*/\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Owned {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/*ERC20*/\n', 'contract TokenERC20 is Pausable {\n', '    using SafeMath for uint256;\n', '    // Public variables of the token\n', '    string public name = "NRC";\n', '    string public symbol = "R";\n', '    uint8 public decimals = 0;\n', '    // how many token units a buyer gets per wei\n', '    uint256 public rate = 50000;\n', '    // address where funds are collected\n', '    address public wallet = 0xd3C8326064044c36B73043b009155a59e92477D0;\n', '    // contributors address\n', '    address public contributorsAddress = 0xa7db53CB73DBe640DbD480a928dD06f03E2aE7Bd;\n', '    // company address\n', '    address public companyAddress = 0x9c949b51f2CafC3A5efc427621295489B63D861D;\n', '    // market Address \n', '    address public marketAddress = 0x199EcdFaC25567eb4D21C995B817230050d458d9;\n', '    // share of all token \n', '    uint8 public constant ICO_SHARE = 20;\n', '    uint8 public constant CONTRIBUTORS_SHARE = 30;\n', '    uint8 public constant COMPANY_SHARE = 20;\n', '    uint8 public constant MARKET_SHARE = 30;\n', '    // unfronzen periods \n', '    uint8 constant COMPANY_PERIODS = 10;\n', '    uint8 constant CONTRIBUTORS_PERIODS = 3;\n', '    // token totalsupply amount\n', '    uint256 public constant TOTAL_SUPPLY = 80000000000;\n', '    // ico token amount\n', '    uint256 public icoTotalAmount = 16000000000;\n', '    uint256 public companyPeriodsElapsed;\n', '    uint256 public contributorsPeriodsElapsed;\n', '    // token frozened amount\n', '    uint256 public frozenSupply;\n', '    uint256 public initDate;\n', '    uint8 public contributorsCurrentPeriod;\n', '    uint8 public companyCurrentPeriod;\n', '    // This creates an array with all balances\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event InitialToken(string desc, address indexed target, uint256 value);    \n', '    \n', '    /**\n', '     * Constrctor function\n', '     * Initializes contract with initial supply tokens to the creator of the contract\n', '     */\n', '    function TokenERC20(\n', '    ) public {\n', '        // contributors share 30% of totalSupply,but get all by 3 years\n', '        uint256 tempContributors = TOTAL_SUPPLY.mul(CONTRIBUTORS_SHARE).div(100).div(CONTRIBUTORS_PERIODS);\n', '        contributorsPeriodsElapsed = tempContributors;\n', '        balanceOf[contributorsAddress] = tempContributors;\n', '        InitialToken("contributors", contributorsAddress, tempContributors);\n', '        \n', '        // company shares 20% of totalSupply,but get all by 10 years\n', '        uint256 tempCompany = TOTAL_SUPPLY.mul(COMPANY_SHARE).div(100).div(COMPANY_PERIODS);\n', '        companyPeriodsElapsed = tempCompany;\n', '        balanceOf[companyAddress] = tempCompany;\n', '        InitialToken("company", companyAddress, tempCompany);\n', '\n', '        // ico takes 20% of totalSupply\n', '        uint256 tempIco = TOTAL_SUPPLY.mul(ICO_SHARE).div(100);\n', '        icoTotalAmount = tempIco;\n', '\n', '        // expand the market cost 30% of totalSupply\n', '        uint256 tempMarket = TOTAL_SUPPLY.mul(MARKET_SHARE).div(100);\n', '        balanceOf[marketAddress] = tempMarket;\n', '        InitialToken("market", marketAddress, tempMarket);\n', '\n', '        // frozenSupply waitting for being unfrozen\n', '        uint256 tempFrozenSupply = TOTAL_SUPPLY.sub(tempContributors).sub(tempIco).sub(tempCompany).sub(tempMarket);\n', '        frozenSupply = tempFrozenSupply;\n', '        initDate = block.timestamp;\n', '        contributorsCurrentPeriod = 1;\n', '        companyCurrentPeriod = 1;\n', '        paused = true;\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to].add(_value) > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '        // Subtract from the sender\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '}\n', '/******************************************/\n', '/*       NRCToken STARTS HERE       */\n', '/******************************************/\n', '\n', 'contract NRCToken is Owned, TokenERC20 {\n', '    uint256 private etherChangeRate = 10 ** 18;\n', '    uint256 private minutesOneYear = 365*24*60 minutes;\n', '    bool public  tokenSaleActive = true;\n', '    // token have been sold\n', '    uint256 public totalSoldToken;\n', '    // all frozenAccount addresses\n', '    mapping(address => bool) public frozenAccount;\n', '\n', '    /* This generates a public log event on the blockchain that will notify clients */\n', '    event LogFrozenAccount(address target, bool frozen);\n', '    event LogUnfrozenTokens(string desc, address indexed targetaddress, uint256 unfrozenTokensAmount);\n', '    event LogSetTokenPrice(uint256 tokenPrice);\n', '    event TimePassBy(string desc, uint256 times );\n', '    /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param value ehter paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event LogTokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '    // ICO finished Event\n', '    event TokenSaleFinished(string desc, address indexed contributors, uint256 icoTotalAmount, uint256 totalSoldToken, uint256 leftAmount);\n', '    \n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function NRCToken() TokenERC20() public {}\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_from != _to);\n', '        require(_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(balanceOf[_from] >= _value); // Check if the sender has enough\n', '        require(balanceOf[_to].add(_value) > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]); // Check if sender is frozen\n', '        require(!frozenAccount[_to]); // Check if recipient is frozen\n', '        balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].add(_value); // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '    }\n', '       /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) public onlyOwner whenNotPaused {\n', '        require(target != 0x0);\n', '        require(target != owner);\n', '        require(frozenAccount[target] != freeze);\n', '        frozenAccount[target] = freeze;\n', '        LogFrozenAccount(target, freeze);\n', '    }\n', '\n', '    /// @notice Allow users to buy tokens for `newTokenRate` eth\n', '    /// @param newTokenRate Price users can buy from the contract\n', '    function setPrices(uint256 newTokenRate) public onlyOwner whenNotPaused {\n', '        require(newTokenRate > 0);\n', '        require(newTokenRate <= icoTotalAmount);\n', '        require(tokenSaleActive);\n', '        rate = newTokenRate;\n', '        LogSetTokenPrice(newTokenRate);\n', '    }\n', '\n', '    /// @notice Buy tokens from contract by sending ether\n', '    function buy() public payable whenNotPaused {\n', '        // if ICO finished ,can not buy any more!\n', '        require(!frozenAccount[msg.sender]); \n', '        require(tokenSaleActive);\n', '        require(validPurchase());\n', '        uint tokens = getTokenAmount(msg.value); // calculates the amount\n', '        require(!validSoldOut(tokens));\n', '        LogTokenPurchase(msg.sender, msg.value, tokens);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n', '        calcTotalSoldToken(tokens);\n', '        forwardFunds();\n', '    }\n', '\n', '    // Override this method to have a way to add business logic to your crowdsale when buying\n', '    function getTokenAmount(uint256 etherAmount) internal view returns(uint256) {\n', '        uint256 temp = etherAmount.mul(rate);\n', '        uint256 amount = temp.div(etherChangeRate);\n', '        return amount;\n', '    }\n', '\n', '    // send ether to the funder wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    // calc totalSoldToken\n', '    function calcTotalSoldToken(uint256 soldAmount) internal {\n', '        totalSoldToken = totalSoldToken.add(soldAmount);\n', '        if (totalSoldToken >= icoTotalAmount) { \n', '            tokenSaleActive = false;\n', '        }\n', '    }\n', '\n', '    // @return true if the transaction can buy tokens\n', '    function validPurchase() internal view returns(bool) {\n', '        bool limitPurchase = msg.value >= 1 ether;\n', '        bool isNotTheOwner = msg.sender != owner;\n', '        bool isNotTheCompany = msg.sender != companyAddress;\n', '        bool isNotWallet = msg.sender != wallet;\n', '        bool isNotContributors = msg.sender != contributorsAddress;\n', '        bool isNotMarket = msg.sender != marketAddress;\n', '        return limitPurchase && isNotTheOwner && isNotTheCompany && isNotWallet && isNotContributors && isNotMarket;\n', '    }\n', '\n', '    // @return true if the ICO is in progress.\n', '    function validSoldOut(uint256 soldAmount) internal view returns(bool) {\n', '        return totalSoldToken.add(soldAmount) > icoTotalAmount;\n', '    }\n', '    // @return current timestamp\n', '    function time() internal constant returns (uint) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    /// @dev send the rest of the tokens after the crowdsale end and\n', '    /// send to contributors address\n', '    function finaliseICO() public onlyOwner whenNotPaused {\n', '        require(tokenSaleActive == true);        \n', '        uint256 tokensLeft = icoTotalAmount.sub(totalSoldToken);\n', '        tokenSaleActive = false;\n', '        require(tokensLeft > 0);\n', '        balanceOf[contributorsAddress] = balanceOf[contributorsAddress].add(tokensLeft);\n', '        TokenSaleFinished("finaliseICO", contributorsAddress, icoTotalAmount, totalSoldToken, tokensLeft);\n', '        totalSoldToken = icoTotalAmount;\n', '    }\n', '\n', '\n', '    /// @notice freeze unfrozenAmount\n', '    function unfrozenTokens() public onlyOwner whenNotPaused {\n', '        require(frozenSupply >= 0);\n', '        if (contributorsCurrentPeriod < CONTRIBUTORS_PERIODS) {\n', '            unfrozenContributorsTokens();\n', '            unfrozenCompanyTokens();\n', '        } else {\n', '            unfrozenCompanyTokens();\n', '        }\n', '    }\n', '\n', '    // unfrozen contributors token year by year\n', '    function unfrozenContributorsTokens() internal {\n', '        require(contributorsCurrentPeriod < CONTRIBUTORS_PERIODS);\n', '        uint256 contributortimeShouldPassBy = contributorsCurrentPeriod * (minutesOneYear);\n', '        TimePassBy("contributortimeShouldPassBy", contributortimeShouldPassBy);\n', '        uint256 contributorsTimePassBy = time() - initDate;\n', '        TimePassBy("contributortimePassBy", contributorsTimePassBy);\n', '\n', '        contributorsCurrentPeriod = contributorsCurrentPeriod + 1;\n', '        require(contributorsTimePassBy >= contributortimeShouldPassBy);\n', '        frozenSupply = frozenSupply.sub(contributorsPeriodsElapsed);\n', '        balanceOf[contributorsAddress] = balanceOf[contributorsAddress].add(contributorsPeriodsElapsed);\n', '        LogUnfrozenTokens("contributors", contributorsAddress, contributorsPeriodsElapsed);\n', '    }\n', '\n', '    // unfrozen company token year by year\n', '    function unfrozenCompanyTokens() internal {\n', '        require(companyCurrentPeriod < COMPANY_PERIODS);\n', '        uint256 companytimeShouldPassBy = companyCurrentPeriod * (minutesOneYear);\n', '        TimePassBy("CompanytimeShouldPassBy", companytimeShouldPassBy);\n', '        uint256 companytimePassBy = time() - initDate;\n', '        TimePassBy("CompanytimePassBy", companytimePassBy);\n', '\n', '        require(companytimePassBy >= companytimeShouldPassBy);\n', '        companyCurrentPeriod = companyCurrentPeriod + 1;\n', '        frozenSupply = frozenSupply.sub(companyPeriodsElapsed);\n', '        balanceOf[companyAddress] = balanceOf[companyAddress].add(companyPeriodsElapsed);\n', '        LogUnfrozenTokens("company", companyAddress, companyPeriodsElapsed);\n', '    }\n', '\n', '    // fallback function - do not allow any eth transfers to this contract\n', '    function() external {\n', '        revert();\n', '    }\n', '\n', '}']