['pragma solidity ^0.4.23;\n', '\n', '/*\n', '\n', 'Options Exchange\n', '========================\n', '\n', 'An Exchange for American Options.\n', 'An American Option is a contract between its Buyer and its Seller, giving the Buyer the ability\n', 'to buy (or sell) an Asset at a specified Strike Price any time before a specified time (Maturation).\n', '\n', 'Authors: /u/Cintix and /u/Hdizzle83\n', '\n', '*/\n', '\n', '// Using the SafeMath Library helps prevent integer overflow bugs.\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert((a == 0) || (c / a == b));\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) pure internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '// Options can only be created for tokens adhering to the ERC20 Interface.\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract Token {\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool success) {}\n', '  function transfer(address to, uint256 value) public returns (bool success) {}\n', '}\n', '\n', '// An Option is a bet between two users on the relative price of two assets on a given date.\n', '// The Seller locks amountLocked of assetLocked in the Option in exchange for immediate payment of amountPremium of assetPremium from the Buyer.\n', '// The Buyer is then free to exercise the Option by trading amountTraded of assetTraded for the locked funds.\n', '// The ratio of amountTraded and amountLocked is called the Strike Price.\n', '// At the closing date (Maturation) or when the Buyer exercises the Option, the Option&#39;s funds are sent back to the Seller.\n', 'contract OptionsExchange {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // Admin takes a 1% cut of each purchased Option&#39;s Premium, stored as a ratio with 1 ether as the denominator.\n', '  uint256 public fee_ratio = 10 ** 16;\n', '  \n', '  // Admin is initialized to the contract creator.\n', '  address public admin = msg.sender;\n', '  \n', '  // User balances are stored as userBalance[user][asset], where ETH is stored as address 0.\n', '  mapping (address => mapping(address => uint256)) public userBalance;\n', '  \n', '  // Onchain Option data indicates the current Buyer and Seller along with corresponding nonces used to invalidate old offchain orders.\n', '  // The Seller and Buyer addresses and their nonces take up two 32 byte storage slots, making up the only onchain data for each Option.\n', '  // When both storage slots are zero (i.e. uninitialized), the Option is Available or Invalid.\n', '  // When both storage slots are non-zero, the Option is Live or Matured.\n', '  // When only the Buyer storage slot is non-zero, the Option is Closed.\n', '  // When only the Seller storage slot is non-zero, the Option is Exercised or Cancelled.\n', '  // When only nonceSeller is non-zero, the Option is Cancelled.\n', '  // When an Option is Live, nonceSeller and nonceBuyer store how many users have been the Option&#39;s Seller and Buyer, respectively.\n', '  // The storage slots are zeroed out when the Option is Closed or Exercised to refund 10,000 gas.\n', '  struct optionDatum {\n', '    address seller;\n', '    uint96 nonceSeller;\n', '    address buyer;\n', '    uint96 nonceBuyer;\n', '  }\n', '  \n', '  // To reduce onchain storage, Options are indexed by a hash of their offchain parameters, optionHash.\n', '  mapping (bytes32 => optionDatum) public optionData;\n', '  \n', '  // Possible states an Option (or its offchain order) can be in.\n', '  // Options implicitly store locked funds when they&#39;re Live or Matured.\n', '  enum optionStates {\n', '    Invalid,   // Option parameters are invalid.\n', '    Available, // Option hasn&#39;t been created or filled yet.\n', '    Cancelled, // Option&#39;s initial offchain order has been cancelled by the Maker.\n', '    Live,      // Option contains implicitly stored funds, can be resold or exercised any time before its Maturation time.\n', '    Exercised, // Option has been exercised by its buyer, withdrawing its implicitly stored funds.\n', '    Matured,   // Option still contains implicitly stored funds but has passed its Maturation time and is ready to be closed.\n', '    Closed     // Option has been closed by its Seller, who has withdrawn its implicitly stored funds.\n', '  }\n', '  \n', '  // Events emitted by the contract for use in tracking exchange activity.\n', '  // For Deposits and Withdrawals, ETH balances are stored as an asset with address 0.\n', '  event Deposit(address indexed user, address indexed asset, uint256 amount);\n', '  event Withdrawal(address indexed user, address indexed asset, uint256 amount);\n', '  event OrderFilled(bytes32 indexed optionHash,\n', '                    address indexed maker,\n', '                    address indexed taker,\n', '                    address[3] assetLocked_assetTraded_firstMaker,\n', '                    uint256[3] amountLocked_amountTraded_maturation,\n', '                    uint256[2] amountPremium_expiration,\n', '                    address assetPremium,\n', '                    bool makerIsSeller,\n', '                    uint96 nonce);\n', '  event OrderCancelled(bytes32 indexed optionHash, bool bySeller, uint96 nonce);\n', '  event OptionExercised(bytes32 indexed optionHash, address indexed buyer, address indexed seller);\n', '  event OptionClosed(bytes32 indexed optionHash, address indexed seller);\n', '  event UserBalanceUpdated(address indexed user, address indexed asset, uint256 newBalance);\n', '  \n', '  // Allow the admin to transfer ownership.\n', '  function changeAdmin(address _admin) external {\n', '    require(msg.sender == admin);\n', '    admin = _admin;\n', '  }\n', '  \n', '  // Users must first deposit assets into the Exchange in order to create, purchase, or exercise Options.\n', '  // ETH balances are stored as an asset with address 0.\n', '  function depositETH() external payable {\n', '    userBalance[msg.sender][0] = userBalance[msg.sender][0].add(msg.value);\n', '    emit Deposit(msg.sender, 0, msg.value);\n', '    emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]);\n', '  }\n', '  \n', '  // Users can withdraw any amount of ETH up to their current balance.\n', '  function withdrawETH(uint256 amount) external {\n', '    require(userBalance[msg.sender][0] >= amount);\n', '    userBalance[msg.sender][0] = userBalance[msg.sender][0].sub(amount);\n', '    msg.sender.transfer(amount);\n', '    emit Withdrawal(msg.sender, 0, amount);\n', '    emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]);\n', '  }\n', '  \n', '  // To deposit tokens, users must first "approve" the transfer in the token contract.\n', '  // Users must first deposit assets into the Exchange in order to create, purchase, or exercise Options.\n', '  function depositToken(address token, uint256 amount) external {\n', '    require(Token(token).transferFrom(msg.sender, this, amount));  \n', '    userBalance[msg.sender][token] = userBalance[msg.sender][token].add(amount);\n', '    emit Deposit(msg.sender, token, amount);\n', '    emit UserBalanceUpdated(msg.sender, token, userBalance[msg.sender][token]);\n', '  }\n', '  \n', '  // Users can withdraw any amount of a given token up to their current balance.\n', '  function withdrawToken(address token, uint256 amount) external {\n', '    require(userBalance[msg.sender][token] >= amount);\n', '    userBalance[msg.sender][token] = userBalance[msg.sender][token].sub(amount);\n', '    require(Token(token).transfer(msg.sender, amount));\n', '    emit Withdrawal(msg.sender, token, amount);\n', '    emit UserBalanceUpdated(msg.sender, token, userBalance[msg.sender][token]);\n', '  }\n', '  \n', '  // Transfer funds from one user&#39;s balance to another&#39;s.  Not externally callable.\n', '  function transferUserToUser(address from, address to, address asset, uint256 amount) private {\n', '    require(userBalance[from][asset] >= amount);\n', '    userBalance[from][asset] = userBalance[from][asset].sub(amount);\n', '    userBalance[to][asset] = userBalance[to][asset].add(amount);\n', '    emit UserBalanceUpdated(from, asset, userBalance[from][asset]);\n', '    emit UserBalanceUpdated(to, asset, userBalance[to][asset]);\n', '  }\n', '  \n', '  // Hashes an Option&#39;s parameters for use in looking up information about the Option.  Callable internally and externally.\n', '  // Variables are grouped into arrays as a workaround for the "too many local variables" problem.\n', '  // Instead of directly encoding the asset exchange rate (Strike Price), it is instead implicitly\n', '  // stored as the ratio of amountLocked, the amount of assetLocked stored in the Option, and amountTraded,\n', '  // the amount of assetTraded needed to exercise the Option.\n', '  function getOptionHash(address[3] assetLocked_assetTraded_firstMaker,\n', '                         uint256[3] amountLocked_amountTraded_maturation) pure public returns(bytes32) {\n', '    bytes32 optionHash = keccak256(assetLocked_assetTraded_firstMaker[0],\n', '                                   assetLocked_assetTraded_firstMaker[1],\n', '                                   assetLocked_assetTraded_firstMaker[2],\n', '                                   amountLocked_amountTraded_maturation[0],\n', '                                   amountLocked_amountTraded_maturation[1],\n', '                                   amountLocked_amountTraded_maturation[2]);\n', '    return optionHash;\n', '  }\n', '  \n', '  // Hashes an Order&#39;s parameters for use in ecrecover.  Callable internally and externally.\n', '  function getOrderHash(bytes32 optionHash,\n', '                        uint256[2] amountPremium_expiration,\n', '                        address assetPremium,\n', '                        bool makerIsSeller,\n', '                        uint96 nonce) view public returns(bytes32) {\n', '    // A hash of the Order&#39;s information which was signed by the Maker to create the offchain order.\n', '    bytes32 orderHash = keccak256("\\x19Ethereum Signed Message:\\n32",\n', '                                  keccak256(address(this),\n', '                                            optionHash,\n', '                                            amountPremium_expiration[0],\n', '                                            amountPremium_expiration[1],\n', '                                            assetPremium,\n', '                                            makerIsSeller,\n', '                                            nonce));\n', '    return orderHash;\n', '  }\n', '  \n', '  // Computes the current state of an Option given its parameters.  Callable internally and externally.\n', '  function getOptionState(address[3] assetLocked_assetTraded_firstMaker,\n', '                          uint256[3] amountLocked_amountTraded_maturation) view public returns(optionStates) {\n', '    // Tokens must be different for Option to be Valid.\n', '    if(assetLocked_assetTraded_firstMaker[0] == assetLocked_assetTraded_firstMaker[1]) return optionStates.Invalid;\n', '    // Options must have a non-zero amount of locked assets to be Valid.\n', '    if(amountLocked_amountTraded_maturation[0] == 0) return optionStates.Invalid;\n', '    // Exercising an Option must require trading a non-zero amount of assets.\n', '    if(amountLocked_amountTraded_maturation[1] == 0) return optionStates.Invalid;\n', '    // Options must reach Maturation between 2018 and 2030 to be Valid.\n', '    if(amountLocked_amountTraded_maturation[2] < 1514764800) return optionStates.Invalid;\n', '    if(amountLocked_amountTraded_maturation[2] > 1893456000) return optionStates.Invalid;\n', '    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    address seller = optionData[optionHash].seller;\n', '    uint96 nonceSeller = optionData[optionHash].nonceSeller;\n', '    address buyer = optionData[optionHash].buyer;\n', '    if(seller == 0x0) {\n', '      // Check if the Option&#39;s offchain order was cancelled.\n', '      if(nonceSeller != 0) return optionStates.Cancelled;\n', '      // If both Buyer and Seller are still 0, Option is Available, even if it&#39;s past Maturation.\n', '      if(buyer == 0x0) return optionStates.Available;\n', '      // If Seller is 0 and Buyer is non-zero, Option must have been Closed.\n', '      return optionStates.Closed;\n', '    }\n', '    // If Seller is non-zero and Buyer is 0, Option must have been Exercised.\n', '    if(buyer == 0x0) return optionStates.Exercised;\n', '    // If Seller and Buyer are both non-zero and the Option hasn&#39;t passed Maturation, it&#39;s Live.\n', '    if(now < amountLocked_amountTraded_maturation[2]) return optionStates.Live;\n', '    // Otherwise, the Option must have Matured.\n', '    return optionStates.Matured;\n', '  }\n', '  \n', '  // Transfer payment from an Option&#39;s Buyer to the Seller less the 1% fee sent to the admin.  Not externally callable.\n', '  function payForOption(address buyer, address seller, address assetPremium, uint256 amountPremium) private {\n', '    uint256 fee = (amountPremium.mul(fee_ratio)).div(1 ether);\n', '    transferUserToUser(buyer, seller, assetPremium, amountPremium.sub(fee));\n', '    transferUserToUser(buyer, admin, assetPremium, fee);\n', '  }\n', '  \n', '  // Allows a Taker to fill an offchain Option order created by a Maker.\n', '  // Transitions new Options from Available to Live, depositing its implicitly stored locked funds.\n', '  // Maintains state of existing Options as Live, without affecting their implicitly stored locked funds.\n', '  function fillOptionOrder(address[3] assetLocked_assetTraded_firstMaker,\n', '                           uint256[3] amountLocked_amountTraded_maturation,\n', '                           uint256[2] amountPremium_expiration,\n', '                           address assetPremium,\n', '                           bool makerIsSeller,\n', '                           uint96 nonce,\n', '                           uint8 v,\n', '                           bytes32[2] r_s) external {\n', '    // Verify offchain order hasn&#39;t expired.\n', '    require(now < amountPremium_expiration[1]);\n', '    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    // A hash of the Order&#39;s information which was signed by the Maker to create the offchain order.\n', '    bytes32 orderHash = getOrderHash(optionHash, amountPremium_expiration, assetPremium, makerIsSeller, nonce);\n', '    // A nonce of zero corresponds to creating a new Option, while nonzero means reselling an old one.\n', '    if(nonce == 0) {\n', '      // Option must be Available, which means it is valid, unfilled, and uncancelled.\n', '      require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Available);\n', '      // Option must not already be past its Maturation time.\n', '      require(now < amountLocked_amountTraded_maturation[2]);\n', '      // Verify the Maker&#39;s offchain order is valid by checking whether it was signed by the first Maker.\n', '      require(ecrecover(orderHash, v, r_s[0], r_s[1]) == assetLocked_assetTraded_firstMaker[2]);\n', '      // Set the Option&#39;s Buyer and Seller and initialize the nonces to 1, marking the Option as Live.\n', '      // Ternary operator to assign the Seller and Buyer from the Maker and Taker: (<conditional> ? <if-true> : <if-false>)\n', '      optionData[optionHash].seller = makerIsSeller ? assetLocked_assetTraded_firstMaker[2] : msg.sender;\n', '      optionData[optionHash].nonceSeller = 1;\n', '      optionData[optionHash].buyer = makerIsSeller ? msg.sender : assetLocked_assetTraded_firstMaker[2];\n', '      optionData[optionHash].nonceBuyer = 1;\n', '      // The Buyer pays the Seller the premium for the Option.\n', '      payForOption(optionData[optionHash].buyer, optionData[optionHash].seller, assetPremium, amountPremium_expiration[0]);\n', '      // Lock amountLocked of the Seller&#39;s assetLocked in implicit storage as specified by the Option parameters.\n', '      require(userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]] >= amountLocked_amountTraded_maturation[0]);\n', '      userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]] = userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]].sub(amountLocked_amountTraded_maturation[0]);\n', '      emit UserBalanceUpdated(optionData[optionHash].seller, assetLocked_assetTraded_firstMaker[0], userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]]);\n', '      emit OrderFilled(optionHash, \n', '                       assetLocked_assetTraded_firstMaker[2],\n', '                       msg.sender,\n', '                       assetLocked_assetTraded_firstMaker,\n', '                       amountLocked_amountTraded_maturation,\n', '                       amountPremium_expiration,\n', '                       assetPremium,\n', '                       makerIsSeller,\n', '                       nonce);\n', '    } else {\n', '      // Option must be Live, which means this order is a resale by the current buyer or seller.\n', '      require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Live);\n', '      // If the Maker is the Seller, they&#39;re buying back out their locked asset.\n', '      // Otherwise, the Maker is the Buyer and they&#39;re reselling their ability to exercise the Option.\n', '      if(makerIsSeller) {\n', '        // Verify the nonce of the Maker&#39;s offchain order matches to ensure the order isn&#39;t old or cancelled.\n', '        require(optionData[optionHash].nonceSeller == nonce);\n', '        // Verify the Maker&#39;s offchain order is valid by checking whether it was signed by the Maker.\n', '        require(ecrecover(orderHash, v, r_s[0], r_s[1]) == optionData[optionHash].seller);\n', '        // The Maker pays the Taker the premium for buying out their locked asset.\n', '        payForOption(optionData[optionHash].seller, msg.sender, assetPremium, amountPremium_expiration[0]);\n', '        // The Taker directly sends the Maker an amount equal to the Maker&#39;s locked assets, replacing them as the Seller.\n', '        transferUserToUser(msg.sender, optionData[optionHash].seller, assetLocked_assetTraded_firstMaker[0], amountLocked_amountTraded_maturation[0]);\n', '        // Update the Option&#39;s Seller to be the Taker and increment the nonce to prevent double-filling.\n', '        optionData[optionHash].seller = msg.sender;\n', '        optionData[optionHash].nonceSeller += 1;\n', '        emit OrderFilled(optionHash, \n', '                         optionData[optionHash].seller,\n', '                         msg.sender,\n', '                         assetLocked_assetTraded_firstMaker,\n', '                         amountLocked_amountTraded_maturation,\n', '                         amountPremium_expiration,\n', '                         assetPremium,\n', '                         makerIsSeller,\n', '                         nonce);\n', '      } else {\n', '        // Verify the nonce of the Maker&#39;s offchain order matches to ensure the order isn&#39;t old or cancelled.\n', '        require(optionData[optionHash].nonceBuyer == nonce);\n', '        // Verify the Maker&#39;s offchain order is valid by checking whether it was signed by the Maker.\n', '        require(ecrecover(orderHash, v, r_s[0], r_s[1]) == optionData[optionHash].buyer);\n', '        // The Taker pays the Maker the premium for the ability to exercise the Option.\n', '        payForOption(msg.sender, optionData[optionHash].buyer, assetPremium, amountPremium_expiration[0]);\n', '        // Update the Option&#39;s Buyer to be the Taker and increment the nonce to prevent double-filling.\n', '        optionData[optionHash].buyer = msg.sender;\n', '        optionData[optionHash].nonceBuyer += 1;\n', '        emit OrderFilled(optionHash, \n', '                         optionData[optionHash].buyer,\n', '                         msg.sender,\n', '                         assetLocked_assetTraded_firstMaker,\n', '                         amountLocked_amountTraded_maturation,\n', '                         amountPremium_expiration,\n', '                         assetPremium,\n', '                         makerIsSeller,\n', '                         nonce);\n', '      }      \n', '    }\n', '  }\n', '  \n', '  // Allows a Maker to cancel their offchain Option order early (i.e. before its expiration).\n', '  function cancelOptionOrder(address[3] assetLocked_assetTraded_firstMaker,\n', '                             uint256[3] amountLocked_amountTraded_maturation,\n', '                             bool makerIsSeller) external {\n', '    optionStates state = getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    // Option must be Available or Live.  Orders can&#39;t be filled in any other state.\n', '    require(state == optionStates.Available || state == optionStates.Live);\n', '    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    // If the Option is Available, the first order hasn&#39;t been filled yet.\n', '    if(state == optionStates.Available) {\n', '      // Only allow the Maker to cancel their own offchain Option order.\n', '      require(msg.sender == assetLocked_assetTraded_firstMaker[2]);\n', '      emit OrderCancelled(optionHash, makerIsSeller, 0);\n', '      // Mark the Option as Cancelled by setting the Seller nonce nonzero while the Seller is still 0x0.\n', '      optionData[optionHash].nonceSeller = 1;\n', '    } else {\n', '      // Live Options can be resold by either the Buyer or the Seller.\n', '      if(makerIsSeller) {\n', '        // Only allow the Maker to cancel their own offchain Option order.\n', '        require(msg.sender == optionData[optionHash].seller);\n', '        emit OrderCancelled(optionHash, makerIsSeller, optionData[optionHash].nonceSeller);\n', '        // Invalidate the old offchain order by incrementing the Maker&#39;s nonce.\n', '        optionData[optionHash].nonceSeller += 1;\n', '      } else {\n', '        // Only allow the Maker to cancel their own offchain Option order.\n', '        require(msg.sender == optionData[optionHash].buyer);\n', '        emit OrderCancelled(optionHash, makerIsSeller, optionData[optionHash].nonceBuyer);\n', '        // Invalidate the old offchain order by incrementing the Maker&#39;s nonce.\n', '        optionData[optionHash].nonceBuyer += 1;\n', '      }\n', '    }\n', '  }\n', '  \n', '  // Allow an Option&#39;s Buyer to exercise the Option, trading amountTraded of assetTraded to the Option for amountLocked of assetLocked.\n', '  // The traded funds are sent directly to the Seller so they don&#39;t need to close it afterwards.\n', '  // Transitions an Option from Live to Exercised, withdrawing its implicitly stored locked funds.\n', '  function exerciseOption(address[3] assetLocked_assetTraded_firstMaker,\n', '                          uint256[3] amountLocked_amountTraded_maturation) external {\n', '    // Option must be Live, which means it&#39;s been filled and hasn&#39;t passed its trading deadline (Maturation).\n', '    require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Live);\n', '    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    address buyer = optionData[optionHash].buyer;\n', '    address seller = optionData[optionHash].seller;\n', '    // Only allow the current Buyer to exercise the Option.\n', '    require(msg.sender == buyer);\n', '    // The Buyer sends the Seller the traded assets as specified by the Option parameters.\n', '    transferUserToUser(buyer, seller, assetLocked_assetTraded_firstMaker[1], amountLocked_amountTraded_maturation[1]);\n', '    // Mark the Option as Exercised by zeroing out the Buyer and the corresponding nonce.\n', '    delete optionData[optionHash].buyer;\n', '    delete optionData[optionHash].nonceBuyer;\n', '    // The Buyer receives the implicitly stored locked assets as specified by the Option parameters.\n', '    userBalance[buyer][assetLocked_assetTraded_firstMaker[0]] = userBalance[buyer][assetLocked_assetTraded_firstMaker[0]].add(amountLocked_amountTraded_maturation[0]);\n', '    emit UserBalanceUpdated(buyer, assetLocked_assetTraded_firstMaker[0], userBalance[buyer][assetLocked_assetTraded_firstMaker[0]]);\n', '    emit OptionExercised(optionHash, buyer, seller);\n', '  }\n', '  \n', '  // Allows an Option&#39;s Seller to withdraw their funds after the Option&#39;s Maturation.\n', '  // Transitions an Option from Matured to Closed, withdrawing its implicitly stored locked funds.\n', '  function closeOption(address[3] assetLocked_assetTraded_firstMaker,\n', '                       uint256[3] amountLocked_amountTraded_maturation) external {\n', '    // Option must have Matured, which means it&#39;s filled, unexercised, and has passed its Maturation time.\n', '    require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Matured);\n', '    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\n', '    address seller = optionData[optionHash].seller;\n', '    // Only allow the Seller to close their own Option.\n', '    require(msg.sender == seller);\n', '    // Mark the Option as Closed by zeroing out the Seller and the corresponding nonce.\n', '    delete optionData[optionHash].seller;\n', '    delete optionData[optionHash].nonceSeller;\n', '    // Transfer the Option&#39;s implicitly stored locked funds back to the Seller.\n', '    userBalance[seller][assetLocked_assetTraded_firstMaker[0]] = userBalance[seller][assetLocked_assetTraded_firstMaker[0]].add(amountLocked_amountTraded_maturation[0]);\n', '    emit UserBalanceUpdated(seller, assetLocked_assetTraded_firstMaker[0], userBalance[seller][assetLocked_assetTraded_firstMaker[0]]);\n', '    emit OptionClosed(optionHash, seller);\n', '  }\n', '  \n', '  function() payable external {\n', '    revert();\n', '  }\n', '  \n', '}']