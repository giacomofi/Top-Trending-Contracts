['/* Author: Victor Mezrin  <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a5d3ccc6d1cad7e5c8c0dfd7cccb8bc6cac8">[email&#160;protected]</a> */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnableInterface\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableInterface {\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address);\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the current owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require (msg.sender == getOwner());\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable is OwnableInterface {\n', '\n', '  /* Storage */\n', '\n', '  address owner = address(0x0);\n', '  address proposedOwner = address(0x0);\n', '\n', '\n', '  /* Events */\n', '\n', '  event OwnerAssignedEvent(address indexed newowner);\n', '  event OwnershipOfferCreatedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferAcceptedEvent(address indexed currentowner, address indexed proposedowner);\n', '  event OwnershipOfferCancelledEvent(address indexed currentowner, address indexed proposedowner);\n', '\n', '\n', '  /**\n', '   * @dev The constructor sets the initial `owner` to the passed account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner requests transfer ownership to the new owner.\n', '   * @param _proposedOwner The address to transfer ownership to.\n', '   */\n', '  function createOwnershipOffer(address _proposedOwner) external onlyOwner {\n', '    require (proposedOwner == address(0x0));\n', '    require (_proposedOwner != address(0x0));\n', '    require (_proposedOwner != address(this));\n', '\n', '    proposedOwner = _proposedOwner;\n', '\n', '    emit OwnershipOfferCreatedEvent(owner, _proposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the new owner to accept an ownership offer to contract control.\n', '   */\n', '  //noinspection UnprotectedFunction\n', '  function acceptOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == proposedOwner);\n', '\n', '    address _oldOwner = owner;\n', '    owner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnerAssignedEvent(owner);\n', '    emit OwnershipOfferAcceptedEvent(_oldOwner, owner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Old owner cancels transfer ownership to the new owner.\n', '   */\n', '  function cancelOwnershipOffer() external {\n', '    require (proposedOwner != address(0x0));\n', '    require (msg.sender == owner || msg.sender == proposedOwner);\n', '\n', '    address _oldProposedOwner = proposedOwner;\n', '    proposedOwner = address(0x0);\n', '\n', '    emit OwnershipOfferCancelledEvent(owner, _oldProposedOwner);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev The getter for "owner" contract variable\n', '   */\n', '  function getOwner() public constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "proposedOwner" contract variable\n', '   */\n', '  function getProposedOwner() public constant returns (address) {\n', '    return proposedOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ManageableInterface\n', ' * @dev Contract that allows to grant permissions to any address\n', ' * @dev In real life we are no able to perform all actions with just one Ethereum address\n', ' * @dev because risks are too high.\n', ' * @dev Instead owner delegates rights to manage an contract to the different addresses and\n', ' * @dev stay able to revoke permissions at any time.\n', ' */\n', 'contract ManageableInterface {\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(address _manager, string _permissionName) public constant returns (bool);\n', '\n', '  /**\n', '   * @dev Modifier to use in derived contracts\n', '   */\n', '  modifier onlyAllowedManager(string _permissionName) {\n', '    require(isManagerAllowed(msg.sender, _permissionName) == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Manageable is OwnableInterface,\n', '                       ManageableInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (address => bool) managerEnabled;  // hard switch for a manager - on/off\n', '  mapping (address => mapping (string => bool)) managerPermissions;  // detailed info about manager`s permissions\n', '\n', '\n', '  /* Events */\n', '\n', '  event ManagerEnabledEvent(address indexed manager);\n', '  event ManagerDisabledEvent(address indexed manager);\n', '  event ManagerPermissionGrantedEvent(address indexed manager, bytes32 permission);\n', '  event ManagerPermissionRevokedEvent(address indexed manager, bytes32 permission);\n', '\n', '\n', '  /* Configure contract */\n', '\n', '  /**\n', '   * @dev Function to add new manager\n', '   * @param _manager address New manager\n', '   */\n', '  function enableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == false);\n', '\n', '    managerEnabled[_manager] = true;\n', '\n', '    emit ManagerEnabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to remove existing manager\n', '   * @param _manager address Existing manager\n', '   */\n', '  function disableManager(address _manager) external onlyOwner onlyValidManagerAddress(_manager) {\n', '    require(managerEnabled[_manager] == true);\n', '\n', '    managerEnabled[_manager] = false;\n', '\n', '    emit ManagerDisabledEvent(_manager);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to grant new permission to the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Granted permission name\n', '   */\n', '  function grantManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == false);\n', '\n', '    managerPermissions[_manager][_permissionName] = true;\n', '\n', '    emit ManagerPermissionGrantedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '  /**\n', '   * @dev Function to revoke permission of the manager\n', '   * @param _manager        address Existing manager\n', '   * @param _permissionName string  Revoked permission name\n', '   */\n', '  function revokeManagerPermission(\n', '    address _manager, string _permissionName\n', '  )\n', '    external\n', '    onlyOwner\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '  {\n', '    require(managerPermissions[_manager][_permissionName] == true);\n', '\n', '    managerPermissions[_manager][_permissionName] = false;\n', '\n', '    emit ManagerPermissionRevokedEvent(_manager, keccak256(_permissionName));\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  /**\n', '   * @dev Function to check manager status\n', '   * @param _manager address Manager`s address\n', '   * @return True if manager is enabled\n', '   */\n', '  function isManagerEnabled(\n', '    address _manager\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    returns (bool)\n', '  {\n', '    return managerEnabled[_manager];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check permissions of a manager\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager has been granted needed permission\n', '   */\n', '  function isPermissionGranted(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return managerPermissions[_manager][_permissionName];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check if the manager can perform the action or not\n', '   * @param _manager        address Manager`s address\n', '   * @param _permissionName string  Permission name\n', '   * @return True if manager is enabled and has been granted needed permission\n', '   */\n', '  function isManagerAllowed(\n', '    address _manager, string _permissionName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidManagerAddress(_manager)\n', '    onlyValidPermissionName(_permissionName)\n', '    returns (bool)\n', '  {\n', '    return (managerEnabled[_manager] && managerPermissions[_manager][_permissionName]);\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  /**\n', '   * @dev Modifier to check manager address\n', '   */\n', '  modifier onlyValidManagerAddress(address _manager) {\n', '    require(_manager != address(0x0));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to check name of manager permission\n', '   */\n', '  modifier onlyValidPermissionName(string _permissionName) {\n', '    require(bytes(_permissionName).length != 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title PausableInterface\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' * @dev Based on zeppelin&#39;s Pausable, but integrated with Manageable\n', ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract PausableInterface {\n', '\n', '  /**\n', '   * Events\n', '   */\n', '\n', '  event PauseEvent();\n', '  event UnpauseEvent();\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public;\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public;\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool);\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenContractNotPaused() {\n', '    require(getPaused() == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenContractPaused {\n', '    require(getPaused() == true);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' * @dev Based on zeppelin&#39;s Pausable, but integrated with Manageable\n', ' * @dev Contract is in paused state by default and should be explicitly unlocked\n', ' */\n', 'contract Pausable is ManageableInterface,\n', '                     PausableInterface {\n', '\n', '  /**\n', '   * Storage\n', '   */\n', '\n', '  bool paused = true;\n', '\n', '\n', '  /**\n', '   * @dev called by the manager to pause, triggers stopped state\n', '   */\n', '  function pauseContract() public onlyAllowedManager(&#39;pause_contract&#39;) whenContractNotPaused {\n', '    paused = true;\n', '    emit PauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the manager to unpause, returns to normal state\n', '   */\n', '  function unpauseContract() public onlyAllowedManager(&#39;unpause_contract&#39;) whenContractPaused {\n', '    paused = false;\n', '    emit UnpauseEvent();\n', '  }\n', '\n', '  /**\n', '   * @dev The getter for "paused" contract variable\n', '   */\n', '  function getPaused() public constant returns (bool) {\n', '    return paused;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BytecodeExecutorInterface interface\n', ' * @dev Implementation of a contract that execute any bytecode on behalf of the contract\n', ' * @dev Last resort for the immutable and not-replaceable contract :)\n', ' */\n', 'contract BytecodeExecutorInterface {\n', '\n', '  /* Events */\n', '\n', '  event CallExecutedEvent(address indexed target,\n', '                          uint256 suppliedGas,\n', '                          uint256 ethValue,\n', '                          bytes32 transactionBytecodeHash);\n', '  event DelegatecallExecutedEvent(address indexed target,\n', '                                  uint256 suppliedGas,\n', '                                  bytes32 transactionBytecodeHash);\n', '\n', '\n', '  /* Functions */\n', '\n', '  function executeCall(address _target, uint256 _suppliedGas, uint256 _ethValue, bytes _transactionBytecode) external;\n', '  function executeDelegatecall(address _target, uint256 _suppliedGas, bytes _transactionBytecode) external;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title BytecodeExecutor\n', ' * @dev Implementation of a contract that execute any bytecode on behalf of the contract\n', ' * @dev Last resort for the immutable and not-replaceable contract :)\n', ' */\n', 'contract BytecodeExecutor is ManageableInterface,\n', '                             BytecodeExecutorInterface {\n', '\n', '  /* Storage */\n', '\n', '  bool underExecution = false;\n', '\n', '\n', '  /* BytecodeExecutorInterface */\n', '\n', '  function executeCall(\n', '    address _target,\n', '    uint256 _suppliedGas,\n', '    uint256 _ethValue,\n', '    bytes _transactionBytecode\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;execute_call&#39;)\n', '  {\n', '    require(underExecution == false);\n', '\n', '    underExecution = true; // Avoid recursive calling\n', '    _target.call.gas(_suppliedGas).value(_ethValue)(_transactionBytecode);\n', '    underExecution = false;\n', '\n', '    emit CallExecutedEvent(_target, _suppliedGas, _ethValue, keccak256(_transactionBytecode));\n', '  }\n', '\n', '  function executeDelegatecall(\n', '    address _target,\n', '    uint256 _suppliedGas,\n', '    bytes _transactionBytecode\n', '  )\n', '    external\n', '    onlyAllowedManager(&#39;execute_delegatecall&#39;)\n', '  {\n', '    require(underExecution == false);\n', '\n', '    underExecution = true; // Avoid recursive calling\n', '    _target.delegatecall.gas(_suppliedGas)(_transactionBytecode);\n', '    underExecution = false;\n', '\n', '    emit DelegatecallExecutedEvent(_target, _suppliedGas, keccak256(_transactionBytecode));\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AssetIDInterface\n', ' * @dev Interface of a contract that assigned to an asset (JNT, JUSD etc.)\n', ' * @dev Contracts for the same asset (like JNT, JUSD etc.) will have the same AssetID.\n', ' * @dev This will help to avoid misconfiguration of contracts\n', ' */\n', 'contract AssetIDInterface {\n', '  function getAssetID() public constant returns (string);\n', '  function getAssetIDHash() public constant returns (bytes32);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AssetID\n', ' * @dev Base contract implementing AssetIDInterface\n', ' */\n', 'contract AssetID is AssetIDInterface {\n', '\n', '  /* Storage */\n', '\n', '  string assetID;\n', '\n', '\n', '  /* Constructor */\n', '\n', '  constructor (string _assetID) public {\n', '    require(bytes(_assetID).length > 0);\n', '\n', '    assetID = _assetID;\n', '  }\n', '\n', '\n', '  /* Getters */\n', '\n', '  function getAssetID() public constant returns (string) {\n', '    return assetID;\n', '  }\n', '\n', '  function getAssetIDHash() public constant returns (bytes32) {\n', '    return keccak256(assetID);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrLicenseRegistryInterface\n', ' * @dev Interface of the contract that stores licenses\n', ' */\n', 'contract CrydrLicenseRegistryInterface {\n', '\n', '  /**\n', '   * @dev Function to check licenses of investor\n', '   * @param _userAddress address User`s address\n', '   * @param _licenseName string  License name\n', '   * @return True if investor is admitted and has required license\n', '   */\n', '  function isUserAllowed(address _userAddress, string _licenseName) public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrLicenseRegistryManagementInterface\n', ' * @dev Interface of the contract that stores licenses\n', ' */\n', 'contract CrydrLicenseRegistryManagementInterface {\n', '\n', '  /* Events */\n', '\n', '  event UserAdmittedEvent(address indexed useraddress);\n', '  event UserDeniedEvent(address indexed useraddress);\n', '  event UserLicenseGrantedEvent(address indexed useraddress, bytes32 licensename);\n', '  event UserLicenseRenewedEvent(address indexed useraddress, bytes32 licensename);\n', '  event UserLicenseRevokedEvent(address indexed useraddress, bytes32 licensename);\n', '\n', '\n', '  /* Configuration */\n', '\n', '  /**\n', '   * @dev Function to admit user\n', '   * @param _userAddress address User`s address\n', '   */\n', '  function admitUser(address _userAddress) external;\n', '\n', '  /**\n', '   * @dev Function to deny user\n', '   * @param _userAddress address User`s address\n', '   */\n', '  function denyUser(address _userAddress) external;\n', '\n', '  /**\n', '   * @dev Function to check admittance of an user\n', '   * @param _userAddress address User`s address\n', '   * @return True if investor is in the registry and admitted\n', '   */\n', '  function isUserAdmitted(address _userAddress) public constant returns (bool);\n', '\n', '\n', '  /**\n', '   * @dev Function to grant license to an user\n', '   * @param _userAddress         address User`s address\n', '   * @param _licenseName         string  name of the license\n', '   */\n', '  function grantUserLicense(address _userAddress, string _licenseName) external;\n', '\n', '  /**\n', '   * @dev Function to revoke license from the user\n', '   * @param _userAddress address User`s address\n', '   * @param _licenseName string  name of the license\n', '   */\n', '  function revokeUserLicense(address _userAddress, string _licenseName) external;\n', '\n', '  /**\n', '   * @dev Function to check license of an investor\n', '   * @param _userAddress address User`s address\n', '   * @param _licenseName string  License name\n', '   * @return True if investor has been granted needed license\n', '   */\n', '  function isUserGranted(address _userAddress, string _licenseName) public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title CrydrLicenseRegistry\n', ' * @dev Contract that stores licenses\n', ' */\n', 'contract CrydrLicenseRegistry is ManageableInterface,\n', '                                 CrydrLicenseRegistryInterface,\n', '                                 CrydrLicenseRegistryManagementInterface {\n', '\n', '  /* Storage */\n', '\n', '  mapping (address => bool) userAdmittance;\n', '  mapping (address => mapping (string => bool)) userLicenses;\n', '\n', '\n', '  /* CrydrLicenseRegistryInterface */\n', '\n', '  function isUserAllowed(\n', '    address _userAddress, string _licenseName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidAddress(_userAddress)\n', '    onlyValidLicenseName(_licenseName)\n', '    returns (bool)\n', '  {\n', '    return userAdmittance[_userAddress] &&\n', '           userLicenses[_userAddress][_licenseName];\n', '  }\n', '\n', '\n', '  /* CrydrLicenseRegistryManagementInterface */\n', '\n', '  function admitUser(\n', '    address _userAddress\n', '  )\n', '    external\n', '    onlyValidAddress(_userAddress)\n', '    onlyAllowedManager(&#39;admit_user&#39;)\n', '  {\n', '    require(userAdmittance[_userAddress] == false);\n', '\n', '    userAdmittance[_userAddress] = true;\n', '\n', '    emit UserAdmittedEvent(_userAddress);\n', '  }\n', '\n', '  function denyUser(\n', '    address _userAddress\n', '  )\n', '    external\n', '    onlyValidAddress(_userAddress)\n', '    onlyAllowedManager(&#39;deny_user&#39;)\n', '  {\n', '    require(userAdmittance[_userAddress] == true);\n', '\n', '    userAdmittance[_userAddress] = false;\n', '\n', '    emit UserDeniedEvent(_userAddress);\n', '  }\n', '\n', '  function isUserAdmitted(\n', '    address _userAddress\n', '  )\n', '    public\n', '    constant\n', '    onlyValidAddress(_userAddress)\n', '    returns (bool)\n', '  {\n', '    return userAdmittance[_userAddress];\n', '  }\n', '\n', '\n', '  function grantUserLicense(\n', '    address _userAddress, string _licenseName\n', '  )\n', '    external\n', '    onlyValidAddress(_userAddress)\n', '    onlyValidLicenseName(_licenseName)\n', '    onlyAllowedManager(&#39;grant_license&#39;)\n', '  {\n', '    require(userLicenses[_userAddress][_licenseName] == false);\n', '\n', '    userLicenses[_userAddress][_licenseName] = true;\n', '\n', '    emit UserLicenseGrantedEvent(_userAddress, keccak256(_licenseName));\n', '  }\n', '\n', '  function revokeUserLicense(\n', '    address _userAddress, string _licenseName\n', '  )\n', '    external\n', '    onlyValidAddress(_userAddress)\n', '    onlyValidLicenseName(_licenseName)\n', '    onlyAllowedManager(&#39;revoke_license&#39;)\n', '  {\n', '    require(userLicenses[_userAddress][_licenseName] == true);\n', '\n', '    userLicenses[_userAddress][_licenseName] = false;\n', '\n', '    emit UserLicenseRevokedEvent(_userAddress, keccak256(_licenseName));\n', '  }\n', '\n', '  function isUserGranted(\n', '    address _userAddress, string _licenseName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidAddress(_userAddress)\n', '    onlyValidLicenseName(_licenseName)\n', '    returns (bool)\n', '  {\n', '    return userLicenses[_userAddress][_licenseName];\n', '  }\n', '\n', '  function isUserLicenseValid(\n', '    address _userAddress, string _licenseName\n', '  )\n', '    public\n', '    constant\n', '    onlyValidAddress(_userAddress)\n', '    onlyValidLicenseName(_licenseName)\n', '    returns (bool)\n', '  {\n', '    return userLicenses[_userAddress][_licenseName];\n', '  }\n', '\n', '\n', '  /* Helpers */\n', '\n', '  modifier onlyValidAddress(address _userAddress) {\n', '    require(_userAddress != address(0x0));\n', '    _;\n', '  }\n', '\n', '  modifier onlyValidLicenseName(string _licenseName) {\n', '    require(bytes(_licenseName).length > 0);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title JCashLicenseRegistry\n', ' * @dev Contract that stores licenses\n', ' */\n', 'contract JCashLicenseRegistry is AssetID,\n', '                                 Ownable,\n', '                                 Manageable,\n', '                                 Pausable,\n', '                                 BytecodeExecutor,\n', '                                 CrydrLicenseRegistry {\n', '\n', '  /* Constructor */\n', '\n', '  constructor (string _assetID) AssetID(_assetID) public { }\n', '}\n', '\n', '\n', '\n', 'contract JUSDLicenseRegistry is JCashLicenseRegistry {\n', '  constructor () public JCashLicenseRegistry(&#39;JUSD&#39;) {}\n', '}']